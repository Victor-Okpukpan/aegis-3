{
  "category": "Prediction Market",
  "total_findings": 83,
  "fetched_at": "2026-01-29T13:45:42Z",
  "findings": [
    {
      "id": "15970",
      "title": "The size calculation can be incorrect for large numbers",
      "impact": "LOW",
      "content": "## Context\n- ConsiderationEncoder.sol#L53-L63\n- ConsiderationConstants.sol#L113\n\n## Description\nThe maximum value of memory offset is defined in `PointerLibraries.sol#L22` as `OffsetOrLengthMask = 0xffffffff`, i.e., `2^32 - 1`. However, the mask `OnlyFullWordMask = 0xffffe0;` is defined to be a 24-bit number.\n\nAssume that the length of the `bytes` type where `srcpoints` is `0xffffe0`, then the following piece of code incorrectly computes the size as `0`.\n\n```solidity\nfunction abi_encode_bytes(\n    MemoryPointer src,\n    MemoryPointer dst\n) internal view returns (uint256 size) {\n    unchecked {\n        size = \n            ((src.readUint256() & OffsetOrLengthMask) + AlmostTwoWords) & \n            OnlyFullWordMask;\n        ...\n    }\n}\n```\n\nThis is because the constant `OnlyFullWordMask` does not have the two higher order bytes set (as a 32-bit type). \n\n**Note:** In practice, it can be difficult to construct `bytes` of length `0xffffe0` due to the upper bound defined by the block gas limit. However, this length is still below Seaport's `OffsetOrLengthMask`, and therefore may be able to evade many checks.\n\n## Recommendation\nChange the value of `OnlyFullWordMask` to `0xffffffe0`. But it does not fully fix this problem, as if `len >= 0xffffffc1`, the calculations can encounter the same issues. However, these numbers are impractical in the EVM and therefore may not be of concern.\n\nThere are two potential approaches to this:\n\n1. Revert early if length is `>= 0xffffffc1`. This is the value beyond which the `add(len, 63)` takes more than 32 bits.\n2. Assign a large value for the rounded up length for any values `>= 0xffffffc1`. `2**32 - 1` is a possibility.\n\nOption 1 would be consistent with Solidity generated code - revert early if the length is too large for specific operations.\n\n## Z3 Proof\nHere's the above Z3 proof with the extra constraint that length is below `0xffffffc1`. This is now unsatisfiable.\n\n```python\nfrom z3 import *\ndef AND(x, y):\n    return x & y\ndef ADD(x, y):\n    return x + y\n\nn_bits = 256\nsymb_len = BitVec('Len', n_bits)\nconst_OnlyFullWordMask = BitVecVal(0xffffffe0, n_bits)\nconst_AlmostTwoWords = BitVecVal(0x3f, n_bits)\nsolver = Solver()\n\n## The expression (for ConsiderationEncoder)\n## from https://github.com/ProjectOpenSea/seaport/pull/798/files\nexpr = AND(ADD(symb_len, const_AlmostTwoWords), const_OnlyFullWordMask)\n\n## Add an upper bound about the length\nsolver.add(ULT(symb_len, BitVecVal(0xffffffc1, n_bits)))\n\n## A model where the expression evaluates to a `value < 32 `. Such model is now unsatisfiable\nsolver.add(ULT(expr, BitVecVal(32, n_bits)))\nresult = solver.check()\n\nif result == sat:\n    print(\"SAT!\")\n    print(solver.model())\nelse:\n    print(result)\n```\n\n## References\n- Seaport: Partially addressed in PR 798.\n- Spearbit: Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15969",
      "title": "getOrderStatus and getContractOffererNonce are prone to view reentrancy",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Consideration.sol#L548\n- Consideration.sol#L607\n- OrderValidator.sol#L84-L87\n- OrderValidator.sol#L277-L280\n- OrderValidator.sol#L284-L287\n- OrderValidator.sol#L382\n\n## Description\nIn a Consideration or the Seaport contract, once `_orderStatus[orderHash]` or `_contractNonces[offerer]` gets updated, if there is a mix of contract offerer orders and partial orders are used, Seaport would call into the offerer contracts (let's call one of these offerer contracts **X**). In turn, **X** can be a contract that would call into other contracts (let's call them **Y**) that take into consideration `_orderStatus[orderHash]` or `_contractNonces[offerer]` in their codebase by calling `getOrderStatus` or `getContractOffererNonce`.\n\nThe values for `_orderStatus[orderHash]` or `_contractNonces[offerer]` might get updated after **Y** seeks those from Seaport due to, for example, multiple partial orders with the same `orderHash` or multiple offerer contract orders using the same offerer. Therefore, **Y** would only take into consideration the mid-flight values and not the final ones after the whole transaction with Seaport is completed.\n\n## Recommendation\nWe need to either make sure to update the storage parameters at the end of the call to Seaport's order fulfilling/matching endpoints (after all the calls to external contracts) or add `_assertNonReentrant()` guard to the `getOrderStatus` and `getContractOffererNonce` endpoints to avoid other contracts **Y** reading mid-flight storage parameters.\n\n## Seaport\nAcknowledged.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15968",
      "title": "Cross-Seaport re-entrancy with the stateful validateOrder call",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n`BasicOrderFulfiller.sol#L280`\n\n## Description\nThe re-entrancy check in Seaport 1.2 will prevent the Zone from interacting with Seaport 1.2 again. However, an interesting scenario arises when the conduit has open channels to both Seaport 1.1 and Seaport 1.2 (or different deployments/forks of Seaport 1.2). This can lead to cross-Seaport re-entrancy. \n\nThis is not immediately problematic, as Zones have limited functionality currently. But since Zones can be as flexible as possible, they need to be careful if they can interact with multiple versions of Seaport.\n\n**Note:** For Seaport 1.1's zone, the check `_assertRestrictedBasicOrderValidity` happens before the transfers, and it's also a static call. \n\nIn the future, Seaport 1.3 could also have the same zone interaction, i.e., stateful calls to zones, allowing for complex cross-Seaport re-entrancy between 1.2 and 1.3. \n\n**Note:** Also see `getOrderStatus` and `getContractOffererNonce`, which are prone to view reentrancy for concerns around view-only re-entrancy.\n\n## Recommendation\n- Document that cross-Seaport re-entrancy can be possible in general, and potentially problematic when paired with `_assertRestrictedBasicOrderValidity` / `validateOrder`, especially when the conduit has open channels with multiple versions of Seaport.\n- Avoid having open channels to both Seaport 1.1 and Seaport 1.2 at the same time, or between multiple versions of Seaport.\n- For Zones with complex logic, consider deploying a new Conduit and carefully assess the risk of opening new channels.\n\n## Acknowledgments\n**Seaport:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15967",
      "title": "In general a contract offerer or a zone cannot draw a conclusion accurately based on the spent offer amounts or received consideration amounts shared with them post-trasnfer",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ContractOffererInterface.sol#L7\n- ContractOffererInterface.sol#L16\n- ZoneInterface.sol#L13\n- ZoneInteraction.sol#L92\n\n## Description\nWhen one calls one of the Seaport endpoints that fulfills or matches a collection of (advanced) orders, the used offer or consideration items will go through different modification steps in the memory. In particular, the `startAmount` of these items is an important parameter to inspect:\n\n- `a`: original `startAmount` parameter shared to Seaport by the caller encoded in the memory.\n- `a0`: the interpolated value and for orders of CONTRACT order type it is the value returned by the contract offerer (interpolation does not have an effect in this case since the `startAmount` and `endAmount` are enforced to be equal).\n- `b`: must be 0 for used consideration items, otherwise the call would revert. For offer items, it can be in [0, 1) (See The spent offer item amounts shared with a zone for restricted (advanced) orders or with a contract offerer for orders of CONTRACT order type is not the actual spent amount in general).\n- `a0`: is the final amount shared by Seaport to either a zone for restricted orders and a contract offerer for CONTRACT order types.\n\n### Offer Items\nFor offer items, perhaps the zone or the contract offerer would like to check that the offerer has spent a maximum `a0` of that specific offer item. For the case of restricted orders where the zone's `validateOrder(...)` will be called, the offerer might end up spending more than `a0` amount of a specific token with the same identifier if the collection of orders includes:\n- A mix of open and restricted orders.\n- Multiple zones for the same offerer, offering the same token with the same identifier.\n- Multiple orders using the same zone. In this case, the zone might not have a sense of the orders of the transfers or which orders are included in the transaction in question (unless the contexts used by the zone enforce the exact ordering and number of items that can be matched/fulfilled in the same transaction).\n\nNote the order of transfers can be manipulated/engineered by constructing specific fulfillment data. Given a fulfillment data to combine/aggregate orders, there could be permutations of it that create different ordering of the executions.\n\n- An order with an actor (a consideration recipient, contract offerer, weird token, ...) that has approval to transfer this specific offer item for the offerer in question. And when Seaport calls into (NATIVE, ERC1155 token transfers, ...) this actor, the actor would transfer the token to a different address than the offerer.\n\nThere also is a special case where an order with the same offer item token and identifier is signed on a different instance of Seaport (1.0, 1.1, 1.2, ..., or other non-official versions) which an actor (a consideration recipient, contract offerer, weird token, ...) can cross-call into (related Cross-Seaport re-entrancy with the stateful `validateOrder` call).\n\nThe above issue can be avoided if the offerer makes sure to not sign different transactions across different or the same instances of Seaport which:\n1. Share the same offer type, offer token, and offer identifier,\n2. but differ in a mix of zone, and order type,\n3. can be active at a shared timestamp.\n\nAnd/or the offerer does not give untrusted parties their token approvals.\n\nA similar issue can arise for a contract offerer if they use a mix of signed orders of non-CONTRACT order type and CONTRACT order types.\n\n### Consideration Items\nFor consideration items, perhaps the zone or the contract offerer would like to check that the recipient of each consideration item has received a minimum of `a0` of that specific consideration item. This case also is similar to the offer items issues above when a mix of orders has been used.\n\n## Recommendation\nThe above issues and notes should be documented for the users. Document the decision for the current zone and contract offerer interaction patterns.\n\n**Seaport:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15966",
      "title": "When _contractNonces[offerer] gets updated no event is emitted",
      "impact": "LOW",
      "content": "## Security Audit Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `OrderValidator.sol#L382`\n- `CounterManager.sol#L54`\n\n## Description\nWhen `_contractNonces[offerer]` gets updated, no event is emitted. This is in contrast to when a counter is updated. \n\nOne might be able to extract the `_contractNonces[offerer]` (if it doesn't overflow 12 bytes to enter into the offerer region in the order hash) from a later event when `OrderFulfilled` gets emitted. `OrderFulfilled` only gets emitted for an order of CONTRACT type if the `generateOrder(...)`'s return data satisfies all the constraints.\n\n## Recommendation\nEmit a custom event when `_contractNonces[offerer]` gets updated if it's important for off-chain agents to monitor this value.\n\n## Acknowledgements\n- **Seaport**: Acknowledged.\n- **Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15965",
      "title": "OrderHash in the context of contract orders need not refer to a unique order",
      "impact": "LOW",
      "content": "## Order Validation Risk Assessment\n\n## Severity: Low Risk\n\n### Context\nOrderValidator.sol#L386\n\n### Description\nIn Seaport 1.1 and in Seaport 1.2 for non-contract orders, order hashes have a unique correspondence with the order, i.e., it can be used to identify the status of an order on-chain and track it. However, in the case of contract orders, this is not the case. It is simply the current nonce of the offerer, combined with the address. This cannot be used to uniquely track an order on-chain.\n\n```solidity\nuint256 contractNonce;\nunchecked {\n    contractNonce = _contractNonces[offerer]++;\n}\nassembly {\n    orderHash := or(contractNonce, shl(0x60, offerer))\n}\n```\n\n### Problematic Scenarios\n\n#### Scenario 1: Reverted Contract Order\nA reverted contract order and the adjacent succeeding contract order will have the same order hash, regardless of whether they correspond to the same order.\n1. Consider Alice calling `fulfilledAdvancedOrder` for a contract order with `offerer = X`, where X is a smart contract that offers contract orders on Seaport 1.2. Assume that this transaction failed because enough gas was not provided for the `generateOrder` call. This transaction would revert with a custom error `InvalidContractOrder`, generated from `OrderValidator.sol#L391`.\n2. Consider Bob calling `fulfilledAdvancedOrder` for a different contract order with `offerer = X`, the same smart contract offerer. This order will succeed and emit the `OrderFulfilled` event from `OrderFulfiller.sol#L124`.\n\nIn the above scenario, there are two different orders: one that reverted on-chain and the other that succeeded, both having the same `orderHash` despite the orders only sharing the same contract offerer -- the other parameters can be completely arbitrary.\n\n#### Scenario 2: Misleading Off-Chain Computed Hashes\nContract order hashes computed off-chain can be misleading.\n1. Consider Alice calling `fulfilledAdvancedOrder` for a contract order with `offerer = X`, where X is a smart contract that offers contract orders on Seaport 1.2. Alice computed the `orderHash` of their order off-chain by simulating the transaction, sends the transaction, and polls the `OrderFulfilled` event with the same `orderHash` to know if the order has been fulfilled.\n2. Consider Bob calling `fulfilledAdvancedOrder` for any contract order with `offerer = X`, the same smart contract offerer.\n3. Bob's transaction gets included first. An `OrderFulfilled` event is emitted, with the `orderHash` being the same hash that Alice computed off-chain! Alice may believe that their order succeeded.\n\n**Note:** For non-contract orders, the above approach would be valid, i.e., one may generate and sign an order, compute the order hash of an order off-chain, and poll for an `OrderFulfilled` with the order hash to know that it was fulfilled. \n\n**Note:** Even though there is an easier way to track if the order succeeded in these cases, in the general case, Alice or Bob need not be the one executing the orders on-chain. An off-chain agent may send misleading notifications to either party that their order succeeded due to this quirk with contract order hashes.\n\n### Recommendation\n1. Consider computing the order hash for contract orders similarly to how regular orders are hashed.\n2. If the same mechanism is maintained, document that using `orderHashes` as a unique identifier is not reliable.\n\n### Acknowledgments\n- Seaport: Acknowledged.\n- Spearbit: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15964",
      "title": "abi_decode_bytes does not mask the copied data length",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationDecoder.sol#L60\n\n## Description\nWhen `abi_decode_bytes` decodes bytes, it does not mask the copied length of the data in memory (other places where the length is masked by `OffsetOrLengthMask`).\n\n## Recommendation\nMake sure to also mask the copied length before saving it to the memory.\n\n## Seaport\nFixed in PR 823.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15963",
      "title": "When contractNonce occupies more than 12bytes the truncated nonce shared back with the contract offerer through ratifyOrder would be smaller than the actual stored nonce",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationEncoder.sol#L146\n- OrderValidator.sol#L385-L387\n\n## Description\nWhen `contractNonce` occupies more than 12 bytes, the truncated nonce shared back with the contract offerer through `ratifyOrder` would be smaller than the actual stored nonce:\n\n```solidity\n// Write contractNonce to calldata\ndstHead.offset(ratifyOrder_contractNonce_offset).write(\n    uint96(uint256(orderHash))\n);\n```\n\nThis is due to the way `contractNonce` and the offerer's address are mixed in the `orderHash`:\n\n```assembly\norderHash := or(contractNonce, shl(0x60, offerer))\n```\n\n## Recommendation\nOne can avoid the truncation by using XOR when calculating the `orderHash`:\n\n```assembly\norderHash := xor(contractNonce, offerer)\n```\n\nAnd sending the full `orderHash` to the contract offerer's `ratifyOrder` endpoint:\n\n```solidity\ndstHead.offset(ratifyOrder_contractNonce_offset).write(orderHash);\n```\n\nThe contract offerer can deduce the nonce by XORing its address with the received hash again:\n\n```solidity\nnonce := xor(orderHash, address())\n```\n\nThis would also make the calculations cheaper.\n\n## Seaport\nFixed in commit `f82012`.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15962",
      "title": "_isValidBulkOrderSize does not perform the signature length validation correctly.",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Verifiers.sol#L122-L125\n\n## Description\nIn `isValidBulkOrderSize`, the signature's length validation is performed as follows:\n\n```solidity\nlet length := mload(signature)\nvalidLength := and(\n    lt(length, BulkOrderProof_excessSize),\n    lt(and(sub(length, BulkOrderProof_minSize), AlmostOneWord), 2)\n)\n```\n\nThe `sub` opcode in the above snippet wraps around. If this was the correct formula, then it would actually simplify to:\n\n```solidity\nlt(and(sub(length, 3), AlmostOneWord), 2)\n```\n\nThe simplified and the current version would allow length to also be `3`, `4`, `35`, `36`, `67`, `68`, but `_isValidBulkOrderSize` actually needs to check that length (`l`) has the following form:\n\n```\nl = (64 + x) + 3 + 32y\n```\n\nwhere `x ∈ {0, 1}` and `y ∈ {1, 2, ..., 24}` (y represents the height/depth of the bulk order).\n\n## Recommendation\nModify the assembly block to reflect the constraints needed for the above formula:\n\n```solidity\nlet z := sub(mload(signature), BulkOrderProof_minSize)\nvalidLength := and(\n    lt(z, 738), // 738 = (1 + 32 * 23) + 1, named constant BulkOrderProof_rangeSize\n    lt(and(z, AlmostOneWord), 2)\n)\n```\n\n- Verification:\n  ```solidity\n  lt(sub(length, 99), 738)\n  ```\n  ```\n  l − 99 = l − (64 + 3 + 32) = x + 32(y − 1)  ≤ 1 + 32 * 23 = 737 < 738\n  ```\n  \nThis also takes care of underflows and we end up with a condition that `l ∈ {99, 100, ..., 836}`.\n\n```solidity\nlt(and(add(length, 29), 31), 2)\n```\n\n```\n(l + 0b11101) & 0b11111 ∈ {0, 1}\n```\n\ntranslates into `l + 29 ≡ 0, 1 (mod 32)` or `l ≡ 3, 4 (mod 32)` or `l − 99 ≡ 0, 1 (mod 32)` which enforces `l − 99` to be of a form `x + 32y0` where `x ∈ {0, 1}` and `y0 ∈ ℤ`.\n\nFrom the first part, we know that `l − 99 ∈ {0, 1, ..., 737}` and so that would restrict `y0` to be in `{0, 1, ..., 23}`. \n\nAnd so,\n\n```\nl = (64 + x) + 3 + 32(y0 + 1)  ∈ {67 + x, 68 + x, ..., 836}\n```\n\n## Spearbit\nThe solution mentioned above might be cheaper than PR 797 (depends on the stack juggling by the compiler).\n\n## Seaport\nLeaving it as-is for 1.2 as it's close either way.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15961",
      "title": "Calls to TypehashDirectory will be successful",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- TypehashDirectory.sol#L119\n\n## Description\nTypehashDirectory's deployed bytecode starts with `00`, which corresponds to the STOP opcode (SSTORE2 also uses this pattern). This choice for the 1st bytecode causes accidental calls to the contract to succeed silently.\n\n## Recommendation\nDocument the reason why STOP was used for the 1st opcode. If it's not necessary to have STOP as the first opcode, use an opcode that reverts calls to TypehashDirectory, as it is only used as a data storage contract.\n\n## Seaport\nFixed in PR 799.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15960",
      "title": "CriteriaResolvers.criteriaProof is not validated in the identifierOrCriteria == 0 case",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File**: `CriteriaResolution.sol`\n- **Lines**: 199-206\n\n## Description\nIn the case of `identifierOrCriteria == 0`, the criteria resolver completely skips any validations on the Merkle proof and, in particular, is missing the validation that `CriteriaResolvers.criteriaProof.length == 0`.\n\n**Note**: This issue is also present in Seaport 1.1 and may be a known issue.\n\n## Proof of Concept\nModified `test/advanced.spec.ts`:\n\n```diff\n@@ -3568,9 +3568,8 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n // Seller approves marketplace contract to transfer NFTs\n await set1155ApprovalForAll(seller, marketplaceContract.address, true);\n- const { root, proofs } = merkleTree([nftId]);\n- const offer = [getTestItem1155WithCriteria(root, toBN(1), toBN(1))];\n+ const offer = [getTestItem1155WithCriteria(toBN(0), toBN(1), toBN(1))];\n const consideration = [\n getItemETH(parseEther(\"10\"), parseEther(\"10\"), seller.address),\n @@ -3578,8 +3577,9 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n getItemETH(parseEther(\"1\"), parseEther(\"1\"), owner.address),\n ];\n+ // Add a junk criteria proof and the test still passes\n const criteriaResolvers = [\n- buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),\n+ buildResolver(0, 0, 0, nftId, [\"0xdead000000000000000000000000000000000000000000000000000000000000\"]),\n ];\n const { order, orderHash, value } = await createOrder(\n```\n\n## Recommendation\nConsider adding the following additional check in the modified `contracts/lib/CriteriaResolution.sol`:\n\n```diff\n@@ -203,6 +203,8 @@ contract CriteriaResolution is CriteriaResolutionErrors {\n identifierOrCriteria,\n criteriaResolver.criteriaProof\n );\n+ } else {\n+ require(criteriaResolver.criteriaProof.length == 0);\n }\n```\n\n## Seaport\nFixed in PR 825.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15959",
      "title": "Advance orders of CONTRACT order types can generate orders with different consideration recipients that would break the aggregation routine",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationDecoder.sol#L569-L574\n- FulfillmentApplier.sol#L722-L736\n\n## Description\nWhen Seaport receives a collection of advanced orders to match or fulfill, if one of the orders has a CONTRACT order type, Seaport calls the `generateOrder(...)` endpoint of that order's offerer. `generateOrder(...)` can provide new consideration item recipients for this order. These new recipients are going to be used for this order from this point on. \n\nIn `_getGeneratedOrder`, there is no comparison between old or new consideration recipients. The provided new recipients can create an issue when aggregating consideration items. Since the fulfillment data is provided beforehand by the caller of the Seaport endpoint, the caller might have provided fulfillment aggregation data that would have aggregated/combined one of the consideration items of this changed advance order with another consideration item. However, the aggregation had taken into consideration the original recipient of the order in question. \n\nMultiple consideration items can only be aggregated if they share the same `itemType`, `token`, `identifier`, and `recipient` (ref). The new recipients provided by the contract offerer can break this invariant and, in turn, cause a revert.\n\n## Recommendation\nEither:\n- The original consideration item recipients would need to be shared with the contract offerer when `generateOrder(...)` is called, and they would stay the same for the new consideration items. This way, the offerer can check these recipients and revert the call if needed. In this case, the caller of Seaport endpoints would need to somehow (perhaps using the `previewOrder` endpoint) get the recipients beforehand.\n- Ensure that the old and new consideration recipients are the same.\n\nAdditionally, if changes are not applied, consider documenting this scenario for the users you call into Seaport or create custom offerer contracts. Adding more comments/documentation for `previewOrder` endpoint and `generateOrder` is also recommended.\n\n## Seaport\nFixed in PR 824 which ensures that either the new recipient can be any address if the original was `address(0)` or the new and old consideration recipients have to match (otherwise the call would revert).\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15958",
      "title": "ABI decoding for bytes: memory can be corrupted by maliciously constructing the calldata",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity: \n**Medium Risk**\n\n## Context: \n`ConsiderationDecoder.sol#L51-L62`\n\n## Description: \nIn the code snippet below, `size` can be made `0` by maliciously crafting the calldata. In this case, the free memory is not incremented.\n\n```solidity\nassembly {\n    mPtrLength := mload(0x40)\n    let size := and(\n        add(\n            and(calldataload(cdPtrLength), OffsetOrLengthMask),\n            AlmostTwoWords\n        ),\n        OnlyFullWordMask\n    )\n    calldatacopy(mPtrLength, cdPtrLength, size)\n    mstore(0x40, add(mPtrLength, size))\n}\n```\n\nThis has two different consequences:\n1. If the memory offset `mPtrLength` is immediately used, then junk values at that memory location can be interpreted as the decoded bytes type. In the case of Seaport 1.2, the likelihood of the current free memory pointing to junk value is low. So, this case has low severity.\n2. The consequent memory allocation will also use the value `mPtrLength` to store data in memory. This can lead to corrupting the initial memory data. In the worst case, the next allocation can be tuned so that the first bytes data can be any arbitrary data.\n\n### Steps to Make the Size Calculation Return 0:\n1. Find a function call which has `bytes` as a (nested) parameter.\n2. Modify the calldata field where the length of the above byte is stored to the new length `0xffffe0`.\n3. The calculation will now return `size = 0`.\n\n**Note:** There is an additional requirement that this `bytes` type should be inside a dynamic struct. Otherwise, for example, in the case of `function foo(bytes calldata signature)`, the compiler will insert a check that calldata-size is big enough to fit `signature.length`. Since the value `0xffffe0` is too big to fit into calldata, such an attack is impractical.\n\nHowever, for `bytes` type inside a dynamic type, for example in `function foo(bytes[] calldata signature)`, this check is skipped by `solc` (likely because it's expensive). For a practical exploit, we need to look for such a function. In the case of Seaport 1.2, this could be the `matchAdvancedOrders(AdvancedOrder[] calldata orders, ...)` function. The struct `AdvancedOrder` has a nested parameter `bytes signature` as well as `bytes extraData`.\n\nIn the above exploit, one would be able to maliciously modify the calldata in such a way that Seaport would interpret the data in `extraData` as the `signature`. Here is a proof of concept for a simplified case that showcases injecting an arbitrary value into a decoded bytes.\n\nAs for severity, even though interpreting calldata differently may not fundamentally break the protocol, an attacker with enough effort may be able to use this for subtle phishing attacks or as a precursor to other attacks.\n\n## Recommendation: \nUpdating `OnlyFullWordMask` to `0xff_ff_ff_e0` will not fix this as you can still replace `len` by `0xff_ff_ff_e0` and get the same effect. Also see **The size calculation can be incorrect for large numbers**.\n\n## Seaport: \nFixed in PR 789.\n\n## Spearbit: \nVerified.",
      "summary": "\nThis bug report pertains to the code snippet in ConsiderationDecoder.sol#L51-L62, which could be exploited to make the size calculation return 0. This could be done by maliciously crafting the calldata to modify the length of a bytes parameter inside a dynamic struct. This could lead to corrupting the initial memory data, and in the worst case, the next allocation can be tuned to contain arbitrary data. Even though this exploit may not fundamentally break the protocol, it could be used for subtle phishing attacks or as a precursor to other attacks. The bug was fixed in Seaport PR 789, and Spearbit verified the fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "ABI Encoding"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15957",
      "title": "Calls to PausableZone 'sexecuteMatchAdvancedOrders and executeMatchOrders would revert if unused native tokens would need to be returned",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- PausableZone.sol#L34\n- PausableZone.sol#L149\n- PausableZone.sol#L188\n- OrderCombiner.sol#L704-L707\n\n## Description\nIn match (advanced) orders, one can provide native tokens as offer and consideration items. So, a PausableZone would need to provide msg.value to call the corresponding Seaport endpoints. There are a few scenarios where not all the msg.value native tokens amount provided to the Seaport marketplace will be used:\n\n1. Rounding errors in calculating the current amount of offer or consideration items. The zone can prevent sending extra native tokens to Seaport by pre-calculating these values and making sure to have its transaction to be included in the specific block that these values were calculated for (this is important when the start and end amount of an item are not equal).\n2. The zone (un)intentionally sends more native tokens than are necessary to Seaport.\n3. The (advanced) orders sent for matching in Seaport include order type of CONTRACT offerer order and the offerer contract provides a different amount for at least one item that would eventually make the whole transaction not use the full amount of msg.value provided to it.\n\nIn all these cases, since PausableZone does not have a receive or fallback endpoint to accept native tokens, when Seaport tries to send back the unused native token amount, the transaction may revert.\n\n### PausableZone not accepting native tokens:\n```bash\n$ export CODE=$(jq -r '.deployedBytecode' artifacts/contracts/zones/PausableZone.sol/PausableZone.json | tr -d '\\n')\n$ evm --code $CODE --value 1 --prestate genesis.json --sender 0xb4d0000000000000000000000000000000000000 --nomemory=false --debug run\n$ evm --input $(echo $CODE | head -c 44 - | sed -E s/0x//) disasm\n```\n\n```\n6080806040526004908136101561001557600080fd\n...\n```\n\n#### TRACE\n```plaintext\nPUSH1 pc=00000000 gas=4700000 cost=3\nDUP1 pc=00000002 gas=4699997 cost=3\n...\n```\n\n#### LOGS\n```json\ngenesis.json : {\n  \"gasLimit\": \"4700000\",\n  \"difficulty\": \"1\",\n  \"alloc\": {\n    \"0xb4d0000000000000000000000000000000000000\": {\n      \"balance\": \"10000000000000000000000000\",\n      \"code\": \"\",\n      \"storage\": {}\n    }\n  }\n}\n```\n\n```typescript\n// file: test/zone.spec.ts\n...\nit(\"Fulfills an order with executeMatchAdvancedOrders with NATIVE Consideration Item\", async () => {\n  const pausableZoneControllerFactory = await ethers.getContractFactory(\n    \"PausableZoneController\",\n    owner\n  );\n  const pausableZoneController = await pausableZoneControllerFactory.deploy(\n    owner.address\n  );\n  // Deploy pausable zone\n  const zoneAddr = await createZone(pausableZoneController);\n  ...\n});\n...\n```\n\nThis bug also applies to Seaport 1.1 and PausableZone (0x004C00500000aD104D7DBd00e3ae0A5C00560C00)\n\n## Recommendation\nIt is really important for zones that are trying to match orders that involve native tokens to be able to receive those tokens back from Seaport if all of them are not used. In the case of Solidity contracts, one should define receive or fallback endpoints for these contracts (or the __default__ function if using Vyper).\n\n**Seaport:** Acknowledged.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nA bug has been reported in the PausableZone (0x004C00500000aD104D7DBd00e3ae0A5C00560C00 ) and Seaport 1.1 which affects the matching of orders that include native tokens. In these cases, the PausableZone does not have a receive orfallback endpoint to accept native tokens, so when Seaport tries to send back the unsued native token amount the transaction may revert. \n\nThis bug can be caused by a few scenarios where not all the msg.value native tokens amount provided to the Seaport marketplace will be used. These scenarios include rounding errors, the zone (un)intentionally sending more native tokens than necessary, and the (advanced) orders sent for matching in Seaport include order type of CONTRACT offerer order and the offerer contract provides different amount for at least one item.\n\nIn order to prevent this bug, it is important for zones that are trying to match orders that would involve native tokens to be able to receive those tokens back from Seaport if all of them are not used. In case of Solidity contracts, one should define receive orfallback endpoints for these contracts (or the __default__ function if using Vyper).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Refund Ether",
        "DOS"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15956",
      "title": "AdvancedOrder.numerator and AdvancedOrder.denominator are unchecked for orders of CONTRACT order type",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n### Severity: Medium Risk\n\n### Context\n- `OrderValidator.sol#L150-L153`\n- `OrderCombiner.sol#L455-L463`\n\n### Description\nFor most advanced order types, we have the following check:\n\n```solidity\n// Read numerator and denominator from memory and place on the stack.\nuint256 numerator = uint256(advancedOrder.numerator);\nuint256 denominator = uint256(advancedOrder.denominator);\n// Ensure that the supplied numerator and denominator are valid.\nif (numerator > denominator || numerator == 0) {\n    _revertBadFraction();\n}\n```\n\nFor `CONTRACT` order types, this check is skipped. For later calculations (calculating the current amount), Seaport uses the numerator and denominator returned by `_getGeneratedOrder`, which as a pair is either `(1, 1)` or `(0, 0)`. \n\n`advancedOrder.numerator` is only used to skip certain operations in some loops when it is `0`:\n- Skip applying criteria resolvers.\n- Skip aggregating the amount for executions.\n- Skip the final validity check.\n\nSkipping the above operations would make sense. However, when for an `advancedOrder` with `CONTRACT` order type `_getGeneratedOrder` returns `(h, 1, 1)` and `advancedOrder.numerator == 0`, we would:\n- Skip applying criteria resolvers\n- Aggregate the amounts from offer or consideration amounts for this order\n- Skip the final validity check that would call into the `ratifyOrder` endpoint of the offerer. \n\nBut emitting the following `OrderFulfilled` will not be skipped, even though this `advancedOrder` will not be used:\n\n```solidity\n// Emit an OrderFulfilled event.\n_emitOrderFulfilledEvent(\n    orderHash,\n    orderParameters.offerer,\n    orderParameters.zone,\n    recipient,\n    orderParameters.offer,\n    orderParameters.consideration\n);\n```\n\nThis can create discrepancies between what happens on-chain and what off-chain agents index/record.\n\n### Recommendation\nEven though `AdvancedOrder.numerator` and `AdvancedOrder.denominator` are not really used for advanced orders of `CONTRACT` type, and `AdvancedOrder.numerator` is only used for signaling certain decisions in the call, it would be best to either hoist the checks regarding these parameters to an earlier point:\n\n```solidity\n// Read numerator and denominator from memory and place on the stack.\nuint256 numerator = uint256(advancedOrder.numerator);\nuint256 denominator = uint256(advancedOrder.denominator);\n// Ensure that the supplied numerator and denominator are valid.\nif (numerator > denominator || numerator == 0) {\n    _revertBadFraction();\n}\n// If the order is a contract order, return the generated order.\nif (orderParameters.orderType == OrderType.CONTRACT) {\n    // Return the generated order based on the order params and the\n    // provided extra data. If revertOnInvalid is true, the function\n    // will revert if the input is invalid.\n    return _getGeneratedOrder(\n        orderParameters,\n        advancedOrder.extraData,\n        revertOnInvalid\n    );\n}\n```\n\nOr for `orderParameters.orderType == OrderType.CONTRACT`, enforce that `advancedOrder.numerator == advancedOrder.denominator == 1`.\n\n### Additional Notes\n- **Seaport**: Fixed in PR 815.\n- **Spearbit**: Verified.",
      "summary": "\nThis bug report is about a check that is skipped when an advanced order of type CONTRACT is used. The check is supposed to ensure that the numerator and denominator provided are valid. This can create discrepancies between what happens on chain and what off-chain agents index/record. The recommendation is to either hoist the checks regarding these parameters to an earlier point in the code or enforce that the numerator and denominator are both equal to 1. The bug has been fixed in a pull request and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15955",
      "title": "Advance orders of CONTRACT order types can generate orders with less consideration items that would break the aggregation routine",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **OrderValidator.sol**: Lines 444-447\n- **FulfillmentApplier.sol**: Lines 561-569\n\n## Description\nWhen Seaport gets a collection of advanced orders to fulfill or match, if one of the orders has a `CONTRACT` order type, Seaport calls the `generateOrder(...)` endpoint of that order's offerer. `generateOrder(...)` can provide fewer consideration items for this order. So, the total number of consideration items might be less than the ones provided by the caller.\n\nSince the caller would need to provide the fulfillment data beforehand to Seaport, they might use indices that would turn out to be out of range for the consideration in question after the modification applied for the contract offerer above. If this happens, the whole call will be reverted.\n\nThis issue is in the same category as advance orders of `CONTRACT` order types that can generate orders with different consideration recipients, which would break the aggregation routine.\n\n## Recommendation\nIn order for the caller to be able to fulfill/match orders by figuring out how to aggregate and match different consideration and offer items, they would need to have access to all the data before calling into Seaport. Contract offerers are supposed to (though it is not enforced currently) implement `previewOrder`, which the caller can use before making a call to Seaport. However, there is no guarantee that the data returned by `previewOrder` and `generateOrder` for the same shared inputs would be the same.\n\nWe can enforce that the contract offerer does not return fewer consideration items. If it needs to return less, it can either revert or provide a 0 amount.\n\nIf the current conditions are going to stay the same, it is recommended to document this scenario and also provide more comments/documentation for `ContractOffererInterface`.\n\n## Seaport\nAddressed in PR 842.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about an issue with the Seaport service when it receives an advanced order with a CONTRACT order type. The caller provides the fulfillment data to Seaport, but when the contract offerer generates the order, it might provide fewer consideration items than the caller provided. This would cause the call to be reverted and the aggregation routine to break.\n\nTo address this issue, it is recommended to enforce that the contract offerer does not return fewer consideration items. If it needs to return less, it can either revert or provide a 0 amount. Additionally, more comments/documentation should be provided for ContractOffererInterface. Seaport has addressed the issue in PR 842 and it has been verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15954",
      "title": "Empty criteriaResolvers for criteria-based contract orders",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- OrderValidator.sol#L312-L315\n- CriteriaResolution.sol#L119\n\n## Description\nThere is a deviation in how criteria-based items are resolved for contract orders. For contract orders which have offers with criteria, the `_compareItems` function checks that the contract offerer returned a corresponding non-criteria based `itemType` when `identifierOrCriteria` for the original item is 0, i.e., offering from an entire collection. Afterwards, the `orderParameters.offer` array is replaced by the offer array returned by the contract offerer.\n\nFor other criteria-based orders such as offers with `identifierOrCriteria = 0`, the `itemType` of the order is only updated during the criteria resolution step. This means that for such offers there should be a corresponding `CriteriaResolver` struct. See the following test:\n\n```diff\nmodified test/advanced.spec.ts\n@@ -3568,9 +3568,8 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n // Seller approves marketplace contract to transfer NFTs\n await set1155ApprovalForAll(seller, marketplaceContract.address, true);\n- const { root, proofs } = merkleTree([nftId]);\n- const offer = [getTestItem1155WithCriteria(root, toBN(1), toBN(1))];\n+ const offer = [getTestItem1155WithCriteria(toBN(0), toBN(1), toBN(1))];\n const consideration = [\n getItemETH(parseEther(\"10\"), parseEther(\"10\"), seller.address),\n@@ -3578,8 +3577,9 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n getItemETH(parseEther(\"1\"), parseEther(\"1\"), owner.address),\n ];\n+ // Replacing by `const criteriaResolvers = [] `will revert\n const criteriaResolvers = [\n- buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),\n+ buildResolver(0, 0, 0, nftId, []),\n ];\n const { order, orderHash, value } = await createOrder(\n```\n\nHowever, in case of contract offers with `identifierOrCriteria = 0`, Seaport 1.2 does not expect a corresponding `CriteriaResolver` struct and will revert if one is provided as the `itemType` was updated to be the corresponding non-criteria based `itemType`. See `advanced.spec.ts#L510` for a test case.\n\n**Note:** This also means that the fulfiller cannot explicitly provide the identifier when a contract order is being fulfilled. A malicious contract may use this to their advantage. For example, assume that a contract offerer in Seaport only accepts criteria-based offers. The fulfiller may first call `previewOrder` where the criteria is always resolved to a rare NFT, but the actual execution would return an uninteresting NFT. If such offers also required a corresponding resolver (similar behavior as regular criteria-based orders), then this could be fixed by explicitly providing the identifier — akin to a slippage check.\n\nIn short, for regular criteria-based orders with `identifierOrCriteria = 0`, the fulfiller can pick which identifier to receive by providing a `CriteriaResolver` (as long as it's valid). For contract orders, fulfillers don't have this option and contracts may be able to abuse this.\n\n## Recommendation\nAn alternative approach to criteria-based contract orders would be to remove the extra case in `_compareItems`. Now, contract offers will have to return the same `itemType` and `identifierOrCriteria` when an `agenerateOrder` call is made. However, this means that the fulfiller will be able to choose the identifier it wants to receive. This may not be ideal in some cases, but it remains consistent with regular orders.\n\n**Seaport:** We documented this deviation in PR 849.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about a deviation in how criteria-based items are resolved for contract orders in the OrderValidator.sol and CriteriaResolution.sol files. The _compareItems function checks that the contract offerer has returned a corresponding non-criteria based itemType when identifierOrCriteria for the original item is 0. The orderParameters.offer array is then replaced by the offer array returned by the contract offerer. \n\nFor other criteria-based orders such as offers with identifierOrCriteria = 0, the itemType of the order is only updated during the criteria resolution step, which should have a corresponding CriteriaResolver struct. However, for contract offers with identifierOrCriteria = 0, Seaport 1.2 does not expect a corresponding CriteriaResolver struct and will revert if one is provided as the itemType was updated to be the corresponding non-criteria based itemType. This means that the fulfiller cannot explicitly provide the identifier when a contract order is being fulfilled, which a malicious contract may use to their advantage.\n\nThe recommendation is to remove the extra case in_compareItems, which would mean that contract offers will have to return the same itemType and identifierOrCriteria when a generateOrder call is made. This would allow the fulfiller to choose the identifier it wants to receive, although this may not be ideal in some cases. Seaport has documented this deviation in PR 849 and Spearbit has verified it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15953",
      "title": "The spent offer item amounts shared with a zone for restricted (advanced) orders or with a contract offerer for orders of CONTRACT order type is not the actual spent amount in general",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `OrderCombiner.sol#L802-L807`\n- `ConsiderationEncoder.sol#L440-L443`\n- `ZoneInterface.sol#L13-L15`\n- `ContractOffererInterface.sol#L16-L22`\n- `OrderCombiner.sol#L322-L325`\n- `FulfillmentApplier.sol#L299-L306`\n- `FulfillmentApplier.sol#L432-L433`\n- `FulfillmentApplier.sol#L120-L125`\n- `OrderCombiner.sol#L794-L798`\n\n## Description\nWhen Seaport is called to fulfill or match a collection of (advanced) orders, there are scenarios where not all offer items will be used. When not all the current amount of an offer item is used and if this offer item belongs to an order which is of either CONTRACT order type or it is a restricted order (and the caller is not the zone), then the spent amount shared with either the contract offerer or zone through their respective endpoints (`validateOrder` for zones and `ratifyOrder` for contract offerers) does not reflect the actual amount spent.\n\nWhen Seaport is called through one of its more complex endpoints to match or fulfill orders, the offer items go through a few phases:\n\n- **Parameter Description**\n  - `It` - item type\n  - `T` - token\n  - `i` - identifier\n  - `as` - start amount\n  - `ae` - end amount\n  - `acurr` - the interpolation of startAmount and endAmount depending on the time and the fraction of the order.\n  - `O` - offer item.\n\nAssuming an offer item is originally `O = (It, T, i, as, ae)`:\n- In `_validateOrdersAndPrepareToFulfill`, `O` gets transformed into `(It, T, i, acurr, acurr)`\n- Then, depending on whether the order is part of a match (1, 2, 3) or fulfillment (1, 2) order and whether there is corresponding fulfillment data pointing at this offer item, it might transform into `(It, T, i, b, acurr)` where `b ∈ [0, 1)`. For fulfilling a collection of orders, `b ∈ {0, acurr}` depending on whether the offer item gets used or not, but for match orders, it can be in the more general range of `b ∈ [0, 1)`.\n- Finally, for restricted or CONTRACT order types, before calling `_assertRestrictedAdvancedOrderValidity`, the offer item would be transformed into `(It, T, i, acurr, acurr)`.\n\nSo the start amount of an offer item goes through the following flow:\n`as → acurr → b ∈ [0, 1) → acurr`\n\nAt the end, `acurr` is the amount used when Seaport calls into the `validateOrder` of a zone or `ratifyOrder` of a contract offerer. `acurr` does not reflect the actual amount that this offer item has contributed to a combined amount used for an execution transfer.\n\n## Recommendation\nFor non-matched collections of (advanced) orders, the actual spent amount for an offer item is `acurr * b ∈ {0, acurr}`, which reflects whether the item has been used or not. \n\nFor these two Seaport endpoints (`fulfillAvailableOrders`, `fulfillAvailableAdvancedOrders`), one can calculate the actual spent amount. For example, at the end of the flow for `startAmount`, one can do:\n\n```solidity\n// Utilize assembly to calculate the spent amount.\nassembly {\n    let startAmountPtr := add(offerItem, Common_amount_offset)\n    let originalAmount := mload(add(offerItem, Common_endAmount_offset))\n    let unusedAmount := mload(startAmountPtr)\n    mstore(\n        startAmountPtr,\n        sub(originalAmount, unusedAmount)\n    )\n}\n```\n\nFor matched orders, since in certain scenarios, `b` can be any number in `B256`, it would be hard to say how much of that particular offer item was spent or not spent. Thus, the above suggestion would not work in general for matched orders.\n\n### Seaport\nFixed in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by the `msg.sender`.\n\n### Spearbit\nVerified.",
      "summary": "\nThis bug report is about an issue with the Seaport platform, which is used to match and fulfill orders. The problem is that when not all of the current amount of an offer item is used, the amount shared with either the contract offerer or zone through their respective endpoints does not reflect the actual amount spent. This is because the offer item's start amount goes through a transformation process and the end amount, acurr, does not reflect the actual amount spent.\n\nTo fix this issue, Seaport proposed a solution in PR 839 where all unspent offer amounts are transferred to the recipient provided by the msg.sender. This was verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15952",
      "title": "The spent offer amounts provided to OrderFulfilled for collection of (advanced) orders is not the actual amount spent in general",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **OrderCombiner.sol**: Lines 455-463\n- **OrderFulfiller.sol**: Lines 377-385\n\n## Description\nWhen Seaport is called to fulfill or match a collection of (advanced) orders, the `OrderFulfilled` is called before applying fulfillments and executing transfers. The offer and consideration items have the following forms:\n\n- **C** = (It, T, i, acurr, R, acurr)  \n- **O** = (It, T, i, acurr, acurr)  \n\n### Parameter Description\n| Parameter | Description                                                        |\n|-----------|--------------------------------------------------------------------|\n| It        | itemType                                                          |\n| T         | token                                                             |\n| i         | identifier                                                        |\n| acurr     | the interpolation of startAmount and endAmount depending on the time and the fraction of the order. |\n| R         | consideration item's recipient                                      |\n| O         | offer item.                                                       |\n| C         | consideration item.                                               |\n\nThe `SpentItem` and `ReceivedItem` items provided to the `OrderFulfilled` event ignore the last component of the offer/consideration items in the above form since they are redundant.\n\nSeaport enforces that all consideration items are used. But for the endpoints in this context, we might end up with offer items with only a portion of their amounts being spent. So in the end, `O.acurr` might not be the amount spent for this offer item, but `OrderFulfilled` emits `O.acurr` as the amount spent. This can cause discrepancies in off-chain bookkeeping by agents listening for this event.\n\nThe `fulfillOrder` and `fulfillAdvancedOrder` do not have this issue, since all items are enforced to be used. These two endpoints also differ from when there are collections of (advanced) orders, in that they would emit the `OrderFulfilled` at the end of their call before clearing the reentrancy guard.\n\n## Recommendation\nMake sure the accounting is updated to only provide the spent offer item amounts to `OrderFulfilled`. Moving the emission of this event to the end of the call flow, before clearing the reentrancy guard, like the aforementioned simpler endpoint would make it easier to provide the correct values. This approach would also make the whole flow between different endpoints more consistent and potentially create an opportunity to refactor the codebase further.\n\n## Seaport \nFixed in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by `msg.sender`.\n\n## Spearbit \nVerified.",
      "summary": "\nThis bug report is about a discrepancy in off-chain bookkeeping by agents listening to the OrderFulfilled event. The problem occurs when Seaport is called to fulfill or match a collection of (advanced) orders. The offer and consideration items have certain forms and the SpentItem and ReceivedItem items provided to the OrderFulfilled event ignore the last component of the offer/consideration items. This causes discrepancies in off-chain bookkeeping because the OrderFulfilled event emits O.acurr as the amount spent, which might not be the actual amount spent for the offer item.\n\nThe recommendation was to make sure the accounting is updated to only provide the spent offer item amounts to OrderFulfilled. Moving the emission of this event to the end of the call flow before clearing the reentrancy guard would make it easier to provide the correct values and make the whole flow between different endpoints more consistent.\n\nSeaport fixed the issue in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by the msg.sender. Spearbit verified the fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "13597",
      "title": "ERC20 tokens with no return value will fail to transfer ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed using OpenZeppelin’s SafeERC20.\n\n\n#### Description\n\n\nAlthough the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard.\n\n\nIn that case, the `.transfer()` call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.\n\n\n**code/contracts/ExchangeDeposit.sol:L229-L231**\n\n\n\n```\nif (!instance.transfer(getSendAddress(), forwarderBalance)) {\n    revert('Could not gather ERC20');\n}\n\n```\n#### Recommendation\n\n\nConsider using [OpenZeppelin’s SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol).",
      "summary": "\nThis bug report is about a problem that can occur when transferring ERC20 tokens. The ERC20 standard suggests that a transfer should return `true` on success, however, some tokens are non-compliant in this regard. When this happens, the `.transfer()` call can revert even if the transfer is successful. To fix this issue, OpenZeppelin’s SafeERC20 was used. SafeERC20 is a smart contract library that provides a safe version of the ERC20 token standard. It allows for transfers to be made in a secure and reliable way. To avoid this issue in the future, it is recommended to use OpenZeppelin’s SafeERC20.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "bitbank",
      "source_link": "https://consensys.net/diligence/audits/2020/11/bitbank/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Nicholas Ward",
        "John Mardlin"
      ]
    },
    {
      "id": "11541",
      "title": "[L20] Outdated test coverage report",
      "impact": "LOW",
      "content": "The [test coverage report](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#coverage-report) has not been updated for Augur Core v2 code base. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.\n\n\nConsider updating the test coverage report, and making it reach at least 95% of the source code.\n\n\n***Update****: fixed in* [*`88e7aa0`*](https://github.com/AugurProject/augur/commit/88e7aa0bafb98520bc0efb8d2d54a335c2acc6bc) *by revamping the entire test coverage setup.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11540",
      "title": "[L19] Outdated and inaccurate README file",
      "impact": "LOW",
      "content": "The [README.md](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/README.md) file in the augur-core repository is out of date and inaccurate. It does not reflect the v2 changes, some of the suggested commands do not work, and the build is failing. In particular, some of the identified issues are:\n\n\n* The [“Source code organization”](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#source-code-organization) section is missing the `legacy_reputation` folder.\n* In the [“Docker — Test” subsection](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#docker) there is a link pointing to [Augur’s old, deprecated repository](https://github.com/AugurProject/augur-core). This is the same in the [“Worst-case-loss for trades”](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#worst-case-loss-escrow-for-trades) section.\n* The Reporting flow diagram mentioned in [“Reporting diagrams”](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#reporting-diagrams) is outdated.\n* There are [instructions](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#running-oyente) to run [Oyente](https://github.com/melonproject/oyente), a smart contract analysis tool that has not been updated in more than a year and is unclear if it works properly with Solidity +0.5. According to the Oyente’s output when run with a test contract: *“The latest supported version is 0.4.19”*.\n* The list of files and folders in the [“Tests” section](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#tests) is clearly outdated, with many inconsistencies (*e.g.* `delegation_sandbox.py` and `test_mutex.py` are listed but do not exist in [the](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/tests) [`tests`](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/tests) [folder](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/tests)).\n* [The coverage report](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core#coverage-report) is outdated and the suggested command does not work.\n\n\nREADME files on the root of git repositories are the first documents that most developers often read, so they should be complete, clear, concise and accurate. To define the structure and contents of this file, consider following [Standard Readme](https://github.com/RichardLitt/standard-readme). Furthermore, it is highly advisable to include instructions for the [responsible disclosure](https://en.wikipedia.org/wiki/Responsible_disclosure) of any security vulnerabilities found in the project.\n\n\n***Update****: fixed in* [*`c629b50`*](https://github.com/AugurProject/augur/commit/c629b5069b89d5596f9f876eb222b454b07edac7) *by updating the README file where appropriate.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11539",
      "title": "[L18] Undocumented assembly blocks",
      "impact": "LOW",
      "content": "The `CloneFactory` contract in `CloneFactory.sol` includes a function `createClone` with [an assembly block](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/CloneFactory.sol#L9). Even though the function is taken from [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167) where the functionality is documented, assembly is a low-level language that is harder to parse by readers. Consider including extensive inline documentation clearly explaining what every single assembly instruction does. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it. Note that the use of assembly discards several important safety features of Solidity, which may render the code less safe and more error-prone. Hence, consider implementing thorough tests to cover all potential use cases of the `createClone` function to ensure it behaves as expected.\n\n\n***Update:*** *fixed in* [*`fe274f5`*](https://github.com/AugurProject/augur/commit/fe274f5fcf623c97355b051d2db212d47e22ce72) *by adding explanatory inline comments for each assembly instruction.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11538",
      "title": "[L17] Not using safe arithmetic operations",
      "impact": "LOW",
      "content": "Several arithmetic operations in the code base are not using the available `SafeMathUint256` and `SafeMathInt256` libraries that would prevent arithmetic issues. See for example [line 455 in](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L455) [`Market.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L455), line [147 in](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L147) [`Universe.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L147) or lines [245](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/Orders.sol#L245), [246](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/Orders.sol#L246), [249](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/Orders.sol#L249) and [250](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/Orders.sol#L250) in `Orders.sol`.\n\n\nWhile this issue does not pose a security risk, as no exploitable overflows or underflows were detected in the current implementation, this may not hold true in future changes to the code base if unit testing is not effectively covering all cases.\n\n\nGiven that arithmetic operations on integers may overflow / underflow silently, causing bugs, consider using the existing `SafeMathUint256` and `SafeMathInt256` libraries for all arithmetic operations. Unit tests to ensure correct behavior are of utmost importance in cases where safe arithmetic operations are not used in favor of gas efficiency.\n\n\n***Update****: fixed in* [*`b138335`*](https://github.com/AugurProject/augur/commit/b138335a73206a10d2d371da8849a1597dd2e552) *for all of instances of the issue that we pointed out as examples.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11537",
      "title": "[L16] Multiple getters for the same state variable",
      "impact": "LOW",
      "content": "Several contracts in the Augur code base contain multiple public getter functions for the same state variable. For example:\n\n\n* In the [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol), there are multiple getter functions that return the token’s total supply. Namely,[`supply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L16) (automatically generated by Solidity) and[totalSupply](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L31).\n* In the[`Augur`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol), there are multiple getter functions that get the contract registered with a given key. Namely,[`registry`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L78) (automatically generated by Solidity) and[`lookup`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103).\n\n\nTo favor encapsulation and explicitness, ensure that there is at most one publicly exposed getter for each contract state variable.\n\n\n***Update****: fixed in* [*`66745b6`*](https://github.com/AugurProject/augur/pull/2603/commits/66745b6af1a503a23a73c21bcc32186573d3d8ab) *by restricting the visibility of* *`supply`* *and* *`registry`**.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11536",
      "title": "[L15] Multiple unused return values",
      "impact": "LOW",
      "content": "In multiple locations in the Augur code base, there are private and internal functions that return boolean values indicating the function’s success. However, the functions often either revert or return true and their return values are not checked. Many public functions in the Augur code base also follow this pattern but the Augur team clarified that the return values of the public functions are intended for off-chain systems. Consider removing any unnecessary return values to avoid confusion about their intended purpose.\n\n\n***Update****: Fixed in* [*`2921365`*](https://github.com/AugurProject/augur/pull/2577/commits/292136502dba869a484a6b70bd1c42d101e4bc32) *by removing several unused return values.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11535",
      "title": "[L14] Inconsistent use of afterInitialized modifier in contracts",
      "impact": "LOW",
      "content": "Several contracts in Augur’s code base are intended to be deployed behind the [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167) minimal proxy contract. Therefore, to be able to replace the `constructor` function, they all inherit functionality from the [`Initializable`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Initializable.sol) contract. It provides two modifiers [`beforeInitialized`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Initializable.sol#L13) and [`afterInitialized`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Initializable.sol#L8), which are used to allow / deny access to a function based on the [`initialized`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Initializable.sol#L6) boolean flag, which can be toggled to `true` (and never be set back to `false`) by calling the internal [`endInitialization`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Initializable.sol#L18) function.\n\n\nAn inconsistent use of the `afterInitialized` modifier was found throughout Augur’s contracts. Where in many contracts `afterInitialized` seems to be correctly used to label every function that can only be called *after* initialization (*e.g.* in [`DisputeWindow`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeWindow.sol)), in other contracts (*e.g.* [`Market`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol)) the `afterInitialized` modifier is never used.\n\n\nConsider making the necessary changes in the contracts to consistently use the `afterInitialized` modifier, adding related unit tests that prevent developers from reintroducing this kind of issues. Thorough testing is in order should the development team decide to remove the `afterInitialized` modifier from all functions in contracts that are deployed through factories (which call the implementation’s `initialize` function), so as to ensure behavior is not affected and security not compromised in any sense.\n\n\n***Update****: fixed in* [*`aff5118`*](https://github.com/AugurProject/augur/commit/aff51185371b552b186a2a1a47767fb7cc124b87) *by removing all* *`afterInitialized`* *modifiers.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11534",
      "title": "[L13] Outdated ReentrancyGuard contract in use",
      "impact": "LOW",
      "content": "The [`ReentrancyGuard`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ReentrancyGuard.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ReentrancyGuard.sol) currently in use is out of date. While its [`nonReentrant`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ReentrancyGuard.sol#L19) [modifier](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ReentrancyGuard.sol#L19) works as expected, consider updating the contract to the [latest version](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.3.0/contracts/utils/ReentrancyGuard.sol) in order to benefit from an optimized gas usage for small transactions. Refer to [OpenZeppelin’s issue #1056](https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056) for more details about such gas savings.\n\n\n***Update****: the Augur team decided not to implement our recommendation because the latest version of the* *`ReentrancyGuard`* *contract has an additional local variable which causes stack depth issues in some of their contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11533",
      "title": "[L12] Unnecessary code repetition in CompleteSets contract",
      "impact": "LOW",
      "content": "The `CompleteSets` contract includes the functions [`publicSellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L69) and [`publicSellCompleteSetsWithCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L76), which implement the exact same logic, both calling the [`sellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83). Similarly, the functions [`publicBuyCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L35) and [`publicBuyCompleteSetsWithCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L42) also behave the same, in this case calling the [`buyCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L49) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L49). Therefore, so as to favor simplicity, avoid confusions and reduce the code’s attack surface, consider removing one in each pair functions.\n\n\n***Update****: fixed in* [*`ebed2db`*](https://github.com/AugurProject/augur/commit/edeb2d90bf5b3f8b8906a4190b924dd25560c980) *by removing the* *`publicSellCompleteSetsWithCash`* *and* *`publicBuyCompleteSetsWithCash`* *functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11532",
      "title": "[L11] Unnecessary code repetition in Auction contract",
      "impact": "LOW",
      "content": "The `Auction` contract implements the functions [`getAuctionStartTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L231) and [`getAuctionEndTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L239), which implement the exact same logic except for [line 244](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L244). Therefore, to favor simplicity and modularization, consider factoring out the repeated logic into a private function.\n\n\n***Update****: this issue is no longer valid as the* *`Auction`* *contract has been removed in* [*`f641c42`*](https://github.com/AugurProject/augur/commit/f641c42c47ca22d73e1e4184f6a5bb6e387e0630)*.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11531",
      "title": "[L10] Current Market owner may not receive no-show bond after initial report",
      "impact": "LOW",
      "content": "All market creators stake a no-show bond (paid in REP tokens) upon creating a market, which is to be automatically returned if the designated reporter reports a tentative outcome within the first 24 hours after the [market’s end time](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L46). When a `Market` is [initialized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L63), the `owner` and `repBondOwner` state variables (the first one inherited from the [`Ownable`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol)) are set to the market creator’s address (see [lines 78 and 79](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L78-L79)).\n\n\nIn a scenario where the ownership of a market has been transferred by calling the [`transferOwnership`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol#L39) function and the designated reporter effectively shows up, the no-show bond is going to be still [transferred back to the original owner of the market](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L151), tracked in the `repBondOwner` state variable, and not to the current owner of the market. This behavior is inconsistent with what occurs in the [`InitialReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol), where the stake received after the initial report is [awarded to the current owner](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L32) of the contract, and not to the original (*i.e.* the [actual reporter](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L46-L47)).\n\n\nShould this be the system’s expected behavior, consider explicitly documenting such sensitive scenarios to raise end-user awareness. Adding related unit tests to increase coverage is advisable too.\n\n\n***Update****: fixed in* [*`142ed41`*](https://github.com/AugurProject/augur/commit/142ed4113a9773e9ebc9adc525f65c0800ed9446) *by adding a new* *`transferRepBondOwnership`* *function that must be called manually by the address in* *`repBondOwner`* *to transfer the ownership of the REP bond. However, the added function does not emit an event to notify off-chain clients of such sensitive change.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11530",
      "title": "[L09] System relies on off-chain clients calling unrestricted functions to stay up-to-date",
      "impact": "LOW",
      "content": "The Augur system relies on off-chain clients to call unrestricted functions in order to update and sync system parameters. In particular, public functions whose purpose is to update state, like [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) and [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) may be dangerous if called at an unexpected time. If the contract relies on a certain state during various stages of execution, having these functions available to be called by anyone may result in an undesired state change that may render the system inconsistent or vulnerable to an attack. Consequences of this issue can be seen in **“[C08] Fork reputation goal threshold can be decreased during fork”** or **“[L08] Getter for REP total theoretical supply may be inaccurate”**.\n\n\nConsider removing any state variables used to store dynamically calculated values such as `totalTheoreticalSupply` in the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) and `forkReputationGoal` and `disputeThresholdForFork` in the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79). Instead, access these values through getter functions that recalculate the values as needed. This will guarantee they are up to date and accurate and remove any dependencies on off-chain systems.\n\n\n***Update****:* *fixed in* [*`48744d6`*](https://github.com/AugurProject/augur/commit/48744d6948c017dff747cf58e9efba2b6681b43e) *by removing the* *`totalTheoreticalSupply`* *state variable from the* *`ReputationToken`* *contract and modifying the* *`getTotalTheoreticalSupply`* *to recalculate and return the updated value of the total theoretical supply of REP tokens every time it is called.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11529",
      "title": "[L08] Getter for REP total theoretical supply may be inaccurate",
      "impact": "LOW",
      "content": "The `ReputationToken` contract implements the [`getTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L164) [public getter function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L164) to retrieve the value of the token’s [totalTheoreticalSuppy](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L24). While the `totalTheoreticalSuppy` is a [fixed value in the genesis universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L154-L155), it is [variable in a child universe whose parent universe fork is already finished](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L156-L157). However, for the `totalTheoreticalSupply` to change, the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) must be manually called. Therefore, if the total supply of REP tokens has changed over a period of time during which the `updateTotalTheoreticalSupply` function was never called, the value returned by the `getTotalTheoreticalSupply` function will be outdated and potentially inaccurate.\n\n\nConsider implementing a more general approach to always keep in sync the `totalTheoreticalSupply` with the total supply of REP tokens in a child universe whose parent’s fork has already finished, as described in the reported **“[L09] System relies on off-chain clients calling unrestricted functions to stay up-to-date”** issue. For this case in particular, the `updateTotalTheoreticalSupply` function could be called before returning the `totalTheoreticalSupply` inside the `getTotalTheoreticalSupply` function.\n\n\n***Update****: fixed in* [*`48744d6`*](https://github.com/AugurProject/augur/commit/48744d6948c017dff747cf58e9efba2b6681b43e) *. The* *`getTotalTheoreticalSupply`* *function now calculates and returns the updated value of the total theoretical supply of REP tokens.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11528",
      "title": "[L07] REP token allows migration of legacy tokens after universe fork",
      "impact": "LOW",
      "content": "The `ReputationToken` contract implements the [`migrateFromLegacyReputationToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L183) function that allows users to migrate [legacy reputation tokens](https://docs.augur.net/#legacy-rep) in. However, there is no validation in place to prevent this migration from occurring in a REP token whose universe has forked and that fork has already finished.\n\n\nTo prevent unexpected locking and loss of tokens, consider implementing the necessary validations in the `migrateFromLegacyReputationToken` function to ensure no legacy tokens can be migrated to a REP token of a locked universe whose fork period has finished.\n\n\n***Update****: this has been identified as a non-issue by the Augur team, since even after a fork users should be able to migrate to the Genesis universe. Yet, our report led the Augur team to uncover a serious vulnerability which we included in this report, for the sake of completeness and transparency, in the new* ***“[H06] Legacy REP tokens can be migrated to child universes”*** *issue.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11527",
      "title": "[L06] LegacyReputationToken’s decimals public getter does not return uint8",
      "impact": "LOW",
      "content": "The [ERC20](https://eips.ethereum.org/EIPS/eip-20#decimals) specification specifies an optional getter for the token’s `decimals`, which must return a `uint8` type. While the [`LegacyReputationToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/LegacyReputationToken.sol#L12) [does implement this getter](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/LegacyReputationToken.sol#L12), it returns a `uint256` instead. Consider changing it to `uint8` to be fully ERC20 compliant. If `uint256` was used intentionally to match the currently deployed REP token implementation, consider thoroughly documenting that reasoning.\n\n\n***Update****: fixed in* [*`43a8d57`*](https://github.com/AugurProject/augur/commit/43a8d5736cb68c86f187c47b210e81490391cffa) *. Now the* *`decimals`* *public getter returns a* *`uint8`* *type.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11526",
      "title": "[L05] Redundant Mint and Burn events in VariableSupplyToken contract",
      "impact": "LOW",
      "content": "In the `VariableSupplyToken` contract, consider reusing the [`Burned`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29-L30) [and](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29-L30) [`Minted`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29-L30) [events](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29-L30) inherited from the `ERC777Token` contract, thus removing the defined [`Burn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L11) and [`Mint`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L10) events.\n\n\n***Update****: fixed in* [*`484e3ac`*](https://github.com/AugurProject/augur/commit/484e3ac8c3ae077797941d763ac2fc80dabf4161) *. The* *`Burn`* *and* *`Mint`* *events in the* *`VariableSupplyToken`* *have been removed and the* *`burn`* *and* *`mint`* *functions now call the inherited* *`_mint`* *and* *`_burn`* *functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11525",
      "title": "[L04] Externally-owned accounts can be registered as contracts in the Augur contract",
      "impact": "LOW",
      "content": "The [`registerContract`>](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L90) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L90) in the `Augur` contract is a privileged function (only [called by the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L91) [`uploader`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L91) [`address`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L91)) in charge of registering contract addresses in the [`registry`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L93) [`mapping`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L93), by associating the address with a given `key`. However, while the function is only intended to register contract addresses, there is currently no validation on whether the address provided is either a contract or an externally-owned account.\n\n\nWhile this issue does not pose a security risk, consider using the [`exists`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ContractExists.sol#L6) [function of the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ContractExists.sol#L6) [`ContractExists`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ContractExists.sol#L6) [utility library](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ContractExists.sol#L6) to ensure the address being registered is indeed a contract.\n\n\n***Update****: fixed in* [*`eb10e94`*](https://github.com/AugurProject/augur/commit/eb10e94592d1c9b58fe61c9716fc9cfa61d2069c) *by using the* *`exists`* *function to validate the address being registered is indeed a contract.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11524",
      "title": "[L03] The Cash contract should not be an ERC777 token",
      "impact": "LOW",
      "content": "The [`Cash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Cash.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Cash.sol) inherits from the [`VariableSupplyToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol) which is an [ERC777](https://eips.ethereum.org/EIPS/eip-777) token (although with several major deviations, as reported in **“[H01] Implementation of EIP 777 does not fully match the specification”**). Augur’s contracts are built to be able to use any ERC20 token (such as DAI) as the “Cash token”, which is used for trading as well as other purposes. Should the Cash token be implemented as an ERC777 token in production, it would potentially render other Augur contracts vulnerable to serious unexpected exploits such as reentrancy and denial of service attacks. Therefore, consider removing all ERC777 functionality from the `Cash` contract to avoid any unexpected behaviors, clearly documenting that the Cash token should not implement ERC777-related features, but only ERC20.\n\n\n***Update****: fixed in* [*`c0ad321`*](https://github.com/AugurProject/augur/commit/c0ad321e7cd514a72ed3f086be2f1bb06c23afa3) *by turning the* *`Cash`* *contract into an ERC20.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11523",
      "title": "[L02] Use of magic constants",
      "impact": "LOW",
      "content": "There are several occurrences of magic constants in the Augur code base, an issue deeply related with what is being reported in **“[M03] Undocumented mathematical operations to compute Augur payouts”**. These values make the code harder to understand and to maintain.\n\n\nThe following is a non-extensive list of some locations in the code where magic constants can be found:\n\n\n* [Line 73](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L73) in `ReputationToken.sol`\n* [Line 216](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L216) and [228](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L228) in `Market.sol`\n* [Lines 81 to 84](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L81-L84), [444 to 445](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L444-L445), [451 to 452](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L451-L452) and [460](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L460) in `Universe.sol`\n\n\nConsider defining a constant variable for every magic constant (including booleans), giving it a clear and self-explanatory name. For complex values, or in cases where defining a constant variable does not seem appropriate, consider adding an inline comment explaining how they were calculated or why they were chosen. All of this will allow for added readability, easing maintenance.\n\n\n***Update****: fixed in* [*`fe4ccb2`*](https://github.com/AugurProject/augur/commit/fe4ccb29175ef63657f86b11dd6c4ca341f1c0ae) *by defining new constant state variables and adding explanatory inline comments in the* *`Universe`* *and* *`Reporting`* *contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11522",
      "title": "[L01] Lookup key strings are not centrally defined",
      "impact": "LOW",
      "content": "Known Augur contracts are tracked in the [`registry`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L78) [`mapping`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L78) of the `Augur` contract. New entries can be added by a privileged address via the [`registerContract`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L90) function, and the [`lookup`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103) function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of legitimate Augur contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are: `\"ReputationTokenFactory\"`, `\"AuctionFactory\"`, `\"MarketFactory\"`, `\"DisputeWindowFactory\"`, `\"CompleteSets\"`, `\"UniverseFactory\"`, `\"CreateOrder\"`, `\"CancelOrder\"`, `\"FillOrder\"`, `\"Trade\"`, `\"ClaimTradingProceeds\"`, `\"Orders\"`, `\"Time\"`, `\"Cash\"`, `\"ProfitLoss\"`, `\"Map\"`, `\"Market\"` and `\"ShareToken\"`.\n\n\nThis issue does not pose a security risk, but the approach taken is very error-prone and difficult to maintain. Therefore, consider factoring out all mentioned constant strings to a single library, which can be then imported in the necessary contracts. This will ease maintenance and make the code more resilient to future changes.\n\n\n***Update****: the Augur team decided not to move forward with our recommendation, arguing that centrally defining the constants would add unnecessary complexity and some additional gas costs related to the resulting size of the contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11521",
      "title": "[M09] Calls to sellCompleteSets function in FillOrder contract can be unexpectedly reverted",
      "impact": "MEDIUM",
      "content": "In the [`CompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol), the [`sellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) is used to burn a complete set of outcome tokens in exchange for the underlying CASH token for a given market. This function is used by the `FillOrder` contract’s [`fillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [when the parameter](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405) [`_ignoreShares`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405) [is set to false](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405).\n\n\nThe `sellCompleteSets` function, in [line 100](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L100) of `CompleteSets.sol`, calls the [`destroyShares`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L48) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L48) which then calls the `VariableSupplyToken` contract’s [`burn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L22) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L22), that in turn calls the [`ERC777`](https://eips.ethereum.org/EIPS/eip-777) [hook](https://eips.ethereum.org/EIPS/eip-777) on the `_sender` if the `_sender` is an ERC820-registered contract. This can be leveraged by a malicious `_sender` by reverting transactions when `sellCompleteSets` is called. This includes any calls to the [`fillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) when the `_ignoreShares` parameter is set to false.\n\n\nConsider not calling the ERC777 token hooks when outcome tokens are burned by the `sellCompleteSets` function. This will eliminate the risk of a malicious party unexpectedly reverting transactions.\n\n\n***Update****: Fixed in* [*`c6eed38`*](https://github.com/AugurProject/augur/commit/c6eed38e36d2ca6f11d26175df05d9284e830936) *. The call to the* *`VariableSupplyToken`* *contract’s* *`burn`* *function no longer triggers the ERC777 hook.*",
      "summary": "\nThis bug report is about the `sellCompleteSets` function in the `CompleteSets.sol` contract, which is used by the `FillOrder` contract’s `fillOrder` function when the parameter `_ignoreShares` is set to false. This function is used to burn a complete set of outcome tokens in exchange for the underlying CASH token for a given market.\n\nThe `sellCompleteSets` function calls the `destroyShares` function which then calls the `VariableSupplyToken` contract’s `burn` function. This `burn` function calls the ERC777 hook on the `_sender` if the `_sender` is an ERC820-registered contract. This can be leveraged by a malicious `_sender` by reverting transactions when `sellCompleteSets` is called, including any calls to the `fillOrder` function when the `_ignoreShares` parameter is set to false.\n\nThe issue has been fixed in `c6eed38` by no longer triggering the ERC777 hook when the `VariableSupplyToken` contract’s `burn` function is called. This eliminates the risk of a malicious party unexpectedly reverting transactions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11520",
      "title": "[M08] Factories may unexpectedly fail to create proxies",
      "impact": "MEDIUM",
      "content": "Augur’s [factories](https://github.com/AugurProject/augur/tree/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories) are [`CloneFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/CloneFactory.sol) contracts in charge of creating clones of minimal proxies (following [EIP 1167](https://eips.ethereum.org/EIPS/eip-1167)). The target addresses of such proxies are queried from the `Augur` contract by calling its [`lookup`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103) with a particular key.\n\n\nA problem may arise when a key has not been registered in the `Augur` contract, since the `lookup` function always defaults to return the zero address in such case. This address will then be set as the target address of the created minimal proxy, which will therefore attempt to delegate all calls to the zero address. After wrapping the proxy with the corresponding interface, all factories call the target’s `initialize` function and expect a boolean value in return. As this value will *not* be present in the data returned by the proxy’s target contract, the transaction will be unexpectedly reverted without a clear nor informative reason.\n\n\nConsider implementing, in all factories, the necessary validations on the address returned by the [`lookup`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L103) to make sure it is different from the zero address, thus avoiding unexpected failures in Augur’s factories.\n\n\n***Update****: The Augur team decided not to move forward with our recommendation, since the transaction is reverted when calling the* *`initialize`* *function on a clone that points to the zero address.*",
      "summary": "\nThis bug report is about Augur's factories, which are CloneFactory contracts responsible for creating clones of minimal proxies. The target address of these proxies is queried from the Augur contract by calling its lookup function with a particular key. The problem is that if a key has not been registered in the Augur contract, the lookup function defaults to return the zero address, which will then be set as the target address of the created minimal proxy. When the proxy is wrapped with the corresponding interface and the target's initialize function is called, the transaction is unexpectedly reverted without a clear nor informative reason.\n\nThe Augur team was recommended to implement validations on the address returned by the lookup function to make sure it is different from the zero address, but they decided not to move forward with this recommendation as the transaction is reverted when calling the initialize function on a clone that points to the zero address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11519",
      "title": "[M07] Unchecked return value in Ownable contract",
      "impact": "MEDIUM",
      "content": "In the [`Ownable`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol)‘s [`transferOwnership`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol#L39) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol#L39), the abstract internal function [`onTransferOwnership`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/Ownable.sol#L48) is called but the boolean value it returns is never checked. Hence, if a subclass of `Ownable` were to return `false` from `onTransferOwnership` to prevent ownership transfers, all transfers would still succeed.\n\n\nIn the Augur code base, there are no contracts currently using `onTransferOwnership` to prevent ownership transfers. Yet, it is advisable to either check the return value in a `require` statement (to prevent introducing issues in future changes) or remove the return boolean value altogether.\n\n\n*Update: fixed in* [*`5bc7904`*](https://github.com/AugurProject/augur/commit/5bc7904b257d40d8ceeb941d1ce66dff879fce0a) *. The internal* *`onTransferOwnership`* *function no longer returns a boolean flag.*",
      "summary": "\nThis bug report concerns the Augur code base. The `Ownable` contract has a `transferOwnership` function which calls an abstract internal function called `onTransferOwnership`. This function returns a boolean value, but this value is never checked. This means that if a subclass of `Ownable` were to return `false` from `onTransferOwnership` to prevent ownership transfers, all transfers would still succeed. \n\nTo prevent any issues arising in the future, it is recommended to check the return value in a `require` statement, or to remove the return boolean value altogether. The bug has now been fixed in the commit `5bc7904b257d40d8ceeb941d1ce66dff879fce0a`, and the internal `onTransferOwnership` function no longer returns a boolean flag.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11518",
      "title": "[M06] Lack of event emission when market’s dispute phase starts pacing on",
      "impact": "MEDIUM",
      "content": "Following what is stated in Augur’s whitepaper, if a market’s tentative outcome is disputed with a bond greater than 0.02% of all REP but less than 2.5% of all REP, then the market enters the waiting for next fee window to begin phase, before undergoing another dispute round. The purpose of this is simply to slow down the dispute process as the bonds get larger, therefore giving honest participants more time to crowdfund the larger dispute bond.\n\n\nThe `Market` contract implements such behavior [toggling a boolean flag called](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L207) [`disputePacingOn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L207), which once set to `true`, will [prevent further contributions](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L161) to the market’s current tentative outcome. However, the `Market` contract never emits an event in such scenario.\n\n\nConsidering how important and sensitive this stage in a market’s dispute phase is, consider defining and emitting an event in order to effectively notify off-chain clients about it.\n\n\n***Update****: fixed in* [*`27be8c5`*](https://github.com/AugurProject/augur/commit/27be8c54fecc5f9518cb86264771bf18387a8504) *. The* *`DisputeCrowdsourcerCompleted`* *event now logs a flag that indicates whether the market’s dispute phase is pacing on.*",
      "summary": "\nThis bug report is about the Augur's whitepaper which states that if a market's tentative outcome is disputed with a bond greater than 0.02% of all REP but less than 2.5% of all REP, then the market enters the waiting for next fee window to begin phase, before undergoing another dispute round. This is to slow down the dispute process as the bonds get larger, giving honest participants more time to crowdfund the larger dispute bond. However, the `Market` contract never emits an event in such a scenario. To address this issue, developers added the `DisputeCrowdsourcerCompleted` event which logs a flag that indicates whether the market’s dispute phase is pacing on. This event will effectively notify off-chain clients about it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11517",
      "title": "[M05] Lack of input validation",
      "impact": "MEDIUM",
      "content": "Several functions in the Augur code base lack explicit checks of user-controlled parameters. While this practice is often used as a way to reduce gas costs, under no circumstances should the lack of input validation undermine security nor functionality. Some examples of issues of varying severity that steam from unsanitized input are **“[C01] All CASH tokens approved to Augur can be emptied”**, **“[L04] Externally-owned accounts can be registered as contracts in the Augur contract”** or even **“[M08] Factories may unexpectedly fail to create proxies”**.\n\n\nConsider implementing [require statements](https://solidity.readthedocs.io/en/v0.5.4/control-structures.html?#error-handling-assert-require-revert-and-exceptions) where appropriate to validate all user-controlled input. Including clear user-friendly error messages (as reported in **“[M02] Missing error messages in require statements”**) is highly recommended as well.\n\n\n***Update****: input validation has been implemented across a* [*series of commits*](https://github.com/AugurProject/augur/pull/2603/commits)*.*",
      "summary": "\nThe Augur code base is missing explicit checks of user-controlled parameters, which can lead to security and functionality issues. Examples of these issues include when all CASH tokens approved to Augur can be emptied, when externally-owned accounts can be registered as contracts in the Augur contract, and when factories may unexpectedly fail to create proxies. To prevent these issues, require statements should be implemented to validate all user-controlled input, and clear user-friendly error messages should be included. This has since been implemented across a series of commits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11516",
      "title": "[M04] Undocumented REP price auction mechanism",
      "impact": "MEDIUM",
      "content": "The [`Auction`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol), together with the [`AuctionToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/AuctionToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/AuctionToken.sol), implement the logic behind the built-in auction-based REP price oracle introduced in Augur Core v2. Although the logic appears to be fairly straightforward, no detailed documentation (apart from the unit tests) was found regarding how the auction is expected to work. The lack of explicit explanations about the functions’ intended behavior and the rationale behind arithmetic operations (observed throughout the entire Augur code base, as more generally described in **“[M01] Missing docstrings throughout”** and **“[M03] Undocumented mathematical operations to compute Augur payouts”**) prevent us from thoroughly assessing the correctness and security of these important mechanisms that will govern the REP price in the future.\n\n\nConsider thoroughly documenting the entire REP price auction mechanism, both in docstrings and external end-user documentation. This should greatly add to the project’s maintainability and transparency, helping future developers, users and auditors evaluate the code’s level of security and correctness.\n\n\n***Update****: fixed by removing th* *`Auction`* *contract in* [*`f641c42`*](https://github.com/AugurProject/augur/commit/f641c42c47ca22d73e1e4184f6a5bb6e387e0630) *.*",
      "summary": "\nThis bug report is about the lack of documentation for the Auction and AuctionToken contracts that are part of Augur Core v2. The contracts are responsible for implementing the logic behind the built-in auction-based REP price oracle. Without detailed documentation, it is difficult to assess the correctness and security of the mechanisms that will govern the REP price in the future. \n\nThe bug was fixed by removing the Auction contract in the commit f641c42c47ca22d73e1e4184f6a5bb6e387e0630. To ensure the security and correctness of the REP price in the future, it is suggested that the entire REP price auction mechanism be documented both in docstrings and external end-user documentation. This will help future developers, users, and auditors evaluate the code and maintain the project's transparency.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11515",
      "title": "[M03] Undocumented mathematical operations to compute Augur payouts",
      "impact": "MEDIUM",
      "content": "The Augur platform relies on a number of complex economic incentives to effectively align users’ behavior, thus preventing misuse and attacks on the system. Such incentives are mostly based on stakes and fees that users and stakeholders deposit and receive in several different scenarios. Intending to make the platform as transparent as possible, the Augur team has implemented most of the calculations for fees, bonds, stakes and payouts in their smart contracts. However, such sensitive operations were found to be undocumented, rendering them extremely hard to follow and understand. Refer to the reported issues **“[M01] Missing docstrings throughout”** and **“[L02] Use of magic constants”** for related problems.\n\n\nWhile attempts to map all calculations spread throughout the code base to the Augur’s in-progress v2 whitepaper were made, still the manual process was unreliable and error-prone. Assessing for correctness becomes difficult when there is no way to straightforwardly understand the intentions behind each calculation, regardless of their simplicity.\n\n\nSome examples of this issue can be found in:\n\n\n* `Market.sol`: lines [216](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L216), [278](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L278) and [343](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L343)\n* `Universe.sol`: lines [83 to 84](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L83-L84), [324](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L324) and calculations in functions [`getOrCacheValidityBond`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L327) , [`getOrCacheDesignatedReportStake`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L342) and [`getOrCacheDesignatedReportNoShowBond`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L358)\n* `DisputeCrowdsourcer.sol`: line [81](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L81) and several calculations made in the [`redeem`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L35) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L35)\n* `AuctionToken.sol`: line [46](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/AuctionToken.sol#L46)\n* `Auction.sol`: line [101](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L101), lines [203 to 205](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L203-L205)\n\n\nConsider thoroughly documenting all sensitive calculations made in the code base, making explicit the rationale behind them where appropriate. As a starting point, this can be done in inline comments and docstrings; although it is highly advisable to include references to external more-detailed end-user documentation for v2 once it is ready. All of this will greatly improve the readability of the code, which should add to the platform’s transparency and the users’ overall experience.\n\n\n***Update****: fixed across a* [*series of commits*](https://github.com/AugurProject/augur/pull/2603/commits)*.*",
      "summary": "\nThe Augur platform relies on complex economic incentives to align user behavior and prevent misuse. The Augur team has implemented many of these calculations in their smart contracts, but they were found to be undocumented. This made it difficult to understand the intentions behind each calculation, making it difficult to assess their correctness. As a result, the Augur team has proposed thoroughly documenting all sensitive calculations made in the code base. This will improve the readability of the code and add to the platform's transparency and the users' overall experience. This issue has been fixed across a series of commits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11514",
      "title": "[M02] Missing error messages in require statements",
      "impact": "MEDIUM",
      "content": "Most `require` statements in Augur contracts are lacking error messages. Consider including specific and informative error messages in all require statements, as they greatly improve code readability, making the code base more self-explanatory.\n\n\n***Update****: partially fixed across a* [*series of commits*](https://github.com/AugurProject/augur/pull/2603/commits)*.*",
      "summary": "\nA bug report was filed concerning the Augur contracts, which are used for creating decentralized prediction markets. The bug was that most `require` statements in Augur contracts were lacking error messages. This means that if an error occurs, the code does not provide any information as to what the issue is.\n\nError messages are important as they help to explain what the issue is and how it can be resolved. They also make the code more self-explanatory, which is beneficial for anyone reading through the code.\n\nThe bug has been partially fixed in a series of commits. This means that some of the `require` statements now have error messages, but not all of them. It is recommended that all `require` statements should include error messages to make the code more self-explanatory.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11513",
      "title": "[M01] Missing docstrings throughout",
      "impact": "MEDIUM",
      "content": "Most of the contracts and functions in Augur’s code base lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. In general, docstrings should explicitly explain the purpose or intention of functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update****: fixed across a* [*series of commits*](https://github.com/AugurProject/augur/pull/2603/commits)*.*",
      "summary": "\nThis bug report is related to Augur's code base lacking documentation. Documentation is essential for reviewers to correctly assess the security and correctness of the code. Additionally, docstrings improve readability and ease maintenance. The report suggests that all functions (and their parameters) that are part of the contracts’ public API should be thoroughly documented. Furthermore, functions implementing sensitive functionality, even if not public, should be clearly documented as well. It is suggested to follow the Ethereum Natural Specification Format (NatSpec) when writing docstrings. The bug has been fixed across a series of commits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11512",
      "title": "Update: [H06] Legacy REP tokens can be migrated to child universes",
      "impact": "HIGH",
      "content": "When reviewing the originally reported **“[L07] REP token allows migration of legacy tokens after universe fork”**, finally identified as a non-issue, the Augur team uncovered a serious vulnerability that would allow legacy REP tokens to be migrated to child universes in v2. In Augur team’s words: *“This would allow v1 REP tokens to abstain from v2 forks safely and therefore bypass the v2 use-or-lose mechanism”*.\n\n\nThe fix entails allowing the migration of legacy REP tokens only in Genesis universes, and it was implemented in [`48744d6`](https://github.com/AugurProject/augur/commit/48744d6948c017dff747cf58e9efba2b6681b43e).",
      "summary": "\nA vulnerability was uncovered that would allow REP tokens from Augur v1 to be migrated to child universes in v2. This would enable users to bypass the “use-or-lose” mechanism of v2, allowing them to abstain from v2 forks safely. To fix this, the Augur team implemented a change in their codebase that only allows the migration of legacy REP tokens in Genesis universes. The fix was implemented in `48744d6` on the AugurProject/augur GitHub repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11511",
      "title": "[H05] Not following the Checks-Effects-Interactions pattern",
      "impact": "HIGH",
      "content": "[Solidity recommends the usage of the Check-Effects-Interactions Pattern](https://solidity.readthedocs.io/en/v0.5.4/security-considerations.html#use-the-checks-effects-interactions-pattern) to avoid potential vulnerabilities, such as [reentrancy](https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-107). In several locations throughout the Augur code base (*e.g.* in `Market` contract functions [`distributeInitialReportingRep`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L156), [`distributeMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L323) and [`disavowCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L415-L416)), calls to external, potentially attacker-controlled, contracts are made *before* making the necessary checks and modifications in the contract’s storage. This can potentially expose serious reentrancy vulnerabilities, as discussed in the **“[H04] Reentrancy vulnerabilities in Market contract”** issue.\n\n\nStrictly following the [Check-Effects-Interactions](https://solidity.readthedocs.io/en/v0.5.4/security-considerations.html#use-the-checks-effects-interactions-pattern) pattern is of utmost importance in systems like Augur where most of the token transfers involve ERC777-like tokens, which explicitly call hook functions in the sender and receiver of each transfer operation. Therefore, the development team must ensure all interactions with external contracts are performed after all checks and state changes are made.\n\n\n***Update****: Some instances of this issue have been fixed in* [*`9f6ca45`*](https://github.com/AugurProject/augur/commit/9f6ca4515a1eacd859a22aad87d9564a8aa49e4a).",
      "summary": "\nThis bug report is about a potential vulnerability in the Augur codebase that could expose serious reentrancy issues. The vulnerability is related to the Check-Effects-Interactions Pattern, which is recommended by Solidity and is used to avoid potential vulnerabilities, such as reentrancy. \n\nThe vulnerability is related to the fact that in several locations throughout the Augur codebase, calls to external, potentially attacker-controlled, contracts are made *before* making the necessary checks and modifications in the contract’s storage. This could potentially expose the system to reentrancy attacks. \n\nIt is important to strictly follow the Check-Effects-Interactions Pattern in systems like Augur where most of the token transfers involve ERC777-like tokens, which explicitly call hook functions in the sender and receiver of each transfer operation. Therefore, the development team must ensure all interactions with external contracts are performed after all checks and state changes are made. \n\nSome instances of this issue have already been fixed in the 9f6ca45 commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11510",
      "title": "[H04] Reentrancy vulnerabilities in Market contract",
      "impact": "HIGH",
      "content": "In the [`Market`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol) there are two reentrancy issues that allow for the removal of all of the contract’s REP tokens. In the contract’s current state, neither of these issues are exploitable because the contract never holds a REP token balance beyond the `repBond` being transferred in both instances.\n\n\nIn the [`disavowCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L415-L416) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L415-L416), the `repBond` is transferred to the `repBondOwner` before the `repBond` is set to `0`. Because it is an ERC777-like transfer, the [`tokensReceived`](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) [hook](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) is called on `repBondOwner` if `repBondOwner` is an ERC820-registered contract. Should the `repBondOwner` address actually be an attacker-controlled contract, it could reenter the `Market` contract by calling back into the `disavowCrowdsourcers` function from the `tokensReceived` hook and continue to do this until all REP tokens are drained from the market.\n\n\nA similar issue was identified in the [`distributeInitialReportingRep`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L150-L156) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L150-L156). In this case, the attacker could call the [`doInitialReport`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L127) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L127) which calls the [`doInitialReportInternal`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L132) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L132), which in turn calls the [`distributeInitialReportingRep`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L146) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L146), finally executing an [ERC777-like transfer](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L152) to the designated reporter address. In a scenario where the designated reporter address is a malicious attacker-controlled contract, it could reenter the `Market` contract by calling back into the `doInitialReport` function and continue to do so until all REP has been drained from the market.\n\n\nDespite neither of these vulnerabilities being exploitable, as in the current implementation the amount of REP held in a market is limited to the `repBond`, precautions should be taken to prevent an exploitable vulnerability from being introduced in the future. In this regard, consider always following the [Checks-Effects-Interactions](https://solidity.readthedocs.io/en/v0.5.4/security-considerations.html#use-the-checks-effects-interactions-pattern) pattern to mitigate the chances of calls to external addresses resulting in an exploitable reentrancy vulnerability.\n\n\n***Update****: fixed in* [*`c6eed38`*](https://github.com/AugurProject/augur/commit/c6eed38e36d2ca6f11d26175df05d9284e830936). *Transfers of REP tokens in the* *`Market`* *contract no longer call the ERC777 hooks.*",
      "summary": "\nThis bug report is about a reentrancy issue in the Market contract of the AugurProject. The issue allows for the removal of all of the contract’s REP tokens. The reentrancy issue was identified in two functions, disavowCrowdsourcers and distributeInitialReportingRep. In both functions, a REP token balance is transferred to the repBondOwner before the repBond is set to 0. If the repBondOwner address is an attacker-controlled contract, it could reenter the Market contract by calling back into the functions from the tokensReceived hook and continue to do this until all REP tokens are drained from the market. \n\nThe issue is not exploitable in the current implementation as the amount of REP held in a market is limited to the repBond. However, precautions should be taken to prevent an exploitable vulnerability from being introduced in the future. The Checks-Effects-Interactions pattern should be followed to mitigate the chances of calls to external addresses resulting in an exploitable reentrancy vulnerability. \n\nThe bug has been fixed in c6eed38, where transfers of REP tokens in the Market contract no longer call the ERC777 hooks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11509",
      "title": "[H03] Affiliate fees are not accumulated in multiple trading operations",
      "impact": "HIGH",
      "content": "In Augur v2, market creators can set an [`affiliateFeeDivisor`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L45) value which corresponds to the proportion of market creator fees that will be assigned to the [market’s affiliate](https://www.augur.net/blog/augur-v2/#affiliate) when trading occurs.\n\n\nFor this purpose, the `Market` contract implements the function [`recordMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L295), which can only be called by [“known fee senders”](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L296) and is in charge of [calculating](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L297-L302) the amount of fees to be assigned to the creator and the affiliate (if exists). As trading can occur multiple times in a market, this function is expected to be called multiple times with fees for creator and affiliates [accumulating](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L302) each time, and it should distribute the fees to the corresponding parties [only when the market is finalized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L303).\n\n\nHowever, while the fees are [correctly accumulated](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L302) for market creators, [affiliates’ fees are instead overwritten](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L299) (*i.e.* they are assigned to the `affiliateFeesAttoCash` mapping while they should be added using `affiliateFeesAttoCash[_affiliateAddress] = affiliateFeesAttoCash[_affiliateAddress].add(_affiliateFees);` ). As a consequence, if more than one trading operation of shares occurs in a market involving the same affiliate address, the affiliate will receive less fees than expected once the market is finalized.\n\n\nConsider accumulating affiliate fees the same way market creators fees are currently accumulated. Furthermore, it is highly recommended to include unit tests that cover the described scenario, so as to make sure this issue is not reintroduced in future changes to the code base.\n\n\n***Update****: fixed in* *[`1b07fa4`](https://github.com/AugurProject/augur/commit/1b07fa4ee7c763d2c85230a4d3eaeaae0077f884#diff-8ed676c60e9fab2fdbd79f09555a59be).* *Affiliate fees are now properly incremented.*",
      "summary": "\nAugur v2 is a decentralized prediction market platform. Market creators can set an ‘affiliateFeeDivisor’ value which corresponds to the proportion of market creator fees that will be assigned to the market’s affiliate when trading occurs. The ‘Market’ contract implements the ‘recordMarketCreatorFees’ function which calculates the amount of fees to be assigned to the creator and the affiliate but a bug was discovered where the fees for the affiliate were being overwritten instead of accumulated with each trading operation. This would result in the affiliate receiving less fees than expected once the market was finalized. To fix this, the bug was fixed by accumulating the affiliate fees in the same way the market creator fees were being accumulated. Unit tests were also added to make sure this issue is not reintroduced in future changes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11508",
      "title": "[H02] EIP 820 implementation must be updated to EIP 1820",
      "impact": "HIGH",
      "content": "[EIP 1820](https://github.com/ethereum/EIPs/pull/1820) has superseded [EIP 820](https://github.com/ethereum/EIPs/issues/820), the former being the latter’s adaptation for Solidity 0.5, due to [a bug](https://github.com/ethereum/EIPs/issues/820#issuecomment-452465748) that was found in [ERC820](https://eips.ethereum.org/EIPS/eip-820) which would prevent certain calls made in the [`staticcall`](https://github.com/jbaylina/ERC820/blob/master/contracts/ERC820Registry.sol#L201) to never return a `true`.\n\n\nTherefore, consider updating the specification to [ERC1820](https://eips.ethereum.org/EIPS/eip-1820). This will update the [`insize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) [parameter of the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) [`staticcall`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol#L149) from `0x08` to `0x24`. Contracts in [`ERC820Implementer.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/ERC820Implementer.sol), [`IERC820Registry.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/IERC820Registry.sol)[`ERC820Registry.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/ERC820Registry.sol), [`ReputationToken.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L28), [`DisputeWindow.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L20), and a number of other contracts using the ERC820 registry must all be updated to reflect the changes.\n\n\n***Update****: the ERC820 contract has been replaced with the ERC1820 contract in* [*`484e3ac`*](https://github.com/AugurProject/augur/commit/484e3ac8c3ae077797941d763ac2fc80dabf4161).",
      "summary": "\nA bug was found in the Ethereum Request for Comment (ERC) 820 which would prevent certain calls made in the \"staticcall\" from returning a \"true\". As a result, ERC 1820 was created as an adaptation for Solidity 0.5 to replace ERC 820. \n\nThe \"insize\" parameter of the \"staticcall\" must be updated from \"0x08\" to \"0x24\" in the contracts \"ERC820Implementer.sol\", \"IERC820Registry.sol\", \"ERC820Registry.sol\", \"ReputationToken.sol\", and \"DisputeWindow.sol\". The ERC1820 contract can be found in the Github commit \"484e3ac8c3ae077797941d763ac2fc80dabf4161\". \n\nIt is important to update the ERC820 contracts to the new ERC1820 contract to prevent the bug from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11507",
      "title": "[H01] Implementation of EIP 777 does not fully match the specification",
      "impact": "HIGH",
      "content": "The following mismatches between the [EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777) and the related implementation contracts (*i.e.* [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol), [`ERC777TokensRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensRecipient.sol) and [`ERC777TokensSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensSender.sol)) were identified.\n\n\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), the following functions are missing from the ERC777 interface: `name()`, `symbol()`, `totalSupply()`, `balanceOf(address)`, `granularity()`, `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)`. It is worth highlighting that `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)` are the only functions never implemented in child contracts.\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), [`ERC777TokensSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensSender.sol) and [`ERC777TokensRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777TokensRecipient.sol), all function and event parameters defined as type `bytes32` should be defined as `bytes`.\n* In [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol), the `authorizeOperator(address)`, `revokeOperator(address)`, `send(address,uint256,bytes)` and `operatorSend(address,address,uint256,bytes,bytes)` functions return a success `bool` while the EIP 777 standard does not specify a return value for any of those functions.\n* The [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) does not implement the `burn(uint256,bytes)` and `operatorBurn(address,uint256,bytes,bytes)` functions, which as mentioned, are missing from the [`ERC777Token`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol) interface. Augur developers acknowledge this situation in [an inline comment](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L17).\n* The [`ERC777BaseToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol) implements a public [`sendNoHooks`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L49) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L49) that allows the caller to transfer tokens bypassing the `tokensReceived` and `tokensToSend` hooks of the sender and receiver, a feature [completely opposite to the EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777#sending-tokens).\n* The [`mint`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) of `VariableSupplyToken` does not call the [`callRecipient`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777BaseToken.sol#L122) function of `ERC777BaseToken`, thus never calling the receiver’s `tokensReceived` hook. According to [the EIP 777 spec](https://eips.ethereum.org/EIPS/eip-777#minting-tokens), calling such hook is a MUST when minting tokens.\n* The [`Minted`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29) [event](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/ERC777Token.sol#L29) defined in `ERC777Token` is never emitted when minting tokens in the [`mint`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L13) of `VariableSupplyToken`. According to [the EIP 777 spec](https://eips.ethereum.org/EIPS/eip-777#minting-tokens), emitting such event is a MUST when minting tokens.\n* According to the spec, the `tokensToSend` hook MUST be called *before* the token’s state is updated. Similarly, the `tokensReceived` hook MUST be called *after* the token’s state is updated. However, the function [`transferFrom`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/StandardToken.sol#L26) of the `StandardToken` contract [modifies the token’s state](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/StandardToken.sol#L31) (*i.e.* the allowances) before the `tokensToSend` hook is called.\n\n\nMany of these particular noncompliances seem to be known by Augur’s development team, who still decided to move forward with their custom implementation of EIP 777. This kind of decisions come with trade-offs. While the deviations from the spec may be more suitable for the Augur protocol, they might potentially cause errors in clients interacting with Augur that expect a fully-compliant implementation of the EIP 777. Therefore, it is advisable to either avoid calling the implemented token ERC777 altogether (its similarities and differences with the standard spec could be described in end-user documentation), or instead fully comply with the EIP’s specification by following [OpenZeppelin’s ERC777 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v2.3.0/contracts/token/ERC777), released in the 2.3.0 version.\n\n\n***Update:*** *in an* [*attempt to fix*](https://github.com/AugurProject/augur/pull/2510) *this issue, where the* *`mint`* *function of the* *`VariableSupplyToken`* *was modified to call the ERC777* *`tokensReceived`* *hook, a critical regression error has been introduced. The* *`migrateBalanceFromLegacyRep`* *function of the* *`OldLegacyRepToken`* *contract must be called for every token holder to complete the migration, and as* *`mint`* *now calls the* *`tokensReceived`* *hook, any holder can revert attempts to mint new tokens for them. As a result, malicious tokens holders can prevent the migration from finishing (i.e. potentially never allowing the* *`isMigratingFromLegacy`* *flag to be set to* *`false`**).*",
      "summary": "\nThis bug report is regarding the implementation of EIP 777, a standard for tokens on the Ethereum network, and the related contracts. Specifically, the report identifies mismatches between the EIP 777 specification and the related implementation contracts. These include missing functions, incorrect parameter types, return values that are not specified in the EIP 777 standard, and functions that do not follow the EIP 777 specification. Augur developers acknowledge some of these mismatches in an inline comment.\n\nIn addition, the report states that a critical regression error was introduced when an attempt was made to fix the issue, where the mint function of the VariableSupplyToken was modified to call the ERC777 tokensReceived hook. This allowed malicious token holders to prevent the migration from finishing, potentially never allowing the isMigratingFromLegacy flag to be set to false.\n\nIn order to fix this issue, it is recommended to either avoid calling the implemented token ERC777 altogether, or to follow OpenZeppelin’s ERC777 implementation which is released in the 2.3.0 version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11506",
      "title": "[C08] Fork reputation goal threshold can be decreased during fork",
      "impact": "HIGH",
      "content": "Once a universe is forking, all REP token holders are expected to migrate out their entire REP balance to one of the child universes. The migration of tokens can be accomplished calling the [`migrateOut`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) or [`migrateOutByPayout`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L39) functions in the `ReputationToken` contract corresponding to the forking universe. These will then trigger the [burning of REP tokens in the forking universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L51), and by calling the [`migrateIn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L52) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L52) of the child universe’s REP token, the corresponding REP tokens [will be minted](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L60) in the child universe. The forking stage will be considered finished either when a certain amount of REP tokens have been migrated (*i.e.* [`forkReputationGoal`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L31) tokens) to a child universe (which will be considered the winning child universe), or when a fixed amount of time has passed (*i.e.* when the system’s time is greater than [`forkEndTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L30)).\n\n\nWhile the `forkReputationGoal` was expected to be a fixed threshold during a fork, an attack vector has been identified in a second-generation forking universe where any malicious user can turn the `forkReputationGoal` into an ever-decreasing moving target, thus dangerously allowing a holder of tokens to potentially manipulate the outcome of a fork in an unintended way.\n\n\nConsider a Universe B, winning child of a locked Universe A that forked in the past (*i.e.* in Universe B, `augur.getTimestamp() >= parentUniverse.getForkEndTime()` equals `true`). Now consider that the Universe B is forking to several universes, but still has not settled on which child universe is the winning one; that is, users are actively migrating their Universe-B-REP tokens to one of the many child universes by calling the [`migrateOut`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) of the Universe-B-REP token. Therefore, the total supply of Universe-B-REP tokens is decreasing (because Universe-B-REP tokens are [burned](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L51)).\n\n\nThe `ReputationToken` contract implements the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) that can be called by anyone at any time. In our scenario, calling this function will always execute [line 157](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L156-L157) of `ReputationToken.sol`, thus updating the `totalTheoreticalSupply` of Universe-B-REP tokens to the last registered `totalSupply` of tokens. This means that, as the `totalSupply` of Universe-B-REP tokens is decreasing due to tokens being migrated and burned, the `totalTheoreticalSupply` will also decrease each time `updateTotalTheoreticalSupply` is called after at least one Universe-B-REP token is migrated out to a child universe.\n\n\nThe `Universe` contract implements the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) that can be called by anyone at any time, and [updates the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [`forkReputationGoal`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [with the last registered value of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [`totalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81)`.` In our scenario, if the `updateForkValues` function is called in Universe B after calling `updateTotalTheoreticalSupply` in the Universe-B-REP token, then the `forkReputationGoal` threshold will be decreased, as the `totalTheoreticalSupply` was decreased (explained in previous paragraph).\n\n\nAs a consequence, any user can leverage the migration of Universe-B-REP tokens to effectively turn the `forkReputationGoal` threshold of Universe B into a moving target, thus each time requiring [less and less tokens for a child universe to be considered the winning universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L231), not only because the amount of REP migrated is increasing (which is expected), but also because the threshold is being lowered.\n\n\nConsider analyzing the need of having a public function that updates critical system parameters such as [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79)`.` If it is to remain public to be called from off-chain clients, then its execution during a fork should be halted, making sure it is called one last time before entering the fork stage. As a starting point, one potential (untested) solution for this issue could be adding a `require(!isForking())` statement at the beginning of the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79), and adding a call to it in the [`fork`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L70) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L70) of the `Universe` contract. Regardless of the course of action taken, thorough unit tests to cover the described scenario should be included to prevent this issue from being reintroduced in future changes to the code base.\n\n\n***Update:*** *fixed in* *[`a9560f4`](https://github.com/AugurProject/augur/commit/a9560f44ea42db3fce4dedf8f238f91354aca265).* *The fork reputation goal threshold can no longer be changed once a fork has begun.*",
      "summary": "\nThis bug report is about a potential attack vector in a second-generation forking universe where any malicious user can turn the `forkReputationGoal` into an ever-decreasing moving target, thus dangerously allowing a holder of tokens to potentially manipulate the outcome of a fork in an unintended way. \n\nWhen a universe is forking, all REP token holders are expected to migrate out their entire REP balance to one of the child universes. This is done by calling the `migrateOut` or `migrateOutByPayout` functions in the `ReputationToken` contract corresponding to the forking universe. This will then trigger the burning of REP tokens in the forking universe and minting the corresponding REP tokens in the child universe. The forking stage is considered finished either when a certain amount of REP tokens have been migrated (`forkReputationGoal` tokens) to a child universe (the winning child universe) or when a fixed amount of time has passed (`forkEndTime`).\n\nThe bug is that the `ReputationToken` contract implements the `updateTotalTheoreticalSupply` function that can be called by anyone at any time. This will always execute line 157 of `ReputationToken.sol`, thus updating the `totalTheoreticalSupply` of Universe-B-REP tokens to the last registered `totalSupply` of tokens. This means that, as the `totalSupply` of Universe-B-REP tokens is decreasing due to tokens being migrated and burned, the `totalTheoreticalSupply` will also decrease each time `updateTotalTheoreticalSupply` is called after at least one Universe-B-REP token is migrated out to a child universe.\n\nThe `Universe` contract implements the `updateForkValues` function that can be called by anyone at any time, and updates the `forkReputationGoal` with the last registered value of `totalTheoreticalSupply`. If the `updateForkValues` function is called in Universe B after calling `updateTotalTheoreticalSupply` in the Universe-B-REP token, then the `forkReputationGoal` threshold will be decreased, as the `totalTheoreticalSupply` was decreased. This means that any user can leverage the migration of Universe-B-REP tokens to effectively turn the `forkReputationGoal` threshold of Universe",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11505",
      "title": "[C07] All dispute bonds can be held hostage or permanently frozen when a Market is in a forking universe",
      "impact": "HIGH",
      "content": "When a non-forking market is in a forking universe, its [`disavowCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L400) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L400) must be called either directly or through the [`migrateThroughOneFork`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L357) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L357) before dispute bond holders can [redeem](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L35) and migrate their REP tokens to a child universe. This is due to the fact that the `DisputeCrowdsourcer` contract [must be disavowed or the market must be finalized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L36-L39) before redemption is allowed, and the market [cannot be finalized in a forking universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L242).\n\n\nIn the `disavowCrowdsourcers` function, a [transfer](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L415) of REP tokens is made to the `repBondOwner` address. As the REP token is similar to an [ERC777 token](https://eips.ethereum.org/EIPS/eip-777), its [`transfer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L96) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L96) will call the [`tokensReceived`](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) [hook](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) on the `repBondOwner` address if it is an [ERC820-registered](https://eips.ethereum.org/EIPS/eip-820) contract.\n\n\nA malicious `repBondOwner` account could leverage this hook to revert any calls to the `tokensReceived` function, rendering it impossible to successfully call the `disavowCrowdsourcers` or `migrateThroughOneFork` functions on that market. As a consequence, this attack will effectively freeze all dispute bond funds and therefore prevent the market from being migrated to the winning fork. It would be trivial for the malicious `repBondOwner` account to only release funds when a ransom has been paid to the contract which can then be collected by the attacker. This can also be exploited just as a griefing attack to cause Augur reporting participants to lose funds.\n\n\nWhen making ERC777-like transfers, consider strictly implementing the [withdrawal payments pattern](https://solidity.readthedocs.io/en/v0.5.4/common-patterns.html#withdrawal-from-contracts) (a.k.a. “pull style” payments) or ensuring the ERC777 transfer hooks are not called to mitigate attack vectors associated with making calls to external addresses.\n\n\n***Update****: fixed in* [*`c6eed38.`*](https://github.com/AugurProject/augur/commit/c6eed38e36d2ca6f11d26175df05d9284e830936) *The transfer of REP token in the* *`disavowCrowdsourcers`* *function no longer calls the ERC 777 hooks.*",
      "summary": "\nThis bug report is about a vulnerability in Augur's market when it is in a forking universe. The vulnerability is that a malicious repBondOwner account could leverage the ERC777 token transfer hook to prevent users from successfully calling the disavowCrowdsourcers or migrateThroughOneFork functions on that market. This would freeze all dispute bond funds and prevent the market from being migrated to the winning fork. It could also be exploited as a griefing attack to cause Augur reporting participants to lose funds.\n\nTo fix this vulnerability, the transfer of REP token in the disavowCrowdsourcers function was changed to no longer call the ERC 777 hooks. This was done by strictly implementing the withdrawal payments pattern (a.k.a. “pull style” payments) or ensuring the ERC777 transfer hooks are not called. This fix was released in the c6eed38 commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11504",
      "title": "[C06] Affiliate’s fees can be withdrawn in an invalid, finalized Market",
      "impact": "HIGH",
      "content": "The `Market` contract implements the [`recordMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L295) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L295), which can only be called by [“known fee senders”](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L296) and is in charge of calculating the amount of fees to be assigned to the creator and the affiliate (if exists). When the market [is finalized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L303-L304), the function takes care of calling the [`distributeMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314). This last function either:\n\n\n* A) If the market is valid, [transfers the current owner all corresponding fees](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L316) (*i.e.* `marketCreatorFeesAttoCash`). Additionally, if there is an affiliate, `distributeMarketCreatorFees` [sends the corresponding fees to the affiliate too by calling the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L318) [`withdrawAffiliateFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L318) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L318).\n* B) If the market is invalid, [sends all market creator fees](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L321) (*i.e.* `marketCreatorFeesAttoCash`) to a fee pool.\n\n\nIn case (B), the amount of CASH tokens sent to the fee pool does not include any affiliate fees (they are always [subtracted from](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L300) [`marketCreatorFeesAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L300) [in line 300](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L300)). That means that the [transfer of CASH tokens in line 321](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L321) does not actually transfer the affiliate’s fees to the pool, and therefore an affiliate can still call [`withdrawAffiliateFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L327) to cash out the fees.\n\n\nIn a scenario where addresses controlled by the market creator are set as the affiliate address in trading operations, and the `affiliateFeeDivisor` is set to 1 (so that in [line 298](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L298) the `_affiliateFees` are as high as possible – equal to `marketCreatorFees`), then the market creator will not lose any fees if the market ends up being invalid, as they will be able to get away with all affiliate fees by calling the [`withdrawAffiliateFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L327) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L327).\n\n\nSimilar to what is currently done with market creator fees, consider implementing the necessary changes in the `distributeMarketCreatorFees` function to effectively send all affiliate fees to the fee pool if the market is invalid. Unit tests to cover this sensitive scenario are in order, which should prevent this issue from being reintroduced in future changes to the code base.\n\n\n***Update****: fixed in* [*`8707454`*](https://github.com/AugurProject/augur/commit/87074545a99c6dd97709286fbdeca01e0454b7bf) *. Affiliate fees are now transferred to the dispute window for invalid markets.*",
      "summary": "\nThis bug report is about an issue with the `Market` contract in the Augur Project. This contract implements the `recordMarketCreatorFees` function, which can only be called by \"known fee senders\" and is in charge of calculating fees to be assigned to the creator and the affiliate (if exists). When the market is finalized, the function calls the `distributeMarketCreatorFees` function. In the case of a valid market, this function transfers the current owner all corresponding fees and, if there is an affiliate, sends the corresponding fees to the affiliate too. However, in the case of an invalid market, the function only sent the market creator fees to a fee pool, but not the affiliate fees, meaning the affiliate could still call the `withdrawAffiliateFees` function to cash out the fees.\n\nTo fix this issue, changes were made to the `distributeMarketCreatorFees` function to ensure all affiliate fees are sent to the fee pool if the market is invalid. Additionally, unit tests were created to cover this sensitive scenario to prevent the issue from being reintroduced in future changes to the code base. The bug has now been fixed in the `8707454` commit, where affiliate fees are now transferred to the dispute window for invalid markets.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11503",
      "title": "[C05] Unfillable orders can be placed to constrain or halt markets",
      "impact": "HIGH",
      "content": "In the [`FillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L363) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L363), the `fillOrder` function calls `tradeMakerTokensForFillerTokens` in the [`Trade`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L18) [`library`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L18) located in the same file. The `tradeMakerTokensForFillerTokens` function makes a [transfer](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L197-L199) of `longShareToken` and `shortShareToken` to the `_longBuyer` and `_shortBuyer` respectively. Either the `_longBuyer` or the `_shortBuyer` will be the order `creator` depending on the direction of the trade. Both transfers will trigger the [`tokensReceived`](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) [hook](https://eips.ethereum.org/EIPS/eip-777#erc777tokensrecipient-and-the-tokensreceived-hook) on the recipient if the recipient is an [ERC820-registered](https://eips.ethereum.org/EIPS/eip-820) contract. This means that if the order `creator` is a contract that reverts when `tokensReceived` is called, the order will be unfillable because it will cause `fillOrder` to revert.\n\n\nAccording to Augur v2 whitepaper, “Orders are never executed at a worse price than the limit price set by the trader, but may be executed at a better price.” An unfillable order may severely limit or completely disable a market because it must be filled before an order with a worse price can be filled. This applies to orders on both sides of the order book.\n\n\nAny malicious user can exploit this vulnerability by placing an unfillable order at a price they do not want the market to trade above or below (depending on the direction of the order), thus creating an artificial ceiling or floor on the market. Furthermore, just by placing two unfillable orders, one long, one short, with a very tight spread, the attacker can effectively halt all trading operations in any Augur market.\n\n\nConsider using the [`trustedFillOrderTransfer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L59) function instead of `transfer`, both in [line 197](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L197) and [line 199](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L199) of `FillOrder.sol`, to ensure the [`ERC777`](https://eips.ethereum.org/EIPS/eip-777) [`hooks`](https://eips.ethereum.org/EIPS/eip-777) are not called, which should mitigate the described critical vulnerability.\n\n\n***Update:*** *fixed in* [*`98a3f36`*](https://github.com/AugurProject/augur/commit/98a3f369bbf00f8ee9fd392fbe1612fd3c5d66be) *by modifying transfers of Augur’s Share tokens to no longer call the ERC 777 hooks.*",
      "summary": "\nThis bug report is about a vulnerability in the Augur v2 'FillOrder' contract. The 'fillOrder' function calls the 'tradeMakerTokensForFillerTokens' function in the 'Trade' library located in the same file. The 'tradeMakerTokensForFillerTokens' function makes a transfer of 'longShareToken' and 'shortShareToken' to the '_longBuyer' and '_shortBuyer' respectively. This transfer triggers the 'tokensReceived' hook on the recipient if the recipient is an ERC820-registered contract. If the order creator is a contract that reverts when 'tokensReceived' is called, the order will be unfillable, which can severely limit or completely disable a market. Malicious users can exploit this vulnerability by placing an unfillable order at a price they do not want the market to trade above or below, thus creating an artificial ceiling or floor on the market. \n\nTo mitigate this critical vulnerability, Augur suggested using the 'trustedFillOrderTransfer' function instead of 'transfer' in lines 197 and 199 of 'FillOrder.sol'. This should ensure that the ERC777 hooks are not called. The bug has since been fixed in '98a3f36' by modifying transfers of Augur's Share tokens to no longer call the ERC 777 hooks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11502",
      "title": "[C04] DisputeCrowdsourcer contract does not allow for the purchase of overload tokens once its size is filled",
      "impact": "HIGH",
      "content": "The `DisputeCrowdsourcer`‘s [`contribute`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L75) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L75) is expected to mint [DISP tokens](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L18) for contributors until the funding goal is reached. After the funding goal has been reached, further contributions are rewarded with “overload tokens” to enable participants to quickly raise the dispute stakes without waiting through multiple dispute rounds. This mechanism prevents malicious parties from dragging out disputes.\n\n\nHowever, in [line 78](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L78) of `DisputeCrowdsourcer.sol`, `size.sub(_curStake)` will inevitably revert if `_curStake` is larger than `size`. `size` is the funding goal of the `DisputeCrowdsourcer` and is the threshold at which DISP tokens stop being minted, replaced by the minting of overload tokens. The value of `_curStake` is calculated by the [`getStake`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L106) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol#L106) which sums the total supply of all DISP and overload tokens. As a consequence, only the first purchase of overload tokens that brings the total stake above the funding goal will succeed. Every subsequent attempt to contribute to the tentative outcome (*i.e.* by purchasing overload tokens) will revert because the total number of overload tokens and DISP tokens will exceed the funding goal (*i.e.* `size`).\n\n\nConsider refactoring the `contribute` function to handle the described scenario, where the total number of overload tokens and DISP tokens exceeds the funding goal, so as to ensure disputes cannot be easily dragged out by malicious parties.\n\n\n*Note: The* *`DisputeCrowdsourcer`* *contract is not within the scope of this audit but has many interactions with the contracts covered by this report.*\n\n\n***Update:*** *fixed in* [*`2ea5753`*](https://github.com/AugurProject/augur/commit/2ea575351ff90253cca7380ccf141fec2e101b0b) *by removing the concept of overload tokens.*",
      "summary": "\nThis bug report is regarding the `DisputeCrowdsourcer` contract, which is used to mint tokens for contributors until the funding goal is reached. After the funding goal is reached, further contributions are rewarded with “overload tokens” to prevent malicious parties from dragging out disputes. However, in line 78 of `DisputeCrowdsourcer.sol`, `size.sub(_curStake)` will inevitably revert if `_curStake` is larger than `size`. `size` is the funding goal of the `DisputeCrowdsourcer` and is the threshold at which DISP tokens stop being minted, replaced by the minting of overload tokens. The value of `_curStake` is calculated by the `getStake` function which sums the total supply of all DISP and overload tokens. As a consequence, only the first purchase of overload tokens that brings the total stake above the funding goal will succeed, and every subsequent attempt to contribute will revert.\n\nThis bug was fixed in `2ea5753` by removing the concept of overload tokens. The refactored `contribute` function handles the scenario where the total number of overload tokens and DISP tokens exceeds the funding goal, thus ensuring disputes cannot be easily dragged out by malicious parties.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11501",
      "title": "[C03] Anyone can remove all market’s dispute crowdsourcers",
      "impact": "HIGH",
      "content": "After an initial report is done, the tentative outcome for an Augur market can be disputed by any REP token holder during the market’s dispute round. Such dispute consists of staking REP tokens on an outcome other than the market’s current tentative outcome. A dispute is considered successful when the total amount of dispute stake on some outcome meets the dispute bond size required for the current dispute round. It is important to highlight that dispute bonds do not need to be paid in their entirety by a single user; instead, users can crowdsource them.\n\n\nDuring the dispute round, a `Market` keeps track of contributions to each possible outcome by instantiating [`DisputeCrowdsourcer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/DisputeCrowdsourcer.sol) contracts, storing references to them in the [`crowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L59) [`collection`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L59). These `DisputeCrowdsourcer` contracts act as escrows for the staked REP tokens for each possible outcome, and are expected only to be cleared (via the [`clearCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425)) when either the [crowdsourcing for a particular dispute bond finishes](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L201) or [existing crowdsourcers need to be disavowed during a fork](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L420). However, as the [`clearCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425) is `public`, anyone can, at any time, silently delete all crowdsourcer addresses registered in a `Market` contract. This renders the entire disputing process pointless, as anyone can just delete all crowdsourcers before a dispute bond is about to be filled, thus avoiding any dispute over the market’s tentative outcome.\n\n\nConsider restricting the visibility of the [`clearCrowdsourcers`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L425) to `private`. Furthermore, to prevent this issue from being reintroduced in future changes to the code base, consider adding related unit tests.\n\n\n***Update****: fixed in* [*`99d06e8`*](https://github.com/AugurProject/augur/commit/99d06e861ae8cd79fa92ee2c101bfac4ead2a4ef) *by restricting the* *`clearCrowdsourcers`* *function’s visibility to* *`private`**.*",
      "summary": "\nAugur is a decentralized prediction market platform that allows users to stake their REP tokens on an outcome of a market. During the dispute round, a `Market` contract keeps track of contributions to each possible outcome by instantiating `DisputeCrowdsourcer` contracts, which act as escrows for the staked REP tokens. It was discovered that the `clearCrowdsourcers` function, which is responsible for clearing the `DisputeCrowdsourcer` contracts, was public, meaning anyone could delete all the crowdsourcers before a dispute bond is filled, thus avoiding any dispute over the market’s tentative outcome. To fix this, the visibility of the `clearCrowdsourcers` function has been restricted to `private` and related unit tests have been added to prevent this issue from being reintroduced in future changes to the code base.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11500",
      "title": "[C02] CASH tokens can be stolen from the Market contract",
      "impact": "HIGH",
      "content": "By exploiting the critical vulnerability described in **“[C01] All CASH tokens approved to Augur can be emptied”**, any malicious user can move all CASH tokens approved to Augur, sending them to Market contracts. But the attacker does not *directly* benefit from the attack.\n\n\nHowever, a severe attack vector has been identified in the Market contract that would allow the attacker to actually steal all tokens previously moved to the Market contract. Therefore, this issue should be considered as an extension of **“[C01] All CASH tokens approved to Augur can be emptied”**. Following, we set out to describe step by step how an attacker can leverage a malicious universe and the lack of input validations to finally move the CASH tokens to any address in their control.\n\n\nOnce the approved CASH tokens are moved to the `Market` contract (described in **“[C01] All CASH tokens approved to Augur can be emptied”**), the [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol) calls the market’s [`initialize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L63) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L63). This means that:\n\n\n* 1.1) Market’s [`owner`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L78) and [`repBondOwner`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L79) are set to the victim’s address (*i.e.* the `_sender` parameter).\n* 1.2) Market’s [`universe`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L75) is set to an attacker controlled `IUniverse` contract.\n* 1.3) The market [adds a new](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [`InitialReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [to the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [p`articipants`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87) [`array`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L87), the attacker being the [`designatedReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L22) of the added `InitialReporter` contract.\n* 1.4) Market’s [`repBond`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98) [is set to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98) [`0`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L98), as `universe.getOrCacheMarketRepBond()` is controlled by the attacker.\n* 1.5) Market’s [`validityBondAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L100) [is set](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L100) to the entire CASH balance of the `Market` contract.\n\n\nNow, when the market’s `endTime` passes (this parameter is attacker-controlled too, and [set during initialization](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L81)), the attacker can either submit an initial report or just wait the 24 hours until public reporting is allowed. In any case, the `Market` has to be reported as “Invalid”.\n\n\n* 2.1) Regardless of when the attacker submits the initial report, the transfer operations in [lines 151 and 152](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L151-L152) or [line 154](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L154) of `Market.sol` will move `0` REP tokens, as `_initialReportStake` is the same as `repBond` and `repBond` was set to zero (see 1.4).\n* 2.2) In [line 140](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L140) the `disputeWindow` of the `Market` is initialized by the attacker-controlled `universe`.\n* 2.3) In [line 141](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L141) (then [lines 46 and 47 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L46-L47) [`InitialReporter.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L46-L47)) the attacker gets registered as the `owner` and `actualReporter` of the `InitialReporter` contract.\n* 2.4) Then, in [line 50 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L50) [`InitialReporter.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L50) the `payoutNumerators` is set to the attacker-controlled `_payoutNumerators`, such that `payouNumerators[0] > 0`, so the `Market` is reported as “Invalid”. From now on, the function [`getPayoutNumerator(0)`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/BaseReportingParticipant.sol#L54) (inherited from the `BaseReportingParticipant` contract) will always return a value greater than zero.\n* 2.5) In [line 51](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol#L51) of `InitialReporter.sol` the `size` is set to zero.\n\n\nFinally, the attacker calls the [`finalize`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L235) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L235) on the `Market` contract.\n\n\n* 3.1) The `require` statement in [line 236](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L236) of `Market.sol` is verified correctly.\n* 3.2) In [line 237](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L237), the attacker-controlled `universe` returns the necessary value to make `true` the conditional clause, bypassing (*i.e.* never executing) all logic in the [`else`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L240) [`clause`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L240).\n* 3.3) The attacker-controlled `universe` sets `winningPayoutDistributionHash` to some value other than zero in [line 239](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L239). From now on, every call to `Market`‘s [`isFinalized`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L468) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L468) will return `true`.\n* 3.4) In [line 250](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L250), the execution flow goes into the [`distributeValidityBondAndMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L308) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L308), where in line 310 the [`marketCreatorFeesAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310) [is set to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310) [`validityBondAttoCash`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L310), which in turn is all `Market`‘s CASH balance (see 1.5).\n* 3.5) Inside the [`distributeMarketCreatorFees`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L314), the [call to](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) [`isInvalid`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) [in line 315](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L315) will return `true` (see 3.3 and 2.4), therefore the execution flow will jump straight to [line 321](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol#L321), where the `Market` contract will finally send `marketCreatorFeesAttoCash` amount of tokens (the entire CASH balance – see 3.4 and 1.5) to an attacker-controlled address (as the attacker controls `universe.getOrCreateNextDisputeWindow(false)`).\n\n\nAs explained, by combining the vulnerability reported in the issue **“[C01] All CASH tokens approved to Augur can be emptied”** with the correct execution of the steps above, any malicious user can effectively steal CASH tokens that are approved to the Augur contract. While initially the attack here described seems to be prevented by properly verifying the legitimacy of the `universe` address set in the `Market` contract, a thorough review of the entire attack vector, which includes complex interactions between the [`Augur`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol), [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol), [`Market`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol) and [`InitialReporter`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/InitialReporter.sol) contracts, is in order, so as to determine the most appropriate course of action to mitigate the critical vulnerability.\n\n\n***Update****: the Augur team correctly pointed out that this attack is not actually possible because the transaction will be reverted upon calling the `logInitialReportSubmitted`* *function in the* *`Augur`* *contract (which checks that the passed universe address is legitimate).*",
      "summary": "\nA critical vulnerability has been discovered in Augur's CASH tokens which can be exploited by malicious users to move all CASH tokens approved to Augur and send them to Market contracts. However, a severe attack vector has been identified in the Market contract that would allow the attacker to actually steal all tokens previously moved to the Market contract. \n\nThe issue is an extension of the original vulnerability, and the attack vector is enabled by the lack of input validations. The attacker is able to set the Market's owner and repBondOwner to the victim's address, set the universe to an attacker controlled IUniverse contract, set the repBond to zero, set the validityBondAttoCash to the entire CASH balance of the Market contract, register themselves as the owner and actualReporter of the InitialReporter contract, set the payoutNumerators to the attacker-controlled _payoutNumerators, set the size to zero, and call the finalize function on the Market contract.\n\nOnce the endTime passes, the attacker can either submit an initial report or wait the 24 hours until public reporting is allowed. In either case, the Market has to be reported as \"Invalid\". This allows the attacker to bypass the logic in the else clause, have the universe set the winningPayoutDistributionHash to some value other than zero, and have every call to the Market's isFinalized function return true. The result is that the attacker is able to move all CASH tokens to any address in their control.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11499",
      "title": "[C01] All CASH tokens approved to Augur can be emptied",
      "impact": "HIGH",
      "content": "A [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol) has a [`createMarket`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L13) [public function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L13) that allows anyone to create a new [`Market`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Market.sol). After [creating the market](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L14), and before [initializing it](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L18), the factory first [transfers all its REP token balance to the market](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L16). Then, it calls the given [`IAugur`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/IAugur.sol) [`contract`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/IAugur.sol) to execute a “trusted transfer” of CASH tokens, for an amount given by `_universe.getOrCacheValidityBond()` (being `_universe` the address of a potentially user-controlled [`IUniverse`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/IUniverse.sol) contract).\n\n\nIn a scenario where a victim has approved `N` CASH tokens to the `Augur` contract, and the `MarketFactory` is registered as a [`trustedSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L75) in such `Augur` contract, an attack vector has been identified where tokens approved by the victim to the `Augur` contract can be freely emptied by an attacker, sending them to any newly created market.\n\n\nAll the attacker needs to do is call the [`createMarket`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L13) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L13) of the trusted `MarketFactory` with the following relevant parameters:\n\n\n* `_universe`: an address of a contract controlled by the attacker that implements the `getReputationToken` function and `getOrCacheValidityBond` function\n* `_sender`: address of the victim that approved `N` “Cash” tokens to `Augur` contract\n\n\nAs a consequence:\n\n\n1. The [`require`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L16) [in line 16 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L16) [`MarketFactory.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L16) passes regardless of how many tokens the `MarketFactory` contact owns.\n2. The [`require`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L17) [in line 17 of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L17) [`MarketFactory.sol`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L17) makes a [`trustedTransfer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L204) of CASH tokens. The amount of tokens to be transferred is controlled by attacker, as attacker controls `_universe.getOrCacheValidityBond()`.\n3. Upon its [`trustedTransfer`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L204) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L204) being called, the [`Augur`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L205) [contract recognizes](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L205) [`MarketFactory`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L205) [as a](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L205) [`trustedSender`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/Augur.sol#L205), and executes a `transferFrom` from the victim’s address, to the market’s address, of as much tokens as the attacker set.\n4. Finally, back in the `MarketFactory` contract, the [created market is initialized](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/factories/MarketFactory.sol#L18).\n\n\nAs a result, the victim lost all CASH tokens approved to `Augur`, which were freely moved by an attacker to the newly created market. It is important to highlight that in the issue **“CASH tokens can be stolen from the Market contract”** a related attack vector is thoroughly described, where the attacker is able to actually steal the tokens moved to the market.\n\n\nEven if a user approves a certain amount of tokens to a contract (*e.g.* the `Augur` contract), under no circumstances should those tokens be allowed to be moved at the will of a potentially malicious external actor. Therefore, consider implementing the necessary restrictions in the `MarketFactory` contract to prevent a scenario as the one described above. Related unit tests to thoroughly cover such dangerous cases must also be implemented.\n\n\n***Update:*** *fixed in* *`814b390`* *by checking that the universe address passed into the* *`createMarket`* *function is a known universe, thus eliminating the possibility of it being malicious.*",
      "summary": "\nA bug report has been identified in the Augur project, which is a decentralized prediction market platform. The bug involves the MarketFactory contract, which has a public function called createMarket that allows anyone to create a new Market. Before initializing the market, the factory transfers all its REP token balance to the market and calls the IAugur contract to execute a “trusted transfer” of CASH tokens.\n\nIn a scenario where a victim has approved N CASH tokens to the Augur contract, and the MarketFactory is registered as a trustedSender in such Augur contract, an attack vector has been identified where tokens approved by the victim to the Augur contract can be freely emptied by an attacker, sending them to any newly created market. The attacker needs to call the createMarket function of the trusted MarketFactory with relevant parameters that include the address of a contract controlled by the attacker that implements the getReputationToken function and getOrCacheValidityBond function, and the address of the victim that approved N “Cash” tokens to Augur contract.\n\nAs a consequence, the Augur contract recognizes MarketFactory as a trustedSender and executes a transferFrom from the victim’s address, to the market’s address, of as much tokens as the attacker set. The victim then loses all CASH tokens approved to Augur, which were freely moved by the attacker to the newly created market.\n\nTo prevent this scenario, the necessary restrictions must be implemented in the MarketFactory contract, and related unit tests must also be implemented. The bug has since been fixed in 814b390 by checking that the universe address passed into the createMarket function is a known universe, thus eliminating the possibility of it being malicious.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11498",
      "title": "[L11] Missing return value",
      "impact": "LOW",
      "content": "The [`doInitialReport` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L33) of the `WarpSync` contract is supposed to return a boolean but does not explicitly return a value. Consider including a `return` statement in the function.\n\n\n**Update**: *Fixed in [commit `8ca7638e`](https://github.com/AugurProject/augur/pull/5567/commits/8ca7638e3a259852990b492c067fd54cd9942059).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11497",
      "title": "[L10] Missing docstrings",
      "impact": "LOW",
      "content": "The [`GnosisSafeRegistry`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol), [`Affiliates`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol), [`AffiliateValidator`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol) and [`WarpSync`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol) contracts completely lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/v0.5.10/natspec-format.html) (NatSpec).\n\n\n**Update**: *Fixed in [commit `6e2c2558`](https://github.com/AugurProject/augur/pull/5567/commits/6e2c2558ba7653ca00a9e00901f7eb001df42e86). The documentation for these contracts has significantly improved.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11496",
      "title": "[L09] Missing error messages in require statements",
      "impact": "LOW",
      "content": "In the `Affiliates` contract, there is a [`require` statement without an error message](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L22).\n\n\nIn the `Market` contract, most of the `require` statements do not include error messages. The only statements with error messages can be seen in lines [135](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L135) and [210](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L210).\n\n\nConsider always including specific and informative error messages in all `require` statements.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11495",
      "title": "[L08] Ownership transfer fails silently",
      "impact": "LOW",
      "content": "The [`transferOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/libraries/Ownable.sol#L39-L44) of the `Ownable` contract returns a boolean indicating if the transfer succeeds. However, it returns `true` in all cases, even when the `_newOwner` parameter is zero and the contract’s `owner` is not updated. Consider returning `false` in this scenario.\n\n\n**Update**: *Fixed in [commit `550a6511`](https://github.com/AugurProject/augur/pull/5567/commits/550a65111b0f065717bd6c7918a4802d8cc42a21).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11494",
      "title": "[L07] Undocumented assembly blocks",
      "impact": "LOW",
      "content": "The `Proxy` and `ProxyFactory` contracts include assembly blocks. See [lines 25 to 37](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L25-L37), [58 to 60](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L58-L60), [88 to 90](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L88-L90) and [104 to 106](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L104-L106) in `ProxyFactory.sol`. Taking the first case as example, on top of the `delegatecall`-related logic found in typical proxy contracts, the assembly block intends to build a public getter for the first slot of the contract’s storage (i.e., the [`masterCopy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L8) internal state variable).\n\n\nAs this is a low-level language that is harder to parse by regular users, consider including extensive documentation regarding the rationale behind its use, clearly explaining what every single assembly instruction does. Clear documentation should make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it. As an example, refer to [OpenZeppelin’s SDK `Proxy` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/Proxy.sol#L31-L48).\n\n\nNote that the use of assembly discards several important safety features of Solidity, which may render the code more error-prone. While no issues were identified in the audited version, consider implementing thorough tests to cover all potential use cases of these contracts to programmatically ensure they behave as expected, which should also help prevent introducing regression bugs in future modifications to the code base.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11493",
      "title": "[L06] Erroneous docstrings in Proxy contract",
      "impact": "LOW",
      "content": "The [docstrings](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L19) of the `Proxy` contract’s fallback function state that the function *“forwards all transactions”*. However, transactions [with calldata equal to `0xa619486e00000000000000000000000000000000000000000000000000000000`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L28-L30) (i.e., calling a `masterCopy()` getter) will not be forwarded to the `masterCopy` address.\n\n\nConsider modifying the function’s docstrings to correctly describe its exact behavior.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11492",
      "title": "[L05] Proxy deployment using create2 does not revert upon failure",
      "impact": "LOW",
      "content": "The [`deployProxyWithNonce` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L80) of the `ProxyFactory` contract does not revert the transaction when the [`create2` operation](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L89) fails. Depending on the `initializer` payload, this [may or may not cause the transaction to fail](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L102).\n\n\nFollowing the “fail early and loudly” principle, consider reverting the transaction when the address returned by `create2` is zero. For an example, refer to [OpenZeppelin’s SDK `ProxyFactory` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol#L87-L90).\n\n\n**Update**: *Fixed in [commit `7787dba1`](https://github.com/AugurProject/augur/commit/7787dba1b0b0ba8b93e23e08be5540561c47dc6f#diff-7c400beb2b04aa551f558c2a76a864adR106).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11491",
      "title": "[L04] Different callers can deploy proxies to same address",
      "impact": "LOW",
      "content": "The [`deployProxyWithNonce` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L80) of the `ProxyFactory` contract does not use the `msg.sender` variable to [compute the salt](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L85) that is later [passed to `create2`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L89). As a consequence, two different callers can effectively deploy a proxy to the same address – potentially opening a race condition scenario should the [`saltNonce`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L79) have insufficient entropy.\n\n\nWhile this does not pose a security issue for Augur, consider either using `msg.sender` to calculate the salt or explicitly documenting this behavior in the docstrings of the `deployProxyWithNonce` function to avoid misuses. For an example of the former, refer to [OpenZeppelin’s SDK `ProxyFactory` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol#L84).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11490",
      "title": "[L03] Warp Sync market finalization not recorded nor rewarded in migrated market",
      "impact": "LOW",
      "content": "When the Warp Sync market is finalized, the [`recordMarketFinalized` function of the `WarpSync` contract is called](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L54) to [reward the transaction sender](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L62) and to [update the `data` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L63-L64) with the latest values.\n\n\nHowever, if the market is migrated to a child universe and then finalized, [a consistency check in the `notifyMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L50) will inevitably fail, thus never calling `recordMarketFinalized`. As a result, the finalization of the market is not going to be recorded in the `WarpSync` contract and the user that initiated the finalization transaction will not be rewarded.\n\n\nConsider handling the special case where a recurring market changes universe before it is finalized, or clearly documenting this behavior.\n\n\n**Update**: *Fixed in [commit `b95d70d7`](https://github.com/AugurProject/augur/pull/5567/commits/b95d70d77d8e6787abb921378f2513096bd1ad56). The WarpSync market can no longer migrate.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11489",
      "title": "[L02] Transfer of REP tokens to the zero address",
      "impact": "LOW",
      "content": "The [`transferRepBondOwnership` function of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L752) does not prevent the new owner from being the zero address.\n\n\nIn this situation, an [initial report by the designated reporter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L150) or a [fork migration](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L485) could cause a transfer of REP tokens to the zero address, thus bypassing a [restriction imposed by the `ERC777` specification](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/libraries/token/ERC777.sol#L113).\n\n\nConsider restricting the REP bond owner to non-zero addresses.\n\n\n**Update**: *Fixed in [commit `53a59728`](https://github.com/AugurProject/augur/commit/53a597281072dcede8ce917ea51b4c5b4ae6c337#diff-8ed676c60e9fab2fdbd79f09555a59be).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11488",
      "title": "[L01] GnosisSafe contract does not fully match known implementation",
      "impact": "LOW",
      "content": "Contracts in the [`GnosisSafe.sol` file](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol) do not entirely match any of the known implementations available in [Gnosis’s repository](https://github.com/gnosis/safe-contracts/tags). Augur’s `GnosisSafe` contract [claims to correspond to version 1.1.0](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L601), yet several differences with the [official 1.1.0 version](https://github.com/gnosis/safe-contracts/releases/tag/v1.1.0) were detected. Moreover, while the `GnosisSafe.sol` file [claims to have been verified in Etherscan on 2019-03-28](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L1-L3), that is the date when the `1.0.0` version of the official Gnosis Safe Multisig wallet was submitted for verification (see [code in Etherscan](https://etherscan.io/address/0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A#code). The address was taken from [Gnosis’s v1.0.0 `zos.mainnet.json`](https://github.com/gnosis/safe-contracts/blob/v1.0.0/zos.mainnet.json#L4) file).\n\n\nFollowing we detail, for each contract in `GnosisSafe.sol`, which version matches (if any):\n\n\n* [`Enum` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L8): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/Enum.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-3348d8fb93c06d96f860a6047172e36b).\n* [`EtherPaymentFallback` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L17): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/EtherPaymentFallback.sol).\n* [`Executor` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L29): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/base/Executor.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-84b2520eaabbff02363b707ce2a57d6e).\n* [`SecuredTokenTransfer` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L80): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/SecuredTokenTransfer.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-74ef60297a673a9f9dea59759a35c019)\n* [`SelfAuthorized` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L105): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/SelfAuthorized.sol).\n* [`ModuleManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L113): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/base/ModuleManager.sol), not v1.1.0.  \n\n[See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-906331fa104408184e67471856577847).\n* [`OwnerManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L209): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/OwnerManager.sol).\n* [`MasterCopy` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L370): Augur’s implementation matches [v1.0.0](https://github.com/gnosis/safe-contracts/blob/v1.0.0/contracts/common/MasterCopy.sol), not v1.1.0. [See differences between v1.0.0 and v1.1.0](https://github.com/gnosis/safe-contracts/compare/v1.0.0..v1.1.0?diff=split#diff-6e84cdd7b11e601b78f401db016ba857).\n* [`Module` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L388): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/Module.sol).\n* [`SignatureDecoder` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L408): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/common/SignatureDecoder.sol).\n* [`SafeMath` library](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L453): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/external/SafeMath.sol).\n* [`ISignatureValidatorConstants` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L514): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/interfaces/ISignatureValidator.sol#L3).\n* [`ISignatureValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L520): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/interfaces/ISignatureValidator.sol#L8).\n* [`FallbackManager` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L540): Augur’s implementation matches [v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/base/FallbackManager.sol).\n* [`GnosisSafe` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L596): Augur’s implementation does not *fully* match any of the known versions. While the [`VERSION` claims to be 1.1.0](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L601), the contract’s code does not match the [official v1.1.0](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol). The most notable modifications from v1.1.0 are:\n* A new [`checkTransaction` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L715-L737) has been defined to replace the code block in [lines 122 to 133](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L122-L133).\n* A new [`executeTransaction` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L739-L766) was defined to replace the code block in lines [135 to 148](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L135-L148).\n* A [`require` statement that checked the gas left](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L134) in the transaction [has been commented out](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L708).\n* In the `checkSignatures` function, a [`require` statement](https://github.com/gnosis/safe-contracts/blob/v1.1.0/contracts/GnosisSafe.sol#L184-L187) to validate that the `threshold` state variable (inherited from the `OwnerManager` contract) was initialized (i.e., greater than zero) [has been removed](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L800).\n\n\nNote that the `GnosisSafe.sol` file was left out of the audit’s scope. We only checked for compliance with known implementations, but did not audit Augur’s implementation to verify functionality nor security. Consider either clearly documenting the above mentioned differences to raise awareness, or implementing a known non-modified version of the GnosisSafe wallet. Should Augur choose the latter, consider using [the latest GnosisSafe version (1.1.1)](https://github.com/gnosis/safe-contracts/releases/tag/v1.1.1).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11487",
      "title": "[M04] Lack of event emission",
      "impact": "MEDIUM",
      "content": "Several functions in the code base do not emit relevant events to log their execution. In particular:\n\n\n* In the `GnosisSafeRegistry` contract, external functions [`register`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L52) and [`deRegister`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L59) do not emit events when executed.\n* In the `AffiliateValidator` contract, ownership transfer does not emit an event. The [`onTransferOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L57) has been declared but its body is empty. For consistency, consider following the pattern used in the [`onTransferOwnership` function of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L743-L745).\n* In the `WarpSync` contract, the [`recordMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L61) should emit an event whenever the `data` for the current universe [is updated](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L63-L64).\n* In the `Market` contract, the [`transferRepBondOwnership` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L752) should emit an event whenever the address in `repBondOwner` is successfully updated.\n\n\nConsider defining and emitting events whenever sensitive changes occur. This would allow effective notifications to off-chain clients about important modifications in the system.\n\n\n**Update**: *Partially fixed in [PR #5577](https://github.com/AugurProject/augur/pull/5577/files). The events have been added and logged except for the `onTransferOwnership` function of the `AffiliateValidator` contract, since the additional complexity would not be worth the gain.*",
      "summary": "\nThis bug report is about several functions in the code base that do not emit relevant events to log their execution. In particular, the `GnosisSafeRegistry` contract's external functions `register` and `deRegister` do not emit events when executed, the `AffiliateValidator` contract's ownership transfer does not emit an event, the `WarpSync` contract's `recordMarketFinalized` function should emit an event whenever the data for the current universe is updated, and the `Market` contract's `transferRepBondOwnership` function should emit an event whenever the address in `repBondOwner` is successfully updated. \n\nIt is suggested that events should be defined and emitted whenever sensitive changes occur, as this would allow effective notifications to off-chain clients about important modifications in the system. This bug has been partially fixed in PR #5577, where the events have been added and logged except for the `onTransferOwnership` function of the `AffiliateValidator` contract, as the additional complexity would not be worth the gain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11486",
      "title": "[M03] WarpSync contract may return erroneous finalization reward",
      "impact": "MEDIUM",
      "content": "The public [`getFinalizationReward` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L67) of the `WarpSync` contract is intended to retrieve the finalization reward of a given market. Internally, it calls the [`getRepReward` private function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L75) passing the end time of the market’s dispute window as an argument.\n\n\nIf `getFinalizationReward` is called when the market’s dispute window is not yet over (i.e., when `block.timestamp` is lower than `_market.getDisputeWindow().getEndTime()`), then the [unsafe arithmetic operation in line 77](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L77) will inevitably underflow. As a result, the returned amount of REP representing the finalization reward will be erroneous.\n\n\nNote that this issue does not introduce a security risk on its own. The only time the `getFinalizationReward` function is used internally by Augur is [at the `recordMarketFinalized` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/WarpSync.sol#L62), when the market’s dispute window should already be over. At this point, no underflows should occur when calculating the reward. Additionally, the `getCreationReward` function is not affected by the unsafe arithmetic operation mentioned in the previous paragraph, as any known Augur universe is expected to have a lower creation time than the current `block.timestamp`.\n\n\nYet, to prevent unexpected behaviors when querying the `getFinalizationReward` function from off-chain clients (or other functions in future changes to the code base), consider reverting the transaction when an underflow occurs. Alternatively, depending on Augur’s use cases for this getter function, consider returning zero as the REP reward when the given market’s dispute window is not yet over.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `WarpSync` contract now uses `SafeMathUint256` in all calculations.*",
      "summary": "\nThe Augur Project identified a bug in the `getFinalizationReward` function of the `WarpSync` contract. This function is intended to retrieve the finalization reward of a given market, and it calls the `getRepReward` private function passing the end time of the market’s dispute window as an argument. \n\nHowever, if `getFinalizationReward` is called when the market’s dispute window is not yet over, then an unsafe arithmetic operation in line 77 will cause an underflow, resulting in a wrong amount of REP being returned. This bug does not introduce a security risk on its own, as the only time the function is used internally by Augur is when the market’s dispute window should already be over.\n\nTo fix this bug, the Augur Project considered reverting the transaction when an underflow occurs, or returning zero as the REP reward when the given market’s dispute window is not yet over. The bug has since been fixed in PR #5564, where the `WarpSync` contract now uses `SafeMathUint256` in all calculations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11485",
      "title": "[M02] Total amount of affiliate fees not decreased after withdrawal",
      "impact": "MEDIUM",
      "content": "The [`withdrawAffiliateFees` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L390) of the `Market` contract allows anyone to trigger a withdrawal of all fees an affiliate has earned. While the corresponding affiliate fees are correctly [set to zero](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L396), the total amount of affiliate fees (tracked in the [`totalAffiliateFeesAttoCash` state variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L58)) is never decreased. As a result, all Augur markets can end up in an inconsistent state where the sum of all entries in the [`affiliateFeesAttoCash` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L67) does not exactly add up to `totalAffiliateFeesAttoCash`.\n\n\nThis issue does not pose a security risk for the Augur protocol. Still, consider always decreasing the `totalAffiliateFeesAttoCash` after a withdrawal of affiliate fees to ensure consistency and avoid breaking a relevant invariant of the `Market` contract.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). This is actually the intended behavior so `totalAffiliateFeesAttoCash` has been renamed to `totalPreFinalizationAffiliateFeesAttoCash` for clarity.*",
      "summary": "\nThis bug report concerns the `withdrawAffiliateFees` function of the `Market` contract in the Augur protocol. This function allows anyone to trigger a withdrawal of all fees an affiliate has earned. After the withdrawal, the corresponding affiliate fees are correctly set to zero. However, the total amount of affiliate fees is not decreased, and this can cause the sum of all entries in the `affiliateFeesAttoCash` mapping to not add up to the `totalAffiliateFeesAttoCash` state variable.\n\nThis bug does not pose a security risk for the Augur protocol, but it can cause inconsistencies and break a relevant invariant of the `Market` contract. To avoid this, it is recommended to always decrease the `totalAffiliateFeesAttoCash` after a withdrawal of affiliate fees.\n\nThe issue has now been fixed in pull request #5564. The `totalAffiliateFeesAttoCash` has been renamed to `totalPreFinalizationAffiliateFeesAttoCash` for clarity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11484",
      "title": "[M01] Affiliate keys can be reused",
      "impact": "MEDIUM",
      "content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, should the signer be a registered operator on multiple instances of the same `AffiliateValidator` contract, any user can take a signature intended for one contract and apply it to any other. As a consequence, any user would be able to obtain valid keys without going through the mandatory KYC process.\n\n\nDepending on the expected scenarios where multiple `AffiliateValidator` contracts share operators, it may be acceptable for the same user to reuse a key (assuming the reported **“[H03] Affiliate keys can be stolen”** issue is first addressed). Otherwise, consider including the contract’s address within the key hash to ensure the signature can only be used with the expected `AffiliateValidator` contract.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `AffiliateValidator` contract address is included within the key hash.*",
      "summary": "\nThe `addKey` function of the `AffiliateValidator` contract is used to associate a key with a user account. The key is expected to be derived from the user's KYC information and is confirmed to be signed by an operator and that the salt has not been used already. However, if the signer is a registered operator on multiple instances of the same `AffiliateValidator` contract, any user can take a signature intended for one contract and apply it to any other, allowing them to obtain valid keys without going through the mandatory KYC process. To address this issue, the contract's address is included within the key hash to ensure the signature can only be used with the expected `AffiliateValidator` contract. This bug has been fixed in PR #5564.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11483",
      "title": "[H04] User can unknowingly contribute to the wrong market outcome in forked universe",
      "impact": "HIGH",
      "content": "The `Market` contract [has a `preemptiveDisputeCrowdsourcer` variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L59) that allows users to pool funds in support of the tentative winning outcome in anticipation of a dispute. If a dispute is successful, it becomes the new tentative winning outcome and [the `preemptiveDisputeCrowdsourcer`, if it is non-zero, becomes a counter-dispute contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L239-L251) in favor of the previous outcome.\n\n\nHowever, it is possible for the `preemptiveDisputeCrowdsourcer` to (inconsistently) support an outcome that is not the current tentative winning outcome. In particular, when a different market in Augur undergoes a fork and `disavowCrowdsourcers` is called on the non-forking market, [the dispute chain is reset to the initial reporter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L477-L479) but the `preemptiveDisputeCrowdsourcer` is not reset. While the initial reporter [becomes the tentative winning outcome](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L623-L628), it may have a different payout distribution hash to the `preemptiveDisputeCrowdsourcer`.\n\n\nIn this scenario, should a user call the [`contributeToTentative` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L166) with the correct payout numerators corresponding to the tentative winning outcome, the function will eventually [call `internalContribute` with `overload` set to `true`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L176). As a consequence, the internal call to `getOrCreateDisputeCrowdsourcer` [will retrieve the (inconsistent) `preemptiveDisputeCrowdsourcer`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L402), and the user funds will be [incorrectly added to this outcome](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L203).\n\n\nConsider resetting the `preemptiveDisputeCrowdsourcer` in the `disavowCrowdsourcers` function.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `preemptiveDisputeCrowdsourcer` state variable is now is reset in the `disavowCrowdsourcers` function.*",
      "summary": "\nThis bug report describes an issue with the `Market` contract in the Augur project. The `preemptiveDisputeCrowdsourcer` variable allows users to pool funds in support of the tentative winning outcome in anticipation of a dispute. When a different market undergoes a fork and `disavowCrowdsourcers` is called on the non-forking market, the dispute chain is reset to the initial reporter but the `preemptiveDisputeCrowdsourcer` is not reset. This can lead to the `preemptiveDisputeCrowdsourcer` supporting an outcome that is not the current tentative winning outcome. If a user calls the `contributeToTentative` function with the correct payout numerators corresponding to the tentative winning outcome, the user funds will be incorrectly added to the `preemptiveDisputeCrowdsourcer` outcome.\n\nThe bug was fixed in PR #5564, where the `preemptiveDisputeCrowdsourcer` state variable was reset in the `disavowCrowdsourcers` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11482",
      "title": "[H03] Affiliate keys can be stolen",
      "impact": "HIGH",
      "content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, the signature is not cryptographically tied to the caller’s address (i.e., the `msg.sender` address). This means that an attacker can obtain the signature before it is confirmed (e.g., by reading it in a node’s public pool of pending transactions), and later call the `addKey` function to associate the stolen key with the attacker’s account. This will allow the attacker to register a valid key without going through the mandatory KYC process. Furthermore, it will also prevent the victim from using the signature.\n\n\nConsider modifying the `addKey` function of the `AffiliateValidator` contract to include the user’s address within the key hash, so as to ensure the signature can only be redeemed by the intended account.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The user’s address is included within the key hash.*",
      "summary": "\nThis bug report is about the `addKey` function of the `AffiliateValidator` contract. This function is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. However, the signature is not cryptographically tied to the caller’s address (i.e., the `msg.sender` address). This means that an attacker can obtain the signature before it is confirmed and later call the `addKey` function to associate the stolen key with the attacker’s account. This will allow the attacker to register a valid key without going through the mandatory KYC process. \n\nTo fix this issue, the `addKey` function of the `AffiliateValidator` contract was modified to include the user’s address within the key hash. This ensures that the signature can only be redeemed by the intended account. This issue has been fixed in Pull Request #5564.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11481",
      "title": "[H02] Market creators can avoid paying 20% cut of affiliate fees to traders",
      "impact": "HIGH",
      "content": "The [`recordMarketCreatorFees`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L337) function of the `Market` contract determines under which circumstances a portion of the market’s creator fees gets distributed to affiliates. When there is an affiliate associated with the `_sourceAccount` address, the fingerprint of the affiliate’s address is [compared](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L342) against the fingerprint passed as an argument. If both fingerprints match, then [the affiliate’s address is set to zero](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L344). As a result, no fees are paid to the affiliate nor the source account (who is expecting to receive 20% of the affiliate’s fees). These fees are taken from the total amount of market creator fees.\n\n\nWhen a user trading in a market has been referred by the market creator, then the market creator should receive the corresponding affiliate fees from the user’s trading operations. In this case, to avoid paying 20% of the affiliate fees to the user, the market creator can execute front-running transactions that will cause the following trading operation to pay zero fees to affiliates. Specifically, the market creator should:\n\n\n1. See in advance which fingerprint the user set when submitting the trading transaction.\n2. Front-run with a call to the [`setFingerprint` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L17), aiming to change her account’s fingerprint to the one used by the user.\n\n\nIf the front-run succeeds, then the stored fingerprint and the one submitted by the user should match. As a consequence, the execution of `recordMarketCreatorFees` will not pay the 20% of the affiliate fees to the user (because the execution would never jump into the [`if` block in lines 347 to 355](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L347-L355)). Note that this attack should only be profitable for a market creator when the amount to be paid to the user (i.e., 20% of the affiliate fees) is greater than the cost of submitting the front-running transaction to change the fingerprint.\n\n\nThis issue is related to another issue already anticipated by Augur: the fingerprint scheme is intended to prevent users from registering a different address that they control as their affiliate, but it can be easily bypassed by simply changing the fingerprint to a unique value per address. Any solution that can effectively prevent Sybil attacks (where individual users can gain an advantage by controlling multiple accounts) would typically involve identity-based schemes, such as the KYC process intended to be used with the `AffiliateValidator` contract.\n\n\nSince the fingerprint protection can be easily bypassed and it also introduces the vulnerability described here, consider removing the fingerprint mechanism entirely.\n\n\nAlternatively, one plausible course of action to be analyzed is restricting the amount of times an account can modify its fingerprint in the `Affiliates` contract. More importantly, if there are no reasons why an account should ever update its fingerprint, consider reverting all calls to the [`setFingerprint` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L17) if the caller has already registered a fingerprint in the contract.\n\n\n**Update**: *Augur has decided to accept this risk because the market creator already chooses an affiliate validation contract, as well as the market creator fees that are distributed. While we understand Augur’s stance, we keep our reservations on whether this risk should be accepted, considering that it allows market creators to avoid paying fees owed to individual traders.*",
      "summary": "\nThe bug report describes a vulnerability in the Market contract of Augur, a decentralized prediction market platform. The vulnerability allows market creators to avoid paying fees owed to individual traders by front-running transactions and changing their account's fingerprint. This is possible because the fingerprint protection can be easily bypassed and the fingerprint mechanism is not as effective at preventing Sybil attacks as an identity-based scheme. Augur has decided to accept this risk, but the report keeps reservations on whether this is the right decision.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11480",
      "title": "[H01] Malicious market can arbitrarily decide when to pay affiliate fees",
      "impact": "HIGH",
      "content": "It is possible for any user to create a malicious Augur market that can arbitrarily decide when to pay affiliate fees (including the 20% that should be directed to the source trader account).\n\n\nAny attacker can create a `Market` through the [`createMarket` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/factories/MarketFactory.sol#L27) of the `MarketFactory` contract. The `_affiliateValidator` parameter may be the address of an attacker-controlled contract implementing the [`IAffiliateValidator` interface](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/external/IAffiliateValidator.sol). This address is then [set during initialization of the `Market` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L77) without any kind of validation.\n\n\nOnce the [`recordMarketCreatorFees` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L337) of the `Market` contract is called, the `Market` contract [executes a call to the `getAndValidateReferrer` function of the `Affiliates` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L340), passing the attacker-controlled `affiliateValidator` address as the second argument. In turn, the `getAndValidateReferrer` function will [attempt to call a `validateReference` function](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L48) in the attacker-controlled `affiliateValidator` address, providing the two accounts as parameters. At this point, the attacker is in full control of the execution and can arbitrarily determine whether or not the call is successful. If it is not, then the `getAndValidateReferrer` function [will return the zero address](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Affiliates.sol#L55-L57). As a consequence, back in the `Market` contract, the [`_affiliateAddress` local variable](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L340) will be set to zero, which will [prevent paying out the trading fees to the `_sourceAccount` and accumulating affiliate fees](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/reporting/Market.sol#L347-L355).\n\n\nIt must be stressed that the decision of *if* and *when* to pay fees does not currently depend on the Augur protocol at all, but rather on arbitrary logic chosen by the creator of the market in the `affiliateValidator` address.\n\n\nTrying to prevent this attack by limiting the gas forwarded to the potentially malicious `AffiliateValidator` contract does not seem to be a complete solution. Consider putting more strict limitations on the kind of affiliate validator contract that a market creator can set. Ultimately, consider entirely disallowing market creators to set potentially malicious contracts in a market’s `affiliateValidator` address, and instead deploying and setting legitimate `AffiliateValidator` contracts programmatically during a `Market` initialization.\n\n\n**Update**: *Fixed in [commit `8e62ffe8`](https://github.com/AugurProject/augur/commit/8e62ffe80226c385d01dcb0ffc9fc1d601dd7da6). Anyone can create a new `AffiliateValidator` instance using the known contract template, and the `Market` contract ensures the specified validator is one of these instances.*",
      "summary": "\nThis bug report is about an attack vector in the Augur protocol. It is possible for any user to create a malicious Augur market that can arbitrarily decide when to pay affiliate fees, including the 20% that should be directed to the source trader account. The attack works by setting the '_affiliateValidator' parameter of the 'MarketFactory' contract to an attacker-controlled contract that implements the 'IAffiliateValidator' interface. This address is then set during initialization of the 'Market' contract without any kind of validation. \n\nWhen the 'recordMarketCreatorFees' function of the 'Market' contract is called, the 'Market' contract attempts to call a 'validateReference' function in the attacker-controlled 'affiliateValidator' address. At this point, the attacker is in full control of the execution and can arbitrarily determine whether or not the call is successful. If it is not, then the 'getAndValidateReferrer' function will return the zero address. As a consequence, the '_affiliateAddress' local variable will be set to zero, which will prevent paying out the trading fees to the '_sourceAccount' and accumulating affiliate fees. \n\nThe solution to this attack is to limit the kind of affiliate validator contract that a market creator can set, and to entirely disallow market creators to set potentially malicious contracts in a market’s 'affiliateValidator' address. This bug was fixed in commit '8e62ffe8'.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11479",
      "title": "[C01] Anyone can register backdoored wallets for any owner in GnosisSafeRegistry contract",
      "impact": "HIGH",
      "content": "The `GnosisSafeRegistry` contract is intended to be a single on-chain registry to keep track of Augur users’ Gnosis Safe Multisig wallets. The registry is expected to be called upon creation of a Gnosis Safe Multisig so that Augur can quickly look up and verify a user’s wallet. `GnosisSafeRegistry` allows users to register one or more wallets through the [`register`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L52) and [`callRegister`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L33) functions. Calls to these functions are expected to always be executed from a user-controlled Gnosis Safe Multisig wallet. Wallets are stored in the [`accountSafes` mapping](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L14) under the first address listed in the `owners` array of the `GnosisSafe` contract. As a consequence, a single owner can have multiple wallets registered in Augur’s `GnosisSafeRegistry`.\n\n\n`GnosisSafeRegistry` is implemented as a registry of proxy contracts pointing to a single known, legitimate, implementation of [`GnosisSafe`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L596). All registered proxies must:\n\n\n* Delegate to an implementation address equal to the [registry’s state variable `gnosisSafeMasterCopy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L19). This address is [queried](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L26) from the `Augur` contract during initialization of the registry.\n* Be instances of the [`Proxy`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L4) contract created through the [`ProxyFactory`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/ProxyFactory.sol#L44) contract.\n\n\nAdditionally, to further restrict the type of valid wallets, all registered wallets can only have [a single owner](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L78) and a [threshold equal to 1](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L76).\n\n\nIn spite of all described restrictions, it is possible for an attacker to register malicious Gnosis Safe Multisig wallets under any owner address. By leveraging [Gnosis Safe modules](https://github.com/gnosis/safe-modules), an attacker can craft, deploy and register Gnosis wallets with any owner address and modules attached. Complying with all requirements programmatically enforced by Augur’s registry, these wallets would appear to be legitimate and victim-controlled, but would actually contain a malicious backdoor that would give the attacker unrestricted control over it. This undermines the fundamental assumption of the `GnosisSafeRegistry` contract, thus it should be considered a critical vulnerability. A step-by-step proof-of-concept exploit of this vulnerability can be found [in this private repository](https://github.com/OpenZeppelin/exploit-augur-gnosis-safe-registry).\n\n\nAt least two sensitive attack vectors have been identified:\n\n\n* **For a user that has never registered a wallet in the registry:** an attacker can simply register a wallet with the victim’s address as its owner and perform actions through the wallet. To minimize unexpected side-effects, they could front-run a legitimate transaction intending to register a wallet. Upon querying the registry with the [`getSafe`](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafeRegistry.sol#L82) function, the victim would see a valid wallet registered under her address (and she would even be its sole owner). However, this wallet would have attached an attacker-controlled module that would grant the attacker unrestricted privileges over it. Thus, as [module actions do not require owners’ signatures](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L165-L178), the attacker would be able to trigger any kind of transactions *from* the wallet without requiring confirmation from its owner (i.e., the victim).\n* **For a user that has already registered a wallet in the registry:** an attacker could deploy and register a wallet with the victim’s address as its owner. This wallet would be registered under the victim’s address in the registry, but would end up in the queue of the victim’s registered wallets. Only after de-registering her first wallet would the victim find out that there is another wallet registered under her address. Were she to start using it (as she would be its listed owner), the attacker would be able leverage the backdoor to execute malicious actions from it.\n\n\nIn both cases the attack leverages the fact that Augur’s registry tracks wallets under their owner addresses. As explained, in Gnosis Safe Multisig wallets with malicious modules attached, addresses listed as owners can be easily controlled by an attacker. Consider implementing further restrictions to prevent any attacker to register backdoored wallets for any owner address in Augur’s registry. As starting points to be further analyzed by Augur’s development team, we suggest:\n\n\n* Further restricting the type of Gnosis Safe Multisig wallets that can be registered to only those *without* modules attached. This property can be checked by querying the [`getModules` public getter](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/GnosisSafe.sol#L182).\n* Ensuring the caller of the registry’s `register` and `callRegister` functions is the address listed in the `owners` array of the `GnosisSafe` contract. This can be checked by requiring the owner’s signature or a transaction signed by the owner address.\n\n\n**Update**: *Fixed in [commit `7787dba1`](https://github.com/AugurProject/augur/commit/7787dba1b0b0ba8b93e23e08be5540561c47dc6f). Now only Gnosis Safe Multisig wallets deployed with known parameters and no modules can be registered.*",
      "summary": "\nThe GnosisSafeRegistry contract is a single on-chain registry that keeps track of Augur users’ Gnosis Safe Multisig wallets. It is called upon creation of a Gnosis Safe Multisig so that Augur can quickly look up and verify a user’s wallet. The wallets are stored in the `accountSafes` mapping under the first address listed in the `owners` array of the `GnosisSafe` contract. There are restrictions in place to ensure that only wallets with a single owner and a threshold of 1 can be registered.\n\nUnfortunately, it is possible for an attacker to register malicious Gnosis Safe Multisig wallets under any owner address. By leveraging Gnosis Safe modules, an attacker can craft, deploy and register wallets with any owner address and modules attached that comply with all requirements enforced by Augur’s registry. These wallets would appear to be legitimate and victim-controlled, but would actually contain a malicious backdoor that would give the attacker unrestricted control over it.\n\nAt least two sensitive attack vectors have been identified. For a user that has never registered a wallet in the registry, an attacker can simply register a wallet with the victim’s address as its owner and perform actions through the wallet. For a user that has already registered a wallet in the registry, an attacker could deploy and register a wallet with the victim’s address as its owner.\n\nTo prevent any attacker from registering backdoored wallets for any owner address in Augur’s registry, Augur’s development team should consider implementing further restrictions. Suggestions include further restricting the type of Gnosis Safe Multisig wallets that can be registered to only those without modules attached, and ensuring the caller of the registry’s `register` and `callRegister` functions is the address listed in the `owners` array of the `GnosisSafe` contract.\n\nThis vulnerability has been fixed in commit `7787dba1`. Now only Gnosis Safe Multisig wallets deployed with known parameters and no modules can be registered.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Augur Core v2 Audit: Components",
      "source_link": "https://blog.openzeppelin.com/augur-core-v2-audit-components/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}