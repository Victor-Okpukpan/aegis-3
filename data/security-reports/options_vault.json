{
  "category": "Options Vault",
  "total_findings": 689,
  "fetched_at": "2026-01-29T12:55:00Z",
  "findings": [
    {
      "id": "64690",
      "title": "[L-05] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n## [I-01] Burned UUIDs Can Be Re-Minted\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `RWA.mint(...)` assigns a `uuid` to each token and enforces uniqueness by tracking `_usedUUIDs[uuid]` (context).\n\nHowever, all burn paths (`burn(...)`, `burnForRedemption(...)`, `burnForSellback(...)`) delete `_usedUUIDs[uuid]`, making the UUID available for reuse (problem).\n\nThis means the on-chain guarantee is “no two _currently existing_ tokens share a UUID”, not “a UUID is unique forever”. If off-chain systems treat `uuid` as a permanent physical-asset identifier, UUID reuse can lead to confusion or allow re-issuance of previously redeemed assets without an explicit re-deposit workflow (impact).\n\n## Location of Affected Code\n\nFile: [sRWA.sol#L140-L152](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L140-L152)\n\n```solidity\nfunction mint(address to, string calldata uuid) external onlyRole(MINTER_ROLE) nonReentrant whenNotPaused {\n    // code\n    if (_usedUUIDs[uuid]) revert UUIDAlreadyExists();\n    // code\n    _tokenUUID[tokenId] = uuid;\n    _usedUUIDs[uuid] = true;\n    _safeMint(to, tokenId);\n}\n```\n\nFile: [sRWA.sol#L200-L207](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L200-L207)\n\n```solidity\nfunction burnForRedemption(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    string memory uuid = _tokenUUID[tokenId];\n    // @audit UUID becomes reusable after burn\n    delete _usedUUIDs[uuid];\n    delete _tokenUUID[tokenId];\n    _burn(tokenId);\n}\n```\n\n## Impact\n\nUUID uniqueness is not permanent.\n\n## Proof of Concept\n\n1. Admin mints a token with `uuid = \"UUID-123\"`.\n2. Owner calls `burnForRedemption(tokenId)`.\n3. Admin mints a new token again with `uuid = \"UUID-123\"`; the mint succeeds because `_usedUUIDs[\"UUID-123\"]` was deleted.\n\n## Recommendation\n\nDecide which uniqueness guarantee is required:\n\n- If UUID must be globally unique forever, **do not delete** `_usedUUIDs[uuid]` on burn.\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] Redundant `usedSignatures` Tracking Alongside Nonce-Based Replay Protection\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` and `RWA` apply two replay protections to EIP-712 signatures:\n\n- Per-user `nonces[user]` included in the signed payload and incremented on success.\n- A global `usedSignatures[digest]` mapping.\n\nFor these flows, the nonce already prevents replay for the same sender: after a successful call, the contract computes the digest using `nonce + 1`, so the old signature no longer verifies. As a result, `usedSignatures` is largely redundant and adds an extra storage write.\n\nNote: `Treasury.transferWithSignature(...)` does not include a nonce, so `usedSignatures` (or adding a nonce/salt) is required there to prevent replay until `validUntil`.\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n- `usedSignatures[digest]` check + write in signature validation paths\n- `nonces[msg.sender]++` performed after successful validation\n\nFile: [Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n- Signature payload lacks a nonce; `usedSignatures` provides replay protection until `validUntil`\n\n## Impact\n\nEach successful signature-based call in `PawnShop`/`RWA` incurs an extra `SSTORE` for `usedSignatures[digest]`.\n\n## Recommendation\n\nIn `PawnShop` and `RWA`, remove `usedSignatures` and rely on nonces for replay protection.\n\n## Team Response\n\nFixed.\n\n## [I-03] Configuration Mismatch Risk Across `backendSigner` and `treasury` Addresses\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe system relies on coordinated configuration across three separate contracts:\n\n- `PawnShop` validates a backend signature (`pawnSignature`) using its own `backendSigner`.\n- `RWA` validates a backend signature (`sellbackSignature`) using its own `backendSigner`.\n- `Treasury` validates a backend signature (`treasurySignature`) using _its_ `backendSigner`, and also requires the caller to be allowlisted.\n\nThese settings are each managed independently via admin setters (context).\n\nHowever, there is no on-chain enforcement that these configuration values remain consistent (problem).\n\nThis means a simple operational misconfiguration (e.g., updating `PawnShop.backendSigner` but not `Treasury.backendSigner`, or pointing `PawnShop.treasury` at the wrong address) can halt core flows like `pawn(...)` and `burnForSellback(...)` (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\naddress public backendSigner;\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\n## Impact\n\nMismatched signers or wrong treasury addresses cause signature checks or external calls to revert, halting user actions.\n\n## Proof of Concept\n\n1. Admin updates `PawnShop.backendSigner` to a new key.\n2. Admin forgets to update `Treasury.backendSigner`.\n3. Users can no longer successfully call `pawn(...)` because the pawn signature and treasury signature are validated against different signer keys across contracts.\n\n## Recommendation\n\nUse a **single configuration source of truth**, e.g. a registry contract that stores `backendSigner`/`treasury` addresses read by all modules.\n\n## Team Response\n\nAcknowledged.\n\n## [I-04] PawnShop `MAX_LOAN_AMOUNT` Can Exceed Treasury\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` validates offers up to its hard cap `MAX_LOAN_AMOUNT = 1_000_000 * 10**6`, but the funding path `Treasury.transferWithSignature(...)` applies a per-call limit from `contractTransferLimits[msg.sender]` (defaulting to `maxTransferPerCall = 100_000 * 10**6` when unset).\n\nAs a result, `PawnShop` can accept and sign offers up to 1,000,000 USDC that will deterministically revert in Treasury for amounts above 100,000 USDC unless the transfer limit is explicitly raised.\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L62](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L62)\n\n```solidity\n// max loan is 1 million usdc\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\nmapping(address => uint256) public contractTransferLimits;\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nfunction transferWithSignature(address recipient, uint256 amount, uint256 validUntil, bytes32 operationHash, bytes calldata signature) external nonReentrant whenNotPaused {\n    // code\n    uint256 limit = contractTransferLimits[msg.sender];\n    if (limit == type(uint256).max) limit = maxTransferPerCall;\n\n    if (amount > limit) revert AmountExceedsMaxTransfer();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n    // code\n}\n```\n\n## Impact\n\nUsers can waste gas on offers that pass `PawnShop` checks but fail funding.\n\n## Recommendation\n\nAlign the constraints:\n\n- Either lower `PawnShop.MAX_LOAN_AMOUNT` to match the effective Treasury limit, or\n- Raise/configure `Treasury.maxTransferPerCall` / `contractTransferLimits[PawnShop]` to support the intended max loan.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64689",
      "title": "[L-04] Admin Can Drain Treasury Reserves via `withdrawUSDC()`",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `Treasury` contract is the central pool of USDC that the system uses to fund `PawnShop.pawn(...)` loans and `RWA.burnForSellback(...)` buybacks (context).\n\nHowever, `Treasury.withdrawUSDC(...)` allows `DEFAULT_ADMIN_ROLE` to transfer arbitrary amounts of USDC to an arbitrary address, with no on-chain constraints.\n\nThis means an admin can fully drain user/protocol reserves and render core flows insolvent, effectively enabling a rug pull where the admin can steal all Treasury funds while users have NFTs locked in active pawn positions.\n\n## Location of Affected Code\n\nFile: [Treasure.sol#L167-L174](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol#L167-L174)\n\n```solidity\nfunction withdrawUSDC(address to, uint256 amount) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Admin can withdraw the entire USDC reserve at any time\n    if (to == address(0)) revert InvalidAddress();\n    if (amount == 0) revert InvalidAmount();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n\n    usdc.safeTransfer(to, amount);\n    emit USDCWithdrawn(to, amount);\n}\n```\n\n## Impact\n\nThe vulnerability enables direct fund loss as the admin can transfer all USDC out of the Treasury, leading to protocol insolvency where drained reserves cause signature-authorized payouts to fail due to insufficient balance, halting both `pawn(...)` and sellback flows. This effectively creates a rug pull scenario where the admin can drain all Treasury reserves while users have NFTs locked in active pawn positions, leaving users unable to access new loans and completely compromising the protocol's solvency.\n\n## Proof of Concept\n\n1. `Treasury` holds USDC reserves for loans and buybacks.\n2. Admin calls `withdrawUSDC(admin, usdc.balanceOf(address(treasury)))`.\n3. `Treasury` becomes empty; future payouts revert due to `InsufficientBalance()`.\n\n## Recommendation\n\nAllow a rescue token functionality with no USDC withdrawal or keep a track of the protocol's funds and only allow to sweep the dust.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64688",
      "title": "[L-04] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64687",
      "title": "[L-03] `permit()` Can Approve a Blacklisted Spender (Missing Blacklist Check) But approve() Does Not Allow",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`RWA` enforces blacklist restrictions in `approve()` / `setApprovalForAll()` by reverting when the target operator/spender is blacklisted.\n\nHowever, the gasless approval path `permit()` does **not** validate `_isBlacklisted[spender]` and directly calls `_approve(spender, ...)`.\nAs a result, a blacklisted address can become the current `getApproved(tokenId)` via `permit()`, even though `approve()` would revert.\n\nNote: the blacklisted spender still cannot execute `transferFrom()` while blacklisted because `_update()` reverts when `auth` (caller) is blacklisted.\nSo this is primarily a **policy bypass / inconsistency** (and potential UX/integration/compliance confusion), not an immediate theft vector by itself.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nfunction permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n  // code\n   _approve(spender, tokenId, owner); // missing: if (_isBlacklisted[spender]) revert Blacklisted();\n}\n\nfunction approve(address to, uint256 tokenId) public virtual override {\n   if (_isBlacklisted[to]) revert Blacklisted(); // blacklist enforced here\n   super.approve(to, tokenId);\n}\n```\n\n## Impact\n\nA blacklisted address can still appear as the approved spender for a token (`getApproved(tokenId)`), despite the blacklist policy.\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Permit_Allows_BlacklistedSpender_ToBeApproved() public {\n    /**\n     * POC: `RWA.permit()` does NOT check `_isBlacklisted[spender]`, unlike `approve()`.\n     *\n     * Expected blacklist policy (as implemented in approve()):\n     * - You should NOT be able to approve a blacklisted spender.\n     *\n     * Actual behavior:\n     * - `approve(blacklisted, tokenId)` reverts,\n     * - but `permit(blacklisted, tokenId, ...)` succeeds and sets `getApproved(tokenId) == blacklisted`.\n     *\n     * Note: the blacklisted spender still cannot transfer (blocked by `_update()`'s `auth` blacklist check),\n     * so the impact is mainly \"policy bypass / inconsistent approval state\".\n     */\n    address blacklistedSpender = makeAddr(\"blacklistedSpender\");\n    address relayer = makeAddr(\"relayer\");\n    address receiver = makeAddr(\"receiver\");\n\n    // Mint a fresh token to `owner` (we have ownerPk so we can sign permits).\n    vm.startPrank(owner);\n    rwa.mint(owner, \"PERMIT-BLACKLIST\");\n    uint256 tokenId = rwa.nextTokenId() - 1;\n\n    // Admin blacklists the spender.\n    rwa.blacklistContract(blacklistedSpender);\n    assertTrue(rwa.isBlacklisted(blacklistedSpender));\n\n    // Baseline: normal approve() respects blacklist and reverts.\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.approve(blacklistedSpender, tokenId);\n    vm.stopPrank();\n\n    // Build an EIP-712 permit approving the blacklisted spender.\n    uint256 nonce = rwa.nonces(owner);\n    uint256 deadline = block.timestamp + 1 hours;\n    (uint8 v, bytes32 r, bytes32 s) = _signPermit(ownerPk, blacklistedSpender, tokenId, nonce, deadline);\n\n    // Anyone can submit the permit (gasless approval). Use a relayer for clarity.\n    vm.prank(relayer);\n    rwa.permit(blacklistedSpender, tokenId, deadline, v, r, s);\n\n    // Approval state is now set to a blacklisted address (policy bypass).\n    assertEq(rwa.getApproved(tokenId), blacklistedSpender);\n\n    // Even though approved, the blacklisted spender cannot transfer due to `_update()` reverting on `auth` blacklist.\n    vm.prank(blacklistedSpender);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.transferFrom(owner, receiver, tokenId);\n}\n```\n\n## Recommendation\n\nConsider adding the same blacklist enforcement to `permit()` as `approve()`:\n\n- `if (spender != address(0) && _isBlacklisted[spender]) revert Blacklisted();`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64686",
      "title": "[L-02] Hardcoded 6-decimal Stablecoin Assumptions Brick Protocol on 18-decimal Deployments",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nNote: this issue is valid if the protocol deploys in chains like BSC\n\n1. In the BSC chain, a stable coin with $8B in circulation has 18 decimals: [address](https://bscscan.com/token/0x55d398326f99059ff775485246999027b3197955)\n2. Search other stablecoins, here at https://bscscan.com/tokens. They are mostly of 18 decimals\n\nMultiple core parameters are hardcoded as if the payment token (\"USDC\") always uses **6 decimals** (multiplying by `10**6`).\nIf the deployed payment token uses **18 decimals** (common for stables on some chains), these constants become off by 10^12,\ncausing critical functionality to revert or enforce meaningless limits.\n\nSpecifically:\n\n- `PawnShop.MAX_LOAN_AMOUNT` is expressed in 6-decimal units, so any realistic 18-decimal loan amount becomes “too high” and reverts.\n- `RWA.MIN_SELLBACK_AMOUNT` is intended to represent “1 USDC”, but on 18 decimals, it becomes dust, so the minimum sellback policy is not enforced.\n- `Treasury.maxTransferPerCall` defaults to a 6-decimal unit limit, so `transferWithSignature()` reverts for normal 18-decimal amounts until an admin updates the value.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n\nif (offerAmount == 0 || offerAmount > MAX_LOAN_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MIN_SELLBACK_AMOUNT = 1 * 10**6;\n\nif (usdcAmount < MIN_SELLBACK_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nif (limit == type(uint256).max) limit = maxTransferPerCall;\nif (amount > limit) revert AmountExceedsMaxTransfer();\n```\n\n## Impact\n\n- **Protocol bricking on 18-decimals deployments**: borrowers cannot take “normal” loans because `pawn()` reverts with `InvalidAmount()` for realistic values.\n- **Broken economic constraint**: `MIN_SELLBACK_AMOUNT` no longer enforces “minimum 1 token”; users can sell back for dust amounts if the backend signs it.\n- **Operational failure risk**: Treasury payouts revert with `AmountExceedsMaxTransfer()` until `maxTransferPerCall` is manually updated.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_18DecimalsStable_Hardcoded1e6_Assumptions_BrickOrBreakLimits() public {\n    /**\n     * This POC demonstrates a real deployment hazard:\n     * the protocol hardcodes several \"USDC has 6 decimals\" constants (x * 10**6),\n     * but many chains/tokens (e.g. BSC stables) use 18 decimals.\n     *\n     * In THIS test suite, `MockUSDC` inherits OpenZeppelin `ERC20`, which uses 18 decimals by default.\n     * So amounts like 1e18 represent \"1 whole token\", while 1e6 represents \"0.000000000001 token\".\n     *\n     * We prove all 3 issues in one flow:\n     *  (1) PawnShop.MAX_LOAN_AMOUNT is set to 1_000_000 * 1e6 (6-decimal units).\n     *      With an 18-decimal token, even a 1-token loan (1e18) is > MAX_LOAN_AMOUNT and reverts.\n     *  (2) RWA.MIN_SELLBACK_AMOUNT is set to 1 * 1e6, intended to mean \"1 USDC\".\n     *      With an 18-decimal token, this is dust (1e-12 token), so the \"min 1 token\" policy is not enforced.\n     *  (3) Treasury.maxTransferPerCall defaults to 100_000 * 1e6, also 6-decimals units.\n     *      With an 18-decimal token, even a 1-token payout exceeds the limit until the admin updates it.\n     */\n    assertEq(usdc.decimals(), 18);\n\n    // 1 whole token in base units for an 18-decimal ERC20.\n    uint256 oneToken = 1e18;\n\n    /* =============================================================\n     * (1) PawnShop MAX_LOAN_AMOUNT bricks normal loans on 18-decimals.\n     * ============================================================= */\n    {\n        uint256 tokenId = 1;\n\n        // MAX_LOAN_AMOUNT is 1_000_000 * 1e6 = 1e12 base units.\n        // On an 18-decimal token, 1e12 base units is only 0.000001 token.\n        assertEq(pawnShop.MAX_LOAN_AMOUNT(), 1_000_000 * 10**6);\n        assertGt(oneToken, pawnShop.MAX_LOAN_AMOUNT());\n\n        // Even with valid signatures, the call reverts before signature verification due to the hardcoded max amount.\n        PawnCall memory c = _buildPawnCall(user, tokenId, 7, oneToken, block.timestamp + 1 hours);\n\n        // Approve first (this should succeed). Then prove the pawn() itself is bricked by the hardcoded MAX_LOAN_AMOUNT.\n        vm.prank(user);\n        rwa.approve(address(pawnShop), tokenId);\n\n        vm.expectRevert(PawnShop.InvalidAmount.selector);\n        _pawnWithCall(user, c, false);\n\n        // Sanity: pawn reverted, so the NFT was not transferred.\n        assertEq(rwa.ownerOf(tokenId), user);\n    }\n\n    /* =============================================================\n     * (2) RWA MIN_SELLBACK_AMOUNT becomes dust on 18-decimal tokens.\n     * ============================================================= */\n    uint256 userBalBeforeSell = usdc.balanceOf(user);\n    {\n        uint256 tokenId = 1;\n        uint256 sellAmount = rwa.MIN_SELLBACK_AMOUNT(); // 1 * 1e6 base units\n        assertEq(sellAmount, 1 * 10**6);\n\n        // On 18 decimals, this is far less than 1 whole token, so the intended \"min 1 token\" policy is not enforced.\n        assertLt(sellAmount, oneToken);\n\n        uint256 validUntil = block.timestamp + 1 hours;\n        uint256 nonce = rwa.nonces(user);\n        bytes memory sellSig = _signSellback(backendPk, tokenId, sellAmount, validUntil, nonce);\n        bytes32 opHash = keccak256(abi.encode(\"SELLBACK\", tokenId, sellAmount, nonce, user));\n        bytes memory treasSig = _signTreasury(backendPk, user, sellAmount, validUntil, opHash);\n\n        // This succeeds because `sellAmount` >= MIN_SELLBACK_AMOUNT (even though it's dust in 18-decimal terms).\n        vm.prank(user);\n        rwa.burnForSellback(tokenId, sellAmount, validUntil, sellSig, treasSig);\n\n        assertEq(usdc.balanceOf(user), userBalBeforeSell + sellAmount);\n        vm.expectRevert();\n        rwa.ownerOf(tokenId); // tokenId 1 is burned\n    }\n\n    /* =============================================================\n     * (3) Treasury maxTransferPerCall is also 6-decimals by default.\n     * ============================================================= */\n    {\n        // Create a new approved contract so we can call `transferWithSignature` from an authorized sender.\n        TreasurySigReplayer replayer;\n        vm.startPrank(owner);\n        replayer = new TreasurySigReplayer(treasury);\n        treasury.approveContractForTransfers(address(replayer));\n        vm.stopPrank();\n\n        // Try a \"normal\" 1-token payout.\n        uint256 validUntil = block.timestamp + 1 hours;\n        bytes32 opHash = keccak256(\"POC_TREASURY_LIMIT_18_DECIMALS\");\n        bytes memory sig = _signTreasury(backendPk, user, oneToken, validUntil, opHash);\n\n        // This fails because Treasury defaults to maxTransferPerCall = 100_000 * 1e6 (6-decimals units).\n        // In 18-decimal terms, that limit is tiny, so even 1 token exceeds it.\n        assertEq(treasury.maxTransferPerCall(), 100_000 * 10**6);\n        assertGt(oneToken, treasury.maxTransferPerCall());\n\n        vm.expectRevert(Treasury.AmountExceedsMaxTransfer.selector);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n\n        // Admin can \"fix\" this after deployment by updating the limit to 18-decimal units,\n        // e.g. 100_000 tokens = 100_000 * 1e18.\n        vm.startPrank(owner);\n        treasury.setMaxTransferPerCall(100_000 * oneToken);\n        // Fund Treasury so the post-fix payout doesn't fail the balance check.\n        usdc.mint(address(treasury), oneToken);\n        vm.stopPrank();\n\n        uint256 userBalBeforePayout = usdc.balanceOf(user);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n        assertEq(usdc.balanceOf(user), userBalBeforePayout + oneToken);\n    }\n}\n```\n\n## Recommendation\n\n- Remove `10**6` hardcoding for the payment token.\n- Make thresholds **decimals-aware** by :\n  - **Passing `tokenDecimals` / `unit` as a constructor parameter**\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64685",
      "title": "[L-01] Pawn Duration Not Bound to Signed Quote Allows 7↔30-day Term Tampering",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` verifies an EIP-712 signature over `(tokenId, offerAmount, validUntil, nonce)` but `pawn()` accepts a user-supplied `durationDays` that is **not signed**.\nThis lets a borrower reuse the _same_ backend+treasury signatures while swapping duration terms:\n\n#### (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n\nImpact (max severity scenario):\n\n- If your backend/risk engine prices or approves offers differently per duration (common),\n  a borrower can bypass that policy by choosing the more favourable term on-chain.\n\n#### (Case 2): The backend intended a 30-day loan, but the borrower executed it as a 7-day loan.\n\nImpact:\n\n- Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n- If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\n// durationDays is NOT part of the signed struct\nbytes32 private constant PAWN_TYPEHASH =\n    keccak256(\"Pawn(uint256 tokenId,uint256 offerAmount,uint256 validUntil,uint256 nonce)\");\n\nbytes32 structHash = keccak256(\n   abi.encode(\n       PAWN_TYPEHASH,\n       tokenId,\n       offerAmount,\n       validUntil,\n       usedNonce\n   )\n);\n\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata, bytes calldata) external {\n    // durationDays controls fee + deadline, but is not authenticated by signatures\n    uint16 fee = durationDays == 7 ? fee7Days : fee30Days;\n    uint256 deadline = block.timestamp + (durationDays * 1 days);\n\n    // Treasury signature is also not bound to durationDays\n    bytes32 operationHash = keccak256(abi.encode(\"PAWN\", tokenId, offerAmount, currentNonce, msg.sender));\n}\n```\n\n## Impact\n\n- **7 → 30**: borrower can extend repayment window / delay liquidation from 7 to 30 days while using a quote intended for 7 days (bypasses duration-based risk approval; increases exposure + liquidity risk).\n- **30 → 7**: borrower can execute as 7 days to pay the lower fee schedule (protocol revenue loss + bypasses duration-based pricing).\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Pawn_DurationNotSigned_AllowsExtending7DayQuoteTo30Days() public {\n    /**\n     * POC (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n     *\n     * Root cause:\n     * - `PawnShop`'s EIP-712 signature (`PAWN_TYPEHASH`) does NOT commit to `durationDays` (or `deadline`).\n     * - The Treasury `operationHash` also does NOT commit to `durationDays`.\n     * Therefore, the exact same signatures are valid for BOTH `durationDays=7` and `durationDays=30`.\n     *\n     * Impact (max severity scenario):\n     * - If your backend/risk engine prices or approves offers differently per duration (common),\n     *   A borrower can bypass that policy by choosing the more favourable term on-chain.\n     * - Here we demonstrate the most dangerous direction: a borrower can EXTEND the repayment window\n     *   (and liquidation delay) from 7 days to 30 days while using the same signed quote.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 validUntil = block.timestamp + 1 hours;\n\n    uint256 pawnTime = block.timestamp;\n\n    // \"Backend quote\" is represented by building signatures while expecting `durationDays=7`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 7, amount, validUntil);\n    bytes32 digest = _pawnDigest(tokenId, amount, validUntil, c.nonce);\n\n    // Borrower flips ONLY the duration parameter (not covered by the signature) to extend the loan term.\n    c.durationDays = 30;\n\n    _pawnWithCall(user, c, true);\n\n    // The loan is now a 30-day loan on-chain, despite being signed as a \"7-day quote\" off-chain.\n    (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n    assertTrue(active);\n    assertEq(deadline, pawnTime + 30 days);\n    assertEq(feeBP, pawnShop.fee30Days());\n    assertTrue(pawnShop.usedSignatures(digest));\n\n    // Demonstrate the practical consequence: borrower can wait past 7 days and still redeem.\n    // A correctly-bound 7-day loan would have expired at this point (redeem would revert).\n    vm.warp(pawnTime + 8 days);\n    (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n    // Borrower already received `amount` during `pawn()`. Mint only the fee so the redemption can succeed.\n    usdc.mint(user, fee);\n\n    vm.startPrank(user);\n    usdc.approve(address(pawnShop), totalDue);\n    pawnShop.redeem(tokenId);\n    vm.stopPrank();\n\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n\nfunction test_POC_Pawn_DurationNotSigned_AllowsUsing30DayQuoteAs7Days_ToPayLowerFee() public {\n    /**\n     * POC (Case 2): backend intended a 30-day loan, but borrower executes it as a 7-day loan.\n     *\n     * Impact:\n     * - Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n     * - If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 pawnTime = block.timestamp;\n    uint256 validUntil = pawnTime + 1 hours;\n    uint256 treasuryBal0 = usdc.balanceOf(address(treasury));\n\n    // Build signatures while the backend expects `durationDays=30`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 30, amount, validUntil);\n    // Borrower flips ONLY the duration parameter to reduce the fee schedule to the 7-day rate.\n    c.durationDays = 7;\n\n    _pawnWithCall(user, c, true);\n\n    {\n        (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n        assertTrue(active);\n        assertEq(deadline, pawnTime + 7 days);\n        assertEq(feeBP, pawnShop.fee7Days());\n    }\n    assertTrue(pawnShop.usedSignatures(_pawnDigest(tokenId, amount, validUntil, c.nonce)));\n\n    // Fee difference: 30-day fee basis points are higher than 7-day fee basis points.\n    vm.warp(pawnTime + 1 days);\n    {\n        (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n        uint256 expectedFee7 = (amount * pawnShop.fee7Days()) / 10_000;\n        assertEq(fee, expectedFee7);\n        assertTrue(((amount * pawnShop.fee30Days()) / 10_000) > expectedFee7);\n\n        // Redeem and verify Treasury only collected the lower (7-day) fee.\n        usdc.mint(user, fee);\n\n        vm.startPrank(user);\n        usdc.approve(address(pawnShop), totalDue);\n        pawnShop.redeem(tokenId);\n        vm.stopPrank();\n\n        assertEq(usdc.balanceOf(address(treasury)), treasuryBal0 + expectedFee7);\n    }\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n```\n\n## Recommendation\n\nBind the loan term to signatures by including `durationDays` (or the derived `deadline`) in the `pawn()` EIP-712 signed struct.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64684",
      "title": "[M-02] Liquidation Can Be Blocked By Pausing or Blacklisting the NFT Contract, Permanently Trapping Expired Loans",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nWhen a pawn expires, `PawnShop.liquidate(...)` closes the position by burning the escrowed NFT collateral through the NFT’s `burn(...)` function (context).\n\nHowever, in this system, the NFT is `RWA`, whose burn path is gated by `whenNotPaused`, and whose transfer/burn internals revert if the caller (`auth`) is blacklisted. This means an admin action on `RWA` (pause or blacklist) can cause `PawnShop.liquidate(...)` to revert (problem).\n\nThis traps the loan in an unrecoverable state: the borrower cannot redeem after the `deadline`, and the manager cannot liquidate, so the collateral remains stuck in `PawnShop` indefinitely (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L262-L271](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L262-L271)\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    // @audit Depends on external NFT burn rules\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L189-L197](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L189-L197)\n\n```solidity\nfunction burn(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    // code\n    _burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L270-L277](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L270-L277)\n\n```solidity\nfunction _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n    // code\n    if (auth != address(0) && _isBlacklisted[auth]) revert Blacklisted();\n    // code\n}\n```\n\n## Impact\n\n- Expired loans may become impossible to close if `RWA` is paused or if `PawnShop` is blacklisted.\n- Borrowers cannot redeem after `deadline`, so collateral can remain trapped without a clean resolution path.\n\n## Proof of Concept\n\n1. User opens a pawn via `PawnShop.pawn(...)`.\n2. Time passes beyond `deadline`.\n3. Admin pauses `RWA` (or blacklists `PawnShop` in `RWA`).\n4. Manager calls `PawnShop.liquidate(tokenId)`.\n5. The call reverts when it reaches `RWA.burn(...)`, leaving the loan stuck.\n\n## Recommendation\n\n- **Decouple liquidation from `RWA` pause/blacklist**:\n  - Allow `PawnShop` to liquidate by transferring the NFT to a protocol-controlled address if burning is blocked, or\n  - Give `PawnShop` a special role in `RWA` that can burn even when paused / not subject to blacklist, or\n  - Modify `RWA` so that pausing does not block burns initiated by the protocol liquidator.\n- Consider allowing **borrower redemption at/after deadline until liquidation occurs** to avoid “stuck forever” states.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a problem where a loan cannot be closed if the collateral used is a type of NFT called RWA and it is paused or blacklisted. This means that the borrower cannot get their collateral back and the manager cannot sell it, leaving it stuck in the system. The affected code is in the Pawn.sol and sRWA.sol files and the impact is that loans can become impossible to close and borrowers cannot get their collateral back. A proof of concept is provided and recommendations are given to decouple liquidation from RWA and to allow borrower redemption until liquidation occurs. The team has responded that the issue has been fixed.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64683",
      "title": "[M-01] Admin Can Seize Pawn Collateral via `emergencyWithdrawNFT()`",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nThe `pawn(...)` flow escrows a user’s NFT inside `PawnShop` as collateral until the user repays via `redeem(...)` or the position is closed via `liquidate(...)` (context).\n\nHowever, `PawnShop` also exposes an `emergencyWithdrawNFT(...)` function that lets `DEFAULT_ADMIN_ROLE` transfer _any_ NFT held by the contract to an arbitrary address, with no restriction that the loan is inactive and no state cleanup (problem).\n\nThis means an admin can directly steal user collateral (even for active loans) and can also permanently break the loan’s lifecycle because `redeem(...)`/`liquidate(...)` expect the contract to still own the NFT (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction emergencyWithdrawNFT(uint256 tokenId, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Can transfer active collateral to an arbitrary address\n    if (to == address(0)) revert InvalidAddress();\n    nftToken.safeTransferFrom(address(this), to, tokenId);\n    emit EmergencyNFTWithdrawn(tokenId, to);\n}\n```\n\n## Impact\n\n- **User collateral theft**: An admin can move escrowed NFTs to themselves (or any address), bypassing borrower repayment rules.\n- **Protocol/loan state corruption**: Once the NFT is moved out, `redeem(...)` cannot return collateral and `liquidate(...)` cannot burn it, leaving the `pawns[tokenId]` state effectively unresolvable.\n\n## Proof of Concept\n\n1. Alice calls `pawn(...)` and `PawnShop` escrows Alice’s NFT.\n2. Admin calls `emergencyWithdrawNFT(tokenId, admin)`.\n3. Alice can no longer redeem her NFT, and the protocol cannot liquidate it on-chain because the NFT is no longer owned by `PawnShop`.\n\n## Recommendation\n\nConsider applying the following changes:\n\n- **Restrict scope**: Only allow emergency withdrawal for NFTs that are _not_ backing an active pawn:\n  - Require `!pawns[tokenId].active`, or\n  - Only allow withdrawal to `pawns[tokenId].borrower`.\n- **Add safeguards**: Use a timelock + multisig for `DEFAULT_ADMIN_ROLE`, and consider an on-chain guardian/emergency procedure that cannot seize active collateral.\n- **Maintain invariants**: If a forced withdrawal is ever allowed, update or clear the pawn state in a way that preserves a consistent resolution path.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a bug in the `pawn()` function of the `PawnShop` contract. This function allows users to use their NFTs as collateral for a loan. However, the contract also has an `emergencyWithdrawNFT()` function that can be used by the admin to transfer any NFT held by the contract to an arbitrary address, even if the loan is still active. This means that the admin can steal user collateral and break the loan's lifecycle. The affected code can be found in the `Pawn.sol` file. The impact of this bug includes user collateral theft and protocol/loan state corruption. The report also provides a proof of concept and recommendations for fixing the bug, which the team has already addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64682",
      "title": "[H-02] Blacklisted Operators Can Not Be Revoked from Being an Operator",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nNFTs can be stolen by the blacklisted operators. They can then burn/sell afterwards.\nImpact is high, as the victim NFT owner cannot revoke the approval from this balcaklisted operator because of this line below\n\nRoot cause :\n\n- `sRWA::setApprovalForAll(account, false)` reverts if account is blacklisted\n- `sRWA::approve()` can be called by blacklisted operators.\n\nFile: [sRWA.sol#L280](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L280)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n>>>  if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n```\n\nIn `sRWA.sol`:\n\n1. A router exists, and a user who owns 10 NFTs sets it as his operator by calling `setApprovalForAll(router, true)`.\n2. The admin decides to blacklist this operator address (router) by calling `blacklistContract(router)` (e.g., due to OFAC/rogue).\n3. The user attempts to revoke the operator by calling `setApprovalForAll(router, false)`, but it reverts in line 301 below. (Issue 1)\n4. The rogue (now blacklisted) operator calls `approve(rogue operator's new unblacklisted account, victim owner's tokenId)`.\n5. Once approved, the attacker pulls those tokens via `transferFrom(victim owner, new unblacklisted account, victim owner's tokenId)`, and now the attacker owns them.\n6. Check line 389 of ERC721 below. It allows operators to assign new approvals for each token id\n\n## Location of Affected Code\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n     if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n\n function approve(address to, uint256 tokenId) public virtual override {\n     if (_isBlacklisted[to]) revert Blacklisted();\n     super.approve(to, tokenId);\n }\n```\n\nFile: [contracts/token/ERC721/ERC721.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol)\n\n```solidity\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n   // Avoid reading the owner unless necessary\n   if (emitEvent || auth != address(0)) {\n       address owner = _requireOwned(tokenId);\n\n       // We do not use _isAuthorized because single-token approvals should not be able to call approve\n>>>    if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n           revert ERC721InvalidApprover(auth);\n       }\n\n       if (emitEvent) {\n           emit Approval(owner, to, tokenId);\n       }\n   }\n\n   _tokenApprovals[tokenId] = to;\n}\n```\n\n## Impact\n\nUsers who previously granted `setApprovalForAll(router, true)` can have their NFTs stolen after the router is blacklisted, because:\n\n- The user cannot revoke the operator approval.\n- The blacklisted operator can still delegate approvals to an unblacklisted attacker, who can then transfer the NFTs.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_BlacklistedOperator_CannotBeRevoked_AndCanStealViaApprove() public {\n    address router = makeAddr(\"router\");\n    address attacker = makeAddr(\"attacker\");\n\n    // Mint 9 more tokens so `user` owns 10 NFTs total (tokenIds 1..10)\n    vm.startPrank(owner);\n    rwa.mint(user, \"UUID-124\");\n    rwa.mint(user, \"UUID-125\");\n    rwa.mint(user, \"UUID-126\");\n    rwa.mint(user, \"UUID-127\");\n    rwa.mint(user, \"UUID-128\");\n    rwa.mint(user, \"UUID-129\");\n    rwa.mint(user, \"UUID-130\");\n    rwa.mint(user, \"UUID-131\");\n    rwa.mint(user, \"UUID-132\");\n    vm.stopPrank();\n\n    // 1) user makes router an operator\n    vm.prank(user);\n    rwa.setApprovalForAll(router, true);\n    assertTrue(rwa.isApprovedForAll(user, router));\n\n    // 2) admin blacklists the operator/router address\n    vm.prank(owner);\n    rwa.blacklistContract(router);\n    assertTrue(rwa.isBlacklisted(router));\n\n    // 3) user attempts to revoke operator approval, but it reverts\n    vm.prank(user);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.setApprovalForAll(router, false);\n\n    // 4) blacklisted router approves an unblacklisted attacker for each tokenId\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(router);\n        rwa.approve(attacker, tokenId);\n        assertEq(rwa.getApproved(tokenId), attacker);\n    }\n\n    // 5) attacker pulls the tokens and becomes the owner\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(attacker);\n        rwa.transferFrom(user, attacker, tokenId);\n        assertEq(rwa.ownerOf(tokenId), attacker);\n    }\n}\n```\n\n## Recommendation\n\n1. Allow revocation even if the operator is blacklisted (only block when setting `approved == true`).\n2. Block blacklisted callers from managing approvals (e.g., revert in `approve()` and `setApprovalForAll()` when `msg.sender` is blacklisted), so a blacklisted operator cannot delegate approvals to an unblacklisted attacker.\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```diff\nfunction approve(address to, uint256 tokenId) public virtual override {\n+  if (_isBlacklisted[msg.sender]) revert Blacklisted();\n   if (_isBlacklisted[to]) revert Blacklisted();\n      super.approve(to, tokenId);\n   }\n}\n\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n-     if (_isBlacklisted[operator]) revert Blacklisted();\n+     if (_isBlacklisted[operator] && approved == true) revert Blacklisted();\n         super.setApprovalForAll(operator, approved);\n      }\n}\n```\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThis bug report discusses a problem with NFTs (non-fungible tokens) being stolen by blacklisted operators. These operators are able to burn or sell the NFTs after stealing them. The severity of this issue is high as the victim NFT owner cannot revoke the approval from the blacklisted operator. The root cause of this issue is that the code does not allow for revocation if the operator is blacklisted. Additionally, the blacklisted operator is able to call a function that allows them to delegate approvals to an unblacklisted attacker, who can then steal the NFTs. The affected code can be found in the files sRWA.sol and ERC721.sol. A proof of concept has been provided to demonstrate how this bug can be exploited. The recommendation is to allow for revocation even if the operator is blacklisted and to block blacklisted callers from managing approvals. The team has responded that they have fixed the issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64681",
      "title": "[H-01] Protocol Insolvency Risk Due to Lack of On-Chain Oracle",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nThe protocol’s solvency relies on an off-chain `backendSigner` to determine the loan principal (`offerAmount`) without any on-chain verification of collateral value or an on-chain “unhealthy position” liquidation path. As a result, the protocol can become undercollateralized during the loan term (or even at origination if the signed offer is incorrect), while liquidation is only possible after a time-based deadline.\n\nIn volatile markets, this design can systematically create bad debt and drain protocol reserves.\n\n### Technical Details\n\n1. `offerAmount` is trusted without on-chain valuation checks\n\n`Pawn.pawn()` accepts `offerAmount` from a signature and stores it as the pawn principal. There is no on-chain mechanism to validate that the loan-to-value (LTV) is within safe limits at the time of origination. Protocol takes care of it off-chain.\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata pawnSignature, bytes calldata treasurySignature) external nonReentrant whenNotPaused {\n    // code\n    (bytes32 digest, uint256 currentNonce) = _validatePawnSignature(\n        tokenId,\n        offerAmount,\n        validUntil,\n        pawnSignature\n    );\n    // code\n    pawns[tokenId] = Pawn({\n        borrower: msg.sender,\n        amount: offerAmount,\n        deadline: deadline,\n        feeBasisPoints: fee,\n        active: true\n    });\n    // code\n}\n```\n\n2. Liquidation is strictly time-based (no health-factor liquidation)\n\n`Pawn.liquidate()` can only be executed after the pawn deadline. Even if the collateral value collapses during the term, the protocol cannot liquidate early to preserve solvency.\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n\n    // Liquidation is only possible after the time-based deadline\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n    emit TokenLiquidated(tokenId, msg.sender);\n}\n```\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n## Impact\n\nIf the collateral value drops below the loan principal during the loan term, rational borrowers are incentivized to default. The protocol then realizes a loss equal to:\n\n`Bad Debt = (Principal + Accrued Fees) - Collateral Value at recovery`\n\nPractical consequences:\n\n- **Protocol insolvency / reserve depletion:** USDC can be paid out against collateral that later becomes insufficient.\n- **Systemic bad debt:** The issue is not limited to one position; it is a structural failure mode whenever the signed `offerAmount` exceeds safe LTV or market prices fall during the term.\n- **Limited mitigation after the fact:** Because liquidation burns the token (claiming the underlying asset), the protocol is effectively forced to “take delivery” at an unfavourable valuation, crystallising losses.\n\n## Proof of Concept\n\n1. An RWA token represents a physical gold bar worth 2,000 USDC.\n2. The backend signs a loan offer for 1,800 USDC (90% LTV) due to error, stale pricing, or sudden market movement.\n3. The next day, gold drops 20% and the collateral value becomes 1,600 USDC.\n4. The protocol cannot liquidate because `block.timestamp < deadline`.\n5. The borrower rationally defaults because repayment exceeds collateral value.\n6. At `deadline`, the protocol liquidates and ends up recovering an asset worth ~1,600 USDC after having lent 1,800 USDC (excluding fees).\n7. Net loss is ~200 USDC (plus any additional loss due to fees/realization costs).\n\n## Recommendations\n\n### A) Enforce origination LTV on-chain\n\nIntegrate an on-chain pricing source for the underlying collateral and enforce a maximum LTV at pawn creation.\n\n```solidity\nuint256 collateralValue = oracle.getPrice(tokenId); // must define units + decimals\nrequire(offerAmount <= (collateralValue * MAX_LTV_BPS) / 10_000, \"LTV too high\");\n```\n\nMinimum requirements for a robust Oracle integration:\n\n- Staleness checks (e.g., revert if price is older than a configured threshold).\n- Consistent units/decimals normalization.\n- Clear fallback behavior when the oracle is unavailable.\n\n### B) Add health-factor-based liquidation during the term\n\nImplement a liquidation condition that triggers when the position becomes undercollateralized (e.g., collateral value falls below a liquidation threshold). This can allow liquidation before the `deadline` and materially reduce bad debt.\n\n### C) If an oracle is not feasible, reduce trust in the backend signer\n\nIf on-chain pricing is not currently possible, consider compensating controls (still weaker than an oracle), such as:\n\n- Very conservative LTV caps hard-coded on-chain per asset class.\n- Shorter maximum loan durations.\n- Emergency controls to halt new pawns when pricing is uncertain.\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "\nThe bug report identifies a high-risk issue in a protocol that could lead to insolvency and bad debt. The protocol relies on an off-chain `backendSigner` to determine the loan amount without any on-chain verification, which can result in undercollateralization. Additionally, liquidation is only possible after a time-based deadline, which could lead to losses in volatile markets. The affected code is located in the `Pawn.sol` file. The impact of this bug includes protocol insolvency, systemic bad debt, and limited mitigation options. A proof of concept is presented, and recommendations are made to address the issue, including enforcing on-chain verification of collateral value, implementing health-factor-based liquidation, or reducing trust in the backend signer. The team has acknowledged the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "63000",
      "title": "Storage read optimizations",
      "impact": "GAS",
      "content": "**Description:**\n1. [`AccountableOpenTerm::_calculateRequiredLiquidity`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L642-L655): `vault` and `_scaleFactor` can be cached. Also consider changing so that `_calculateRequiredLiquidity` takes `address vault_` as a parameter. That would allow to cache the   `vault` read in the [`_isDelinquent`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L492-L497), [`_getAvailableLiquidity`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L658-L663), [`_borrowable`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L518-L523) and [`_validateLiquidityForTermChange`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L526-L533) flows as well.\n\n2. [`AccountableOpenTerm::_getAvailableLiquidityForProcessing`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L666-L671): `vault` can be cached. Also consider same as above, add `address vault_` as a parameter, then use a cached value from [`_processAvailableWithdrawals`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L536-L570).\n\n3. [`AccountableOpenTerm::_penaltyFee`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L587-L599), use the cached value `gracePeriod` on [L595](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L595)\n\n4. [`AccountableOpenTerm::supply`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L238-L244): `vault` can be cached\n\n5. [`AccountableOpenTerm::repay`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L260-L272): `vault` can be cached.\n\n6. [`AccountableFixedTerm::_sharePrice`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableFixedTerm.sol#L533-L540): `loanState` can be cached.\n\n7. [`AccountableStrategy::acceptBorrowerRole`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableStrategy.sol#L181-L189): Use `msg.sender` instead of `pendingBorrower` on [L185](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableStrategy.sol#L185) and instead of `borrower` on [L188](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableStrategy.sol#L188)\n\n8. [`AccountableStrategy::_requireLoanNotOngoing`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableStrategy.sol#L474-L476): `loanState` can be cached.\n\n9. [`AccountableStrategy::_requireLoanOngoing`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableStrategy.sol#L479-L481): `loanState` can be cached.\n\n10. [AccountableWithdrawalQueue::_push](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/queue/AccountableWithdrawalQueue.sol#L82-L84): Set `_queue.nextRequestId` to `1` at construction and remove the if to save a read each `_push`.\n\n11. [`AccountableAsyncRedeemVault::redeem`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L155-L156): `state.redeemPrice` can be cached\n\n12. [`AccountableAsyncRedeemVault::withdraw`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L176-L177): `state.withdrawPrice` can be cached.\n\n13. [`AccountableAsyncRedeemVault::_updateRedeemState`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L197-L201): `state.maxWithdraw` and `state.redeemShares` can be cached.\n\n14. [`AccountableAsyncRedeemVault::_fulfillRedeemRequest`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L305-L326): `state.pendingRedeemRequest`, `state.maxWithdraw` and `state.redeemShares` can be cached.\n\n15. [`AccountableAsyncRedeemVault::maxRedeem`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L352-L356) and [AccountableAsyncRedeemVault::maxWithdraw](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/AccountableAsyncRedeemVault.sol#L359-L363): Can be rewritten as:\n    ```solidity\n    function maxWithdraw(address receiver) public view override returns (uint256 maxAssets) {\n        VaultState storage state = _vaultStates[receiver];\n        maxAssets = state.maxWithdraw;\n        if (state.redeemShares == 0) return 0;\n    }\n    ```\n\n16. [`Authorizable::_verify`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/access/Authorizable.sol#L47-L75): `signer` can be cached.\n\n17. [`RewardsDistributorMerkle::acceptRoot`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/rewards/RewardsDistributorMerkle.sol#L67-L68): `_pendingRoot.validAt` can be cached.\n\n18. [`RewardsDistributorMerkle::claim`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/rewards/RewardsDistributorMerkle.sol#L100-L102): `claimed[account][asset])` can be cached\n\n19. [`RewardsDistributorStrategy::claim`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/rewards/RewardsDistributorStrategy.sol#L40-L42): `claimed[account][asset])` can be cached\n\n\n**Accountable:** Most fixed in commit [`8e1cfa2`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/8e1cfa29de4dc4b0198e26e59acb56e7c929dbcf)\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62999",
      "title": "State changes without events",
      "impact": "LOW",
      "content": "There are state variable changes in this function but no event is emitted. Consider emitting an event to enable offchain indexers to track the changes.\n\n- [Line: 47](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/modules/GlobalRegistry.sol#L47)\n\n\t```solidity\n\t    function setSecurityAdmin(address securityAdmin_) external onlyOwner {\n\t```\n\n- [Line: 53](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/modules/GlobalRegistry.sol#L53)\n\n\t```solidity\n\t    function setOperationsAdmin(address operationsAdmin_) external onlyOwner {\n\t```\n\n- [Line: 59](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/modules/GlobalRegistry.sol#L59)\n\n\t```solidity\n\t    function setTreasury(address treasury_) external onlyOwner {\n\t```\n\n- [Line: 65](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/modules/GlobalRegistry.sol#L65)\n\n\t```solidity\n\t    function setVaultFactory(address vaultFactory_) external onlyOwner {\n\t```\n\n- [Line: 71](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/modules/GlobalRegistry.sol#L71)\n\n\t```solidity\n\t    function setRewardsFactory(address rewardsFactory_) external onlyOwner {\n\t```\n\n**Accountable:** Fixed in commit [`13600f4`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/13600f460f9796f16d151d19dc4a1d5c35c1475d)\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62998",
      "title": "Unused errors",
      "impact": "LOW",
      "content": "The following errors in) `https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol` are unused. Consider using or removing the unused error.\n\n\n- [Line: 15](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L15) `error InvalidVerifier();`\n\n- [Line: 18](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L18) `error InvalidExpiration();`\n\n- [Line: 27](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L27) `error UnauthorizedOwnerOrReceiver();`\n\n- [Line: 30](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L30) `error UnauthorizedController();`\n\n- [Line: 45](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L45) `error AccountAlreadyVerified();`\n\n- [Line: 49](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L49) `error NotAdminOrOperator(address account);`\n\n- [Line: 52](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L52) `error Paused(address account);`\n\n- [Line: 59](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L59) `error CancelDepositRequestPending();`\n\n- [Line: 65](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L65) `error DepositRequestWasCancelled();`\n\n- [Line: 71](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L71) `error ExceedsDepositLimit();`\n\n- [Line: 89](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L89) `error NoDepositRequest();`\n\n- [Line: 95](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L95) `error NoPendingDepositRequest();`\n\n- [Line: 101](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L101) `error NoCancelDepositRequest();`\n\n- [Line: 113](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L113) `error ProposalExpired();`\n\n- [Line: 116](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L116) `error NoPendingProposal();`\n\n- [Line: 122](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L122) `error AlreadyInQueue();`\n\n- [Line: 141](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L141) `error LoanAlreadyAccepted();`\n\n- [Line: 153](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L153) `error LoanInDefault();`\n\n- [Line: 162](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L162) `error LoanNotAcceptedByBorrower();`\n\n- [Line: 168](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L168) `error ZeroSharePrice();`\n\n- [Line: 177](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L177) `error LoanNotRepaid();`\n\n- [Line: 186](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L186) `error PaymentNotDue();`\n\n- [Line: 192](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L192) `error RequestDepositFailed();`\n\n- [Line: 195](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L195) `error RequestRedeemFailed();`\n\n- [Line: 210](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L210) `error BorrowerNotSet();`\n\n- [Line: 213](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L213) `error PriceOracleNotSet();`\n\n- [Line: 216](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/constants/Errors.sol#L216) `error RewardsDistributorNotSet();`\n\n**Accountable:** Errors removed in commit [`18ce919`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/18ce919d1771bdb0951e3601c667e5608957122c)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62997",
      "title": "`nonReentrant` is not the first modifier",
      "impact": "LOW",
      "content": "**Description:** In `FeeManager::withdrawProtocolFee`, `nonReentrant` is not the first modifier. To protect against reentrancy in other modifiers, the `nonReentrant` modifier should be the first modifier in the list of modifiers. Consider putting `nonReentrant` first for consistent reentrancy protection.\n\n**Accountable:** Fixed in commit [`c7f31b5`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/c7f31b51fc1bfb4fe96450a189751f6f72d8274d)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62996",
      "title": "ERC20 zero amount transfer rejection",
      "impact": "LOW",
      "content": "**Description:** The `_checkTransfer` function reverts on zero-amount transfers, violating ERC-20 standard which mandates that transfers of 0 values [MUST be treated](https://eips.ethereum.org/EIPS/eip-20#transfer) as normal transfers.\n\n**Impact:** Violation of `eip20_transferSupportZeroAmount` and `eip20_transferFromSupportZeroAmount`.\n\n**Proof of Concept:** ❌ Violated: https://prover.certora.com/output/52567/9c9c3c73f4d64f9baf1284ced4f4a8f5/?anonymousKey=160f0b0d10e3f688f1981708e4aa3819e7023a80\n\n```solidity\n// EIP20-06: Verify transfer() handles zero amount transfers correctly\n// EIP-20: \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\nrule eip20_transferSupportZeroAmount(env e, address to, uint256 amount) {\n\n    setup(e);\n\n    // Perform transfer\n    transfer(e, to, amount);\n\n    // Zero amount transfers must succeed\n    satisfy(amount == 0);\n}\n\n// EIP20-09: Verify transferFrom() handles zero amount transfers correctly\n// EIP-20: \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\nrule eip20_transferFromSupportZeroAmount(env e, address from, address to, uint256 amount) {\n\n    setup(e);\n\n    // Perform the transferFrom\n    transferFrom(e, from, to, amount);\n\n    // Zero amount transferFrom must succeed\n    satisfy(amount == 0);\n}\n```\n\n✅ Verified after the fix: https://prover.certora.com/output/52567/0babf2c2b4da49ec87cc0ae00036b0e7/?anonymousKey=21b1c4b60901ee2fea0115aa8a1b0e621c04bfaa\n\n**Recommended Mitigation:**\n```diff\ndiff --git a/credit-vaults-internal/src/vault/AccountableVault.sol b/credit-vaults-internal/src/vault/AccountableVault.sol\nindex 629b6d0..fb3676a 100644\n--- a/credit-vaults-internal/src/vault/AccountableVault.sol\n+++ b/credit-vaults-internal/src/vault/AccountableVault.sol\n@@ -141,7 +141,8 @@ abstract contract AccountableVault is IAccountableVault, ERC20, AccessBase {\n\n     /// @dev Checks transfer restrictions before executing the underlying transfer\n     function _checkTransfer(uint256 amount, address from, address to) private {\n-        if (amount == 0) revert ZeroAmount();\n+        // @certora FIX for eip20_transferSupportZeroAmount and eip20_transferFromSupportZeroAmount\n+        // if (amount == 0) revert ZeroAmount();\n         if (!transferableShares) revert SharesNotTransferable();\n         if (!isVerified(to, msg.data)) revert Unauthorized();\n         if (throttledTransfers[from] > block.timestamp) revert TransferCooldown();\n```\n\n**Accountable:** Fixed in commit [`e90d3de`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/e90d3de5c133c73f0e783d552bb4e256400a547c)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62995",
      "title": "Incorrect event emission is possible in `AccountableAsyncRedeemVault::cancelRedeemRequest` flows",
      "impact": "LOW",
      "content": "**Description:** `cancelRedeemRequest()` takes \"requestID\" as input, but it is never used and never validated to be associated with the input controller address.\n\nAll cancellation flows (immediate/ async) work with the requestID of the controller address stored in `_requestIds[controller]`, but the input requestID is only used for event data in `CancelRedeemRequest()` and `CancelRedeemClaimable()` events.\n\nBecause this is never verified, caller can input any requestID and have it emitted in the events.\n\n**Impact:** Incorrect event emission is possible, potentially leading to data corruption for the frontend and anyone else using this event data.\n\n**Recommended Mitigation:** Remove the \"requestID\" parameter from the `cancelRedeemRequest()` function definition and simply use the existing requestID of the controller in event emission.\n\n**Accountable:** Fixed in commits [`aa64491`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/aa64491b1ebe68375793efbc961a323ea739f58c) and [`0675c3d`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/0675c3de2f4eae3456470f04a2241c8f60255088).\n\n**Cyfrin:** Verified. The redeem request of the controller is now used.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62994",
      "title": "Violations of ERC7540 specs",
      "impact": "LOW",
      "content": "**Description:** Several deviations from the ERC7540 specs have been noticed for `AccountableAsyncRedeemVault`\n\n1. According to [ERC-7540](https://eips.ethereum.org/EIPS/eip-7540) specification:\n\n> Redeem Request approval of shares for a msg.sender NOT equal to owner may come either from ERC-20 approval over the shares of owner or if the owner has approved the msg.sender as an operator.\n\nThe current implementation in `requestRedeem()` only supports operator approval (from owner to caller). The contract does not implement the ERC-20 allowance path for share approval, limiting the request redeem functionality to only operator-approved addresses.\n\n2. As per the EIP,\n\n> All requests with the same requestID MUST transition from Pending to Claimable state at the same time, and receive the same exchange rate\n\nThis means the request should always gets processed in full. Right now, the vault implementation allows partial redemptions and that too at different share prices (if processingMode == CurrentPrice).\n\n\n**Impact:** Non-compliance with ERC7540.\n\n**Recommended Mitigation:** Consider documenting if the vault is intended to be completely compliant with the EIP, and if so, consider changing the implementation accordingly.\n\n**Accountable:** We acknowledge this as it's not our intention to be 100% compliant, we will document this.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62993",
      "title": "Consider enforcing a minimum deposit amount",
      "impact": "LOW",
      "content": "The vault/strategy accepts arbitrarily small deposits (down to 1 wei). While functionally correct, dust deposits are effectively useless for legitimate users (since the gas to call `deposit` often exceeds the value deposited) and can be abused by adversaries to abuse rounding edge cases.\n\nTo remove a possible attack vector for black hats, consider enforcing a `minimumDepositAmount`.\n\n**Accountable:** Fixed in [`b9edb2b`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/b9edb2bf071db803fbd16460411688207aedc85d)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62992",
      "title": "Consider consistently use `Ownable2Step`",
      "impact": "LOW",
      "content": "**Description:** Currently some contracts use just Ownable, consider have all contracts use Ownable2Step to prevent accidental ownership loss.\n\n\n**Accontable:**\nFixed in commit [`be75091`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/be7509165d468fd19bf48bab3fa87e565412a5b6)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62991",
      "title": "Prevent accidental ownership and admin renouncement",
      "impact": "LOW",
      "content": "**Description:** The inherited `renounceOwnership()` and allow the last authority to remove themselves, potentially leaving the contract permanently ownerless or admin‑less, blocking critical functions.\n\nConsider override `renounceOwnership()` in `TokenAirdrop` to always revert.\n\n**Accountable:** Fixed in commit [`be75091`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/be7509165d468fd19bf48bab3fa87e565412a5b6)\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62990",
      "title": "Deployment script requires unencrypted private key",
      "impact": "LOW",
      "content": "**Description:** The deployment scripts [`FactoryScript.s.sol`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/script/FactoryScript.s.sol) and [`FeeManagerScript.s.sol`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/script/FeeManagerScript.s.sol) requires a private key to be stored in clear text as an environment variable:\n\n```solidity\nuint256 deployerPk = vm.envUint(\"DEPLOYER_TESTNET_PK\");\n```\n\nStoring private keys in plain text represents an operational security risk, as it increases the chance of accidental exposure through version control, misconfigured backups, or compromised developer machines.\n\nA more secure approach is to use Foundry’s [wallet management features](https://getfoundry.sh/forge/reference/script/), which allow encrypted key storage. For example, a private key can be imported into a local keystore using [`cast`](https://getfoundry.sh/cast/reference/wallet/import/):\n\n```bash\ncast wallet import deployerKey --interactive\n```\n\nThis key can then be referenced securely during deployment:\n\n```bash\nforge script script/Deploy.s.sol:DeployScript \\\n    --rpc-url \"$RPC_URL\" \\\n    --broadcast \\\n    --account deployerKey \\\n    --sender <address associated with deployerKey> \\\n    -vvv\n```\nAnd used just with `vm.startBroadcast()`:\n```solidity\nvm.startBroadcast();\n\n...\n\nvm.stopBroadcast();\n```\n\nFor additional guidance, see [this explanation video](https://www.youtube.com/watch?v=VQe7cIpaE54) by Patrick.\n\n**Accountable:** Fixed in commit [`79d8cfd`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/79d8cfd8dee652adb0964ade05280a745cedb3b3)\n\n**Cyfrin:** Verified. Deploy scripts now don't require a private key in clear text.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62989",
      "title": "`Authorizable::_verify` should use EIP-712 typed structured data hashing",
      "impact": "LOW",
      "content": "**Description:** [`Authorizable::_verify`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/access/Authorizable.sol#L46-L78) signs ad-hoc payloads that include `chainId`, but the flow is not [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed-data compliant. This limits wallet UX/visibility and interoperability and mixes domain data (`chainId`) with message data.\n\n**Impact:** Users are more susceptible to ambiguous signing prompts; weaker ecosystem compatibility; harder audits/upgrades; higher risk of encoding/packing mistakes and replay bugs across contracts or chains.\n\n**Recommended mitigation:**\nAdopt EIP-712 and move `chainId` to the domain separator (remove it from the struct). Keep the existing intent of the message:\n\n* **Domain:** `{ name: \"Authorizable\", version: \"1\", chainId, verifyingContract: address(this) }`.\n* **Typed struct (no chainId inside):**\n\n  ```solidity\n  struct TxAuthData {\n      bytes   functionCallData;   // selector + encoded args\n      address contractAddress;    // target contract (can be redundant with domain; decide and document)\n      address account;            // controller / signer subject\n      uint256 nonce;              // per-account nonce\n      uint256 blockExpiration;    // deadline\n  }\n\n  bytes32 constant TXAUTH_TYPEHASH = keccak256(\n      \"TxAuthData(bytes functionCallData,address contractAddress,address account,uint256 nonce,uint256 blockExpiration)\"\n  );\n  ```\n* **Hashing & verify (using OZ EIP712 + SignatureChecker):**\n\n  ```solidity\n  bytes32 structHash = keccak256(abi.encode(\n      TXAUTH_TYPEHASH,\n      keccak256(txAuth.functionCallData), // hash dynamic bytes\n      txAuth.contractAddress,\n      txAuth.account,\n      txAuth.nonce,\n      txAuth.blockExpiration\n  ));\n  bytes32 digest = _hashTypedDataV4(structHash);\n  require(\n      SignatureChecker.isValidSignatureNow(signer, digest, signature),\n      \"INVALID_SIGNATURE\"\n  );\n  ```\n**Accountable:** Fixed in commit [`70cd486`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/70cd4863e3bef0f80f2eeb012c79a801c099fc7e)\n\n**Cyfrin:** Verified. EIP-712 typed data is now used for the signatures.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62988",
      "title": "Reserved assets could be extracted from the Vault",
      "impact": "LOW",
      "content": "**Description:** Some strategy functions can release assets without checking if those assets are part of `reservedLiquidity`. `AccountableFixedTerm._loan.drawableFunds` is not verified to be in sync with the queue `reservedLiquidity`. Hence the borrower can inadvertently borrow more funds than they should.\n\n**Impact:** The vault can become insolvent by releasing funds needed to honor a withdrawal.\n\n**Proof of Concept:** Violated in `FixedTerm.acceptLoanLocked(), FixedTerm.borrow(), FixedTerm.pay(), FixedTerm.acceptLoanDynamic(), FixedTerm.claimInterest()`: https://prover.certora.com/output/52567/edb399a43d1849a9b22f027e66b17924/?anonymousKey=3dcf62dfa004381083966b3639b6a485fa2e9501\n\n```solidity\n// Reserved liquidity must not exceed total assets\ninvariant reservedLiquidityBacked(env e)\n    ghostReservedLiquidity256 <= ghostTotalAssets256\n```\n\n**Recommended Mitigation:** When `reservedLiquidity` is increased in the withdrawal queue, this needs to be synced to the FixedTerm starategy.\n\n**Accountable:** Fixed in commit [`979c0e`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/979c0ebe4bd5860fe9b2e446f9fac2ae3919b39c).\n\nIssue was addressed to satisfy the invariant and prevent future upgrades that might allow redemptions in a FixedTerm loan, but as of right now there's no possible way to increase `reservedLiquidity` such that it is out-of-sync with`drawableFunds`.\n\nBorrowing after the loan is in a `Repaid` state cannot happen due to `_requireLoanOngoing` so any redemptions that increase `reservedLiquidity` would require a state when both depositing/borrowing is blocked.\n\n**Cyfrin:** Verified. `reservedLiquidity` is now checked in FixedTerm.",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [
        "Auditing and Logging"
      ],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62987",
      "title": "Missing controller validation in `AccountableAsyncRedeemVault::requestRedeem` allows zero address state",
      "impact": "LOW",
      "content": "**Description:** The `requestRedeem()` function fails to call `_checkController(controller)` validation, allowing the zero address to accumulate vault state.\n\n**Impact:** `zeroControllerEmptyState` violation.\n\n**Proof of Concept:** ❌ Violated: https://prover.certora.com/output/52567/acc42433123e4b289c0f84e69fa52a44/?anonymousKey=e60b3d66b5574868073bfde4218b385aa2fe5f2a\n\n```solidity\n// Zero address must have empty state for all vault fields\ninvariant zeroControllerEmptyState(env e)\n    ghostVaultStatesMaxMint256[0] == 0 &&\n    ghostVaultStatesMaxWithdraw256[0] == 0 &&\n    ghostVaultStatesDepositAssets256[0] == 0 &&\n    ghostVaultStatesRedeemShares256[0] == 0 &&\n    ghostVaultStatesDepositPrice256[0] == 0 &&\n    ghostVaultStatesMintPrice256[0] == 0 &&\n    ghostVaultStatesRedeemPrice256[0] == 0 &&\n    ghostVaultStatesWithdrawPrice256[0] == 0 &&\n    ghostVaultStatesPendingDepositRequest256[0] == 0 &&\n    ghostVaultStatesPendingRedeemRequest256[0] == 0 &&\n    ghostVaultStatesClaimableCancelDepositRequest256[0] == 0 &&\n    ghostVaultStatesClaimableCancelRedeemRequest256[0] == 0 &&\n    !ghostVaultStatesPendingCancelDepositRequest[0] &&\n    !ghostVaultStatesPendingCancelRedeemRequest[0] &&\n    ghostRequestIds128[0] == 0\nfiltered { f -> !EXCLUDED_FUNCTION(f) } { preserved with (env eFunc) { SETUP(e, eFunc); } }\n```\n\n✅ Verified after the fix: https://prover.certora.com/output/52567/f385fd34e82c4635bd410279e4da2c97/?anonymousKey=82309551a07845692bfabb2164179224523f87ba\n\n**Recommended Mitigation:**\n```diff\ndiff --git a/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol b/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\nindex 4cd0a3e..a64f47c 100644\n--- a/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\n+++ b/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\n@@ -113,6 +113,9 @@ contract AccountableAsyncRedeemVault is IAccountableAsyncRedeemVault, Accountabl\n         onlyAuth\n         returns (uint256 requestId)\n     {\n+        // @certora FIX for zeroControllerEmptyState\n+        _checkController(controller);\n+\n         _checkOperator(owner);\n         _checkShares(owner, shares);\n```\n\n**Accountable:** Fixed in commit [`e90d3de`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/e90d3de5c133c73f0e783d552bb4e256400a547c)\n\n**Cyfrin:** Verified. `checkController` added as a modifier to the function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62986",
      "title": "Upgradeable contracts which are inherited from should use ERC7201 namespaced storage layouts or storage gaps to prevent storage collisions",
      "impact": "LOW",
      "content": "**Description:** The protocol has upgradeable contracts which other contracts inherit from. These contracts should either use:\n* [ERC7201](https://eips.ethereum.org/EIPS/eip-7201) namespaced storage layouts - [example](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/AccessControlUpgradeable.sol#L60-L72)\n* storage gaps (though this is an [older and no longer preferred](https://blog.openzeppelin.com/introducing-openzeppelin-contracts-5.0#Namespaced) method)\n\nThe ideal mitigation is that all upgradeable contracts use ERC7201 namespaced storage layouts.\n\nWithout using one of the above two techniques storage collision can occur during upgrades.\n\n**Accountable:** Fixed in commit [`8422762`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/842276202616ce58cdf7d766c2792fc3752157ba)\n\n**Cyfrin:** Verified. Namespaced storage now used in `AccountableStrategy`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62985",
      "title": "Invalid `maxWithdraw()` check in `withdraw()`",
      "impact": "MEDIUM",
      "content": "**Description:** Vault incorrectly checks `maxWithdraw(receiver)` instead of `maxWithdraw(controller/owner)`.\n\n**Impact:**\n- Allows unauthorized withdrawals by exploiting the receiver's limits instead of the owner's.\n- DDoS in `withdraw()`\n\n**Proof of Concept:** ❌ Violated: https://prover.certora.com/output/52567/ef88bd2d76b74cafb175f8d026e484b3/?anonymousKey=599db11fbc5df1632ff4006c69a03f836b23fa6c\n\n```solidity\n// MUST NOT be higher than the actual maximum that would be accepted\nrule eip4626_maxWithdrawNoHigherThanActual(env e, uint256 assets, address receiver, address owner) {\n\n    setup(e);\n\n    storage init = lastStorage;\n\n    mathint limit = maxWithdraw(e, owner) at init;\n\n    withdraw@withrevert(e, assets, receiver, owner) at init;\n    bool reverted = lastReverted;\n\n    // Withdrawals above the limit must revert\n    assert(assets > limit => reverted, \"Withdraw above limit MUST revert\");\n}\n```\n\n✅ Verified after the fix: https://prover.certora.com/output/52567/8e7cfdf612d64a4cb7e5d9d9d939968e/?anonymousKey=a961467ded443bd1cab3718ca882be71f38887e9\n\n**Recommended Mitigation:**\n```diff\ndiff --git a/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol b/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\nindex a64f47c..c8824bb 100644\n--- a/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\n+++ b/credit-vaults-internal/src/vault/AccountableAsyncRedeemVault.sol\n@@ -173,7 +173,7 @@ contract AccountableAsyncRedeemVault is IAccountableAsyncRedeemVault, Accountabl\n     function withdraw(uint256 assets, address receiver, address controller) public onlyAuth returns (uint256 shares) {\n         _checkController(controller);\n         if (assets == 0) revert ZeroAmount();\n-        if (assets > maxWithdraw(receiver)) revert ExceedsMaxRedeem();\n+        if (assets > maxWithdraw(controller)) revert ExceedsMaxRedeem(); // @certora FIX for eip4626_maxWithdrawNoHigherThanActual (receiver -> controller)\n\n         VaultState storage state = _vaultStates[controller];\n         shares = _convertToShares(assets, state.withdrawPrice, Math.Rounding.Floor);\n```\n\n**Accountable:** Fixed in commit [`6dc92b0`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/6dc92b0b09e8d2e2fc01b94d41902bbf4f5fc293)\n\n**Cyfrin:** Verified. `controller` now passed to `maxWithdraw`.\n\n\\clearpage",
      "summary": "\nThe bug report is about a mistake in the code of the Vault program. The program checks for the maximum amount of money that can be withdrawn by the wrong person, which could allow unauthorized withdrawals and cause a DDoS attack. The report includes a proof of concept that shows the bug being exploited and recommends a fix for the issue. The fix has been implemented and verified by another party. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62984",
      "title": "Frequent `AccountableOpenTerm::accrueInterest` calls reduce interest accrual",
      "impact": "MEDIUM",
      "content": "**Description:** In [`AccountableOpenTerm::_linearInterest`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableOpenTerm.sol#L602-L604), interest accrual uses integer math, `_linearInterest(rate, dt) = rate * dt / DAYS_360_SECONDS`:\n```solidity\nfunction _linearInterest(uint256 interestRate, uint256 timeDelta) internal pure returns (uint256) {\n    return interestRate.mulDiv(timeDelta, DAYS_360_SECONDS);\n}\n```\n\nFor small `timeDelta`, this often rounds to zero. Yet `accrueInterest()` still sets `_accruedAt = block.timestamp` even when the computed increment is zero. Repeated calls with short intervals therefore discard elapsed time in many zero-increment slices, producing a persistently lower `_scaleFactor` than a single accrual over the same wall-clock period.\n\nFor example, for a 15% APY (150_000) you would have to call once every 207 seconds (~4 minutes):\n```\n360 days / 150_000 = 31104000 / 150_000 = 207\n```\n\n**Impact:** Any actor can repeatedly call `accrueInterest()` at short intervals to suppress interest growth. Over time this materially underpays LPs (lower share price / fewer assets owed by the borrower) and reduces protocol fee bases tied to interest. The effect compounds with call cadence and APR, creating measurable loss without needing privileged access.\n\n**Proof of Concept:** Add the following test to `AccountableOpenTerm.t.sol`:\n```solidity\nfunction test_interest_rounding_from_frequent_accrue_calls() public {\n    vm.warp(1739893670);\n\n    vm.prank(manager);\n    usdcLoan.setPendingBorrower(borrower);\n    vm.prank(borrower);\n    usdcLoan.acceptBorrowerRole();\n\n    // Use a common APR (15%) and short interval; depositPeriod = 0 to keep price logic simple.\n    LoanTerms memory terms = LoanTerms({\n        minDeposit: 0,\n        minRedeem: 0,\n        maxCapacity: USDC_AMOUNT,\n        minCapacity: USDC_AMOUNT / 2,\n        interestRate: 150_000,        // 15% APR in bps units\n        interestInterval: 30 days,\n        duration: 0,\n        depositPeriod: 0,\n        acceptGracePeriod: 0,\n        lateInterestGracePeriod: 0,\n        lateInterestPenalty: 0,\n        withdrawalPeriod: 0\n    });\n    vm.prank(manager);\n    usdcLoan.setTerms(terms);\n    vm.prank(borrower);\n    usdcLoan.acceptTerms();\n\n    // Provide principal so interest accrues on outstanding assets.\n    vm.prank(alice);\n    usdcVault.deposit(USDC_AMOUNT, alice, alice);\n\n    // Snapshot the baseline state just after start.\n    uint256 snap = vm.snapshot();\n\n    // ------------------------------------------------------------\n    // Scenario A: \"Spam accrual\" — call accrueInterest() every 12s for 1 hour.\n    // Each 12s step yields baseRate = rate * 12 / 360d ≈ 0 (integer), but _accruedAt is reset,\n    // so we lose that fractional time forever.\n    // ------------------------------------------------------------\n    uint256 step = 180;          // 3 minutes\n    uint256 total = 3600;        // 1 hour\n    uint256 n = total / step;    // 300 iterations\n\n    for (uint256 i = 0; i < n; i++) {\n        vm.warp(block.timestamp + step);\n        usdcLoan.accrueInterest(); // returns new scale but we just trigger the reset\n    }\n\n    // Capture the resulting scale factor after the spammy accrual pattern\n    uint256 sfSpam = usdcLoan.accrueInterest(); // one more call just to read the value\n\n    // ------------------------------------------------------------\n    // Scenario B: Single accrual after the same total wall-clock time.\n    // ------------------------------------------------------------\n    vm.revertTo(snap);\n    vm.warp(block.timestamp + total);\n    uint256 sfClean = usdcLoan.accrueInterest();\n\n    // Expect the spammed path to have strictly lower scale factor than the clean path.\n    assertLt(sfSpam, sfClean, \"frequent zero-delta accrual bleeds interest vs single accrual\");\n\n    // Anything more often than 207 in this case will result in no interest growth at all.\n    assertEq(sfSpam, 1e36, \"frequent accruals yield no interest growth\");\n}\n```\n\n**Recommended Mitigation:** Consider using higher precision to track interest rate. For example, 1e18 or 1e36.\n\n**Accountable:** Fixed in commit [`29c3f72`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/29c3f72ddcb73474918dc3e74a52a2dd3c247bb5)\n\n**Cyfrin:** Verified. `_linearInterest` now scales with `PRECISION`.",
      "summary": "\nThe bug report discusses an issue with the `AccountableOpenTerm::_linearInterest` function, which is used for interest accrual in the Accountable Protocol. The function uses integer math, which can result in rounding to zero for small time intervals. This means that even when there is no interest growth, the `_accruedAt` variable is still set, leading to a lower `_scaleFactor` over time. This can be exploited by anyone to suppress interest growth, resulting in lower returns for LPs and reduced protocol fees. A proof of concept test has been provided to demonstrate this issue, and a recommended mitigation is to use higher precision for tracking interest rates. The bug has been fixed in the latest commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62983",
      "title": "Auto-draw on `AccountableFixedTerm::pay` lets third parties force unwanted borrowing",
      "impact": "MEDIUM",
      "content": "In [`AccountableFixedTerm::pay`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableFixedTerm.sol#L354-L357), any positive `_loan.drawableFunds` are automatically drawn via `_updateAndRelease(drawableFunds)` before transferring the due interest/fees:\n```solidity\nuint256 drawableFunds = _loan.drawableFunds;\nif (drawableFunds > 0) {\n    _updateAndRelease(drawableFunds);\n}\n```\n\nSince `_loan.drawableFunds` increases when users deposit/mint into the vault, a third party can deposit immediately before the borrower calls `pay`. This causes `pay` to both increase `_loan.outstandingPrincipal` by the new liquidity and also add remaining-term interest on that added principal, while releasing the assets to the borrower, without borrower consent.\n\n**Impact:** Borrower loses discretion over principal size. Calling `pay` can increase debt (principal + future interest) unexpectedly. This enables griefing/economic DoS as attackers can “stuff” the vault before each payment window, repeatedly forcing draws and increasing interest payments in the future.\n\n**Recommended Mitigation:** Consider removing auto-draw from `AccountableFixedTerm::pay`. Loan increases should occur only via an explicit borrower action (e.g., `draw(uint256)`), not implicitly during interest payment.\n\n**Accountable:** Fixed in commit [`03f871b`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/03f871bfc7baff5fe5f9dfbd8a0ef74e99619e78)\n\n**Cyfrin:** Verified. \"auto-draw\" is removed from `pay`.",
      "summary": "\nThe bug report discusses an issue with the `AccountableFixedTerm` contract's `pay` function. This function automatically draws any positive drawable funds before transferring due interest or fees. However, this can lead to unexpected increases in debt for the borrower if a third party deposits funds into the vault right before the borrower calls `pay`. This can be exploited to cause griefing or economic denial of service attacks. The recommended solution is to remove the auto-draw feature from the `pay` function and only allow loan increases through explicit borrower actions. This bug has been fixed in the `03f871b` commit of the `credit-vaults-internal` repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62982",
      "title": "Withdrawal queue `RequestPrice` can be front run in case of defaults",
      "impact": "MEDIUM",
      "content": "**Description:** When `processingMode == ProcessingMode.RequestPrice` in `AccountableWithdrawalQueue`, a redeem request’s value is fixed at the request-time share price. The request is later processed potentially at a very different price.\n\n**Impact:** * Normal operation: Requesters are typically disadvantaged because price usually rises as interest accrues. Locking at request time forfeits subsequent gains.\n* Defaults: Requesters can front-run defaults by submitting withdrawals just before delinquency/default and keep the pre-default higher price, draining liquidity and pushing losses onto remaining LPs. This worsens loss socialization precisely when fairness matters most.\n\n**Recommended Mitigation:** Consider removing `ProcessingMode.RequestPrice` (and `AccountableWithdrawalQueue .processingMode` all together) so redemption value is always determined at processing time. Alternatively implement a safeguard for large price movements that will invalidate the redeem request.\n\n**Accontable:**\nFixed in commit [`4e5eef5`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/4e5eef57464d548ec09048eae27b6fcc1489a5c3)\n\n**Cyfrin:** Verified. `processingMode` removed and current price used throughout.",
      "summary": "\nThe bug report explains that when the `processingMode` is set to `ProcessingMode.RequestPrice` in the `AccountableWithdrawalQueue`, there is an issue with the redeem request's value being fixed at the time of the request. This means that the request is processed at a potentially different price, which can disadvantage requesters. This can also lead to front-running defaults and causing losses for other users. To fix this, it is recommended to remove `processingMode` or implement a safeguard for large price movements. The bug has been fixed and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62981",
      "title": "Borrower in OpenTerm loan can stay delinquent effectively forever",
      "impact": "MEDIUM",
      "content": "**Description:** Delinquency is flagged when vault reserves fall below `_calculateRequiredLiquidity()`, setting `delinquencyStartTime`. Late penalties only accrue after the grace period elapses. If the borrower briefly restores liquidity (e.g., `supply()`/`repay()`) before grace expiry, delinquency is cleared and `delinquencyStartTime` resets to 0. The borrower can immediately `borrow()` again to drop reserves to the threshold and the next block, when interest has accrued again, start a fresh grace window. This “pulse” can be executed back-to-back, even within one block, allowing the borrower to remain effectively delinquent indefinitely without ever incurring penalties.\n\n**Impact:** Borrowers can avoid late penalties while keeping lenders under-reserved, degrading lender protections.\n\n**Recommended Mitigation:** Consider removing the grace period entirely so penalties accrue as soon as the loan becomes delinquent. This would reduce complexity and be in line with how a lot of other lending protocols work.\n\nAlternatively consider redesigning the grace period to be cumulative, i.e. A year loan has a cumulative 1 week grace period which the borrower can draw from.\n\n**Accountable:** We will acknowledge this. We don't have an actionable path on how loans are managed when it comes to penalties grace periods or even whether penalties are enabled or not. Having a considerable grace period is by design and as a fallback a manager can always initiate a default. In most use-cases borrow/repay actions won't be very often and given these entities deploy funds to other venues, also off-chain, doing such actions can come with a reputational cost.",
      "summary": "\nThe report highlights a bug in the lending protocol where borrowers can avoid late penalties by briefly restoring their liquidity before the grace period expires. This allows them to remain delinquent indefinitely without incurring any penalties, which can harm lenders. The recommended solution is to either remove the grace period entirely or redesign it to be cumulative. The team responsible for the protocol will acknowledge the bug, but there is currently no clear plan on how to address it. This bug is due to the design of the protocol, where borrow/repay actions are not frequent and can come with a reputational cost.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62980",
      "title": "Fees never deducted in `AccountableOpenTerm` loan",
      "impact": "MEDIUM",
      "content": "**Description:** In `AccountableOpenTerm`, `interestData()` returns non-zero `performanceFee` and `establishmentFee`, but no path ever charges these fees. `_accrueInterest()` only updates `_scaleFactor` for base interest and none of `supply` or `repay` calls `FeeManager` (unlike FixedTerm’s `collect`). As a result, fees are never charged.\n\n**Impact:** Protocol/manager fees are effectively never taken.\n\n**Recommended Mitigation:** Consider charge the fee in `supply()`/`repay()`, before any other state changes. Compute fees for the elapsed period and transfer to `FeeManager`, then proceed.\n\n**Accountable:** Fixed in commits [`fce6961`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/fce6961c71269739ec35da60131eaf63e66e1726) and [`8e53eba`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/8e53eba7340f223f86c9c392f50b8b2d885fdd39)\n\n**Cyfrin:** Verified. `performanceFee` and `establishmentFee` are now deducted for open term loans.",
      "summary": "\nThis report describes a bug in the `AccountableOpenTerm` code. The `interestData()` function returns non-zero `performanceFee` and `establishmentFee`, but these fees are never charged. As a result, fees are effectively never taken by the protocol/manager. To fix this, the fees should be charged in the `supply()` and `repay()` functions, before any other state changes. This bug has been fixed in the commits `fce6961` and `8e53eba` by the `Accountable-Protocol` team. The bug has been verified and the fees are now correctly deducted for open term loans.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62979",
      "title": "`AccountableFixedTerm::claimInterest` unpredictable due to share burn mechanics",
      "impact": "MEDIUM",
      "content": "**Description:** [`AccountableFixedTerm::claimInterest`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/strategies/AccountableFixedTerm.sol#L215-L217) lets a lender redeem their share of already-paid interest by burning vault shares and receiving assets. The burn uses a divisor based on the full-term max net return (fixed at loan acceptance), not the interest actually funded so far:\n\n```solidity\nuint256 maxNetYield = PRECISION + _interestParams.netReturn;\nclaimedInterest = shares.mulDiv(claimableInterest, totalShares, Math.Rounding.Floor);\nuint256 usedShares = claimedInterest.mulDiv(PRECISION, maxNetYield, Math.Rounding.Ceil);\n```\n\nBecause `netReturn` is an optimistic, end-of-term figure, early claimers burn fewer shares per unit claimed, shrinking `totalSupply` and making later outcomes order- and timing-dependent. This yields unpredictable per-user results and creates a systematic advantage for early claimers, especially harmful if the loan later underperforms or defaults, where early claims are crystallized at optimistic rates and late claimers eat the shortfall.\n\nIf the loan finishes without default and everyone eventually claims, equal-share lenders converge to the same total interest.\n\n**Impact:** * Unpredictable user payouts / MEV: Two equal lenders can claim different amounts purely due to claim order; bots can claim immediately after `pay()` to improve their take.\n* Asymmetric default risk: If the loan defaults before maturity, early claimers have already extracted cash flows computed using the potential full-term net return. Late/non-claimers are left with less remaining claimable interest/recovery, creating an unfair “claim early” optimization and worsening losses for cooperative users.\n* UX / reputational risk: Users pressing “claim” cannot deterministically know the amount; outcomes can be front-run within the same interval.\n\n**Proof of Concept:** Add the following test to `AccountableFixedTerm.t.sol`:\n```solidity\nfunction test_earlyClaimerAdvantage_dueToMaxNetReturnBurn_usdc() public {\n    vm.warp(1739893670);\n\n    // Setup borrower/terms identical to other tests\n    vm.prank(manager);\n    usdcLoan.setPendingBorrower(borrower);\n\n    vm.prank(borrower);\n    usdcLoan.acceptBorrowerRole();\n\n    vm.prank(manager);\n    usdcLoan.setTerms(\n        LoanTerms({\n            minDeposit: 0,\n            minRedeem: 0,\n            maxCapacity: USDC_AMOUNT,\n            minCapacity: USDC_AMOUNT / 2,\n            interestRate: 1e5,\n            interestInterval: 30 days,\n            duration: 360 days,\n            lateInterestGracePeriod: 2 days,\n            depositPeriod: 2 days,\n            acceptGracePeriod: 0,\n            lateInterestPenalty: 5e2,\n            withdrawalPeriod: 0\n        })\n    );\n\n    // Equal deposits for Alice & Bob\n    uint256 userDeposit = USDC_AMOUNT / 2;\n\n    uint256 aliceBalanceBefore = usdc.balanceOf(alice);\n    uint256 bobBalanceBefore   = usdc.balanceOf(bob);\n\n    vm.prank(alice);\n    usdcVault.deposit(userDeposit, alice, alice);\n\n    vm.prank(bob);\n    usdcVault.deposit(userDeposit, bob, bob);\n\n    // Sanity: equal initial shares\n    assertEq(usdcVault.balanceOf(alice), userDeposit, \"alice initial shares\");\n    assertEq(usdcVault.balanceOf(bob),   userDeposit, \"bob initial shares\");\n\n    // Accept loan\n    vm.warp(block.timestamp + 3 days);\n    vm.prank(borrower);\n    usdcLoan.acceptLoanLocked();\n\n    // Fund borrower to pay interest and approve\n    usdc.mint(borrower, 2_000_000e6);\n    vm.prank(borrower);\n    usdc.approve(address(usdcLoan), 2_000_000e6);\n\n    uint256 aliceMidClaim;\n    uint256 aliceEndClaim;\n    uint256 bobEndClaim;\n\n    // Pay month by month; Alice claims once in the middle, Bob waits\n    for (uint8 i = 1; i <= 12; i++) {\n        uint256 nextDueDate = usdcLoan.loan().startTime + (i * usdcLoan.loan().interestInterval);\n        vm.warp(nextDueDate + 1 days);\n\n        // Borrower pays owed interest for this interval\n        vm.startPrank(borrower);\n        uint256 owed = _interestOwed(usdcLoan);\n        usdcLoan.pay(owed);\n        vm.stopPrank();\n\n        // Alice claims right after month 6 payment\n        if (i == 6) {\n            vm.prank(alice);\n            aliceMidClaim = usdcLoan.claimInterest();\n            assertGt(aliceMidClaim, 0, \"alice mid-term claim > 0\");\n        }\n    }\n\n    // After last payment, both can claim\n    vm.prank(alice);\n    aliceEndClaim += usdcLoan.claimInterest();\n\n    vm.prank(bob);\n    bobEndClaim += usdcLoan.claimInterest();\n\n    uint256 aliceTotal = aliceMidClaim + aliceEndClaim;\n    uint256 bobTotal   = bobEndClaim;\n\n    // Alice has gotten more than Bob by claiming early\n    assertGt(aliceTotal, bobTotal, \"Alice (mid+end) should claim more than Bob (end only)\");\n\n    // repay & clean-up\n    vm.prank(borrower);\n    usdcLoan.repay(0);\n\n    // Ensure both still redeem principal back pro-rata after interest claims\n    uint256 sharesAlice = usdcVault.balanceOf(alice);\n    uint256 sharesBob   = usdcVault.balanceOf(bob);\n\n    vm.prank(alice);\n    usdcVault.requestRedeem(sharesAlice, alice, alice);\n    vm.prank(bob);\n    usdcVault.requestRedeem(sharesBob, bob, bob);\n\n    vm.startPrank(alice);\n    uint256 maxWithdrawAlice = usdcVault.maxWithdraw(alice);\n    usdcVault.withdraw(maxWithdrawAlice, alice, alice);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    uint256 maxWithdrawBob = usdcVault.maxWithdraw(bob);\n    usdcVault.withdraw(maxWithdrawBob, bob, bob);\n    vm.stopPrank();\n\n    assertEq(usdcVault.balanceOf(alice), 0, \"alice no shares\");\n    assertEq(usdcVault.balanceOf(bob),   0, \"bob no shares\");\n\n    uint256 aliceBalanceAfter  = usdc.balanceOf(alice);\n    uint256 bobBalanceAfter    = usdc.balanceOf(bob);\n\n    uint256 aliceGain = aliceBalanceAfter - aliceBalanceBefore;\n    uint256 bobGain   = bobBalanceAfter   - bobBalanceBefore;\n\n    // Alice and Bob has gained the same in the end\n    assertEq(aliceGain, bobGain, \"alice and bob gained the same\");\n}\n```\n\n**Recommended Mitigation:** Consider replacing the share-burn with an accumulator (“rewards-per-share”) model: Maintain a high-precision `accInterestPerShare` that increases only when real net interest is paid (after fees) by `netInterest / totalShares`; each lender tracks a checkpoint of this accumulator, and on claim receives `(accCurrent − checkpoint) × shares`, then updates their checkpoint.\nIf transfers/mints/burns were ever allowed mid-loan, first settle pending interest for the party(ies) at the current accumulator and then adjust checkpoints:\n```solidity\nuint256 accInterestPerShare;\nmapping(address user => uint256 index) userIndex;\nmapping(address user => uint256 interest) pendingInterest;\n\nfunction onTransfer(address from, address to, uint256 amount) external onlyVault nonReentrant {\n\n    // Settle sender’s pending interest (if not mint)\n    if (from != address(0)) {\n        _settleAccount(from);\n        userIndex[from] = accInterestPerShare;\n    }\n\n    // Settle receiver’s pending interest (if not burn)\n    if (to != address(0)) {\n        _settleAccount(to);\n        userIndex[to] = accInterestPerShare;\n    }\n\n}\n\n/// Internal: settle one account’s pending interest using current accumulator\nfunction _settleAccount(address user) internal {\n    uint256 shares = vault.balanceOf(user);\n    uint256 idx = userIndex[user];\n\n    if (shares == 0) {\n        userIndex[user] = accInterestPerShare;\n        return;\n    }\n\n    uint256 delta  = accInterestPerShare - idx;\n    if (delta == 0) return;\n\n    pendingInterest[user] += (shares * delta) / PRECISION;\n    userIndex[user] = accInterestPerShare;\n}\n```\n\nThis makes payouts deterministic and call-order independent, distributes only actually received interest (so no “pre-claiming” future yield), and remains fair under partial payments or defaults while preserving price invariance without burning.\n\n**Accountable:** Fixed in commits [`19a50c8`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/19a50c8e1275545ae3e461233f4699cb681ec731) and [`fd74c1d`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/fd74c1d62d4b1ae8cac03f501fd398e1a6854545)\n\n**Cyfrin:** Verified. An interest accrual system is used and the vault now calls an `onTransfer`-hook on the strategy for transfers.",
      "summary": "\nThis bug report describes an issue with the `claimInterest` function in the `AccountableFixedTerm` contract. The function allows lenders to redeem their share of already-paid interest by burning vault shares and receiving assets. However, the burn uses a divisor based on the full-term max net return, rather than the actual interest funded so far. This creates an advantage for early claimers and can lead to unpredictable payouts, asymmetric default risk, and potential front-running by bots. The report suggests a mitigation by replacing the share-burn with an accumulator model, which has since been implemented in the code. The bug has been fixed in the commits `19a50c8` and `fd74c1d` by the `Accountable` team. The report has been verified by `Cyfrin`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62978",
      "title": "Manual/Instant `fulfillRedeemRequest` doesn’t reserve liquidity",
      "impact": "MEDIUM",
      "content": "**Description:** `AccountableAsyncRedeemVault` account for reserved liquidity only when processing the queue through (`AccountableWithdrawalQueue::processUpToShares` / `AccountableWithdrawalQueue::processUpToRequestId`).\nHowever, the manual fulfillment paths (`fulfillRedeemRequest`) and the instant branch of `requestRedeem` mark shares as claimable without increasing `reservedLiquidity`.\n\nWhen these paths are mixed, multiple fulfillments can each pass the “liquidity” check independently (because nothing was reserved by earlier fulfills), producing a state where:\n\n```\nsum(claimable assets across users)  >  vault.totalAssets() - reservedLiquidity\n```\n\nPotentially causing claimable assets to be larger than the available liquidity.\n\n**Impact:** The vault can end up with more claimable redemptions than available assets, causing later withdrawals to revert (depending on integration logic), and creating fairness and accounting issues between users.\n\n**Proof of Concept:** Add the following test to `AccountableWithdrawalQueue.t.sol`:\n```solidity\nfunction test_manualFulfill_vsQueuedFulfill_mismatch() public {\n    // Setup: price = 1e36, deposits for Alice & Bob\n    _setupInitialDeposits(1e36, DEPOSIT_AMOUNT);\n\n    uint256 aliceHalf = vault.balanceOf(alice) / 2;\n    uint256 bobHalf   = vault.balanceOf(bob)   / 2;\n\n    // === (A) Queue Bob first and reserve via processor ===\n    vm.prank(bob);\n    uint256 bobReqId = vault.requestRedeem(bobHalf, bob, bob);\n    assertEq(bobReqId, 1, \"Bob should be the head of the queue\");\n\n    // Processor path reserves liquidity for Bob\n    uint256 price = strategy.sharePrice(address(vault)); // 1e36\n    uint256 expectedBobAssets = (bobHalf * price) / 1e36;\n    uint256 used = vault.processUpToShares(bobHalf);\n    assertEq(used, expectedBobAssets, \"queued fulfill reserves exact assets for Bob\");\n\n    // Sanity: reservedLiquidity == Bob's claimable assets\n    uint256 reservedBefore = vault.reservedLiquidity();\n    assertEq(reservedBefore, expectedBobAssets, \"only Bob's queued path bumped reservedLiquidity\");\n\n    // === (B) Now manually fulfill Alice (no reservation bump) ===\n    vm.prank(alice);\n    uint256 aliceReqId = vault.requestRedeem(aliceHalf, alice, alice);\n    assertEq(aliceReqId, 2, \"Alice should be behind Bob in the queue\");\n\n    // Manual fulfill creates claimables but doesn't increase reservedLiquidity\n    strategy.fulfillRedeemRequest(0, address(vault), alice, aliceHalf);\n\n    // Compute claimables in assets\n    uint256 aliceClaimableShares = vault.claimableRedeemRequest(0, alice);\n    uint256 bobClaimableShares   = vault.claimableRedeemRequest(0, bob);\n    assertEq(aliceClaimableShares, aliceHalf, \"Alice claimable shares set by manual fulfill\");\n    assertEq(bobClaimableShares,   bobHalf,   \"Bob claimable shares set by queued processor\");\n\n    uint256 aliceClaimableAssets = (aliceClaimableShares * price) / 1e36;\n    uint256 bobClaimableAssets   = (bobClaimableShares   * price) / 1e36;\n    uint256 totalClaimables      = aliceClaimableAssets + bobClaimableAssets;\n\n    // Mismatch: claimables exceed reservedLiquidity because Alice's path didn't reserve\n    assertGt(totalClaimables, reservedBefore, \"claimables > reservedLiquidity (oversubscription)\");\n\n    // === (C) Bob withdraws his reserved claim → consumes all reservation ===\n    uint256 bobMax = vault.maxWithdraw(bob);\n    assertEq(bobMax, bobClaimableAssets, \"Bob can withdraw exactly his reserved amount\");\n\n    uint256 vaultAssetsBefore = vault.totalAssets();\n    vm.prank(bob);\n    vault.withdraw(bobMax, bob, bob);\n\n    // After paying Bob, reservation is zero, but Alice still has claimables (unreserved)\n    uint256 reservedAfter = vault.reservedLiquidity();\n    assertEq(reservedAfter, 0, \"all reserved liquidity consumed by Bob's withdrawal\");\n\n    uint256 aliceClaimableShares2 = vault.claimableRedeemRequest(0, alice);\n    uint256 aliceClaimableAssets2 = (aliceClaimableShares2 * price) / 1e36;\n    assertEq(aliceClaimableShares2, aliceHalf, \"Alice still has claimables (manual path)\");\n    assertGt(aliceClaimableAssets2, reservedAfter, \"manual claimables remain with zero reservation\");\n\n    // Optional sanity: vault asset balance decreased by Bob's withdrawal only\n    uint256 vaultAssetsAfter = vault.totalAssets();\n    assertEq(vaultAssetsBefore - vaultAssetsAfter, bobMax, \"vault paid only the reserved portion\");\n}\n```\n\n**Recommended Mitigation:** Consider making `_fulfillRedeemRequest` the single source of truth for reservation accounting:\n\n1. Move`reservedLiquidity` bump into `_fulfillRedeemRequest`.\n2. Remove `reservedLiquidity` increments from `processUpToShares` / `processUpToRequestId` (to avoid double counting).\n\n**Accountable:** Fixed in commit [`c3a7cbf`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/c3a7cbf0275a758a5d816c9f3298bc95d788db4f)\n\n**Cyfrin:** Verified. Recommended mitigation implemented. `reservedLiquidity` is tracked in `_fulfillRedeemRequest` and removed form the \"process\" functions.",
      "summary": "\nThe bug report describes an issue with the `AccountableAsyncRedeemVault` where the manual fulfillment and instant branch of `requestRedeem` do not properly account for reserved liquidity. This can result in multiple fulfillments passing the \"liquidity\" check independently, causing the vault to have more claimable redemptions than available assets. This can lead to later withdrawals failing and fairness and accounting issues between users. A proof of concept test is provided and a mitigation is recommended which involves making `_fulfillRedeemRequest` the single source of truth for reservation accounting. The bug has been fixed and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62977",
      "title": "InvestmentManager can use `AccountableFixedTerm::coverDefault` to misuse token approvals from anyone",
      "impact": "MEDIUM",
      "content": "**Description:** `AccountableFixedTerm::coverDefault` allows InvestmentManager of the loan to add additional assets to the system.\n\n```solidity\n    function coverDefault(uint256 assets, address provider) external onlySafetyModuleOrManager whenNotPaused {\n        _requireLoanInDefault();\n\n        loanState = LoanState.InDefaultClaims;\n\n        IAccountableVault(vault).lockAssets(assets, provider);\n\n        emit DefaultCovered(safetyModule, provider, assets);\n    }\n```\n\nAnd `lockAssets()` pulls assets from the input \"provider\" address, transferring them to the vault.\n\nThis means any user address who had asset token balance, and approved the vault contract (potential pending approvals from the past) is at risk of losing their funds here.\n\nThe Manager can pull funds from a random provider address without any permissions, and the \"provider\" would lose his approved funds without getting anything in return.\n\n**Impact:** Any pending asset approvals from user => vault contract, can be misused to cover loan default.\n\nThe same problem also exists in AccountableOpenTerm.\n\n**Recommended Mitigation:** Consider removing the \"provider\" address logic from `coverDefault()`, and simply pull assets from `msg.sender`.\n\n**Accountable:** Fixed in commit [`014d7fb`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/014d7fb6f11766fada9054a736a264cf1d95c9f6)\n\n**Cyfrin:** Verified. `provider` is removed.",
      "summary": "\nThe bug report describes an issue in the code for the `coverDefault` function in the `AccountableFixedTerm` contract. This function allows the InvestmentManager of a loan to add additional assets to the system. However, the code also allows the manager to pull assets from a random user's address without their permission, potentially resulting in the loss of their funds. This issue also exists in the `AccountableOpenTerm` contract. The report recommends removing the \"provider\" address logic and using `msg.sender` instead. The bug has been fixed in the code and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62976",
      "title": "`AccountableAsyncRedeemVault` allows deposits for non-whitelisted or non-KYCed addresses",
      "impact": "MEDIUM",
      "content": "**Description:** Almost all functions in `AccountableAsyncRedeemVault` use an `onlyAuth()` modifier to verify that the caller is KYC-ed or Whitelisted (according to the vault's own policy).\n\nThis logic can be seen in `isVerified()` function in AccessBase.sol\n\nHere is the `AccountableAsyncRedeemVault::onlyAuth` modifier :\n\n```solidity\n    modifier onlyAuth() {\n        if (!isVerified(msg.sender, msg.data)) revert Unauthorized();\n        _;\n    }\n\n```\n\nThis passes `msg.sender` as the \"Account\" address to be verified, but these checks are not working.\n\nIf we look at the `deposit()` function here, `msg.sender` is not the actual account address, for whom the deposit will be done, instead the \"receiver\" address here is the actual account. The \"Receiver\" address receives the shares but it is not verified that they are whitelisted/ KYC-ed.\n\n```solidity\n    function deposit(uint256 assets, address receiver, address controller) public onlyAuth returns (uint256 shares) {\n        _checkController(controller);\n        if (assets == 0) revert ZeroAmount();\n        if (assets > maxDeposit(controller)) revert ExceedsMaxDeposit();\n\n        uint256 price = strategy.onDeposit(address(this), assets, receiver, controller);\n        shares = _convertToShares(assets, price, Math.Rounding.Floor);\n\n        _mint(receiver, shares);\n        _deposit(controller, assets);\n\n```\n\nThis means that a KYC'ed user can call `deposit()` and mint new share tokens for random \"receiver\" addresses (who have set the KYC'ed user as their operator using `setOperator()` and for the input params `controller == receiver` can be used). This \"receiver\" can then take part in the vault by holding vault shares, redeeming them via the operator etc.\n\n**Impact:** The KYC/ Whitelist configuration does not prevent KYC’ed addresses from minting shares to non-KYCed addresses.\n\nSimilar problems might exist in the access control for other methods in the vault, the reason being `onlyAuth()` only checks the msg.sender and not the other address holding the position.\n\n**Recommended Mitigation:** Consider documenting what is the intended permissions granted to a KYC-ed/ Whitelisted user. If they should not be allowed to open positions for other non KYC-ed addresses, then the auth checks need to be done for actual receiver/ controller addresses.\n\n**Accountable:** Fixed in commits [`c804a31`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/c804a31d3e5b161065b775fa57f3590be3581e5a) and [`2eeb273`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/2eeb2736eb5ba8dafa2c9f2f458b31fd8eb2d6bf)\n\n**Cyfrin:** Verified. Both `reciever` and `controller` are verified to be KYC'd throughout the calls.",
      "summary": "\nThe bug report explains that there is an issue with the `onlyAuth()` modifier in the `AccountableAsyncRedeemVault` function. This modifier is used to verify that the caller is KYC-ed or Whitelisted, but it is not working properly. The report suggests that the problem may also exist in other parts of the vault. The recommended solution is to check for KYC-ed addresses in the actual receiver and controller addresses, instead of just the msg.sender. The bug has been fixed in the latest commits by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62975",
      "title": "`transferWhitelist` checks are missing in `AccountableVault::_checkTransfer`",
      "impact": "MEDIUM",
      "content": "**Description:** AccountableVault.sol employs a \"transferWhitelist\" feature to help select addresses that should be allowed to transfer vault shares, overriding the other restrictions checked in `_checkTransfer()`.\n\nBoth `transfer()` and `transferFrom()` functions internally call `_checkTransfer()`, but the \"transferWhitelist\" check is missing in all transfer flows.\n\n**Impact:** The transferWhitelist feature does not work, so it does not make a difference if an address was whitelisted or not.\n\n```solidity\n    /// @notice Mapping of addresses that can override transfer restrictions\n    mapping(address => bool) public transferWhitelist;\n```\n\nThe comment above says \"Mapping of addresses that can override transfer restrictions\" which does not hold true as transferWhitelist is never being checked.\n\nA method to call vault.setTransferWhitelist() is also missing in both the current strategy contracts, so when fixing keep note of it.\n\n**Recommended Mitigation:**\n```solidity\n    function _checkTransfer(uint256 amount, address from, address to) private {\n\n+++      if(transferWhitelist[from] && transferWhitelist[to]) return;\n\n        if (amount == 0) revert ZeroAmount();\n        if (!transferableShares) revert SharesNotTransferable();\n        if (!isVerified(to, msg.data)) revert Unauthorized();\n        if (throttledTransfers[from] > block.timestamp) revert TransferCooldown();\n    }\n```\n\nAlso consider adding a method to the AccountableFixedTerm and AccountableOpenTerm strategy contracts (one that calls vault.setTransferWhitelist()) if it is required in context of that strategy.\n\n**Accountable:** Whitelist removed in commit [`6a81e38`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/6a81e389513ad690216fc8c037ec69513f3121c7)\n\n**Cyfrin:** Verified. Whitelist removed.",
      "summary": "\nThe AccountableVault.sol contract has a feature called \"transferWhitelist\" that is supposed to allow certain addresses to transfer vault shares, overriding other restrictions. However, this feature is not working and is not being checked in the transfer functions. This means that the whitelist does not have any effect and any address can transfer shares. To fix this, the _checkTransfer() function needs to be updated to include a check for the transferWhitelist. Additionally, a method to set the whitelist should be added to the strategy contracts. This issue has been fixed in the Accountable contract, but it is still present in the Cyfrin contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62974",
      "title": "Complete bypass of transfer restrictions on vault share token is possible",
      "impact": "MEDIUM",
      "content": "**Description:** In `AccountableVault.sol` (which is inherited by the `AccountableAsyncRedeemVault`, we have certain transfer restrictions (KYC, if from address is subject to a throttle timestamp), applied in `_checkTransfer()` function.\n\nThese restrictions are applied on `transfer()`/ `transferFrom()` function (inherited from ERC20) when share holders try to move their holdings.\n\nThese restrictions do not apply when the internal `_transfer()` function is used, which is fine for most cases as these share tokens will be moved only for deposits and redeems.\n\nBut there is one case where user can use the `cancelRedeemRequest()` feature to bypass all these restrictions completely, and move share tokens to a different address.\n\nThis is how it can be done :\n\n- Assume controller has a deposit in the vault\n- Controller places a redeem request\n- Controller immediately cancels the redeem request\n- Controller calls `claimCancelRedeemRequest()` where share tokens are transferred to a \"receiver\" address\n\n```solidity\n   function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        public\n        onlyAuth\n        returns (uint256 shares)\n    {\n        _checkController(controller);\n        VaultState storage state = _vaultStates[controller];\n        shares = state.claimableCancelRedeemRequest;\n        if (shares == 0) revert ZeroAmount();\n\n        strategy.onClaimCancelRedeemRequest(address(this), controller);\n\n        state.claimableCancelRedeemRequest = 0;\n\n        _transfer(address(this), receiver, shares); // @audit bypasses all transfer restrictions.\n\n        emit CancelRedeemClaim(receiver, controller, requestId, msg.sender, shares);\n    }\n```\n\nFor this transfer step, the internal `_transfer()` function is used which skips all transfer restrictions applicable as per AccountableVault logic.\n\n**Impact:** This \"receiver\" address input while calling `claimCancelRedeemRequest()` is the controller's choice and there are no checks on it as `_checkTransfer()` gets bypassed. This allows to transfer shares even if \"to\" address is not KYC-ed or transfers originating at \"from\" address had to work with a cooldown time.\n\nThis way controller is able to move their vault shares to a random receiver address, bypassing the transfer restrictions.\n\n**Recommended Mitigation:** In `claimCancelRedeemRequest()`, remove the receiver address logic and just transfer the cancelled shares back to the controller address. This solves the issue as controller is already expected to be KYC-ed, and there will be no need for a cooldown check in that case as shares are going back to the original holder.\n\n**Accountable:** Fixed in commit [`2eeb273`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/2eeb2736eb5ba8dafa2c9f2f458b31fd8eb2d6bf)\n\n**Cyfrin:** Verified. `reciever` now checked against KYC.",
      "summary": "\nThe `AccountableVault.sol` file has a function called `_checkTransfer()` that applies restrictions on transferring shares. However, these restrictions are not applied when using the `cancelRedeemRequest()` feature, allowing the controller to transfer shares to a different address without any checks. This can be done by placing a redeem request and then immediately cancelling it, followed by calling `claimCancelRedeemRequest()` with the \"receiver\" address set to the desired destination. To fix this issue, the receiver address logic should be removed and the shares should be transferred back to the controller address. This has been fixed in the latest commit by the Accountable team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62973",
      "title": "`AccountableOpenTerm` loan interest cannot be repaid once principal hits zero",
      "impact": "HIGH",
      "content": "**Description:** In `AccountableOpenTerm`, interest accrues virtually via `_scaleFactor`, but there is no mechanism to pay/realize that interest. The only funding paths are `borrow()`, `supply()`, and `repay()`. Both `supply()` and `repay()` first service withdrawals and then reduce `_loan.outstandingPrincipal`. When principal reaches zero, `repay()` sets `loanState = Repaid`; in `Repaid`, `_requireLoanOngoing()` blocks further `supply()/repay()`, and `_sharePrice()` switches to `assetShareRatio()` (ignoring accrued `_scaleFactor`). As a result, any accrued interest becomes unpayable and is never delivered to LPs (or fee recipients).\n\n**Impact:** If the borrower repays the principa after time has passed, the loan flips to `Repaid` and all accrued interest is effectively forgiven. LPs receive principal back with zero interest. A borrower can always avoid interest by repaying principal before realizing it. This can happen intentionally by a malicious borrower or even unintentionally since the payments decrease principal first. Hence all interest needs to be repaid with the last payment.\n\n**Proof of Concept:** Add the following test to `AccountableOpenTerm.t.sol`:\n```solidity\nfunction test_openTerm_repay_principal_only_setsRepaid_no_interest_paid() public {\n    vm.warp(1739893670);\n\n    // Setup borrower & terms\n    vm.prank(manager);\n    usdcLoan.setPendingBorrower(borrower);\n    vm.prank(borrower);\n    usdcLoan.acceptBorrowerRole();\n\n    LoanTerms memory terms = LoanTerms({\n        minDeposit: 0,\n        minRedeem: 0,\n        maxCapacity: USDC_AMOUNT,\n        minCapacity: USDC_AMOUNT / 2,\n        interestRate: 150_000,           // 15% APR so scale factor grows visibly\n        interestInterval: 30 days,\n        duration: 0,\n        depositPeriod: 2 days,\n        acceptGracePeriod: 0,\n        lateInterestGracePeriod: 0,\n        lateInterestPenalty: 0,\n        withdrawalPeriod: 0\n    });\n    vm.prank(manager);\n    usdcLoan.setTerms(terms);\n    vm.prank(borrower);\n    usdcLoan.acceptTerms();\n\n    // Single LP deposits during deposit period → 1:1 shares at PRECISION\n    vm.prank(alice);\n    usdcVault.deposit(USDC_AMOUNT, alice, alice);\n    assertEq(usdcVault.totalAssets(), USDC_AMOUNT, \"vault funded\");\n\n    // Borrower draws full principal → vault drained\n    vm.prank(borrower);\n    usdcLoan.borrow(USDC_AMOUNT);\n    assertEq(usdcVault.totalAssets(), 0, \"all assets borrowed\");\n    assertEq(usdcLoan.loan().outstandingPrincipal, USDC_AMOUNT, \"principal outstanding\");\n\n    // Time passes → interest accrues virtually (scale factor > PRECISION)\n    vm.warp(block.timestamp + 180 days);\n    uint256 sfBefore = usdcLoan.accrueInterest();\n    assertGt(sfBefore, 1e36, \"scale factor increased (virtual interest)\");\n\n    // Borrower repays EXACTLY principal (no extra for interest)\n    usdc.mint(borrower, USDC_AMOUNT);\n    vm.startPrank(borrower);\n    usdc.approve(address(usdcVault), type(uint256).max);\n    usdcLoan.repay(USDC_AMOUNT);\n    vm.stopPrank();\n\n    // Loan marked repaid even though totalAssets < totalShareValue at sfBefore\n    assertEq(uint8(usdcLoan.loanState()), uint8(LoanState.Repaid), \"loan flipped to Repaid\");\n\n    // After Repaid, share price uses assetShareRatio (actual assets), not the higher scale factor.\n    // With one LP and totalAssets == totalSupply, ratio == PRECISION → no interest realized.\n    uint256 spAfter = usdcLoan.sharePrice(address(usdcVault));\n    assertEq(spAfter, 1e36, \"share price fell back to assetShareRatio (no interest paid)\");\n\n    // Sanity: vault now only holds repaid principal\n    assertEq(usdcVault.totalAssets(), USDC_AMOUNT, \"vault holds only principal after repay\");\n    assertEq(usdcVault.totalSupply(), USDC_AMOUNT, \"shares unchanged\");\n\n    // Now borrower cannot \"pay the interest\" anymore\n    vm.prank(borrower);\n    vm.expectRevert(); // blocked by _requireLoanOngoing()\n    usdcLoan.supply(1e6);\n}\n```\n\n**Recommended Mitigation:** Consider modeling borrower liability in debt shares instead of tracking principal/interest separately.\n\nOn `borrow(assets)`, after `accrue()`, mint `debtShares = ceil(assets * PRECISION / price)` where `price = scaleFactor`. Debt then equals `debtShares * price / PRECISION`. Interest accrual only moves `price`, not shares.\n\nOn `repay(assets)`, after `accrue()`, burn `sharesToBurn = floor(assets * PRECISION / price)` (capped to balance). When `debtShares == 0`, the loan is repaid.\n\nThis guarantees interest can always be repaid at the current price, prevents the “principal hits zero” dead-end, and supports partial/frequent repayments cleanly. If protocol/establishment fees apply, take them on each accrual/settle step before any excess refunds to keep fee accounting correct.\n\n**Accountable:** Fixed in commits [`fce6961`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/fce6961c71269739ec35da60131eaf63e66e1726) and [`8e53eba`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/8e53eba7340f223f86c9c392f50b8b2d885fdd39)\n\n**Cyfrin:** Verified. Debt is not tracked using shares.\n\n\\clearpage",
      "summary": "\nThe bug report is about a code called `AccountableOpenTerm`, which accrues interest but has no mechanism to pay or realize the interest. This means that any interest accrued by the code is never delivered to the intended recipients. This can happen intentionally or unintentionally, resulting in the borrower avoiding paying any interest. A test was added to the code to showcase this bug, and a recommended solution is proposed to fix it. The bug has been fixed in the code by the developers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62972",
      "title": "`AccountableAsyncRedeemVault::fulfillRedeemRequest` ignores processingMode and directly uses currentPrice for finalizing a redeem request",
      "impact": "HIGH",
      "content": "**Description:** When a redeem request is placed using `requestRedeem` function, it pushes a new request struct into the withdrawal queue. If the processingMode of the vault is configured to be `== RequestPrice`, the current `sharePrice` at that time is stored as the \"request.sharePrice\" for later use when the request will be processed.\n\nAll functions in the `AccountableWithdrawalQueue` honour this price and the assets user receives depends on this stored sharePrice (in case processingMode == RequestPrice).\n\nBut there is one function in `AccountableAsyncRedeemVault` that ignores the processing mode and uses the current `sharePrice`.\n\n```solidity\n    function fulfillRedeemRequest(address controller, uint256 shares) public onlyOperatorOrStrategy {\n        _fulfillRedeemRequest(_requestIds[controller], controller, shares, sharePrice());\n        _reduce(controller, shares);\n    }\n```\n\nThe `sharePrice` here fetches the current price of the shares, but if the `sharePrice` changed since the request time, it can be unfavourable to the user as he could get lesser amount of assets just because of the delay in processing, and that should not happen when the `processingMode == RequestPrice`.\n\n**Impact:** For a vault configured with `processingMode == RequestPrice`, the `fulfillRedeemRequest` functions breaks the guarantee that the price stored at time of placing the redeem request would be used for calculating the assets user gets in return, which might be unfavourable if the sharePrice decreased due to any reason.\n\n**Recommended Mitigation:**\n```solidity\n    function fulfillRedeemRequest(address controller, uint256 shares) public onlyOperatorOrStrategy {\n+++         uint256 price;\n+++         if (processingMode == ProcessingMode.CurrentPrice)\n+++              price = sharePrice();\n+++       }\n+++         else {\n+++              uint128 requestId = _requestIds[controller];\n+++              price = _queue.requests[requestId].sharePrice;\n+++      }\n\n               _fulfillRedeemRequest(_requestIds[controller], controller, shares, price);\n               _reduce(controller, shares);\n           }\n```\n\n**Accountable:** Not applicable due to `processingMode` being removed in commit [`4e5eef5`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/4e5eef57464d548ec09048eae27b6fcc1489a5c3)",
      "summary": "\nThis bug report highlights an issue with the `fulfillRedeemRequest` function in the `AccountableAsyncRedeemVault` contract. This function does not properly follow the `processingMode` configuration and instead uses the current share price, which may result in users receiving less assets than expected. A suggested solution is provided to mitigate this issue. However, it is noted that this bug is no longer applicable due to the removal of `processingMode` in a recent commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62971",
      "title": "Partial redemptions can be used to steal assets",
      "impact": "HIGH",
      "content": "**Description:** The request state is not handled properly when redeem requests are filled partially, leading to an inflated redemption price for the remaining part of the request.\n\n- When a new redemption is pushed onto an existing requestID, then the average redemption price is calculated using the updated `totalValue` and updated `request.shares`. This is then stored as the `request.sharePrice` (used for calculating assets owed for those shares).\n\n```solidity\n        } else { // if controller had an existing active requestID\n            requestId = requestId_;\n\n            WithdrawalRequest storage request = _queue.requests[requestId_];\n\n            request.shares += shares;\n\n            if (processingMode == ProcessingMode.RequestPrice) {\n                request.totalValue += shares.mulDiv(sharePrice, _precision);\n                request.sharePrice = request.totalValue.mulDiv(_precision, request.shares); // the average sharePrice is being calculated here.\n            } // the whole request will have a single price, averaged recursively as new redeem requests come up.\n\n        totalQueuedShares += shares;\n    }\n```\n\n\n- This works fine when request is fulfilled completely or cancelled completely as in those cases request data gets wiped out. But the problem is that when such a request is filled partially, this totalValue is never decreased while request.shares is decreased.\n\n\n```solidity\n    function _reduce(address controller, uint256 shares) internal returns (uint256 remainingShares) {\n        uint128 requestId = _requestIds[controller];\n        if (requestId == 0) revert NoQueueRequest();\n\n        uint256 currentShares = _queue.requests[requestId].shares;\n        if (shares > currentShares || currentShares == 0) revert InsufficientShares();\n\n        remainingShares = currentShares - shares;\n        totalQueuedShares -= shares;\n\n        if (remainingShares == 0) {\n            _delete(controller, requestId);\n        } else {\n            _queue.requests[requestId].shares = remainingShares;\n        } // @audit the totalValue is not updated here.\n    }\n```\n\n\nThis is the attack path :\n- User places a redeem request for 100 shares at a time when sharePrice == 2. So the request data stored is => {request.totalValue = 200, request.sharePrice = 2, request.shares = 100}.\n- This request gets fulfilled partially ie. 50 shares. Resultant state => {request.totalValue = 200, request.sharePrice = 2, request.shares = 50}. User got 100 assets.\n- User places another redeem request with 100 shares for the same controller address, thus the same requestID data will be modified. The new sharePrice will be calculated using an inflated \"request.totalValue\" and a normal request.shares. As per the calculation, the resultant state => {request.totalValue = 400, request.shares = 150, and request.sharePrice = 2.66}\n- Assume this request gets filled completely. User now gets 400 assets.\n\nUser got a total of 500 assets for redeeming 200 shares, even though the sharePrice was only 2. This is because the calculation uses an inflated value of request.totalValue to calculate the redemption price.\n\n- This request.sharePrice is used when calculating assets owed to the controller in  `_fulfillRedeemRequest()` flow\n\nThis means an inflated amount of assets will be added to the VaultState.maxWithdraw => allowing controller to claim more assets than they deserved if actual sharePrice was used.\n\nNote : Partial redemption is possible when `fulfillRedeemRequest()` is called with a portion of the request's shares, and also possible when `processUptoShares()` is used and it hits a block with maxShares/ liquidityShares (such that a particular request is not processed completely.\n\n**Impact:** An attacker can steal assets easily if their redeem request was fulfilled partially, in case the vault is configured with a processingMode == RequestPrice.\n\nThis issue exists only when processingMode == RequestPrice, as only then the request.sharePrice value is used for calculating assets owed.\n\n**Recommended Mitigation:** Consider removing the processingMode logic entirely to simplify the system, or decrease redeemed assets from `request.totalValue` as part of the `_reduce()` function.\n\n**Accountable:** Fixed in commit [`4e5eef5`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/4e5eef57464d548ec09048eae27b6fcc1489a5c3)\n\n**Cyfrin:** Verified. `processingMode` removed as well as `totalValue`.\n\n\\clearpage",
      "summary": "\nThis bug report describes an issue where the request state is not handled properly when redeem requests are partially filled. This leads to an inflated redemption price for the remaining part of the request. This issue can be exploited by an attacker to steal assets if their redeem request is fulfilled partially. The issue occurs only when the processing mode is set to RequestPrice. The recommended mitigation is to remove the processing mode logic or decrease the redeemed assets from the total value in the _reduce() function. The issue has been fixed in the commit 4e5eef5 and verified by Cyfrin. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62970",
      "title": "Critical DOS in queue processing if async cancellations are allowed",
      "impact": "HIGH",
      "content": "**Description:** The `cancelRedeemRequest()` function can be used to DOS the queue processing (ie. `processUpToShares()` and `processUpToRequestID()` can be made to revert).\n\nThis is the attack path :\n- `cancelRedeemRequest()` marks `state.pendingCancelRedeemRequest = true`;\n- Assume that this cancellation is not instantly fulfilled, as the associated strategy may support async cancellations\n\n\n```solidity\n    function cancelRedeemRequest(uint256 requestId, address controller) public onlyAuth {\n        _checkController(controller);\n        VaultState storage state = _vaultStates[controller];\n        if (state.pendingRedeemRequest == 0) revert NoPendingRedeemRequest();\n        if (state.pendingCancelRedeemRequest) revert CancelRedeemRequestPending();\n\n        state.pendingCancelRedeemRequest = true;\n\n        bool canCancel = strategy.onCancelRedeemRequest(address(this), controller); // @audit strategy can choose to return false here, thus mandating async cancellations.\n        if (canCancel) {\n            uint256 pendingShares = state.pendingRedeemRequest;\n\n            _fulfillCancelRedeemRequest(uint128(requestId), controller);\n            _reduce(controller, pendingShares);\n        }\n        emit CancelRedeemRequest(controller, requestId, msg.sender);\n    }\n```\n\n\n\n- At this step, it also skips \"reducing\" the shares in request state, as _reduce() will only be called when cancellation is fulfilled via `fulfillCancelRedeemRequest()`\n- Later when `processUpToShares()` is called, `_processRequest()` returns normal request data (does not return \"zero values\" as request.shares was not reduced in the cancel logic ) => so it doesn't break the loop or continue with nextRequestID\n- It goes on to call `_fulfillRedeemRequest()`, where it reverts due to pendingCancelRedeemRequest = true\n\n```solidity\n    function _fulfillRedeemRequest(uint128 requestId, address controller, uint256 shares, uint256 price)\n        internal\n        override\n    {\n        VaultState storage state = _vaultStates[controller];\n        if (state.pendingRedeemRequest == 0) revert NoRedeemRequest();\n        if (state.pendingRedeemRequest < shares) revert InsufficientAmount();\n        if (state.pendingCancelRedeemRequest) revert RedeemRequestWasCancelled();  // @audit\n```\n\nThis means even a single async cancellation (that is pending for processing) can DOS queue processing.\n\n\n**Impact:** Queue processing can be repeatedly DOS'ed under normal operations as well as by an attacker frontrunning a process call, in case the strategy contract allows async cancellations.\n\n\n**Recommended Mitigation:** Consider removing async cancellations' support from the system, which prevents this kind of attacks.\n\n**Accountable:** Fixed in commit [`2eeb273`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/2eeb2736eb5ba8dafa2c9f2f458b31fd8eb2d6bf)\n\n**Cyfrin:** Verified. Async cancelation of redeem requests now removed.",
      "summary": "\nThe `cancelRedeemRequest()` function has a bug that can be used to cause the queue processing to revert. This is because the function marks `state.pendingCancelRedeemRequest` as true and skips reducing the shares in the request state. When `processUpToShares()` is called, `_processRequest()` does not return zero values as expected, causing the loop to break. As a result, the queue processing can be repeatedly DOS'ed, even if the strategy contract allows async cancellations. The bug has been fixed by removing async cancellations' support from the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62969",
      "title": "`AccountableAsyncRedeemVault::fulfillCancelRedeemRequest` can de-sync request data causing permanent DOS for queue processing",
      "impact": "HIGH",
      "content": "**Description:** `fulfillCancelRedeemRequest()` function first finalises the cancellation of the redeeem request with input `requestID`, and then calls `_reduce()` to update the request state and `totalQueuedShares`.\n\n```solidity\n    function fulfillCancelRedeemRequest(address controller) public onlyOperatorOrStrategy {\n        _fulfillCancelRedeemRequest(_requestIds[controller], controller);\n        _reduce(controller, _vaultStates[controller].pendingRedeemRequest);\n    }\n```\n\nThe problem here is that it is using current value of `_vaultStates[controller].pendingRedeemRequest` in the `_reduce()` call, but it has been set to zero in `_fulfillCancelRedeemRequest()`.\n\nThis means `_reduce()` here will always be called with zero shares, and it does not revert when shares input is zero. But it corrupts the request struct and `totalQueuedShares` value.\n\nThe request will still exist with actual shares values, and create problems in usual batch processing of the queue.\n\nOne example of the resulting impact is this :\n1. User X places a redeem request for 100 shares\n2. User X cancels this redeem request\n3. His request is not fulfilled instantly (this depends on the strategy)\n4. Operator calls `fulfillCancelRedeemRequest()` to process this cancellation.\n5. The call goes through properly. As a result [state.pendingRedeemRequest = 0] but the request state still has request.shares == 100 and other values. Also, the `_queue.nextRequestID` remains unchanged.\n6. Now when batch processing proceeds via `processUpToShares()`, it is guaranteed that User X's requestID will also be processed (it is still in the queue from nextRequestID to lastRequestID) and when that happens, it will suffer a revert in `_processUptoShares()` => `_fulfillRedeemRequest()` because `state.pendingRedeemRequest` was set to == 0 in step 5.\n\n```solidity\n    function _fulfillRedeemRequest(uint128 requestId, address controller, uint256 shares, uint256 price)\n        internal\n        override\n    {\n        VaultState storage state = _vaultStates[controller];\n        if (state.pendingRedeemRequest == 0) revert NoRedeemRequest();\n        if (state.pendingRedeemRequest < shares) revert InsufficientAmount();\n        if (state.pendingCancelRedeemRequest) revert RedeemRequestWasCancelled();\n```\n\n\n**Impact:** If this function is ever called, there will be a permanent de-sync between the values stored as per requestID data and the vaultState of the controller, which will interfere with queue processing in different ways.\n\nThe example showcased here is a critical DOS blocking queue processing permanently. This will happen for strategies that offer async cancellation processing, but since vault is expected to be compatible with this behavior, fixing this is critical.\n\n\n**Recommended Mitigation:**\n```solidity\n    function fulfillCancelRedeemRequest(address controller) public onlyOperatorOrStrategy {\n\n+++        uint256 pendingShares = state.pendingRedeemRequest;\n               _fulfillCancelRedeemRequest(_requestIds[controller], controller);\n---          _reduce(controller, _vaultStates[controller].pendingRedeemRequest);\n+++        _reduce(controller, pendingShares);\n    }\n```\n\n**Accountable:** Fixed in commit [`84946dd`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/84946dd49dd70f9f5dfe40184beb52b734362701)\n\n**Cyfrin:** Verified. `pendingShares` now cached before fulfill and then passed as argument to `_reduce`.",
      "summary": "\nThe `fulfillCancelRedeemRequest()` function in the code first cancels a redeem request and then updates the request state and total queued shares. However, there is a bug where the `_reduce()` function is called with a value of zero shares, even though the request state was set to zero in the previous step. This can cause problems in the batch processing of the queue and can lead to permanent de-sync between the values stored and the vault state. To fix this, the code has been updated to cache the pending shares before fulfilling the cancel request and then passing it as an argument to the `_reduce()` function. This bug has been fixed in commit `84946dd`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "62968",
      "title": "Cancelling redeem requests permanently blocks the withdrawal queue",
      "impact": "HIGH",
      "content": "**Description:** `AccountableWithdrawalQueue` can deadlock at the head if the current head entry (`_queue.nextRequestId`) is fully removed (e.g., by a cancel that zeroes `shares` and clears `controller`) without advancing `nextRequestId`.\n\nIn [`AccountableWithdrawalQueue::_processUpToShares`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/queue/AccountableWithdrawalQueue.sol#L153-L156) and [`AccountableWithdrawalQueue::_processUpToRequestId`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/queue/AccountableWithdrawalQueue.sol#L193-L196), the loop checks `if (shares_ == 0) break;` before incrementing `nextRequestId`:\n```solidity\n(uint256 shares_, uint256 assets_, bool processed_) =\n    _processRequest(request_, liquidity, maxShares_, precision_);\n\nif (shares_ == 0) break;\n```\n\nWhen the head is an empty entry (`controller == address(0)`), [`AccountableWithdrawalQueue::_processRequest`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/queue/AccountableWithdrawalQueue.sol#L219) returns `(0, 0, true)`, `shares_ == 0`, the loop breaks:\n```solidity\nif (request.controller == address(0)) return (0, 0, true);\n```\nThe head never advances, so every subsequent call to process or preview gets stuck on the same empty head forever.\n\nThis can be triggered by any user whose request is currently at the head by canceling any dust amount (even 1 wei) such that their head entry is fully deleted at the time of processing (e.g., instant cancel-fulfillment) in [`AccountableWithdrawalQueue::_delete`](https://github.com/Accountable-Protocol/audit-2025-09-accountable/blob/fc43546fe67183235c0725f6214ee2b876b1aac6/src/vault/queue/AccountableWithdrawalQueue.sol#L130-L134):\n```solidity\n/// @dev Deletes a withdrawal request and its controller from the queue\nfunction _delete(address controller, uint128 requestId) private {\n    delete _queue.requests[requestId];\n    delete _requestIds[controller];\n}\n```\nOnce the head becomes an empty slot and the pointer doesn’t move, the entire queue is bricked.\n\n\n**Impact:** Queue is permanently stuck and no subsequent user will be able to withdraw.\n\n**Proof of Concept:** Add the following test to `test/vault/AccountableWithdrawalQueue.t.sol`:\n```solidity\nfunction testHeadDeletionDeadlocksQueue() public {\n    // Setup: deposits are instant, redemptions are queued, cancel is instantly fulfilled\n    strategy.setInstantFulfillDeposit(true);\n    strategy.setInstantFulfillRedeem(false);\n    strategy.setInstantFulfillCancelRedeem(true);\n\n    // Seed vault with liquidity and create first (head) request by Alice\n    // This helper deposits for Alice and Bob at 1e36 price.\n    _setupInitialDeposits(1e36, DEPOSIT_AMOUNT);\n\n    // 1) Alice creates a redeem request -> head of queue (requestId = 1)\n    uint256 aliceSharesToQueue = 1;\n    vm.prank(alice);\n    uint256 headId = vault.requestRedeem(aliceSharesToQueue, alice, alice);\n    assertEq(headId, 1, \"first request should be head (id = 1)\");\n\n    // 2) Alice cancels; cancel is fulfilled instantly by the strategy.\n    //    This fully removes the head request entry (controller becomes address(0)),\n    //    but _queue.nextRequestId is NOT advanced by the implementation.\n    vm.prank(alice);\n    vault.cancelRedeemRequest(headId, alice);\n\n    // Sanity: queue indices should still point at the deleted head\n    (uint128 nextRequestId, uint128 lastRequestId) = vault.queue();\n    assertEq(nextRequestId, 1, \"nextRequestId remains stuck at deleted head\");\n    assertGe(lastRequestId, 1, \"there is at least one request in the queue history\");\n\n    // 3) Charlie makes a NEW redeem request -> tail (requestId = 2).\n    //    This request is perfectly processable with existing liquidity.\n    token.mint(charlie, 1000e6);\n    vm.prank(charlie);\n    token.approve(address(vault), 1000e6);\n    vm.prank(charlie);\n    vault.deposit(1000e6, charlie);\n\n    uint256 charlieShares = vault.balanceOf(charlie) / 2;\n    vm.prank(charlie);\n    uint256 tailId = vault.requestRedeem(charlieShares, charlie, charlie);\n    assertEq(tailId, 2, \"second request should be tail (id = 2)\");\n\n    // Check queue bounds reflect head(=1, deleted) and tail(=2, valid)\n    (nextRequestId, lastRequestId) = vault.queue();\n    assertEq(nextRequestId, 1, \"still pointing at deleted head\");\n    assertEq(lastRequestId, 2, \"tail id should be 2\");\n\n    // 4) Attempt to process. BUG: _processUpToShares reads head slot (controller==0),\n    //    inner _processRequest returns (0,0,true), outer loop sees shares_==0 and BREAKS\n    //    BEFORE ++nextRequestId, so NOTHING gets processed and the queue is permanently stuck.\n    uint256 assetsBefore = vault.totalAssets();\n    uint256 used = vault.processUpToShares(type(uint256).max);\n    assertEq(used, 0, \"deadlock: processing does nothing while a valid tail exists\");\n\n    (uint256 _shares, uint256 _assets) = vault.processUpToRequestId(2);\n    assertEq(_shares, 0, \"deadlock: processing does nothing while a valid tail exists\");\n    assertEq(_assets, 0, \"deadlock: processing does nothing while a valid tail exists\");\n\n    // 5) Verify tail wasn't progressed at all\n    assertEq(vault.claimableRedeemRequest(0, charlie), 0, \"tail remains unclaimable\");\n    assertEq(vault.pendingRedeemRequest(0, charlie), charlieShares, \"tail remains fully pending\");\n    assertEq(vault.totalAssets(), assetsBefore, \"no reserves changed due to deadlock\");\n    (nextRequestId, lastRequestId) = vault.queue();\n    assertEq(nextRequestId, 1, \"nextRequestId is still stuck at deleted head\");\n}\n```\n\n**Recommended Mitigation:** Consider incrementing the counter if it's processed, and `continue` instead of break:\n```solidity\nif (shares_ == 0) {\n    if (processed_) {\n        ++nextRequestId;\n        continue;\n    }\n    break;\n}\n```\n\n**Accountable:** Fixed in commits [`2df3becf`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/2df3becf29e20d0d1707eb0567b51fe103f606ed) and [`b432631`](https://github.com/Accountable-Protocol/credit-vaults-internal/commit/b432631089e400742b1e584976e26e9e7ae8da85)\n\n**Cyfrin:** Verified. The counter is now incremented if the request was processed even if shares were 0.",
      "summary": "\nThe bug report describes an issue with the `AccountableWithdrawalQueue` that can cause it to become permanently stuck. This happens when the current head entry is fully removed without advancing the next request ID. This can be triggered by a user canceling a small amount of their request, which results in the head becoming an empty slot and the pointer not moving. This means that subsequent users will not be able to withdraw from the queue. The report includes a proof of concept test to demonstrate the issue and recommends a mitigation by incrementing the counter and using `continue` instead of `break`. The bug has been fixed by the team and verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Accountable",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-10-16-cyfrin-accountable-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Immeas",
        "Chinmay",
        "Alexzoid"
      ]
    },
    {
      "id": "18512",
      "title": "M-3: Updating the feeManger on config will cause desync between bank and vaults",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32 \n\n## Found by \n0x52\n## Summary\n\nWhen the bank is initialized it caches the current config.feeManager. This is problematic since feeManger can be updated in config. Since it is precached the address in bank will not be updated leading to a desync between contracts the always pull the freshest value for feeManger and bank.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n        feeManager = config_.feeManager();\n\nAbove we see that feeManger is cached during initialization.\n\n https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/vault/HardVault.sol#L140-L143\n\n        withdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n            address(uToken),\n            shareAmount\n        );\n\nThis is in direct conflict with other contracts the always use the freshest value. This is problematic for a few reasons. The desync will lead to inconsistent fees across the ecosystem either charging users too many fees or not enough.\n\n## Impact\n\nAfter update users will experience inconsistent fees across the ecosystem\n\n## Code Snippet\n\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L142\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBlueBerryBank should always use config.feeManger instead of caching it.",
      "summary": "\nThis bug report is about the issue M-3, which is related to the desync between the bank and the vaults due to the updating of the feeManager on the config. It was found by 0x52 and the impact of this issue is that users will experience inconsistent fees across the ecosystem after the update. The code snippet for this issue is from the BlueBerryBank.sol file at line 142. This issue was found using manual review and the recommendation is that BlueBerryBank should always use the config.feeManger instead of caching it.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/32",
      "tags": [
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18511",
      "title": "M-2: ShortLongSpell#openPosition attempts to burn wrong token",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30 \n\n## Found by \n0x52\n## Summary\n\nShortLongSpell#openPosition attempts to burn vault.uToken when it should be using vault instead. The result is that ShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L133-L140\n\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n\nWe see above that the contract attempts to withdraw vault.uToken from the wrapper.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L145-L150\n\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nThis is in direct conflict with the collateral that is actually deposited which is vault. This will cause the function to always revert when adding to an existing position.\n\n## Impact\n\nShortLongSpell#openPosition will be completely nonfunctional when the user is adding to their position\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBurn token should be vault rather than vault.uToken",
      "summary": "\nThis bug report is about a problem with the ShortLongSpell#openPosition function in the 2023-05-blueberry-judging repository. The issue is that the function attempts to burn vault.uToken when it should be using vault instead, resulting in the function being completely nonfunctional when the user is adding to their position. The code snippet that is causing the issue can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151. The bug was found by 0x52 using manual review. The recommendation to fix the issue is to burn token should be vault rather than vault.uToken.",
      "quality_score": 2,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/30",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18510",
      "title": "M-1: BalancerPairOracle#getPrice will revert due to division by zero in some cases",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25 \n\n## Found by \n0x52, nobody2018\n## Summary\n\n`BalancerPairOracle#getPrice` internally calls `computeFairReserves`, which returns fair reserve amounts given spot reserves, weights, and fair prices. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur.\n\n## Vulnerability Detail\n\nIn `BalancerPairOracle#getPrice`, resA and resB passed to `computeFairReserves` are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n\n```solidity\nfunction computeFairReserves(\n        uint256 resA,\n        uint256 resB,\n        uint256 wA,\n        uint256 wB,\n        uint256 pxA,\n        uint256 pxB\n    ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    \t...\n    \t//@audit r0 = 0 when resA < resB.\n->      uint256 r0 = resA / resB;\n        uint256 r1 = (wA * pxB) / (wB * pxA);\n        // fairResA = resA * (r1 / r0) ^ wB\n        // fairResB = resB * (r0 / r1) ^ wA\n        if (r0 > r1) {\n            uint256 ratio = r1 / r0;\n            fairResA = resA * (ratio ** wB);\n            fairResB = resB / (ratio ** wA);\n        } else {\n->          uint256 ratio = r0 / r1;\t\t// radio = 0 when r0 = 0\n->          fairResA = resA / (ratio ** wB);   \t// revert divided by 0\n            fairResB = resB * (ratio ** wA);\n        }\n    }\n```\n\nAnother case is **when the decimals of tokenA is smaller than the decimals of tokenB**, such as usdc(e6)-weth(e18).\n\n## Impact\n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^ wB\n         // fairResB = resB * (r0 / r1) ^ wA\n```\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n\n**This issue is same root as #28**.\nThe impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\nMerging the two reports is the best description.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is a valid M/H. Please review **Vulnerability Detail** of this report, it describes 2 cases:\n> 1. resA and resB passed to computeFairReserves are the balance of TokenA and TokenB of the pool respectively. It is common for the balance of TokenB to be greater than the balance of TokenA.\n> 2. when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18).\n> \n> **This issue is same root as #28**.\n> The impact described in #28 is only possible if the dp of the two tokens are different. But it is not completely correct, because when the dp of token0 is less than the dp of token1, a division by zero error occurs, such as token0(e6)-token1(e18).\n> Merging the two reports is the best description.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with escalation. This and #28 are dupes and this does a better job of describing the issue so it should be the main issue. Additionally given that the contract would become nonfunctional rather than return an incorrect price, I agree with the watson's original severity of medium.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nMaking this issue the main one and #28 a duplicate of this issue. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Making this issue the main one and #28 a duplicate of this issue. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue in BalancerPairOracle#getPrice which can cause a transaction to revert due to division by zero in some cases. It was found by 0x52 and nobody2018. \n\nThe issue is caused by the `computeFairReserves` function, which is called by `BalancerPairOracle#getPrice`. When the parameter `resA` passed to `computeFairReserves` is smaller than `resB`, division by 0 will occur. This is common for the balance of TokenB to be greater than the balance of TokenA. Another case is when the decimals of tokenA is smaller than the decimals of tokenB, such as usdc(e6)-weth(e18). \n\nAll functions that subcall `BalancerPairOracle#getPrice` will be affected. The code snippet can be found at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L35-L66. The tool used to find this bug was Manual Review. \n\nThe recommendation is to modify the code as follows:\n\n```diff\n--- a/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n+++ b/blueberry-core/contracts/oracle/BalancerPairOracle.sol\n@@ -50,7 +50,7 @@ contract BalancerPairOracle is UsingBaseOracle, IBaseOracle {\n         // --> fairResA / r1^wB = constant product\n         // --> fairResA = resA^wA * resB^wB * r1^wB\n         // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n-        uint256 r0 = resA / resB;\n+        uint256 r0 = resA * 10**(decimalsB) / resB;\n         uint256 r1 = (wA * pxB) / (wB * pxA);\n         // fairResA = resA * (r1 / r0) ^",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/25",
      "tags": [
        "Wrong Math",
        "Missing-Logic",
        "Decimals"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18509",
      "title": "H-2: ShortLongSpell#openPosition uses the wrong balanceOf when determining how much collateral to put",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31 \n\n## Found by \n0x52\n## Summary\n\nThe _doPutCollateral subcall in ShortLongSpell#openPosition uses the balance of the uToken rather than the vault resulting in the vault tokens being left in the contract which will be stolen.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150\n\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n\nWhen putting the collateral the contract is putting vault but it uses the balance of the uToken instead of the balance of the vault.\n\n## Impact\n\nVault tokens will be left in contract and stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the balanceOf vault rather than vault.uToken\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC\n\nIn #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> In #Blueberry Update, despite the successful escalation of the issue, no reward was granted for the heightened severity and impact of the vulnerability. However, in #Blueberry Update2, a reward was offered specifically for the detection and reporting of a similar vulnerability.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nThis issue has been escalated in the first contest and should be valid in both\n\n**hrishibhat**\n\nEscalation accepted\n\nThis is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> This is a valid issue, and necessary decisions have been taken in the respective issue from the previous contest. \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the ShortLongSpell#openPosition subcall in the Smart Contract of the Blueberry project. The issue is that the contract uses the balance of the uToken rather than the balance of the vault when determining how much collateral to put. This results in the vault tokens being left in the contract, which can be stolen. The code snippet that is causing the issue is located at https://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L144-L150. The bug was found by 0x52 and manual review was used as a tool. The impact is that vault tokens will be left in contract and stolen. The recommendation is to use the balanceOf vault rather than vault.uToken. The bug was escalated for 10 USDC and the escalation was accepted. This issue was already escalated in the first contest and the necessary decisions have been taken in the respective issue from the previous contest. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/31",
      "tags": [
        "External Contract",
        "Fund Lock",
        "Coding-Bug"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18508",
      "title": "H-1: AuraSpell#openPositionFarm fails to return all rewards to user",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n## Found by \n0x52, nobody2018\n## Summary\n\nWhen a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. The issues is that WAuraPool will send all reward tokens to the contract but it only sends Aura back to the user, causing all other rewards to be lost.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L256-L261\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n\nInside WAuraPools#burn reward tokens are sent to the user.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L130-L140\n\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\nWe see above that the contract only refunds Aura to the user causing all other extra reward tokens received by the contract to be lost to the user.\n\n## Impact\n\nUser will lose all extra reward tokens from their original position\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWAuraPool returns the reward tokens it sends. Use this list to refund all tokens to the user\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC.\nThe issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> The issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nEscalate for 10 USDC\nvalid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> valid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with second escalation\n\n**sleepriverfish**\n\nSo, the issue https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42 considered invalid? I believe it should be categorized and rewarded in some way.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nThe issue mentioned above has been resolved accordingly in the respective contest. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> The issue mentioned above has been resolved accordingly in the respective contest. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug report has been raised in the Sherlock Audit repository about an issue with the AuraSpell#openPositionFarm contract. It was found by 0x52 and nobody2018 and is related to the WAuraPool contract. The issue is that when a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. However, the WAuraPool contract only sends the Aura token back to the user, causing all other rewards to be lost. \n\nThe vulnerability detail is that inside the WAuraPools#burn function, reward tokens are sent to the user. However, in the AuraSpell#openPositionFarm function, the contract only refunds Aura to the user, causing all other extra reward tokens received by the contract to be lost to the user. \n\nThe impact of this bug is that users will lose all extra reward tokens from their original position.\n\nThe tool used to identify this bug was manual review. The recommendation is that WAuraPool should be modified to return the reward tokens it sends. This list should then be used to refund all tokens to the user.\n\nThe issue was discussed and it was decided that the issue mentioned previously had been resolved accordingly in the respective contest, so the escalation was rejected. Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update #2",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29",
      "tags": [
        "Check Return Value",
        "Missing-Logic",
        "Fund Lock",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18507",
      "title": "M-13: Missing checks for whether Arbitrum Sequencer is active",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142 \n\n## Found by \n0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, tsvetanovv\n## Summary\n\nMissing checks for whether Arbitrum Sequencer is active\n\n## Vulnerability Detail\n\nthe onchain deployment context is changed, in prev contest the protocol only attemps to deploy the code to ethereum while in the current contest\n\nthe protocol intends to deploy to arbtrium as well!\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\n\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\n\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n\n## Impact\n\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L76-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.",
      "summary": "\nThis bug report is about the missing checks for whether the Arbitrum Sequencer is active. It was found by 0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, and tsvetanovv. The protocol intends to deploy to Arbtrium, and Chainlink recommends that users using price oracles check whether the Arbitrum sequencer is active. If the sequencer goes down, the index oracles may have stale prices which can result in false liquidation or over-borrowing. The code snippet for this issue can be found at the given link. The tool used was Manual Review. The recommendation is to use sequencer oracle to determine whether the sequencer is offline or not, and not to allow orders to be executed while the sequencer is offline.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142",
      "tags": [
        "Oracle",
        "Missing-Logic",
        "L2 Sequencer",
        "Arbitrum",
        "Stale Price"
      ],
      "finders": [
        "Bauer",
        "J4de",
        "tallo",
        "tsvetanovv",
        "deadrxsezzz",
        "Brenzee",
        "Bauchibred",
        "0xepley",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18506",
      "title": "M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128 \n\n## Found by \n0x52\n## Summary\n\npendingRewards pulls a fresh count of reward tokens each time it is called. This is problematic if reward tokens are ever removed from the the underlying Aura/Convex pools because it means that they will no longer be distributed and will be locked in the contract forever.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\nIn the lines above we can see that only tokens that are currently available on the pool. This means that if tokens are removed then they are no longer claimable and will be lost to those entitled to shares.\n\n## Impact\n\nUsers will lose reward tokens if they are removed\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReward tokens should be stored with the tokenID so that it can still be paid out even if it the extra rewardToken is removed.",
      "summary": "\nThis bug report is about an issue with reward tokens being removed from the WAuraPool/WConvexPools contract in the Sherlock Audit 2023-04-blueberry-judging project. The bug was found by 0x52 and it was identified through manual review. \n\nThe code snippet shows that only tokens that are currently available in the pool are taken into consideration when the pendingRewards function is called. This means that if tokens are removed from the pool, they will not be distributed to the users and will be locked in the contract forever. As a result, users will lose reward tokens if they are removed.\n\nThe recommendation is to store the reward tokens with the tokenID so that it can still be paid out even if the extra rewardToken is removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128",
      "tags": [
        "Lending Pool",
        "Deposit/Reward tokens",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18505",
      "title": "M-11: AuraSpell#closePositionFarm requires users to swap all reward tokens through same router",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122 \n\n## Found by \n0x52\n## Summary\n\nAuraSpell#closePositionFarm requires users to swap all reward tokens through same router. This is problematic as it is very unlikely that a UniswapV2 router will have good liquidity sources for all tokens and will result in users experiencing forced losses to their reward token.  \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAll tokens are forcibly swapped through a single router.\n\n## Impact\n\nUsers will be forced to swap through a router even if it doesn't have good liquidity for all tokens\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "summary": "\nA bug was found in the AuraSpell#closePositionFarm function of the Sherlock-Audit/2023-04-blueberry-judging repository by 0x52. This bug requires users to swap all reward tokens through the same UniswapV2 router, resulting in users experiencing forced losses to their reward token due to lack of liquidity. The code snippet responsible for this issue is located in AuraSpell.sol#L193-L203. The impact of this bug is that users are forced to swap through a router even if it doesn't have good liquidity for all tokens. The bug was found through manual review. The recommendation is to allow users to use an aggregator like paraswap or multiple routers instead of only one single UniswapV2 router.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/122",
      "tags": [
        "Uniswap",
        "Swap",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18504",
      "title": "M-10: Issue 94 from previous contest has not been fixed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118 \n\n## Found by \n0x52, Bauchibred, cducrest-brainbot, deadrxsezzz, helpMePlease, kaysoft, peanuts, tsvetanovv\n## Summary\n\n[Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94) still exists exactly even though it was marked as \"will fix\".\n\n## Vulnerability Detail\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Impact\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L77-L97](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L77-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)",
      "summary": "\nThis bug report is about Issue M-10, which is related to Issue 94 from a previous contest. It was found by eight members of the Sherlock Audit team, and it has not been fixed even though it was marked as \"will fix\". The vulnerability details, impact, code snippet, and recommendation can be found in Issue 94. It was found using manual review. This issue needs to be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118",
      "tags": [
        "Stale Price",
        "Oracle",
        "Missing-Logic"
      ],
      "finders": [
        "kaysoft",
        "0x52",
        "cducrest-brainbot",
        "tsvetanovv",
        "deadrxsezzz",
        "peanuts",
        "Bauchibred",
        "helpMePlease"
      ]
    },
    {
      "id": "18503",
      "title": "M-9: Issue 290 from previous contest has not been fully addressed by fixes",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117 \n\n## Found by \n0x52, HonorLt, cducrest-brainbot\n## Summary\n\n[Issue 290](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/290) from the previous contest points out that users may be liquidated without the chance to repay their debt. Liquidate was changed to only be allowed when repayment was allowed. While this does address some of the problem this will still fail to protect users who become liquidatable during the period of time that repay has been disabled.\n\nMEV bots are typically used to liquidate positions since it is always more profitable to liquidate the vault even if a user tries to pay off their debt on the same black that repay is enabled, they will still be liquidated because of frontrunning.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nUsers who become liquidatable during a repay pause will still be unable to save their position\n\n## Code Snippet\n\n[BlueBerryBank.sol#L487-L548](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen repay is paused and then resumed, put a timer that prevents liquidations for some amount of time after (i.e. 4 hours) so that users can fairly repay their position after repayment has been resumed.",
      "summary": "\nThis bug report is about an issue from a previous contest that has not been fully addressed by the fixes. The issue is that users may be liquidated without the chance to repay their debt. MEV bots are typically used to liquidate positions, so even if a user tries to pay off their debt on the same block that repay is enabled, they will still be liquidated due to frontrunning. The impact of this is that users who become liquidatable during a repay pause will still be unable to save their position. The code snippet mentioned in the report is BlueBerryBank.sol#L487-L548. The recommendation given is to put a timer that prevents liquidations for some amount of time after repayment has been resumed, so that users can fairly repay their position.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/117",
      "tags": [
        "Missing-Logic",
        "Liquidation"
      ],
      "finders": [
        "cducrest-brainbot",
        "HonorLt",
        "0x52"
      ]
    },
    {
      "id": "18502",
      "title": "M-8: asking for the wrong address for `balanceOf()`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\nShortLongSpell.[openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L143-L150) pass to `_doPutCollateral()` wrong value of `balanceOf()`\n```solidity\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n                address(this)\n            )\n        );\n```\nthe balance should be of `address(vault)`\n\n## Impact\n- `openPosition()` will never work\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n        // 5. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n-            IERC20Upgradeable(ISoftVault(vault).uToken()).balanceOf(\n-                address(this)\n+                IERC20Upgradeable(vault).balanceOf(address(this))\n            )\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThis is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n\nAlso of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is a simple finding when you know that `SoftVault` is transferring all `uToken` to Compound to generate yield \n> \n> Also of wonder the judge set this as invalid but he submitted both this and #114  in the next contest **Blueberry Update 2**\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nSince the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Since the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue considering this a valid medium. \n> \n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue is that the wrong address is being asked for the `balanceOf()` function. This issue was found by Ch_301 and was escalated for 10 USDC. \n\nThe vulnerability detail is that the `openPosition()` function passes the wrong value of `balanceOf()` to the `_doPutCollateral()` function. The impact of this issue is that `openPosition()` will never work. The code snippet of the issue is provided in the report. The tool used to find the issue was Manual Review. \n\nThe recommendation for the issue is to change the code snippet as shown in the report. The discussion section shows that the issue was accepted as a valid medium as the issue does not clearly identify the impact where the tokens can be stolen, but still correctly recognizes the underlying issue. \n\nThus, this bug report is about an issue found in the code of the ShortLongSpell contract in the 2023-04-blueberry-judging Github repository. The issue was found by Ch_301 and was accepted as a valid medium. The impact of this issue is that `openPosition()` will never work. The recommendation is to change the code snippet as shown in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/116",
      "tags": [
        "Vault",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18501",
      "title": "M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115 \n\n## Found by \n0x52, nobody2018\n## Summary\n\ncollToken.pendingRewards pulls the most recent reward list from Aura/Convex. In the event that reward tokens are added to pools that don't currently have an oracle then it will DOS every action (repaying, liquidating, etc.). While this is only temporary it prevents liquidation which is a key process that should have 100% uptime otherwise the protocol could easily be left with bad debt.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n          (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n              pos.collToken\n          ).pendingRewards(pos.collId, pos.collateralSize);\n          for (uint256 i; i < tokens.length; i++) {\n              rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n          }\n\nUsing the pendingRewards method pulls a fresh list of all tokens. When a token is added as a reward but can't be priced then the call to getTokenValue will revert. Since getPostionValue is used in liquidations, it temporarily breaks liquidations which in a volatile market can cause bad debt to accumulate.\n\n## Impact\n\nTemporary DOS to liquidations which can result in bad debt\n\n## Code Snippet\n\n[BlueBerryBank.sol#L392-L417](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L392-L417)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn zero valuation if extra reward token can't be priced.",
      "summary": "\nThis bug report is about BlueBerryBank#getPositionValue which is a function in the BlueBerryBank.sol file. It is found by 0x52, nobody2018 and it causes a Denial-of-Service (DOS) attack if reward tokens are added to pools that don't have an oracle. This means that liquidations, which are a key process that should have 100% uptime, are temporarily prevented which can result in bad debt accumulating in a volatile market. \n\nThe code snippet for this vulnerability can be found in BlueBerryBank.sol#L392-L417. It was found through manual review. \n\nThe recommendation for this bug is to return a zero valuation if extra reward tokens can't be priced. This should prevent the DOS attack and keep the liquidation process running smoothly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115",
      "tags": [
        "Oracle",
        "Liquidation",
        "Denial-Of-Service"
      ],
      "finders": [
        "0x52",
        "nobody2018"
      ]
    },
    {
      "id": "18500",
      "title": "M-6: M-03 wrong token address on `ShortLongSpell.sol`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114 \n\n## Found by \nCh\\_301\n## Summary\n\n## Vulnerability Detail\n[ShortLongSpell.openPosition()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#LL111C4-L151C6) send `uToken` to SoftVault then deposit it into the Compound protocol to earn a passive yield. In return, SPELL receives share tokes of SoftVault  `address(strategy.vault)`  \n\n`WERC20.sol` should receive `address(strategy.vault)` token, but the logic of `ShortLongSpell.sol` subcall (WERC20.sol) `wrapper.burn()` and pass the `uToken` address (please check the Code Snippet part) instead of `strategy.vault` address\n\n## Impact\nShort/Long Spell will never work\n\n## Code Snippet\n1- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L128-L141\n```solidity\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L229-L234\n```solidity\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n            address(ISoftVault(strategy.vault).uToken()),\n            param.amountPosRemove\n        );\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n1- \n```diff\n-            address burnToken = address(ISoftVault(strategy.vault).uToken());\n+            address burnToken = strategy.vault;\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n```\n2- \n```diff\n        // 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        werc20.burn(\n-            address(ISoftVault(strategy.vault).uToken()),\n+            strategy.vault,\n            param.amountPosRemove\n        );\n```\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe same reason as #116 but in a different implementation and it needs another solution \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The same reason as #116 but in a different implementation and it needs another solution \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nThis is a valid issue\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> This is a valid issue\n> \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the ShortLongSpell.sol contract, which is part of the Sherlock Audit 2023-04-blueberry-judging project. The issue is that the wrong token address is being passed to the SoftVault contract. This means that the Short/Long Spell will never work.\n\nThe issue was found by Ch_301 and confirmed by hrishibhat. It was then escalated for 10 USDC. The bug was caused because the `uToken` address was being passed instead of the `strategy.vault` address.\n\nThe issue can be fixed by changing the code snippet in two places. The first code snippet is located at ShortLongSpell.sol#L128-L141, and the second is located at ShortLongSpell.sol#L229-L234. The changes should be made according to the recommendations given in the report.\n\nAfter the issue is fixed, the contestants' payouts and scores will be updated according to the changes made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/114",
      "tags": [
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18499",
      "title": "M-5: `getPositionRisk()` will return a wrong value of risk",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97 \n\n## Found by \nCh\\_301\n## Summary\nIn order to interact with SPELL the users need to `lend()` some collateral which is known as **Isolated Collateral** and the SoftVault will deposit them into Compound protocol to generate some lending interest (to earn passive yield)  \n\n## Vulnerability Detail\nto [liquidate](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L487-L548) a position this function `isLiquidatable()` should return `true`\n```solidity\n    function isLiquidatable(uint256 positionId) public view returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n```\nand it is subcall to `getPositionRisk()`\n```solidity\n    function getPositionRisk(\n        uint256 positionId\n    ) public view returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);          \n        uint256 ov = getDebtValue(positionId);             \n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov // Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            // Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n```\nas we can see the `cv`  is a critical value in terms of the calculation of `risk `\nthe `cv` is returned by `getIsolatedCollateralValue()`\n\n```solidity\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public view override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        // NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =                                              \n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() * \n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION; \n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n ```\nand it uses `exchangeRateStored()` to ask Compound (CToken.sol) for the exchange rate \n[from `CToken` contract ](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL281C18-L281C18)\n```diff\nThis function does not accrue interest before calculating the exchange rate\n``` \nso the `getPositionRisk()` will return a wrong value of risk because the interest does not accrue for this position \n\n## Impact\nthe user (position) could get liquidated even if his position is still healthy \n  \n## Code Snippet\nhttps://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#LL270C1-L286C6\n```solidity\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n```    \n## Tool used\n\nManual Review\n\n## Recommendation\nYou shoud use `exchangeRateCurrent()` to  Accrue interest first.\n\n\n\n## Discussion\n\n**Gornutz**\n\nSince we are using a view function we are unable to use `exchangeRateCurrent()` we have to use `exchangeRateStored()` \n\n**Ch-301**\n\nEscalate for 10 USDC\n\nThe sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \nI believe the rules are clear on that \nHe decided to not fix it but the risk still exists   \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> The sponsor confirms that. so the user could get liquidated even in case his position is still healthy. \n> I believe the rules are clear on that \n> He decided to not fix it but the risk still exists   \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nCan be a valid medium\n\n**hrishibhat**\n\nEscalation accepted\n\nValid medium\nAlthough the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid medium\n> Although the difference in the interest accumulated here can be very low as it updates slowly, although this cannot be exactly quantified, the fact that a position can be liquidated based on outdated value makes it a valid medium.\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the `getPositionRisk()` function, which is used to calculate the risk of a position and determine if it is liquidatable. It was found by Ch_301 and is located in the BlueBerryBank.sol contract. This function calls the `getIsolatedCollateralValue()` function, which is used to get the collateral value of a position. This function in turn calls the `exchangeRateStored()` function, which is located in the CToken.sol contract. This function does not accrue interest before calculating the exchange rate, resulting in a wrong value of risk being returned. This can cause a user's position to be liquidated even if it is still healthy. It was recommended to use the `exchangeRateCurrent()` function to accrue interest first. This recommendation was accepted and the issue was closed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/97",
      "tags": [
        "Liquidation",
        "External Contract",
        "External Call",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "18498",
      "title": "M-4: Users can fail to closePositionFarm and lose their funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64 \n\n## Found by \nBauer\n## Summary\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to call the `CurveSpell.closePositionFarm()` function to  repay his debt, resulting in his assets being liquidated.\n\n\n## Vulnerability Detail\nThe `CurveSpell.closePositionFarm()` function is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. Inside the function, the protocol swaps the harvested CRV tokens to the debt token, and calculates the actual amount of LP tokens to remove from the Curve pool. It then removes the LP tokens using the remove_liquidity_one_coin function of the Curve pool. \n```solidity\n   int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n```\nIf self.is_killed in the curve pool contract  becomes true, calling such `remove_liquidity_one_coin()` function would always revert. In this case, calling the `CurveSpell.closePositionFarm()` function reverts. When user's position is about to be liquidated, if the `closePositionFarm()` function is DOS'ed,user may be unable to repay his debt, resulting in the user losing their funds\n```solidity\ndef remove_liquidity_one_coin(\n    _token_amount: uint256,\n    i: int128,\n    _min_amount: uint256\n) -> uint256:\n    \"\"\"\n    @notice Withdraw a single coin from the pool\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\n    @param i Index value of the coin to withdraw\n    @param _min_amount Minimum amount of coin to receive\n    @return Amount of coin received\n    \"\"\"\n    assert not self.is_killed  # dev: is killed\n\n    dy: uint256 = 0\n    dy_fee: uint256 = 0\n    dy, dy_fee = self._calc_withdraw_one_coin(_token_amount, i)\n\n```\n\n## Impact\nIf self.is_killed in the curve pool contract  becomes true, user may be unable to repay his debt, resulting in his assets being liquidated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L197\n\n## Tool used\n\nManual Review\n\n## Recommendation",
      "summary": "\nThis bug report is about an issue with the CurveSpell.closePositionFarm() function in the Curve pool contract. If the self.is_killed variable in the Curve pool contract becomes true, it is not possible to call the remove_liquidity_one_coin() function which is used to unwind a position on a strategy that involves farming CRV rewards through staking LP tokens in a Curve pool. This would result in users not being able to repay their debt and losing their funds. The vulnerability was found manually and the code snippet provided in the report is from the CurveSpell.sol#L197 file. It is recommended to check the self.is_killed variable in the Curve pool contract to prevent users from losing their funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/64",
      "tags": [
        "Missing-Logic",
        "Liquidation",
        "Lending Pool",
        "Fund Lock",
        "Denial-Of-Service"
      ],
      "finders": [
        "Bauer"
      ]
    },
    {
      "id": "18497",
      "title": "M-3: The protocol  will not be able to add liquidity on the curve with another token with a balance.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47 \n\n## Found by \nBauer, nobody2018\n## Summary\nThe `CurveSpell` protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n\n## Vulnerability Detail\nThe  `openPositionFarm()` function enables user to open a leveraged position in a yield farming strategy by borrowing funds and using them to add liquidity to a Curve pool, while also taking into account certain risk management parameters such as maximum LTV and position size. When add liquidity on curve ,the protocol use the borrowed token and the collateral token, it checks the number of tokens in the pool and creates an array of the supplied token amounts to be passed to the add_liquidity function. Then the curve will transfer the tokens from the protocol and mint lp tokens to the protocol. However, the protocol only ensure approve curve pool to spend its borrow token. Hence, it will not be able to add liquidity on the curve with another token with a balance.\n```solidity\n // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n```\n\n## Impact\nThe protocol  will not be able to add liquidity on the curve with another token with a balance.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115\n## Tool used\n\nManual Review\n\n## Recommendation\nAllow the curve pool to spend tokens that have a balance in the protocol to add liquidity",
      "summary": "\nThis bug report is about the `CurveSpell` protocol, which is used to open leveraged positions in a yield farming strategy. The protocol only ensures approve curve pool to spend its borrow token, and hence it will not be able to add liquidity on the curve with another token with a balance. This is because the `openPositionFarm()` function creates an array of the supplied token amounts to be passed to the add_liquidity function, but it only checks the number of tokens in the pool and not the balance of the tokens.\n\nThe impact of this bug is that the protocol will not be able to add liquidity on the curve with another token with a balance. The code snippet for this bug can be found at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L90-L115. This bug was found by Bauer and nobody2018 using manual review.\n\nThe recommendation to fix this bug is to allow the curve pool to spend tokens that have a balance in the protocol to add liquidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/47",
      "tags": [
        "Missing-Logic",
        "Deposit/Reward tokens",
        "Coding-Bug"
      ],
      "finders": [
        "Bauer",
        "nobody2018"
      ]
    },
    {
      "id": "18496",
      "title": "M-2: AuraSpell openPositionFarm does not join pool",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46 \n\n## Found by \nCh\\_301, cducrest-brainbot, cuthalion0x, nobody2018\n## Summary\n\nThe function to open a position for the AuraSpell does not join the pool due to wrong conditional check.\n\n## Vulnerability Detail\n\nThe function deposits collateral into the bank, borrow tokens, and attempts to join the pool:\n\n```solidity\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        ...\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n        ...\n    }\n```\n\nThe function only borrowed one type of tokens from the bank so the contract only owns one type of token. As a result one of the `maxAmountsIn` value is 0. Either `poolAmountFromA` or `poolAmountFromB` is 0 as a result of computation. `poolAmountOut` is the minimal value of `poolAmountFromA` and `poolAmountFromB`, it is 0. The following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined.\n\n## Impact\n\nThe rest of the function proceeds correctly without reverting. Users will think they joined the pool and are earning reward while they are not earning anything. This is a loss of funds to the user.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is hard to tell the intent of the developer from this check. Maybe the issue is simply that `poolAmountOut` should be the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "summary": "\nThis bug report is about an issue with the function openPositionFarm() in the AuraSpell smart contract. The issue is that the function does not join the pool due to a wrong conditional check. The function deposits collateral into the bank, borrows tokens, and attempts to join the pool, but the conditional check only borrows one type of token from the bank, so one of the maxAmountsIn values is 0. This means that either poolAmountFromA or poolAmountFromB is 0, and the following check `if (poolAmountOut > 0)` will always fail and the pool will never be joined. This means that users will think they joined the pool and are earning rewards while they are not, resulting in a loss of funds to the user. The recommendation is to change the computation of `poolAmountOut` to either the sum or the max value out of `poolAmountFromA` and `poolAmountFromB` instead of the min.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/46",
      "tags": [
        "Lending Pool",
        "Coding-Bug"
      ],
      "finders": [
        "cducrest-brainbot",
        "Ch\\_301",
        "nobody2018",
        "cuthalion0x"
      ]
    },
    {
      "id": "18495",
      "title": "M-1: Calculation underflow/overflow in BalancerPairOracle, which will affect pools in Aura Finance",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11 \n\n## Found by \nn1punp\n## Summary\nLP price calculation for Balancer Pair in BalancerPairOracle will produce calculation underflow/overflow (so Aura pools won't work too).\n\n## Vulnerability Detail\n- The values r0, r1 can underflow, e.g. if resA < resB --> r0 = 0, so it'll go to the else case --> and so `ratio` will be 0 --> `fairResA` calculation will revert upon dividing by 0.\n- There are also other math calculations there that will cause reverts, e.g. ratio ** wB will lead to overflow. What you'd need here is Balancer's implementation of `bpow` or similar.\n\n## Impact\nLP price for Balancer-like collateral token will revert in most cases, if not all.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L53-L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\n- Change the calculation logic so it aligns with Alpha's original implementation (with precision control), e.g. https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/BalancerPairOracle.sol#L42-L53 (you can see there's BONE extra precision in each step)\n\n\n\n## Discussion\n\n**n1punp**\n\nEscalate for 10 USDC.\nI think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> I think this is incorrectly **excluded**. The issue is not related to **flashloan** via **BalancerPairOracle**, but rather an organic math overflow/underflow, since the implementation is directly using 0.8.x's default SafeMath mode. Upon certain conditions (e.g. `resA < resB` the calculation will always revert).\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI don't think this report has sufficient prove\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid medium \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid medium \n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug was identified in the BalancerPairOracle contract, which is used by Aura Finance pools. The bug is a calculation underflow/overflow, which will cause the LP price calculation to revert in most cases. The bug was found by manual review and the code snippet can be found at the provided GitHub link. The impact of the bug is that LP prices for Balancer-like collateral tokens will not be calculated correctly. The recommendation is to change the calculation logic to align with Alpha's original implementation, which has precision control. The bug was accepted as a valid medium and the contest payout and scores will be updated accordingly.",
      "quality_score": 2,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/11",
      "tags": [
        "Wrong Math",
        "Uniswap",
        "Overflow/Underflow",
        "Lending Pool"
      ],
      "finders": [
        "n1punp"
      ]
    },
    {
      "id": "18494",
      "title": "H-14: Deadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145 \n\n## Found by \nBauer, Breeje, ctf\\_sec\n## Summary\n\nDeadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed\n\n## Vulnerability Detail\n\nIn the current implementation in CurveSpell.sol\n\n```solidity\n{\n\t// 2. Swap rewards tokens to debt token\n\tuint256 rewards = _doCutRewardsFee(CRV);\n\t_ensureApprove(CRV, address(swapRouter), rewards);\n\tswapRouter.swapExactTokensForTokens(\n\t\trewards,\n\t\t0,\n\t\tswapPath,\n\t\taddress(this),\n\t\ttype(uint256).max\n\t);\n}\n```\n\nthe deadline check is set to type(uint256).max, which means the deadline check is disabled!\n\nIn IChiSpell. the swap is directedly call on the pool instead of the router\n\n```solidity\nSWAP_POOL.swap(\n\taddress(this),\n\t// if withdraw token is Token0, then swap token1 -> token0 (false)\n\t!isTokenA,\n\tamountToSwap.toInt256(),\n\tisTokenA\n\t\t? param.sqrtRatioLimit + deltaSqrt\n\t\t: param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n\tabi.encode(address(this))\n);\n```\n\nand it has no deadline check for the transaction when swapping\n\n## Impact\n\nAMMs provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see Uniswap V2 and Uniswap V3). If such an option is not present, users can unknowingly perform bad trades:\n\nAlice wants to swap 100 tokens for 1 ETH and later sell the 1 ETH for 1000 DAI.\n\nThe transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n\nWhen the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of ETH could have drastically changed. She will still get 1 ETH but the DAI value of that output might be significantly lower. \n\nShe has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. \n\nThe price of tokens has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her maximum slippage value (sqrtPriceLimitX96 and minOut in terms of the Spell contracts) is outdated and would allow for significant slippage.\n\nA MEV bot detects the pending transaction. Since the outdated maximum slippage value now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L162-L175\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol use block.timstamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly!",
      "summary": "\nThis bug report is about an issue found in CurveSpell.sol, a smart contract used to provide liquidity to decentralized exchanges (DEXs). The issue is that the deadline check is set to type(uint256).max, which means the deadline check is disabled. This allows outdated slippage and pending transactions to be executed unexpectedly. \n\nThis issue can be maliciously exploited through the process of miner extractable value (MEV), where a MEV bot can detect a pending transaction and sandwich Alice, resulting in significant profit for the bot and significant loss for Alice. \n\nThe bug was found by Bauer, Breeje, and ctf_sec, and the code snippet can be found on GitHub.\n\nThe recommendation is that the protocol should use block.timestamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Lending Pool",
        "Deadline"
      ],
      "finders": [
        "Bauer",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18493",
      "title": "H-13: `BalancerPairOracle` can be manipulated using read-only reentrancy",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141 \n\n## Found by \ncuthalion0x\n## Summary\n\n`BalancerPairOracle.getPrice` makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. As a result, the oracle can be trivially manipulated to liquidate user positions prematurely.\n\n## Vulnerability Detail\n\nIn February, the Balancer team disclosed a read-only reentrancy vulnerability in the Balancer Vault. The detailed disclosure can be found [here](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345). In short, all Balancer pools are susceptible to manipulation of their external queries, and all integrations must now take an extra step of precaution when consuming data. Via reentrancy, an attacker can force token balances and BPT supply to be out of sync, creating very inaccurate BPT prices.\n\nSome protocols, such as Sentiment, remained unaware of this issue for a few months and were later [hacked](https://twitter.com/spreekaway/status/1643313471180644360) as a result.\n\n`BalancerPairOracle.getPrice` makes a price calculation of the form `f(balances) / pool.totalSupply()`, so it is clearly vulnerable to synchronization issues between the two data points. A rough outline of the attack might look like this:\n\n```solidity\nAttackerContract.flashLoan() ->\n    // Borrow lots of tokens and trigger a callback.\n    SomeProtocol.flashLoan() ->\n        AttackerContract.exploit()\n\nAttackerContract.exploit() ->\n    // Join a Balancer Pool using the borrowed tokens and send some ETH along with the call.\n    BalancerVault.joinPool() ->\n        // The Vault will return the excess ETH to the sender, which will reenter this contract.\n        // At this point in the execution, the BPT supply has been updated but the token balances have not.\n        AttackerContract.receive()\n\nAttackerContract.receive() ->\n    // Liquidate a position using the same Balancer Pool as collateral.\n    BlueBerryBank.liquidate() ->\n        // Call to the oracle to check the price.\n        BalancerPairOracle.getPrice() ->\n            // Query the token balances. At this point in the execution, these have not been updated (see above).\n            // So, the balances are still the same as before the start of the large pool join.\n            BalancerVaul.getPoolTokens()\n\n            // Query the BPT supply. At this point in the execution, the supply has already been updated (see above).\n            // So, it includes the latest large pool join, and as such the BPT supply has grown by a large amount.\n            BalancerPool.getTotalSupply()\n\n            // Now the price is computed using both balances and supply, and the result is much smaller than it should be.\n            price = f(balances) / pool.totalSupply()\n\n        // The position is liquidated under false pretenses.\n```\n\n## Impact\n\nUsers choosing Balancer pool positions (such as Aura vaults) as collateral can be prematurely liquidated due to unreliable price data.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/BalancerPairOracle.sol#L70-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe Balancer team recommends utilizing their [official library](https://github.com/balancer/balancer-v2-monorepo/blob/3ce5138abd8e336f9caf4d651184186fffcd2025/pkg/pool-utils/contracts/lib/VaultReentrancyLib.sol) to safeguard queries such as `Vault.getPoolTokens`. However, the library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are then two options:\n1. Invoke the library somewhere else. Perhaps insert a hook into critical system functions like `BlueBerryBank.liquidate`.\n2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "summary": "\nThis bug report is about the `BalancerPairOracle` contract, which is used to calculate the price of a Balancer Pool Token (BPT). The issue is that the `BalancerPairOracle.getPrice` function makes an external call to `BalancerVault.getPoolTokens` without checking the Balancer Vault's reentrancy guard. This means that the Oracle can be manipulated to liquidate user positions prematurely, as the price calculation is based on a combination of token balances and BPT supply.\n\nThe vulnerability was found by cuthalion0x and was initially disclosed by the Balancer team in February. It was later exploited in a hack of the Sentiment protocol.\n\nThe code snippet provided is from the `BalancerPairOracle.sol` file, line 70 to 92. The tool used was manual review.\n\nThe Balancer team recommends using their official library to safeguard queries such as `Vault.getPoolTokens`. However, this library makes a state-modifying call to the Balancer Vault, so it is not suitable for `view` functions such as `BalancerPairOracle.getPrice`. There are two possible solutions: 1. Invoke the library somewhere else, such as in critical system functions like `BlueBerryBank.liquidate`, or 2. Adapt a slightly different read-only solution that checks the Balancer Vault's reentrancy guard without actually entering.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141",
      "tags": [
        "Read-only Reentrancy",
        "Oracle",
        "Flash Loan"
      ],
      "finders": [
        "cuthalion0x"
      ]
    },
    {
      "id": "18492",
      "title": "H-12: Pending CRV rewards are not accounted for and can cause unfair liquidations",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136 \n\n## Found by \n0x52\n## Summary\n\npendingRewards are factored into the health of a position so that the position collateral is fairly assessed. However WCurveGauge#pendingRewards doesn't return the proper reward tokens/amounts meaning that positions aren't valued correctly and users can be unfairly liquidated.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n            }\n\nWhen BlueBerryBank is valuing a position it also values the pending rewards since they also have value. \n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {}\n\nAbove we see that WCurveGauge#pendingRewards returns empty arrays when called. This means that pending rewards are not factored in correctly and users can be liquidated when even when they should be safe.\n\n## Impact\n\nUser is liquidated when they shouldn't be\n\n## Code Snippet\n\n[WCurveGauge.sol#L106-L114](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WCurveGauge.sol#L106-L114)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange WCurveGauge#pendingRewards to correctly return the pending rewards",
      "summary": "\nThis bug report is about an issue found in the BlueBerryBank smart contract, which is used to value positions. The bug is that the WCurveGauge#pendingRewards function doesn't return the proper reward tokens or amounts, meaning that positions aren't valued correctly and users can be unfairly liquidated. This is due to the fact that BlueBerryBank is valuing a position and also valuing the pending rewards, which have value. The impact of this bug is that users are liquidated when they shouldn't be. The bug was found through manual review, and the recommendation is to change WCurveGauge#pendingRewards to correctly return the pending rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/136",
      "tags": [
        "Liquidation",
        "Coding-Bug",
        "Array"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18491",
      "title": "H-11: ShortLongSpell#openPosition can cause user unexpected liquidation when increasing position size",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWhen increasing a position, all collateral is sent to the user rather than being kept in the position. This can cause serious issues because this collateral keeps the user from being liquidated. It may unexpectedly leave the user on the brink of liquidation where a small change in price leads to their liquidation.\n\n## Vulnerability Detail\n\n[ShortLongSpell.sol#L129-L141](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L129-L141)\n\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collSize = pos.collateralSize;\n            address burnToken = address(ISoftVault(strategy.vault).uToken());\n            if (collSize > 0) {\n                if (posCollToken != address(wrapper))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wrapper.burn(burnToken, collSize);\n                _doRefund(burnToken);\n            }\n        }\n\nIn the above lines we can see that all collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nBest case the user's transaction reverts but worst case they will be liquidated almost immediately.  \n\n## Impact\n\nUnfair liquidation for users\n\n## Code Snippet\n\n[ShortLongSpell.sol#L111-L151](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L111-L151)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't burn the collateral",
      "summary": "\nThis bug report is about ShortLongSpell#openPosition, a function in the ShortLongSpell.sol contract, which can cause users to experience unexpected liquidation when increasing their position size. The bug was discovered by 0x52 and Ch_301 using manual review.\n\nThe bug occurs when all of the collateral is sent to the user rather than kept in the position. This can lead to serious issues as the collateral is needed to prevent liquidation. As a result, users may find themselves on the brink of liquidation and a small change in price could lead to their liquidation.\n\nThe code snippet for this issue is found in ShortLongSpell.sol#L129-L141. Here, all of the collateral is burned and the user is sent the underlying tokens. This is problematic as it sends all the collateral to the user, leaving the position collateralized by only the isolated collateral.\n\nThe impact of this bug is that users may experience unfair liquidation. The recommendation is to not burn the collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/135",
      "tags": [
        "Liquidation",
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18490",
      "title": "H-10: Balance check for swapToken in ShortLongSpell#_deposit is incorrect and will result in nonfunctional contract",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133 \n\n## Found by \n0x52, Ch\\_301, sinarette\n## Summary\n\nThe balance checks on ShortLongSpell#_withdraw are incorrect and will make contract basically nonfunctional \n\n## Vulnerability Detail\n\nswapToken is always vault.uToken. borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. \n\n[ShortLongSpell.sol#L83-L89](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L83-L89)\n\n        uint256 strTokenAmt = _doBorrow(param.borrowToken, param.borrowAmount);\n\n        // 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        // swapData.fromAmount = strTokenAmt;\n        PSwapLib.megaSwap(augustusSwapper, tokenTransferProxy, swapData);\n        strTokenAmt = swapToken.balanceOf(address(this)) - strTokenAmt; <- @audit-issue will always revert on swap\n\nBecause swapToken == borrowToken if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional\n\n## Impact\n\nShortLongSpell is nonfunctional\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L202](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove check",
      "summary": "\nThis bug report is about the balance check for swapToken in ShortLongSpell#_deposit being incorrect and resulting in a nonfunctional contract. It was found by 0x52, Ch\\_301 and sinarette using manual review. \n\nThe issue is that swapToken is always vault.uToken and borrowToken is always required to be vault.uToken which means that swapToken == borrowToken. This means that the token borrowed is always required to be swapped. Because swapToken == borrowToken, if there is ever a swap then the swapToken balance will decrease. This causes L89 to always revert when a swap happens, making the contract completely non-functional. \n\nThe impact of this bug is that ShortLongSpell is nonfunctional. The code snippet of the issue is located at ShortLongSpell.sol#L160-L202. The recommendation is to remove the check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/133",
      "tags": [
        "Swap",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "sinarette",
        "0x52"
      ]
    },
    {
      "id": "18489",
      "title": "H-9: UniswapV3 sqrtRatioLimit doesn't provide slippage protection and will result in partial swaps",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132 \n\n## Found by \n0x52\n## Summary\n\nThe sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead it just cause the swap to partially fill. This is a [known issue](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L641) with using sqrtRatioLimit as can be seen here where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L209-L223\n\n        if (amountToSwap > 0) {\n            SWAP_POOL = IUniswapV3Pool(vault.pool());\n            uint160 deltaSqrt = (param.sqrtRatioLimit *\n                uint160(param.sellSlippage)) / uint160(Constants.DENOMINATOR);\n            SWAP_POOL.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                amountToSwap.toInt256(),\n                isTokenA\n                    ? param.sqrtRatioLimit + deltaSqrt\n                    : param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n                abi.encode(address(this))\n            );\n        }\n\nsqrtRatioLimit is used as slippage protection for the user but is ineffective and depending on what tokens are being swapped, tokens may be left the in the contract which can be stolen by anyone.\n\n## Impact\n\nIncorrect slippage application can result in partial swaps and loss of funds\n\n## Code Snippet\n\n[IchiSpell.sol#L181-L236](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/IchiSpell.sol#L181-L236)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the amount received from the swap and compare it against some user supplied minimum",
      "summary": "\nThis bug report is about the issue H-9 which was found by 0x52. The sqrtRatioLimit for UniV3 doesn't cause the swap to revert upon reaching that value. Instead, it just causes the swap to partially fill. This is a known issue with using sqrtRatioLimit as can be seen in the code snippet, where the swap ends prematurely when it has been reached. This is problematic as this is meant to provide the user with slippage protection but doesn't. This incorrect slippage application can result in partial swaps and loss of funds. The code snippet provided is from IchiSpell.sol#L181-L236. The tool used to identify this bug was manual review. The recommendation given is to check the amount received from the swap and compare it against some user supplied minimum.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/132",
      "tags": [
        "Uniswap",
        "Swap",
        "Slippage",
        "Missing-Logic",
        "Configuration"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "18488",
      "title": "H-8: UserData for balancer pool exits is malformed and will permanently trap users",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nUserData for balancer pool exits is malformed and will result in all withdrawal attempts failing, trapping the user permanently. \n\n## Vulnerability Detail\n\n[AuraSpell.sol#L184-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189)\n\n    wAuraPools.getVault(lpToken).exitPool(\n        IBalancerPool(lpToken).getPoolId(),\n        address(this),\n        address(this),\n        IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n    );\n\nWe see above that UserData is encoded as \"\". This is problematic as it doesn't contain the proper data for exiting the pool, causing all exit request to fail and trap the user permanently.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F9#L50\n\n    function exactBptInForTokenOut(bytes memory self) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (WeightedPool.ExitKind, uint256, uint256));\n    }\n\nUserData is decoded into the data shown above when using ExitKind = 0. Since the exit uses \"\" as the user data this will be decoded as 0 a.k.a [EXACT_BPT_IN_FOR_ONE_TOKEN_OUT](https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L50). This is problematic because the token index and bptAmountIn should also be encoded in user data for this kind of exit. Since it isn't the exit call will always revert and the user will be permanently trapped.\n\n## Impact\n\nUsers will be permanently trapped, unable to withdraw\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEncode the necessary exit data in userData",
      "summary": "\nThis bug report is about an issue found in the code of the AuraSpell.sol contract. The code in question is located at https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L189. This code is responsible for handling the exit of users from a balancer pool. \n\nThe issue is that the UserData for the balancer pool exits is malformed and does not contain the proper data for exiting the pool. This will cause all exit requests to fail, trapping the user permanently. This issue was found by 0x52 and cuthalion0x while manually reviewing the code. \n\nThe impact of this issue is that users will be permanently trapped, unable to withdraw. The recommended solution to this issue is to encode the necessary exit data in the userData.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/129",
      "tags": [
        "Lending Pool",
        "Data Validation",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18487",
      "title": "H-7: WAuraPools will irreversibly break if reward tokens are added to pool after deposit",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nWAuraPools will irreversibly break if reward tokens are added to pool after deposit due to an OOB error on accExtPerShare.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength(); <- @audit-issue rewardTokenCount pulled fresh\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n\n            @audit-issue attempts to pull from array which will be too small if tokens are added\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\naccExtPerShare stores the current rewardPerToken when the position is first created. It stores it as an array and only stores values for reward tokens that have been added prior to minting. This creates an issue if a reward token is added because now it will attempt to pull a value for an index that doesn't exist and throw an OOB error.\n\nThis is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute.\n\n## Impact\n\nWAuraPools will irreversibly break if reward tokens are added to pool after\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a mapping rather than an array to store values",
      "summary": "\nThis bug report is about the WAuraPools smart contract. It was found by 0x52 and Ch_301 and is related to the issue of adding reward tokens to a pool after a deposit. This results in an Out of Bounds (OOB) error on the accExtPerShare variable, which is an array that stores the current reward per token when the position is first created. This OOB error occurs because the array only stores values for reward tokens that were added prior to minting, and so if a reward token is added after, it will attempt to pull a value for an index that doesn't exist. This is problematic because pendingRewards is called every single transaction via the isLiquidatable subcall in BlueBerryBank#execute. As a result, WAuraPools will irreversibly break if reward tokens are added to the pool after a deposit. The code snippet associated with this issue is found in the WAuraPools.sol file from line 152 to line 190. The tool used to find this bug was manual review. The recommendation to solve this issue is to use a mapping rather than an array to store values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/127",
      "tags": [
        "Missing-Logic",
        "Mapping",
        "Coding-Bug",
        "Array Bound"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18486",
      "title": "H-6: ShortLongSpell#_withdraw checks slippage limit but never applies it making it useless",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126 \n\n## Found by \n0x52, Ch\\_301\n## Summary\n\nSlippage limits protect the protocol in the event that a malicious user wants to extract value via swaps, this is an important protection in the event that a user finds a way to trick collateral requirements. Currently the sell slippage is checked but never applied so it is useless.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nSlippage limit protections are ineffective for ShortLongSpell\n\n## Code Snippet\n\n[ShortLongSpell.sol#L160-L20](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApply sell slippage after it is checked\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is not a valid M/H. The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI still think this is a valid issue\n\nsellSlippage checked but not applied\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/spell/ShortLongSpell.sol#L160-L202\n\n```solidity\n   function _withdraw(\n        ClosePosParam calldata param,\n        Utils.MegaSwapSellData calldata swapData\n    ) internal {\n        if (param.sellSlippage > bank.config().maxSlippageOfClose())\n            revert Errors.RATIO_TOO_HIGH(param.sellSlippage);\n```\n\nit is true that the slippage is checked but not applied\n\n> The toAmont and expectedAmount in the off-chain parameter [MegaSwapSellData](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/libraries/Paraswap/Utils.sol#L30-L42) structure are the real slippage protection parameters. Just like ExactInputParams/ExactOutputParams of uniswapV3 pool.\n\nthis is true, but the code should still check the slippage based on the received amount instead of off-chain parameter\n\n\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nAgree with the Lead judge comment. \nSlippage must be checked on code whenever possible instead of an off-chain parameter. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> Agree with the Lead judge comment. \n> Slippage must be checked on code whenever possible instead of an off-chain parameter. \n> \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nA bug has been identified in the ShortLongSpell protocol, where the sell slippage is checked but never applied, making it useless. This is an important protection in the event that a user finds a way to trick collateral requirements. The code snippet that is affected can be found at ShortLongSpell.sol#L160-L202. The bug was discovered by 0x52 and Ch\\_301.\n\nThe impact of this bug is that slippage limit protections are ineffective for ShortLongSpell. The recommendation is to apply sell slippage after it is checked.\n\nThe bug was discussed by securitygrid, sherlock-admin, ctf-sec, and hrishibhat. Securitygrid pointed out that the toAmont and expectedAmount in the off-chain parameter MegaSwapSellData structure are the real slippage protection parameters, and that this is similar to the ExactInputParams/ExactOutputParams of uniswapV3 pool. Ctf-sec argued that the code should still check the slippage based on the received amount instead of off-chain parameter. Hrishibhat then rejected the escalation, saying that slippage must be checked on code whenever possible instead of an off-chain parameter. Sherlock-admin then confirmed that the escalations had been rejected and that Watsons who escalated the issue will have their escalation amount deducted from their next payout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/126",
      "tags": [
        "Slippage",
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "Ch\\_301",
        "0x52"
      ]
    },
    {
      "id": "18485",
      "title": "H-5: ConvexSpell#closePositionFarm removes liquidity without any slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124 \n\n## Found by \n0x52, Breeje, Ch\\_301, n1punp\n## Summary\n\nConvexSpell#closePositionFarm removes liquidity without any slippage protection allowing withdraws to be sandwiched and stolen. Curve liquidity has historically been strong but for smaller pairs their liquidity is getting low enough that it can be manipulated via flashloans. \n\n## Vulnerability Detail\n\n[ConvexSpell.sol#L204-L208](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L204-L208)\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n\nLiquidity is removed as a single token which makes it vulnerable to sandwich attacks but no slippage protection is implemented. The same issue applies to CurveSpell.\n\n## Impact\n\nUser withdrawals can be sandwiched\n\n## Code Snippet\n\n[ConvexSpell.sol#L147-L230](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L147-L230)\n\n[CurveSpell.sol#L143-L223](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L143-L223)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify min out",
      "summary": "\nThis bug report is about the ConvexSpell and CurveSpell smart contracts, which are used to remove liquidity from Curve pools. The issue is that these smart contracts remove liquidity without any slippage protection, which makes them vulnerable to sandwich attacks. This means that user withdrawals can be sandwiched and stolen. The code snippets which are vulnerable to this attack are ConvexSpell.sol#L147-L230 and CurveSpell.sol#L143-L223. The bug was found by 0x52, Breeje, Ch_301, and n1punp. The recommended solution is to allow users to specify a minimum out.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/124",
      "tags": [
        "Slippage",
        "Sandwich Attack",
        "Flash Loan"
      ],
      "finders": [
        "Ch\\_301",
        "0x52",
        "Breeje",
        "n1punp"
      ]
    },
    {
      "id": "18484",
      "title": "H-4: Potential flash loan attack vulnerability in `getPrice` function of CurveOracle",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123 \n\n## Found by \nBauer, helpMePlease\n## Summary\nDuring a security review of the `getPrice` function in the CurveOracle, a potential flash loan attack vulnerability was identified.\n\n## Vulnerability Detail\nThe `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users.\n\n## Impact\nThis vulnerability could potentially allow attackers to manipulate the price of tokens in Curve LP pools and profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\nuse TWAP to determine the prices of the underlying assets in the pool.",
      "summary": "\nA security review of the `getPrice` function in the CurveOracle revealed a potential flash loan attack vulnerability. The `getPrice` function retrieves the spot price of each token in a Curve LP pool, calculates the minimum price among them, and multiplies it by the virtual price of the LP token to determine the USD value of the LP token. If the price of one or more tokens in the pool is manipulated, this can cause the minimum price calculation to be skewed, leading to an incorrect USD value for the LP token. This can be exploited by attackers to make a profit at the expense of other users. If exploited, this vulnerability could result in significant financial losses for affected users. The code snippet for this vulnerability can be found at  https://github.com/sherlock-audit/2023-04-blueberry/blob/96eb1829571dc46e1a387985bd56989702c5e1dc/blueberry-core/contracts/oracle/CurveOracle.sol#L122. The security review was conducted manually. The recommendation to mitigate this vulnerability is to use TWAP (Time-Weighted Average Price) to determine the prices of the underlying assets in the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/123",
      "tags": [
        "Oracle",
        "Lending Pool",
        "Flash Loan"
      ],
      "finders": [
        "Bauer",
        "helpMePlease"
      ]
    },
    {
      "id": "18483",
      "title": "H-3: Users are forced to swap all reward tokens with no slippage protection",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121 \n\n## Found by \n0x52, Bauer, Breeje, J4de, ctf\\_sec, n1punp, nobody2018\n## Summary\n\nAuraSpell forces users to swap their reward tokens to debt token but doesn't allow them to specify any slippage values.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L193-L203\n](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L193-L203)\n\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\nAbove all reward tokens are swapped and always use 0 for min out meaning that deposits will be sandwiched and stolen.\n\n## Impact\n\nAll reward tokens can be sandwiched and stolen\n\n## Code Snippet\n\n[AuraSpell.sol#L149-L224](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L149-L224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify slippage parameters for all reward tokens",
      "summary": "\nThis bug report is about an issue found in the AuraSpell.sol contract, which is part of the Sherlock Audit project. The issue is that users are forced to swap all reward tokens with no slippage protection. This was found through manual review by 0x52, Bauer, Breeje, J4de, ctf_sec, n1punp, and nobody2018.\n\nThe vulnerability detail is that the code snippet for the swap function does not allow users to specify any slippage values, meaning that deposits can be sandwiched and stolen. This can result in all reward tokens being sandwiched and stolen. The code snippet for the vulnerability can be found in AuraSpell.sol#L193-L203 and the full code snippet can be found in AuraSpell.sol#L149-L224.\n\nThe impact of this vulnerability is that all reward tokens can be sandwiched and stolen. The recommendation for this issue is to allow users to specify slippage parameters for all reward tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/121",
      "tags": [
        "Slippage",
        "Deposit/Reward tokens"
      ],
      "finders": [
        "Bauer",
        "0x52",
        "J4de",
        "n1punp",
        "nobody2018",
        "Breeje",
        "ctf\\_sec"
      ]
    },
    {
      "id": "18482",
      "title": "H-2: AuraSpell#openPositionFarm uses incorrect join type for balancer",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120 \n\n## Found by \n0x52, cuthalion0x\n## Summary\n\nThe JoinPoolRequest uses \"\" for userData meaning that it will decode into 0. This is problematic because join requests of type 0 are \"init\" type joins and will revert for pools that are already initialized. \n\n## Vulnerability Detail\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49\n\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n\nWe see above that enum JoinKind is INIT for 0 values.\n\nhttps://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L290\n\n            return _joinExactTokensInForBPTOut(balances, normalizedWeights, userData);\n        } else if (kind == JoinKind.TOKEN_IN_FOR_EXACT_BPT_OUT) {\n            return _joinTokenInForExactBPTOut(balances, normalizedWeights, userData);\n        } else {\n            _revert(Errors.UNHANDLED_JOIN_KIND);\n        }\n\nHere user data is decoded into join type and since it is \"\" it will decode to type 0 which will result in a revert.\n\n## Impact\n\nUsers will be unable to open any farm position on AuraSpell\n\n## Code Snippet\n\n[AuraSpell.sol#L63-L147](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L63-L147)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUses JoinKind = 1 for user data",
      "summary": "\nThis bug report is about an issue found in the AuraSpell#openPositionFarm function in the Sherlock Audit 2023-04-blueberry-judging repository. The issue is that the JoinPoolRequest uses \"\" for userData, which will decode into 0, resulting in a join request of type 0, which is an \"init\" type join and will revert for pools that are already initialized. This issue was found by 0x52 and cuthalion0x and confirmed by manual review. The impact of this issue is that users will be unable to open any farm position on AuraSpell. The code snippet for this issue can be found in the AuraSpell.sol#L63-L147. The recommendation is to use JoinKind = 1 for user data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/120",
      "tags": [
        "Configuration",
        "Coding-Bug"
      ],
      "finders": [
        "0x52",
        "cuthalion0x"
      ]
    },
    {
      "id": "18481",
      "title": "H-1: attackers will keep stealing the `rewards` from Convex SPELL",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101 \n\n## Found by \nBauer, Ch\\_301\n## Summary\nOn [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) transfer [CRV + CVX + the extra rewards](https://docs.convexfinance.com/convexfinance/general-information/why-convex/convex-for-liquidity-providers) to Convex SPELL \n\n\n## Vulnerability Detail\nBut [ConvexSpell.openPositionFarm()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L67-L138) only refund CVX to the user.\nSo the rest rewards will stay in the SPELL intel if someone (could be an attacker) invokes `_doRefund()` within `closePositionFarm()` with the same address tokens \n\n## Impact\n- Convex SPELL steals the user rewards \n- the protocol will lose some fees \n- attackers will keep stealing the rewards from Convex SPELL\n\n## Code Snippet\n`WConvexPools.burn()` transfer CRV + CVX + the extra rewards\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235\n```solidity\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n```\n\nonly refund CVX to the user\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#LL127C1-L138C10\n```solidity\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nyou should Refund all Rewards (CRV + CVX + the extra rewards)\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nConvex docs are confirming this point \n\n```diff\nConvex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\nEarn claimable CRV with a high boost without locking any CRV\nEarn CVX rewards\nZero deposit and withdraw fees\nZero fees on extra incentive tokens (SNX, etc)\n```\nand [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n\nso Convex SPELL should refund all the rewards\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Convex docs are confirming this point \n> \n> ```diff\n> Convex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\n> Earn claimable CRV with a high boost without locking any CRV\n> Earn CVX rewards\n> Zero deposit and withdraw fees\n> Zero fees on extra incentive tokens (SNX, etc)\n> ```\n> and [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n> \n> so Convex SPELL should refund all the rewards\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSenior watson's comment:\n\nsame as\nhttps://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \nThis issue is a valid high along with another duplicate #42\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n> This issue is a valid high along with another duplicate #42\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Convex SPELL code. The code allows users to transfer CRV, CVX, and extra rewards to the SPELL, but only refunds CVX to the user when the position is closed. This means that the extra rewards remain in the SPELL, and can be stolen by attackers if they invoke the same address tokens with the _doRefund() function. This vulnerability can cause the Convex SPELL to steal user rewards, leading to the protocol losing fees, and attackers being able to keep stealing rewards from the SPELL. The code snippet provided in the report shows the WConvexPools.burn() function, which transfers CRV, CVX, and extra rewards, and the ConvexSpell.openPositionFarm() function, which only refunds CVX to the user. The tool used to identify this bug was manual review. The recommendation is to refund all rewards (CRV + CVX + the extra rewards). The discussion that followed included a comment from Ch-301, who suggested escalating the bug for 10 USDC, and Convex docs to confirm the point. Senior Watson's comment pointed to a duplicate issue, and Hrishibhat accepted the escalation. Finally, Sherlock-Admin confirmed that the issue's escalation had been accepted, and that contestants' payouts and scores would be updated accordingly.",
      "quality_score": 1,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Blueberry Update",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101",
      "tags": [
        "Deposit/Reward tokens",
        "Coding-Bug",
        "Business Logic"
      ],
      "finders": [
        "Bauer",
        "Ch\\_301"
      ]
    },
    {
      "id": "10336",
      "title": "Incomplete Docstrings",
      "impact": "LOW",
      "content": "Although docstrings are present above the [`_countVoteNominal`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L124-L127) and [`_countVoteFractional`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L151-L156) functions, they do not provide complete information about the purpose of these functions and the parameters passed to them.\n\n\nSince the `GovernorCountingFractional` contract supports rolling votes, once an address has cast a portion of its votes using the `_countVoteFractional` function, the subsequent votes should be cast by calling the `_countVoteFractional` function again, even if the votes are in favor of only one option.\n\n\nConsider adding proper docstrings to the functions, following the NatSpec format, stating the scenarios in which these functions should be called, and mentioning their limitations.\n\n\n***Update**: Resolved in [pull request #42](https://github.com/ScopeLift/flexible-voting/pull/42) at commit [c19467a](https://github.com/ScopeLift/flexible-voting/pull/42/commits/c19467a81255a7d1e9f262a41bd526905c453d4f).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ScopeLift Flexible Voting Audit",
      "source_link": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10335",
      "title": "Change Quorum to Account for Abstain Votes",
      "impact": "LOW",
      "content": "The [`COUNTING_MODE` function](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L45) in the `GovernorCountingFractional` contract sets the [quorum to `bravo`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L46), meaning that only [the `For` votes are counted to reach the quorum](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L79).\n\n\nIt is noted that the projects integrating with this contract can `override` the `COUNTING_MODE` and `_quorumReached` functions to choose their preferred quorum setting. However, since the `GovernorCountingFractional` contract is to be used as a library, it is recommended to allow both `For` and `Abstain` votes to be included in reaching a quorum. This would also help in improving the compatibility and consistency with OpenZeppelin’s governance modules.\n\n\nConsider changing the quorum to `for,abstain` to be consistent with OpenZeppelin’s [`GovernorCountingSimple` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.2/contracts/governance/extensions/GovernorCountingSimple.sol#L37).\n\n\n***Update**: Resolved in [pull request #41](https://github.com/ScopeLift/flexible-voting/pull/41) at commit [450b444](https://github.com/ScopeLift/flexible-voting/pull/41/commits/450b444ef167c337b3119f5f224a69b2daea36f4).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ScopeLift Flexible Voting Audit",
      "source_link": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10334",
      "title": "Inconsistent Ordering of Votes",
      "impact": "LOW",
      "content": "In [`GovernorCountingFractional.sol`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol), the [`ProposalVote` struct](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L23-L27) is defined in the following order: `againstVotes`, `forVotes`, `abstainVotes`. This order aligns with the standard usage in [OpenZeppelin’s contracts library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6db3408885aeeb35bf9d31c9efc148def81b6d94/contracts/governance/IGovernor.sol#L92) as well as in [Compound’s Bravo](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/Governance/GovernorBravoInterfaces.sol#L12).\n\n\nHowever, the `voteData` bytes parameter received by the [`_countVote` function](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L98-L100) requires a different order: `forVotes`, `againstVotes`, `abstainVotes`. While the code currently handles the decoding of this bytes parameter correctly, this inconsistency in the ordering can be problematic for projects that are integrating with the `GovernorCountingFractional` contract.\n\n\nIn the interest of improving clarity and being less error-prone, consider changing the order of the `voteData` to require votes in the originally-defined order (`againstVotes`, `forVotes`, `abstainVotes`).\n\n\n***Update**: Resolved in [pull request #40](https://github.com/ScopeLift/flexible-voting/pull/40) at commit [8bea587](https://github.com/ScopeLift/flexible-voting/pull/40/commits/8bea5877a8533b55bc6ac449c0063dc53f94f127).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ScopeLift Flexible Voting Audit",
      "source_link": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "5642",
      "title": "M-2: The `_fee()` function is wrongly implemented in the code",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95 \n\n## Found by \nCh\\_301\n\n## Summary\n _fee() function is wrongly implemented in the code so the protocol will get fewer fees and the trader will earn more\n\n## Vulnerability Detail\n```solidity\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n```\nlet's say we have:\n`newFee` 100 USDC\nUSDC Decimals is 6\n`settlementFeePercentage` is 20% ==> 200\n\nThe `unitFee` will be 520_000\n\n`amount` = (100 * 1_000_000) / 520_000 \n`amount` = 192 USDC\nWhich is supposed to be  `amount` = 160 USDC\n\n## Impact\nThe protocol will earn fees less than expected\n\n## Code Snippet\n```solidity\n       function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L318-L353\n\n```solidity\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L424-L437\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `_fee()` function needs to calculate the fees in this way\n```solidity\ntotal_fee = (5000 * amount)/ (10000 - sf)\n```\n\n## Discussion\n\n**0x00052**\n\nFixed in [PR#22](https://github.com/bufferfinance/Buffer-Protocol-v2/pull/22)\n\nChanges look good. New math returns correct values. Validated for both unit fee and option amount.",
      "summary": "\nThis bug report is about the `_fee()` function which is wrongly implemented in the code. This means the protocol will get fewer fees and the trader will earn more. The incorrect implementation of the function is causing the amount to be calculated incorrectly. For example, if the `newFee` is 100 USDC and the USDC Decimals is 6, the `settlementFeePercentage` is 20%, the `unitFee` will be 520_000 and the `amount` should be 160 USDC, but the function is calculating it as 192 USDC. This means the protocol will earn fees less than expected. The bug was found by Ch\\_301 and the tool used for the review was manual review. The recommendation to fix the bug is to calculate the fees using this formula: `total_fee = (5000 * amount)/ (10000 - sf)`. The changes were made in PR#22 and the changes look good and the new math returns correct values.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95",
      "tags": [],
      "finders": [
        "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95",
        "Ch\\_301"
      ]
    },
    {
      "id": "3835",
      "title": "M-3: resolveQueuedTrades is intended to be non atomic but invalid signature can still cause entire transaction to revert",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/84 \n\n## Found by \n0x52\n\n## Summary\n\nBufferRouter#resolveQueuedTrades and unlockOptions attempt to be non atomic (i.e. doesn't revert the transaction if one fails) but an invalid signature can still cause the entire transaction to revert, because the ECDSA.recover sub call in _validateSigner can still revert.\n\n## Vulnerability Detail\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n_validateSigner can revert at the ECDSA.recover sub call breaking the intended non atomic nature of BufferRouter#resolveQueuedTrades and unlockOptions.\n\n## Impact\n\nBufferRouter#resolveQueuedTrades and unlockOptions don't function as intended if signature is malformed\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L260-L271\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse a try statement inside _validateSigner to avoid any reverts:\n\n        function _validateSigner(\n            uint256 timestamp,\n            address asset,\n            uint256 price,\n            bytes memory signature\n        ) internal view returns (bool) {\n            bytes32 digest = ECDSA.toEthSignedMessageHash(\n                keccak256(abi.encodePacked(timestamp, asset, price))\n            );\n    -       address recoveredSigner = ECDSA.recover(digest, signature);\n\n    +       try ECDSA.recover(digest, signature) returns (address recoveredSigner) {\n    +           return recoveredSigner == publisher;\n    +       } else {\n    +           return false;\n    +       }\n        }\n\n## Discussion\n\n**bufferfinance**\n\nThe protocol has been tested against wrong signatures.\n[https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/tests/test_router.py#L815](url)\n\n**0x00052**\n\nEscalate for 10 USDC.\n\nMy submission is valid and sponsor's comment here is inaccurate. ECDSA.recover will revert in the _throwError subcall under quite a few conditions not covered by their tests, including signature of invalid length and signature that resolve to address(0).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/24d1bb668a1152528a6e6d71c2e285d227ed19d9/contracts/utils/cryptography/ECDSA.sol#L88-L92 \n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> My submission is valid and sponsor's comment here is inaccurate. ECDSA.recover will revert in the _throwError subcall under quite a few conditions not covered by their tests, including signature of invalid length and signature that resolve to address(0).\n> \n> https://github.com/OpenZeppelin/openzeppelin-contracts/blob/24d1bb668a1152528a6e6d71c2e285d227ed19d9/contracts/utils/cryptography/ECDSA.sol#L88-L92 \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nInvalid signatures resolving to address(0) reverts _validateSigner \n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> Invalid signatures resolving to address(0) reverts _validateSigner \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**bufferfinance**\n\nWill fix this\n\n\n**0x00052**\n\nFixed in [PR#28](https://github.com/bufferfinance/Buffer-Protocol-v2/pull/28)\n\nChanges look good.  ECDSA.recover changed to ECDSA.tryRecover to prevent any revert when recovering signatures",
      "summary": "\nThis bug report is about an issue found in the BufferRouter#resolveQueuedTrades and unlockOptions functions of the Buffer Protocol V2. The issue is that an invalid signature can cause the entire transaction to revert, breaking the intended non atomic nature of the functions. This issue was found by 0x52 and is detailed in the code snippet provided. The impact of this issue is that BufferRouter#resolveQueuedTrades and unlockOptions don't function as intended if the signature is malformed. \n\nTo fix this issue, 0x52 recommended using a try statement inside _validateSigner to avoid any reverts. This recommendation was accepted by the bufferfinance team and was fixed in PR#28. The changes look good and ECDSA.recover was changed to ECDSA.tryRecover to prevent any revert when recovering signatures.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/84",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3631",
      "title": "M-5: Limited support to a specific subset of ERC20 tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/73 \n\n## Found by \nak1, bin2chen, 0x4non, jonatascm, sach1r0, pashov, HonorLt, peanuts, m\\_Rassska, adriro, Deivitto, \\_\\_141345\\_\\_, eierina, 0xcc, rvierdiiev, cccz, minhtrng, ctf\\_sec, aphak5010, Bnke0x0, eyexploit, hansfriese, 0x007\n\n## Summary\n\nBuffer contest states 'any ERC20 supported', therefore it should take into account all the different ways of signalling success and failure.  This is not the case, as all ERC20's transfer(), transferFrom(), and approve() functions are either not verified at all or verified for returning true. As a result, depending on the ERC20 token, some transfer errors may result in passing unnoticed, and/or some successfull transfer may be treated as failed.\n\nCurrently the only supported ERC20 tokens are the ones that fulfill both the following requirements:\n- always revert on failure;\n- always returns boolean true on success.\n\nAn example of a very well known token that is not supported is Tether USD (USDT).\n\n> **👋** IMPORTANT\n> This issue is not the same as reporting that \"return value must be verified to be true\" where the checks are missing! Indeed **such a simplistic report should be considered invalid** as it still does not solve all the problems but rather introduces others. See Vulnerability Details section for rationale.\n\n## Vulnerability Detail\n\nTokens have different ways of signalling success and failure, and this affect mostly transfer(), transferFrom() and approve() in ERC20 tokens. While some tokens revert upon failure, others consistently return boolean flags to indicate success or failure, and many others have mixed behaviours.\n\nSee below a snippet of the [USDT Token contract](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L1) compared to the 0x's [ZRX Token contract](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L1) where the USDT Token transfer function does not even return a boolean value, while the ZRX token consistently returns boolean value hence returning false on failure instead of reverting.\n\n***USDT Token snippet (no return value) from Etherscan***\n```solidity\nfunction transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n\tvar _allowance = allowed[_from][msg.sender];\n\n\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\t// if (_value > _allowance) throw;\n\n\tuint fee = (_value.mul(basisPointsRate)).div(10000);\n\tif (fee > maximumFee) {\n\t\tfee = maximumFee;\n\t}\n\tif (_allowance < MAX_UINT) {\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n\t}\n\tuint sendAmount = _value.sub(fee);\n\tbalances[_from] = balances[_from].sub(_value);\n\tbalances[_to] = balances[_to].add(sendAmount);\n\tif (fee > 0) {\n\t\tbalances[owner] = balances[owner].add(fee);\n\t\tTransfer(_from, owner, fee);\n\t}\n\tTransfer(_from, _to, sendAmount);\n}\n```\n\n***ZRX Token snippet (consistently true or false boolean result) from Etherscan***\n```solidity\nfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\n\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n\t\tbalances[_to] += _value;\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tTransfer(_from, _to, _value);\n\t\treturn true;\n\t} else { return false; }\n}\n```\n\n## Impact\n\nGiven the different usages of token transfers in BufferBinaryOptions.sol, BufferBinaryPool.sol, and BufferRouter.sol, there can be 2 types of impacts depending on the ERC20 contract being traded.\n\n### Impact type 1\nThe ERC20 token being traded is one that consistently returns a boolean result in the case of success and failure like for example [0x](https://www.0x.org/)'s [ZRX Token contract](https://etherscan.io/token/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L1). Where the return value is currently not verified to be true (i.e.: [#1](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86), [#2](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L331), [#3](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L335), [#4](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L361), [#5](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L141), [#6](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L477)) the transfer may fail (e.g.: no tokens transferred due to insufficient balance) but the error would not be detected by the Buffer contracts.\n\n### Impact type 2\nThe ERC20 token being traded is one that do not return a boolean value like for example the well knonw [Tether USD Token contract](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L1). Successful transfers would cause a revert in the Buffer contracts where the return value is verified to be true (i.e.: [#1](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L162), [#2](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L205), [#3](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L241), [#4](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L323)) due to the token not returing boolean results.\n\nSame is true for appove calls.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86-L90\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L331\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L335-L338\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L361-L364\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L141\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L477\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L162\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L205\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L241\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L323\n\n## Tool used\n\nManual Review\n\n## Recommendation\nTo handle most of these inconsistent behaviors across multiple tokens, either use OpenZeppelin's [SafeERC20 library](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20), or use a more reusable implementation (i.e. library) of the following intentionally explicit, descriptive example code for an ERC20 transferFrom() call that takes into account all the different ways of signalling success and failure, and apply to all ERC20 transfer(), transferFrom(), approve() calls in the Buffer contracts.\n\n```solidity\nIERC20 token = whatever_token;\n\n(bool success, bytes memory returndata) = address(token).call(abi.encodeWithSelector(IERC20.transferFrom.selector, sender, recipient, amount));\n\n// if success == false, without any doubts there was an error and callee reverted\nrequire(success, \"Transfer failed!\");\n\n// if success == true, we need to check whether we got a return value or not (like in the case of USDT)\nif (returndata.length > 0) {\n\t// we got a return value, it must be a boolean and it should be true\n\trequire(abi.decode(returndata, (bool)), \"Transfer failed!\");\n} else {\n\t// since we got no return value it can be one of two cases:\n\t// 1. the transferFrom does not return a boolean and it did succeed\n\t// 2. the token address is not a contract address therefore call() always return success = true as per EVM design\n\t// To discriminate between 1 and 2, we need to check if the address actually points to a contract\n\trequire(address(token).code.length > 0, \"Not a token address!\");\n}\n```",
      "summary": "\nThis bug report concerns limited support to a specific subset of ERC20 tokens in the Buffer contest. It was found by ak1, bin2chen, 0x4non, jonatascm, sach1r0, pashov, HonorLt, peanuts, m\\_Rassska, adriro, Deivitto, \\_\\_141345\\_\\_, eierina, 0xcc, rvierdiiev, cccz, minhtrng, ctf\\_sec, aphak5010, Bnke0x0, eyexploit, hansfriese, 0x007 and was manually reviewed. \n\nCurrently, the only supported ERC20 tokens are the ones that fulfill both the following requirements: they always revert on failure and always return boolean true on success. An example of a token that is not supported is Tether USD (USDT).\n\nDepending on the ERC20 token, some transfer errors may result in passing unnoticed, and/or some successfull transfer may be treated as failed. There can be two types of impacts depending on the ERC20 contract being traded. \n\nThe first type of impact is that the ERC20 token being traded is one that consistently returns a boolean result in the case of success and failure like for example 0x's ZRX Token contract. Where the return value is currently not verified to be true, the transfer may fail but the error would not be detected by the Buffer contracts.\n\nThe second type of impact is that the ERC20 token being traded is one that do not return a boolean value like for example the well knonw Tether USD Token contract. Successful transfers would cause a revert in the Buffer contracts where the return value is verified to be true due to the token not returing boolean results. Same is true for appove calls.\n\nTo handle the inconsistent behaviors across multiple tokens, either use OpenZeppelin's SafeERC20 library, or use a more reusable implementation (i.e. library) of the following intentionally explicit, descriptive example code for an ERC20 transferFrom() call that takes into account all the different ways of signalling success and failure, and apply to all ERC20 transfer(), transferFrom(), approve() calls in the Buffer contracts.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/73",
      "tags": [],
      "finders": [
        "Bnke0x0",
        "peanuts",
        "minhtrng",
        "eierina",
        "ctf\\_sec",
        "pashov",
        "eyexploit",
        "0xcc",
        "0x007",
        "adriro",
        "m\\_Rassska",
        "aphak5010",
        "0x4non",
        "Deivitto",
        "cccz",
        "hansfriese",
        "ak1",
        "rvierdiiev",
        "bin2chen",
        "\\_\\_141345\\_\\_",
        "sach1r0",
        "HonorLt",
        "jonatascm"
      ]
    },
    {
      "id": "3630",
      "title": "M-4: Insufficient support for fee-on-transfer tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/76 \n\n## Found by \neierina, dipp, KingNFT, rvierdiiev, cccz, supernova, Deivitto, \\_\\_141345\\_\\_, jonatascm, pashov\n\n## Summary\n\nThe ```BufferBinaryPool.sol``` and ```BufferRouter.sol``` do not support fee-on-transfer tokens. If ```tokenX``` is a fee-on-transfer token, tokens received from users could be less than the amount specified in the transfer.\n\n## Vulnerability Detail\n\nThe ```initiateTrade``` function in ```BufferRouter.sol``` receives tokens from the user with amount set to ```initiateTrade```'s ```totalFee``` input. If tokenX is a fee-on-transfer token then the actual amount received by ```BufferRouter.sol``` is less than ```totalFee```. When a trade is opened, the protocol will [send a settlementFee to ```settlementFeeDisbursalContract```](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L137-L141) and a [premium to ```BufferBinaryPool.sol```](), where the settlementFee is calculated using the incorrect, inflated totalFee amount. When the totalFee is greater than the fee required [the user is reimbursed the difference](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L333-L339). Since the settlementFee is greater than it should be the user receives less reimbursement.\n\nIn ```BufferBinaryPool.sol```'s ```lock``` function, the premium for the order is sent from the Options contract to the Pool. The totalPremium state variable would be updated incorrectly if fee-on-transfer tokens were used.\n\nThe ```_provide``` function in ```BufferBinaryPool.sol```receives tokenXAmount of tokenX tokens from the user and calculates the amount of shares to mint using the tokenXAmount. If fee-on-transfer tokens are used then the user would receive more shares than they should.\n\n## Impact\n\nThe protocol and users could suffer a loss of funds.\n\n## Code Snippet\n\n[BufferRouter.sol#L86-L90](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86-L90)\n\n[BufferBinaryPool.sol#L161](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L161)\n\n[BufferBinaryPool.sol#L236-L240](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L161)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking the balance of the contract before and after token transfers and using instead of the amount specified in the contract.\n\n## Discussion\n\n**0x00052**\n\nOnly an issue if project intends to support fee-on-transfer tokens as underlying\n\n**bufferfinance**\n\nNot supporting fee-on-transfer tokens for now.",
      "summary": "\nThis bug report is about the ```BufferBinaryPool.sol``` and ```BufferRouter.sol``` not supporting fee-on-transfer tokens. Fee-on-transfer tokens are tokens that take a fee from the amount sent by the user, meaning the contract receives less than the amount specified in the transfer. This could lead to the protocol and users suffering a loss of funds.\n\nThe issue was found by a team of 10 people, and the code snippets linked in the report were reviewed manually. The recommendation is to check the balance of the contract before and after token transfers. It is not intended to support fee-on-transfer tokens for now.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/76",
      "tags": [
        "Fee On Transfer",
        "ERC20"
      ],
      "finders": [
        "supernova",
        "pashov",
        "Deivitto",
        "cccz",
        "KingNFT",
        "dipp",
        "\\_\\_141345\\_\\_",
        "rvierdiiev",
        "jonatascm",
        "eierina"
      ]
    },
    {
      "id": "3629",
      "title": "M-3: The `_fee()` function is wrongly implemented in the code",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95 \n\n## Found by \nCh\\_301\n\n## Summary\n _fee() function is wrongly implemented in the code so the protocol will get fewer fees and the trader will earn more\n\n## Vulnerability Detail\n```solidity\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n```\nlet's say we have:\n`newFee` 100 USDC\nUSDC Decimals is 6\n`settlementFeePercentage` is 20% ==> 200\n\nThe `unitFee` will be 520_000\n\n`amount` = (100 * 1_000_000) / 520_000 \n`amount` = 192 USDC\nWhich is supposed to be  `amount` = 160 USDC\n\n## Impact\nThe protocol will earn fees less than expected\n\n## Code Snippet\n```solidity\n       function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L318-L353\n\n```solidity\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n```\nhttps://github.com/bufferfinance/Buffer-Protocol-v2/blob/83d85d9b18f1a4d09c728adaa0dde4c37406dfed/contracts/core/BufferBinaryOptions.sol#L424-L437\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `_fee()` function needs to calculate the fees in this way\n```solidity\ntotal_fee = (5000 * amount)/ (10000 - sf)\n```",
      "summary": "\nThis bug report is about an issue found in the code of the Buffer Protocol v2. The issue is with the `_fee()` function which is implemented incorrectly. This leads to the protocol earning fewer fees than expected and the trader earning more. The code snippet included in the report shows how the function is currently implemented. The impact of this bug is that the protocol will earn fewer fees than expected. The bug was found by manual review and the recommendation is to implement the `_fee()` function in this way: `total_fee = (5000 * amount)/ (10000 - sf)`.",
      "quality_score": 4,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/95",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "Ch\\_301"
      ]
    },
    {
      "id": "3628",
      "title": "M-2: When tokenX is an ERC777 token, users can bypass maxLiquidity",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/112 \n\n## Found by \ncccz\n\n## Summary\nWhen tokenX is an ERC777 token, users can use callbacks to provide liquidity exceeding maxLiquidity\n## Vulnerability Detail\nIn BufferBinaryPool._provide, when tokenX is an ERC777 token, the tokensToSend function of account will be called in tokenX.transferFrom before sending tokens. When the user calls provide again in tokensToSend, since BufferBinaryPool has not received tokens at this time, totalTokenXBalance() has not increased, and the following checks can be bypassed, so that users can provide liquidity exceeding maxLiquidity.\n```solidity\n         require(\n             balance + tokenXAmount <= maxLiquidity,\n             \"Pool has already reached it's max limit\"\n         );\n```\n## Impact\nusers can provide liquidity exceeding maxLiquidity.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L216-L240\n## Tool used\n\nManual Review\n\n## Recommendation\nChange to\n```diff\n    function _provide(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) internal returns (uint256 mint) {\n+        bool success = tokenX.transferFrom(\n+            account,\n+            address(this),\n+            tokenXAmount\n+        );\n        uint256 supply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        require(\n            balance + tokenXAmount <= maxLiquidity,\n            \"Pool has already reached it's max limit\"\n        );\n\n        if (supply > 0 && balance > 0)\n            mint = (tokenXAmount * supply) / (balance);\n        else mint = tokenXAmount * INITIAL_RATE;\n\n        require(mint >= minMint, \"Pool: Mint limit is too large\");\n        require(mint > 0, \"Pool: Amount is too small\");\n\n-        bool success = tokenX.transferFrom(\n-            account,\n-            address(this),\n-            tokenXAmount\n-        );\n```\n\n## Discussion\n\n**0x00052**\n\nNeither tokenX (USDC or BFR) are ERC777, so not applicable to current contracts. Something to consider if the team plans to add and ERC777",
      "summary": "\nThis bug report is about an issue found in the BufferBinaryPool._provide function when tokenX is an ERC777 token. It was found by cccz and the vulnerability detail is that when the user calls provide again in tokensToSend, since BufferBinaryPool has not received tokens at this time, totalTokenXBalance() has not increased, and the checks can be bypassed, so that users can provide liquidity exceeding maxLiquidity. The impact of this is that users can provide liquidity exceeding maxLiquidity. The tool used was Manual Review and the recommendation is to change the code snippet to the one provided. Lastly, it was discussed that neither tokenX (USDC or BFR) are ERC777, so not applicable to current contracts.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/112",
      "tags": [
        "Reentrancy",
        "ERC777",
        "CEI"
      ],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "3627",
      "title": "M-1: resolveQueuedTrades() ERC777 re-enter to steal funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/130 \n\n## Found by \nbin2chen, HonorLt, KingNFT\n\n## Summary\n_openQueuedTrade() does not follow the “Checks Effects Interactions” principle and may lead to re-entry to steal the funds\n\nhttps://fravoll.github.io/solidity-patterns/checks_effects_interactions.html\n\n## Vulnerability Detail\nThe prerequisite is that tokenX is ERC777 e.g. “sushi”\n1. resolveQueuedTrades() call _openQueuedTrade()\n2. in _openQueuedTrade() call \"tokenX.transfer(queuedTrade.user)\" if (revisedFee < queuedTrade.totalFee) before set queuedTrade.isQueued = false; \n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer( //***@audit call transfer , if ERC777 , can re-enter ***/\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        queuedTrade.isQueued = false;  //****@audit  change state****/\n    }\n```\n3.if ERC777 re-enter to #cancelQueuedTrade() to get tokenX back,it can close,  because queuedTrade.isQueued still equal true\n4. back to _openQueuedTrade()  set queuedTrade.isQueued = false\n5.so steal tokenX\n## Impact\nif tokenX equal ERC777 can steal token\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L350\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nfollow “Checks Effects Interactions” \n\n```solidity\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n...\n+      queuedTrade.isQueued = false; \n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n-       queuedTrade.isQueued = false; \n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n```",
      "summary": "\nThis bug report concerns a vulnerability in the _openQueuedTrade() function of the BufferRouter.sol smart contract. It was found by bin2chen, HonorLt, and KingNFT and is related to the “Checks Effects Interactions” principle. If a tokenX is an ERC777 token, a malicious user could re-enter the cancelQueuedTrade() function to get the token back, as the queuedTrade.isQueued variable would still be true. This could result in the malicious user stealing tokenX.\n\nThe code snippet provided in the report shows the original code and the recommended code changes. The original code calls tokenX.transfer() before setting queuedTrade.isQueued to false. In the recommended code, queuedTrade.isQueued is set to false before the tokenX transfer.\n\nThe impact of this vulnerability is that if tokenX is an ERC777 token, a malicious user could steal it. The tool used to detect this vulnerability was manual review. The recommendation is to follow the “Checks Effects Interactions” principle when writing code.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/130",
      "tags": [
        "Reentrancy",
        "ERC777",
        "CEI"
      ],
      "finders": [
        "KingNFT",
        "HonorLt",
        "bin2chen"
      ]
    },
    {
      "id": "3626",
      "title": "H-3: Early depositors to BufferBinaryPool can manipulate exchange rates to steal funds from later depositors",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/81 \n\n## Found by \ndipp, gandu, rvierdiiev, Ruhum, hansfriese, cccz, 0x52, ctf\\_sec, joestakey\n\n## Summary\n\nTo calculate the exchange rate for shares in BufferBinaryPool it divides the total supply of shares by the totalTokenXBalance of the vault. The first deposit can mint a very small number of shares then donate tokenX to the vault to grossly manipulate the share price. When later depositor deposit into the vault they will lose value due to precision loss and the adversary will profit.\n\n## Vulnerability Detail\n\n    function totalTokenXBalance()\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        return tokenX.balanceOf(address(this)) - lockedPremium;\n    }\n\nShare exchange rate is calculated using the total supply of shares and the totalTokenXBalance, which leaves it vulnerable to exchange rate manipulation. As an example, assume tokenX == USDC. An adversary can mint a single share, then donate 1e8 USDC. Minting the first share established a 1:1 ratio but then donating 1e8 changed the ratio to 1:1e8. Now any deposit lower than 1e8 (100 USDC) will suffer from precision loss and the attackers share will benefit from it.\n\n## Impact\n\nAdversary can effectively steal funds from later users through precision loss\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L405-L412\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRequire a small minimum deposit (i.e. 1e6) \n\n## Discussion\n\n**bufferfinance**\n\nWe'll add the initial liquidity and then burn those LP tokens.",
      "summary": "\nThis bug report is about an issue found in the BufferBinaryPool contract which allows early depositors to manipulate exchange rates to steal funds from later depositors. The exchange rate is calculated using the total supply of shares and the totalTokenXBalance, which leaves it vulnerable to manipulation. An adversary can mint a single share, then donate a large amount of tokenX to the vault to grossly manipulate the share price. When later depositors deposit into the vault they will lose value due to precision loss and the adversary will profit. The impact of this vulnerability is that the adversary can effectively steal funds from later users through precision loss. The bug was found manually and the recommendation is to require a small minimum deposit (e.g. 1e6). The issue has been discussed and a solution has been proposed.",
      "quality_score": 3.5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/81",
      "tags": [
        "ERC4626",
        "Initial Deposit"
      ],
      "finders": [
        "0x52",
        "cccz",
        "joestakey",
        "Ruhum",
        "hansfriese",
        "dipp",
        "gu",
        "rvierdiiev",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3625",
      "title": "H-2: Design of BufferBinaryPool allows LPs to game option expiry",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/82 \n\n## Found by \n\\_\\_141345\\_\\_, 0x52\n\n## Summary\n\nWhen an option is created, enough collateral is locked in BufferBinaryPool to cover a payout should it close ITM. As long as an LP isn't locked (trivially 10 minutes) and there is sufficient liquidity they can cash out their shares for underlying. The price and expiration of all options are public by design, meaning an LP can know with varying degrees of certainty if they will make or lose money from an option expiry. The result is that there will be a race to withdraw capital before any option expires ITM. LPs who make it out first won't lose any money, leaving all other LPs to hold the bags.\n\nOn the flip-side of this when there are large options expiring OTM, LPs will rush to stake their capital in the pool. This allows them to claim the payout while experiencing virtually zero risk, since they can immediately withdraw after 10 minutes.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nLPs can game option expiry at the expense of other LPs\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L124-L126\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI strongly recommend an epoch based withdraw and deposit buffer to prevent a situation like this. Alternatively increasing lockupPeriod would be a quicker, less precise fix.\n\n## Discussion\n\n**bufferfinance**\n\nYes we were planning to adjust the lockup accordingly.",
      "summary": "\nThis bug report is about an issue found in the design of BufferBinaryPool, which allows Liquidity Providers (LPs) to game option expiry. This means that LPs can use the knowledge of the price and expiration of options to withdraw capital before any option expires ITM (in-the-money), thus avoiding any losses. On the other hand, when there are large options expiring OTM (out-of-the-money), LPs can rush to stake their capital in the pool to claim the payout while experiencing virtually zero risk. This issue was found by two individuals, \\_\\_141345\\_\\_ and 0x52, using manual review.\n\nThe impact of this vulnerability is that LPs can game option expiry at the expense of other LPs. The recommendation to prevent a situation like this is to implement an epoch based withdraw and deposit buffer or to increase the lockup period. The discussion suggests that the team was planning to adjust the lockup accordingly.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/82",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "0x52",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "3624",
      "title": "H-1: When private keeper mode is off users can queue orders with the wrong asset",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/85 \n\n## Found by \nKingNFT, adriro, bin2chen, 0x52, kaliberpoziomka\n\n## Summary\n\nAfter an order is initiated, it must be filled by calling resolveQueuedTrades. This function validates that the asset price has been signed but never validates that the asset being passed in matches the asset of the queuedTrade. When private keeper mode is off, which is the default state of the contract, this can be abused to cause huge loss of funds.\n\n## Vulnerability Detail\n\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trad\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n\nBufferRouter#resolveQueueTrades never validates that the asset passed in for params is the same asset as the queuedTrade. It only validates that the price is the same, then passes the price and queueId to _openQueuedTrade:\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        ...\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\nInside _openQueuedTrade it checks that the price is within the slippage bounds of the order, cancelling if its not. Otherwise it uses the price to open an option. According to documentation, the same router will be used across a large number of assets/pools, which means the publisher for every asset is the same, given that router only has one publisher variable.\n\nExamples:\n\nImagine two assets are listed that have close prices, asset A = $0.95 and asset B = $1. An adversary could create an call that expires in 10 minutes on asset B with 5% slippage, then immediately queue it with the price of asset A. $0.95 is within the slippage bounds so it creates the option with a strike price of $0.95. Since the price of asset B is actually $1 the adversary will almost guaranteed make money, stealing funds from the LPs. This can be done back and forth between both pools until pools for both assets are drained.\n\nIn a similar scenario, if the price of the assets are very different, the adversary could use this to DOS another user by always calling queue with the wrong asset, causing the order to be cancelled.\n\n## Impact\n\nAdversary can rug LPs and DOS other users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L136-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPass the asset address through so the BufferBinaryOptions contract can validate it is being called with the correct asset",
      "summary": "\nThis bug report is about an issue in the BufferRouter contract, where when private keeper mode is off, users can queue orders with the wrong asset. This vulnerability was discovered by KingNFT, adriro, bin2chen, 0x52, and kaliberpoziomka. \n\nWhen an order is initiated, it must be filled by calling resolveQueuedTrades. This function validates that the asset price has been signed but never validates that the asset being passed in matches the asset of the queuedTrade. When private keeper mode is off, which is the default state of the contract, this can be abused to cause huge loss of funds.\n\nFor example, if two assets are listed that have close prices, asset A = $0.95 and asset B = $1, an adversary could create an call that expires in 10 minutes on asset B with 5% slippage, then immediately queue it with the price of asset A. $0.95 is within the slippage bounds so it creates the option with a strike price of $0.95. Since the price of asset B is actually $1, the adversary will almost guaranteed make money, stealing funds from the LPs. This can also be used to DOS another user by always calling queue with the wrong asset, causing the order to be cancelled.\n\nThe impact of this vulnerability is that an adversary can rug LPs and DOS other users. The code snippet for this bug can be found at https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L136-L185 and the tool used for this bug was manual review. The recommendation for this bug is to pass the asset address through so the BufferBinaryOptions contract can validate it is being called with the correct asset.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Buffer Finance",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-buffer-judging/issues/85",
      "tags": [
        "Validation"
      ],
      "finders": [
        "0x52",
        "bin2chen",
        "kaliberpoziomka",
        "KingNFT",
        "adriro"
      ]
    },
    {
      "id": "10511",
      "title": "Variable outside store",
      "impact": "LOW",
      "content": "In contrast to most of the code base, the [last policy identifier](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/Policy.sol#L32) is saved directly in the `Policy` contract. However, to maintain continuity and prevent conflicts, any new version will [need to import](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/Policy.sol#L35) the old value.\n\n\nConsider saving it in the `Store` contract.\n\n\n**Update:** *Fixed as of commit `1826fa97f1b325d40b0b3446b384dac35074540f` in [pull request #168](https://github.com/neptune-mutual-blue/protocol/pull/168).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10510",
      "title": "Incorrect individual liquidity share",
      "impact": "LOW",
      "content": "The [calculation](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L107) of an individual’s share of liquidity for a particular cover incorrectly uses `values[5]` instead of `values[4]` as the number of PODs. Since this is always zero, the returned share of liquidity will always be zero.\n\n\nThis has no implications within the current code base but would mislead external users that rely on it. Consider using the correct number of PODs in the calculation.\n\n\n**Update:** *Fixed as of commit `2192646ab5efa95a90521b986c81c05ed04fcd37` in [pull request #166](https://github.com/neptune-mutual-blue/protocol/pull/166).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10509",
      "title": "The info parameter might lose information about an IPFS hash",
      "impact": "LOW",
      "content": "The `info` parameter of the `report`, [`dispute`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/Reporter.sol#L190-L196), and other functions assume that the length of the IPFS hash is 32 bytes or shorter. However, that is not the case for [CIDv1](https://github.com/multiformats/cid#cidv1) where the hash can be longer than 32 bytes and also contain prefixes.\n\n\nThis leads to a data availability issue when NPM holders might be unable to retrieve the incident information from the smart contracts. Consequently, they are unable to decide whether to attest or refute the incident.\n\n\nConsider using a different data structure for storing an IPFS hash.\n\n\n**Update:** *Fixed as of commit `5ebb130fe274f0237e368ceaac25751936c1b321` in [pull request #165](https://github.com/neptune-mutual-blue/protocol/pull/165).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10508",
      "title": "Protocol administrator needs to handle external tokens",
      "impact": "LOW",
      "content": "The protocol administrator is one of the most critical roles with immense privilege in the operation of the entire protocol. For example, only the administrator can [re-initialize](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L78) the protocol, [grant key access control roles](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L283-L287), as well as set up all [staking](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L45) and [bonding](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Bond/BondPoolBase.sol#L54) pools.\n\n\nHowever, when [setting up a staking pool](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L36-L46), a [non-zero amount](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L120) of reward tokens are required to be pre-transferred to the administrator account and [pulled to the contract](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L170). This implies that the administrator needs to receive and approve the transaction a priori. This increases the attack surface and may not fit the intended security assumptions for a critical role.\n\n\nConsider either using a less critical role to perform staking pool initialization or allowing pool initialization without any token transfer.\n\n\n**Update:** *Fixed as of commit `71fd05996061b9c438c557c92cd888f4f4c9c542` in [pull request #173](https://github.com/neptune-mutual-blue/protocol/pull/173). The Liquidity Manager must now initialise and manage the staking pools. They must also set up the Bond pools.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10507",
      "title": "No unstaking window",
      "impact": "LOW",
      "content": "After an incident is resolved, successful stakers can retrieve their rewards [provided the incident has not been finalized](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L425). When the incident occurred, they will have [at least the claim period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Finalization.sol#L60). However, if the incident was successfully disputed, there is no claim period and the incident can be finalized immediately before stakers have been provided sufficient time to claim their rewards. Consider including an unstaking window for this scenario.\n\n\n**Update:** *Acknowledged, not fixed. The Neptune team stated:*\n\n\n\n> *For incidents resolved as `false reporting`, we intend to restore the cover status to operational as soon as possible. This flexibility allows us to accomplish a speedier finalization while still allowing the tokenholder community sufficient time to unstake their claim (with reward) on a case-by-case basis.*\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10506",
      "title": "Missing event parameter",
      "impact": "LOW",
      "content": "The [`PoolUpdated` event](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L48) does not include the `stakingTarget` parameter. Consider including it.\n\n\n**Update:** *Fixed as of commit `89d30f63d6c43dd3787cd291e31c03a2b712a0a2` in [pull request #163](https://github.com/neptune-mutual-blue/protocol/pull/163).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10505",
      "title": "Lack of input validation",
      "impact": "LOW",
      "content": "* The [`mustNotExceedNpmThreshold`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/delegates/VaultDelegateBase.sol#L246) function should validate [`npmStakeToAdd`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/delegates/VaultDelegateBase.sol#L237) instead of `amount`.\n* The [`setPolicyRatesByKey`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/PolicyAdmin.sol#L68) function in the `PolicyAdmin` contract does not check that `ceiling` is greater than `floor`, while a similar function [`setPolicyRates`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/policy/PolicyAdmin.sol#L43) does.\n* The [`initialize`](https://github.com/neptune-mutual-blue/protocol/blob/rc2/audit-start/contracts/core/Protocol.sol#L51-L113) function in the `Protocol` contract does not check the length of the input `values` array.\n* When [computing unstaking rewards](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/GovernanceUtilV1.sol#L430) after an incident resolution, the sum of the `toBurn` and `toReporter` rates are not validated to be bounded above by `ProtoUtilV1.MULTIPLIER`.\n\n\nConsider including the corresponding validations.\n\n\n**Update:** *Fixed as of commit `5ce4b8d3ff0b0a7eb4f0265b4201c93c43af4f30` in [pull request #172](https://github.com/neptune-mutual-blue/protocol/pull/172) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10504",
      "title": "Incorrect NPM threshold",
      "impact": "LOW",
      "content": "Some operations require an NPM stake that must not exceed [a threshold](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ProtoUtilV1.sol#L20), currently set to 10 billion. However, the total NPM supply [cannot exceed 1 billion](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/token/NPM.sol#L10), making the threshold non-functional. The Neptune team indicated the threshold should only be 10 million. Consider updating the constant accordingly.\n\n\n**Update:** *Fixed as of commit `78fafa7314793a3b6b5fe40e1c9129c8f8c4f813` in [pull request #164](https://github.com/neptune-mutual-blue/protocol/pull/164).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10503",
      "title": "Imprecise bounds",
      "impact": "LOW",
      "content": "There are several examples where the time windows or value ranges are defined inconsistently. In particular:\n\n\n* The `getWithdrawalInfoInternal` function of the `RoutineInvokerLibV1` library considers the `end` timestamp to be [part of the withdrawal period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/RoutineInvokerLibV1.sol#L70) but the `mustBeDuringWithdrawalPeriod` validation function [does not](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/RoutineInvokerLibV1.sol#L161).\n* The `StakingPoolLibV1` library [prevents withdrawals](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L293) on the block height where withdrawals can start.\n* Neither the [`mustBeBeforeResolutionDeadline` function](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L261) nor the [`mustBeAfterResolutionDeadline` function](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L282) will succeed on the resolution deadline.\n* The flash loan fee calculation requires the loan to be [strictly less](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L306) than the available balance, even though the contract [claims](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L347) to loan out the whole balance.\n\n\n**Update:** *Fixed as of commit `3412b68b9d729d0bc5c3b5860ace7a38a06b9835` in [pull request #167](https://github.com/neptune-mutual-blue/protocol/pull/167).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10502",
      "title": "Implicit timing assumptions",
      "impact": "LOW",
      "content": "To account for the coverage delay, some valid cxTokens [may be excluded](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L103) from making claims. Any coverage that will become active [within 14 days](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L108) but [before the incident resolution](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/cxToken/cxToken.sol#L111) will be disregarded. This implicitly assumes that no valid cover starts after either of these deadlines (otherwise it should also be excluded). Since the coverage delay and resolution window are configurable parameters, the assumptions may not hold. Consider calculating exclusions based on the specific parameters that are relevant to the incident being processed.\n\n\n**Update:** *Fixed as of commit `e00b4248768c196a2b5047dcc21d91a2503452ab` in [pull request #162](https://github.com/neptune-mutual-blue/protocol/pull/162) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10501",
      "title": "Collision between constants",
      "impact": "LOW",
      "content": "The [`NS_POOL_MAX_STAKE`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L27) and [`NS_POOL_REWARD_TOKEN`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L22) constants are defined to be the same string, which introduces the possibility of unexpected storage collisions. In the current code base they are used with non-overlapping data types, which are saved in different mappings. Nevertheless, in the interest of predictability, consider redefining the `NS_POOL_MAX_STAKE` constant to a unique string.\n\n\n**Update:** *Fixed as of commit `90f03dce0d24af3affc50d19ac81bbc12b524a4f` in [pull request #161](https://github.com/neptune-mutual-blue/protocol/pull/161).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10500",
      "title": "Able to close non-empty staking pool",
      "impact": "LOW",
      "content": "A staking pool can be [closed](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPoolBase.sol#L51-L59) without checking if there is any remaining liquidity of either the staking token or the reward token. Once the pool is closed, neither [`deposit`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPools.sol#L20-L23) nor [`withdraw`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/pool/Staking/StakingPools.sol#L39-L41) functions are allowed. Hence, users won’t be able to access their funds. However a recovery agent is still able to [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) both staking and reward tokens and distribute them as desired.\n\n\nConsider checking for remaining liquidity before closing a pool.\n\n\n**Update:** *Fixed as of commit `86b0caa0995ffcdbb1deecf8547c9a3db8c23821` in [pull request #160](https://github.com/neptune-mutual-blue/protocol/pull/160).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10499",
      "title": "Unexpected deployer privileges",
      "impact": "MEDIUM",
      "content": "The deployer address of the `Store` contract is [recorded as a protocol member](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/store/StoreBase.sol#L30), which allows it to update the storage arbitrarily. The same address [is set](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/Ownable.sol#L29) as the contract’s `owner` role, which allows it to [pause and unpause](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/store/StoreBase.sol#L65-L83) storage updates. We believe these are intended to be the same role, but they are not programmatically connected. In particular, if the owner address is [renounced or transferred](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/Ownable.sol#L47-L65), the deployer will still be able to update storage.\n\n\nMoreover, it is unclear why the `Store` owner or deployer requires the ability to modify storage arbitrarily.\n\n\nConsider documenting the role in the [Security overview](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/security.md) if the role is required. Otherwise, consider renouncing protocol member privileges from the deployer address after the deployment is finished.\n\n\n**Update:** *Fixed as of commit `0b278019c01dbce22923d0bb6968ddb48bcc3e2d` in [pull request #123](https://github.com/neptune-mutual-blue/protocol/pull/123). The deployer address is removed as a protocol member, assuming the deployer is the address that calls the `initialize` function.*",
      "summary": "\nThis bug report is about the `Store` contract in the Neptune Mutual Blue Protocol. The `Store` contract has two roles - deployer and owner - which are not programmatically connected. This means that if the owner address is changed, the deployer will still be able to update storage. Furthermore, it is unclear why the `Store` owner or deployer requires the ability to modify storage arbitrarily.\n\nThe bug was fixed in commit `0b278019c01dbce22923d0bb6968ddb48bcc3e2d` in pull request #123. The deployer address was removed as a protocol member, assuming the deployer is the address that calls the `initialize` function. To ensure the security of the protocol, the role should be documented in the Security overview if required. Otherwise, the deployer address should be renounced after the deployment is finished.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10498",
      "title": "Unable to unstake after finalization",
      "impact": "MEDIUM",
      "content": "Reporters on the winning camp can [unstake their tokens](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Unstakable.sol#L42-L46) even after the incident has been [finalized](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Resolvable.sol#L130-L131), albeit with no reward. However, the [resolution deadline](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Resolvable.sol#L142) is not specific to a particular incident and is [reset to 0](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/governance/resolution/Finalization.sol#L92) during finalization. Since the [deadline is checked](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ValidationLibV1.sol#L400) during unstaking, the operation will fail. This means that some successful NPM stakers will be unable to retrieve their funds.\n\n\nIn this scenario, a recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the `Resolution` contract and distribute them as desired.\n\n\nConsider recording the resolution deadline with the incident date so it does not need to be cleared during finalization.\n\n\n**Update:** *Fixed as of commit `6cb6b6064eca18cccee8114cbcefd2455c286ce9` in [pull request #132](https://github.com/neptune-mutual-blue/protocol/pull/132) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*",
      "summary": "\nThis bug report is about a system that allows users to stake tokens and win rewards. The issue is that when the incident has been finalized, the resolution deadline is reset to 0, which means that some successful stakers will be unable to retrieve their funds. A recovery agent could still retrieve the funds from the Resolution contract, but it would be better to record the resolution deadline with the incident date so it does not need to be cleared during finalization. This issue has since been fixed with commits 6cb6b6064eca18cccee8114cbcefd2455c286ce9 in pull request #132 and 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10497",
      "title": "Parallel access control",
      "impact": "MEDIUM",
      "content": "The `Protocol` contract inherits the OpenZeppelin `AccessControl` contract, and uses it to define [the role hierarchy](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/ProtoBase.sol#L18). It also provides a mechanism for the administrator to [grant an existing role](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Protocol.sol#L283) to a new address. However, this mechanism functions in parallel to the [inherited mechanism](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/AccessControl.sol#L130) for granting roles. This leads to two inconsistencies:\n\n\n* A role administrator can bypass the `whenNotPaused` restriction by using the inherited mechanism.\n* The `NS_ROLES_ADMIN` can use the new mechanism to grant the `NS_ROLES_GOVERNANCE_AGENT`, even though they [do not directly administer](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/ProtoBase.sol#L23) that role.\n\n\nConsider ensuring consistency between the two mechanisms. Depending on the desired outcome, this could involve relying on the original mechanism, changing the role relationships, or overriding the inherited `grantRole` function.\n\n\n**Update:** *Fixed as of commit `1d54d66493e3109c12d610f0231529cbd65b5ba9` in [pull request #157](https://github.com/neptune-mutual-blue/protocol/pull/157) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196).*",
      "summary": "\nThe Protocol contract is an inherited OpenZeppelin AccessControl contract, which defines the role hierarchy and provides a mechanism for the administrator to grant an existing role to a new address. However, this mechanism functions in parallel to the inherited mechanism for granting roles, leading to two inconsistencies. Firstly, a role administrator can bypass the whenNotPaused restriction by using the inherited mechanism. Secondly, the NS_ROLES_ADMIN can use the new mechanism to grant the NS_ROLES_GOVERNANCE_AGENT, even though they do not directly administer that role. \n\nTo fix this, the developers considered ensuring consistency between the two mechanisms. Depending on the desired outcome, this could involve relying on the original mechanism, changing the role relationships, or overriding the inherited grantRole function. After the necessary changes were made, the bug was fixed as of two commits in pull requests #157 and #196.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10496",
      "title": "Incorrect policy fee",
      "impact": "MEDIUM",
      "content": "There are two discrepancies when calculating a policy fee rate:\n\n\n* It is always [strictly higher](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L55-L57) than the configured floor.\n* The [amount of days charged](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L64) does not account for a non-standard [coverage lag period](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L259).\n\n\nConsider updating the calculation accordingly.\n\n\n**Update:** *Fixed as of commit `84a6fc3167adfb61b6f16666f0ba422b60bc0b2c` in [pull request #159](https://github.com/neptune-mutual-blue/protocol/pull/159) and commit `4b929c274100a981107e35d40fbf5b57fabc9be4` in [pull request #196](https://github.com/neptune-mutual-blue/protocol/pull/196). The Neptune team have chosen not to address the first bullet.*",
      "summary": "\nA bug report has been filed regarding discrepancies when calculating a policy fee rate. Specifically, the calculated rate is always higher than the configured floor, and the amount of days charged does not account for a non-standard coverage lag period. The Neptune team have chosen to address the second issue, and have fixed it in two commits, `84a6fc3167adfb61b6f16666f0ba422b60bc0b2c` in pull request #159 and `4b929c274100a981107e35d40fbf5b57fabc9be4` in pull request #196. The first issue has not been addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10495",
      "title": "Potential token transfer from unrelated account",
      "impact": "MEDIUM",
      "content": "The `CoverReassurance` contract [contains a mechanism](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/lifecycle/CoverReassurance.sol#L66) to retrieve funds from an arbitrary account, as long as the account has provided a non-zero allowance. This would occur whenever a cover owner can front-run another cover owner’s reassurance transaction, allowing them to redirect the funds to their own cover.\n\n\nEven without front-running, there are multiple reasons an account may have a non-zero allowance, including:\n\n\n* Their `addReassurance` transaction failed and they didn’t revoke the allowance.\n* They made an unlimited approval.\n* They approved a higher allowance than the amount they eventually transferred.\n\n\nIn all cases, an attacker can retrieve those funds and direct them towards a cover.\n\n\nA recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the `CoverReassurance` contract and distribute them as desired, although it is unclear how they would distinguish a front-running attack from one where a cover owner legitimately transfers funds from a different account.\n\n\nConsider retrieving the tokens from the message sender rather than an arbitrary [`account` parameter](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/lifecycle/CoverReassurance.sol#L53).\n\n\n**Update:** *Fixed as of commit `ca55b69c5cdd80bcccdc83dd5d569933f450fa6a` in [pull request #139](https://github.com/neptune-mutual-blue/protocol/pull/139).*",
      "summary": "\nThis bug report is about a vulnerability in the `CoverReassurance` contract that allows attackers to retrieve funds from an arbitrary account. This can occur if the account has a non-zero allowance, such as if their `addReassurance` transaction failed, they made an unlimited approval, or they approved a higher allowance than what they eventually transferred. The recovery agent could still retrieve the funds, but it is unclear how they could distinguish a front-running attack from a legitimate transfer.\n\nA solution was proposed to retrieve the tokens from the message sender rather than an arbitrary `account` parameter. This was fixed as of commit `ca55b69c5cdd80bcccdc83dd5d569933f450fa6a` in pull request #139.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10494",
      "title": "Unenforced staking requirement",
      "impact": "MEDIUM",
      "content": "Adding liquidity requires a liquidity provider to have at least [a minimum amount of NPM tokens](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L151) staked in the vault.\n\n\nHowever, the purpose and usefulness of this requirement is unclear, since it can be bypassed. In particular:\n\n\n* there is no relationship between the amount of PODs created and the size of the stake\n* PODs are transferable to unstaked users, so users can provide liquidity without staking\n* staked users can [exit their entire staked `amount`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/liquidity/VaultLiquidity.sol#L113-L118) without redeeming any PODs by calling `removeLiquidity` with parameters `podsToRedeem = 0`, `npmStakeToRemove = amount`, and `exit = 1`; the `exit = 1` is crucial as it allows execution of [line 234](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/VaultLibV1.sol#L234) of `VaultLibV1.sol`\n\n\nConsider documenting and enforcing the intended relationship between NPM staking and liquidity provision.\n\n\n**Update:** *Acknowledged, not fixed. The Neptune team stated:*\n\n\n\n> *Although we plan to redo the staking requirement logic from scratch, we wish to consider this risk as acceptable for the time being.*\n> \n>",
      "summary": "\nThis bug report is about the relationship between NPM staking and liquidity provision in the Neptune Mutual protocol. It states that a liquidity provider is required to have a minimum amount of NPM tokens staked in the vault. However, it can be bypassed, as there is no relationship between the amount of PODs created and the size of the stake. Furthermore, PODs are transferable to unstaked users, which allows users to provide liquidity without staking. Lastly, staked users can exit their entire staked amount without redeeming any PODs. The Neptune team has acknowledged the risk but they plan to redo the staking requirement logic from scratch in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10493",
      "title": "Risk of insufficient liquidity",
      "impact": "HIGH",
      "content": "When purchasing a cover, the protocol [ensures it has enough funds](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/PolicyHelperV1.sol#L50) to pay out all potential claimants. The computation of the [existing commitments](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/CoverUtilV1.sol#L477-L481) includes all covers expiring in the next 3 months, since this is the [maximum policy duration](https://github.com/neptune-mutual-blue/protocol/blob/133bc8a4157d4f27471b0cf43ac0ce2b51bb5e5a/contracts/libraries/ProtoUtilV1.sol#L14). However, some covers may expire [in the fourth month](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/CoverUtilV1.sol#L609) and these would be excluded from the calculation. Therefore, the protocol could sell more insurance than it can support, and some valid claimants may be unable to retrieve their payment.\n\n\nConsider including the extra month in the commitment computation.\n\n\n**Update:** *Fixed as of commit `63fce22c67f72cf090ffa124784a3d92935e2d66` in [pull request #136](https://github.com/neptune-mutual-blue/protocol/pull/136).*",
      "summary": "\nA bug was identified in the Neptune Mutual Protocol, which is responsible for ensuring that enough funds are available when a cover is purchased. The protocol was counting the existing commitments, but only included covers expiring in the next three months, as this is the maximum policy duration. However, some covers may expire in the fourth month and these would be excluded from the calculation. This could lead to the protocol selling more insurance than it can support, and some valid claimants may be unable to retrieve their payment.\n\nTo address this, it was suggested to include the extra month in the commitment computation. This bug has now been fixed and the fix can be found in commit `63fce22c67f72cf090ffa124784a3d92935e2d66` in pull request #136.",
      "quality_score": 2,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10492",
      "title": "Conflated staking pool reward balances",
      "impact": "HIGH",
      "content": "Each staking pool specifies its own reward token and [corresponding balance](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L210-L214) in the same aggregate contract. When retrieving this value, the [token balance of the aggregate contract](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L158) is returned. Since there could be multiple staking pools with the same reward token, this could include balances from other pools. It could also include any reward token balances that were directly sent to the contract.\n\n\nMoreover, current user rewards [could also be overstated](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L178), which would [prevent users from claiming the last rewards](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L212). Since [rewards are claimed](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolLibV1.sol#L298) when withdrawing stake, anyone could prevent users from unstaking by directly sending reward tokens to the staking pool contract. Any non-zero amount would be sufficient to trigger this scenario. If this occurs, a recovery agent could still [retrieve](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/Recoverable.sol#L49) the funds from the aggregate pool contract and distribute them as desired, although it is not clear how they should distribute the remaining rewards.\n\n\nConsider reading the pool balance from the saved record.\n\n\n**Update:** *Fixed as of commit `8b660b13cf9fbcde0bfedb3819dbb670ba74b09a` in [pull request #156](https://github.com/neptune-mutual-blue/protocol/pull/156).*",
      "summary": "\nA bug was discovered in the Neptune Mutual protocol that affects the way staking pools handle rewards. Each staking pool specifies its own reward token and corresponding balance in the same aggregate contract. However, when retrieving this value, the token balance of the aggregate contract is returned, which could include balances from other pools or any reward token balances that were directly sent to the contract. This could lead to user rewards being overstated, preventing them from claiming the last rewards. In addition, if a malicious actor sent a non-zero amount of reward tokens to the staking pool contract, it would further prevent users from unstaking. In order to fix this issue, the pool balance was read from the saved record in commit 8b660b13cf9fbcde0bfedb3819dbb670ba74b09a in pull request #156.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Neptune Mutual Audit",
      "source_link": "https://blog.openzeppelin.com/neptune-mutual-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "23749",
      "title": "[N-22]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions\n\n*There are 14 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n291:              require(msg.sender == o.reservedAddress);\n\n299:              require(amount == 1, 'only 1 erc721 at 1 time');\n\n349:          require(status == 3);\n\n350:          require(amountRemaining >= amount);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L291\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n158:              require(epochs[index] < epoch);\n\n220:          require(address(ve) != address(0), ' VE not added yet');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L158\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n1008:         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n874:          require(msg.sender == voter);\n\n944:          require(_value > 0); // dev: need non-zero value\n\n982:          require(_locked.amount > 0, 'No existing lock found');\n\n983:          require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n999:          require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n211:          require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n186:          require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23748",
      "title": "[N-21]  Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n79:       event NonceIncremented(address indexed maker, uint256 newNonce);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L79\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n70:       event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L70\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n67:       event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n284       event Deposit(\n285           address indexed provider,\n286           uint256 tokenId,\n287           uint256 value,\n288           uint256 indexed locktime,\n289           DepositType deposit_type,\n290           uint256 ts\n291:      );\n\n292:      event Withdraw(address indexed provider, uint256 tokenId, uint256 value, uint256 ts);\n\n293:      event Supply(uint256 prevSupply, uint256 supply);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L67\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n29:       event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23747",
      "title": "[N-20]  File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n0:    /// [MIT License]\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L0\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23746",
      "title": "[N-19]  Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n2:    pragma solidity ^0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23745",
      "title": "[N-18]  Variable names that consist of all capital letters should be reserved for `constant`/`immutable` variables",
      "impact": "LOW",
      "content": "If the variable needs to be different based on which class it comes from, a `view`/`pure` _function_ should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n45:       ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L45\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n50:       uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23744",
      "title": "[N-17]  Inconsistent method of specifying a floating pragma",
      "impact": "LOW",
      "content": "Some files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n2:    pragma solidity ^0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23743",
      "title": "[N-16]  Lines are too long",
      "impact": "LOW",
      "content": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n132:                          'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n\n329:      ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L132\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n126:                      epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L126\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n72:           output = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"468\" viewBox=\"0 0 512 468\" fill=\"none\"><g clip-path=\"url(#clip0_2_190)\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"#232323\"/><g filter=\"url(#filter0_f_2_190)\"><ellipse cx=\"256.5\" cy=\"-132\" rx=\"164\" ry=\"381.5\" transform=\"rotate(-90 256.5 -132)\" fill=\"#FF8982\"/></g>';\n\n78:                   '</text><text y=\"318px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Locked Till</text>'\n\n86:                   '</text><text y=\"248px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Voting Power</text>'\n\n94:                   '</text><text y=\"391px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Value</text>'\n\n102:                  '</text><mask id=\"mask0_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"#C4C4C4\"/></mask><g mask=\"url(#mask0_2_190)\"><path d=\"M458.138 73.4955H396.962V133.076H458.138V73.4955Z\" fill=\"#FD7A7A\"/><path d=\"M396.962 76.7614H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 80.266H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 83.7708H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 87.2754H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 90.7802H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 94.2848H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 97.7897H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 101.294H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 104.799H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 108.304H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 111.808H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 115.313H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 118.818H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 122.323H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 125.827H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 129.332H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/></g><mask id=\"mask1_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask1_2_190)\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" stroke=\"black\" stroke-width=\"0.876179\"/><path d=\"M422.132 130.606H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/><path d=\"M422.132 73.5752H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/></g><mask id=\"mask2_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"393\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask2_2_190)\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\" stroke=\"black\" stroke-width=\"0.876179\"/></g></g><defs><filter id=\"filter0_f_2_190\" x=\"-381\" y=\"-552\" width=\"1275\" height=\"840\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"/><feGaussianBlur stdDeviation=\"128\" result=\"effect1_foregroundBlur_2_190\"/></filter><clipPath id=\"clip0_2_190\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"white\"/></clipPath></defs></svg>'\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L72\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23742",
      "title": "[N-15]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
      "impact": "LOW",
      "content": "While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n48:       uint256 constant dailyEmission = 600000 * 10**18;\n\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L48\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23741",
      "title": "[N-14]  Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L3\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23740",
      "title": "[N-13]  Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L100\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n308:      mapping(uint256 => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L308\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23739",
      "title": "[N-12]  Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit 600000\n48:       uint256 constant dailyEmission = 600000 * 10**18;\n\n/// @audit 60\n/// @audit 60\n57:       uint256 constant secsInDay = 24 * 60 * 60;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L48\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit 86400\n296:      uint256 internal constant MAXTIME = 4 * 365 * 86400;\n\n/// @audit 86400\n297:      int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L296\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23738",
      "title": "[N-11]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals\n\n*There are 49 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit 50\n/// @audit 10000\n212:              o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n\n/// @audit 3\n226:          require(status == 3, 'order not valid');\n\n/// @audit 50\n/// @audit 10000\n242:          payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n/// @audit 50\n254:                      (o.totalAmt * 50) /\n\n/// @audit 10000\n255:                      10000 -\n\n/// @audit 50\n/// @audit 10000\n263:                  (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n\n/// @audit 50\n/// @audit 10000\n269:          distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n\n/// @audit 3\n295:          require(status == 3);\n\n/// @audit 3\n349:          require(status == 3);\n\n/// @audit 50\n/// @audit 10000\n381:          uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n\n/// @audit 0x00\n436:              mstore(0x00, a)\n\n/// @audit 0x20\n437:              mstore(0x20, b)\n\n/// @audit 0x00\n/// @audit 0x40\n438:              value := keccak256(0x00, 0x40)\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L212\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n/// @audit 150_000_000\n/// @audit 1e18\n44:           _mint(_airdrop, 150_000_000 * 1e18);\n\n/// @audit 62_500_000\n/// @audit 1e18\n52:           _mint(_rewardDistributor, 62_500_000 * 1e18);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L44\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit 1659211200\n84:           startTime = 1659211200;\n\n/// @audit 1000000000\n/// @audit 18\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n/// @audit 67\n/// @audit 100\n120:              rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n\n/// @audit 33\n/// @audit 100\n121:              rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L84\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n/// @audit 4\n/// @audit 3\n17:           uint256 encodedLen = 4 * ((len + 2) / 3);\n\n/// @audit 32\n20:           bytes memory result = new bytes(encodedLen + 32);\n\n/// @audit 0xffffff\n34:                   let input := and(mload(add(data, i)), 0xffffff)\n\n/// @audit 0x3F\n36:                   let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n\n/// @audit 0x3F\n/// @audit 0xFF\n38:                   out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n\n/// @audit 0x3F\n/// @audit 0xFF\n40:                   out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n\n/// @audit 0x3F\n/// @audit 0xFF\n42:                   out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n\n/// @audit 0x3d3d\n52:                   mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n\n/// @audit 0x3d\n55:                   mstore(sub(resultPtr, 1), shl(248, 0x3d))\n\n/// @audit 48\n144:              buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L17\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit 255\n745:              for (uint256 i = 0; i < 255; ++i) {\n\n/// @audit 128\n1044:         for (uint256 i = 0; i < 128; ++i) {\n\n/// @audit 128\n1115:         for (uint256 i = 0; i < 128; ++i) {\n\n/// @audit 255\n1167:         for (uint256 i = 0; i < 255; ++i) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L745\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n/// @audit 500\n99:           require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23737",
      "title": "[N-10]  Non-assembly method available",
      "impact": "LOW",
      "content": "`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`<br>\nThere are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n98:               chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L98\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n577:              size := extcodesize(account)\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L577\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23736",
      "title": "[N-09]  `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 13 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n203       function fillAsk(\n204           Order calldata o,\n205           uint256 amount,\n206           address referrer,\n207           Payment calldata p,\n208           address receiver\n209:      ) public payable nonReentrant {\n\n279       function fillBid(\n280           Order calldata o,\n281           uint256 amount,\n282           address referrer,\n283           Payment calldata p\n284:      ) public nonReentrant {\n\n312:      function cancelOrder(Order calldata o) public nonReentrant {\n\n334       function fillCriteriaBid(\n335           Order calldata o,\n336           uint256 amount,\n337           uint256 tokenId,\n338           bytes32[] calldata proof,\n339           address referrer,\n340           Payment calldata p\n341:      ) public nonReentrant {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L203-L209\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n98:       function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141:      function traderClaim(address addr, uint256[] memory epochs) public {\n\n155:      function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172:      function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n\n215       function stakerRewards(uint256 tokenid) public view returns (\n216               uint256,\n217               uint256,\n218:              uint256[] memory\n\n254       function traderRewards(address addr) public view returns (\n255:              uint256        \n\n269       function exchangeRewards(address addr) public view returns (\n270:              uint256\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n66        function _tokenURI(\n67            uint256 _tokenId,\n68            uint256 _balanceOf,\n69            uint256 _locked_end,\n70            uint256 _value\n71:       ) public pure returns (string memory output) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L66-L71\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n185:      function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L185\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23735",
      "title": "[N-08]  `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There are 31 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n220:              require(msg.sender == o.reservedAddress);\n\n285           require(\n286               o.totalAmt * amount >\n287                   (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n288:          ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n\n291:              require(msg.sender == o.reservedAddress);\n\n293:          require(o.orderType == 1);\n\n295:          require(status == 3);\n\n296:          require(amountRemaining >= amount);\n\n313:          require(o.signer == msg.sender);\n\n342:          require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n\n345:              require(msg.sender == o.reservedAddress);\n\n347:          require(o.orderType == 2);\n\n349:          require(status == 3);\n\n350:          require(amountRemaining >= amount);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L220\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n88:           require(msg.sender == trader);\n\n144:              require(epochs[index] < epoch);\n\n158:              require(epochs[index] < epoch);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L88\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n360:          require(_entered_state == _not_entered);\n\n540:          require(_isApprovedOrOwner(_sender, _tokenId));\n\n646:          require(owner != address(0));\n\n648:          require(_approved != owner);\n\n652:          require(senderIsOwner || senderIsApprovedForAll);\n\n869:          require(msg.sender == voter);\n\n874:          require(msg.sender == voter);\n\n879:          require(msg.sender == voter);\n\n884:          require(msg.sender == voter);\n\n889:          require(msg.sender == voter);\n\n895:          require(_from != _to);\n\n896:          require(_isApprovedOrOwner(msg.sender, _from));\n\n897:          require(_isApprovedOrOwner(msg.sender, _to));\n\n927:          require(_value > 0); // dev: need non-zero value\n\n944:          require(_value > 0); // dev: need non-zero value\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L360\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n245:          require(_isApprovedOrOwner(_sender, _tokenId));\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L245\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23734",
      "title": "[N-07]  Contract implements interface without extending the interface",
      "impact": "LOW",
      "content": "Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit IERC721Enumerable.tokenOfOwnerByIndex()\n275:  contract VoteEscrowCore is IERC721, IERC721Metadata {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L275\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23733",
      "title": "[N-06]  Remove `include` for hardhat's console",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n9:    import 'hardhat/console.sol';\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L9\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23732",
      "title": "[N-05]  Invalid/extraneous/optional function definitions in interface",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit withdraw(uint256) isn't defined with those arguments in the standard ERC20 definition\n33:       function withdraw(uint256 wad) external;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L33\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit mint(address,uint256) isn't defined with those arguments in the standard ERC20 definition\n24:       function mint(address account, uint256 amount) external;\n\n/// @audit balanceOfNFTAt(uint256,uint256) isn't defined with those arguments in the standard ERC20 definition\n26:       function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n/// @audit deposit() isn't defined with those arguments in the standard ERC20 definition\n28:       function deposit() external payable;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23731",
      "title": "[N-04]  Remove commented out code",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowDelegation.sol\n\n218      // /// @notice Remove delegation by user\n219      // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n220      //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n221      //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n222      //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n223      //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n224      //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n225:     // }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L218-L225\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23730",
      "title": "[N-03]  Boilerplate not replaced",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: /contracts/governance/GolomToken.sol\n\n5:   /// @notice Explain to an end user what this does\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L5\n\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowDelegation.sol\n\n68:      /// @notice Explain to an end user what this does\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23729",
      "title": "[N-02]  `ecrecover()` signature validity not checked",
      "impact": "LOW",
      "content": "`ecrecover()` returns the zero address if the signature is invalid. If the signer provided is also zero, then all incorrect signatures will be allowed\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n176          address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n177          require(signaturesigner == o.signer, 'invalid signature');\n178          if (signaturesigner != o.signer) {\n179              return (0, hashStruct, 0);\n180:         }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L180\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23728",
      "title": "[N-01]  Consider addings checks for signature malleability",
      "impact": "LOW",
      "content": "Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n176          address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n177          require(signaturesigner == o.signer, 'invalid signature');\n178          if (signaturesigner != o.signer) {\n179              return (0, hashStruct, 0);\n180:         }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L180\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23727",
      "title": "[L-13]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 19 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit Missing: '@return'\n162       ///      OrderStatus = 3 , valid order\n163       /// @param o the Order struct to be validated\n164       function validateOrder(Order calldata o)\n165           public\n166           view\n167           returns (\n168               uint256,\n169               bytes32,\n170:              uint256\n\n/// @audit Missing: '@param tokenId'\n/// @audit Missing: '@param proof'\n328       /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n329       ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n330       /// @param o the Order struct to be filled must be orderType 2\n331       /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n332       /// @param referrer referrer of the order\n333       /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n334       function fillCriteriaBid(\n335           Order calldata o,\n336           uint256 amount,\n337           uint256 tokenId,\n338           bytes32[] calldata proof,\n339           address referrer,\n340           Payment calldata p\n341:      ) public nonReentrant {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L162-L170\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit Missing: '@return'\n213       /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n214       /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n215       function stakerRewards(uint256 tokenid) public view returns (\n216               uint256,\n217               uint256,\n218:              uint256[] memory\n\n/// @audit Missing: '@return'\n252       /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n253       /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n254       function traderRewards(address addr) public view returns (\n255:              uint256        \n\n/// @audit Missing: '@return'\n267       /// @dev returns unclaimed golom rewards of a trader\n268       /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n269       function exchangeRewards(address addr) public view returns (\n270:              uint256\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L213-L218\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit Missing: '@return'\n366       /// @dev Interface identification is specified in ERC-165.\n367       /// @param _interfaceID Id of the interface\n368:      function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n\n/// @audit Missing: '@return'\n396       ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n397       /// @param _owner Address for whom to query the balance.\n398:      function _balance(address _owner) internal view returns (uint256) {\n\n/// @audit Missing: '@return'\n403       ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n404       /// @param _owner Address for whom to query the balance.\n405:      function balanceOf(address _owner) external view returns (uint256) {\n\n/// @audit Missing: '@return'\n409       /// @dev Returns the address of the owner of the NFT.\n410       /// @param _tokenId The identifier for an NFT.\n411:      function ownerOf(uint256 _tokenId) public view returns (address) {\n\n/// @audit Missing: '@return'\n415       /// @dev Get the approved address for a single NFT.\n416       /// @param _tokenId ID of the NFT to query the approval of.\n417:      function getApproved(uint256 _tokenId) external view returns (address) {\n\n/// @audit Missing: '@return'\n422       /// @param _owner The address that owns the NFTs.\n423       /// @param _operator The address that acts on behalf of the owner.\n424:      function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n\n/// @audit Missing: '@return'\n935       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n936       /// @param _to Address to deposit\n937       function _create_lock(\n938           uint256 _value,\n939           uint256 _lock_duration,\n940           address _to\n941:      ) internal returns (uint256) {\n\n/// @audit Missing: '@return'\n957       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n958       /// @param _to Address to deposit\n959       function create_lock_for(\n960           uint256 _value,\n961           uint256 _lock_duration,\n962           address _to\n963:      ) external nonreentrant returns (uint256) {\n\n/// @audit Missing: '@return'\n968       /// @param _value Amount to deposit\n969       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n970:      function create_lock(uint256 _value, uint256 _lock_duration) external nonreentrant returns (uint256) {\n\n/// @audit Missing: '@param _tokenId'\n974       /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n975       /// @param _value Amount of tokens to deposit and add to the lock\n976:      function increase_amount(uint256 _tokenId, uint256 _value) external nonreentrant {\n\n/// @audit Missing: '@param _tokenId'\n988       /// @notice Extend the unlock time for `_tokenId`\n989       /// @param _lock_duration New number of seconds until tokens unlock\n990:      function increase_unlock_time(uint256 _tokenId, uint256 _lock_duration) external nonreentrant {\n\n/// @audit Missing: '@return'\n1079      /// @dev Returns current token URI metadata\n1080      /// @param _tokenId Token ID to fetch URI for.\n1081:     function tokenURI(uint256 _tokenId) external view returns (string memory) {\n\n/// @audit Missing: '@param t'\n1189      /// @notice Calculate total voting power\n1190      /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n1191      /// @return Total voting power\n1192:     function totalSupplyAtT(uint256 t) public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L366-L368\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23726",
      "title": "[L-12]  Typos",
      "impact": "LOW",
      "content": "\n*There are 24 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit succesful\n53:           Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n\n/// @audit facilating\n54:           Payment prePayment; // another payment , can be used for royalty, facilating trades\n\n/// @audit usefull\n60:           uint256 nonce; // nonce of order usefull for cancelling in bulk\n\n/// @audit succesful\n201:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesful\n278:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesful\n333:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesfully\n370:      /// @dev function to settle balances when a bid is filled succesfully\n\n/// @audit succesful\n374:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L53\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit epoc\n61:       mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n\n/// @audit epoc\n/// @audit exhange\n62:       mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n\n/// @audit epoc\n63:       mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n\n/// @audit epoc\n64:       mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n\n/// @audit upto\n66:       mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n\n/// @audit upto\n67:       mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n\n/// @audit facilated\n95:       /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n\n/// @audit atleast\n107:              // this assumes atleast 1 trade is done daily??????\n\n/// @audit begiining\n/// @audit begining\n111:              // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n\n/// @audit facilated\n154:      // allows exchange that facilated the nft trades to claim there previous epoch rewards\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L61\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit blocktimes\n267:   * and per block could be fairly bad b/c Ethereum changes blocktimes.\n\n/// @audit Exeute\n526:      /// @dev Exeute transfer of a NFT.\n\n/// @audit Pevious\n688:      /// @param old_locked Pevious locked amount / end lock time for the user\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L267\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n/// @audit Exeute\n227:      /// @dev Exeute transfer of a NFT.\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L227\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23725",
      "title": "[L-11]  Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n181:          //deadline\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L181\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n99:           //console.log(block.timestamp,epoch,fee);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L99\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23724",
      "title": "[L-10]  Missing event and or timelock for critical parameter change",
      "impact": "LOW",
      "content": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n444       function setDistributor(address _distributor) external onlyOwner {\n445           if (address(distributor) == address(0)) {\n446               distributor = Distributor(_distributor);\n447           } else {\n448               pendingDistributor = _distributor;\n449               distributorEnableDate = block.timestamp + 1 days;\n450           }\n451:      }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L444-L451\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n58        function setMinter(address _minter) external onlyOwner {\n59            pendingMinter = _minter;\n60            minterEnableDate = block.timestamp + 1 days;\n61:       }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L58-L61\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n868       function setVoter(address _voter) external {\n869           require(msg.sender == voter);\n870           voter = _voter;\n871:      }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L868-L871\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23723",
      "title": "[L-09]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n448:              pendingDistributor = _distributor;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L448\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n59:           pendingMinter = _minter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L59\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n81:           trader = _trader;\n\n287:          pendingTrader = _trader;\n\n303:              pendingVoteEscrow = _voteEscrow;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L81\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n870:          voter = _voter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L870\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n53:           token = _token;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L53\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23722",
      "title": "[L-08]  Wrong comment",
      "impact": "LOW",
      "content": "The function description and return values are incorrectly copied from another function\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/rewards/RewardDistributor.sol\n\n252      /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n253      /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n254      function traderRewards(address addr) public view returns (\n255              uint256        \n256:             ){\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L252-L256\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23721",
      "title": "[L-07]  Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator`",
      "impact": "LOW",
      "content": "See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n101          EIP712_DOMAIN_TYPEHASH = keccak256(\n102              abi.encode(\n103                  keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n104                  keccak256(bytes('GOLOM.IO')),\n105                  keccak256(bytes('1')),\n106                  chainId,\n107                  address(this)\n108              )\n109:         );\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L101-L109\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23720",
      "title": "[L-06]  Function may run out of gas",
      "impact": "LOW",
      "content": "Once the number of epochs grow to a large number, the array allocated will be large, and the number of iterations calling external functions on `ve` will also be large, leading to the function running out of gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/rewards/RewardDistributor.sol\n\n215      function stakerRewards(uint256 tokenid) public view returns (\n216              uint256,\n217              uint256,\n218              uint256[] memory\n219          ){\n220          require(address(ve) != address(0), ' VE not added yet');\n221  \n222          uint256 reward = 0;\n223          uint256 rewardEth = 0;\n224          uint256[] memory unclaimedepochs = new uint256[](epoch);\n225          // for each epoch\n226:         for (uint256 index = 0; index < epoch; index++) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L215-L224\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23719",
      "title": "[L-05]  Self-delegation is not automatic",
      "impact": "LOW",
      "content": "Unlike some of the other functions, `_mint()` isn't overridden to call `delegate()`, which means the user may forget to do so and will miss out\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowCore.sol\n\n677      function _mint(address _to, uint256 _tokenId) internal returns (bool) {\n678          // Throws if `_to` is zero address\n679          assert(_to != address(0));\n680          // Add NFT. Throws if `_tokenId` is owned by someone\n681          _addTokenTo(_to, _tokenId);\n682          emit Transfer(address(0), _to, _tokenId);\n683          return true;\n684:     }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L677-L684\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23718",
      "title": "[L-04]  `require()` should be used instead of `assert()`",
      "impact": "LOW",
      "content": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".\n\n*There are 13 instances of this issue:*\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n493:          assert(idToOwner[_tokenId] == address(0));\n\n506:          assert(idToOwner[_tokenId] == _from);\n\n519:          assert(idToOwner[_tokenId] == _owner);\n\n666:          assert(_operator != msg.sender);\n\n679:          assert(_to != address(0));\n\n861:              assert(IERC20(token).transferFrom(from, address(this), _value));\n\n977:          assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n981:          assert(_value > 0); // dev: need non-zero value\n\n991:          assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n1007:         assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n1023:         assert(IERC20(token).transfer(msg.sender, value));\n\n1110:         assert(_block <= block.number);\n\n1206:         assert(_block <= block.number);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L493\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23717",
      "title": "[L-03]  Unused/empty `receive()`/`fallback()` function",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n459:      fallback() external payable {}\n\n461:      receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L459\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n313:      fallback() external payable {}\n\n315:      receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L313\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23716",
      "title": "[L-02]  Don't use `payable.transfer()`/`payable.send()`",
      "impact": "LOW",
      "content": "The use of `payable.transfer()` is [heavily frowned upon](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) because it can lead to the locking of funds. The `transfer()` call requires that the recipient is either an EOA account, or is a contract that has a `payable` callback. For the contract case, the `transfer()` call only provides 2300 gas for the contract to complete its operations. This means the following cases can cause the transfer to fail:\n* The contract does not have a `payable` callback\n* The contract's `payable` callback spends more than 2300 gas (which is only enough to emit something)\n* The contract is called through a proxy which itself uses up the 2300 gas\nUse OpenZeppelin's `Address.sendValue()` instead\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n154:              payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L154\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23715",
      "title": "[L-1]  Only a billion checkpoints available",
      "impact": "LOW",
      "content": "A user can only have a billion checkpoints which, if the user is a DAO, may cause issues down the line, especially if the last checkpoint involved delegating and can thereafter not be undone\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/contracts/VotingEscrow.sol\n\n535:     mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n```\nhttps://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L535\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "8797",
      "title": "[G-42] Variable `end` can be of type  `uint128`",
      "impact": "GAS",
      "content": "Variable `end` can be of type  `uint128`  to take less place and save one storage slot.<br>\nA lot of protocols even use `uint64` for dates to reduce gas usage.<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L270-L273\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n270: struct LockedBalance {\n271:     int128 amount;\n272:     uint256 end; //@audit can be uint128 to save storage slot\n273: }\n```\nit can be\n```solidity\n270: struct LockedBalance {\n271:     int128 amount;\n272:     uint128 end;\n273: }\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-42-variable-end-can-be-of-type--uint128",
      "tags": [],
      "finders": []
    },
    {
      "id": "8796",
      "title": "[G-41] Obsolete constants",
      "impact": "GAS",
      "content": "These values can be accessed via kewords, there is no benefit in having these constants:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L57\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n57:     uint256 constant secsInDay = 24 * 60 * 60; \n```\nWe can use `1 days` instead of `secsInDay`<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L4\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n295:     uint256 internal constant WEEK = 1 weeks;\n```\nWe can use `1 weeks` instead of `WEEK`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-41-obsolete-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8795",
      "title": "[G-40] Same calculation twice",
      "impact": "GAS",
      "content": "`supply_before - value` calculated twice, also it is *checked* arithmetic operation, so cheaper to store result in a stack variable than calculate it twice;<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1015-L1029\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1015:         uint256 supply_before = supply;\n1016:         supply = supply_before - value;\n\n1029:         emit Supply(supply_before, supply_before - value);\n```\nWe could store result to stack variable and use it instead:\n```solidity\n1016:         uint256 supply_now = supply = supply_before - value;\n\n1029:         emit Supply(supply_before, supply_now);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-40-same-calculation-twice",
      "tags": [],
      "finders": []
    },
    {
      "id": "8794",
      "title": "[G-39] No need for mapping `supportedInterfaces` to exist",
      "impact": "GAS",
      "content": "This mapping takes some space and every time `supportsInterface(bytes4)` is called we do `SLOAD` to get data from this mapping.<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L368\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n368:     function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n369:         return supportedInterfaces[_interfaceID];\n370:     }\n```\nI suggest we remove the mapping and  change the function `supportsInterface(bytes4)` to:\n```solidity\n368:     function supportsInterface(bytes4 _interfaceID) external virtual view returns (bool) {\n369:         return _interfaceID == ERC165_INTERFACE_ID ||\n\t\t\t\t\t\t\t\t\t\t\t_interfaceID == ERC721_INTERFACE_ID ||\n\t\t\t\t\t\t\t\t\t\t\t_interfaceID == ERC721_METADATA_INTERFACE_ID\n370:     }\n```\n\nThis way we don't need the mapping `supportedInterfaces` and no `SLOAD`s done;<br>\nIf inherited contracts support other interfaces or don't support these just override this function and add/remove conditions;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-39-no-need-for-mapping-supportedinterfaces-to-exist",
      "tags": [],
      "finders": []
    },
    {
      "id": "8793",
      "title": "[G-38] Remove duplicate code",
      "impact": "GAS",
      "content": "There is a peace of code that is duplicated in bo blocks of `if` `else`<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#467\n```solidity\n467:    if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n```\n\nTo reduce deployment gas should be:\n```solidity\n\tif (current_count != current_index) {\n\t\t\tuint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n\t\t\t// Add\n\t\t\t// update ownerToNFTokenIdList\n\t\t\townerToNFTokenIdList[_from][current_index] = lastTokenId;\n\t\t\t// update tokenToOwnerIndex\n\t\t\ttokenToOwnerIndex[lastTokenId] = current_index;\n\t} \n\t// update ownerToNFTokenIdList\n\townerToNFTokenIdList[_from][current_count] = 0;\n\t// update tokenToOwnerIndex\n\ttokenToOwnerIndex[_tokenId] = 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-38-remove-duplicate-code",
      "tags": [],
      "finders": []
    },
    {
      "id": "8792",
      "title": "[G-37] Wasted gas on copying a struct",
      "impact": "GAS",
      "content": "https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#840\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n840: LockedBalance memory _locked = locked_balance;\n\n1164:     function _supply_at(Point memory point, uint256 t) internal view returns (uint256) {\n1165:         Point memory last_point = point;\n```\n`locked_balance` is of same type and never used after this. Same thing with `point`;<br>\nThere is no need in copy of it, but gas for making a copy is spent;\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-37-wasted-gas-on-copying-a-struct",
      "tags": [],
      "finders": []
    },
    {
      "id": "8791",
      "title": "[G-36] `last_point` value rewritten right after initialization",
      "impact": "GAS",
      "content": "If `_epoch > 0`, then `last_point` is rewritten, and initialization on L726 becomes waste of gas;<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#726\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n726:        Point memory last_point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n727:        if (_epoch > 0) {\n728:            last_point = point_history[_epoch];\n729:        }\n```\n### Mitigation\n```solidity\nPoint memory last_point = _epoch > 0 ? last_point = point_history[_epoch] \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-36-last_point-value-rewritten-right-after-initialization",
      "tags": [],
      "finders": []
    },
    {
      "id": "8790",
      "title": "[G-35] No need to read `tokenId` second time",
      "impact": "GAS",
      "content": "https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L948\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n948:        ++tokenId;\n949:        uint256 _tokenId = tokenId;\n```\n### Mitigation\nChange it to `uint256 _tokenId = ++tokenId;` and `92 gas is saved this way`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-35-no-need-to-read-tokenid-second-time",
      "tags": [],
      "finders": []
    },
    {
      "id": "8789",
      "title": "[G-34] No need to evaluate all expressions to know if one of them is true",
      "impact": "GAS",
      "content": "When we have a code `expressionA || expressionB` if `expressionA` is true then `expressionB` will not be evaluated and gas saved;<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L650\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n650: bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n651: bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n652: require(senderIsOwner || senderIsApprovedForAll);\n```\nVariables `bool senderIsOwner` and `bool senderIsApprovedForAll`  just add more work, \nit  should  be:\n```solidity\n require((idToOwner[_tokenId] == msg.sender) || (ownerToOperators[owner])[msg.sender];\n```\nso if `(idToOwner[_tokenId] == msg.sender)` is `true` we will not do SLOAD to get `(ownerToOperators[owner])[msg.sender]`;\nsaving runtime and deployment gas;\n\nsame thing here:\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L439\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n439:        bool spenderIsOwner = owner == _spender;\n440:        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n441:        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n442:        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n```\nBut this one is a `view` function, so only deployment gas saved.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-34-no-need-to-evaluate-all-expressions-to-know-if-one-of-them-is-true",
      "tags": [],
      "finders": []
    },
    {
      "id": "8788",
      "title": "[G-33] Remove unreachable code",
      "impact": "GAS",
      "content": "There is a peace of code that does not need to exist:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L177\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n177:        require(signaturesigner == o.signer, 'invalid signature');\n178:        if (signaturesigner != o.signer) {\n179:            return (0, hashStruct, 0); //@audit unreachable code\n180:        }\n```\nCheck inside `if` is pointless, because `signaturesigner != o.signer` can not be `true`, when if it is, then transaction is already reverted because of line 177.<br>\n`hardhat-gas-reporter` shows deployment gas difference from `2013842` to `2001108`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-33-remove-unreachable-code",
      "tags": [],
      "finders": []
    },
    {
      "id": "8787",
      "title": "[G-32] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L317\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n317:     string public constant name = 'veNFT';\n318:    string public constant symbol = 'veNFT';\n319:    string public constant version = '1.0.0';\n320:    uint8 public constant decimals = 18;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-32-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8786",
      "title": "[G-31] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.<br>\nLess obvious fixes/optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98-L138\n`rewardToken` accessed 7 times;\n`epoch` accessed 15 times;\n`ve` accessed 2 times;\n`epochTotalFee[epoch]` accessed 2 times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L144\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L158\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L172-L210\n`ve` accessed 8 times\n`epochBeginTime[epochs[index]]` accessed 4 times\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L242-L269\n`distributor` accessed two times; \n\n### Small PoC\ncopy `distributor` to stack variable:<br>\n`Distributor _distributor = distributor` ;<br>\nuse `_distributor` instead of `distributor`;<br>\n`hardhat-gas-reporter` results<br>\nbefore fix:\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238153 |241948|241401| 7 |\nafter fix:\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238052 |241847|241300| 7 |\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L382-L383<br>\n`WETH` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L384-L402<br>\n`distributor` accessed two times; \n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L138-L139<br>\n`checkpoints[nftId][nCheckpoints - 1]` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L213-L214<br>\n`checkpoint.delegatedTokenIds` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L644-L650<br>\n`idToOwner[_tokenId]` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L948-L949<br>\n`tokenId` accessed two times;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-31-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "8785",
      "title": "[G-30] State variables with values known at compile time should be constants",
      "impact": "GAS",
      "content": "Variables with values known at compile time and that do not change at runtime should be declared as `constant`.<br>\n*There is 2 instance of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L46\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n46: uint256 public startTime; // timestamp at which the contracts need to be activated\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L45\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n45: ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-30-state-variables-with-values-known-at-compile-time-should-be-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8784",
      "title": "[G-29] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "Avoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a `PUSH32` (3 gas). If getters are still desired, '\\_' can be added to the variable name and the getter can be added manually.\n\n*There is 3 instance of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n68: ERC20 public rewardToken;\n69: ERC20 public weth;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L300\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n300: address public token;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-29-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8783",
      "title": "[G-28] Remove or replace unused variables",
      "impact": "GAS",
      "content": "Remove or replace unused variables to save deployment gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L4\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n319:    string public constant version = '1.0.0';\n320:    uint8 public constant decimals = 18;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-28-remove-or-replace-unused-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "8782",
      "title": "[G-27] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra chunk of byetes past the original 32 i[incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs 3 gas.<br>\n*There are 8 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L24\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n24: require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L181\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n181:  require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n\n292: require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n309: require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L73\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n73: require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L929\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n929: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n945: require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n\n983: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-27-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8781",
      "title": "[G-26] Copying struct to memory can be more expensive than just reading from storage",
      "impact": "GAS",
      "content": "I suggest using the `storage` keyword instead of the `memory` one, as the copy in memory is wasting some MSTOREs and MLOADs.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L925\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1083: LockedBalance memory _locked = locked[_tokenId];\n\n1136: Point memory point_1 = point_history[_epoch + 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L101\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n101: Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n```\n\nShould use `storage`, because each struct field is read only once.\n \n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-26-copying-struct-to-memory-can-be-more-expensive-than-just-reading-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "8780",
      "title": "[G-25] `<array>.length` should not be looked up in every loop of a for-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop<br>\n* storage arrays incur a Gwarmaccess (100 gas)\n* memory arrays use `MLOAD` (3 gas)\n* calldata arrays use `CALLDATALOAD` (3 gas)\n\t\nCaching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n143: for (uint256 index = 0; index < epochs.length; index++) {\n\n157: for (uint256 index = 0; index < epochs.length; index++) {\n\n180: for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183: for (uint256 index = 0; index < epochs.length; index++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L415\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n415: for (uint256 i = 0; i < proof.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L171\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n171: for (uint256 index = 0; index < delegated.length; index++) {\n\n189: for (uint256 index = 0; index < delegatednft.length; index++) {\n\n199: for (uint256 i; i < _array.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-25-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "8779",
      "title": "[G-24] Do not calculate constants",
      "impact": "GAS",
      "content": "Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L48\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n48: uint256 constant dailyEmission = 600000 * 10**18;\n\n57: uint256 constant secsInDay = 24 * 60 * 60;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L296\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n296: uint256 internal constant MAXTIME = 4 * 365 * 86400;\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-24-do-not-calculate-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8778",
      "title": "[G-23] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 12 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L36\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n36: function mint(address _account, uint256 _amount) external onlyMinter {\n\n42: function mintAirdrop(address _airdrop) external onlyOwner {\n\n50: function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n\n58: function setMinter(address _minter) external onlyOwner {\n\n65: function executeSetMinter() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L285\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n285: function changeTrader(address _trader) external onlyOwner {\n\n291: function executeChangeTrader() external onlyOwner {\n\n298: function addVoteEscrow(address _voteEscrow) external onlyOwner {\n\n308: function executeAddVoteEscrow() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n444: function setDistributor(address _distributor) external onlyOwner {\n\n454: function executeSetDistributor() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L260\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n260: function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-23-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8777",
      "title": "[G-22] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.\n\n*There are 5 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L58\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n58:    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n59:    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L332\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n331: /// @dev Mapping from owner address to count of his tokens.\n332: mapping(address => uint256) internal ownerToNFTokenCount;\n\n334: /// @dev Mapping from owner address to mapping of index to tokenIds\n335: mapping(address => mapping(uint256 => uint256)) internal ownerToNFTokenIdList;\n\n340: /// @dev Mapping from owner address to mapping of operator addresses.\n341: mapping(address => mapping(address => bool)) internal ownerToOperators;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-22-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "8776",
      "title": "[G-21] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save **\\~50 gas** each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also saves deployment gas.\n\n*There are 76 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L24\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n24: require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n\n43: require(!isAirdropMinted, 'already minted');\n\n51: require(!isGenesisRewardMinted, 'already minted');\n\n69: require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L88\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n88: require(msg.sender == trader);\n\n144: require(epochs[index] < epoch);\n\n158: require(epochs[index] < epoch);\n\n173: require(address(ve) != address(0), ' VE not added yet');\n\n181: require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n\n184: require(epochs[index] < epoch, 'cant claim for future epochs');\n185: require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n\n220: require(address(ve) != address(0), ' VE not added yet');\n\n292: require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n309: require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L177\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n177: require(signaturesigner == o.signer, 'invalid signature');\n\n211:  require(\n212:    o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n213:    'amt not matching'\n214:  );\n\n217: require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n220: require(msg.sender == o.reservedAddress);\n\n222: require(o.orderType == 0, 'invalid orderType');\n\n226: require(status == 3, 'order not valid');\n227: require(amountRemaining >= amount, 'order already filled');\n\n235: require(amount == 1, 'only 1 erc721 at 1 time');\n\n285: require(\n286:   o.totalAmt * amount >\n287:    (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n\n291:  require(msg.sender == o.reservedAddress);\n\n293: require(o.orderType == 1);\n\n295:  require(status == 3);\n296:  require(amountRemaining >= amount);\n\n299: require(amount == 1, 'only 1 erc721 at 1 time');\n\n313: require(o.signer == msg.sender);\n\n342: require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n\n345: require(msg.sender == o.reservedAddress);\n\n347: require(o.orderType == 2);\n\n349: require(status == 3);\n350: require(amountRemaining >= amount);\n\n359: require(amount == 1, 'only 1 erc721 at 1 time');\n\n455: require(distributorEnableDate <= block.timestamp, 'not allowed');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L72\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n72: require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n73: require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n99: require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n130: require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n186: require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n211: require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n239: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n245: require(_isApprovedOrOwner(_sender, _tokenId));\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L360\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n360: require(_entered_state == _not_entered);\n\n538: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n540: require(_isApprovedOrOwner(_sender, _tokenId));\n\n646: require(owner != address(0));\n\n648: require(_approved != owner);\n\n652: require(senderIsOwner || senderIsApprovedForAll);\n\n869: require(msg.sender == voter);\n\n874: require(msg.sender == voter);\n\n879: require(msg.sender == voter);\n\n884: require(msg.sender == voter);\n\n889: require(msg.sender == voter);\n\n894: require(attachments[_from] == 0 && !voted[_from], 'attached');\n895: require(_from != _to);\n896: require(_isApprovedOrOwner(msg.sender, _from));\n897: require(_isApprovedOrOwner(msg.sender, _to));\n\n927: require(_value > 0); // dev: need non-zero value\n928: require(_locked.amount > 0, 'No existing lock found');\n929: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n944: require(_value > 0); // dev: need non-zero value\n945: require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n946: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n982: require(_locked.amount > 0, 'No existing lock found');\n983: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n996: require(_locked.end > block.timestamp, 'Lock expired');\n997: require(_locked.amount > 0, 'Nothing is locked');\n998: require(unlock_time > _locked.end, 'Can only increase lock duration');\n999: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n1008: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n1011: require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n\n1082: require(idToOwner[_tokenId] != address(0), 'Query for nonexistent token');\n\n1227: require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n```\n\n### Mitigation\nCustom errors are defined using the `error` statement<br>\nReplace `require` statements with custom errors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-21-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8775",
      "title": "[G-20] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.<br>\nIt is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html<br>\n\nUse a larger size then downcast where needed.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L271\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n271: int128 amount; //@audit no storage slot saved\n\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n311: mapping(uint256 => int128) public slope_changes; // time -> signed slope change\n\n320: uint8 public constant decimals = 18;\n\n356:  uint8 internal constant _not_entered = 1;\n357:\tuint8 internal constant _entered = 2;\n358:  uint8 internal _entered_state = 1;\n\n697:  int128 old_dslope = 0;\n698:  int128 new_dslope = 0;\n\n749:  int128 d_slope = 0;\n\n1169: int128 d_slope = 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-20-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "8774",
      "title": "[G-19] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` and `assert` statement",
      "impact": "GAS",
      "content": "`> 0` is less efficient than `!= 0` for unsigned integers.<br>\n`!= 0` costs less gas compared to `> 0` for unsigned integers in `require` and `assert` statements with the optimizer enabled (6 gas).<br>\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L927\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n927: require(_value > 0); // dev: need non-zero value\n\n944: require(_value > 0); // dev: need non-zero value\n\n981: assert(_value > 0); // dev: need non-zero value\n```\n### Mitigation\nReplace `> 0` with `!= 0`<br>\nOr update soldity compiler to >=0.8.13\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-19-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-and-assert-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "8773",
      "title": "[G-18] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27><br>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past.\n\n*There are 5 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L20\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n20:    bool public isAirdropMinted;\n21:    bool public isGenesisRewardMinted;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L314\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n314: mapping(uint256 => bool) public voted;\n\n341: mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n344: mapping(bytes4 => bool) internal supportedInterfaces;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-18-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "8772",
      "title": "[G-17] Unchecked arithmetic",
      "impact": "GAS",
      "content": "The default “checked” behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.<br>\nIf it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an unchecked block will save gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L60\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\nminterEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L106\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n106: if (block.timestamp > startTime + (epoch) * secsInDay) {\n\n112:  uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n113:    rewardToken.totalSupply();\n114:  uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n118: epoch = epoch + 1;\n\n143: for (uint256 index = 0; index < epochs.length; index++) {\n\n157: for (uint256 index = 0; index < epochs.length; index++) {\n\n180: for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183: for (uint256 index = 0; index < epochs.length; index++) {\n\n258: for (uint256 index = 0; index < epoch; index++) {\n\n273: for (uint256 index = 0; index < epoch; index++) {\n\n286: traderEnableDate = block.timestamp + 1 days;\n\n302: voteEscrowEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L324\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n324: uint256 newNonce = ++nonces[msg.sender];\n\n415: for (uint256 i = 0; i < proof.length; i++) {\n\n449: distributorEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L107\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n107: numCheckpoints[toTokenId] = nCheckpoints + 1;\n\n119: return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n\n138:    if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n139:        return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n\n148: uint256 upper = nCheckpoints - 1;\n\n150: uint256 center = upper - (upper - lower) / 2;\n\n157: upper = center - 1;\n\n171: for (uint256 index = 0; index < delegated.length; index++) {\n172: \t    votes = votes + this.balanceOfNFT(delegated[index]);\n\n189:    for (uint256 index = 0; index < delegatednft.length; index++) {\n190:        votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n\n199: for (uint256 i; i < _array.length; i++) {\n\n201: _array[i] = _array[_array.length - 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L499\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n499: ownerToNFTokenCount[_to] += 1;\n\n512: ownerToNFTokenCount[_from] -= 1;\n\n745: for (uint256 i = 0; i < 255; ++i) {\n\n748: t_i += WEEK;\n\n768: _epoch += 1;\n\n994: uint256 unlock_time = ((block.timestamp + _lock_duration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n999: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n1044: for (uint256 i = 0; i < 128; ++i) {\n\n1049: uint256 _mid = (_min + _max + 1) / 2;\n\n1053: _max = _mid - 1;\n\n1115: for (uint256 i = 0; i < 128; ++i) {\n\n1120: uint256 _mid = (_min + _max + 1) / 2;\n\n1124: _max = _mid - 1;\n\n1167: for (uint256 i = 0; i < 255; ++i) {\n\n1213:  Point memory point_next = point_history[target_epoch + 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/TokenUriHelper.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/TokenUriHelper.sol\n138:            digits++;\n139:            temp /= 10;\n\n143:            digits -= 1;\n144:            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n145:            value /= 10;\n```\n\n### Mitigation\nPlace the arithmetic operations in an `unchecked` block\n```\n\tfor (uint i; i < length;) {\n\t\t...\n\t\tunchecked{ ++i; }\n\t}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-17-unchecked-arithmetic",
      "tags": [],
      "finders": []
    },
    {
      "id": "8771",
      "title": "[G-16] `internal` and `private` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 10 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L116\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n116: function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) \n{\n129: function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n\n198: function removeElement(uint256[] storage _array, uint256 _element) internal {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L452\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n452: function _addTokenToOwnerList(address _to, uint256 _tokenId) internal {\n\n462: function _removeTokenFromOwnerList(address _from, uint256 _tokenId) internal {\n\n571: function _isContract(address account) internal view returns (bool) {\n\n677: function _mint(address _to, uint256 _tokenId) internal returns (bool) {\n\n1107: function _balanceOfAtNFT(uint256 _tokenId, uint256 _block) internal view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L123\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n123: function _hashOrder(Order calldata o) private pure returns (bytes32) {\n\n127: function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-16-internal-and-private-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8770",
      "title": "[G-15] `x += y` costs more gas than `x = x + y` for state variables",
      "impact": "GAS",
      "content": "`x += y` costs more than `x = x + y`<br>\nsame as `x -= y`<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L499\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n499: ownerToNFTokenCount[_to] += 1;\n\n512: ownerToNFTokenCount[_from] -= 1;\n```\n\n### Mitigation\nReplace `x += y` and `x -= y` with `x = x + y` and `x = x - y`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-15-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "8769",
      "title": "[G-14] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "These state variables can be packed together to use less storage slots:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L297\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n320: uint8 public constant decimals = 18;\n\n347: bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n350: bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n353: bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n356: uint8 internal constant _not_entered = 1;\n357: uint8 internal constant _entered = 2;\n358: uint8 internal _entered_state = 1;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-14-state-variables-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "8768",
      "title": "[G-13] `struct Order`: can be more tighly packed",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (20000 gas) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.<br>\n\nBefore:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L47\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n47:     struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId — set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n```\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238167 |241974|241425| 7 |\n| GolomTrader | setDistributor| 46281 |70449|47432| 21 |\n\n| Deployments ||\n|-|:-:|\n| Contract | avg |\n| GolomTrader | 2029204 |\n\nAfter:<br>\n```solidity\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId — set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n```\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238153 |241948|241394| 7 |\n| GolomTrader | setDistributor| 46259 |70427|47410| 21 |\n\n| Deployments ||\n|-|:-:|\n| Contract | avg |\n| GolomTrader | 2013782 |\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-13-struct-order-can-be-more-tighly-packed",
      "tags": [],
      "finders": []
    },
    {
      "id": "8767",
      "title": "[G-12] `abi.encode()` is less efficient than `abi.encodePacked()`",
      "impact": "GAS",
      "content": "Consider changing it if possible.<br>\n*There are 4 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L102\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n102:  abi.encode(\t\n115:\tabi.encode(\t\t \n130:\tabi.encode(\n414:  bytes32 computedHash = keccak256(abi.encode(leaf));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-12-abiencode-is-less-efficient-than-abiencodepacked",
      "tags": [],
      "finders": []
    },
    {
      "id": "8766",
      "title": "[G-11] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "Instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement (saving 3 gas per `&`).<br>\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper.\n\n*There are 4 instances of this issue:*\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L239\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n239: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L538\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n538: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n894: require(attachments[_from] == 0 && !voted[_from], 'attached');\n1008: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-11-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8765",
      "title": "[G-10] Multiplication/division by 2 should use bit shifting",
      "impact": "GAS",
      "content": "`<x> * 2` is equivalent to `<x> << 1` and `<x> / 2` is the same as `<x> >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas.\n\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L150\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n150: uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1049\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1049: uint256 _mid = (_min + _max + 1) / 2;\n1120: uint256 _mid = (_min + _max + 1) / 2;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-10-multiplicationdivision-by-2-should-use-bit-shifting",
      "tags": [],
      "finders": []
    },
    {
      "id": "8764",
      "title": "[G-09] Default value initialization",
      "impact": "GAS",
      "content": "\n### Problem\nIf a variable is not set/initialized, it is assumed to have the default value (`0`, `false`, `0x0` etc depending on the data type).<br>\nExplicitly initializing it with its default value is an anti-pattern and wastes gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L45\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n45:  uint256 public epoch = 0;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\nuint256 public MIN_VOTING_POWER_REQUIRED = 0;\n```\n\n### Proof of Concept\nIn case of `RewardDistributor`<br>\n`hardhat-gas-reporter` results<br>\nbefore fix:<br>\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2379507  | 2379543  |  2379537\t|\nafter fix:\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2377233  | 2377269  |  2377263\t|\n\n### Mitigation\nRemove explicit initialization for default values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-09-default-value-initialization",
      "tags": [],
      "finders": []
    },
    {
      "id": "8763",
      "title": "[G-08] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "If you choose to make suggested above `public` functions as `external`, to continue gas optimizaton we can use `calldata`  function arguments instead of `memory`.<br>\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n98:  function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141: function traderClaim(address addr, uint256[] memory epochs) public {\n\n155: function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172: function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-08-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8762",
      "title": "[G-07] `public` functions to `external`",
      "impact": "GAS",
      "content": "External call cost is less expensive than of public functions.<br>\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents’ functions and change the visibility from `external` to `public`.<br>\nThe following functions could be set `external` to save gas and improve code quality:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n98:  function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141: function traderClaim(address addr, uint256[] memory epochs) public {\n\n155: function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172: function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L203\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n203: function fillAsk(\n204:        Order calldata o,\n205:        uint256 amount,\n206:        address referrer,\n207:        Payment calldata p,\n208:        address receiver\n209:    ) public payable nonReentrant {\n\n279: function fillBid(\n280:        Order calldata o,\n281:        uint256 amount,\n282:        address referrer,\n283:        Payment calldata p\n284:    ) public nonReentrant {\n\n312: function cancelOrder(Order calldata o) public nonReentrant {\n\n334: function fillCriteriaBid(\n335:        Order calldata o,\n336:        uint256 amount,\n337:        uint256 tokenId,\n338:        bytes32[] calldata proof,\n339:        address referrer,\n340:        Payment calldata p\n341:    ) public nonReentrant {\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-07-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "8761",
      "title": "[G-06] Amounts should be checked for `0` before calling a transfer",
      "impact": "GAS",
      "content": "Checking non-zero transfer values can avoid an expensive external call and save gas.<br>\nWhile this is done at some places, it's not consistently done in the solution.<br>\nI suggest adding a non-zero-value check here:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L151\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n151: rewardToken.transfer(addr, reward);\n\n165: rewardToken.transfer(addr, reward);\n\n208:  rewardToken.transfer(tokenowner, reward);\n\n209:  weth.transfer(tokenowner, rewardEth);\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L238\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n238: ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n\n304: nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n\n364: nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n\n382: WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n\n383: WETH.withdraw(o.totalAmt * amount);\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1023\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1023: assert(IERC20(token).transfer(msg.sender, value));\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-06-amounts-should-be-checked-for-0-before-calling-a-transfer",
      "tags": [],
      "finders": []
    },
    {
      "id": "8760",
      "title": "[G-05] The result of external function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "There is no need to call another contract functions multiple times to get same value, returned value should be cached in a variable;\nThe instances below point to the second+ call of the function within a single function:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L100\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n100: if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n112:\t\tuint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n113:\t\t\trewardToken.totalSupply();\n114:\t\tuint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n239:      (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n240:      ve.totalSupplyAt(epochBeginTime[index]);\n\n244:       ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n245:     ve.totalSupplyAt(epochBeginTime[index]);\n```\n`rewardToken.totalSupply()` should be cached.\n`ve.balanceOfAtNFT(tokenid, epochBeginTime[index]))` should be cached.\n`ve.totalSupplyAt(epochBeginTime[index])` should be cached.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-05-the-result-of-external-function-calls-should-be-cached-rather-than-re-calling-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "8759",
      "title": "[G-04] Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it",
      "impact": "GAS",
      "content": "To help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.\nThe effect can be quite significant.<br>\nAs an example, instead of repeatedly calling `someMap[someIndex]`, save its reference like this: `SomeStruct storage someStruct = someMap[someIndex]` and use it.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n138:        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n139:            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n```\n\nDeclare `storage` variable and use it:\n```solidity\nCheckpoint storage checkpoint = checkpoints[nftId][nCheckpoints - 1];\nif (checkpoint.fromBlock <= blockNumber) {\n    return checkpoint.delegatedTokenIds;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-04-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it",
      "tags": [],
      "finders": []
    },
    {
      "id": "8758",
      "title": "[G-03] Cheaper input valdiations should come before expensive operations",
      "impact": "GAS",
      "content": "Check @audit comment for details<br>\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L925\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n925:        LockedBalance memory _locked = locked[_tokenId];\n926:\t\t\t\t\t//@audit this check should be before we read from storage\n927:        require(_value > 0); // dev: need non-zero value\n\n942:        uint256 unlock_time = ((block.timestamp + _lock_duration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n943:\t\t\t\t\t//@audit this check should be before we do unlock_time evalutaion\n944:        require(_value > 0); // dev: need non-zero value\n\n977:        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n978:\n979:        LockedBalance memory _locked = locked[_tokenId];\n980:\t\t\t\t\t//@audit this check should be first, before line 977 check\n981:        assert(_value > 0); // dev: need non-zero value\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-03-cheaper-input-valdiations-should-come-before-expensive-operations",
      "tags": [],
      "finders": []
    },
    {
      "id": "8757",
      "title": "[G-02] Access mappings directly rather than using accessor functions",
      "impact": "GAS",
      "content": "Saves having to do two `JUMP` instructions, along with stack setup<br>\n*There are 6 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L72\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n72:\t\trequire(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n211:  require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1229\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1229:\taddress owner = ownerOf(_tokenId);\n\n406:\treturn _balance(_owner);\n\n453:\tuint256 current_count = _balance(_to);\n\n464:\tuint256 current_count = _balance(_from) - 1;\n```\n### Mitigation\nIstead of `ownerOf(tokenId)` use `idToOwner[tokenId]`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-02-access-mappings-directly-rather-than-using-accessor-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "8756",
      "title": "[G-01] ++variable costs less gas than variable++, especially when it’s used in for-loops (--variable/variable-- too)",
      "impact": "GAS",
      "content": "Prefix increments are cheaper than postfix increments.<br>\nSaves 6 gas *PER LOOP*<br>\n*There are 12 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n143:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n157:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n180:\tfor (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n226:\tfor (uint256 index = 0; index < epoch; index++) {\n\n258:\tfor (uint256 index = 0; index < epoch; index++) {\n\n273:\tfor (uint256 index = 0; index < epoch; index++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L415\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n415:\tfor (uint256 i = 0; i < proof.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L171\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n171:\tfor (uint256 index = 0; index < delegated.length; index++) {\n\n189:\tfor (uint256 index = 0; index < delegatednft.length; index++) {\n\n199:\tfor (uint256 i; i < _array.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/TokenUriHelper.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/TokenUriHelper.sol\n138:\tdigits++;\n```\n\n### Mitigation\nChange `i++` to `++i`\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-01-variable-costs-less-gas-than-variable-especially-when-its-used-in-for-loops---variablevariable---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "8755",
      "title": "[M-18] `fillAsk()` Allows for `msg.value` to be larger than require locking the excess in the contract",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L217](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L217)<br>\n\nIt is possible to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract.\n\n### Proof of Concept\n\nThere is only one check over `msg.value` and it is that it's greater than `o.totalAmt * amount + p.paymentAmt`. As seen in the following code snippet from #217.\n\n```solidity\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n```\n\nThe issue here is that the contract will only ever spend exactly `o.totalAmt * amount + p.paymentAmt`. Hence if `msg.value` is greater than this then the excess value will be permanently locked in the contract.\n\n### Recommended Mitigation Steps\n\nTo avoid this issue consider enforcing a strict equality.\n\n```solidity\n        require(msg.value == o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/75)**\n\n**[0xsaruman (Golom) disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/75#issuecomment-1236313317):**\n > Resolved: https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR217\n> \n> Disagree with severity cause it's user choice to send more.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/75#issuecomment-1276385424):**\n > I agree with this being a medium. It opens up the potential for griefing attacks and all sorts of other issues that may be beyond the scope of \"the user decided to send excess funds\". Further, it's common for contracts to return excess funds, so the user may reasonably expect this behaviour.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the GolomTrader.sol contract, which is part of the 2022-07-golom GitHub repository. This bug could allow someone to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract, meaning the funds are not retrievable. To mitigate this issue, the code should be updated to enforce a strict equality for the `msg.value` parameter, instead of just a greater-than comparison. This would ensure that the exact amount required is sent, and no excess funds are locked in the contract.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/75",
      "tags": [],
      "finders": [
        "codexploder",
        "scaraven",
        "cryptonue",
        "GiveMeTestEther",
        "rbserver",
        "arcoun",
        "minhquanym",
        "joestakey",
        "Twpony",
        "Lambda",
        "peritoflores",
        "Green",
        "reassor",
        "jayphbee",
        "cccz",
        "rotcivegaf",
        "Ruhum",
        "0xSky",
        "Treasure-Seeker",
        "horsefacts",
        "ych18",
        "RustyRabbit",
        "CertoraInc",
        "bin2chen",
        "AuditsAreUS",
        "dipp",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8754",
      "title": "[M-17] NFTs that don't have a checkpoint can't be transferred",
      "impact": "MEDIUM",
      "content": "\nSubmitting as high risk because it breaks a fundamental operation (transferring) for a large number of tokens.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L212-L213>\n\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n\nL242 of `transferFrom()` calls `removeDelegation()` with the tokenId of the token being transferred. For tokens that don't have any checkpoints, L212 will return 0. This was cause an underflow error and revert in L213.\n\n### Recommended Mitigation Steps\n\nMake removeDelegation simply return if `nCheckpoints = 0`.\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/191#issuecomment-1202226637):**\n > Unsure if high risk, but warden correctly identified the issue (that some others didn't) that the underflow in `removeDelegation` will prevent tokens from being transferred.\n\n**[zeroexdead (Golom) disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/191)**\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/191#issuecomment-1276259331):**\n > Marking this as a medium risk because it only temporarily breaks functionality. The workaround would be to delegate the token and then transfer it, making the impact aggravating but ultimately minimal.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the transferFrom() function of the VoteEscrowDelegation.sol contract. It impacts the transfer of NFTs (Non-Fungible Tokens) that don't have a checkpoint, as they can't be transferred. A proof of concept is provided, showing that the transferFrom() function calls removeDelegation() with the tokenId of the token being transferred. If the token doesn't have any checkpoints, an underflow error will occur and the transfer will be reverted. The recommended mitigation step is to make removeDelegation simply return if nCheckpoints = 0.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/191",
      "tags": [],
      "finders": [
        "0x52",
        "0xsanson"
      ]
    },
    {
      "id": "8753",
      "title": "[M-16] `GolomTrader`: `validateOrder` function does not check if ecrecover return value is 0",
      "impact": "MEDIUM",
      "content": "\nThe validateOrder function of GolomTrader calls the Solidity ecrecover function directly to verify the given signatures.\nThe return value of ecrecover may be 0, which means the signature is invalid, but the check can be bypassed when signer is 0.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L177>\n\n### Recommended Mitigation Steps\n\nUse the recover function from OpenZeppelin's ECDSA library for signature verification.\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/357#issuecomment-1205955355):**\n > Seems invalid or QA at best. No impact on protocol as far as I see, invalid orders from \"address 0\" will revert.<br>\n> In fillAsk if the `o.signer` is address 0, the function will try to pull tokens from address 0 and will fail.<br>\n> In fillBid/criteria, function will try to transfer msg.sender's tokens to address 0 and pull weth from address 0. So will fail.<br>\n\n**[0xsaruman (Golom) disputed](https://github.com/code-423n4/2022-07-golom-findings/issues/357)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/357#issuecomment-1277605944):**\n > This is valid as a medium risk. It opens a griefing attack where a bad actor spams any system that relies on this function. The fact that the fill will fail while the order appears valid is specifically what makes this griefing attack possible.\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the GolomTrader contract’s validateOrder function, which calls the Solidity ecrecover function directly to verify the given signatures. The return value of ecrecover may be 0, indicating an invalid signature, but the check can be bypassed when signer is 0. This bug could have a serious impact, as it could allow someone to bypass the signature verification process.\n\nTo fix this issue, it is recommended to use the recover function from OpenZeppelin’s ECDSA library for signature verification. This library provides a secure and reliable way to verify signatures, and should be used instead of the ecrecover function. By using this library, the bug can be fixed, and the signature verification process can be made secure.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/357",
      "tags": [],
      "finders": [
        "cccz",
        "joestakey",
        "0xHarry",
        "teddav",
        "AuditsAreUS",
        "jayjonah8",
        "djxploit",
        "0x1f8b"
      ]
    },
    {
      "id": "8752",
      "title": "[M-15] Griefer can minimize delegatee's voting power",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L71-L89><br>\n\nSimilar to a previous submission, there are no checks preventing against delegating the same lock NFT multiple times. This opens an avenue to an expensive but potentially profitable griefing attack where the malicious user fills the victim's delegated token array with minimum voting power. The attacker can ensure that a delegatee has 0 voting power.\n\n### Proof of Concept\n\nTaking a look at the `delegate()` function below, there are no checks that a lock NFT has not already been delegated. Therefore, an attacker can delegate their token with minimum voting power (threshold initialized with value 0) to the victim.\n\n        function delegate(uint256 tokenId, uint256 toTokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n\n            delegates[tokenId] = toTokenId;\n            uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n\n            if (nCheckpoints > 0) {\n                Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                checkpoint.delegatedTokenIds.push(tokenId);\n                _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n            } else {\n                uint256[] memory array = new uint256[](1);\n                array[0] = tokenId;\n                _writeCheckpoint(toTokenId, nCheckpoints, array);\n            }\n\n\n            emit DelegateChanged(tokenId, toTokenId, msg.sender);\n        }\n\nThere is a limit of 500 delegated tokens per delegatee. Therefore, the attacker can ensure minimum voting power if they delegate a worthless token 500 times to the victim:\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\nA more likely scenario would be as follows:\n\n*   A proposal is live.\n*   Users delegate their voting power to addresses of their choosing.\n*   A and B are around the same voting power.\n*   A and B both have 400 delegatees.\n*   Malicious address A delegates minimum voting power 100 times to fill B's array to 500.\n*   Address A can self-delegate just a bit more to obtain more voting power.\n\n### Recommended Mitigation Steps\n\nFirstly, removing the ability to delegate the same lock NFT would make this griefing attack much more expensive. Even if that is patched, a griefing attack is still possible by simply creating more locks and delegating them all once.\n\nI believe that removing the 500 delegated token limit would prove to mitigate this issue.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/707)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1236182307):**\n > We plan to keep sufficiently high `MIN_VOTING_POWER_REQUIRED` to prevent spam. \n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1238341323):**\n > Removed the ability to delegate same NFT. If user is trying to delegate same NFT, the old delegation will be removed.\n> \n> Reference: https://github.com/golom-protocol/contracts/commit/c74d95b4105eeb878d2781982178db5ca08a1a9b\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1279179694):**\n > I agree with the ranking of medium. This is a direct attack vector, but it's unlikely to be used.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the VoteEscrowDelegation.sol contract. This vulnerability allows malicious users to fill a victim's delegated token array with minimum voting power, reducing the victim's voting power to zero. This can be done by delegating a worthless token 500 times to the victim.\n\nThe vulnerability exists because there are no checks preventing against delegating the same lock NFT multiple times. There is also a limit of 500 delegated tokens per delegatee, meaning that an attacker can fill the victim's array with minimum voting power by delegating a worthless token 500 times.\n\nThe recommended mitigation steps are to remove the ability to delegate the same lock NFT, and to remove the 500 delegated token limit. This would make the griefing attack much more expensive, and would prevent the attacker from filling the victim's array with minimum voting power.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/707",
      "tags": [],
      "finders": [
        "0x52",
        "0xsanson",
        "simon135",
        "0xDjango",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8751",
      "title": "[M-14] `VoteEscrowDelegation._transferFrom` can only be executed by the token owner",
      "impact": "MEDIUM",
      "content": "\n`VoteEscrowDelegation._transferFrom` should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. `removeDelegation` is called in `_transferFrom`. `removeDelegation` only accepts the token owner. Thus, `_transferFrom` can only be executed by the token owner.\n\n### Proof of Concept\n\n`removeDelegation` is called in `_transferFrom`<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242>\n\n        function _transferFrom(\n            address _from,\n            address _to,\n            uint256 _tokenId,\n            address _sender\n        ) internal override {\n            require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n            // remove the delegation\n            this.removeDelegation(_tokenId);\n\n            // Check requirements\n            require(_isApprovedOrOwner(_sender, _tokenId));\n            …\n        }\n\nHowever, `removeDelegation` only accept the token owner<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211>\n\n        function removeDelegation(uint256 tokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            uint256 nCheckpoints = numCheckpoints[tokenId];\n            Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n            removeElement(checkpoint.delegatedTokenIds, tokenId);\n            _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        }\n\n### Recommended Mitigation Steps\n\nFix the permission control in `removeDelegation`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/631)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/631#issuecomment-1236182667):**\n > Changed the `external` function to `public`. Users address will be passed as `msg.sender` now.<br>\n> https://github.com/golom-protocol/contracts/commit/10ec920765a5ee2afc2fe269d32ea9138d1156b6\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/631)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the permission control in the VoteEscrowDelegation smart contract. The `_transferFrom` function should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. However, the `removeDelegation` function which is called in `_transferFrom` only accepts the token owner. This means that the `_transferFrom` function can only be executed by the token owner. To fix this, the permission control in `removeDelegation` should be changed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/631",
      "tags": [],
      "finders": [
        "GimelSec",
        "GalloDaSballo",
        "kenzo",
        "kebabsec"
      ]
    },
    {
      "id": "8750",
      "title": "[M-13] Rewards owed burned NFT in `RewardDistributor.sol` become irretrievable",
      "impact": "MEDIUM",
      "content": "\n[RewardDistributor.sol#L172-L210](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210)<br>\n\nRewards owed burned NFT are permanently locked.\n\n### Proof of Concept\n\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\nAfter an NFT is burned, owner of token is set to `address(0)`.\n\n        rewardToken.transfer(tokenowner, reward);\n\nThis causes issues in multiStakerClaim L208. GOLOM uses OZ's implementation of ERC20 which doesn't allow tokens to be sent to `address(0)`. Because the \"owner\" of the burned NFT is `address(0)` multiStakerClaim will always revert when called for a burned NFT trapping rewards in contract forever.\n\n### Recommended Mitigation Steps\n\nImplement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)) the rewards should be transferred to different address. These rewards could be claimed to the treasury or burned, etc.\n\n        if (tokenowner == address(0){\n            rewardToken.transfer(treasury, reward);\n            weth.transfer(treasury, rewardEth);\n        }\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/86#issuecomment-1230541517):**\n > I think its QA because burning NFT means the owner doesn't want anything to do with rewards or the NFT anymore.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the RewardDistributor.sol contract, located on the github repository at the given link. The issue is that when an NFT is burned, the owner of the token is set to address(0). This causes an issue in the multiStakerClaim function, which uses OZ's implementation of ERC20, which does not allow tokens to be sent to address(0). As a result, the rewards are trapped in the contract forever.\n\nThe impact of this bug is that rewards owed to burned NFTs are permanently locked.\n\nThe proof of concept for this bug is provided in the report, and tools used are not specified.\n\nThe recommended mitigation step for this bug is to implement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)), the rewards should be transferred to a different address. These rewards could be claimed to the treasury or burned, etc.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/86",
      "tags": [],
      "finders": [
        "kyteg",
        "0x52"
      ]
    },
    {
      "id": "8749",
      "title": "[M-12] Some setters' timelock can be bypassed",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L58-L72><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444-L457><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L298-L311><br>\n\nMED - Function could be impacted\n\nAs the timelock does not work as supposed to work, the owner of the contract can bypass timelock.\n\n*   Affected Functions:\n    *   `GolomToken`: `setMinter`, `executeSetMinter`\n    *   `GolomTrader`: `setDistributor`, `executeSetDistributor`\n    *   `RewardDistributor`: `addVoteEscrow`, `executeAddVoteEscrow`\n\n### Proof of Concept\n\n*   [GolomTrader::it can bypass timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26)\n*   [GolomToken::setMinter it should set the minter with timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)\n\nThe [first poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26) shows to bypass timelock for `GolomTrader::setDistributor`. The same logic applies for the `RewardDistributor::addVoteEscrow`.<br>\n0\\. The `setDistributor` was called once in the beforeEach block to set the initial distributor. For this exploit to work, the `setDistributor` should be called only once. If `setDistributor` was called more than once, one can set the distributor to zero address (with timelock like in the `GolomToken` case, then set to a new distributor after that)\n\n1.  reset distributor to zero address without timelock by calling `executeSetDistributor`\n2.  set a new distributor without timelock by calling `setDistributor`\n3.  Rinse and repeat: as long as `setDistributor` is not called multiple times in row, the owner can keep setting distributor without timelock.\n\nA little bit different variation of timelock bypass was found in the `GolomToken`. Although the owner should wait for the timelock to set the minter to zero address, but after that, the owner can set to the new minter without waiting for a timelock. Since the meaning of timelock is to let people know the new minter's implementation, if the owner can bypass that, the timelock is almost meaningless.<br>\nThe exploitation steps: [the second proof of concept](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)\n\n1.  call `setMineter` with zero address\n2.  wait for the timelock\n3.  call `executeSetMineter` to set the minter to zero address\n4.  now the onwer can call `setMineter` with any address and call `executeSetMinter` without waiting for the timelock\n\nThe owner can call `executeSetdistributor` even though there is no `pendingDistributor` set before. Also, `setDistributor` sets the new distributor without timelock when the existing distributor's address is zero.\n\n```solidity\n// GolomTrader\n// almost identical logic was used in `RewardDistributor` to addVoteEscrow\n// similar logic was used in `GolomToken` to `setMineter`\n\n\n444     function setDistributor(address _distributor) external onlyOwner {\n445         if (address(distributor) == address(0)) {\n446             distributor = Distributor(_distributor);\n447         } else {\n448             pendingDistributor = _distributor;\n449             distributorEnableDate = block.timestamp + 1 days;\n450         }\n451     }\n452\n453     /// @notice Executes the set distributor function after the timelock\n454     function executeSetDistributor() external onlyOwner {\n455         require(distributorEnableDate <= block.timestamp, 'not allowed');\n456         distributor = Distributor(pendingDistributor);\n457     }\n```\n\n### Recommended Mitigation Steps\n\nTo mitigate, execute functions can check whether pendingDistributor is not zero. It will ensure that the setters are called before executing them, as well as prevent to set to zero addresses.\n\n**[0xsaruman (Golom) disputed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1216949773):**\n > call setMineter with zero address<br>\n> wait for the timelock\n> \n> This alone will trigger awareness that something malicious is happening and since timelock is there people have time to get out.\n\n**[0xsaruman (Golom) confirmed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1219749160):**\n > The second POC is valid.\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1236738770):**\n > Removed all secondary time locks in the contract and only using the primary timelock that will be behind the owner.\n>\n > https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-94d75c3059a714c355bd15d139c30d4f9899df283d29717622ffd5c930445499R59\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that could be exploited in the code of the GolomToken, GolomTrader, and RewardDistributor smart contracts. The vulnerability would allow the owner of the contract to bypass the timelock, meaning they could set the minter and distributor without waiting for the timelock to expire. This could have a medium impact on the function of the contract. \n\nTwo proof of concept scenarios have been provided. The first one shows how to bypass the timelock for the GolomTrader::setDistributor and the same logic applies for the RewardDistributor::addVoteEscrow. The steps for this exploit include resetting the distributor to a zero address without a timelock and then setting a new distributor without the timelock. \n\nThe second proof of concept shows how to bypass the timelock for the GolomToken::setMinter. This exploit involves calling the setMinter with a zero address, waiting for the timelock to expire, then calling the executeSetMinter to set the minter to zero address. After that, the owner can call the setMinter with any address and call the executeSetMinter without waiting for the timelock. \n\nThe owner can also call the executeSetDistributor even though there is no pendingDistributor set before. Furthermore, the setDistributor can be set to a new distributor without a timelock when the existing distributor's address is zero. \n\nNo tools were used for this vulnerability. The recommended mitigation steps to prevent this exploit from happening include executing functions that check whether the pendingDistributor is not zero. This will ensure that the setters are called before executing them, as well as prevent setting to zero addresses.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/698",
      "tags": [],
      "finders": [
        "GiveMeTestEther",
        "berndartmueller",
        "zzzitron",
        "GimelSec",
        "sseefried"
      ]
    },
    {
      "id": "8748",
      "title": "[M-11] When `MIN_VOTING_POWER_REQUIRED` is changed, previous votes are not affected",
      "impact": "MEDIUM",
      "content": "\nWhen `MIN_VOTING_POWER_REQUIRED` is changed, tokenIDs with votes lower than `MIN_VOTING_POWER_REQUIRED` will not be able to vote through the delegate function, but previous votes will not be affected.<br>\nSince `MIN_VOTING_POWER_REQUIRED` is mainly used to reduce the influence of spam users, changing this value should affect previous votes.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L260-L262><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L73-L74><br>\n\n### Recommended Mitigation Steps\n\nIn the getPriorVotes and getVotes functions, when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased\n\n```diff\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n+         if(this.balanceOfNFT(delegated[index]) >= MIN_VOTING_POWER_REQUIRED){\n            votes = votes + this.balanceOfNFT(delegated[index]);\n+       }\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n+         if(this.balanceOfAtNFT(delegatednft[index], blockNumber) >= MIN_VOTING_POWER_REQUIRED){\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n+         }\n        }\n        return votes;\n    }\n```\n\n**[zeroexdead (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/626)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/626#issuecomment-1236182938):**\n > When calling we `getVotes()` and `getPriorVotes()` we're considering `MIN_VOTING_POWER_REQUIRED`.<br>\n> Reference: https://github.com/golom-protocol/contracts/commit/db650729b0805ec19906a0ea11de6af7a53ac382\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/626)**\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/626#issuecomment-1279184086):**\n > Downgrading this to medium. Assets are not at direct risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the VoteEscrowDelegation.sol contract. The vulnerability occurs when the MIN_VOTING_POWER_REQUIRED value is changed. This value is used to reduce the influence of spam users, and when it is changed, tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be able to vote through the delegate function, but the votes already cast will not be affected.\n\nThe impact of this vulnerability is that when MIN_VOTING_POWER_REQUIRED is changed, the votes from tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be counted, even though they were cast prior to the change.\n\nThe recommended mitigation steps for this vulnerability are to modify the getVotes and getPriorVotes functions so that when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased. This will ensure that the votes from tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be counted.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/626",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "8747",
      "title": "[M-10] Delegated NFTs that are withdrawn while still delegated will remain delegated even after burn",
      "impact": "MEDIUM",
      "content": "\n[VoteEscrowCore.sol#L1226-L1236](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)<br>\n\nBurn NFTs remained delegated causing bloat and wasting gas.\n\n### Proof of Concept\n\nVoteEscrowDelegation.sol doesn't change the withdraw or \\_burn functions inherited from VoteEscrowCore.sol. These functions are ignorant of the delegation system and don't properly remove the delegation when burning an NFT. The votes for the burned NFT will be removed but the reference will still be stored in the delegation list where it was last delegated. This creates a few issues. 1) It adds bloat to both getVotes and getPriorVotes because it adds a useless element that must be looped through. 2) The max number of users that can delegate to another NFT is 500 and the burned NFT takes up one of those spots reducing the number of real users that can delegate. 3) Adds gas cost when calling removeDelegation which adds gas cost to \\_transferFrom because removeElement has to cycle through a larger number of elements.\n\n### Recommended Mitigation Steps\n\nOverride \\_burn in VoteEscrowDelegation and add this.removeDelegation(\\_tokenId), similar to how it was done in \\_transferFrom.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/59)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/59#issuecomment-1236184219):**\n > Fixed.<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/a30a50abe1aa677374bdbf68e1e81d80e1545563\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/59)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/59#issuecomment-1279177352):**\n > I agree with the wardens and sponsor who rate this as medium. It does negatively impact the functioning of the protocol, but none of the reporting wardens have shown how it can be used as a direct attack vector IMO.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on an issue with the VoteEscrowDelegation.sol code in the 2022-07-golom GitHub repository. The bug affects the _burn function inherited from VoteEscrowCore.sol. The issue is that when an NFT is burned, the votes for that NFT are removed but the reference of the NFT is still stored in the delegation list. This causes a few issues, such as adding bloat to the getVotes and getPriorVotes functions, reducing the number of real users that can delegate, and adding gas cost when calling removeDelegation.\n\nThe recommended mitigation step is to override _burn in VoteEscrowDelegation and add this.removeDelegation(_tokenId), similar to how it was done in _transferFrom. This will ensure that when an NFT is burned, the reference to it is removed from the delegation list. This will help reduce bloat, increase the number of users that can delegate, and reduce the gas cost when calling removeDelegation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/59",
      "tags": [],
      "finders": [
        "IllIllI",
        "0x52",
        "rotcivegaf",
        "berndartmueller",
        "kenzo"
      ]
    },
    {
      "id": "8746",
      "title": "[M-09] `GolomToken.sol` doesn't contain a function to mint treasury tokens",
      "impact": "MEDIUM",
      "content": "\n[GolomToken.sol#L14-L73](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L14-L73)<br>\n\nPotential downtime in GolomTrader\n\n### Proof of Concept\n\nGolomToken.sol doesn't have a function to mint the treasury tokens as specified in the docs (<https://docs.golom.io/tokenomics-and-airdrop>). In order for these tokens to be minted, the minter would have to be changed via `setMinter()` and `executeSetMinter()` to a contract that can mint the treasury tokens. Because of the 24 hour timelock, this would lead to downtime for GolomTrader.sol if trading has already begun. This is because GolomTrader.sol calls `RewardDistributor.sol#addFees` each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. Because of the timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert.\n\n### Recommended Mitigation Steps\n\nAdd a function to GolomToken.sol to mint the treasury tokens similar to the `mintAirdrop()` and `mintGenesisReward()` functions.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/205)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/205#issuecomment-1236300333):**\n > https://github.com/golom-protocol/contracts/commit/746507ea6f71a017be178f7eeb66d2dbf92a4524\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the GolomToken.sol code which may lead to potential downtime in GolomTrader. This is because GolomTrader.sol calls RewardDistributor.sol#addFees each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. However, because of the 24 hour timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert. To mitigate this, a function should be added to GolomToken.sol to mint the treasury tokens similar to the mintAirdrop() and mintGenesisReward() functions.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/205",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "8745",
      "title": "[M-08] Pre-check is not correct",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L342><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L397><br>\n\n`fillCriteriaBid` can be reverted due to the pre-check while it can work.\n\n### Proof of Concept\n\nWhen `refererrAmt > 0` and `referrer` address is not set (is 0),\n`(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time.\n\nIt is when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`.<br>\nIn that case, `_settleBalances` can work, but fillCriteriaBid will be reverted due to the check in line 342.\n\n### Recommended Mitigation Steps\n\nI think `require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt)` is correct.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/851#issuecomment-1234195947):**\n > Very small chance of both conditions happening, `o.refererrAmt > (p.paymentAmt + protocolfee) / amount` and referrer address is 0.\n>\n > Resolved https://github.com/golom-protocol/contracts/commit/c15fa96271d8cf764274271eee649c79ca1b1f7d\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/851#issuecomment-1277666029):**\n > Nice catch.\n> \n> This tracks as a medium for me... it breaks protocol functionality given external factors.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the GolomTrader.sol contract. The vulnerability is that `fillCriteriaBid` can be reverted due to a pre-check while it can work. A proof of concept has been provided which demonstrates that when `refererrAmt > 0` and `referrer` address is not set (is 0), `(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time. This happens when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`. In this case, `_settleBalances` can work, but `fillCriteriaBid` will be reverted due to the check in line 342. \n\nThe recommended mitigation step is to add the requirement that `o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt`. Manual review was used to identify this vulnerability.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/851",
      "tags": [],
      "finders": [
        "0xSky"
      ]
    },
    {
      "id": "8744",
      "title": "[M-07] veNFT withdraw and merge fail for approved callers",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236><br>\n\nGolom is impacted by a known issue with the veNFT contract that causes the `merge` and `withdraw` functions to revert when called by an approved spender rather than the token owner.\n\n`merge` and `withdraw` may both be called by either the token owner or an approved spender. Note that both of these functions check `_isApprovedOrOwner`:\n\n[`VoteEscrowCore#merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908)\n\n```solidity\n    function merge(uint256 _from, uint256 _to) external {\n        require(attachments[_from] == 0 && !voted[_from], 'attached');\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint256 value0 = uint256(int256(_locked0.amount));\n        uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\n    }\n```\n\n[`VoteEscrowCore#withdraw`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030)\n\n```solidity\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint256 _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n        uint256 value = uint256(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0, 0);\n        uint256 supply_before = supply;\n        supply = supply_before - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n```\n\nHowever, both functions make internal calls to `_burn`, which does **not** handle the case of an approved caller correctly. The call to `_removeTokenFrom` on [L1234](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1234-L1235) passes `msg.sender` rather than the token `owner`, which will revert:\n\n[`VoteEscrowCore#_burn`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)\n\n```solidity\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n```\n\n### Impact\nApproved callers cannot `merge` or `withdraw` veNFTs. `merge` and `withdraw` may only be called by the token owner.\n\n### Recommended Mitigation Steps\n\nUpdate `_burn` to pass token owner address rather than `msg.sender`:\n\n```solidity\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(owner, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n```\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/858)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/858#issuecomment-1236181856):**\n > Removed `merge` and fixed withdraw here: https://github.com/golom-protocol/contracts/commit/c79913ec08ba2dca87a22f1bc6fe47f65f7b4202\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/858)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the veNFT contract of the Golom platform. The `merge` and `withdraw` functions of the contract check the `_isApprovedOrOwner` function, which allows either the token owner or an approved spender to call them. However, both functions make internal calls to `_burn`, which does not handle the case of an approved caller correctly. The call to `_removeTokenFrom` passes `msg.sender` rather than the token `owner`, which will cause the `merge` and `withdraw` functions to revert. \n\nThis means that approved callers cannot `merge` or `withdraw` veNFTs and `merge` and `withdraw` may only be called by the token owner. To fix this issue, the `_burn` function should be updated to pass token owner address rather than `msg.sender`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/858",
      "tags": [],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "rotcivegaf",
        "minhquanym",
        "GalloDaSballo",
        "berndartmueller",
        "hansfriese",
        "horsefacts",
        "kenzo"
      ]
    },
    {
      "id": "8743",
      "title": "[M-06] Orders with `tokenAmt` of `type(uint256).max` cannot be cancelled by `GolomTrader.sol#cancelOrder`",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L312-L317](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L312-L317)<br>\n\nOrder unable to be cancelled by `cancelOrder`.\n\n### Proof of Concept\n\n        filled[hashStruct] = o.tokenAmt + 1;\n\n`cancelOrder` will overflow in the line shown above if `o.tokenAmt` is `type(uint256).max` causing the transaction to always revert for that order.\n\n### Recommended Mitigation Steps\n\nI don't see any reason why 1 should be added to `o.tokenAmt`, change to:\n\n        filled[hashStruct] = o.tokenAmt;\n\n**[0xsaruman (Golom) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/176)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the code of the GolomTrader contract located at the GitHub link provided. The bug occurs when an order is unable to be cancelled by the cancelOrder function due to an overflow in the line: \n\n\"filled[hashStruct] = o.tokenAmt + 1;\"\n\nIf o.tokenAmt is type(uint256).max, the transaction will always revert for that order. To fix this, the line should be changed to \"filled[hashStruct] = o.tokenAmt;\" as there is no reason to add 1 to o.tokenAmt.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/176",
      "tags": [],
      "finders": [
        "0x52",
        "GimelSec"
      ]
    },
    {
      "id": "8742",
      "title": "[M-05] Replay attack in case of hard fork",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L98](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L98)<br>\n\nIf there is ever a hardfork for Golom then `EIP712_DOMAIN_TYPEHASH` value will become invalid. This is because the chainId parameter is computed in constructor. This means even after hard fork chainId would remain same which is incorrect and could cause possible replay attacks\n\n### Proof of Concept\n\n1.  Observe the constructor\n\n```\nconstructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n```\n\n2.  As we can see the chainId is derived and then hardcoded in `EIP712_DOMAIN_TYPEHASH`\n\n3.  This means even after hard fork, `EIP712_DOMAIN_TYPEHASH` value will remain same and point to incorrect chainId\n\n### Recommended Mitigation Steps\n\nThe EIP712\\_DOMAIN_TYPEHASH variable should be recomputed everytime by placing current value of chainId.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/391)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/391#issuecomment-1236138456):**\n > Resolved https://github.com/golom-protocol/contracts/commit/d8a24442b8f3a764139e312ed393e5d5ffb7e596\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/391#issuecomment-1276282601):**\n > I'm going to leave this as a medium risk. It would be a very high-impact scenario, but it relies on the external factor of a hard fork. That said, hard forks can and do happen.\n\n\n\n***\n\n",
      "summary": "\nThe bug report describes a vulnerability in the GolomTrader.sol code, which is part of the 2022-07-golom repository on GitHub. The vulnerability is related to the EIP712_DOMAIN_TYPEHASH variable, which is hardcoded in the constructor. If there is ever a hardfork for Golom, the chainId parameter will remain the same, which could lead to possible replay attacks. The recommended mitigation step is to recompute the EIP712_DOMAIN_TYPEHASH variable every time with the current value of chainId.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/391",
      "tags": [],
      "finders": [
        "codexploder",
        "0xsanson",
        "teddav",
        "berndartmueller",
        "chatch",
        "0x1f8b",
        "Treasure-Seeker",
        "0xNineDec",
        "RustyRabbit"
      ]
    },
    {
      "id": "8741",
      "title": "[M-04]  `VoteEscrowCore.safeTransferFrom` does not check correct magic bytes returned from receiver contract's `onERC721Received` function",
      "impact": "MEDIUM",
      "content": "\n[ERC721.sol#L395-L417](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ce0068c21ecd97c6ec8fb0db08570f4b43029dde/contracts/token/ERC721/ERC721.sol#L395-L417)<br>\n\nWhile `VoteEscrowCore.safeTransferFrom` does try to call `onERC721Received` on the receiver it does not check the for the required \"magic bytes\" which is `IERC721.onERC721received.selector` in this case. See [OpenZeppelin docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-) for more information.\n\nIt's quite possible that a call to `onERC721Received` could succeed because the contract had a `fallback` function implemented, but the contract is not ERC721 compliant.\n\nThe impact is that NFT tokens may be sent to non-compliant contracts and lost.\n\n### Proof of Concept\n\n[Lines 604 - 605](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L604-L605) are:\n\n```solidity\ntry IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\n    bytes memory reason\n```\n\nbut they should be:\n\n```solidity\ntry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n    return retval == IERC721Receiver.onERC721Received.selector;\n} catch (bytes memory reason)\n```\n\n### Recommended Mitigation Steps\n\nImplement `safeTransferReturn` so that it checks the required magic bytes: `IERC721Receiver.onERC721Received.selector`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/577)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/577#issuecomment-1236183431):**\n > Fixed.<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/19ba6e83892e24b859f081525c7e0f751f5e7ebb\n\n**[0xsaruman (Golom) resolved, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/577)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the OpenZeppelin Contracts ERC721 token contract. The vulnerability is that the `VoteEscrowCore.safeTransferFrom` function does not check for the required “magic bytes” which is `IERC721.onERC721received.selector`. This means that NFT tokens may be sent to non-compliant contracts and lost. The proof of concept for this vulnerability is that the lines 604 - 605 of the VoteEscrowCore.sol file should be changed from `try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (bytes memory reason` to `try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason)`. To mitigate this vulnerability, it is recommended that the `safeTransferReturn` function should be implemented and should check for the required magic bytes.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/577",
      "tags": [],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "0x4non",
        "rbserver",
        "cccz",
        "Jmaxmanblue",
        "arcoun",
        "rotcivegaf",
        "minhquanym",
        "berndartmueller",
        "Lambda",
        "JohnSmith",
        "sseefried"
      ]
    },
    {
      "id": "8740",
      "title": "[M-03] Voter in `VoteEscrowCore` can permanently lock user tokens",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L873-L876><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L883-L886><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L894><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L538><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008><br>\n\nA malicious voter can arbitrarily increase the number of `attachments` or set the `voted` status of a token to true. This prevents the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like.\n\nI submitted this is as a medium severity because it has external circumstances (a malicious voter) however has a very high impact if it does occur.\n\n### Proof of Concept\n\n1.  A user creates a lock for their token and deposits it into the VoteEscrowDelegate/Core contract.\n2.  The malicious voter then calls either `voting()` or `attach()` thereby preventing the user withdrawing their token after the locked time bypasses\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nI have not seen any use of `voting()` or `attach()` in any of the other contracts so it may be sensible to remove those functions altogether. On the other hand, setting voter to be smart contract which is not malicious offsets this problem.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/712)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/712#issuecomment-1236182159):**\n > Removed Voter: https://github.com/golom-protocol/contracts/commit/03572010ef868597310f4736c91aacf3aa044ce9\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/712)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the VoteEscrowCore.sol code which could allow a malicious voter to arbitrarily increase the number of attachments or set the voted status of a token to true. This would prevent the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like. The malicious voter could achieve this by calling either the voting() or attach() functions. The impact of this vulnerability is high, as it could cause a user to lose their tokens. \n\nThe vulnerability was found using the VS Code tool. The recommended mitigation steps include either removing the voting() and attach() functions from the code, or setting the voter to be a smart contract which is not malicious.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/712",
      "tags": [],
      "finders": [
        "scaraven"
      ]
    },
    {
      "id": "8739",
      "title": "[M-02] Use `safeTransferFrom` Instead of `transferFrom` for ERC721",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L236](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L236)<br>\n\nUse of `transferFrom` method for ERC721 transfer is discouraged and recommended to use safeTransferFrom whenever possible by OpenZeppelin.<br>\nThis is because `transferFrom()` cannot check whether the receiving address know how to handle ERC721 tokens.\n\nIn the function shown at below PoC, ERC721 token is sent to `msg.sender` with the `transferFrom` method.<br>\nIf this `msg.sender` is a contract and is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.\n\nReference: <https://docs.openzeppelin.com/contracts/3.x/api/token/erc721>\n\n### Proof of Concept\n```\nGolomTrader.sol:236:            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n```\n\n### Recommended Mitigation Steps\n\nI recommend to call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/342)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/342#issuecomment-1236301290):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR238\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the use of the transferFrom method for ERC721 token transfers. The use of this method is discouraged and it is recommended to use the safeTransferFrom method instead. This is because the transferFrom method cannot check if the receiving address knows how to handle ERC721 tokens. If the receiving address is a contract which is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.\n\nThe bug report includes a proof of concept which shows the use of the transferFrom method in the function. The bug was discovered using manual analysis.\n\nThe recommended mitigation step is to call the safeTransferFrom() method instead of transferFrom() for NFT transfers. This will ensure that the receiving address is aware of the incoming ERC721 tokens, and that the tokens are not locked up in the contract forever.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/342",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "SafeTransfer"
      ],
      "finders": [
        "0x52",
        "i0001",
        "rokinot",
        "0xf15ers",
        "Jujic",
        "brgltd",
        "cryptonue",
        "Bnke0x0",
        "saian",
        "djxploit",
        "Ch_301",
        "_Adam",
        "JC",
        "0xNazgul",
        "PaludoX0",
        "rbserver",
        "arcoun",
        "TomJ",
        "minhquanym",
        "0xDjango",
        "Twpony",
        "Chom",
        "M0ndoHEHE",
        "Lambda",
        "peritoflores",
        "Kenshin",
        "Sm4rty",
        "0x4non",
        "reassor",
        "apostle0x01",
        "0xsanson",
        "cccz",
        "Waze",
        "rotcivegaf",
        "erictee",
        "Ruhum",
        "ellahi",
        "hansfriese",
        "oyc_109",
        "cloudjunky",
        "Treasure-Seeker",
        "Kumpa",
        "sseefried",
        "TrungOre",
        "8olidity",
        "__141345__",
        "CertoraInc",
        "bin2chen",
        "Dravee",
        "GalloDaSballo",
        "shenwilly",
        "RedOneN",
        "benbaessler",
        "GimelSec"
      ]
    },
    {
      "id": "8738",
      "title": "[M-01] Use `call()` rather than `transfer()` on address payable",
      "impact": "MEDIUM",
      "content": "\n[L154](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154) in [GolomTrader.sol](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol) uses `.transfer()` to send ether to other addresses. There are a number of issues with using `.transfer()`, as it can fail for a number of reasons (specified in the Proof of Concept).\n\n### Proof of Concept\n\n1.  The destination is a smart contract that doesn’t implement a `payable` function or it implements a `payable` function but that function uses more than 2300 gas units.\n2.  The destination is a smart contract that doesn’t implement a `payable` `fallback` function or it implements a `payable` `fallback` function but that function uses more than 2300 gas units.\n3.  The destination is a smart contract but that smart contract is called via an intermediate proxy contract increasing the case requirements to more than 2300 gas units. A further example of unknown destination complexity is that of a multisig wallet that as part of its operation uses more than 2300 gas units.\n4.  Future changes or forks in Ethereum result in higher gas fees than transfer provides. The `.transfer()` creates a hard dependency on 2300 gas units being appropriate now and into the future.\n\n### Tools Used\n\nVim\n\n### Recommended Remediation Steps\n\nInstead use the `.call()` function to transfer ether and avoid some of the limitations of `.transfer()`. This would be accomplished by changing `payEther()` to something like;\n\n```solidity\n(bool success, ) = payable(payAddress).call{value: payAmt}(\"\"); // royalty transfer to royaltyaddress\nrequire(success, \"Transfer failed.\");\n```\n\nGas units can also be passed to the `.call()` function as a variable to accomodate any uses edge cases. Gas could be a mutable state variable that can be set by the contract owner.\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/343)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/343#issuecomment-1236301220):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR154\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/343#issuecomment-1287092544):**\n > Given how many upgrades I'm making on this, I figured a comment on my reasoning was in order. In many contests, this would be considered low risk. While unlikely to occur without warning, it is well-documented and so very well might occur at some point in the foreseeable future. With Golom's implementation, the entire functionality of the protocol would break if the gas price were to rise, resulting in a need to relaunch/redeploy. The extreme nature of this disruption offsets the other factors normally considered and is why I consider it to be a medium risk in this contest.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of GolomTrader.sol, a smart contract. The vulnerability is related to the use of the `.transfer()` function to send ether to other addresses. This function can fail for a number of reasons, such as if the destination is a smart contract that doesn’t implement a `payable` function, or if it implements a `payable` function but that function uses more than 2300 gas units. It can also fail if the destination is a smart contract but that smart contract is called via an intermediate proxy contract, or if future changes or forks in Ethereum result in higher gas fees than transfer provides. To remediate this issue, the recommended solution is to use the `.call()` function instead of `.transfer()`, and to pass the gas units as a variable to the `.call()` function. This will help to avoid some of the limitations of `.transfer()`.",
      "quality_score": 1.0014334963240574,
      "rarity_score": 1.001075122243043,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/343",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "codexploder",
        "0x52",
        "scaraven",
        "brgltd",
        "cryptonue",
        "Bnke0x0",
        "saian",
        "giovannidisiena",
        "0xNazgul",
        "arcoun",
        "minhquanym",
        "joestakey",
        "Chom",
        "Lambda",
        "peritoflores",
        "0x1f8b",
        "MEP",
        "Noah3o6",
        "IllIllI",
        "reassor",
        "immeas",
        "Ruhum",
        "ellahi",
        "oyc_109",
        "Treasure-Seeker",
        "StyxRave",
        "0xNineDec",
        "durianSausage",
        "CertoraInc",
        "cthulhu_cult",
        "Dravee",
        "GalloDaSballo",
        "0xHarry",
        "dharma09",
        "JohnSmith",
        "navinavu",
        "bulej93",
        "Jmaxmanblue",
        "Jujic",
        "Krow10",
        "rbserver",
        "bardamu",
        "kenzo",
        "Deivitto",
        "cccz",
        "rotcivegaf",
        "hansfriese",
        "cloudjunky",
        "bin2chen",
        "shenwilly",
        "RedOneN",
        "indijanc",
        "GimelSec",
        "0xf15ers",
        "_Adam",
        "TomJ",
        "0xDjango",
        "Kenshin",
        "simon135",
        "jayphbee",
        "bearonbike",
        "0xsolstars",
        "kyteg",
        "zzzitron",
        "sseefried",
        "TrungOre",
        "8olidity",
        "__141345__",
        "StErMi",
        "dipp",
        "obront",
        "rokinot",
        "ladboy233",
        "cryptphi",
        "djxploit",
        "asutorufos",
        "teddav",
        "c3phas",
        "0x4non",
        "0xsanson",
        "horsefacts",
        "jayjonah8",
        "carlitox477",
        "hyh",
        "cRat1st0s"
      ]
    },
    {
      "id": "8737",
      "title": "[H-11] Cannot remove delegation from a token to another token",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L213](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L213)<br>\n\nA user who has delegated the vote of a veGolom token (that he/she owns) to another veGolom token cannot remove the delegation, so the delegatee token will permanently hold the voting power of the delegator token.\n\n### Proof of Concept\n\nA user tries to remove the delegation from `tokenId` he/she owns to the delegated token, calling `removeDelegation(uint256 tokenId)`.<br>\nThe delegation should be removed at the lines:\n\n```solidity\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n```\n\nbut the array `checkpoint.delegatedTokenIds` is the list of **delegators** to `tokenId` **itself**. So, unless the delegation was from the token to itself, `removeDelegation` does nothing.\n\n### Recommended Mitigation Steps\n\nTwo fixes are proposed:\n\n1.  Add the delegatee as an argument to `removeDelegation` and remove `tokenId` from its list of delegators:\n\n```diff\n-   function removeDelegation(uint256 tokenId) external {\n+   function removeDelegation(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```\n\nor\n\n2.  Load the delegatee from the mapping `delegates` which maps each delegator to its current delegatee:\n\n```diff\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n+       uint256 toTokenId = delegates[tokenId];\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1202178536):**\n > Note that in the mitigation, `nCheckpoints` should access `toTokenId` instead of `tokenId`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/751)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1236182091):**\n > Fixed. https://github.com/golom-protocol/contracts/commit/4b19fce83ad53bc56b1bad058e1e88d90acda444\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/751)**\n\n**[LSDan (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1277527328):**\n > I agree with the other wardens who rated this high risk. It has a direct impact on the functioning of the protocol and allows for a myriad of governance attacks.\n\n\n\n***\n \n",
      "summary": "\nA bug was found in the code for the VoteEscrowDelegation.sol file on line 213. The bug prevents a user who has delegated the vote of a veGolom token (that they own) to another veGolom token from removing the delegation, meaning the delegatee token will permanently hold the voting power of the delegator token. \n\nThe bug is caused by the array checkpoint.delegatedTokenIds being the list of delegators to tokenId itself, meaning unless the delegation was from the token to itself, the removeDelegation function does nothing. \n\nTwo fixes have been proposed to mitigate this bug. The first fix is to add the delegatee as an argument to removeDelegation and remove tokenId from its list of delegators. The second fix is to load the delegatee from the mapping delegates which maps each delegator to its current delegatee. \n\nIt is important to fix this bug as it prevents users from removing the delegation from their veGolom tokens, meaning the delegatee token will permanently hold the voting power of the delegator token.",
      "quality_score": 5,
      "rarity_score": 1.3333333333333333,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/751",
      "tags": [],
      "finders": [
        "panprog",
        "IllIllI",
        "0x52",
        "Bahurum",
        "0xsanson",
        "cccz",
        "scaraven",
        "CertoraInc",
        "GalloDaSballo",
        "berndartmueller",
        "dipp",
        "Green",
        "0xA5DF",
        "GimelSec",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8736",
      "title": "[H-10] Upon changing of delegate, `VoteDelegation` updates both the previous and the current checkpoint",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L79><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213><br>\n\nThe contract is accidently editing both the previous and current checkpoint when changing/removing a delegate.\n\n### Impact\n\nIncorrect counting of votes.\n\n### Proof of Concept\n\nIf in `delegate` the delegate already has checkpoints, the function will grab the latest checkpoint, and add the `tokenId` to it. Note that it changes the storage variable.\n\n```solidity\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n```\n\nIt then calls `_writeCheckpoint`, which [will add](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L106) a new checkpoint if there's no checkpoint created for this block yet:\n\n```solidity\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n```\n\nTherefore, if this function has created a new checkpoint with the passed `_delegatedTokenIds`, we already saw that the previous function has already added `tokenId` to the previous checkpoint, so now both the new checkpoint and the previous checkpoint will have `tokenId` in them.<br>\nThis is wrong as it updates an earlier checkpoint with the latest change.\n\nThe same situation happens in [`removeDelegation`](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213).\n\n### Recommended Mitigation Steps\n\nWhen reading the latest checkpoint:\n\n```solidity\nCheckpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n```\n\nChange the `storage` to `memory`. This way it will not affect the previous checkpoint, but will pass the correct updated array to `_writeCheckpoint`, which will then write/update the correct checkpoint.\n\n**[zeroexdead (Golom) confirmed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1238529978):**\n > Fixed `delegate()`: https://github.com/golom-protocol/contracts/commit/8a8c89beea22cd57f4ffaf3d0defcce863e9657f\n> \n> Fixed `removeDelegation()`: https://github.com/golom-protocol/contracts/commit/72350b0a3bdae4f21e2f015327037080f6bab867\n\n**[LSDan (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1276357474):**\n > I went back and forth on if this was a duplicate of [H-04 (#169)](https://github.com/code-423n4/2022-07-golom-findings/issues/169) or not. The two issues are so similar it's hard to pull them apart. Ultimately I do see the difference, mainly that this version of the issue results in a retroactive manipulation of voting power whereas the other issue allows the creation of infinite voting power. I'm upgrading this to high risk because it effectively destroys the integrity of the voting system which impacts every aspect of the protocol which is subject to vote.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the VoteEscrowDelegation.sol contract, which incorrectly counts votes. The bug occurs when a delegate is changed or removed. The contract is accidently editing both the previous and current checkpoint, which causes an incorrect counting of votes. To fix the bug, the storage variable should be changed to a memory variable when reading the latest checkpoint. This will prevent the previous checkpoint from being affected, and will pass the correct updated array to the _writeCheckpoint function, which will then write/update the correct checkpoint.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/81",
      "tags": [],
      "finders": [
        "0xpiglet",
        "IllIllI",
        "0xsanson",
        "Bahurum",
        "arcoun",
        "0xA5DF",
        "kenzo"
      ]
    },
    {
      "id": "8735",
      "title": "[H-09] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185><br>\n\nA malicious user can repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This can effectively be done using services like [Flashbots bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#can-you-give-a-step-by-step-description-of-how-flashbots-works-for-a-searcher-today) and will result in the draining of the WETH balance of the `RewardDistributor` contract.\n\nThe idea is to bypass the require statement [line 185](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185) which checks if a claim has been already done for the epoch, **for a specific token ID**. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, **if the transaction happens in the same block for which the epoch is updated**.\n\nIndeed, when `multiStakerClaim()` is called, the `rewardETH` will be calculated from the amount of tokens locked in `tokenids[tindex]` at the block that triggered the epoch change (variable `epochBeginTime`). If, during this time, an attacker transfers its staked tokens to a new vault using the [`merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893) function of the VE token, the function will calculate the amount of staked tokens for the newly created tokenID **as the same as the original tokenID reward**.\n\nA example abuse will look like this (pseudo-code adapted from the PoC) :\n\n```javascript\nlockID = voteEscrow.create_lock(amount, 1 week); // Create lock #1 before\n// IN THE BLOCK OF EPOCH CHANGE\nrewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch 0 rewards for lock #1\nvoteEscrow.create_lock(1, 1 week); // Create lock #2 (requires 1 Golom token, could be created in advance)\nvoteEscrow.merge(lockId, lockId + 1); // Transfer lock #1 tokens to lock #2\nrewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2\n// repeat ...\n```\n\nTo abuse this, the attacker needs to follow this steps:\n\n*   Have some locked Golom tokens.\n*   Wait for a `addFee` call that will trigger an epoch change (this can be monitored by looking at the mempool or predicted from block timestamps). Services like Flashbots also [allows for specifying a range of blocks for bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#how-do-i-target-a-timestamp-range-instead-of-a-block-number-when-submitting-a-bundle) for better targeting.\n*   Send a bundle of transactions to be included with the block containing the epoch changing transaction (see the PoC for an example of transactions).\n\nNote that this needs to succeed only once to allow an attacker to drain all WETH funds so if the bundle isn't included for a particular epoch, given the frequency of epoch changes, the bundle will eventually be included and trigger the exploit.\n\n### Proof of Concept\n\nSee warden's [original submission](https://github.com/code-423n4/2022-07-golom-findings/issues/139) for full proof of concept.\n\n### Recommended Mitigation Steps\n\nI initially thought about a few possible solutions:\n\n*   Checking a lock creation time to prevent claiming from locks created in the same block **but the attacker can just create the blocks beforehand.**\n*   Tracking the `msg.sender` or `tx.origin` for preventing multiple calls to `multiStakerClaim` in the same block **but the attacker can just send transactions from different addresses.**\n*   Preventing the merging of locks **but the attacker can just create locks in advance and withdraw/add funds continuously between old/new locks.**\n\nNone really fixes the vulnerability as it comes from the feature of **locks being tradable** meaning it's not practically feasable to know if a lock has already be claimed by an individual **just by looking at the lock ID**.\n\nA possible solution would be to find a way to prevent multiple calls to the same function within a block or better, make a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards (instead of querying the VE contract in the loop).\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/139)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/139#issuecomment-1237934237):**\n > Removed `merge()`<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/b987077f2a227273bc7051e382bd55264162a77e\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious user being able to repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This is done by bypassing the require statement which checks if a claim has been already done for the epoch, for a specific token ID. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, if the transaction happens in the same block for which the epoch is updated.\n\nThe attacker needs to follow steps such as having some locked Golom tokens, waiting for a `addFee` call that will trigger an epoch change, sending a bundle of transactions to be included with the block containing the epoch changing transaction and repeating the process as much as necessary.\n\nThe recommended mitigation steps to fix this vulnerability include finding a way to prevent multiple calls to the same function within a block or making a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/139",
      "tags": [],
      "finders": [
        "Krow10"
      ]
    },
    {
      "id": "8734",
      "title": "[H-08]  Users can avoid paying fees while trading trustlessly & using Golom's network effects",
      "impact": "HIGH",
      "content": "\n*   If a maker makes below mentioned `AvoidsFeesContract` a [reservedAddress](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L220) and hides the info about how much they want their NFT in [order.root](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L58), they can avoid paying fees while trading trustlessly and using the nework effects of golom maketplace with 0 [o.totalAmt](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L52). See POC to get a better idea.\n*   Here the maker uses order.root to hide the amount they want to get paid because it is much cleaner for a POC.\n    *   But since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n    *   Reason they would use deadline is because that is something they can control in the golom NFT frontend\n    *   They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check in the contract would look a different\n\n### Proof of Concept\n\n*   Clone the [repo](https://github.com/code-423n4/2022-07-golom) and run `yarn`\n*   Create a `AvoidsFeesContract.sol` contract in `contracts/test/` folder with following code\n\n```\n//contract that avoids paying fees everytime\n\npragma solidity 0.8.11;\n\nimport \"../core/GolomTrader.sol\";\n\n//A maker will be gurranteed a payout if it makes this contract the reservedAddress and hide the payment info about how much they want in Oder.root\n//Users will use this every time to trade to avoid paying fees\n//They use the networking effects of the golom marketplace without paying the fees\ncontract AvoidsFeesContract {\n    GolomTrader public immutable golomTrader;\n\n    constructor(GolomTrader _golomTrader) {\n        golomTrader = _golomTrader;\n    }\n\n    function fillAsk(\n        GolomTrader.Order calldata o,\n        uint256 amount,\n        address referrer,\n        GolomTrader.Payment calldata p,\n        address receiver\n    ) public payable {\n        require(\n            o.reservedAddress == address(this),\n            \"not allowed if signer has not reserved this contract\"\n        ); //the signer will only allow this contract to execute the trade and since it has following checks, they will be guranteed a payout they want without paying the fees\n        require(\n            p.paymentAddress == o.signer,\n            \"signer needs to be the payment address\"\n        );\n        //I am using root as an example because it is much cleaner for a POC.\n        //but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n        //Reason they would use deadline is because that is something they can control in the golom NFT frontend\n        //They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check below would look a little different\n        require(\n            p.paymentAmt == uint256(o.root),\n            \"you need to pay what signer wants\"\n        ); //the maker will hide the payment info in oder.root\n\n        golomTrader.fillAsk{value: msg.value}(\n            o,\n            amount,\n            referrer,\n            p,\n            receiver = msg.sender\n        );\n    }\n}\n\n```\n\n*   Add following test in `test/GolomTrader.specs.ts` [here](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L390).\n*   Also, add `const AvoidsFeesContractArtifacts = ethers.getContractFactory('AvoidsFeesContract');` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L14) line and `import { AvoidsFeesContract as AvoidsFeesContractTypes } from '../typechain/AvoidsFeesContract';` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L28) line.\n*   Run `npx hardhat compile && npx hardhat test`\n\n```\n       it.only('should allow malicious contract to execute the trade while bypassing the fees', async () => {\n            //deploy the malicious contract\n            const avoidsFeesContract: AvoidsFeesContractTypes = (await (await AvoidsFeesContractArtifacts).deploy(golomTrader.address)) as AvoidsFeesContractTypes;\n\n            //here the frontend calculates exchangeAmount and prePaymentAmt as a percentage of how much the make wants to receive for their NFT. \n            //as far as the frontend is concerned, the maker inputs 0 for their NFT value which in turn makes the exchangeAmount and prePaymentAmt 0 \n            let exchangeAmount = ethers.utils.parseEther('0'); // nothing to the exchange\n            let prePaymentAmt = ethers.utils.parseEther('0'); // no royalty cut\n            let totalAmt = ethers.utils.parseEther('0');\n            let tokenId = await testErc721.current();\n\n            let nftValueThatMakerWants = ethers.utils.parseEther('10.25');\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: ethers.utils.hexZeroPad(nftValueThatMakerWants.toHexString(), 32), //convert Bignumber to bytes32\n                reservedAddress: avoidsFeesContract.address,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2); //a valid signature as far as your frontend goes\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n            let makerBalanceBefore = await ethers.provider.getBalance(await maker.getAddress());\n\n            await avoidsFeesContract.connect(taker).fillAsk(\n                order,\n                1,\n                '0x0000000000000000000000000000000000000000',\n                {\n                    paymentAmt: nftValueThatMakerWants,\n                    paymentAddress: order.signer,\n                },\n                receiver,\n                {\n                    value: nftValueThatMakerWants,\n                }\n            );\n\n            let makerBalanceAfter = await ethers.provider.getBalance(await maker.getAddress());\n\n            expect(await testErc721.balanceOf(await taker.getAddress())).to.be.equals('1');\n            expect(makerBalanceAfter.sub(makerBalanceBefore)).to.be.equals(nftValueThatMakerWants);//maker is guaranteed a payout\n\n        });\n\n```\n\n### Tools Used\n\n*   The [repo](https://github.com/code-423n4/2022-07-golom) itself. (hardhat)\n\n### Recommended Mitigation Steps\n\n*   Make sure that o.totalAmt is greater than p.paymentAmt in addition to [this](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L217) check\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/33)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/33#issuecomment-1214216268):**\n > Circumvented by putting this line in the code\n> \n> `require(o.totalAmt * amount * 15/100 >= p.paymentAmt, 'can only pay 15% extra');`\n\n\n\n***\n\n",
      "summary": "\nA vulnerability has been identified in the code of the GolomTrader.sol contract, which is part of the 2022-07-golom repository on GitHub. This vulnerability could allow users to avoid paying fees when trading trustlessly and making use of the network effects of the Golom marketplace. This is done by making a specific contract, called AvoidsFeesContract, a reservedAddress and hiding the information about how much they want for their NFT in order.root.\n\nThe proof of concept for this vulnerability involves cloning the repository, creating the AvoidsFeesContract contract, and adding a test to the GolomTrader.specs.ts file. This test would deploy the malicious contract and then use the frontend to calculate exchangeAmount and prePaymentAmt as a percentage of how much the maker wants to receive for their NFT. The maker would then input 0 for their NFT value, which in turn would make the exchangeAmount and prePaymentAmt 0. The maker would then hide the payment information in order.root.\n\nThe recommended mitigation steps for this vulnerability include making sure that o.totalAmt is greater than p.paymentAmt in addition to the existing check.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/33",
      "tags": [],
      "finders": [
        "kankodu"
      ]
    },
    {
      "id": "8733",
      "title": "[H-07] `_writeCheckpoint` does not write to storage on same block",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L101-L108](https://github.com/golom-protocol/contracts/blob/4e84d5c2115d163ca54a1729da46164e8cf4df6d/contracts/vote-escrow/VoteEscrowDelegation.sol#L101-L108)<br>\n\nIn `VoteEscrowDelegation._writeCheckpoint`, when the checkpoint is overwritten in the same block the new value is set with `memory oldCheckpoint` and thus is never written to storage.\n\n```javascript\nCheckpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\nif (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n\noldCheckpoint.delegatedTokenIds = _delegatedTokenIds; \n}\n```\n\nUsers that remove and delegate a token (or call `delegate` on the same token twice) in the same block will only have their first delegation persisted.\n\n### Proof of Concept\n\n*   User delegates a `tokenId` by calling `delegate`.\n*   In the same block, the user decides to delgate the same token to a different token ID and calls `delegate` again which calls `_writeCheckpoint`.  Since this is the second transaction in the same block the if statement in the code block above executes and stores `_delegatedTokenIds` in `memory oldCheckpoint`, thus not persisting the array of `_delegatedTokenIds` in the checkpoint.\n\n### Recommended Mitigation Steps\n\nDefine the `oldCheckpoint` variable as a `storage` pointer:\n\n`Checkpoint storage oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];`\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/455#issuecomment-1211731162):**\n > Just want to add to the impact (in case the judges consider to decrease severity), in my report of this bug ([#625](https://github.com/code-423n4/2022-07-golom-findings/issues/625)) I've mentioned a more severe impact:\n> \n> > An attacker can use this to multiplying his delegation power endlessly, by adding a delegation and removing it in the same block (using a contract to run those 2 functions in the same tx). The delegation will succeed but the removal will fail, this way each time this runs the user delegates again the same token.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/455)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/455#issuecomment-1236183555):**\n > Fixed.\n> Ref: https://github.com/golom-protocol/contracts/commit/74b2e718f6ae9da815b52242a44451527d60d1ae\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/455)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the VoteEscrowDelegation smart contract. The vulnerability occurs when a user delegates a tokenId and then calls the delegate function again in the same block to delegate the same tokenId to a different tokenId. This causes the array of delegatedTokenIds to be stored in memory instead of storage, thus not persisting the array and only persisting the first delegation. This can be mitigated by defining the oldCheckpoint variable as a storage pointer.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/455",
      "tags": [],
      "finders": [
        "0xpiglet",
        "IllIllI",
        "0xsanson",
        "scaraven",
        "async",
        "Dravee",
        "ElKu",
        "JohnSmith",
        "DimitarDimitrov",
        "ak1",
        "0xA5DF",
        "kenzo"
      ]
    },
    {
      "id": "8732",
      "title": "[H-06] NFT transferring won't work because of the external call to `removeDelegation`.",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L242><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211><br>\n\nThe `VoteEscrowDelegation._transferFrom` function won't work because it calls `this.removeDelegation(_tokenId)`. The `removeDelegation` function is external, so when the call is done by `this.removeDelegation(_tokenId)` msg.sender changes to the contract address.\n\nThis causes the check in the \\`\\` function to (most likely) fail because the contract is not the owner of the NFT, and that will make the function revert.<br>\n`require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');`\n\n### Recommended Mitigation Steps\n\nMake the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address).\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/377)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/377#issuecomment-1236183959):**\n > Fixed.\n> \n> Ref: https://github.com/golom-protocol/contracts/commit/10ec920765a5ee2afc2fe269d32ea9138d1156b6\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/377)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the `VoteEscrowDelegation._transferFrom` function in the `VoteEscrowDelegation.sol` file. The issue is caused by the `removeDelegation` function, which is external. When the call is done by `this.removeDelegation(_tokenId)`, the msg.sender changes to the contract address. This causes the check in the `` function to fail and the function reverts. The impact of this bug is that the `VoteEscrowDelegation._transferFrom` function won't work.\n\nThe bug was found manually using VS Code and the author's mind. The recommended mitigation step is to make the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address).",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/377",
      "tags": [],
      "finders": [
        "TrungOre",
        "Bahurum",
        "0xsanson",
        "CertoraInc",
        "GalloDaSballo",
        "cryptphi",
        "carlitox477",
        "0xA5DF",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8731",
      "title": "[H-05] `addFee` will stop accumulating fee once `rewardToken` has reached max supply",
      "impact": "HIGH",
      "content": "\n`RewardDistributor` will stop accumulating fees for staker rewards once `rewardToken` supply has reached the maximum supply (1 billion).\n\n### Vulnerability Details\n\n[RewardDistributor.sol#L98-L138](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138)\n\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n        \n        ...\n        \n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n    }\n\nThe check at the beginning of `addFee` is supposed to stop `RewardDistributor` from minting additional rewardToken once it has reached 1 billion supply. However, the current implementation has a side effect of causing the function to skip recording accumulated trading fees (the last 3 lines of the function). This will cause stakers to lose their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract.\n\n### Proof of Concept\n\n*   Alice staked `GOLOM` to receive fee rewards from `RewardDistributor`.\n*   `GOLOM` supply reaches 1 billion token.\n*   Traders keep trading on `GolomTrader`, sending protocol fees to `RewardDistributor`. However, `RewardDistributor.addFee` does not update the fee accounting.\n*   Alice won't receive any fee reward and protocol fees are stuck in the contract.\n\n### Recommended Mitigation Steps\n\nModify `addFee` so that the check won't skip accruing trade fees:\n\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n\n            if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n                emit NewEpoch(epoch, 0, 0, previousEpochFee);\n            } else {\n                uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                    rewardToken.totalSupply();\n                uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n                rewardStaker[epoch] = stakerReward;\n                rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n                rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n                rewardToken.mint(address(this), tokenToEmit);\n                epochBeginTime[epoch] = block.number;\n                if (previousEpochFee > 0) {\n                    if (epoch == 1){\n                        epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                        weth.deposit{value: address(this).balance}();  \n                    }else{\n                        weth.deposit{value: previousEpochFee}();\n                    }\n                }\n                emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n            }\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/320)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/320#issuecomment-1234338228):**\n > Resolved in https://github.com/golom-protocol/contracts/commit/192e152dde2eed6c01a3945aa5fd223ff786ca5e\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the RewardDistributor contract of the 2022-07-golom project. The vulnerability affects the function addFee, which is responsible for recording trading fees for staker rewards. The check at the beginning of the function is meant to stop RewardDistributor from minting additional rewardTokens once it has reached 1 billion supply, but it also causes the function to skip recording accumulated trading fees. This means that stakers will not receive their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract. \n\nA proof of concept is provided to demonstrate the issue. Alice stakes GOLOM to receive fee rewards from RewardDistributor. Once GOLOM supply reaches 1 billion token, traders keep trading on GolomTrader, sending protocol fees to RewardDistributor. However, RewardDistributor.addFee does not update the fee accounting, so Alice won't receive any fee reward and the protocol fees are stuck in the contract.\n\nThe recommended mitigation step is to modify addFee so that the check won't skip accruing trade fees. The modified code is provided, which should be implemented in order to fix the vulnerability.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/320",
      "tags": [],
      "finders": [
        "reassor",
        "0x52",
        "GiveMeTestEther",
        "rbserver",
        "rokinot",
        "scaraven",
        "Picodes",
        "M0ndoHEHE",
        "kaden",
        "berndartmueller",
        "Lambda",
        "shenwilly",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8730",
      "title": "[H-04] Old delegatee not deleted when delegating to new tokenId",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L80](https://github.com/code-423n4/2022-07-golom/blob/8f198624b97addbbe9602a451c908ea51bd3357c/contracts/vote-escrow/VoteEscrowDelegation.sol#L80)<br>\n\nIn `delegate`, when a user delegates to a new tokenId, the tokenId is not removed from the current delegatee. Therefore, one user can easily multiply his voting power, which makes the toking useless for voting / governance decisions.\n\n### Proof Of Concept\n\nBob owns the token with ID 1 with a current balance of 1000. He also owns tokens 2, 3, 4, 5. Therefore, he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, `delegate(1, 5)`. Now, if there is a governance decision and `getVotes` is called, Bobs balance of 1000 is included in token 2, 3, 4, and 5. Therefore, he quadrupled the voting power of token 1.\n\n### Recommended Mitigation Steps\n\nRemove the entry in `delegatedTokenIds` of the old delegatee or simply call `removeDelegation` first.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/169)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/169#issuecomment-1238345165):**\n > Fixed. \n> \n> Ref: https://github.com/golom-protocol/contracts/commit/c74d95b4105eeb878d2781982178db5ca08a1a9b\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the VoteEscrowDelegation.sol file on line 80 of the code. The vulnerability allows users to multiply their voting power, which makes the token useless for voting and governance decisions. This is done by calling the `delegate` function with different tokenIds. For example, Bob owns token 1 with a balance of 1000 and also owns tokens 2, 3, 4, and 5. If he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, and `delegate(1, 5)`, then when `getVotes` is called, Bob's balance of 1000 is included in tokens 2, 3, 4, and 5, thus quadrupling the voting power of token 1. To mitigate this vulnerability, the entry in `delegatedTokenIds` of the old delegatee should be removed or `removeDelegation` should be called first.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/169",
      "tags": [
        "Vote"
      ],
      "finders": [
        "0x52",
        "scaraven",
        "berndartmueller",
        "GiveMeTestEther",
        "arcoun",
        "Twpony",
        "0xDjango",
        "Lambda",
        "Green",
        "0xA5DF",
        "MEP",
        "kenzo",
        "Bahurum",
        "0xsanson",
        "cccz",
        "kyteg",
        "0xpiglet",
        "panprog",
        "GalloDaSballo",
        "rajatbeladiya",
        "dipp",
        "neumo",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8729",
      "title": "[H-03] GolomTrader's `_settleBalances` double counts protocol fee, reducing taker's payout for a NFT sold",
      "impact": "HIGH",
      "content": "\nCurrently `(o.totalAmt * 50) / 10000)` protocol fee share is multiplied by `amount` twice when being accounted for as a deduction from the total in amount due to the `msg.sender` taker calculations in \\_settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts.\n\nSetting the severity to be high as reduced payouts is a fund loss impact for taker, which receives less than it's due whenever `amount > 1`.\n\nNotice that the amount lost to the taker is left on the contract balance and currently is subject to other vulnerabilities, i.e. can be easily stolen by an attacker that knowns these specifics and tracks contract state. When these issues be fixed this amount to be permanently frozen on the GolomTrader's balance as it's unaccounted for in all subsequent calculations (i.e. all the transfers are done with regard to the accounts recorded, this extra sum is unaccounted, there is no general native funds rescue function, so when all other mechanics be fixed the impact will be permanent freeze of the part of taker's funds).\n\n### Proof of Concept\n\n\\_settleBalances() uses `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times:\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L389-L399>\n\n```solidity\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n```\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400>\n\n```solidity\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n```\n\nSay, if `amount = 6`, while `((o.totalAmt * 50) / 10000) = 1 ETH`, `6 ETH` is total `protocolfee` and needs to be removed from `o.totalAmt * 6` to calculate taker's part, while `1 ETH * 6 * 6 = 36 ETH` is actually removed in the calculation, i.e. `36 - 6 = 30 ETH` of taker's funds will be frozen on the contract balance.\n\n### Recommended Mitigation Steps\n\nConsider accounting for `amount` once, for example:\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L403>\n\n```solidity\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n-       uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n+       uint256 protocolfee = ((o.totalAmt * 50) / 10000);\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n-       payEther(protocolfee, address(distributor));\n+       payEther(protocolfee * amount, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n-       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n+       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee * amount);\n    }\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/240)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/240#issuecomment-1235391176):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR390\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the GolomTrader.sol code, which is part of the 2022-07-golom repository on Github. The bug causes the protocol fee share to be multiplied by the amount twice when being accounted for as a deduction from the total in amount due to the msg.sender taker calculations in _settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts. This results in the taker receiving less than they are due whenever the amount is greater than one. The severity of the bug is high due to the potential fund loss impact for taker.\n\nThe bug is caused by the code in _settleBalances() using `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times. This can be seen in the code snippet provided in the bug report. \n\nFor example, if the amount is 6, while the protocol fee is 1 ETH, 6 ETH is the total protocol fee and needs to be removed from o.totalAmt * 6 to calculate the taker's part, while 1 ETH * 6 * 6 = 36 ETH is actually removed in the calculation, meaning 30 ETH of the taker's funds will be frozen on the contract balance.\n\nThe bug report recommends mitigating the issue by accounting for the amount once. This can be done by changing the code in _settleBalances() to the code snippet provided in the bug report. This will ensure the protocol fee is multiplied by the amount only once, resulting in the taker receiving the correct amount.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/240",
      "tags": [],
      "finders": [
        "0x52",
        "rbserver",
        "auditor0517",
        "scaraven",
        "rotcivegaf",
        "Limbooo",
        "kaden",
        "ElKu",
        "Lambda",
        "0xSky",
        "zzzitron",
        "Krow10",
        "hyh",
        "obront",
        "wastewa",
        "RustyRabbit"
      ]
    },
    {
      "id": "8728",
      "title": "[H-02] `VoteEscrowDelegation._writeCheckpoint` fails when `nCheckpoints` is 0",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86><br>\n\nWhen a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. What’s worse, `nCheckpoints` would be zero before any delegation has been made. In conclusion, users cannot make any delegation.\n\n### Proof of Concept\n\nWhen a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`.<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86>\n\n        function delegate(uint256 tokenId, uint256 toTokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n            delegates[tokenId] = toTokenId;\n            uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n            if (nCheckpoints > 0) {\n                Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                checkpoint.delegatedTokenIds.push(tokenId);\n                _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n            } else {\n                uint256[] memory array = new uint256[](1);\n                array[0] = tokenId;\n                _writeCheckpoint(toTokenId, nCheckpoints, array);\n            }\n\n            emit DelegateChanged(tokenId, toTokenId, msg.sender);\n        }\n\nif `nCheckpoints` is 0, `_writeCheckpoint` always reverts.<br>\nBecause `checkpoints[toTokenId][nCheckpoints - 1]` will trigger underflow in Solidity 0.8.11<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101>\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n            Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            …\n        }\n\n### Recommended Mitigation Steps\n\nFix `_writeCheckpoint`\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n       \n\n            if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n                Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n            } else {\n                checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n                numCheckpoints[toTokenId] = nCheckpoints + 1;\n            }\n        }\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/630)**\n\n**[zeroexdead (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/630#issuecomment-1236185600):**\n > Fixed.\n> Ref: https://github.com/golom-protocol/contracts/commit/95e83a1abead683083b7ddf07853a26803c70b88\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding a vulnerability in the VoteEscrowDelegation.sol contract. The vulnerability occurs when a user calls the `VoteEscrowDelegation.delegate` function in order to make a delegation. This function calls `VoteEscrowDelegation._writeCheckpoint` which updates the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. This is because `checkpoints[toTokenId][nCheckpoints - 1]` will trigger an underflow in Solidity 0.8.11. This means that users cannot make any delegation, resulting in a denial of service.\n\nThe recommended mitigation step for this vulnerability is to fix `_writeCheckpoint` by adding an if statement that checks if `nCheckpoints` is greater than 0 and if the `oldCheckpoint.fromBlock` equals the current block number. If this is true, then the `oldCheckpoint.delegatedTokenIds` should be set to `_delegatedTokenIds`. If it is false, then a new checkpoint should be created with the `block.number` and `_delegatedTokenIds`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/630",
      "tags": [],
      "finders": [
        "0x52",
        "scaraven",
        "berndartmueller",
        "cryptphi",
        "arcoun",
        "Twpony",
        "Lambda",
        "0xA5DF",
        "MEP",
        "kenzo",
        "Bahurum",
        "simon135",
        "0xsanson",
        "kyteg",
        "0xSky",
        "hansfriese",
        "zzzitron",
        "panprog",
        "CertoraInc",
        "ElKu",
        "GalloDaSballo",
        "JohnSmith",
        "rajatbeladiya",
        "GimelSec"
      ]
    },
    {
      "id": "8727",
      "title": "[H-01] Owner can not set the `ve` address via `RewardDistributor.addVoteEscrow`",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173><br>\n\nOn the initial `RewardDistributor.addVoteEscrow` call, the owner of the contract can set the `ve` address without a timelock (which is as intended according to the function documentation). However, as the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized, hence `address(0)`) is used, the `ve` storage variable can not be set to the provided `_voteEscrow` address.\n\nThis prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.\n\n### Proof of Concept\n\n[RewardDistributor.sol#L300](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300)\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(pendingVoteEscrow); // @audit-info The wrong variable is used. It should be `_voteEscrow`\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\n[RewardDistributor.sol#L173](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173)\n\n```solidity\nfunction multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n    require(address(ve) != address(0), ' VE not added yet'); // @audit-info reverts if `ve` is not initialized\n\n    ...\n}\n```\n\n### Recommended Mitigation Steps\n\nUse the correct function parameter `_voteEscrow`:\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(_voteEscrow);\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/611)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/611#issuecomment-1234218994):**\n > Resolved by removing the manually added timelocks and setting the Vote escrow in constructor and a function to change voteescrow by owner\n> \n> https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-359fa403a6143105216e07c066e06ebb7ef2ba2d02f9d5465b042465d3f5bffbR297\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the RewardDistributor.sol code of the 2022-07-golom GitHub repository. The bug affects the `addVoteEscrow` function, which is intended to allow the owner of the contract to set the `ve` address without a timelock. However, the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized) is used. This prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.\n\nThe recommended mitigation step is to use the correct function parameter `_voteEscrow`:\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(_voteEscrow);\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\nThe bug was identified using manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/611",
      "tags": [],
      "finders": [
        "TrungOre",
        "panprog",
        "0x52",
        "0xsanson",
        "rbserver",
        "auditor0517",
        "CRYP70",
        "rajatbeladiya",
        "teddav",
        "berndartmueller",
        "hyh",
        "hansfriese",
        "0x1f8b",
        "Krow10",
        "0xA5DF",
        "GimelSec"
      ]
    },
    {
      "id": "42744",
      "title": "[N-10] NatSpec Is Missing",
      "impact": "LOW",
      "content": "\nNatSpec if missing for the following function\n\n*   `PuttyV2Nft._mint`  - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11>\n*   `PuttyV2Nft.transferFrom` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L21>\n*   `PuttyV2Nft.balanceOf` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L40>\n\n### Recommendation\n\nImplement NatSpec for all functions.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1178063479):**\n > High quality report.\n\n**[HickupHH3 commented](https://github.com/code-423n4/2022-06-putty-findings/issues/306#issuecomment-1186102954):**\n> > L-03 Insufficient Input Validation\n> \n> Disagree, I remember seeing there was a use case for having taker == maker discussed in 1 of the issues somewhere.\n> \n> > L-04 Order Cannot Be Filled Due To Unbounded Whitelist Within An Order\n> \n> Sort a duplicate of #290.\n> \n> Agree that overall it is a very good report! \n\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42743",
      "title": "[N-09] Incorrect functions visibility",
      "impact": "LOW",
      "content": "\nWhenever a function is not being called internally in the code, it can be easily declared as `external`, [saving also gas](https://github.com/crytic/slither/wiki/Detector-Documentation#description-44). While the entire code base have explicit visibilities for every function, some of them can be changed to be `external`.\n\nFollowing are some the functions that can be changed to be `external`\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\n### Recommendation\n\nReview the visibility of the affected functions and change visibility of these functions to `external`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42742",
      "title": "[N-08] Unused imports",
      "impact": "LOW",
      "content": "\nTo improve readability and avoid confusion, consider removing the following unused imports:\n\nIn the `PuttyV2Nft` contract:\n\n*   openzeppelin/utils/Strings.sol\n\nNote that the `Strings.sol` has already been imported in `PuttyV2` contract. Thus, this import can be safely removed.\n\nWithin the `PuttyV2Nft` contract, it does not use any of the functions from `Strings.sol`.\n\n### Recommendation\n\nConsider removing the unused import if it is not required.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42741",
      "title": "[N-07] Inconsistent use of named return variables",
      "impact": "LOW",
      "content": "\nThere is an inconsistent use of named return variables in the `PuttyV2` contract\n\nSome functions return named variables, others return explicit values.\n\nFollowing function return explicit value\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\nFollowing function return return a named variable\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L683>\n\n```solidity\nfunction hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n    // use decode/encode to get a copy instead of reference\n    Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n    // get the opposite side of the order (short/long)\n    oppositeOrder.isLong = !order.isLong;\n    orderHash = hashOrder(oppositeOrder);\n}\n```\n\n### Recommendation\n\nConsider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42740",
      "title": "[N-06] Code Can Be Refactored To Be More Readable",
      "impact": "LOW",
      "content": "\nIn many parts of the `PuttyV2` contract, it uses the following conditions to check the type of the order being passed into the function:\n\n*   order.isLong && order.isCall (equal to long call)\n*   order.isLong && !order.isCall (equal to long put)\n*   order.!isLong && order.isCall (equal to short call)\n*   order.!isLong && order.!isCall (equal to short put)\n\nThese affect the readability of the codes as the readers have to interpret the condition to determine if it is a \"long call\", \"long put\", \"short call\" or \"short put\". This might increase the risk of mistakes in the future if new developer works on the contracts.\n\n### Recommendation\n\nConsider implementing the following functions to improve readability:\n\n*   isLongCall(Order order) public view returns (bool)\n*   isLongPut(Order order) public view returns (bool)\n*   isShortCall(Order order) public view returns (bool)\n*   isShortPut(Order order) public view returns (bool)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42739",
      "title": "[N-05] Consider two-phase ownership transfer",
      "impact": "LOW",
      "content": "\nAdmin calls `Ownable.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nConsider implementing a two step process where the admin nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42738",
      "title": "[N-04] Owner Can Renounce Ownership",
      "impact": "LOW",
      "content": "\nTypically, the contract’s owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities.\n\nThe Openzeppelin's `Ownable` used in `PuttyV2` contract implements `renounceOwnership`. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L53>\n\n```solidity\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n```\n\n### Recommendation\n\nWe recommend to either reimplement the function to disable it or to clearly specify if it is part of the contract design\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42737",
      "title": "[N-03] Insufficient Tests",
      "impact": "LOW",
      "content": "\nIt is crucial to write tests with possibly 100% coverage for smart contract systems.\n\nThe following functions were found to be not included in the test cases:\n\n*   `PuttyV2.batchFillOrder` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L546>\n*   `PuttyV2.acceptCounterOffer` - <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573>\n\n### Recommendation\n\nIt is recommended to write proper tests for all possible code flows and specially edge cases\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42736",
      "title": "[N-02] Draft OpenZeppelin Dependencies",
      "impact": "LOW",
      "content": "\nThe `PuttyV2` contract utilised `draft-EIP712` , an OpenZeppelin contract. This contract is still a draft and is not considered ready for mainnet use. OpenZeppelin contracts may be considered draft contracts if they have not received adequate security auditing or are liable to change with future development.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L40>\n\n```solidity\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\n```\n\n### Recommendation\n\nEnsure the development team is aware of the risks of using a draft contract or consider waiting until the contract is finalised.\n\nOtherwise, make sure that development team are aware of the risks of using a draft OpenZeppelin contract and accept the risk-benefit trade-off.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42735",
      "title": "[N-01] Omissions in events",
      "impact": "LOW",
      "content": "\nThroughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, some events are missing important parameters\n\n#### Instance #1 - Missing Old Value\n\nWhen setting a new `baseURI` and `fee`, only the new value is emitted within the event.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L228>\n\n```solidity\nfunction setBaseURI(string memory _baseURI) public payable onlyOwner {\n    baseURI = _baseURI;\n    emit NewBaseURI(_baseURI);\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n```solidity\nfunction setFee(uint256 _fee) public payable onlyOwner {\n    require(_fee < 30, \"fee must be less than 3%\");\n    fee = _fee;\n    emit NewFee(_fee);\n}\n```\n\nThe events should include the new value and old value where possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42734",
      "title": "[M-11] `fee` can change without the consent of users",
      "impact": "MEDIUM",
      "content": "_Submitted by Picodes, also found by 0xNineDec, 0xsanson, antonttc, berndartmueller, BowTiedWardens, catchup, dirk_y, Alex the Entreprenerd, horsefacts, Metatron, sseefried, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497>\n\n### Impact\n\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n### Proof of Concept\n\nThe scenario would be:\n\n*   Alice and Bob agrees to fill an order at a time fees are 0.1%\n*   During the duration of the option, fees are increased to 3%\n*   At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n### Recommended Mitigation Steps\n\nMitigation could be:\n\n*   Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n*   Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n*   Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1178988085):**\n > Report: Admin can change fee at any time for existing orders.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/422#issuecomment-1185414532):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with the PuttyV2 smart contract, where fees can be changed after an order is filled and before it is withdrawn. This can result in a loss of expected funds for users. A proof of concept scenario is provided, along with recommended mitigation steps such as storing fees in the order and adding a timestamp. The issue has been confirmed and resolved by the Putty Finance team, with a fix implemented in a pull request. A warden has also reviewed and approved the proposed mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": []
    },
    {
      "id": "42733",
      "title": "[M-08] Overlap Between `ERC721.transferFrom()` and `ERC20.transferFrom()` Allows `order.erc20Assets` or `order.baseAsset` To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by reassor and sseefried_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601>\n\n### Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n### Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/52#issuecomment-1179004318):**\n > Report: If an ERC721 token is used in places where ERC20 assets are supposed to be used then ERC721 tokens can get stuck in withdraw() and exercise().\n\n**hyh (warden) reviewed mitigation:**\n > Requires asset whitelisting, now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThe bug report highlights an issue with two functions in the PuttyV2.sol contract, which have the same function signature. This means that it is possible for ERC721 tokens to be used in places where ERC20 tokens are supposed to be used. As a result, these ERC721 tokens can get stuck in the contract and cannot be transferred out. The report recommends implementing a whitelist for approved ERC20 and ERC721 token contracts to prevent this issue. The team behind Putty Finance has acknowledged and addressed this issue on the user interface and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": []
    },
    {
      "id": "42732",
      "title": "[M-05] `fillOrder()` and `exercise()` may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0x29A, 0xc0ffEE, 0xDjango, AmitN, auditor0517, berndartmueller, BowTiedWardens, cccz, danb, dipp, dirk_y, hansfriese, horsefacts, hyh, joestakey, kirk-baird, oyc_109, peritoflores, rfa, sashik_eth, simon135, sseefried, StErMi, swit, xiaoming90, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n### Impact\n\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n### Proof of Concept\n\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325>\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339>\n\nSame for the exercise of call options:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n### Recommended Mitigation Steps\n\nAdd a `require(0 == msg.value)` for the above three conditions.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174516212):**\n > Why would the caller send ETH when they don't have to?\n\n**[sseefried (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1174603678):**\n > User error is one possibility. \n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1179001561):**\n > Report: Native ETH can be lost if it’s not utilised in exercise and fillOrder.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/226#issuecomment-1185413512):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/5.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed with native funds amount control added to strike transfer logic of `fillOrder`. Zero strike and zero premium corner cases are yet unhandled as described in [M.M-01](#mm-01-weth-zero-strike-call-fillorders-msgvalue-will-be-lost) and [M.M-02](#mm-02-zero-premium-short-fillorders-msgvalue-will-be-lost) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by multiple users and found in the PuttyV2.sol contract code. The issue is that the `fillOrder()` and `exercise()` functions can receive Ether even though there are code paths where it is not needed. This means that the Ether sent to these functions will be locked in the contract forever and the sender will not receive anything in return. A proof of concept was provided to show how this can happen. The recommended mitigation steps include adding a `require(0 == msg.value)` for certain conditions in the code. The developers of Putty Finance have confirmed and resolved the issue with a pull request. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": []
    },
    {
      "id": "42731",
      "title": "[M-02] Unbounded loops may cause `exercise()`s and `withdraw()`s to fail",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, sashik_eth, shung, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Impact\n\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n### Proof of Concept\n\nThere are no upper bounds on the number of assets being transferred in these loops:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650>\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661>\n\n### Recommended Mitigation Steps\n\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1177670801):**\n > Adding a hardcoded check at the contract level is not a viable fix given that gas costs and limits are subject change over time.\n> Instead, there already exists a limit of 30 assets on the frontend/db level.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179001005):**\n > Report: Unbounded loop can prevent put option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/227#issuecomment-1179845396):**\n > Medium severity is justified because, while very unlikely to happen, there could be a loss of assets.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report was submitted by several people and found in the PuttyV2.sol contract. The bug allows for an unlimited number of tokens to be transferred in an order, which can cause issues with gas requirements and potentially make orders unexercisable or unwithdrawable. The proof of concept shows that there are no upper limits on the number of assets that can be transferred in certain loops in the code. The recommended mitigation steps include implementing an upper bound on the number of assets or allowing them to be transferred out one at a time. The team behind Putty Finance has acknowledged the issue but disagrees with the severity and has implemented a limit of 30 assets on the frontend and database level. The judge has deemed the bug to have a medium severity as there is a potential for loss of assets, although it is unlikely to occur. The warden has reviewed the mitigation steps and believes it has been addressed on the UI and database level. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": []
    },
    {
      "id": "42730",
      "title": "[H-02] `acceptCounterOffer()` May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "_Submitted by kirk-baird, also found by csanuragjain, hansfriese, Lambda, and minhquanym_\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n### Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n### Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1179004913):**\n > Report: It’s possible to fill an order twice by accepting a counter offer for an already filled order.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1185411950):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/2.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring that order can't be in the filled state on cancel. This fully adheres to the original logic, but wasn't controlled for before.\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the code for Putty Finance, a platform for trading digital assets. The bug allows an attacker to fill an order twice by accepting a counter offer for an already filled order. This results in both orders being filled and the person making the transaction being twice as leveraged as intended. The impact of this bug is that it can cause financial loss for users. The report suggests a mitigation step to fix the bug, which involves adding a line of code to prevent the order from being filled if it has already been filled. The bug has been confirmed and resolved by the team at Putty Finance. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "5015",
      "title": "[L-07] No Check if onERC721Received Is Implemented",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` will mint a long position NFT and short position NFT to the order maker and taker. When minting a NFT, the function does not check if a receiving contract implements onERC721Received().\n\nThe intention behind this function is to check if the address receiving the NFT, if it is a contract, implements onERC721Received(). Thus, there is no check whether the receiving address supports ERC-721 tokens and position could be not transferrable in some cases.\n\nFollowing shows that `_mint` is used instead of `_safeMint`.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L303>\n\n```solidity\nfunction fillOrder(\n\tOrder memory order,\n\tbytes calldata signature,\n\tuint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) {\n\t..SNIP..\n\t// create long/short position for maker\n\t_mint(order.maker, uint256(orderHash));\n\n\t// create opposite long/short position for taker\n\tbytes32 oppositeOrderHash = hashOppositeOrder(order);\n\tpositionId = uint256(oppositeOrderHash);\n\t_mint(msg.sender, positionId);\n\t..SNIP..\n```\n\n### Recommendation\n\nConsider using [`_safeMint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L193) instead of [`_mint`](https://github.com/Rari-Capital/solmate/blob/3c738133a0c1697096d63d28ef7a8ef298f9af6b/src/tokens/ERC721.sol#L157).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-07-no-check-if-onerc721received-is-implemented",
      "tags": [],
      "finders": []
    },
    {
      "id": "5014",
      "title": "[L-06] Order Can Be Cancelled Even After Being Filled",
      "impact": "LOW",
      "content": "\nOnce an order has been filled, no one should be able to cancel the order or mark the order as `Cancelled`.\n\nThe following code shows that the order maker can change the status of the order to `Cancelled` at any point of time.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526>\n\n```solidity\n/**\n    @notice Cancels an order which prevents it from being filled in the future.\n    @param order The order to cancel.\n */\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\nAlthough changing the status of an order to `Cancelled` after it has been filled does not cause any lost of funds at the later stages (e.g. when exercising or withdrawing), it might cause unnecessary confusion to the users as it does not accurately reflect the status of an order on-chain.\n\nUsers might fetch the status of an order directly from the `cancelledOrders` mapping or poll the on-chain for emitted event, and come to a wrong conclusion that since the order has been cancelled, it has not been filled.\n\n### Recommendation\n\nIt is recommended to update the `cancel` function to only allow order maker to call this function only if an order has not been filled.\n\n```solidity\nfunction cancel(Order memory order) public {\n    require(msg.sender == order.maker, \"Not your order\");\n\n    bytes32 orderHash = hashOrder(order);\n    \n    // If an order has been filled, the positionExpirations[orderHash] will be populated.\n    require(positionExpirations[orderHash] == 0, \"Order has already been filled. Cannot cancel.\")\n\n    // mark the order as cancelled\n    cancelledOrders[orderHash] = true;\n\n    emit CancelledOrder(orderHash, order);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-06-order-can-be-cancelled-even-after-being-filled",
      "tags": [],
      "finders": []
    },
    {
      "id": "5013",
      "title": "[L-05] Order Cannot Be Filled Due To Unbounded floorTokens, ERC20Asset Or ERC721Asset Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of tokens within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempts to loop through all the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order to transfer the required assets to `PuttyV2` contract from the order maker or taker.\n\nThe [`_transferERC20sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593), [`_transferERC721sIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L610), [`_transferFloorsIn`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L622) attempt to loop through all the tokens within the array. However, if array contains large number of tokens, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\nFollowing is an example of the vulnerable function.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593>\n\n```solidity\nfunction _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n    for (uint256 i = 0; i < assets.length; i++) {\n        address token = assets[i].token;\n        uint256 tokenAmount = assets[i].tokenAmount;\n\n        require(token.code.length > 0, \"ERC20: Token is not contract\");\n        require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n        ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n    }\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of tokens  within the `floorTokens`, `ERC20Asset` or `ERC721Asset` arrays of an order. (e.g. Maximum of 10 tokens)\n\nAlthough client-side or off-chain might have already verified that the number of tokens do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-05-order-cannot-be-filled-due-to-unbounded-floortokens-erc20asset-or-erc721asset-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5012",
      "title": "[L-04] Order Cannot Be Filled Due To Unbounded Whitelist Within An Order",
      "impact": "LOW",
      "content": "\nAn order can contain large number of addresses within the `whitelist` array of an order.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L78>\n\n```solidity\nstruct Order {\n    address maker;\n    bool isCall;\n    bool isLong;\n    address baseAsset;\n    uint256 strike;\n    uint256 premium;\n    uint256 duration;\n    uint256 expiration;\n    uint256 nonce;\n    address[] whitelist;\n    address[] floorTokens;\n    ERC20Asset[] erc20Assets;\n    ERC721Asset[] erc721Assets;\n}\n```\n\nWhen the `PuttyV2.fillOrder` function is called, it will attempt to check if the caller is whitelisted by looping through the `order.whitelist` array. However, if `order.whitelist` array contains large number of addresses, it will result in out-of-gas error and cause a revert. Thus, this order can never be filled.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L284>\n\n```solidity\nfunction fillOrder(\n    Order memory order,\n    bytes calldata signature,\n    uint256[] memory floorAssetTokenIds\n) public payable returns (uint256 positionId) { // @audit-issue no re-entrancy guard\n\t..SNIP..\n    // check msg.sender is allowed to fill the order\n    require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\t..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L669>\n\n```solidity\nfunction isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n    for (uint256 i = 0; i < whitelist.length; i++) {\n        if (target == whitelist[i]) return true;\n    }\n\n    return false;\n}\n```\n\n### Recommendation\n\nIt is recommended to restrict the number of whitelisted addresses within an order to a upper limit (e.g. 30).\n\nAlthough client-side or off-chain might have already verified that the number of whitelisted addresses do not exceed a certain limit within an order, simply relying on client-side and off-chain validations are not sufficient. It is possible for an attacker to bypass the client-side and off-chain validations and interact directly with the contract. Thus, such validation must also be implemented on the on-chain contracts.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-04-order-cannot-be-filled-due-to-unbounded-whitelist-within-an-order",
      "tags": [],
      "finders": []
    },
    {
      "id": "5011",
      "title": "[L-03] Insufficient Input Validation",
      "impact": "LOW",
      "content": "\nThe `PuttyV2.fillOrder` function does not validate that the `msg.sender` (order taker) is the same as the order maker, which might potentially lead to unwanted behaviour within the system. Order taker should not be the same as order maker under any circumstances.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L268>\n\n```solidity\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n```\n\n### Recommendation\n\nImplement the necessary check to ensure that order taker is not the same as order maker.\n\n```solidity\nrequire(msg.sender != order.maker, \"Invalid order taker\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-03-insufficient-input-validation",
      "tags": [],
      "finders": []
    },
    {
      "id": "5010",
      "title": "[L-02] Discontinuity in Exercise Period",
      "impact": "LOW",
      "content": "\nThe position can be exercised if current block timestamp is less than the position's expiration.\n\nThe position can be withdrawed if current block timestamp is greater than the position's expiration\n\nHowever, when current block timestamp is equal to the position's expiration (`block.timestamp == positionExpirations`), the state is unknown (cannot be exercised or withdraw)\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L401>\n\n```solidity\nfunction exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n    ..SNIP..\n    // check position has not expired\n    require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n    ..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L481>\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n### Recommendation\n\nAllow the user to withdraw the position upon expiration.\n\n```solidity\nfunction withdraw(Order memory order) public {\n    ..SNIP..\n    // check long position has either been exercised or is expired\n    require(block.timestamp >= positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n    ..SNIP..\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-02-discontinuity-in-exercise-period",
      "tags": [],
      "finders": []
    },
    {
      "id": "5009",
      "title": "[L-01] Lack Of Reentrancy Guards On External Functions",
      "impact": "LOW",
      "content": "\nThe following external functions within the `PuttyV2` contract contain function calls (e.g.  `safeTransferFrom`, `safeTransfer`) that pass control to external contracts. Additionally, if ERC777 tokens are being used within an order, it contains various hooks that will pass the execution control to the external party.\n\nThus, it might allow an malicious external contract to re-enter to the contract.\n\n*   `PuttyV2.fillorder`\n*   `PuttyV2.exercise`\n*   `PuttyV2.withdraw`\n*   `PuttyV2.batchFillOrder`\n*   `Putty.acceptCounterOffer`\n\nNo re-entrancy attacks that could lead to loss of assets were observed during the assessment. Thus, this issue is marked as Low.\n\nThe following shows examples of function call being made to an external contract\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Recommendation\n\nIt is recommended to follow the good security practices and apply necessary reentrancy prevention by utilizing the nonReentrant modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "#l-01-lack-of-reentrancy-guards-on-external-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "2949",
      "title": "[M-16] Use of Solidity version 0.8.13 which has two known issues applicable to PuttyV2",
      "impact": "MEDIUM",
      "content": "_Submitted by hubble, also found by horsefacts_\n\nThe solidity version 0.8.13 has below two issues applicable to PuttyV2\n\n1.  Vulnerability related to ABI-encoding.\n\n    ref : <https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/><br>\n    This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions.<br>\n    \"...pass a nested array directly to another external function call or use abi.encode on it.\"\n\n2.  Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly'\n\n    ref : <https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/><br>\n    PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.\n\n### Recommended Mitigation Steps\n\nUse recent Solidity version 0.8.15 which has the fix for these issues.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1176607284):**\n > Great catch.\n\n > Report: Use of Solidity 0.8.13 with known issues in ABI encoding and memory side effects.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/348#issuecomment-1185414140):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/6.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by bumping the solidity version.\n\n***\n\n",
      "summary": "\nThis bug report is about two vulnerabilities related to the Solidity version 0.8.13 used by the PuttyV2 contract. The first vulnerability is related to ABI-encoding and it can be misused if certain conditions are met. The second vulnerability is related to an optimizer bug regarding memory side effects of inline assembly. Both of these issues are addressed in the recent Solidity version 0.8.15. Therefore, the recommended mitigation step is to upgrade to the latest version of Solidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/348",
      "tags": [],
      "finders": [
        "horsefacts",
        "hubble"
      ]
    },
    {
      "id": "2948",
      "title": "[M-15] Zero strike call options will avoid paying system fee",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by csanuragjain, minhquanym, and Treasure-Seeker_\n\nZero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.\n\nAlso, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.\n\nMarking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.\n\n### Proof of Concept\n\nCurrently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506>\n\n```solidity\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.\n\ni.e. consider moving fee gathering to fillOrder:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340>\n\n```solidity\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1174511995):**\n > Zero strike will indeed have a fee of 0.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1178994046):**\n > Report: Charging fees on the strike amount instead of the premium amount can lead to disproportionate fees.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/373#issuecomment-1185414345):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nA bug has been discovered in the code for a derivative type called zero and near zero strike calls. The fee for these derivatives is formulated as a fraction of the order strike. This can be a problem for out-of-the-money (OTM) call options, where the option is nearly worthless but the fee is substantial due to the large strike. This design issue could turn off or distort the core system fee gathering, making it a medium severity vulnerability.\n\nProof of concept code shows that the fee is linked to the order strike, which varies heavily for different types of orders. For example, deep in-the-money (ITM) and OTM calls.\n\nThe recommended mitigation step is to link the fee to the option premium, which is the option value that cannot be easily manipulated and corresponds to the trading volume of the system. This can be done by moving the fee gathering to the fillOrder section of the code. This will convert ETH to WETH instead of forwarding native ETH to the maker, which has two benefits: 1) active market makers will mostly be using WETH not native ETH and 2) attack surface for re-entrancy is reduced.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/373",
      "tags": [],
      "finders": [
        "csanuragjain",
        "hyh",
        "Treasure-Seeker",
        "minhquanym"
      ]
    },
    {
      "id": "2947",
      "title": "[M-14] Order cancellation is prone to frontrunning and is dependent on a centralized database",
      "impact": "MEDIUM",
      "content": "_Submitted by shung, also found by unforgiven_\n\nOrder cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.\n\nThis first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.\n\nThe second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.\n\n### Proof of Concept\n\n1.  Bob signs an order which gets recorded in Putty servers.\n2.  Alice mirrors all the orders using Putty APIs.\n3.  Putty servers go offline.\n4.  Bob wants to cancel his order because changing token prices makes his order less favourable to him.\n5.  Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used.\n6.  Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.\n\n### Recommended Mitigation Steps\n\nAside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a \"minimum valid nonce\" state variable, as a mapping from user address to nonce.\n\n```solidity\nmapping(address => uint256) minimumValidNonce;\n```\n\nAllow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.\n\nAnother method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).\n\nEither of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1177567080):**\n > Should this be tagged as Med or Low? Funds are not directly at risk unless the centralised order book server goes down and loses all the data. Perhaps there is a non-negligible chance that this *could* happen. But even then, orders have an \"expiration\" field attached to them which will render them useless after some set time period. There are also easy fixes on the frontend, such as allowing users to download a txt file with their order/orderHash so that they don't have to rely on the centralised DB for data availability. \n> \n> But will defer to judges.\n>\n> Report: Cannot cancel orders without reliance on centralised database.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1184059122):**\n > The sponsor's point is valid: there is an expiration param that the maker signs as part of the order that marks its validity.\n> \n> However, the warden(s) concerns are valid too. While it is an edge case that is very unlikely to happen, there would arguably be a \"loss\" of assets of the maker because of the protocol's loss of functionality, as per the scenario described above. Hence, the medium severity rating is justified.\n> \n> I recommend implementing the warden's recommended fix; having a `minimumValidNonce` would be great in allowing easy on-chain cancellation of an order. It makes the system a little more trust-less and provides a \"red button\" option for makers to use if necessary.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/186#issuecomment-1185428778):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/10.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by the introduction of `setMinimumValidNonce` function and the corresponding control on order filling. See [M.M-04](#mm-04-minimumvalidnonce-can-be-reduced-due-to-an-operational-mistake-enabling-old-orders) in the Mitigation Review below.\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability of the PuttyV2.sol contract, which is used in decentralized exchanges. The vulnerability allows malicious parties to frontrun order cancellations and fill the order with favourable terms for themselves. This is possible because the only cancellation method requires makers to call `cancel()`, inputting the order as a function parameter. Since orders are signed off-chain and stored in a centralized database, it is likely that end users do not locally record all the orders they make. If the centralized service goes offline, it could allow malicious parties to fill orders that would have been cancelled otherwise.\n\nTo mitigate this vulnerability, the report recommends two methods. The first one is to have an extra method to cancel all orders of a caller, which can be achieved using a \"minimum valid nonce\" state variable. The second method is to use counters, which would require makers to increment the counter state variable by one to cancel all their orders. Either of these methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/186",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "shung",
        "unforgiven"
      ]
    },
    {
      "id": "2946",
      "title": "[M-13] Order duration can be set to 0 by Malicious maker",
      "impact": "MEDIUM",
      "content": "_Submitted by codexploder, also found by ACai, cccz, Critical, horsefacts, ignacio, shenwilly, unforgiven, and xiaoming90_\n\nA malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction\n\n### Proof of Concept\n\n1. Maker creates an order with zero Order duration\n2. Taker fills this order but the order instantly expires since duration was 0\n3. Taker gets the only option to withdraw with fees on strike price\n\n### Recommended Mitigation Steps\n\nEnforce at least x days of duration.\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/107#issuecomment-1185407029):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/7.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by requiring the minimal order duration of 15 minutes on filling.\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious maker who can set a minimum order duration as 0, allowing the order to instantly expire after it is filled. This means that the taker will only have the option to withdraw with fees on the strike price, thus forcing them to lose money in a meaningless transaction. To fix this issue, the recommended mitigation step is to enforce at least a certain number of days of duration. This bug report provides a proof of concept to demonstrate the vulnerability, and the recommended mitigation step to fix it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/107",
      "tags": [],
      "finders": [
        "codexploder",
        "cccz",
        "xiaoming90",
        "shenwilly",
        "ACai",
        "ignacio",
        "unforgiven",
        "Critical",
        "horsefacts"
      ]
    },
    {
      "id": "2945",
      "title": "[M-12] Options with a small strike price will round down to 0 and can prevent assets to be withdrawn",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by auditor0517, hansfriese, IllIllI, Lambda, sashik_eth, shenwilly, and TrungOre_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500>\n\n### Impact\n\nCertain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.\n\n### Proof of Concept\n\n[PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens\n}\n```\n\nSome ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.\n\nSee [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)\n\n**Example:**\n\n*   `order.baseAsset` is one of those weird ERC-20 tokens\n*   `order.strike = 999` (depending on the token decimals, a very small option position)\n*   `fee = 1` (0.1%)\n\n((999 &ast; 1) / 1000 = 0.999) rounded down to 0 -> zero-value transfer reverting transaction\n\n### Recommended Mitigation Steps\n\nAdd a simple check for zero-value token transfers:\n\n```solidity\n// send the fee to the admin/DAO if fee is greater than 0%\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n\n    if (feeAmount > 0) {\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n    }\n}\n```\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1178998816):**\n > Report: withdraw() can be DOS’d for baseAsset ERC20s that prevent 0 transfers if the calculated feeAmount is 0 due to rounding.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/283#issuecomment-1185413905):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed along with [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269) in [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a contract called PuttyV2.sol, which is located on a GitHub repository. This vulnerability can lead to assets and the strike not being able to be withdrawn and remaining locked in the contract. The cause of this vulnerability is that certain ERC-20 tokens do not support zero-value token transfers and revert. If a token with this feature is used as a `order.baseAsset` for a rather small option strike and a low protocol fee rate, it can lead to rounding down to 0 and prevent asset withdrawals for those positions. It is recommended to add a check for zero-value token transfers to fix this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/283",
      "tags": [],
      "finders": [
        "IllIllI",
        "auditor0517",
        "berndartmueller",
        "Lambda",
        "shenwilly",
        "hansfriese",
        "sashiketh",
        "TrungOre_"
      ]
    },
    {
      "id": "2944",
      "title": "[M-11] fee can change without the consent of users",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240\n https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497\n\n\n## Vulnerability details\n\n## Impact\nFees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.\n\n## Proof of Concept\nThe scenario would be:\n\n - Alice and Bob agrees to fill an order at a time fees are 0.1%\n - During the duration of the option, fees are increased to 3%\n - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees\n\n\n## Recommended Mitigation Steps\nMitigation could be:\n - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct\n - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup\n - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal",
      "summary": "\nThis bug report is related to a vulnerability in the code of the PuttyV2.sol contract. The vulnerability can lead to users losing expected funds due to fees changing between the time the order is filled and the time of withdrawal. This can occur when Alice and Bob agree to fill an order at a time when fees are 0.1%, but then during the duration of the option fees are increased to 3%. When they withdraw, they will have to pay 3% of the strike, even though they would not have created the order with such fees. \n\nRecommended mitigation steps include storing the fees in the Order and verifying that they are correct when the order is filled, adding a timestamp, and keeping past fees and fee change timestamps in memory to be able to retrieve the creation time fees at withdrawal.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/422",
      "tags": [],
      "finders": [
        "0xsanson",
        "BowTiedWardens",
        "Metatron",
        "Picodes",
        "unforgiven_",
        "berndartmueller",
        "dirky",
        "antonttc",
        "Alex the Entreprenerd",
        "catchup",
        "horsefacts",
        "0xNineDec",
        "sseefried"
      ]
    },
    {
      "id": "2943",
      "title": "[M-10] Putty position tokens may be minted to non ERC721 receivers",
      "impact": "MEDIUM",
      "content": "_Submitted by horsefacts, also found by 0xc0ffEE, 0xsanson, berndartmueller, BowTiedWardens, csanuragjain, defsec, IllIllI, joestakey, Kenshin, Picodes, shenwilly, Sm4rty, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18>\n\n### Vulnerability Details\n\nPutty uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers:\n\n[`PuttyV2#fillOrder`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L302-L308)\n\n```solidity\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n```\n\n[`PuttyV2Nft#_mint`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2Nft.sol#L11-L18)\n\n```solidity\n    function _mint(address to, uint256 id) internal override {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n```\n\n### Impact\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\n### Recommendation\n\nConsider implementing the `require` check in Solmate's `ERC721#_safeMint` in your own mint function:\n\n```solidity\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n```\n\nHowever, note that calling `_safeMint` introduces a reentrancy opportunity! If you make this change, ensure that the mint is treated as an interaction rather than an effect, and consider adding a reentrancy guard:\n\n```solidity\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        _safeMint(order.maker, uint256(orderHash));\n        _safeMint(msg.sender, positionId);\n```\n\nAlternatively, document the design decision to use `_mint` and the associated risk for end users.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1176613220):**\n> It's unlikely a contract will have all the setup required to interact with PuttyV2 but not be able to handle ERC721 tokens. Adding a check via safeMint adds a gas overhead as well as another re-entrancy attack vector so there is a tradeoff (as noted in the issue report^^).\n\n> Report: Contracts that can’t handle ERC721 tokens will lose their Putty ERC721 position tokens.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/327#issuecomment-1183141452):**\n > In addition, some contracts may have custom logic in their `onERC721Received()` implementation that is triggered only by the safe methods and not their \"unsafe\" counterparts.\n\n***\n\n",
      "summary": "\nThis bug report is about the Putty codebase, which uses ERC721 `safeTransfer` and `safeTransferFrom` throughout the codebase to ensure that ERC721 tokens are not transferred to non ERC721 receivers. However, the initial position mint in `fillOrder` uses `_mint` rather than `_safeMint` and does not check that the receiver accepts ERC721 token transfers.\n\nIf a maker or taker are a contract unable to receive ERC721 tokens, their options positions may be locked and nontransferable. If the receiving contract does not provide a mechanism for interacting with Putty, they will be unable to exercise their position or withdraw assets.\n\nTo fix this issue, it is recommended to implement the `require` check in Solmate's `ERC721#_safeMint` in the mint function. However, note that calling `_safeMint` introduces a reentrancy opportunity and the mint should be treated as an interaction rather than an effect, and consider adding a reentrancy guard. Alternatively, document the design decision to use `_mint` and the associated risk for end users.",
      "quality_score": 2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/327",
      "tags": [
        "mint vs safeMint"
      ],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "0xsanson",
        "BowTiedWardens",
        "Picodes",
        "joestakey",
        "xiaoming90",
        "berndartmueller",
        "shenwilly",
        "0xc0ffEE",
        "unforgiven",
        "Kenshin",
        "horsefacts",
        "Sm4rty",
        "defsec"
      ]
    },
    {
      "id": "2942",
      "title": "[M-09] The contract serves as a flashloan pool without fee",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xc0ffEE, also found by horsefacts, pedroais, and unforgiven_\n\nThe malicious user could leverage PuttyV2 contract to flashloan without paying fee the assets to make profit.\n\nConsider a scenario that maker and taker is the same, and is a contract\n\n1.  The contract call PuttyV2.`fillOrder` with a Long Call order that has `order.baseAssets` references to a contract having custom logic other than standard ERC20. The order also specify `erc20Assets` to the `token` and `tokenAmount` that PuttyV2 contract is owing (similar to `erc721Assets`)\n2.  When the execution is at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>, the custom logic could execute on the contract address `order.baseAsset`.\n3.  The malicious contract then call `exercise` to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in `_transferERC20sOut, _transferERC721sOut`\n4.  The contract uses that assets to make profit on other platforms. After that, the execution continues at <https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324>.\n5.  At the end of `fillOrder`, the contract just transfers enough assets back to PuttyV2 by executing logics in `_transferERC20sIn, _transferERC721sIn` to finish the execution.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174509620):**\n> Warden is saying that they can flashloan without fee, but any exercised option will pay a 3% fee, additionally the order of operations shown (gain control on base.asset.transfer when receiving premium), would mean that the order ERC20s and NFTs have yet to be transferred in, so a \"mid-fillOrder\" \"exercise\" would not only pay the fee, but also revert due to lack of the tokens.\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1174999561):**\n> The 3% will be paid in the fake asset since base asset is an attacker contract so there is no fee to perform the attack. \n> \n> This attack is done with assets that are already inside the contract so there is no revert in transfer out.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175061981):**\n > Acknowledging that technically this is true.\n> Although no easy mitigation exists as far as I can see aside from adding nonReentrant to exercise and fillOrder - adding a non-negligible gas overhead.\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1175108315):**\n > I agree that the finding is valid, the fee can be paid in a mintable token to gain temporary ownership of a token underlying which is repaid at the end of `fillOrder`.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1178994409):**\n > Report: It’s possible to flashloan all assets in the contract without paying a protocol fee.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/377#issuecomment-1182823327):**\n > Flash loans from the contract would be a feature, not a bug. However, being able to do so without paying a protocol fee (ie. paying in fake tokens) wouldn't be great. \n> \n\n***\n\n",
      "summary": "\nA bug has been reported in the PuttyV2 contract, which could allow a malicious user to leverage the contract to flashloan without paying a fee. This could result in the malicious user making a profit at the expense of the contract. \n\nThe bug occurs when the maker and taker are the same, and is a contract. The contract calls PuttyV2.fillOrder with a Long Call order that has order.baseAssets references to a contract with custom logic other than the standard ERC20. The order also specifies erc20Assets to the token and tokenAmount that PuttyV2 contract is owing. \n\nWhen the execution reaches a certain point, the custom logic could be executed on the contract address order.baseAsset. The malicious contract then calls exercise to exercise the short call position. This call will transfer out the assets specified in the order to the malicious contract by executing logics in _transferERC20sOut, _transferERC721sOut. \n\nThe malicious contract then uses the assets to make a profit on other platforms, and then transfers enough assets back to PuttyV2 by executing logics in _transferERC20sIn, _transferERC721sIn to finish the execution. \n\nThis bug could have serious implications for the PuttyV2 contract, and should be addressed as soon as possible.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/377",
      "tags": [],
      "finders": [
        "0xc0ffEE",
        "unforgiven",
        "pedroais",
        "horsefacts"
      ]
    },
    {
      "id": "2941",
      "title": "[M-08] Overlap Between ERC721.transferFrom() and ERC20.transferFrom() Allows order.erc20Assets or order.baseAsset To Be ERC721 Rather Than ERC20",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L344\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L360\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L601\n\n\n## Vulnerability details\n\n## Impact\n\nBoth `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. The impact of this is it's possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20.\n\nThese functions will successfully transfer the NFT into the protocol however they will fail to transfer the NFT out of the contract. That is because the outgoing transfer is `ERC20.safeTransfer()` which calls `transfer(to, amount)` which does not match up with any valid function signatures on ERC721.\n\nTherefore any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract as neither `exercise()` nor `withdraw()` will successfully transfer the tokens out of the contract.\n\n## Proof of Concept\n\n[ERC721.transferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC721.sol#L82-L86)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n```\n\n[ERC20.trasnferFrom()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/lib/solmate/src/tokens/ERC20.sol#L90-L94)\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n```\n\n## Recommended Mitigation Steps\n\nConsider whitelisting approved ERC721 and ERC20 token contracts. Furthermore, separate these two contracts into different whitelists for ERC20s and ERC721s then ensure each contract is in the right category.",
      "summary": "\nThis bug report describes a vulnerability in the code of a project hosted on GitHub. The vulnerability is that the functions `ERC20.transferFrom(address to, address  from, uint256 amount)` and `ERC721.transferFrom(address to, address from, uint256 id)` have the same function signature `0x23b872dd`. This means that it is possible for `baseAsset` or `erc20Assets` to be ERC721 addresses rather than ERC20. As a result, any ERC721 tokens transferred into the contract in this manner via `fillOrder()` will be permanently stuck in the contract and unable to be transferred out.\n\nProof of concept code is provided to demonstrate the vulnerability. The recommended mitigation steps are to consider whitelisting approved ERC721 and ERC20 token contracts, and to separate these two contracts into different whitelists for ERC20s and ERC721s to ensure each contract is in the right category.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/52",
      "tags": [],
      "finders": [
        "reassor  sseefried",
        "kirk-baird"
      ]
    },
    {
      "id": "2940",
      "title": "[M-07] An attacker can create a short put option order on an NFT that does not support ERC721 (like cryptopunk), and the user can fulfill the order, but cannot exercise the option",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by IllIllI and minhquanym_\n\nAn attacker can create a short put option on cryptopunk. When the user fulfills the order, the baseAsset will be transferred to the contract. \n\nHowever, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. Attacker can get premium and get back baseAsset after option expires.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L343-L346>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L628-L629>\n\n### Recommended Mitigation Steps\n\nConsider adding a whitelist to nfts in the order, or consider supporting exercising on cryptopunk.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1174823604):**\n > Putty uses solmate's `ERC721.safeTransferFrom` which requires that the NFT contract implements `onERC721Received`. For the case of OG NFTs like punks and rocks, this will fail, https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L120\n\n**[thereksfour (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1175910424):**\n > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1176031452):**\n > > The user does not need to send cryptopunk to the contract when fulfilling the short put option order, but the user will pay a premium to the order creator. Later, when the user wants to exercise the option, since the cryptopunk does not support safetransferfrom, the user cannot exercise the option.\n> \n> Sorry, I did not consider this path. You are correct to say that a maker can create a short put option order with cryptopunks as a token and the holder of the long put option will not be able to exercise since cryptopunks cannot be transferred with `safeTransferFrom`. From that perspective, this is a valid issue. Thank you for bringing it up. I will defer to the judge for the final decision.\n\n**[outdoteth (Putty Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1178923868):**\n > We dont intend to support cryptopunks or cryptokitties.\n> If users wish to use these tokens then they can get wrapped versions (ex: wrapped cryptopunks).\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/16#issuecomment-1181762798):**\n > I thought cryptokitties are ERC721? I think they were the ones who popularized the standard actually :p \n> Probably meant etherrocks.\n> \n> In general, non-compliant ERC-721 NFTs can be supported through wrappers, though some users might be unaware... Downgrading to med severity, similar to [this issue from another contest](https://github.com/code-423n4/2022-02-foundation-findings/issues/74).\n> \n> \n\n**hyh (warden) reviewed mitigation:**\n > Similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with PuttyV2.sol, a smart contract. An attacker can create a short put option on cryptopunk, a non-fungible token (NFT). When the user fulfills the order, the baseAsset will be transferred to the contract. However, since cryptopunk does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. The attacker can get a premium and get back the baseAsset after the option expires. The code for this vulnerability can be found in lines 343-346 and 628-629 of PuttyV2.sol. To mitigate this issue, the developers should consider adding a whitelist to NFTs in the order, or consider supporting exercising on cryptopunk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/16",
      "tags": [],
      "finders": [
        "cccz",
        "IllIllI  minhquanym"
      ]
    },
    {
      "id": "2939",
      "title": "[M-06] [Denial-of-Service] Contract Owner Could Block Users From Withdrawing Their Strike",
      "impact": "MEDIUM",
      "content": "_Submitted by xiaoming90, also found by berndartmueller_\n\nWhen users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500>\n\n```solidity\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n\n\t// transfer strike to owner if put is expired or call is exercised\n\tif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n\t\t// send the fee to the admin/DAO if fee is greater than 0%\n\t\tuint256 feeAmount = 0;\n\t\tif (fee > 0) {\n\t\t\tfeeAmount = (order.strike * fee) / 1000;\n\t\t\tERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n\t\t}\n\n\t\tERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n\t\treturn;\n\t}\n\t..SNIP..\n}\n```\n\nThere are two methods on how the owner can deny user from withdrawing their strike amount from the contract\n\n#### Method #1 - Set the `owner()` to `zero` address\n\nMany of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226>\n\n```solidity\nfunction _transfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _balances[from] = fromBalance - amount;\n        // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n        // decrementing then incrementing.\n        _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n}\n```\n\nIt is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.\n\n#### Method #2 - If `baseAsset` is a ERC777 token\n\n> Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.\n\nERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .\n\nAssuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.\n\nThis issue will affect all orders that has ERC777 token as its `baseAsset`.\n\n### Impact\n\nUser cannot withdraw their strike amount and their asset will be stuck in the contract.\n\n### Recommended Mitigation Steps\n\nIt is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.\n\nInstead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.\n\nConsider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.\n\nThis will give users more assurance and confidence about the security of their funds stored within Putty.\n\n```solidity\nmapping(address => uint256) public ownerFees;\n\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n    // transfer strike to owner if put is expired or call is exercised\n    if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n        // send the fee to the admin/DAO if fee is greater than 0%\n        uint256 feeAmount = 0;\n        if (fee > 0) {\n            feeAmount = (order.strike * fee) / 1000;\n            ownerFees[order.baseAsset] += feeAmount\n        }\n\n        ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n        return;\n    }\n    ..SNIP..\n}\n\nfunction withdrawFee(address baseAsset) public onlyOwner {\n\tuint256 _feeAmount = ownerFees[baseAsset];\n\townerFees[baseAsset] = 0;\n\tERC20(baseAsset).safeTransfer(owner(), _feeAmount);\n}\n```\n**[outdoteth (Putty Finance) disagreed with severity](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1177678807)**\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1179936225):**\n > The scenarios provided are valid, especially for baseAssets that revert on zero-address transfer.\n> \n> While the likelihood is low, assets are lost and cannot be retrieved.<br>\n> `3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).`\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1181754248):**\n > Thinking about it further, the external conditions / requirements needed for the DoS to happen are somewhat strong.\n> - the ERC777 attack requires `owner()` or the token to be engineered to be malicious and adopted.\n> - DoS via revoking ownership requires `fee` to be non-zero first, which is unlikely to happen. I can classify this as a \"user-prone\" bug, which would be similar to cases like including ETH when WETH is intended to be used (#226).\n> \n> Hence, I think medium severity is more appropriate:\n> `2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/296#issuecomment-1185411399):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269): as the platform fee is now transferred on order filling, any owner griefing can only yield a denial of service. There will be no loss of funds as this way position is only about to be created when the fee is transferred.\n\n***\n\n",
      "summary": "\nThis bug report is concerning the PuttyV2 contract, which is a smart contract used to facilitate the trading of options. When users withdraw their strike escrowed in the Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users. \n\nThe bug is that, there are two methods on how the owner can deny user from withdrawing their strike amount from the contract. The first method is to set the owner() to zero address. This is because many of the token implementations do not allow transfer to zero address, and will revert immediately if the to address (recipient) points to a zero address during a transfer. The second method is if the baseAsset is a ERC777 token. This is because ERC777 contains a tokensReceived hook that will notify the recipient whenever someone sends some tokens to the recipient. The recipient, which is the owner() in this case, could always revert whenever PuttyV2 contract attempts to send the fee to recipient. This will cause the withdraw function to revert too.\n\nThe impact of this bug is that users cannot withdraw their strike amount and their asset will be stuck in the contract.\n\nThe recommended mitigation steps to fix this bug is to adopt a withdrawal pattern for retrieving owner fee. Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the PuttyV2 contract. This will give users more assurance and confidence about the security of their funds stored within Putty.",
      "quality_score": 4.583333333333333,
      "rarity_score": 4.428571428571429,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/296",
      "tags": [
        "DOS",
        "Withdraw Pattern",
        "ERC20",
        "ERC777"
      ],
      "finders": [
        "berndartmueller",
        "xiaoming90"
      ]
    },
    {
      "id": "2938",
      "title": "[M-05] fillOrder() and exercise() may lock Ether sent to the contract, forever",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436\n\n\n## Vulnerability details\n\n## Impact\n`fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.\n\n\n## Proof of Concept\nEther can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n323           if (order.isLong) {\n324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n325           } else {\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325\n\n\nIf the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused:\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n337               } else {\n338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n339               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339\n\n\nSame for the exercise of call options:\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n435               } else {\n436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n437               }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nAdd a `require(0 == msg.value)` for the above three conditions",
      "summary": "\nThis bug report is related to a code inspection of the PuttyV2.sol file. The bug report has identified three code paths that require Ether to be sent to them but do not return anything to the sender. This could result in Ether being locked in the contract forever, with the sender not receiving anything in return. The code paths identified are found at lines 324, 338, and 436. \n\nThe recommended mitigation steps are to add a `require(0 == msg.value)` for these three conditions. This will ensure that no Ether is sent to the contract when these code paths are taken.\n\nTo summarize, this bug report has identified a code issue in the PuttyV2.sol file that could result in Ether being locked in the contract forever. The recommended mitigation steps are to add a `require(0 == msg.value)` for the identified code paths.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/226",
      "tags": [],
      "finders": [
        "zzzitron_",
        "xiaoming90",
        "berndartmueller",
        "0x29A",
        "sashiketh",
        "danb",
        "BowTiedWardens",
        "joestakey",
        "0xDjango",
        "peritoflores",
        "oyc109",
        "IllIllI",
        "swit",
        "simon135",
        "cccz",
        "auditor0517",
        "dirky",
        "hansfriese",
        "horsefacts",
        "sseefried",
        "AmitN",
        "rfa",
        "StErMi",
        "kirk-baird",
        "dipp",
        "0xc0ffEE",
        "hyh"
      ]
    },
    {
      "id": "2937",
      "title": "[M-04] Put options are free of any fees",
      "impact": "MEDIUM",
      "content": "_Submitted by berndartmueller, also found by 0xsanson, hubble, Lambda, Metatron, and swit_\n\nFees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).\n\n#### Put options\n\nIf a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.\n\n#### Call options\n\nIf a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.\n\nHowever, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.\n\n### Proof of Concept\n\nThe protocol fee is correctly charged for exercised calls:\n\n[PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)\n\n```solidity\n// transfer strike to owner if put is expired or call is exercised\nif ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n    // send the fee to the admin/DAO if fee is greater than 0%\n    uint256 feeAmount = 0;\n    if (fee > 0) {\n        feeAmount = (order.strike * fee) / 1000;\n        ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium\n    }\n\n    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high\n\n    return;\n}\n```\n\nContrary, put options are free of any fees:\n\n[PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)\n\n```solidity\n// transfer strike from putty to exerciser\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n```\n\n### Recommended Mitigation Steps\n\nCharge fees also for exercised put options.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1176533283):**\n > Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1179907369):**\n > Making this the primary issue for the med severity issue, as per my comment in [#269](https://github.com/code-423n4/2022-06-putty-findings/issues/269):\n> > \"Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\"\n\n**[outdoteth (Putty Finance) confirmed and resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/285#issuecomment-1185411614):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > The same fix as in [H-01](https://github.com/code-423n4/2022-06-putty-findings/issues/269).\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in PuttyV2.sol, a smart contract used for trading options. The vulnerability is that fees are not charged when put options are exercised. Put options are options that give the holder the right to sell an asset at a certain price. When a put option is exercised, the holder receives the strike price (the price the option was bought at) denominated in order.baseAsset. Call options, on the other hand, give the holder the right to buy an asset at a certain price, and when a call option is exercised, the holder sends the strike price to Putty and the short position holder is able to withdraw the strike amount. \n\nThe bug report provides proof of concept for the vulnerability. It states that the protocol fee is correctly charged for exercised calls, but that put options are free of any fees. The code for this is provided in the report. \n\nThe recommended mitigation step for this vulnerability is to charge fees also for exercised put options.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/285",
      "tags": [],
      "finders": [
        "swit",
        "0xsanson",
        "Metatron",
        "berndartmueller",
        "Lambda",
        "hubble"
      ]
    },
    {
      "id": "2936",
      "title": "[M-03] Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xNineDec, exd0tpy, and zzzitron_\n\nPut option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.\n\n### Proof of Concept\n\nIf the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n453               // transfer assets from exerciser to putty\n454               _transferERC20sIn(order.erc20Assets, msg.sender);\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454>\n\nThe function reverts if any amount is equal to zero, or the asset doesn't exist:\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n594           for (uint256 i = 0; i < assets.length; i++) {\n595               address token = assets[i].token;\n596               uint256 tokenAmount = assets[i].tokenAmount;\n597   \n598               require(token.code.length > 0, \"ERC20: Token is not contract\");\n599               require(tokenAmount > 0, \"ERC20: Amount too small\");\n600   \n601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n602           }\n603       }\n```\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603>\n\n### Recommended Mitigation Steps\n\nVerify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1177638096):**\n > At the contract level there exists 2 possible mitigations;\n> \n> 1) Remove the zero amount check (not feasible because it will cause another DOS issue for tokens that revert on 0 transfer).\n> 2) Check all erc20 assets are valid in `fillOrder` (gas tradeoff because it requires an O(n) loop to check).\n> \n> Instead, the best mitigation imo is to add a check on the frontend/db level to ensure that all erc20 assets have a token amount greater than 0 and that it exists as a contract.\n> \n> If users want to go lower level than the db/frontend then they must exercise their own diligence.\n> \n> edit: decided to go with a 3rd option instead.\n> \n> Simply skip the ERC20 transfer if the amount is 0.<br>\n>\n> Report: Setting an erc20Asset with a zero amount or with no code at the address will result in a revert when exercising a put option.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/223#issuecomment-1185412355):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/8.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed zero amount part by introducing the noop for zero amount transfers in both `_transferERC20sIn` and `_transferERC20sOut` ERC20 transfer functions. The second part of the issue, fake tokens, is similar to [M-01](https://github.com/code-423n4/2022-06-putty-findings/issues/50), [M-02](https://github.com/code-423n4/2022-06-putty-findings/issues/227).\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability that affects Put option buyers in the PuttyV2.sol contract. If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing. The vulnerability was identified through code inspection. To mitigate the issue, it is recommended to verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/223",
      "tags": [
        "Token Existence"
      ],
      "finders": [
        "exd0tpy",
        "IllIllI",
        "0xNineDec",
        "zzzitron"
      ]
    },
    {
      "id": "2935",
      "title": "[M-02] Unbounded loops may cause exercise()s and withdraw()s to fail ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Vulnerability details\n\n## Impact\nThere are no bounds on the number of tokens transferred in an order, and gas requirements can change (especially since orders can have a duration of [27 years](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L287)), so orders filled at time T1 may not be exercisable/withdrawable at time T2, or with the provided assets if the assets use a lot of gas during their transfers (e.g. aTokens and cTokens). The buyer of the option will have paid the premium, and will be unable to get the assets they are owed.\n\n\n## Proof of Concept\nThere are no upper bounds on the number of assets being transferred in these loops:\n```solidity\nFile: contracts/src/PuttyV2.sol   #1\n\n636       function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n637           for (uint256 i = 0; i < assets.length; i++) {\n638               ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n639           }\n640       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L636-L640\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #2\n\n646       function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n647           for (uint256 i = 0; i < assets.length; i++) {\n648               ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n649           }\n650       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L646-L650\n\n\n```solidity\nFile: contracts/src/PuttyV2.sol   #3\n\n657       function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n658           for (uint256 i = 0; i < floorTokens.length; i++) {\n659               ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n660           }\n661       }\n```\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L657-L661\n\n\n## Tools Used\nCode inspection\n\n\n## Recommended Mitigation Steps\nHave an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary",
      "summary": "\nThis bug report is about the PuttyV2 smart contract, which is used to facilitate the transfer of tokens across different platforms. The code inspection tool has identified a vulnerability in the contract, which can be exploited to transfer an unlimited number of tokens in one transaction. This could cause a problem if the assets being transferred use a lot of gas during their transfer, as the buyer of the option may not be able to get the assets they are owed.\n\nThe code inspection tool has identified three lines of code that are vulnerable to this exploit. These are lines 636-640, 646-650, and 657-661. These lines of code allow the contract to transfer an unlimited number of tokens in one transaction.\n\nThe recommended mitigation step for this vulnerability is to have an upper bound on the number of assets that can be transferred in one transaction, or to allow them to be transferred out one at a time. This will ensure that the buyer of the option is able to get the assets they are owed, even if the assets use a lot of gas during their transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/227",
      "tags": [],
      "finders": [
        "IllIllI",
        "xiaoming90_",
        "sashiketh",
        "shung",
        "0xNineDec"
      ]
    },
    {
      "id": "2934",
      "title": "[M-01] Malicious Token Contracts May Lead To Locking Orders",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by 0xA5DF, cccz, chatch, csanuragjain, Alex the Entreprenerd, hansfriese, hyh, itsmeSTYJ, Kenshin, pedroais, sashik_eth, unforgiven, and xiaoming90_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L79>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L80>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L81>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L72>\n\n### Impact\n\nIt is possible to prevent an order from executing `exercise()` or `withdraw()` by having a malicious token contract included in the order as part of the any of the following fields.\n\n*   `baseAsset`\n*   `floorTokens[]`\n*   `erc20Assets[]`\n*   `erc721Assets[]`\n\nAn attacker as a maker may create an order and set one of these addresses to a malicious contract in the attackers control. The attacker allows the user to fill the order then toggles a variable on the malicious contract which always causes it to revert.\n\nThe attacker benefits by preventing orders from being `exercise()` if they are in an undesirable position (e.g. if they have gone short and the price has gone up). The attacker waits for either the time to expire or the price to go down and allows transfers to occur on their malicious token.\n\nSimilar attacks can also be performed over the `withdraw()` function since this also makes calls to untrusted external addresses. This would allow an attacker to exercise an option then prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\n### Proof of Concept\n\nAny of the transfers in [exercise](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L389-L458) make external calls to untrusted addresses.\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n\n        /* ~~~ EFFECTS ~~~ */\n\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n```\n\nThe attacker must control one of these contracts and have it set as a malicious ERC20 / ERC721 function that fails under attacker controlled conditions.\n\n### Recommended Mitigation Steps\n\nConsider whitelisting approved ERC20 token or ERC721 address contracts to prevent users setting malicious token contracts. However, this remediation will have a significant admin input / gas trade-offs.\n\n**[outdoteth (Putty Finance) acknowledged and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1177630161):**\n > Technically this is a valid finding. However we don't intend to fix this at the contract level. Instead there will be adequate warnings on the UI to inform a user that they should be vigilant for any tokens that are not verified by putty (in addition, the UI will show the unverified token's logo as a question mark instead of as the token's logoURI).\n>\n > Report: Setting malicious or invalid erc721Assets, erc20Assets or floorTokens prevents the option from being exercised.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1179463134):**\n > It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. Hence, medium severity is appropriate: `2-Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n**[Pedroais (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1194894079):**\n > I will argue why this issue should be high severity instead of medium.  \n> \n> \"It's contingent on the external requirement for the attacker to be in control of a malicious ERC20 or NFT. \"\n> \n> Anyone can deploy a malicious contract and pass it as an ERC20 or NFT. This is not an external requirement, anyone can do it. Any malicious contract deployed by the attacker will work.\n> \n> This issue imposes a risk of asset loss to users without external requirements. The sponsor states unknown tokens will be shown with a question mark in the UI. This is ok but I think the attack is high severity since the user would be reasonable to think if he is accepting an offer for a BAYC (example of an expensive NFT)  and some unknown token that in the worse case he should at least get the BAYC. This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> A user would be reasonable to expect to at least be able to exercise the real NFT in a case with an option that includes a real NFT and a malicious one. The problem is the malicious NFT can block the exercise of the real NFT. An option can be created using  many real and valuable tokens with just 1 malicious token that prevents exercising the real ones.\n> \n> I hope the judge can consider these arguments and make his decision.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/50#issuecomment-1198793737):**\n> I should have phrased it better. The external requirement isn't on the attacker being in control of the malicious ERC20 / NFT. As rightfully pointed out, it can be easily done.\n> \n> The external requirement here is the user deciding to fill an option containing malicious assets. Such options can be considered to be honeypots that users should be made aware of (eg. through documentation, PSAs or warnings to the user). There's only so much the protocol can do to protect users, with tradeoffs against centralisation risks if the suggestion of whitelisting assets is adopted.\n> \n> > This attack doesn't require the user to be dumb or act recklessly but just normal functioning of the protocol. The fake token shouldn't prevent the user from exercising the real BAYC.\n> \n> Partial exercising of options could be a feature, but opens up new attack surfaces and would be a non-trivial to implement. It is a limitation of the protocol that should be clearly communicated to users.\n\n**hyh (warden) reviewed mitigation:**\n > Now addressed on UI/DB level.\n\n***\n\n",
      "summary": "\nThis bug report concerns the PuttyV2.sol contract, which is part of the code-423n4/2022-06-putty repository. An attacker could use this vulnerability to prevent an order from executing the exercise() or withdraw() functions by including a malicious token contract in any of the fields of the order: baseAsset, floorTokens[], erc20Assets[], or erc721Assets[]. This would allow the attacker to benefit by preventing orders from being exercised if they are in an undesirable position, and also prevent the other user from claiming any of the NFTs or ERC20 tokens that are owed to them.\n\nThe vulnerability is present because any of the transfers in the exercise() function make external calls to untrusted addresses. The attacker must control one of these contracts and have it set as a malicious ERC20/ERC721 function that fails under attacker-controlled conditions.\n\nTo mitigate this vulnerability, the system could consider whitelisting approved ERC20 token or ERC721 address contracts to prevent users from setting malicious token contracts. However, this remediation would require significant admin input and incur gas trade-offs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/50",
      "tags": [],
      "finders": [
        "csanuragjain",
        "sashiketh",
        "unforgiven",
        "cccz",
        "Kenshin",
        "pedroais",
        "itsmeSTYJ",
        "kirk-baird",
        "hansfriese",
        "chatch",
        "hyh",
        "Alex the Entreprenerd",
        "xiaoming90_",
        "0xA5DF"
      ]
    },
    {
      "id": "2933",
      "title": "[H-04] Zero strike call options can be systemically used to steal premium from the taker",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by hansfriese_\n\nSome non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.\n\nMarking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.\n\n### Proof of Concept\n\nCurrently system do not check the strike value, unconditionally attempting to transfer it:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nAs a part of call exercise logic:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443>\n\n```solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        ...\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        }\n```\n\nSome tokens do not allow zero amount transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nThis way for such a token and zero strike option the maker can create short call order, receive the premium:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339>\n\n```solidity\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n```\n\nTransfer in the assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371>\n\n```solidity\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n```\n\nAnd wait for expiration, knowing that all attempts to exercise will revert:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437>\n\n```solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n```\n\nThen recover her assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519>\n\n```solidity\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n```\n\n### Recommended Mitigation Steps\n\nConsider checking that strike is positive before transfer in all the cases, for example:\n\n```solidity\n            } else {\n+               if (order.strike > 0) {\n                    ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n+               }\n            }\n```\n\n**[Alex the Entreprenerd (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1174522101):**\n > Seems contingent on token implementation, however certain ERC20 do revert on 0 transfer and there would be no way to exercise the contract in that case.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1178989277):**\n > Report: Cannot exercise call contract if strike is 0 and baseAsset reverts on 0 transfers.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1182684476):**\n > There is a pre-requisite for the ERC20 token to revert on 0 amount transfers. However, the warden raised a key point: zero strike calls are common, and their premium is substantial. The information asymmetry of the ERC20 token between the maker and taker is another aggravating factor.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1185410362):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/3.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by conditioning call's logic on `order.strike > 0`. There is no use case for zero strike puts and so this case remains unconditioned, i.e. still always require successful `order.strike` transfer. \n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol contract which allows malicious makers to steal from takers. This vulnerability is caused by the code not checking the strike value and attempting to transfer it unconditionally. This is a problem because some tokens do not allow zero amount transfers, meaning malicious makers can create short call orders, receive the premium, transfer in the assets, and wait for expiration without being able to exercise the option, allowing them to effectively steal the premium. To mitigate this vulnerability, the code should check that the strike is positive before transferring it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/418",
      "tags": [],
      "finders": [
        "hyh",
        "hansfriese"
      ]
    },
    {
      "id": "2932",
      "title": "[H-03] Create a short call order with non empty floor makes the option impossible to exercise and withdraw",
      "impact": "HIGH",
      "content": "_Submitted by zzzitron, also found by danb, Kenshin, Metatron, minhquanym, and PwnedNoMore_\n\n**HIGH** - assets can be lost\n\nIf a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s.\n\nThis bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.\n\n### Proof of Concept\n\n*   [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202)\n*   [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)\n\nThe proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases.\n\n*   case 1: he calls exercise with empty `floorAssetTokenIds` array\n*   case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`\n\nIn the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629).\n\n```solidity\n// case 1\n  // PuttyV2.sol: _transferFloorsIn called by exercise\n  // The floorTokens and floorTokenIds do not match the lenghts\n  // floorTokens.length is not zero, while floorTokenIds.length is zero\n\n       ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n```\n\nIn the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts.\n\n    // case2\n    // PuttyV2.sol: exercise\n    // non empty floorAssetTokenIds array is passed for put option, it will revert\n\n            !order.isCall\n                ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n                : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\nAfter the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516).\n\n```solidity\n// maker trying to withdraw\n// PuttyV2.sol: withdraw\n\n  _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n```\n\nNote on the PoC:\n\n*   The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`.\n*   For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out\n*   The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.\n\n### Tools Used\n\nFoundry.\n\n### Recommended Mitigation Steps\n\nIt happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.\n\n**[STYJ (warden) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1174764713):**\n > Note that it is possible to cause loss of funds for others through this.\n> \n> Assume that maker (A) creates a long call and taker (B) fills it, transferring floor tokens (XYZ) into putty. \n> \n> If maker (C) creates a short call with floorTokens (XYZ), taker (D) is able to fill and exercise his long call since XYZ already resides on Putty. This will however invalidate the options pair that was created between A and B since A cannot exercise and B cannot withdraw.\n\n**[outdoteth (Putty Finance) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995529):**\n > Agree that this should be marked as high severity given the exploit scenario provided by @STYJ above.\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995764):**\n > Report: Short call with floorTokens will result in a revert when exercising.\n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1181790939):**\n > Agreed, all wardens gave the same scenario that leads to a direct loss of NFTs and premium, but @STYJ's exploit scenario raises the gravity of the situation since users can be griefed.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1185411060):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/1.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by prohibiting non-empty `order.floorTokens` for short calls.\n >\n > Other option types do need `floorTokens`: long calls' taker provides floor tokens on filling, while long put owner brings in the floor tokens on exercise, taking the strike. Short put owner can thereafter retrieve the tokens on withdraw.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol code on the code-423n4/2022-06-putty repository. If a short call order is created with a non-empty floorTokens array, the taker cannot exercise the option and the maker cannot withdraw after the expiration. This means that both parties lose out: the taker loses premium without possible exercise, and the maker loses the locked ERC20s and ERC721s. The proof of concept provided shows two scenarios: the first is where the input floorAssetTokenIds are checked to be empty for put orders, but the call passes this requirement and eventually causes an Index out of bounds error. The second is where the input floorAssetTokenIds are checked to be empty, but are not empty and thus revert. After expiration, the maker trying to withdraw also fails due to the same issue. The tools used to discover this bug were foundry. The recommended mitigation steps are to ensure that the fillOrder does not have a non-empty floorTokens array when the order is a short call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/369",
      "tags": [],
      "finders": [
        "danb",
        "Metatron",
        "minhquanym",
        "zzzitron",
        "Kenshin",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2931",
      "title": "[H-02] acceptCounterOffer() May Result In Both Orders Being Filled",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584\n\n\n## Vulnerability details\n\n## Impact\n\nWhen a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.\n\nThe impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.\n\n## Proof of Concept\n\n[acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled.\n```solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n```\n\n[cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding.\n```solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n```\n\nTherefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.\n\n## Recommended Mitigation Steps\n\nConsider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.",
      "summary": "\nThis bug report is about a vulnerability in the PuttyV2.sol smart contract. When a user attempts to accept a counter offer, it is possible for an attacker or any other user to fill the original order before the acceptCounterOffer() function cancels it. This means both the original order and the new order will be filled, leaving the user twice as leveraged as they intended to be. The vulnerability is caused by the cancel() function not reverting if an order has already been filled. To mitigate this vulnerability, the cancel() function should be modified to revert if an order has already been filled by adding the line \"require(_ownerOf[uint256(orderHash)] == 0)\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/44",
      "tags": [],
      "finders": [
        "csanuragjain",
        "minhquanym",
        "Lambda",
        "kirk-baird",
        "hansfriese"
      ]
    },
    {
      "id": "2930",
      "title": "[H-01] Fee is being deducted when Put is expired and not when it is exercised.",
      "impact": "HIGH",
      "content": "_Submitted by zishansami, also found by 0x52, 0xsanson, auditor0517, berndartmueller, csanuragjain, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503>\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451>\n\n### Impact\n\nFee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`.\nComment section of the `setFee()` function mentions `\"fee rate that is applied on exercise\"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).\n\nBut, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.\n\nAlso, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).\n\nThis unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\n### Proof of Concept\n\n`if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.\n\n`feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).\n\n### Recommended Mitigation Steps\n\n1.  Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`\n\n2.  Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:\n\n```solidity\nuint256 feeAmount = 0;\nif (fee > 0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n}\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n```\n\n**[outdoteth (Putty Finance) confirmed and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1178999683):**\n > Report: Fees are only applied on puts if they are expired.\n\n**[HickupHH3 (judge) increased severity to High and commented](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1179899567):**\n > Due to incorrect logic, there are 2 consequences of separate severities:\n> \n> 1) Expired put option being charged the admin fee. As @berndartmueller mentioned in [#380](https://github.com/code-423n4/2022-06-putty-findings/issues/380), the fee should be charged on the premium (actually this is another issue, see [#373](https://github.com/code-423n4/2022-06-putty-findings/issues/373)). Since it is possible for the fee amount to be greater than expected, I consider this to be a loss of assets and therefore given a high severity rating.\n> \n> 2) Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\n> \n> Issues that mention (1) or both (1) and (2) will be given a high severity rating, those that mention only (2) will be given a medium.\n\n**[outdoteth (Putty Finance) resolved](https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1185405136):**\n > PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\n**hyh (warden) reviewed mitigation:**\n > Fixed by changing the fee base to be `order.premium` [`PR#4`](https://github.com/outdoteth/putty-v2/pull/4), which is now paid uniformly for all option types on order filling. Utilizing `order.strike` as the fee base was the root cause for [M-04](https://github.com/code-423n4/2022-06-putty-findings/issues/285), [M-06](https://github.com/code-423n4/2022-06-putty-findings/issues/296), [M-11](https://github.com/code-423n4/2022-06-putty-findings/issues/422), [M-15](https://github.com/code-423n4/2022-06-putty-findings/issues/373), so the change to `order.premium` was a shared mitigation for all of them.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of PuttyV2.sol, a contract written in the Solidity programming language. The vulnerability affects how fees are deducted when a Put position is exercised or expired. The code shows that fees are deducted when the position is expired, but not when it is exercised. This unintended deduction of assets from Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\nTo fix this vulnerability, it is recommended to update the if condition at PuttyV2.sol#L498 with (fee > 0 && order.isCall && isExercised). Additionally, feeAmount calculation and deduction should be added after the Put is exercised and the strike is transferred at PuttyV2.sol#L451.\n\nThis bug report was done using manual analysis.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Putty",
      "source_link": "https://code4rena.com/reports/2022-06-putty",
      "github_link": "https://github.com/code-423n4/2022-06-putty-findings/issues/269",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "0x52",
        "0xsanson",
        "auditor0517",
        "zishansami",
        "berndartmueller",
        "zzzitron"
      ]
    },
    {
      "id": "22561",
      "title": "[N-02] valutIndex = 1 is never used",
      "impact": "LOW",
      "content": "The value of vaultIndex = 1  is never assigned to any vault.\n```\n        // vault index should always be odd\n        vaultIndex += 2;\n        vaultId = vaultIndex;\n        _vaults[vaultId] = vault;\n```\nThis can be changed to as below, so that vaultID = 1 is also used\n```\n        vaultId = vaultIndex;\n        // vault index should always be odd\n        vaultIndex += 2;\n        _vaults[vaultId] = vault;\n```\n\n**[outdoteth (Cally) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/281#issuecomment-1128026692):**\n > high quality report\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22560",
      "title": "[N-01] Consistency in fetching vault values",
      "impact": "LOW",
      "content": "In Cally.sol, function buyOption the following is the order of lines.\nline 208   require(vaultId % 2 != 0, \"Not vault type\");\nline 211   Vault memory vault = _vaults[vaultId];\n\nThis can be made consistent with other functions by changing the order.\n\n  Vault memory vault = _vaults[vaultId];\n  require(vaultId % 2 != 0, \"Not vault type\");\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5431",
      "title": "[G-19] `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves 6 gas _PER LOOP_\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/CallyNft.sol   #1\n\n244:          for (uint256 i = 0; i < data.length; i++) {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-19-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "5430",
      "title": "[G-11] `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas [_PER LOOP_](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/CallyNft.sol   #1\n\n244:          for (uint256 i = 0; i < data.length; i++) {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-11-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "5429",
      "title": "[G-10] `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (100 gas)\n* memory arrays use `MLOAD` (3 gas)\n* calldata arrays use `CALLDATALOAD` (3 gas)\n\nCaching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/CallyNft.sol   #1\n\n244:          for (uint256 i = 0; i < data.length; i++) {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-10-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5428",
      "title": "[G-09] `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n188:          vaultIndex += 2;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L188\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n285:              protocolUnclaimedFees += fee;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L285\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-09-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "4684",
      "title": "[G-26] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n119:      function setFee(uint256 feeRate_) external onlyOwner {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L119\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n124:      function withdrawProtocolFees() external onlyOwner returns (uint256 amount) {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L124\n\n**[outdoteth (Cally) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/45#issuecomment-1128108328):**\n > this is the best gas report imo - hats off to you!\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-26-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4683",
      "title": "[G-25] Use custom errors rather than `revert()`/`require()` strings to save deployment gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version\n\n*There are 32 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol\n\n167:          require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n\n168:          require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n\n169:          require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n\n170:          require(durationDays > 0, \"durationDays too small\");\n\n171:          require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n211:          require(vaultId % 2 != 0, \"Not vault type\");\n\n214:          require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n217:          require(vault.isExercised == false, \"Vault already exercised\");\n\n220:          require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n\n224:          require(msg.value >= premium, \"Incorrect ETH amount sent\");\n\n228:          require(block.timestamp >= auctionStartTimestamp, \"Auction not started\");\n\n260:          require(optionId % 2 == 0, \"Not option type\");\n\n263:          require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n269:          require(block.timestamp < vault.currentExpiration, \"Option has expired\");\n\n272:          require(msg.value == vault.currentStrike, \"Incorrect ETH sent for strike\");\n\n304:          require(vaultId % 2 != 0, \"Not vault type\");\n\n307:          require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n320:          require(vaultId % 2 != 0, \"Not vault type\");\n\n323:          require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n328:          require(vault.isExercised == false, \"Vault already exercised\");\n\n329:          require(vault.isWithdrawing, \"Vault not in withdrawable state\");\n\n330:          require(block.timestamp > vault.currentExpiration, \"Option still active\");\n\n353:          require(vaultId % 2 != 0, \"Not vault type\");\n\n354:          require(msg.sender == ownerOf(vaultId), \"Not owner\");\n\n436:          require(from == _ownerOf[id], \"WRONG_FROM\");\n\n437:          require(to != address(0), \"INVALID_RECIPIENT\");\n\n438           require(\n439               msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n440               \"NOT_AUTHORIZED\"\n441:          );\n\n456:          require(_ownerOf[tokenId] != address(0), \"URI query for NOT_MINTED token\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol\n\n```solidity\nFile: contracts/src/CallyNft.sol\n\n15:           require(to != address(0), \"INVALID_RECIPIENT\");\n\n16:           require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n36:           require(owner != address(0), \"ZERO_ADDRESS\");\n\n42:           require(to != address(0), \"INVALID_RECIPIENT\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-25-use-custom-errors-rather-than-revertrequire-strings-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4682",
      "title": "[G-24] Multiplication/division by two should use bit shifting",
      "impact": "GAS",
      "content": "`<x> * 2` is equivalent to `<x> << 1` and `<x> / 2` is the same as `<x> >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/src/CallyNft.sol   #1\n\n241:          bytes memory str = new bytes(2 + data.length * 2);\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L241\n\n```solidity\nFile: contracts/src/CallyNft.sol   #2\n\n245:              str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L245\n\n```solidity\nFile: contracts/src/CallyNft.sol   #3\n\n246:              str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L246\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-24-multiplicationdivision-by-two-should-use-bit-shifting",
      "tags": [],
      "finders": []
    },
    {
      "id": "4681",
      "title": "[G-23] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "Saves deployment costs\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n304:          require(vaultId % 2 != 0, \"Not vault type\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L304\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n328:          require(vault.isExercised == false, \"Vault already exercised\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L328\n\n```solidity\nFile: contracts/src/Cally.sol   #3\n\n323:          require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L323\n\n```solidity\nFile: contracts/src/CallyNft.sol   #4\n\n42:           require(to != address(0), \"INVALID_RECIPIENT\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L42\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-23-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4680",
      "title": "[G-22] Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n217:          require(vault.isExercised == false, \"Vault already exercised\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L217\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n220:          require(vault.isWithdrawing == false, \"Vault is being withdrawn\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L220\n\n```solidity\nFile: contracts/src/Cally.sol   #3\n\n328:          require(vault.isExercised == false, \"Vault already exercised\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L328\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-22-dont-compare-boolean-expressions-to-boolean-literals",
      "tags": [],
      "finders": []
    },
    {
      "id": "4679",
      "title": "[G-20] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nUse a larger size then downcast where needed\n\n*There are 10 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol\n\n76:           uint8 premiumIndex; // indexes into `premiumOptions`\n\n77:           uint8 durationDays; // days\n\n78:           uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\n\n79:           uint32 currentExpiration;\n\n87:       uint32 public constant AUCTION_DURATION = 24 hours;\n\n161:          uint8 premiumIndex,\n\n162:          uint8 durationDays,\n\n163:          uint8 dutchAuctionStartingStrikeIndex,\n\n227:          uint32 auctionStartTimestamp = vault.currentExpiration;\n\n408:          uint32 auctionEndTimestamp,\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol\n\n### [G-21] Using `private` rather than `public` for constants, saves gas\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n87:       uint32 public constant AUCTION_DURATION = 24 hours;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L87\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-20-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4677",
      "title": "[G-18] It costs more gas to initialize variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n282:          uint256 fee = 0;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282\n\n```solidity\nFile: contracts/src/CallyNft.sol   #2\n\n244:          for (uint256 i = 0; i < data.length; i++) {\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L244\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-18-it-costs-more-gas-to-initialize-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "4676",
      "title": "[G-17] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves [6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png) per instance\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n170:          require(durationDays > 0, \"durationDays too small\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L170\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-17-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "4675",
      "title": "[G-16] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "Use a solidity version of at least 0.8.0 to get overflow protection without `SafeMath`\n\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\n\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\n\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/lib/base64/base64.sol   #1\n\n3:    pragma solidity >=0.6.0;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/lib/base64/base64.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-16-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "4674",
      "title": "[G-15] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n382:          return currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L382\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n396:          return premiumOptions[vault.premiumIndex];\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L396\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-15-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4673",
      "title": "[G-14] Cheaper input valdiations should come before expensive operations",
      "impact": "GAS",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n211:         require(vaultId % 2 != 0, \"Not vault type\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L211\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n214:         require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L214\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-14-cheaper-input-valdiations-should-come-before-expensive-operations",
      "tags": [],
      "finders": []
    },
    {
      "id": "4672",
      "title": "[G-13] Access mappings directly rather than using accessor functions",
      "impact": "GAS",
      "content": "Saves having to do two JUMP instructions, along with stack setup\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol\n\n214:         require(ownerOf(vaultId) != address(0), \"Vault does not exist\");\n\n263:         require(msg.sender == ownerOf(optionId), \"You are not the owner\");\n\n307:         require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n323:         require(msg.sender == ownerOf(vaultId), \"You are not the owner\");\n\n354:         require(msg.sender == ownerOf(vaultId), \"Not owner\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-13-access-mappings-directly-rather-than-using-accessor-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4671",
      "title": "[G-12] Offsets should only be calculated once per loop",
      "impact": "GAS",
      "content": "`i * 2` is calculated twice per loop, wasting gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/CallyNft.sol   #1\n\n244          for (uint256 i = 0; i < data.length; i++) {\n245              str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n246              str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n247:         }\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/CallyNft.sol#L244-L247\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-12-offsets-should-only-be-calculated-once-per-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "4667",
      "title": "[G-08] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.\nLess obvious fixes/optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n/// @audit strikeOptions\n169:          require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L169\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n/// @audit feeRate\n284:              fee = (msg.value * feeRate) / 1e18;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L284\n\n```solidity\nFile: contracts/src/Cally.sol   #3\n\n/// @audit vaultIndex\n189:          vaultId = vaultIndex;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L189\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-08-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4666",
      "title": "[G-07] Also `_burn()` the vault to get a gas refund",
      "impact": "GAS",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n275:         _burn(optionId);\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L275\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-07-also-_burn-the-vault-to-get-a-gas-refund",
      "tags": [],
      "finders": []
    },
    {
      "id": "4665",
      "title": "[G-06] Use `unchecked {}` for calculations that cannot overflow",
      "impact": "GAS",
      "content": "The subtraction below can be `unchecked {}` because of the check that comes before it\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n417:         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L417\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-06-use-unchecked--for-calculations-that-cannot-overflow",
      "tags": [],
      "finders": []
    },
    {
      "id": "4664",
      "title": "[G-05] Store actual beneficiary rather than deciding every time",
      "impact": "GAS",
      "content": "If the beneficiary array assigns the owner every time the NFT is minted or transferred, the mapping can be used directly, saving the gas overhead of function calls\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n249:         address beneficiary = getVaultBeneficiary(vaultId);\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L249\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n289:         ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L289\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-05-store-actual-beneficiary-rather-than-deciding-every-time",
      "tags": [],
      "finders": []
    },
    {
      "id": "4663",
      "title": "[G-04] Cheaper to split struct if only part of it is updated frequently",
      "impact": "GAS",
      "content": "The `currentStrike` and `currentExpiration` fields are updated frequently so they should be in a separate struct rather than re-writing the whole struct every time\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n230          // set new currentStrike\n231          vault.currentStrike = getDutchAuctionStrike(\n232              strikeOptions[vault.dutchAuctionStartingStrikeIndex],\n233              vault.currentExpiration + AUCTION_DURATION,\n234              vault.dutchAuctionReserveStrike\n235          );\n236  \n237          // set new expiration\n238          vault.currentExpiration = uint32(block.timestamp) + (vault.durationDays * 1 days);\n239  \n240          // update the vault with the new option expiration and strike\n241:         _vaults[vaultId] = vault;\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L230-L241\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-04-cheaper-to-split-struct-if-only-part-of-it-is-updated-frequently",
      "tags": [],
      "finders": []
    },
    {
      "id": "4662",
      "title": "[G-03] Use existing stack cache variable rather than re-fetching state variable",
      "impact": "GAS",
      "content": "Using `auctionStartTimestamp` defined above will save a Gwarmaccess (100 gas). Since this is in one of the two frequently-called functions, it'll save a lot of gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n233:             vault.currentExpiration + AUCTION_DURATION,\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L233\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-03-use-existing-stack-cache-variable-rather-than-re-fetching-state-variable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4661",
      "title": "[G-02] Re-creation of short `memory` arrays is cheaper than fetching indecies from a storage array",
      "impact": "GAS",
      "content": "Since the arrays are relatively short, it's cheaper to have a pure virtual function that [re-creates them every time](https://ethereum.stackexchange.com/questions/66388/standard-work-around-for-using-a-solidity-constant-array-which-is-not-supported/96599#96599) just to fetch a specific index, rather than incuring a Gcoldsload (2100 gas). Since this is in one of the two frequently-called functions, it'll save a lot of gas\n\n*There are 2 instances of this issue:*\n```solidity\nFile: ./contracts/src/Cally.sol   #1\n\n90:      uint256[] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\n```\n./https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L90\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n92:      uint256[] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L92\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-02-re-creation-of-short-memory-arrays-is-cheaper-than-fetching-indecies-from-a-storage-array",
      "tags": [],
      "finders": []
    },
    {
      "id": "4660",
      "title": "[G-01] Full vault details unnecessarily fetched twice in each call to `buyOption()`",
      "impact": "GAS",
      "content": "`getPremium()` should be changed to have its argument be an index into the array, rather than looking up the vault again. Since this is in one of the two frequently-called functions, it'll save a lot of gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n223:         uint256 premium = getPremium(vaultId);\n```\nhttps://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L223\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#g-01-full-vault-details-unnecessarily-fetched-twice-in-each-call-to-buyoption",
      "tags": [],
      "finders": []
    },
    {
      "id": "4659",
      "title": "[L-07] No event is raised when vault beneficiary is changed",
      "impact": "LOW",
      "content": "\n### Impact\nWhen beneficiary is changed at setVaultBeneficiary(Cally.sol), no event is raised. It would be important to raise this event for any external integration with this system.\n\n### Proof of Concept\nContract : Cally.sol\nFunction : setVaultBeneficiary\n\n### Recommended Mitigation Steps\n\nevent definition\n```\nevent VaultBeneficiaryUpdated(uint256 indexed vaultId, address indexed beneficiary);\n```\n\nevent emit at setVaultBeneficiary function\n```\nemit VaultBeneficiaryUpdated(vaultId, beneficiary);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-07-no-event-is-raised-when-vault-beneficiary-is-changed",
      "tags": [],
      "finders": []
    },
    {
      "id": "4658",
      "title": "[L-06] No event is raised when feeRate is changed",
      "impact": "LOW",
      "content": "\n### Impact\nWhen feeRate is changed at setFee(Cally.sol), no event is raised. It would be important to raise this event for any external integration with this system.\n\n### Proof of Concept\nContract : Cally.sol\nFunction : setFee\n\n### Recommended Mitigation Steps\n\nevent definition\n```\nevent FeeRateUpdated(uint256 newFeeRate);\n```\n\nevent emit at setFee function\n```\nrequire(feeRate_ != feeRate, \"new feeRate should be different\");\nfeeRate = feeRate_;\nemit FeeRateUpdated(feeRate_);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-06-no-event-is-raised-when-feerate-is-changed",
      "tags": [],
      "finders": []
    },
    {
      "id": "4657",
      "title": "[L-05] The available values in premiumOptions[] & strikeOptions[] are too restrictive",
      "impact": "LOW",
      "content": "\nTo reduce gas and storage, the protocol has currently designed to store the index of the premiumOptions[] & strikeOptions[] in the Vault structure.\n\n### Impact\nThis is too restrictive and may not be future proof.\n\n### Recommended Mitigation Steps\nOne suggestion is to add another member unit8 premiumMultiplier (with default value of 1) in the Vault struct, and users can have combination of values of the\npremiumMultiplier and premiumIndex to define more range of premium values if required.\n\nSame suggestion applies for adding a multiplier for the strikeOptions[]\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-05-the-available-values-in-premiumoptions--strikeoptions-are-too-restrictive",
      "tags": [],
      "finders": []
    },
    {
      "id": "4656",
      "title": "[L-04] Ambiguous error message in createVault() for durationDays",
      "impact": "LOW",
      "content": "\nIf a value of 0 is given for durationDays in the createVault() function, the transaction will revert with an ambigous message \"durationDays too small\"\nIt can better stated as given below\n\n### Recommended Mitigation Steps\nError message string can be changed as below.\n> line 170   require(durationDays > 0, \"durationDays cannot be zero\");\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-04-ambiguous-error-message-in-createvault-for-durationdays",
      "tags": [],
      "finders": []
    },
    {
      "id": "4655",
      "title": "[L-03] initiateWithdraw() should not be callable , if option already exercised",
      "impact": "LOW",
      "content": "\nIf the option is already exercised, the vault owner should not be allowed to call the initiateWithdraw() function.\n\n### Recommended Mitigation Steps\nAdd a require statement in the function initiateWithdraw()\n>   require(vault.isExercised == false, \"Vault already exercised\");\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-03-initiatewithdraw-should-not-be-callable--if-option-already-exercised",
      "tags": [],
      "finders": []
    },
    {
      "id": "4654",
      "title": "[L-02]  Function vaults() can return misleading information",
      "impact": "LOW",
      "content": "VaultId are odd in number; if a valultId of event number is given, the function valuts() will return misleading information.\n\nFunction valuts() in Cally.sol\n\n### Recommended Mitigation Steps\nCheck if the valutID parameter is of vault type, by adding a require statement\n\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\n        require(vaultId % 2 != 0, \"Not vault type\");\n        return _vaults[vaultId];\n    }\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-02--function-vaults-can-return-misleading-information",
      "tags": [],
      "finders": []
    },
    {
      "id": "4653",
      "title": "[L-01] Wrong error message string in function createVault()",
      "impact": "LOW",
      "content": "\nFunction : createVault() in Cally.sol\n\nline 169  require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n\n### Impact\nIf the current error message is followed, user will never be able to successfully createVault()\n\n\n### Recommended Mitigation Steps\nCorrect error message string\n> require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike more than Starting strike\");\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "#l-01-wrong-error-message-string-in-function-createvault",
      "tags": [],
      "finders": []
    },
    {
      "id": "2299",
      "title": "[M-10] `createVault()` does not confirm whether `tokenType` and `token`’s type are the same",
      "impact": "MEDIUM",
      "content": "_Submitted by GimelSec, also found by antonttc_\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L158-L201>\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L296>\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L345>\n\n### Impact\n\nWhen calling `createVault()`, `tokenType` could be different from `token`’s type. If a user accidentally used the wrong `tokenType`, it could lead to two different results.\n\nIf `token` is an ERC20 token and the user uses `TokenType.ERC721` as `tokenType`. It is less harmful, since `ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)` still works when `vault.token` is actually ERC20 token.\n\nHowever, if `token` is an ERC721 token and the user uses `TokenType.ERC20` as `tokenType`. When doing `creatVault()`, `ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount)` works fine. But when doing `exercise()` or `withdraw()`, `ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);` doesn’t work since ERC721 doesn’t implement `safeTransfer()` function. In consequence, the ERC721 token is frozen in the vault.\n\n### Proof of Concept\n\n`createVault()` does not confirm whether `tokenType` and `token`’s type are the same.\nBut the token can still be transferred into this contract. Since `transferFrom()` is implemented in ERC20 and `safeTransferFrom()` is implemented in ERC721\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L158-L201>\n\n        function createVault(\n            uint256 tokenIdOrAmount,\n            address token,\n            uint8 premiumIndex,\n            uint8 durationDays,\n            uint8 dutchAuctionStartingStrikeIndex,\n            uint256 dutchAuctionReserveStrike,\n            TokenType tokenType\n        ) external returns (uint256 vaultId) {\n            require(premiumIndex < premiumOptions.length, \"Invalid premium index\");\n            require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \"Invalid strike index\");\n            require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \"Reserve strike too small\");\n            require(durationDays > 0, \"durationDays too small\");\n            require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, \"Invalid token type\");\n\n            Vault memory vault = Vault({\n                tokenIdOrAmount: tokenIdOrAmount,\n                token: token,\n                premiumIndex: premiumIndex,\n                durationDays: durationDays,\n                dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n                currentExpiration: uint32(block.timestamp),\n                isExercised: false,\n                isWithdrawing: false,\n                tokenType: tokenType,\n                currentStrike: 0,\n                dutchAuctionReserveStrike: dutchAuctionReserveStrike\n            });\n\n            // vault index should always be odd\n            vaultIndex += 2;\n            vaultId = vaultIndex;\n            _vaults[vaultId] = vault;\n\n            // give msg.sender vault token\n            _mint(msg.sender, vaultId);\n\n            emit NewVault(vaultId, msg.sender, token);\n\n            // transfer the NFTs or ERC20s to the contract\n            vault.tokenType == TokenType.ERC721\n                ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n                : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n        }\n\nHowever when doing `exercise()` or `withdraw()`, it always reverts since ERC721 doesn’t implement `safeTransfer()`. The ERC721 token is frozen in the contract.\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L296>\n\n```\n    function exercise(uint256 optionId) external payable {\n        …\n        // transfer the NFTs or ERC20s to the exerciser\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L345>\n\n```\n    function withdraw(uint256 vaultId) external nonReentrant {\n        …\n        // transfer the NFTs or ERC20s back to the owner\n        vault.tokenType == TokenType.ERC721\n            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n    }\n\n```\n\n### Recommended Mitigation Steps\n\nConfirm whether `tokenType` and `token`’s type are the same in `createVault()`.\n\n**[outdoteth (Cally) disputed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/243#issuecomment-1127490806):**\n > ref; https://github.com/code-423n4/2022-05-cally-findings/issues/38\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/243#issuecomment-1136521143):**\n > There were a lot of reports recommending a similar change, but this is one of the few that points our a critical issue that could arise in the current state.\n> \n> Although the issue only occurs when the original vault creator makes a user error, the fact that their NFT becomes unrecoverable makes this a Medium Risk concern.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the Cally contract, which is stored on Github. When a user calls the `createVault()` function, they can specify a `tokenType` which may be different from the type of `token` they are using. If the user accidentally uses the wrong `tokenType`, it can lead to two different results. If `token` is an ERC20 token and the user uses `TokenType.ERC721` as `tokenType`, it is less harmful, since `ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)` still works when `vault.token` is actually ERC20 token. However, if `token` is an ERC721 token and the user uses `TokenType.ERC20` as `tokenType`, when doing `creatVault()`, `ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount)` works fine. But when doing `exercise()` or `withdraw()`, `ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);` doesn’t work since ERC721 doesn’t implement `safeTransfer()` function. As a result, the ERC721 token is frozen in the vault. The bug is caused by the fact that `createVault()` does not confirm whether `tokenType` and `token`’s type are the same. To mitigate this vulnerability, it is recommended to confirm whether `tokenType` and `token`’s type are the same in `createVault()`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/243",
      "tags": [],
      "finders": [
        "antonttc",
        "GimelSec"
      ]
    },
    {
      "id": "2298",
      "title": "[M-09] Use safeTransferFrom instead of transferFrom for ERC721 transfers",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3, also found by antonttc, berndartmueller, catchup, cccz, dipp, FSchmoede, GimelSec, hake, jah, jayjonah8, joestakey, kebabsec, Kenshin, Kumpa, MiloTruck, minhquanym, peritoflores, rfa, shenwilly, WatchPug, and ynnad_\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344>\n\n### Details & Impact\n\nThe `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isn’t recommended because:\n\n*   [OpenZeppelin’s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible\n*   Given that any NFT can be used for the call option, there are a few NFTs (here’s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`\n\n### Recommended Mitigation Steps\n\nCall the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.\n\n```solidity\nabstract contract CallyNft is ERC721(\"Cally\", \"CALL\"), ERC721TokenReceiver {...}\n```\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/38#issuecomment-1128776476):**\n > the fix for this issue is here; https://github.com/outdoteth/cally/pull/4\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the use of `transferFrom()` instead of `safeTransferFrom()` in the Cally.sol contract. The `transferFrom()` method is used to save gas, however this is not recommended because OpenZeppelin’s documentation discourages its use and some NFTs have logic in the `onERC721Received()` function which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`. To mitigate this issue, it is recommended to call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. The `CallyNft` contract should also inherit the `ERC721TokenReceiver` contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/38",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "ERC721"
      ],
      "finders": [
        "berndartmueller",
        "FSchmoede",
        "catchup",
        "MiloTruck",
        "minhquanym",
        "joestakey",
        "jah",
        "peritoflores",
        "Kenshin",
        "ynnad",
        "cccz",
        "hickuphh3",
        "WatchPug",
        "kebabsec",
        "Kumpa",
        "hake",
        "rfa",
        "shenwilly",
        "antonttc",
        "jayjonah8",
        "dipp",
        "GimelSec"
      ]
    },
    {
      "id": "2297",
      "title": "[M-08] Vault is Not Compatible with Fee Tokens and Vaults with Such Tokens Could Be Exploited",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1337, also found by 0x52, 0xDjango, 0xsanson, berndartmueller, BondiPestControl, BowTiedWardens, cccz, dipp, GimelSec, hake, hickuphh3, horsefacts, hubble, IllIllI, MaratCerby, MiloTruck, minhquanym, PPrieditis, reassor, shenwilly, smiling_heretic, TrungOre, VAD37, and WatchPug_\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L198-L200>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L294-L296>\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L343-L345>\n\n### Impact\n\nSome ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.\n\n### Proof of Concept\n\nPlenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.\n\n            vault.tokenType == TokenType.ERC721\n                ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n                : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n\nThe implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.\n\nWhen an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.\n\n### Recommended Mitigation Steps\n\nRecommend disallowing fee tokens from being used in the vault. This can be done by adding a `require()` statement to check that the amount increase of the `token` balance in the `Cally` contract is equal to the amount being sent by the caller of the `createVault()` function.\n\n\n**[outdoteth (Cally) confirmed and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/61#issuecomment-1126980897):**\n > reference issue: https://github.com/code-423n4/2022-05-cally-findings/issues/39\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/61#issuecomment-1135276611):**\n > This is a good description of the potential issue when a fee on transfer token is used.\n> \n> Lowing to 2 (Medium). See https://github.com/code-423n4/org/issues/3 for some discussion on how to consider the severity for these types of issues.\n> \n> The attack described does leak value, but the vault could be recovered by transferring in the delta balance so that the contract has more than enough funds in order to exercise or withdraw. That plus these types of tokens are relatively rare is why I don't think this warrants a High severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the \"Cally\" contract, which is a part of a GitHub repository. It explains how the contract can be exploited if ERC20 tokens that charge a transaction fee are used in the \"createVault()\" function. The exploit allows an attacker to use the contract as a conduit to generate fee income, resulting in a loss of user funds and a loss of value from the contract. \n\nTo exploit this vulnerability, an attacker would observe when a vault is created that contains such fee tokens, then create a new vault that contains the same token and withdraw the same amount. This causes the contract to pay the transfer fee for the attacker.\n\nThe recommended mitigation steps are to disallow fee tokens from being used in the vault. This can be done by adding a \"require()\" statement to check that the amount increase of the token balance in the \"Cally\" contract is equal to the amount being sent by the caller of the \"createVault()\" function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/61",
      "tags": [
        "Weird ERC20",
        "Fee On Transfer"
      ],
      "finders": [
        "0x52",
        "berndartmueller",
        "hubble",
        "smilingheretic",
        "MiloTruck",
        "BowTiedWardens",
        "minhquanym",
        "0xDjango",
        "BondiPestControl",
        "PPrieditis",
        "VAD37",
        "IllIllI",
        "reassor",
        "0xsanson",
        "cccz",
        "hickuphh3",
        "0x1337",
        "horsefacts",
        "hake",
        "TrungOre",
        "WatchPug_",
        "MaratCerby",
        "shenwilly",
        "dipp",
        "GimelSec"
      ]
    },
    {
      "id": "2296",
      "title": "[M-07] Lack of 0 amount check allows malicious user to create infinite vaults",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xDjango_\n\nA griefer is able to create as many vaults as they want by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will most likely pose problems on the front-end of the Cally protocol because there will be a ridiculously high number of malicious vaults displayed to actual users.\n\nI define these vaults as malicious because it is possible that a user accidently buys a call on this vault which provides 0 value in return. Overall, the presence of zero-amount vaults is damaging to Cally's product image and functionality.\n\n### Proof of Concept\n\n*   User calls `createVault(0,,,,);` with an ERC20 type.\n*   There is no validation that `amount > 0`\n*   Function will complete successfully, granting the new vault NFT to the caller.\n*   Cally protocol is filled with unwanted 0 amount vaults.\n\n### Recommended Mitigation Steps\n\nAdd the simple check `require(tokenIdOrAmount > 0, \"Amount must be greater than 0\");`\n\n**[outdoteth (Cally) confirmed and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/91#issuecomment-1126912009):**\n > This check should only be applied on ERC20 tokens because ERC721 tokens can still have tokenIds that have ID's with a value of 0.\n\n**[outdoteth (Cally) resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/91#issuecomment-1129154306):**\n > this issue is fixed here: https://github.com/outdoteth/cally/pull/12\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Cally protocol which allows a griefer to create an unlimited number of malicious vaults by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will cause a ridiculously high number of malicious vaults to be displayed to actual users, which can lead to users accidently buying a call on this vault which provides 0 value in return. This is damaging to Cally's product image and functionality.\n\nThe bug was discovered through manual review and the recommended mitigation step is to add a simple check `require(tokenIdOrAmount > 0, \"Amount must be greater than 0\");` to the code. This will ensure that the amount of the vault is greater than 0, thus preventing the malicious vaults from being created.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/91",
      "tags": [],
      "finders": [
        "0xDjango"
      ]
    },
    {
      "id": "2295",
      "title": "[M-06] Owner can set the feeRate to be greater than 100% and cause all future calls to `exercise` to revert",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by 0xDjango, ACai, antonttc, BowTiedWardens, Cityscape, defsec, dipp, FSchmoede, GimelSec, gzeon, hickuphh3, hubble, joestakey, Kenshin, m9800, MiloTruck, RagePit, Ruhum, shenwilly, TomFrenchBlockchain, and WatchPug_\n\n### Impact\n\nThe owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens\n\n### Proof of Concept\n\nAfter a buyer buys an option owned by the owner, the owner can change the fee rate to be close to `type(uint256).max`, which will cause the subtraction below to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer\n\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n288           // increment vault beneficiary's ETH balance\n289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289>\n\n### Recommended Mitigation Steps\n\nAdd reasonable fee rate bounds checks in the `setFee()` function\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/48#issuecomment-1129088954):**\n > this issue is fixed here; https://github.com/outdoteth/cally/pull/7\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a contract called Cally.sol, which is part of a project on the GitHub repository code-423n4/2022-05-cally. The vulnerability allows the owner of the contract to force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens. The proof of concept for this vulnerability is that the owner can change the fee rate to a value close to the maximum allowed, which will cause the subtraction in lines 288 and 289 of the contract to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer.\n\nThe tools used to identify this vulnerability were code inspection. The recommended mitigation step is to add reasonable fee rate bounds checks in the `setFee()` function. This will ensure that the fee rate cannot be set to a value that will cause the subtraction to underflow, and thus prevent the vulnerability from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/48",
      "tags": [],
      "finders": [
        "FSchmoede",
        "m9800",
        "hubble",
        "MiloTruck",
        "BowTiedWardens",
        "joestakey",
        "0xDjango",
        "Kenshin",
        "IllIllI",
        "RagePit",
        "hickuphh3",
        "Ruhum",
        "WatchPug",
        "ACai",
        "Cityscape",
        "gzeon",
        "shenwilly",
        "TomFrenchBlockchain",
        "antonttc",
        "dipp",
        "GimelSec",
        "defsec"
      ]
    },
    {
      "id": "2294",
      "title": "[M-05] Expiration calculation overflows if call option duration ≥ 195 days",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3, also found by BondiPestControl, GimelSec, sseefried, and VAD37_\n\n`vault.durationDays` is of type `uint8`, thus allowing a maximum value of 255. `1 days = 86400`, thus fitting into a `uint24`. Solc creates a temporary variable to hold the result of the intermittent multiplication `vault.durationDays * 1 days` using the data type of the larger operand.\n\nIn this case, the intermittent data type used would be `uint24`, which has a maximum value of `2**24 - 1 = 16777215`. The maximum number allowable before overflow achieved is therefore `(2**24 - 1) / 86400 = 194`.\n\n### Proof of Concept\n\nInsert this test case into [BuyOption.t.sol](https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/test/units/BuyOption.t.sol)\n\n```solidity\n\nfunction testCannotBuyDueToOverflow() public {\n  vm.startPrank(babe);\n  bayc.mint(babe, 2);\n  // duration of 195 days\n  vaultId = c.createVault(2, address(bayc), premiumIndex, 195, strikeIndex, 0, Cally.TokenType.ERC721);\n  vm.stopPrank();\n\n  vm.expectRevert(stdError.arithmeticError);\n  c.buyOption{value: premium}(vaultId);\n}\n```\n\nThen run\n\n    forge test --match-contract TestBuyOption --match-test testCannotBuyDueToOverflow\n\n### Tidbit\n\nThis was the 1 high-severity bug that I wanted to mention at the end of the [C4 TrustX showcase](https://youtu.be/up9eqFRLgMQ?t=5722) but unfortunately could not due to a lack of time :( It can be found in the [vulnerable lottery contract](https://gist.github.com/HickupHH3/d214cfe6e4d003f428a63ae7d127af2d) on L39. Credits to Pauliax / Thunder for the recommendation and raising awareness of this bug =p\n\n### Reference\n\n[Article](https://muellerberndt.medium.com/building-a-secure-nft-gaming-experience-a-herdsmans-diary-1-91aab11139dc)\n\n### Recommended Mitigation Steps\n\nCast the multiplication into `uint32`.\n\n```solidity\nvault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days;\n```\n\n**[outdoteth (Cally) confirmed and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/16#issuecomment-1126902283):**\n > Agree that this is high risk - a user can unintentionally create vaults that would never have been able to have been filled and result in them losing funds because the vault creation was useless. They then also have to initiate a withdraw and then actually withdraw before they can create another vault. \n> \n> In terms of gas prices at 100 gwei (which it frequently was a few months ago) the total gas cost of this bug/incorrect vault creation is not insignificant.\n\n**[outdoteth (Cally) resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/16#issuecomment-1128754365):**\n > This issue is fixed here; https://github.com/outdoteth/cally/pull/3\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/16#issuecomment-1133498030):**\n > This is an easy way someone could create a vault where it's not possible to buy an option, and without using an unreasonably high duration value. If this were to occur, the vault creator could immediately `initiateWithdraw` and then `withdraw`. No time delay is required and the only funds lost is the gas cost of those 3 transactions.\n> \n> Lowering to 2 (Medium) since there's an easy recovery and no assets lost.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of a smart contract called Cally. The code is located at https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L238. The issue is that 'vault.durationDays' is of type 'uint8', which allows a maximum value of 255. However, due to the way the code is written, the maximum number allowable before overflow is achieved is 194. This can be tested using the test case provided in the report.\n\nThe bug can be found in the vulnerable lottery contract on Line 39. The recommended mitigation step is to cast the multiplication into 'uint32'. This will prevent the issue from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/16",
      "tags": [],
      "finders": [
        "VAD37",
        "hickuphh3",
        "BondiPestControl",
        "GimelSec",
        "sseefried"
      ]
    },
    {
      "id": "2293",
      "title": "[M-04] Vaults steal rebasing tokens' rewards",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by horsefacts and smiling_heretic_\n\nRebasing tokens are tokens that have each holder's `balanceof()` increase over time. Aave aTokens are an example of such tokens.\n\n### Impact\n\nIf rebasing tokens are used as the vault token, rewards accrue to the vault and cannot be withdrawn by either the option seller or the owner, and remain locked forever.\n\n### Proof of Concept\n\nThe amount 'available' for withdrawal comes from an input parameter and is stored for later operations:\n\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n173           Vault memory vault = Vault({\n174               tokenIdOrAmount: tokenIdOrAmount,\n175               token: token,\n176               premiumIndex: premiumIndex,\n177               durationDays: durationDays,\n178               dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,\n179               currentExpiration: uint32(block.timestamp),\n180               isExercised: false,\n181               isWithdrawing: false,\n182               tokenType: tokenType,\n183               currentStrike: 0,\n184               dutchAuctionReserveStrike: dutchAuctionReserveStrike\n185           });\n186   \n187           // vault index should always be odd\n188           vaultIndex += 2;\n189           vaultId = vaultIndex;\n190           _vaults[vaultId] = vault;\n191   \n192           // give msg.sender vault token\n193           _mint(msg.sender, vaultId);\n194   \n195           emit NewVault(vaultId, msg.sender, token);\n196   \n197           // transfer the NFTs or ERC20s to the contract\n198           vault.tokenType == TokenType.ERC721\n199               ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n200               : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L173-L200>\n\nThe amount actually available grows over time and is only known at the time of withdrawal. The option withdrawal/exercise use the original amount:\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n345               : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L345>\n\n```solidity\nFile: contracts/src/Cally.sol   #3\n\n296               : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L296>\n\n### Recommended Mitigation Steps\n\nTrack total amounts currently deposited and allow vault creators to withdraw excess on a pro-rata basis\n\n**[outdoteth (Cally) acknowledged and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/50#issuecomment-1126904209):**\n > This is technically an issue however we have no intention of supporting rebase tokens\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Cally smart contract, which is a part of the project hosted on GitHub. The vulnerability is related to rebasing tokens, which are tokens that have each holder's `balanceof()` increase over time. The impact of this vulnerability is that if rebasing tokens are used as the vault token, rewards accrue to the vault and cannot be withdrawn by either the option seller or the owner, and remain locked forever.\n\nThe bug was identified using code inspection, and the recommended mitigation steps are to track total amounts currently deposited and allow vault creators to withdraw excess on a pro-rata basis.\n\nIn conclusion, this bug report is about a vulnerability related to rebasing tokens used as the vault token, which can lead to rewards accruing to the vault and remaining locked forever. The bug was identified using code inspection, and the recommended mitigation steps are to track total amounts currently deposited and allow vault creators to withdraw excess on a pro-rata basis.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/50",
      "tags": [],
      "finders": [
        "IllIllI",
        "horsefacts  smilingheretic_"
      ]
    },
    {
      "id": "2292",
      "title": "[M-03] User's may accidentally overpay in `buyOption()` and the excess will be paid to the vault creator",
      "impact": "MEDIUM",
      "content": "_Submitted by BondiPestControl, also found by 0xf15ers, berndartmueller, cccz, csanuragjain, dipp, GimelSec, hake, horsefacts, IllIllI, jayjonah8, m9800, MadWookie, MiloTruck, pedroais, Ruhum, throttle, and VAD37_\n\nIt is possible for a user purchasing an option to accidentally overpay the premium during `buyOption()`.\n\nAny excess funds paid for in excess of the premium will be transferred to the vault creator.\n\nThe premium is fixed at the time the vault is first created by `vault.premiumIndex`. Hence there is no need to allow users to overpay since there will be no benefit.\n\n### Proof of Concept\n\n`buyOption()` allows `msg.value > premium`\n\n```solidity\n        uint256 premium = getPremium(vaultId);\n        require(msg.value >= premium, \"Incorrect ETH amount sent\");\n```\n\n### Recommended Mitigation Steps\n\nConsider modifying the check such that the `msg.value` is exactly equal to the `premuim`. e.g.\n\n```solidity\n        uint256 premium = getPremium(vaultId);\n        require(msg.value == premium, \"Incorrect ETH amount sent\");\n```\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/84#issuecomment-1129129122):**\n > this issue is fixed in: https://github.com/outdoteth/cally/pull/9\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/84#issuecomment-1133430227):**\n > Agree with 2 (Medium) for this. The issue doesn't really open the door for an attack, except for maybe via a malicious frontend. But it could potentially leak value in terms of over compensating the vault creator.\n\n**[HickupHH3 (warden) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/84#issuecomment-1149503319):**\n > QA report #182 should have its issue bumped up and marked as a duplicate IMO\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract. The vulnerability allows users to accidentally overpay the premium when purchasing an option. This means that any excess funds paid for the option will be transferred to the vault creator. The premium is fixed at the time the vault is created, so there is no need to allow users to overpay. As a proof of concept, the `buyOption()` function allows `msg.value > premium`. To mitigate this vulnerability, it is recommended to modify the check such that the `msg.value` is exactly equal to the `premium`.",
      "quality_score": 1,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/84",
      "tags": [],
      "finders": [
        "csanuragjain",
        "hake",
        "VAD37",
        "IllIllI",
        "MiloTruck",
        "cccz",
        "0xf15ers",
        "MadWookie",
        "Ruhum",
        "throttle",
        "berndartmueller",
        "pedroais",
        "jayjonah8",
        "m9800",
        "dipp",
        "BondiPestControl",
        "horsefacts",
        "GimelSec"
      ]
    },
    {
      "id": "2291",
      "title": "[M-02] It shouldn’t be possible to create a vault with Cally’ own token",
      "impact": "MEDIUM",
      "content": "_Submitted by p4st13r4, also found by GimelSec, TrungOre, and VAD37_\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193>\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199>\n\n### Impact\n\nAffected code:\n\n*   <https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193>\n*   <https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199>\n\nCurrently it’s possible to create an ERC-721 vault using Cally’ own address as `token`, and using the freshly minted vault id as `tokenIdOrAmount`. This results in a new vault whose ownership is passed to Cally contract immediately upon creation.\n\nThe vault allows users to perform `buyOption` and increase the ETH balance of the Cally contract itself, which is still the vault beneficiary. As soon as an user calls `exercise`, she will receive the `vault.tokenIdOrAmount` in exchange, which in this case coincides with the vault nft. However this is of no good because the final user may just initiate a withdrawal, which will:\n\n*   always fail because the vault id is burned (<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335>) and then transferred back to the user (<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344>)\n*   leave all the ETH unredemable in Cally contract\n\nSo the vault will be unusable and the ETH deposited by users to buy/exercise options will remain locked in Cally contract\n\n### Proof of Concept\n\n*   Current vault id is, let’s say, 11\n*   User deploys a vault with Cally’ address as `token` and `13` as `tokenIdOrAmount`\n*   Since `createVault()` mints the vault token to the user, and then transfers the underlying address from the user, an user is able to create a vault with something she doesn’t own at the moment of the `createVault()` function call, because it’s created while the function runs\n*   The vault `13` is pretty limited in functionality, because Cally’ smart contract is the owner\n*   However, users can still buy options: so Alice and Bob deposit their premiums\n*   Whoever `exercise` the active option, becomes the vault owner now; this is of no good because no one can actually call `withdraw()` as it will always revert, and no one can recover the ETH deposited by Alice and Bob as they are locked forever\n\n### Recommended Mitigation Steps\n\nAdd the following check at the start of `createVault()`:\n\n```jsx\nrequire(token != address(this), \"Cant use Cally as token\");\n```\n\n**[outdoteth (Cally) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/224#issuecomment-1127451866):**\n > This is an exploit that requires users to actively make a very precise and niche mistake. should be medium severity in our opinion.\n\n**[outdoteth (Cally) resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/224#issuecomment-1129139902):**\n > fix for this issue is here: https://github.com/outdoteth/cally/pull/10\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/224#issuecomment-1133042663):**\n > Copying in the POC from GimelSec in #244 because it's an interesting attack to consider for this issue as well.\n> \n> 1. Alice (Attacker) pack 2 transactions into same block:\n>     * first transaction: calls `createVault` to vault a NFT which worth 100 ETH, with parameters:\n>         * `dutchAuctionStartingStrikeIndex` is set to 0 (which `strikeOptions` is 1 ETH)\n>         * a long `durationDays`, e.g. `255` days\n>     * then Alice will get a `vaultId 1` token, and Alice do another transaction: call `buyOption(1)` to get a `optionId 2` token\n> 2. Alice re-vault the `vaultId 1` token with strike 89 ETH, and get a `vaultId 3` token\n> 3. Bob see that the auction of `vaultId 3` token is 89 ETH, but the `vaultId 3` token can get the NFT which worth 100 ETH, so Bob pays 89 ETH, calls `buyOption(3)`, and `exercise(4)` to get the `vaultId 1` token. Then, Bob calls `initiateWithdraw(1)` and waits for the `optionId 2` token to expire (which `durationDays` is set to `255` days in step 1).\n> 4. Alice monitors that someone bought the `vaultId 1` token, then Alice quickly calls `exercise(2)`. Finally, Alice just pays Bob 1 ETH, and gets the NFT back. Alice also gets 89 ETH which is paid by Bob from the `vaultId 3` token.\n> \n> I agree with (2) Medium for this issue. It can be abused, but the impacted parties can clearly see this is an attempt to subvert the system in some way (a vault of a vault with an NFT, instead of a single value with an NFT as expected). That should be a red flag for Bob in the example above.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Cally contract code which can lead to ETH being locked in the Cally contract. The affected code can be found at https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193 and https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199.\n\nThe vulnerability allows users to create an ERC-721 vault using Cally's own address as \"token\" and using the freshly minted vault id as \"tokenIdOrAmount\". This results in a new vault whose ownership is passed to Cally contract immediately upon creation.\n\nUsers can then perform \"buyOption\" and increase the ETH balance of the Cally contract itself. When an user calls \"exercise\", they will receive the \"vault.tokenIdOrAmount\" in exchange, which in this case coincides with the vault nft. However, this is of no good because the user cannot initiate a withdrawal, as it will always fail, and the ETH deposited by the user will remain locked in Cally contract.\n\nTo mitigate this vulnerability, a check should be added at the start of \"createVault()\" to ensure that Cally's address is not used as \"token\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/224",
      "tags": [],
      "finders": [
        "VAD37",
        "TrungOre",
        "GimelSec",
        "p4st13r4"
      ]
    },
    {
      "id": "2290",
      "title": "[M-01] Owner can modify the feeRate on existing vaults and steal the strike value on exercise",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI, also found by_ _Adam, 0x52, 0xf15ers, 0xsanson, berndartmueller, Bludya, BondiPestControl, catchup, crispymangoes, Czar102, eccentricexit, ellahi, GimelSec, hake, horsefacts, hubble, joestakey, Kumpa, pedroais, peritoflores, reassor, shenwilly, shung, smiling_heretic, sseefried, and throttle_\n\nOwner can steal the exercise cost which should have gone to the option seller\n\n### Proof of Concept\n\nThere are no restrictions on when the owner can set the `feeRate`:\n\n```solidity\nFile: contracts/src/Cally.sol   #1\n\n117       /// @notice Sets the fee that is applied on exercise\n118       /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18\n119       function setFee(uint256 feeRate_) external onlyOwner {\n120           feeRate = feeRate_;\n121       }\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121>\n\nBy using a rate that consumes the exercise cost, the owner can steal Ether from the seller:\n\n```solidity\nFile: contracts/src/Cally.sol   #2\n\n282           uint256 fee = 0;\n283           if (feeRate > 0) {\n284               fee = (msg.value * feeRate) / 1e18;\n285               protocolUnclaimedFees += fee;\n286           }\n287   \n288           // increment vault beneficiary's ETH balance\n289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282-L289>\n\nThe owner can wait for a particularly large-value NFT, snipe that one option, then retire\n\n### Recommended Mitigation Steps\n\nFix the fee rate per vault during vault creation\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/47#issuecomment-1129124229):**\n > issue is fixed here: https://github.com/outdoteth/cally/pull/8\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/47#issuecomment-1130869666):**\n > This is a valid concern. The owner could abuse this to capture much more ETH than was intended. It assumes that the owner is malicious or compromised and does not introduce any more risk than an upgradeable contract would have.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the Cally smart contract, which allows the owner to steal the exercise cost that should have gone to the option seller. This is possible by setting the fee rate to a value that consumes the exercise cost. The vulnerability can be exploited by waiting for a large-value NFT and sniping the option. The bug was discovered through code inspection. The recommended mitigation step is to fix the fee rate per vault during vault creation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/47",
      "tags": [],
      "finders": [
        "Czar102",
        "0x52",
        "0xf15ers",
        "berndartmueller",
        "catchup",
        "eccentricexit",
        "hubble",
        "smilingheretic",
        "Bludya",
        "throttle_",
        "joestakey",
        "peritoflores",
        "BondiPestControl",
        "IllIllI",
        "reassor",
        "0xsanson",
        "crispymangoes",
        "pedroais",
        "ellahi",
        "horsefacts",
        "sseefried",
        "Kumpa",
        "hake",
        "Adam",
        "shenwilly",
        "shung",
        "GimelSec"
      ]
    },
    {
      "id": "2289",
      "title": "[H-03] [WP-H0] Fake balances can be created for not-yet-existing ERC20 tokens, which allows attackers to set traps to steal funds from future users",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0xsanson, BondiPestControl, and IllIllI_\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201>\n\n```solidity\nfunction createVault(\n    uint256 tokenIdOrAmount,\n    address token,\n    ...\n) external returns (uint256 vaultId) {\n    ...\n    Vault memory vault = Vault({\n        ...\n    });\n\n    // vault index should always be odd\n    vaultIndex += 2;\n    vaultId = vaultIndex;\n    _vaults[vaultId] = vault;\n\n    // give msg.sender vault token\n    _mint(msg.sender, vaultId);\n\n    emit NewVault(vaultId, msg.sender, token);\n\n    // transfer the NFTs or ERC20s to the contract\n    vault.tokenType == TokenType.ERC721\n        ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)\n        : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);\n}\n```\n\n<https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34>\n\n```solidity\nimport \"solmate/utils/SafeTransferLib.sol\";\n\n...\n\ncontract Cally is CallyNft, ReentrancyGuard, Ownable {\n    using SafeTransferLib for ERC20;\n    ...\n```\n\nWhen creating a new vault, solmate's `SafeTransferLib` is used for pulling `vault.token` from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.\n\nThat's because there is a subtle difference between the implementation of solmate's `SafeTransferLib` and OZ's `SafeERC20`:\n\nOZ's `SafeERC20` checks if the token is a contract or not, solmate's `SafeTransferLib` does not.\n\nSee: <https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9>\n\n> Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\n\nAs a result, when the token's address has no code, the transaction will just succeed with no error.\n\nThis attack vector was made well-known by the qBridge hack back in Jan 2022.\n\nFor our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).\n\nHowever, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.\n\nFor example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.\n\nA sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.\n\n### Proof of Concept\n\nGiven:\n\n*   ProjectA has TokenA on another network;\n*   ProjectB has TokenB on another network;\n*   ProjectC has TokenC on another network;\n\n1.  The attacker `createVault()` for `TokenA`, `TokenB`, and `TokenC` with `10000e18` as `tokenIdOrAmount` each;\n2.  A few months later, ProjectB lunched `TokenB` on the local network at the same address;\n3.  Alice created a vault with `11000e18 TokenB`;\n4.  The attacker called `initiateWithdraw()` and then `withdraw()` to receive `10000e18 TokenB`.\n\nIn summary, one of the traps set by the attacker was activated by the deployment of  `TokenB` and Alice was the victim. As a result, `10000e18 TokenB` was stolen by the attacker.\n\n### Recommendation\n\nConsider using OZ's `SafeERC20` instead.\n\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/225#issuecomment-1129066964):**\n > this issue has been fixed here: https://github.com/outdoteth/cally/pull/5\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/225#issuecomment-1133421876):**\n > Great catch and the potential attack is very clearly explained. Although the window for an attack like this would not be common, it's an easy trap to setup and likely would occur as some point if Cally is planning to support multiple networks.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report focuses on the vulnerability of the Cally contract, which is used to create vaults. The vulnerability is related to the use of solmate's SafeTransferLib for pulling tokens from the caller's account, as opposed to OpenZeppelin's SafeERC20. The difference between the two is that the SafeERC20 checks if the token is a contract or not, while the SafeTransferLib does not. This can lead to a situation where a transaction will succeed without an error, even if the token address has no code. This attack vector was made well-known by the qBridge hack in January 2022. \n\nThe bug report goes on to provide a proof of concept (PoC) to demonstrate how a sophisticated attacker can take advantage of this vulnerability. The PoC involves the attacker creating vaults for tokens that do not yet exist, and when the token is eventually deployed, the attacker is able to withdraw the tokens from the vault.\n\nThe bug report recommends that the Cally contract should consider using OpenZeppelin's SafeERC20 instead of the SafeTransferLib to avoid this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/225",
      "tags": [],
      "finders": [
        "WatchPug",
        "IllIllI",
        "0xsanson",
        "BondiPestControl"
      ]
    },
    {
      "id": "2288",
      "title": "[H-02] Inefficiency in the Dutch Auction due to lower duration",
      "impact": "HIGH",
      "content": "_Submitted by hubble, also found by Hawkeye and sseefried_\n\nThe vulnerability or bug is in the implementation of the function getDutchAuctionStrike()\nThe AUCTION_DURATION is defined as 24 hours, and consider that the dutchAuctionReserveStrike (or reserveStrike) will never be set to 0 by user.\n\nNow if a vault is created with startingStrike value of 55 and reserveStrike of 13.5 , the auction price will drop from 55 to 13.5 midway at \\~12 hours.\nSo, after 12 hours from start of auction, the rate will be constant at reserveStrike of 13.5, and remaining time of 12 hours of auction is a waste.\n\nSome other examples :\n\n    startStrike, reserveStrike, time-to-reach-reserveStrike\n    55 , 13.5  , ~12 hours\n    55 , 5     , ~16.7 hours\n    55 , 1.5   , ~20 hours\n    5  , 1.5   , ~11 hours\n\n### Impact\n\nThe impact is high wrt Usability, where users have reduced available time to participate in the auction (when price is expected to change).\nThe vault-Creators or the option-Buyers may or may not be aware of this inefficiency, i.e., how much effective time is available for auction.\n\n### Proof of Concept\n\nContract : Cally.sol\nFunction : getDutchAuctionStrike ()\n\n### Recommended Mitigation Steps\n\nThe function getDutchAuctionStrike() can be modified such that price drops to the reserveStrike exactly at 24 hours from start of auction.\n\n            /*\n                delta = max(auctionEnd - currentTimestamp, 0)\n                progress = delta / auctionDuration\n                auctionStrike = progress^2 * (startingStrike - reserveStrike)             << Changes here\n                strike = auctionStrike + reserveStrike                                    << Changes here\n            */\n            uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\n            uint256 progress = (1e18 * delta) / AUCTION_DURATION;\n            uint256 auctionStrike = (progress * progress * (startingStrike-reserveStrike)) / (1e18 * 1e18);\n\n            strike = auctionStrike + reserveStrike;\n\n**[outdoteth (Cally) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/138#issuecomment-1126980017):**\n > We think this should be bumped to high severity. It would be easy for a user to create an auction that declines significantly faster than what they would have assumed - even over 1 or 2 blocks. It makes no sense for the auction to ever behave in this way and would result in options getting filled at very bad prices for the creator of the vault.\n\n**[outdoteth (Cally) resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/138#issuecomment-1128737816):**\n > The fix for this issue is here: https://github.com/outdoteth/cally/pull/2\n\n**[HardlyDifficult (judge) increased severity to High and commented](https://github.com/code-423n4/2022-05-cally-findings/issues/138#issuecomment-1133408636):**\n > The sponsor comment here makes sense. Agree with (1) High since this can potentially be very detrimental to the promise of this protocol.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the implementation of the function getDutchAuctionStrike() in the Cally.sol contract. The AUCTION_DURATION is defined as 24 hours, and the dutchAuctionReserveStrike (or reserveStrike) is set to a value other than 0 by the user. The bug causes the price to drop from the startingStrike value to the reserveStrike midway at ~12 hours, wasting the remaining 12 hours of the auction. This has a high impact on usability, as users have reduced available time to participate in the auction when the price is expected to change. The recommended mitigation step is to modify the function getDutchAuctionStrike() such that the price drops to the reserveStrike exactly at 24 hours from the start of the auction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/138",
      "tags": [],
      "finders": [
        "hubble",
        "Hawkeye  sseefried"
      ]
    },
    {
      "id": "2287",
      "title": "[H-01] no-revert-on-transfer ERC20 tokens can be drained",
      "impact": "HIGH",
      "content": "_Submitted by Ruhum, also found by oyc_109 and smiling_heretic_\n\n<https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200>\n\n### Impact\n\nSome ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: [Etherscan code](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)\n\nWhen such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.\n\n### Proof of Concept\n\nThe trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false.\n\nHere's a test that showcases the issue:\n\n```solidity\n// CreateVault.t.sol\n    function testStealFunds() public {\n        // address of 0x on mainnet\n        address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n        vm.startPrank(babe);\n        require(ERC20(t).balanceOf(babe) == 0);\n        uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);\n        // check that neither the Cally contract nor the vault creator\n        // had any 0x tokens\n        require(ERC20(t).balanceOf(babe) == 0);\n        require(ERC20(t).balanceOf(address(c)) == 0);\n\n        // check whether vault was created properly\n        Cally.Vault memory v = c.vaults(vaultId);\n        require(v.token == t);\n        require(v.tokenIdOrAmount == 100);\n        vm.stopPrank();\n        // So now there's a vault for 100 0x tokens although the Cally contract doesn't\n        // have any.\n        // If someone buys & exercises the option they won't receive any tokens.\n        uint premium = 0.025 ether;\n        uint strike = 2 ether;\n        require(address(c).balance == 0, \"shouldn't have any balance at the beginning\");\n        require(payable(address(this)).balance > 0, \"not enough balance\");\n\n        uint optionId = c.buyOption{value: premium}(vaultId);\n        c.exercise{value: strike}(optionId);\n\n        // buyer of option (`address(this)`) got zero 0x tokens\n        // But buyer lost their Ether\n        require(ERC20(t).balanceOf(address(this)) == 0);\n        require(address(c).balance > 0, \"got some money\");\n    }\n```\n\nTo run it, you need to use forge's forking mode: `forge test --fork-url <alchemy/infura URL> --match testStealFunds`\n\n### Recommended Mitigation Steps\n\nI think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens.\n\n**[outdoteth (Cally) confirmed and resolved](https://github.com/code-423n4/2022-05-cally-findings/issues/89#issuecomment-1128776685):**\n > the fix for this issue is here; https://github.com/outdoteth/cally/pull/4\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-05-cally-findings/issues/89#issuecomment-1130790694):**\n > This is a great report. I appreciate the clear test showcasing the issue well, and using a real token example.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the Cally smart contract, which can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. An example of such a token is ZRX, where the Etherscan code can be found on the given link. This can cause a loss of funds, as the creator of the vault does receive the buyer's Ether, but the buyer of the option (`address(this)`) gets zero tokens. \n\nThe bug can be exploited by creating a vault with an ERC20 token but using ERC721 as the vault's type, and instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false. \n\nThe recommended mitigation step is to use `safeTransferFrom()` when the token is of type ERC721. This transfer is at the end of the function and should not cause any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature should not exist on ERC20 tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Cally",
      "source_link": "https://code4rena.com/reports/2022-05-cally",
      "github_link": "https://github.com/code-423n4/2022-05-cally-findings/issues/89",
      "tags": [],
      "finders": [
        "oyc109  smilingheretic",
        "Ruhum"
      ]
    },
    {
      "id": "23468",
      "title": "[08] Unused functions and modifiers",
      "impact": "LOW",
      "content": "\nThese functions are noted as for backward compatibility, but not used anywhere, should probably be removed.\n\n### Proof of Concept\n\n[CoreRef.sol#L10](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/CoreRef.sol#L10)<br>\n\nUnused functions:\n\n*   \\_burnVoltHeld\n\nUnused modifiers:\n\n*   onlyVolt\n*   hasAnyOfFiveRoles\n*   hasAnyOfFourRoles\n*   hasAnyOfThreeRoles\n*   onlyGovernorOrGuardianOrAdmin\n*   ifMinterSelf\n\n### Recommended Mitigation Steps\n\nRemove these unused functions and modifiers.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23467",
      "title": "[07] setPublicChainlinkToken only called on chainId 1 and 42",
      "impact": "LOW",
      "content": "\n`ScalingPriceOracle` checks `chainId` in contract constructor, it might be better to upfront reject construction if it is not intended to serve other chains.\n\n### Proof of Concept\n\n[ScalingPriceOracle.sol#L84-L86](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/oracle/ScalingPriceOracle.sol#L84-L86)<br>\n\n### Recommended Mitigation Steps\n\nIt’s better to upfront check and reject construction if it is not intended to serve other chains.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23466",
      "title": "[06] Use Address.sendValue() without import @openzeppelin/contracts/utils/Address.sol",
      "impact": "LOW",
      "content": "\nAlthough `@openzeppelin/contracts/proxy/utils/Initializable.sol` is imported in `Core.sol`. A good coding practice should import `@openzeppelin/contracts/utils/Address.sol` when using it.\n\n### Proof of Concept\n\n[PCVDeposit.sol#L43](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/pcv/PCVDeposit.sol#L43)<br>\n\n### Recommended Mitigation Steps\n\nImport `@openzeppelin/contracts/utils/Address.sol` in `PCVDeposit.sol`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23465",
      "title": "[05] `valid` in `OraclePassThrough/read()` always returns true",
      "impact": "LOW",
      "content": "\nIn `OraclePassThrough.sol`, `valid` is always true in `read()`. Since `OracleRef` uses `valid` to determine validity. There should be a invalid case. Otherwise, the validity check is meaningless.\n\n### Proof of Concept\n\n[OraclePassThrough.sol#L41](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/oracle/OraclePassThrough.sol#L41)<br>\n\n[OracleRef.sol#L102](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/OracleRef.sol#L102)<br>\n\n### Recommended Mitigation Steps\n\nDefine the invalid case.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23464",
      "title": "[04] Using ecrecover is against best practice",
      "impact": "LOW",
      "content": "\nUsing ecrecover is against best practice. Preferably use ECDSA.recover instead. EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature unique. However it should be impossible to be a threat by now.\n\n### Proof of Concept\n\n[Volt.sol#L89](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/volt/Volt.sol#L89)<br>\n\n### Recommended Mitigation Steps\n\nTake these implementations into consideration\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol>\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/draft-ERC20Permit.sol>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23463",
      "title": "[03] Unnecessary usage of `init()`",
      "impact": "LOW",
      "content": "\nSince `Core` contract does not go through a proxy, and the caller of `init()` is the same as the deployer in deploy script, it is unnecessary to use init functions.\n\n### Proof of Concept\n\n[Core.sol#L20](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/core/Core.sol#L20)<br>\n\n### Recommended Mitigation Steps\n\nConsider putting `init()` logic into `constructor` instead and stop inheriting Initializable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23462",
      "title": "[02] `oraclePrice` will be imprecise",
      "impact": "LOW",
      "content": "\nPublic `oraclePrice` variable will be imprecise and confused. If other contracts try to get oracle price by calling `oraclePrice()` rather than calling `getCurrentOraclePrice()`, it will get wrong price.\n\n### Proof of Concept\n\n[ScalingPriceOracle.sol#L36](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/oracle/ScalingPriceOracle.sol#L36)<br>\n\n### Recommended Mitigation Steps\n\nDeclare `oraclePrice` to private, and only use `getCurrentOraclePrice()` to get the price instead.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23461",
      "title": "[1] Roles management",
      "impact": "LOW",
      "content": "\nAfter reviewing the entire volt protocol, we found that role management has been made unnecessarily complex.<br>\nWhile there are no immediate fatal flaws in the current role assignment, from our prior experience in dealing with privilege management, we worry that such a complex system will likely lead to future problems, especially when management gradually moves from the hands of few reliable developers to an open vcon based governance.<br>\nDue to this, we feel that there is a need to express our concerns as well as highlight a few role assignments that we find \"strange\".<br>\n\nFirst. let's review the roles included in Permissions and Tribes. The admin/members shown below are the ones explicitly assigned in contracts.\n\n    DEFAULT_ADMIN_ROLE\t\t\t\t\t\t\t(native)\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    MINTER_ROLE/MINTER\t\t\t\"MINTER_ROLE\"\t\t\t(native) (tribe-major)\n    \tadmin GOVERN_ROLE\n    \tmembers\n\n    BURNER_ROLE\t\t\t\t\"BURNER_ROLE\"\t\t\t(native)\t\t\tunused\n    \tadmin GOVERN_ROLE\n    \tmembers\n\n    PCV_CONTROLLER_ROLE/PCV_CONTROLLER\t\"PCV_CONTROLLER_ROLE\"\t\t(native) (tribe-major)\n    \tadmin GOVERN_ROLE\n    \tmembers\n\n    GOVERN_ROLE/GOVERNOR\t\t\t\"GOVERN_ROLE\"\t\t\t(native) (tribe-major)\n    \tadmin GOVERN_ROLE\n    \tmembers\n    \t\tcore\n    \t\tinit() caller\n\n    GUARDIAN_ROLE/GUARDIAN\t\t\t\"GUARDIAN_ROLE\"\t\t\t(native) (tribe-major)\n    \tadmin GOVERN_ROLE\n    \tmembers\n\n    PARAMETER_ADMIN\t\t\t\t\"PARAMETER_ADMIN\"\t\t(tribe-admin)\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    ORACLE_ADMIN\t\t\t\t\"ORACLE_ADMIN_ROLE\"\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    TRIBAL_CHIEF_ADMIN\t\t\t\"TRIBAL_CHIEF_ADMIN_ROLE\"\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    PCV_GUARDIAN_ADMIN\t\t\t\"PCV_GUARDIAN_ADMIN_ROLE\"\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    MINOR_ROLE_ADMIN\t\t\t\"MINOR_ROLE_ADMIN\"\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    FUSE_ADMIN\t\t\t\t\"FUSE_ADMIN\"\t\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    VETO_ADMIN\t\t\t\t\"VETO_ADMIN\"\t\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    MINTER_ADMIN\t\t\t\t\"MINTER_ADMIN\"\t\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    OPTIMISTIC_ADMIN\t\t\t\"OPTIMISTIC_ADMIN\"\t\t(tribe-admin)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    LBP_SWAP_ROLE\t\t\t\t\"SWAP_ADMIN_ROLE\"\t\t(tribe-minor)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    VOTIUM_ROLE\t\t\t\t\"VOTIUM_ADMIN_ROLE\"\t\t(tribe-minor)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    MINOR_PARAM_ROLE\t\t\t\"MINOR_PARAM_ROLE\"\t\t(tribe-minor)\t\t\tunused\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    ADD_MINTER_ROLE\t\t\t\t\"ADD_MINTER_ROLE\"\t\t(tribe-minor)\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\n    PSM_ADMIN_ROLE\t\t\t\t\"PSM_ADMIN_ROLE\"\t\t(tribe-minor)\n    \tadmin DEFAULT_ADMIN_ROLE\n    \tmembers\n\nNotice how a several of those roles are not used in any of the contracts (marked as unused). This is the first problem. While it is understandable that the protocol is incomplete yet, introducing redundant roles does not make management easier. AccessControl.sol allows introducing new roles post-deployment, so it might be a better idea to keep a list of dynamically introduced roles instead of listing a lot of unused ones upfront, especially since there are roles with similar names (PCV_GUARDIAN_ADMIN and PCV_CONTROLLER), between which the difference is not made clear.\n\nNext, we carry on to see the design of `Permissions`.<br>\nWe note that this contract is modified from the implementation of fei protocol, but on the other hand, disagree that the implementation is anywhere near optimal. To support our argument, we discuss the logic of role granting and revoking below.<br>\nSo let's look at the `grantMinter` function.\n\n        function grantMinter(address minter) external override onlyGovernor {\n            grantRole(MINTER_ROLE, minter);\n\nThe function specifies that it is a `onlyGovernor` function, which should expectedly mean that `GOVERNOR`, and only `GOVERNOR` have the privilege to add `MINTER_ROLE` members. However, if we dig a bit deeper, it is easy to see that this is not the case.\n\nThe `grantRole` function defined in AccessControl.sol is as below. Notice that it also has a modifier that specifies only admins of the specific role has privilege to add new members. Additionally, this function is public.\n\n        function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n            _grantRole(role, account);\n        }\n\nCombining this logic with the `grantMinter` one above, we can see that the workflow essentially becomes\n\n1.  caller is allowed to add new users if it only has admin of `MINTER_ROLE` (call `grantRole` directly)\n2.  caller is allowed to add new users if it has admin of `MINTER_ROLE` and `GOVERNOR` role (call `grantRole` or `grantMinter`)\n3.  caller is not allowed to add new users if it only has `GOVERNOR` role (blocked by `grantRole`)\n\nIt is clear that the `grantMinter` function now becomes semi-useless, since callers with only `GOVERNOR` role cannot do anything without admin of `MINTER_ROLE`, and admin of `MINTER_ROLE` can always call `grantRole` directly even if it does not have `GOVERNOR` role.\n\nOur best guess of the original intention is that `GOVERNOR` has full privilege over role management, while admin of roles are neglected. To realize this concept, it might be better to override the `grantRole` function and make it non-public, so that callers can't circumvent the `GOVERNOR` check. Finally, change `grantMinter` to use the internal function `_grantRole`. Similar modifications should also be done to the `revokeXXX` series of functions.\n\nNow we've gone through `Permissions`, time to look at `CoreRef` and `OracleRef`.<br>\nOne of the more interesting design choice in `CoreRef` is the introduction of `CONTRACT_ADMIN_ROLE`. This allows an additional role to be granted admin over the specific contract. However, throughout the volt protocol, `CONTRACT_ADMIN_ROLE` does not serve any particularly useful purpose. Moreover, in some places, the usage of `CONTRACT_ADMIN_ROLE` does not make much sense.\n\nFor instance, let's look at implementation of `RateLimited` and `MultiRateLimited`.<br>\n`RateLimited` defines a global limit to the `bufferCap` and `rateLimitPerSecond`, and `MultiRateLimited` defines the upper limit of `individualMaxBufferCap` and `individualMaxRateLimitPerSecond`. In our opinion, for the system to make sense, a user granted permission to change `bufferCap` and `rateLimitPerSecond` should also have permission to change `individualMaxBufferCap` and `individualMaxRateLimitPerSecond`. However, it can be seen that `CONTRACT_ADMIN_ROLES` are allowed to change the global limits through `onlyGovernorOrAdmin` modifier, while individual limits can only be changed by `GOVERNOR` since `onlyGovernor` is used.\nThe flexibility introduced through `CONTRACT_ADMIN_ROLE` is not properly utilized in volt protocol, and as we see in the example above, leads to potential role privilege confusions, thus we deemed it more appropriate to remove the `CONTRACT_ADMIN_ROLE` mechanism altogether for simplicity.\n\nThe next aspect we would like to discuss is more of a design choice, and not really a management problem. Take it with a grain of salt.<br>\nThroughout the contract, there are several places that use the `onlyGovernor` modifier. However given that the roles already included controllers/admins for each specific component (`PCV_CONTROLLER_ROLE`, `PSM_ADMIN_ROLE`), it is probably more appropriate to limit `GOVERNOR` to only manage the `Core` contract. If a governor needs to modify stuff from other contracts, add the corresponding admin role to itself and use that role to authenticate further actions. This design can create a clean cut between metadata management, and actually protocol management, at the cost of slightly more gas spent in granting roles. From our limited experience, this kind of management is more robust and greatly lowers the probability of mis-management in the future.\n\nNow we've discussed all general suggestions we have for role management, we finally note a few role modifier usage that we find \"strange\", but are uncertain whether intended or not.\n\n1.  `NonCustodialPSM.withdrawERC20` uses modifier `onlyPCVController`. We find it strange that a function in the PSM module requires PCVController role. Shouldn't this require `PSM_ADMIN_ROLE` instead?\n2.  `CompoundPCVDepositBase.withdraw` uses the modifier `onlyPCVController`. This would require `NonCustodialPSM` to have the `PCV_CONTROLLER_ROLE` to call `withdraw`, and while it is not a problem strictly speaking, we find it strange to grant such a role. A more usual implementation would be to have `CompoundPCVDepositBase` do internal bookkeeping on the amount each address deposited, and allow withdraw with respect to those values (similar to implementation of ERC20). This avoids the introduction of an additional role (a.k.a potential point of failure due to mis-management).\n\nOverall, complexity in role management easily creates confusions over the privilege of each role, and in the specific case of volt protocol, does not really introduce any benefits. We thus urge the developers to re-think the current role management system, and preferably simplify the design.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5298",
      "title": "[G-15] `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables\n\n1.  File: contracts/utils/MultiRateLimited.sol (lines [270-273](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L270-L273))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n2.  File: contracts/utils/MultiRateLimited.sol (lines [305-308](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L305-L308))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n3.  File: contracts/utils/RateLimited.sol (lines [46-49](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L46-L49))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-15-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "5297",
      "title": "[G-12] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code\n\n1.  File: contracts/oracle/ScalingPriceOracle.sol (line [50](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L50))\n\n```solidity\n    uint256 public constant override TIMEFRAME = 28 days;\n```\n\n2.  File: contracts/oracle/ScalingPriceOracle.sol (line [55](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L55))\n\n```solidity\n    uint256 public constant override MAXORACLEDEVIATION = 2_000;\n```\n\n3.  File: contracts/oracle/ScalingPriceOracle.sol (line [61](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L61))\n\n```solidity\n    bytes32 public immutable jobId;\n```\n\n4.  File: contracts/oracle/ScalingPriceOracle.sol (line [64](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L64))\n\n```solidity\n    uint256 public immutable fee;\n```\n\n5.  File: contracts/utils/RateLimited.sol (line [11](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L11))\n\n```solidity\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n```\n\n6.  File: contracts/volt/Volt.sol (lines [13-14](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/volt/Volt.sol#L13-L14))\n\n```solidity\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n```\n\n7.  File: contracts/core/Permissions.sol (line [10](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L10))\n\n```solidity\n    bytes32 public constant override BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n```\n\n8.  File: contracts/core/Permissions.sol (line [11](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L11))\n\n```solidity\n    bytes32 public constant override MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n```\n\n9.  File: contracts/core/Permissions.sol (lines [12-13](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L12-L13))\n\n```solidity\n    bytes32 public constant override PCV_CONTROLLER_ROLE =\n        keccak256(\"PCV_CONTROLLER_ROLE\");\n```\n\n10. File: contracts/core/Permissions.sol (line [14](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L14))\n\n```solidity\n    bytes32 public constant override GOVERN_ROLE = keccak256(\"GOVERN_ROLE\");\n```\n\n11. File: contracts/core/Permissions.sol (line [15](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L15))\n\n```solidity\n    bytes32 public constant override GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n```\n\n12. File: contracts/peg/NonCustodialPSM.sol (line [49](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L49))\n\n```solidity\n    uint256 public immutable override MAX_FEE = 300;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-12-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5296",
      "title": "[G-07] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\n1.  File: contracts/oracle/ScalingPriceOracle.sol (line [171](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L171))\n\n```solidity\n    function _updateCPIData(uint256 _cpiData) internal {\n```\n\n2.  File: contracts/oracle/ScalingPriceOracle.sol (line [218](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L218))\n\n```solidity\n    function _addNewMonth(uint128 newMonth) internal {\n```\n\n3.  File: contracts/core/Permissions.sol (line [211](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L211))\n\n```solidity\n    function _setupGovernor(address governor) internal {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-07-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5295",
      "title": "[G-06] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27>\n\n1.  File: contracts/utils/RateLimited.sol (line [23](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L23))\n\n```solidity\n    bool public doPartialAction;\n```\n\n2.  File: contracts/refs/OracleRef.sol (line [25](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L25))\n\n```solidity\n    bool public override doInvert;\n```\n\n3.  File: contracts/peg/NonCustodialPSM.sol (line [52](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L52))\n\n```solidity\n    bool public redeemPaused;\n```\n\n4.  File: contracts/peg/NonCustodialPSM.sol (line [55](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L55))\n\n```solidity\n    bool public mintPaused;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-06-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5294",
      "title": "[G-05] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: contracts/pcv/compound/CompoundPCVDepositBase.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/CompoundPCVDepositBase.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n2.  File: contracts/pcv/compound/ERC20CompoundPCVDeposit.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/ERC20CompoundPCVDeposit.sol#L2))\n\n```solidity\npragma solidity ^0.8.0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-05-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "5293",
      "title": "[G-04] Use a more recent version of solidity",
      "impact": "GAS",
      "content": "\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: contracts/pcv/PCVDeposit.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/PCVDeposit.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n2.  File: contracts/oracle/OraclePassThrough.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/OraclePassThrough.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n3.  File: contracts/oracle/ScalingPriceOracle.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n4.  File: contracts/utils/Timed.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Timed.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n5.  File: contracts/utils/Deviation.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Deviation.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n6.  File: contracts/utils/GlobalRateLimitedMinter.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/GlobalRateLimitedMinter.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n7.  File: contracts/utils/MultiRateLimited.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n8.  File: contracts/utils/RateLimited.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n9.  File: contracts/volt/Volt.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/volt/Volt.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n10. File: contracts/refs/OracleRef.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n11. File: contracts/refs/CoreRef.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/CoreRef.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n12. File: contracts/core/Core.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Core.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n13. File: contracts/core/TribeRoles.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/TribeRoles.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n14. File: contracts/core/Permissions.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n15. File: contracts/peg/NonCustodialPSM.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-04-use-a-more-recent-version-of-solidity",
      "tags": [],
      "finders": []
    },
    {
      "id": "5292",
      "title": "[G-03] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nSee [original submission](https://github.com/code-423n4/2022-03-volt-findings/issues/47) for instances.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-03-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4360",
      "title": "[G-17] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\n1.  File: contracts/oracle/ScalingPriceOracle.sol (line [150](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L150))\n\n```solidity\n        return sendChainlinkRequestTo(oracle, request, fee);\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-17-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4359",
      "title": "[G-16] Use custom errors rather than `revert()`/`require()` strings to save deployment gas",
      "impact": "GAS",
      "content": "\n1.  File: contracts/oracle/ScalingPriceOracle.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol))\n2.  File: contracts/utils/Timed.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Timed.sol))\n3.  File: contracts/utils/MultiRateLimited.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol))\n4.  File: contracts/utils/RateLimited.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol))\n5.  File: contracts/volt/Volt.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/volt/Volt.sol))\n6.  File: contracts/refs/OracleRef.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol))\n7.  File: contracts/refs/CoreRef.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/CoreRef.sol))\n8.  File: contracts/core/Permissions.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol))\n9.  File: contracts/peg/NonCustodialPSM.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol))\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-16-use-custom-errors-rather-than-revertrequire-strings-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4357",
      "title": "[G-14] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\n1.  File: contracts/pcv/compound/ERC20CompoundPCVDeposit.sol (line [16](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/ERC20CompoundPCVDeposit.sol#L16))\n\n```solidity\n    IERC20 public token;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-14-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4356",
      "title": "[G-13] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\n1.  File: contracts/utils/MultiRateLimited.sol (lines [305-308](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L305-L308))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-13-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4354",
      "title": "[G-11] Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
      "impact": "GAS",
      "content": "\nSee [this](https://github.com/ethereum/solidity/issues/9232) issue for a detail description of the issue.\n\nSee [original submission](https://github.com/code-423n4/2022-03-volt-findings/issues/47) for instances.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-11-expressions-for-constant-values-such-as-a-call-to-keccak256-should-use-immutable-rather-than-constant",
      "tags": [],
      "finders": []
    },
    {
      "id": "4353",
      "title": "[G-10] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\nSee [original submission](https://github.com/code-423n4/2022-03-volt-findings/issues/47) for instances.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-10-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4352",
      "title": "[G-09] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) for an example\n\n1.  File: contracts/volt/Volt.sol (lines [90-93](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/volt/Volt.sol#L90-L93))\n\n```solidity\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Fei: INVALID_SIGNATURE\"\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-09-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4351",
      "title": "[G-08] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second access of a state variable within a function.\nLess obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.\n\n1.  File: contracts/pcv/compound/CompoundPCVDepositBase.sol (line [32](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/CompoundPCVDepositBase.sol#L32))\n\n```solidity\n        require(cToken.isCToken(), \"CompoundPCVDeposit: Not a cToken\");\n```\n\n2.  File: contracts/pcv/compound/CompoundPCVDepositBase.sol (line [57](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/CompoundPCVDepositBase.sol#L57))\n\n```solidity\n            (cToken.balanceOf(address(this)) * exchangeRate) /\n```\n\n3.  File: contracts/pcv/compound/ERC20CompoundPCVDeposit.sol (line [31](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/compound/ERC20CompoundPCVDeposit.sol#L31))\n\n```solidity\n        token.approve(address(cToken), amount);\n```\n\n4.  File: contracts/oracle/ScalingPriceOracle.sol (line [124](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L124))\n\n```solidity\n        percentageChange = (delta * Constants.BP_INT) / int128(previousMonth);\n```\n\n5.  File: contracts/utils/MultiRateLimited.sol (line [344](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L344))\n\n```solidity\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n```\n\n6.  File: contracts/utils/RateLimited.sol (line [110](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L110))\n\n```solidity\n        emit BufferUsed(usedAmount, bufferStored);\n```\n\n7.  File: contracts/refs/OracleRef.sol (line [104](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L104))\n\n```solidity\n            (_peg, valid) = backupOracle.read();\n```\n\n8.  File: contracts/refs/OracleRef.sol (line [111](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L111))\n\n```solidity\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-08-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4345",
      "title": "[G-02] Lots of duplicated code between `RateLimited.sol` and `MultiRateLimited.sol`",
      "impact": "GAS",
      "content": "\nThe functionality of `RateLimited.sol` can be achieved by using either `address(0)` or `address(this)` as the `rateLimitedAddress` so having a separate `RateLimited.sol` contract is a waste of deployment gas.\n\n1.  File: contracts/utils/RateLimited.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol))\n2.  File: contracts/utils/MultiRateLimited.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol))\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-02-lots-of-duplicated-code-between-ratelimitedsol-and-multiratelimitedsol",
      "tags": [],
      "finders": []
    },
    {
      "id": "4344",
      "title": "[G-01] Store the timestamp endpoint rather than re-calculating it every time",
      "impact": "GAS",
      "content": "\nThe `isTimeEnded()` function does a lot of calculations every time it's called. It's called from multiple modifiers so it's important for it to be efficient. Rather than storing the duration, the code can calculate and store the ending timestamp, so `isTimeEnded()` can just be a direct comparison of two `uint256`s. The duration can be calculated by subtracting the start timestamp from the ending timestamp.\n\n1.  File: contracts/utils/Timed.sol (lines [38-59](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Timed.sol#L38-L59))\n\n```solidity\n    /// @notice return true if time period has ended\n    function isTimeEnded() public view returns (bool) {\n        return remainingTime() == 0;\n    }\n\n    /// @notice number of seconds remaining until time is up\n    /// @return remaining\n    function remainingTime() public view returns (uint256) {\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n    }\n\n    /// @notice number of seconds since contract was initialized\n    /// @return timestamp\n    /// @dev will be less than or equal to duration\n    function timeSinceStart() public view returns (uint256) {\n        if (!isTimeStarted()) {\n            return 0; // uninitialized\n        }\n        uint256 _duration = duration;\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n        return timePassed > _duration ? _duration : timePassed;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "#g-01-store-the-timestamp-endpoint-rather-than-re-calculating-it-every-time",
      "tags": [],
      "finders": []
    },
    {
      "id": "1835",
      "title": "[M-06] `NonCustodialPSM` can become insolvent as CPI index rises",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n[NonCustodialPSM.sol#L236-L248](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L236-L248)<br>\n\nNonCustodialPSM mints and redeems VOLT to a chosen stablecoin at the current market rate minus a fixed fee. It is assumed that the difference to be covered with pcvDeposit funds. That assumption is similar to one used in FEI protocol, but there no rate growth takes place as FEI to USD rate supposed to be stable, while VOLT to USD rate will rise over time.\n\nVOLT market rate is tied to the off-chain published CPI index. The growth of this index can easily surpass the yield of the pcvDeposit used, so its interest cannot be guaranteed to be always greater than CPI index advancement. The contract can end up in the situation when no redeem be possible, i.e. NonCustodialPSM can become insolvent.\n\nFor example, let's say the stablecoin is USDC, and now investors are worried about inflation and buy/mint 100m VOLT for 100m USDC. Fast forward 1 year, and investors were generally right, as due to rise of the oil prices happening simultaneously with logistics issues the CPI index growth end up being 30% APR for the year.\n\nThen, inflation fears abated and, say, stocks become stronger, and investors want their funds now to put them there and sell/redeem 100m VOLT expecting 125m USDC in return (for simplicity say 5m USDC goes to mint and redeem fees combined). USDC deposit strategy used in pcvDeposit yielded 10% APR for the year. The contract cannot redeem all the funds due as it is 125 - 100 \\* 1.1 = 15m USDC short.\n\nPutting severity to high as the contract serves requests sequentially and the last investors' funds are lost this way, i.e. in the example above all the users, who came in to redeem when contract has 15m USDC in obligations and no funds, will lose their entire deposits.\n\n### Proof of Concept\n\nContinuing the example, current low risk USDC deposit rates are circa 2.5 lower than US CPI:\n\nAAVE: <https://classic.aave.com/#/markets>\n\nCompound: <https://compound.finance/markets/USDC>\n\nUS CPI: <https://www.bls.gov/cpi/>\n\nNonCustodialPSM.redeem uses current oracle price to determine what amount of stablecoins to be paid for 1 VOLT:\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L236>\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L378-L390>\n\nNonCustodialPSM.mint does the same:\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L274>\n\n<https://github.com/code-423n4/2022-03-volt/blob/main/contracts/peg/NonCustodialPSM.sol#L357-L365>\n\nFor example, FEI protocol use a wide range of pcvDeposits, whose yields vary depending on the underlying strategy:\n\n<https://github.com/fei-protocol/fei-protocol-core/blob/develop/protocol-configuration/mainnetAddresses.ts#L164-L568>\n\nBut there are no PCV deposits whose returns are linked to CPI of any country, so mismatch (basis) risk exists, which has to be addressed.\n\n### Recommended Mitigation Steps\n\nConsider providing a way to directly inject funds from a separately held stability fund (possibly shared across all the stablecoins and corresponding pcvDeposits) in addition to pcvDeposit as its strategy alone cannot guarantee the returns needed.\n\nIdeally, the redeem and mint fees collected should go to this stability fund as well, with the possibility to retrieve them when there is a total surplus big enough.\n\nMore important, consider limiting the redeem amount to total user's share of the pcvDeposit and its stability fund part, so the deficit be visible and shared between all the users. A user can then choose either to withdraw now, obtaining less than CPI index due to current liquidity situation, or to wait for stability fund to be filled up or for pcvDeposit yield to catch up. This way no user will lose the whole deposit.\n\n**[ElliotFriedman (Volt) disputed, disagreed with High severity, and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1091995380):**\n > There is a risk of the system not being able to make everyone whole if the PCV grows too rapidly and onchain yields cannot keep up with or outcompete inflation; however, this is not a code issue, so marking as invalid.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1104682677):**\n > This is a valid concern. The warden explained why it's possible to happen and how the current implementation handled it improperly, which can make some of the users suffer an unexpected and unfair loss.\n> \n> The recommended fix is reasonable.\n> \n> I'll keep this as a `High`.\n\n**[ElliotFriedman (Volt) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1120046828):**\n > There is a 10m FEI liquidity backstop provided by the Tribe DAO, so the system would need to be live for many years without earning any yield to finally become insolvent.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/83#issuecomment-1120441273):**\n > With the new information provided by the sponsor, I now agree that the likelihood of the situation described by the warden is low. And therefore, I'm downgrading the issue from High to Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the NonCustodialPSM contract, which mints and redeems VOLT to a chosen stablecoin at the current market rate minus a fixed fee. It is assumed that the difference to be covered with pcvDeposit funds. The bug is that the growth of the CPI index can easily surpass the yield of the pcvDeposit used, so its interest cannot be guaranteed to be always greater than CPI index advancement. This means that the contract can end up in a situation where no redeem be possible, i.e. NonCustodialPSM can become insolvent.\n\nThe bug is demonstrated with an example. If the stablecoin is USDC, and investors buy/mint 100m VOLT for 100m USDC, and the CPI index growth is 30% APR for the year, when investors try to sell/redeem 100m VOLT expecting 125m USDC in return, the contract cannot redeem all the funds due as it is 15m USDC short. This means that the last investors' funds are lost, and all the users who come in to redeem when the contract has 15m USDC in obligations and no funds will lose their entire deposits.\n\nThe recommended mitigation steps include providing a way to directly inject funds from a separately held stability fund in addition to pcvDeposit, as its strategy alone cannot guarantee the returns needed. The redeem and mint fees collected should also go to this stability fund, with the possibility to retrieve them when there is a total surplus big enough. Additionally, consider limiting the redeem amount to total user's share of the pcvDeposit and its stability fund part, so the deficit be visible and shared between all the users. This way no user will lose the whole deposit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/83",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1834",
      "title": "[M-05] Updating rate limit for addresses restores their entire buffer amount",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[MultiRateLimited.sol#L280](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L280)<br>\n\nWhen the `bufferCap` is updated for an address in `_updateAddress`, the address's allowed buffer (`bufferStored`) is replenished to the entire `bufferCap`.\n\nThe address could frontrun the `updateAddress` call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.\n\n### Recommended Mitigation Steps\n\nKeep the old buffer value, capped by the new `bufferCap`:\n\n```diff\n+ uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n  rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n  rateLimitData.bufferCap = _bufferCap;\n  rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n- rateLimitData.bufferStored = _bufferCap;\n+ rateLimitData.bufferStored = min(_bufferCap, newBuffer);\n```\n\n**[ElliotFriedman (Volt) confirmed and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/27#issuecomment-1092202200):**\n > Good catch!\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the MultiRateLimited.sol code which is located at the given GitHub link. When the bufferCap is updated for an address in _updateAddress, the address's allowed buffer (bufferStored) is replenished to the entire bufferCap. This could allow an address to frontrun the updateAddress call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.\n\nThe recommended mitigation steps to fix this vulnerability is to keep the old buffer value, capped by the new bufferCap. The code should be changed to add the newBuffer variable, set the lastBufferUsedTime, bufferCap, and rateLimitPerSecond variables, and set the bufferStored to the min of the _bufferCap and newBuffer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/27",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1833",
      "title": "[M-04] `OracleRef` assumes backup oracle uses the same normalizer as main oracle",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n[OracleRef.sol#L104](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L104)<br>\n\nThe `OracleRef` assumes that the backup oracle uses the same normalizer as the main oracle.<br>\nThis generally isn't the case as it could be a completely different oracle, not even operated by Chainlink.<br>\n\nIf the main oracle fails, the backup oracle could be scaled by a wrong amount and return a wrong price which could lead to users being able to mint volt cheap or redeem volt for inflated underlying amounts.\n\n### Recommended Mitigation Steps\n\nShould there be two scaling factors, one for each oracle?\n\n**[ElliotFriedman (Volt) confirmed and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/26#issuecomment-1092201320):**\n > This is a good catch as it exposes some underlying assumptions made about backup oracles; however, we can assume that both oracles will use the same scaling factor and thus we will not need a second value for the backup oracle.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about the vulnerability in the 'OracleRef' code on GitHub. The 'OracleRef' code assumes that the backup oracle uses the same normalizer as the main oracle. However, this is not always the case as the backup oracle could be a completely different oracle, not even operated by Chainlink. If the main oracle fails, the backup oracle could be scaled by a wrong amount and return a wrong price, which could lead to users being able to mint volt cheap or redeem volt for inflated underlying amounts. To mitigate this issue, it is recommended that there should be two scaling factors, one for each oracle.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/26",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1832",
      "title": "[M-03] Div by 0",
      "impact": "MEDIUM",
      "content": "_Submitted by robee, also found by georgypetrov, cmichel, and IllIllI_\n\n[Deviation.sol#L23](https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23)<br>\n\nDivision by 0 can lead to accidentally revert,<br>\n(An example of a similar issue - <https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84>)\n\n        https://github.com/code-423n4/2022-03-volt/tree/main/contracts/utils/Deviation.sol#L23 a might be 0\n\nIt's internal function but since it is used in another internal functions that are used in public and neither of them has this protection I thought it can be considered as medium (e.g. isWithinDeviationThreshold).\n\n**[ElliotFriedman (Volt) confirmed](https://github.com/code-423n4/2022-03-volt-findings/issues/58)**\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/58#issuecomment-1100894509):**\n > It's a real issue but just like many other findings, it's unlikely to be triggered in practice.\n\n**[Jack the Pug (judge) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/58#issuecomment-1104667219):**\n > In the particular context of this project, which most of the findings won't lead to a code update, I'll keep this as a `Med`.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code found in the Deviation.sol file on the code-423n4/2022-03-volt GitHub repository. The vulnerability is a division by 0 which can lead to an accidental revert. This is similar to an issue found in the code-423n4/2021-10-defiprotocol-findings/issues/84 repository. The vulnerable code is in the internal function, however, it is also used in other internal functions that are used in public functions, and none of them have the protection against division by 0, so it is considered a medium vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/58",
      "tags": [],
      "finders": [
        "cmichel",
        "robee",
        "IllIllI",
        "georgypetrov"
      ]
    },
    {
      "id": "1831",
      "title": "[M-02] Setting new buffer does not reduce current buffer to cap",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by rayn and catchup_\n\n[RateLimited.sol#L142](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L142)<br>\n\nThe `RateLimited.setBufferCap` function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer.<br>\nMeaning, the updated buffer value can be larger than the new buffer cap which should never be the case.<br>\nActions consuming more than the new buffer cap can be performed.\n\n```solidity\nfunction _setBufferCap(uint256 newBufferCap) internal {\n    // @audit still uses old buffer cap, should set buffer first\n    _updateBufferStored();\n\n    uint256 oldBufferCap = bufferCap;\n    bufferCap = newBufferCap;\n\n\n    emit BufferCapUpdate(oldBufferCap, newBufferCap);\n}\n```\n\n### Recommended Mitigation Steps\n\nUpdate the buffer after setting the new cap:\n\n```diff\nfunction _setBufferCap(uint256 newBufferCap) internal {\n-   _updateBufferStored();\n    uint256 oldBufferCap = bufferCap;\n    bufferCap = newBufferCap;\n\n+   _updateBufferStored();\n\n    emit BufferCapUpdate(oldBufferCap, newBufferCap);\n}\n```\n\n**[ElliotFriedman (Volt) confirmed](https://github.com/code-423n4/2022-03-volt-findings/issues/29)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the RateLimited.setBufferCap function of the code-423n4/2022-03-volt repository. The vulnerability allows users to perform actions that consume more than the new buffer cap. This can be avoided by updating the buffer after setting the new cap. To do this, the code should be changed so that the _updateBufferStored() function is called after the bufferCap is set, instead of before. This will ensure that the new buffer cap is applied to the buffer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/29",
      "tags": [],
      "finders": [
        "cmichel",
        "rayn  catchup"
      ]
    },
    {
      "id": "1830",
      "title": "[M-01] `vcon` address change not persistent across protocol components",
      "impact": "MEDIUM",
      "content": "_Submitted by rayn_\n\n[Core.sol#L27](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/core/Core.sol#L27)<br>\n[CoreRef.sol#L22](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/CoreRef.sol#L22)<br>\n[CoreRef.sol#L199](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/CoreRef.sol#L199)<br>\n\n`vcon` address is allowed to be updated by `GOVERNOR` in `Core`, however, this change will not be reflected in `CoreRef._vcon`. Moreover, since `CoreRef._vcon` cannot be updated due to contract design, it is also impossible to fix this manually.\nWe are not yet sure how `vcon` will be used throughout the volt protocol, since details have not yet been made clear and code does not include related implementations. Consequently, it is impossible to estimate the exact impact. However, this desync between contracts seem dangerous enough to raise our attention, hence this report to inform the volt team about it.\n\n### Proof of Concept\n\nIn `Core`, `vcon` is allowed to be updated by GOVERNORs\n\n        function setVcon(IERC20 _vcon) external onlyGovernor {\n            vcon = _vcon;\n\n            emit VconUpdate(_vcon);\n        }\n\nBut in `CoreRef`, a contract inherited by several other ones including `NonCustodialPSM`, `GlobalRateLimitedMinter`, `ERC20CompountPCVDeposit` and `Volt`, `_vcon` is fixed upon initialization and cannot be further updated\n\n        IERC20 private immutable _vcon;\n        ...\n        constructor(address coreAddress) {\n            ...\n            _vcon = ICore(coreAddress).vcon();\n            ...\n        }\n\nThus if `GOVERNORS` ever updated `vcon` in `Core`, the state between `Core` and all other Volt protocol components will mismatch.\n\nCurrently `_vcon` is not used in any place within the Volt protocol, but judging from the description in whitepapaer, future governance will be based on it, thus any potential desync will be devastating.\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nThere are several possible solutions.\n\nThe first is to dynamically fetch `vcon` from the `Core` whenever `CoreRef` uses it, and avoid storing a static copy locally.\n\n        function vcon() public view override returns (IERC20) {\n            return _volt.vcon();\n        }\n\nThe second is to expose a public API to update `_vcon` in `CoreRef`, however, this approach might not be especially favorable since many components will require updates at once, and it is highly possible that future GOVERNORs miss some of them while doing updates.\n\n**[ElliotFriedman (Volt) disagreed with High severity and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/60#issuecomment-1092212216):**\n > Agreed this is an issue; however, if the VCON address is updated, contracts that need to reference the new value will need to be redeployed to cache this new address when CoreRef is instantiated.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/60#issuecomment-1100818437):**\n > Based on the severity of the impact, I'm downgrading this to `Medium`.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the \"Volt\" protocol. The vulnerability is related to the contract \"Core\" and its inherited contract \"CoreRef\". The \"Core\" contract allows the \"vcon\" address to be updated by the \"GOVERNOR\" but this change is not reflected in the \"CoreRef._vcon\". This desync between the contracts could be dangerous as the \"vcon\" address is used in the Volt protocol to govern the system. \n\nThe bug was found using the tools \"vim\" and \"ganache-cli\". Two possible solutions were suggested to mitigate the vulnerability. The first is to dynamically fetch the \"vcon\" address from the \"Core\" whenever the \"CoreRef\" uses it. The second is to expose a public API to update the \"_vcon\" in the \"CoreRef\". Both solutions have their own merits and drawbacks and should be evaluated before implementing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/60",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "1829",
      "title": "[H-01] Oracle price does not compound",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\n[ScalingPriceOracle.sol#L136](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L136)<br>\n[ScalingPriceOracle.sol#L113](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L113)<br>\n\nThe oracle does not correctly compound the monthly APRs - it resets on `fulfill`.<br>\nNote that the [`oraclePrice` storage variable](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L198) is only set in `_updateCPIData` as part of the oracle `fulfill` callback.<br>\nIt's set to the old price (price from 1 month ago) plus the interpolation from **`startTime`** to now.<br>\nHowever, `startTime` is **reset** in `requestCPIData` due to the `afterTimeInit` modifier, and therefore when Chainlink calls `fulfill` in response to the CPI request, the `timeDelta = block.timestamp - startTime` is close to zero again and `oraclePrice` is updated to itself again.\n\nThis breaks the core functionality of the protocol as the oracle does not track the CPI, it always resets to `1.0` after every `fulfill` instead of compounding it.<br>\nIn addition, there should also be a way for an attacker to profit from the sudden drop of the oracle price to `1.0` again.\n\n### Proof of Concept\n\nAs an example, assume `oraclePrice = 1.0 (1e18)`, `monthlyAPR = 10%`. The time elapsed is 14 days. Calling `getCurrentOraclePrice()` now would return `1.0 + 14/28 * 10% = 1.05`.\n\n*   It's now the 15th of the month and one can trigger `requestCPIData`. **This resets `startTime = now`**.\n*   Calling `getCurrentOraclePrice()` now would return `1.0` again as `timeDelta` (and `priceDelta`) is zero: `oraclePriceInt + priceDelta = oraclePriceInt = 1.0`.\n*   When `fulfill` is called it sets `oraclePrice = getCurrentOraclePrice()` which will be close to `1.0` as the `timeDelta` is tiny.\n\n### Recommended Mitigation Steps\n\nThe `oraclePrice` should be updated in `requestCPIData()` not in `fulfill`.<br>\nCover this scenario of multi-month accumulation in tests.\n\n**[ElliotFriedman (Volt) commented](https://github.com/code-423n4/2022-03-volt-findings/issues/22#issuecomment-1092068671):**\n > Oracle price does compound per this line of code: https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L197-L198\n\n**[ElliotFriedman (Volt) confirmed and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/22#issuecomment-1098397591):**\n > This is the only valid critical finding we have seen so far! Great work cmichel!\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about an issue with the oracle in the code-423n4/2022-03-volt repository. It states that the oracle does not correctly compound the monthly APRs - it resets on fulfill. This is because the oraclePrice storage variable is only set in _updateCPIData as part of the oracle fulfill callback, and startTime is reset in requestCPIData due to the afterTimeInit modifier. As a result, when Chainlink calls fulfill in response to the CPI request, the oraclePrice is updated to itself again, breaking the core functionality of the protocol.\n\nAn example is provided to demonstrate the issue. If the oraclePrice is 1.0, and the monthly APR is 10%, and the time elapsed is 14 days, then calling getCurrentOraclePrice() would return 1.0 + 14/28 * 10% = 1.05. However, if it's the 15th of the month and one triggers requestCPIData, this resets startTime to now, and calling getCurrentOraclePrice() would return 1.0 again. When fulfill is called it sets oraclePrice to getCurrentOraclePrice(), which will be close to 1.0 as the timeDelta is tiny.\n\nThe recommended mitigation steps are that the oraclePrice should be updated in requestCPIData() not in fulfill, and the scenario of multi-month accumulation should be covered in tests.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Volt Protocol",
      "source_link": "https://code4rena.com/reports/2022-03-volt",
      "github_link": "https://github.com/code-423n4/2022-03-volt-findings/issues/22",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "42539",
      "title": "[N-02]",
      "impact": "LOW",
      "content": "\nUse `uint8` for `decimals` in [QTokenStringUtils.sol#L142](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L142)\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/8#issuecomment-1102154756):**\n > Resolved in [RollaProject/quant-protocol@ebe5f2b](https://github.com/RollaProject/quant-protocol/commit/ebe5f2b83a4b8e2431e125e1d803963f7f0be03d).\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/8#issuecomment-1096516916):**\n > Score: 100\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42538",
      "title": "[N-01]",
      "impact": "LOW",
      "content": "\n`collateralTokenId` is used as `deadline` and it could be confused, it's better to rename it or add a specific comment about that.\n\n*   [Actions.sol#L110](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L110)\n*   [Actions.sol#L135](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/libraries/Actions.sol#L135)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42537",
      "title": "[M-10] Admin of the upgradeable proxy contract of `Controller.sol` can rug users",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[Controller.sol#L22-L34](https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34)<br>\n\nUse of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.\n\nThis allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.\n\nThis action can be performed by the malicious/compromised proxy admin without any restriction.\n\nConsidering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.\n\n### Proof of Concept\n\nGiven:\n\n*   collateral: `USDC`\n\n#### Rug Users' Allowances\n\n1.  Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`;\n2.  Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`;\n3.  A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;\n\n#### Rug Contract's Holdings (funds that belong to users)\n\nA malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.\n\n### Severity\n\nA smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.\n\n### Recommended Mitigation Steps\n\nConsider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.\n\nSee also our Recommendation in \\[issue #49](https://github.com/code-423n4/2022-03-rolla-findings/issues/49).\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/48#issuecomment-1102146181):**\n > Resolved with the removal of the previous access control role-based system: [RollaProject/quant-protocol#90](https://github.com/RollaProject/quant-protocol/pull/90).\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/48#issuecomment-1106040260):**\n > Assets are not directly at risk, as a governance attack must happen first. Downgraded to medium.\n\n\n\n***\n\n",
      "summary": "\nThe report highlights a vulnerability in the Controller.sol contract of the Rolla project. The use of an Upgradeable Proxy Contract Structure allows the contract's logic to be changed, potentially allowing a malicious or compromised admin to steal funds from users' wallets. This can be done without any restrictions, making it a high severity issue. The recommended mitigation step is to use a non-upgradeable contract to hold user allowances instead. The issue has been resolved by removing the previous access control system, and the severity has been decreased to medium as a governance attack must happen first for assets to be at risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/48",
      "tags": [],
      "finders": []
    },
    {
      "id": "42536",
      "title": "[M-07] Low-level transfer via `call()` can fail silently",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xDjango_\n\n[TimelockController.sol#L414-L415](https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415)<br>\n\nIn the `_call()` function in `TimelockController.sol`, a call is executed with the following code:\n\n    function _call(\n            bytes32 id,\n            uint256 index,\n            address target,\n            uint256 value,\n            bytes memory data\n        ) private {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = target.call{value: value}(data);\n            require(success, \"TimelockController: underlying transaction reverted\");\n\n            emit CallExecuted(id, index, target, value, data);\n        }\n\nPer the Solidity docs:\n\n\"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\"\n\nTherefore, transfers may fail silently.\n\n### Proof of Concept\n\nPlease find the documentation [here](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions).\n\n### Recommended Mitigation Steps\n\nCheck for the account's existence prior to transferring.\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/51#issuecomment-1102148876):**\n > The TimelockController contract was removed from the protocol.\n > \n > [RollaProject/quant-protocol#90](https://github.com/RollaProject/quant-protocol/pull/90)\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a potential issue in the `_call()` function of the `TimelockController.sol` contract. The function executes a call with the given code, but according to the Solidity docs, this call may fail silently if the account being called does not exist. The report recommends checking for the account's existence before transferring to prevent this issue. The bug has been confirmed and resolved by the Rolla team by removing the TimelockController contract from the protocol. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/51",
      "tags": [],
      "finders": []
    },
    {
      "id": "42535",
      "title": "[M-06] `OperateProxy.callFunction()` should check if the `callee` is a contract",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n[Controller.sol#L550-L558](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558)<br>\n\n```solidity\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n```\n\n[OperateProxy.sol#L10-L19](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19)<br>\n\n```solidity\n    function callFunction(address callee, bytes memory data) external override {\n        require(\n            callee != address(0),\n            \"OperateProxy: cannot make function calls to the zero address\"\n        );\n\n        (bool success, bytes memory returnData) = address(callee).call(data);\n        require(success, \"OperateProxy: low-level call failed\");\n        emit FunctionCallExecuted(tx.origin, returnData);\n    }\n```\n\nAs the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.\n\nFor example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.\n\nThe qBridge exploit (January 2022) was caused by a similar issue.\n\nAs a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), \"Address: call to non-contract\");`\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135>\n\n```solidity\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42>\n\n```solidity\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding a check and throw when the `callee` is not a contract.\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/46#issuecomment-1102149223):**\n > Resolved in [RollaProject/quant-protocol#85](https://github.com/RollaProject/quant-protocol/pull/85).\n\n\n***\n\n",
      "summary": "\nThis bug report highlights an issue with the `OperateProxy.sol` contract in the Quant Protocol. The `callFunction()` function in this contract is not payable, meaning it cannot receive funds. However, the current code allows for a successful call to be made to a non-contract address, which goes against the desired behavior. This can potentially cause malfunctions and even result in fund loss for users. The report recommends adding a check and throw when the address being called is not a contract. The issue has been confirmed and resolved by the Rolla team in their latest update. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "42534",
      "title": "[M-04] `ConfigTimeLockController` will put `QuantConfig` in a stalemate (rendering it unusable)",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xmint_\n\nThe QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:\n\n[ConfigTimelockController.sol#L28](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28)<br>\n\nI discussed with one of the devs about the use of this specific mapping :\n\n[QuantConfig.sol#L27](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27)<br>\n\nAfter discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.\n\n### Recommended Mitigation Steps\n\nIt is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:\n\n`require(minimum delay ≤MAXIMUM_DELAY, “ too high”)`\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/27#issuecomment-1102150437):**\n > Both the ConfigTimeLockController and QuantConfig contracts were removed from the protocol.\n > \n > [RollaProject/quant-protocol#90](https://github.com/RollaProject/quant-protocol/pull/90)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a contract called QuantConfig, which has some important functions for setting certain values. However, there is a problem with the timelock feature, which allows for a delay before these functions can be executed. The issue is that the minimum delay can be set to a very high value, which could make the contract unusable and prevent any changes to be made. This could have a severe impact on the configuration of the contract, especially for the rollaOrderFee which is used in a separate contract called Rolla limit order protocol. The recommended solution is to set a maximum value for the delay and ensure that the minimum delay is always below this value. The developers have confirmed and resolved the issue by removing both the ConfigTimeLockController and QuantConfig contracts from the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/27",
      "tags": [],
      "finders": []
    },
    {
      "id": "42533",
      "title": "[M-02] `COLLATERAL_MINTER_ROLE` can be granted by the deployer of `QuantConfig` and mint arbitrary amount of tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz, also found by danb, and WatchPug_\n\n        function mintCollateralToken(\n            address recipient,\n            uint256 collateralTokenId,\n            uint256 amount\n        ) external override {\n            require(\n                quantConfig.hasRole(\n                    quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                    msg.sender\n                ),\n                \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n            );\n\n            emit CollateralTokenMinted(recipient, collateralTokenId, amount);\n\n            _mint(recipient, collateralTokenId, amount, \"\");\n        }\n\nUsing the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.\n\nIf the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\n### Proof of Concept\n\n[CollateralToken.sol#L101-L117](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117)<br>\n[CollateralToken.sol#L138-L160](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160)<br>\n\n### Recommended Mitigation Steps\n\nConsider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.\n\n**[0xca11 (Rolla) confirmed](https://github.com/code-423n4/2022-03-rolla-findings/issues/12#issuecomment-1102152105)**\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/12#issuecomment-1094436993):**\n > Per sponsor comment on [#47](https://github.com/code-423n4/2022-03-rolla-findings/issues/47#issuecomment-1079940591):\n> \n> \"The roles are renounced as per our deployment config covered in the docs. But this bug is still valid as the role OPTIONS_MINTER_ROLE can be reassigned\".\n> \n> Taking this one as main, with the vulnerability being that several of the MINTER and BURNER roles can be reassigned and have unnecessary powers that can be used to rug users.\n\n**[0xca11 (Rolla) resolved and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/12#issuecomment-1102152105):**\n > All roles were removed from the protocol, and now only the Controller contract can mint QTokens and CollateralTokens.\n > \n > [RollaProject/quant-protocol#90](https://github.com/RollaProject/quant-protocol/pull/90)\n\n\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the mintCollateralToken() function of the CollateralToken contract. This function allows an address with the COLLATERAL_MINTER_ROLE to mint an unlimited amount of collateral tokens. If the private key of the deployer or an address with this role is compromised, it poses a risk of centralization. The report recommends removing the COLLATERAL_MINTER_ROLE and making the Controller contract the only minter. The bug has been confirmed and resolved by the Rolla project. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/12",
      "tags": [],
      "finders": []
    },
    {
      "id": "42532",
      "title": "[M-01] No use of upgradeable SafeERC20 contract in `Controller.sol`",
      "impact": "MEDIUM",
      "content": "_Submitted by jayjonah8_\n\nController.sol makes use of Open Zeppelins `ReentrancyGuardUpgradeable.sol` in the file but does not use an upgradeable version of SafeERC20.sol\n\n### Proof of Concept\n\n[Controller.sol#L5](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L5)<br>\n\n### Recommended Mitigation Steps\n\nMake use of Open Zeppelins [upgradeable version of the SafeERC20.sol contract](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol).\n\n**[0xca11 (Rolla) resolved and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/5#issuecomment-1102153150):**\n > Resolved in [RollaProject/quant-protocol#76](https://github.com/RollaProject/quant-protocol/pull/76).\n\n\n***\n\n",
      "summary": "\nThe bug report is about a contract called Controller.sol which uses a library called ReentrancyGuardUpgradeable.sol. However, it does not use an upgradeable version of another library called SafeERC20.sol. This can potentially cause security issues. The report suggests using an upgradeable version of SafeERC20.sol to mitigate this problem. The bug has been resolved and commented on by the project team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/5",
      "tags": [],
      "finders": []
    },
    {
      "id": "42531",
      "title": "[H-04] `EIP712MetaTransaction.executeMetaTransaction()` failed txs are open to replay attacks",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nAny transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).\n\nIn the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.\n\nAs a result, the same tx can be replayed by anyone, using the same signature.\n\n[EIP712MetaTransaction.sol#L86](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86)<br>\n\n```solidity\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n```\n\nSee also the implementation of OpenZeppelin's `MinimalForwarder`:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66>\n\n### Proof of Concept\n\nGiven:\n\n*   The collateral is USDC;\n*   Alice got `10,000 USDC` in the wallet.\n\n1.  Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`;\n2.  Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob;\n3.  The MetaTransaction submited by Alice in step 1 get executed but failed;\n4.  A few days later, Bob sent `1,000 USDC` to Alice;\n5.  The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.\n\nAlice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.\n\n### Recommended Mitigation Steps\n\nFailed txs should still increase the nonce.\n\nWhile implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/45#issuecomment-1102144427):**\n > Meta transactions replay and insufficient gas griefing attacks are now prevented since [RollaProject/quant-protocol#80](https://github.com/RollaProject/quant-protocol/pull/80).\n\n\n\n***\n \n",
      "summary": "\nThis bug report highlights an issue with the current implementation of a smart contract called EIP712MetaTransaction. This contract allows users to submit transactions that are based on other actions or time-dependent conditions. However, if a transaction fails, the entire transaction is reverted and the nonce, which is used to prevent replay attacks, remains unchanged. This means that the same transaction can be replayed by anyone with the same signature. This can lead to unexpected fund losses, as demonstrated in a proof of concept. The recommended mitigation steps include implementing a change to increase the nonce even for failed transactions and adding a check for sufficient gas to prevent \"insufficient gas griefing attacks.\" This bug has been confirmed and resolved by the RollaProject team in their quant-protocol code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "42530",
      "title": "[H-03]  Wrong implementation of `EIP712MetaTransaction`",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n1.  `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).\n\n[EIP712MetaTransaction.sol#L102-L114](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114)<br>\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\nOtherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53>\n\n```solidity\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n```\n\nSee also: <https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1>\n\n2.  `initializer` can only be called once, it can not be \"called once after every upgrade\".\n\n[EIP712MetaTransaction.sol#L102-L114](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114)<br>\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\n3.  A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.\n\nSee the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28>\n\n```solidity\nabstract contract EIP712Upgradeable is Initializable {\n    // ...\n}\n```\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nabstract contract EIP712MetaTransaction is EIP712Upgradeable {\n    // ...\n}\n```\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function __EIP712MetaTransaction_init(string memory _name, string memory _version)\n        internal\n        onlyInitializing\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/43#issuecomment-1102143348):**\n > Resolved in [RollaProject/quant-protocol@25112fa](https://github.com/RollaProject/quant-protocol/commit/25112fa93a650f7b889e8472faf75dd5c471cdf2), but upgradeability was later removed as per [RollaProject/quant-protocol#90](https://github.com/RollaProject/quant-protocol/pull/90).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with a contract called `EIP712MetaTransaction`. The contract is meant to be inherited by other contracts, but there is a problem with its `initializer` function. The function should not use the `initializer` modifier, but instead use the `onlyInitializing` modifier. This is because when the `initializer` function is called by another contract's `initializer` function, it will be mistaken as being reentered and will be reverted. This can be fixed by changing the `initializer` function to `onlyInitializing` and adding an `internal` modifier. Additionally, the contract should be declared as `abstract` since it is not meant to be deployed on its own. This issue has been resolved in the `RollaProject/quant-protocol` repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "42529",
      "title": "[H-01] Incorrect strike price displayed in name/symbol of qToken",
      "impact": "HIGH",
      "content": "_Submitted by rayn_\n\n`_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.\n\n### Proof of Concept\n\nERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.\n\nThe bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.\n\nThe exploit can be outlined through the following steps:\n\n*   Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`\n\n*   Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L38><br>\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L90><br>\n\n        function _qTokenName(\n            address _quantConfig,\n            address _underlyingAsset,\n            address _strikeAsset,\n            uint256 _strikePrice,\n            uint256 _expiryTime,\n            bool _isCall\n        ) internal view virtual returns (string memory tokenName) {\n            string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n            string memory displayStrikePrice = _displayedStrikePrice(\n                _strikePrice,\n                _strikeAsset\n            );\n    \t\t\n            ...\n    \t\t\n            tokenName = string(\n                abi.encodePacked(\n                    \"ROLLA\",\n                    \" \",\n                    underlying,\n                    \" \",\n                    _uintToChars(day),\n                    \"-\",\n                    monthFull,\n                    \"-\",\n                    Strings.toString(year),\n                    \" \",\n                    displayStrikePrice,\n                    \" \",\n                    typeFull\n                )\n            );\n        }\n\n```\n\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n```\n\n*   `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L136><br>\n\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n            internal\n            view\n            virtual\n            returns (string memory)\n        {\n            uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n            uint256 strikePriceScale = 10**strikePriceDigits;\n            uint256 remainder = _strikePrice % strikePriceScale;\n            uint256 quotient = _strikePrice / strikePriceScale;\n            string memory quotientStr = Strings.toString(quotient);\n\n            if (remainder == 0) {\n                return quotientStr;\n            }\n\n            uint256 trailingZeroes;\n            while (remainder % 10 == 0) {\n                remainder /= 10;\n                trailingZeroes++;\n            }\n\n            // pad the number with \"1 + starting zeroes\"\n            remainder += 10**(strikePriceDigits - trailingZeroes);\n\n            string memory tmp = Strings.toString(remainder);\n            tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n            return string(abi.encodePacked(quotientStr, \".\", tmp));\n        }\n\n*   However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`\n\n<https://github.com/RollaProject/quant-protocol/blob/98639a3/contracts/options/QTokenStringUtils.sol#L206><br>\n\n        function _slice(\n            string memory _s,\n            uint256 _start,\n            uint256 _end\n        ) internal pure virtual returns (string memory) {\n            uint256 range = _end - _start;\n            bytes memory slice = new bytes(range);\n            for (uint256 i = 0; i < range; ) {\n                slice[i] = bytes(_s)[_start + 1];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return string(slice);\n        }\n\n*   The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.\n\n### Recommended Mitigation Steps\n\nFix the bug in the `_slice()`\n\n        function _slice(\n            string memory _s,\n            uint256 _start,\n            uint256 _end\n        ) internal pure virtual returns (string memory) {\n            uint256 range = _end - _start;\n            bytes memory slice = new bytes(range);\n            for (uint256 i = 0; i < range; ) {\n                slice[i] = bytes(_s)[_start + i];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            return string(slice);\n        }\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/28#issuecomment-1102139409):**\n > Resolved in [RollaProject/quant-protocol#77](https://github.com/RollaProject/quant-protocol/pull/77)\n\n\n***\n\n",
      "summary": "\nThe `slice()` function in `options/QTokenStringUtils.sol` is not working correctly, causing a string to be displayed incorrectly in the name and symbol of qTokens. This can lead to confusion over the actual value of options. The bug has been identified and a fix has been recommended. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/28",
      "tags": [],
      "finders": []
    },
    {
      "id": "5270",
      "title": "[L-06]",
      "impact": "LOW",
      "content": "\nIt's possible to call the method [addAssetOracle](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L25) multiple times with the same `_asset`, if you call `addAssetOracle` with empty `_oracle` it will bypass the [assetOracles\\[\\_asset\\] == address(0)](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/pricing/oracle/ProviderOracleManager.sol#L34), and it will be possible to call again the `addAssetOracle` with different values. It will produce a mismatch with the reality and `assets`\n\nIt is mandatory to add a require to verify that the `_oracle` is not empty.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-06",
      "tags": [],
      "finders": []
    },
    {
      "id": "5269",
      "title": "[L-05]",
      "impact": "LOW",
      "content": "\nUse a buggy solidity version with immutables.\n\nThe contract uses immutable, and this solidity version defined in the pragma has some issues with them, as you can see [here](https://github.com/ethereum/solidity/blob/develop/Changelog.md#089-2021-09-29).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-05",
      "tags": [],
      "finders": []
    },
    {
      "id": "5268",
      "title": "[L-04]",
      "impact": "LOW",
      "content": "\nWhen calling [\\_getMonth](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L255) with a value greater than 12 \"December\" is returned, it's best to make sure the value is as expected.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-04",
      "tags": [],
      "finders": []
    },
    {
      "id": "5267",
      "title": "[L-03]",
      "impact": "LOW",
      "content": "\nIt's possible to approve with [metaSetApprovalForAll](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L218-L219) an empty address for any operator, `ecrecover` is not checked to return `address(0)`, so using `owner=address(0)` it is possible to approve or reject empty owners for any operator. It's recommended to use ECDSA from open-zeppelin.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-03",
      "tags": [],
      "finders": []
    },
    {
      "id": "5266",
      "title": "[L-02]",
      "impact": "LOW",
      "content": "\nIt's possible to call the method [createCollateralToken](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L61) multiple times with the same `_qTokenAddress`, if you call `createCollateralToken` with empty `_qTokenAddress` it will bypass the [require(idToInfo\\[id\\].qTokenAddress == address(0))](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L81), and it will be possible to call again the `createCollateralToken` with different values. It will produce a mismatch with the reality and `collateralTokenIds`.\n\nIt is mandatory to add a require to verify that the `_qTokenAddress` is not empty.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-02",
      "tags": [],
      "finders": []
    },
    {
      "id": "5265",
      "title": "[L-01]",
      "impact": "LOW",
      "content": "\nIt's possible to call the method [addAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L60) multiple times with the same `_underlying`, if you call `addAsset` with empty `symbol` it will bypass the [validAsset](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L37) modifier, and it will be possible to call again the `addAsset` with different values. It will produce a mismatch with the reality and `getAssetsLength`.\n\nThis could cause a loss of funds if it is not verified before that this `symbol` is other than empty. It is mandatory to add a require to verify that the `symbol` is not empty. It's also recommended to add a require in [\\_assetSymbol](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L24) to ensure non-existence tokens are returned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "#l-01",
      "tags": [],
      "finders": []
    },
    {
      "id": "1695",
      "title": "[M-10] Admin of the upgradeable proxy contract of Controller.sol can rug users",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34\n\n\n## Vulnerability details\n\nUse of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.\n\nThis allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.\n\nThis action can be performed by the malicious/compromised proxy admin without any restriction. \n\nConsidering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.\n\n### PoC\n\nGiven:\n\n- collateral: `USDC`\n\n#### Rug Users' Allowances\n\n1. Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`;\n2. Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`;\n3. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;\n\n#### Rug Contract's Holdings (funds that belongs to users)\n\nA malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.\n\n### Severity\n\nA smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.\n\n### Recommendation\n\nConsider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.\n\nSee also the Recommendation of [WP-H7].",
      "summary": "\nA bug was identified in a smart contract called Controller.sol, which uses an upgradeable proxy contract structure that allows the logic of the contract to be changed. This makes it possible for a malicious or compromised proxy admin to take funds from users' wallets up to the allowance limit without any restriction. This poses a significant risk as the contract is used for accounting of collateral and longshort tokens. \n\nA proof of concept (PoC) was provided to demonstrate the vulnerability. In the PoC, Alice and Bob both approved and minted options positions with USDC. A malicious/compromised proxy admin could then call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets. The malicious/compromised proxy admin could also call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.\n\nThe severity of this issue was marked as High, as the impact of the vulnerability is severe (all the funds in the contract and funds in users' wallets can be stolen). The recommendation was to consider using the non-upgradeable CollateralToken contract to hold user's allowances instead.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/48",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1694",
      "title": "[M-09] Spreads can be minted with a deactivated oracle",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nWhen deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.\n\nThis way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.\n\n### Proof of Concept\n\nOracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in \\_mintOptionsPosition().\n\nIt isn't checked during spreads creation:\n\n[FundsCalculator.sol#L91-L117](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117)<br>\n\nIn other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.\n\n### Recommended Mitigation Steps\n\nIf oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:\n\n[Controller.sol#L188-L197](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197)<br>\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/66#issuecomment-1102147878):**\n > Resolved in [RollaProject/quant-protocol#81](https://github.com/RollaProject/quant-protocol/pull/81).\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the FundsCalculator.sol library. When deactivateOracle() is called for an oracle in OracleRegistry, it is still available for option spreads minting. This means that users who already possess an option linked to a deactivated oracle can still mint new options linked to it as a part of option spreads. This is because the oracle active state is not checked during spreads creation, only during option creation and minting. This vulnerability allows users to surpass the deactivation, and economically it is close to vanilla options. \n\nThe recommended mitigation step for this vulnerability is to require oracle to be active on spreads minting in the same way it’s done for vanilla option minting. This can be done by adding a check to the code of the Controller.sol library.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/66",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1693",
      "title": "[M-08] Arbitrary code can be run with Controller as msg.sender",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nA malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(\\_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.\n\nThe Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.\n\n### Proof of Concept\n\nWhen the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal \\_qTokenPermit:\n\n[Controller.sol#L91-L92](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92)<br>\n\n\\_qTokenPermit calls the IQToken(\\_qToken) address provided without performing any additional checks:\n\n[Controller.sol#L497-L516](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516)<br>\n\nThis way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.\n\n### Recommended Mitigation Steps\n\nGiven that QToken can be called directly please examine the need for QTokenPermit ActionType.\n\nIf current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(\\_qToken) before calling the address provided.\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/65#issuecomment-1102148357):**\n > Fixed in [RollaProject/quant-protocol#82](https://github.com/RollaProject/quant-protocol/pull/82).\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the Controller contract of the 2022-03-rolla repository on GitHub. This bug allows malicious users to call the Controller's operate function with ActionType.QTokenPermit, providing a precooked contract address as qToken. This contract address will be called by the Controller contract with IQToken(_qToken).permit(). The Controller is an asset bearing contract and it will be the msg.sender in this arbitrary permit() function, which is a setup that should be avoided. \n\nThe bug is caused by the Controller's operate function parsing the arguments with the Actions library and then calling the internal _qTokenPermit. This function then calls the IQToken(_qToken) address provided without performing any additional checks. This allows for a precooked contract to be used which meets the requirement of the IQToken interface and having a permit function with a given signature.\n\nThe recommended mitigation steps for this bug is to examine the need for the QTokenPermit ActionType. If this approach is based on UI convenience and should be kept, then consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/65",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1692",
      "title": "[M-07] Low-level transfer via call() can fail silently",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415\n\n\n## Vulnerability details\n\n## Impact\nIn the `_call()` function in `TimelockController.sol`, a call is executed with the following code:\n\n```\nfunction _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n```\n\nPer the Solidity docs:\n\n\"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\"\n\n\nTherefore, transfers may fail silently.\n\n## Proof of Concept\nPlease find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions\n\n## Tools Used\nManual review.\n\n## Recommended Mitigation Steps\nCheck for the account's existence prior to transferring.",
      "summary": "\nThis bug report is about a vulnerability in the `_call()` function in the `TimelockController.sol` file. The code in the function executes a call without checking for the existence of the account that it is transferring to. As a result, the transfer may fail silently, leading to unexpected behavior. The code can be found at the link provided in the report. \n\nThe vulnerability was discovered through manual review. Documentation to support this can be found at the link provided in the report. The recommended mitigation step is to check for the account's existence prior to transferring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/51",
      "tags": [],
      "finders": [
        "0xDjango"
      ]
    },
    {
      "id": "1691",
      "title": "[M-06] OperateProxy.callFunction() should check if the callee is a contract",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558\n\n```solidity\n    /// @notice Allows a sender/signer to make external calls to any other contract.\n    /// @dev A separate OperateProxy contract is used to make the external calls so\n    /// that the Controller, which holds funds and has special privileges in the Quant\n    /// Protocol, is never the `msg.sender` in any of those external calls.\n    /// @param _callee The address of the contract to be called.\n    /// @param _data The calldata to be sent to the contract.\n    function _call(address _callee, bytes memory _data) internal {\n        IOperateProxy(operateProxy).callFunction(_callee, _data);\n    }\n```\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19\n\n```solidity\n    function callFunction(address callee, bytes memory data) external override {\n        require(\n            callee != address(0),\n            \"OperateProxy: cannot make function calls to the zero address\"\n        );\n\n        (bool success, bytes memory returnData) = address(callee).call(data);\n        require(success, \"OperateProxy: low-level call failed\");\n        emit FunctionCallExecuted(tx.origin, returnData);\n    }\n```\n\nAs the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.\n\nFor example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.\n\nThe qBridge exploit (January 2022) was caused by a similar issue.\n\nAs a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), \"Address: call to non-contract\");`\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135\n\n```solidity\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n```\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42\n\n```solidity\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n```\n\n### Recommendation\n\nConsider adding a check and throw when the `callee` is not a contract.",
      "summary": "\nThis bug report is about the `OperateProxy.sol#callFunction()` function in the Quant Protocol. This function allows a sender/signer to make external calls to any other contract, but does not check if the callee is a contract or not. If the callee is not a contract, the call will still return `success: true` instead of `success: false`, which can potentially break the caller's assumption and malfunction features or even cause fund loss to users. As a reference, OpenZeppelin's `Address.functionCall()` will check and throw an error when the callee is not a contract. The report recommends adding a similar check to the `OperateProxy.sol#callFunction()` function to prevent potential problems.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/46",
      "tags": [
        "Token Existence",
        "Delegate"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1690",
      "title": "[M-05] QTokens with the same symbol will lead to mistakes",
      "impact": "MEDIUM",
      "content": "_Submitted by IllIllI_\n\nThe [`README.md`](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70) states:\n\n> Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.\n\nIt is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.\n\n### Impact\n\nCurrently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.\n\nThe 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.\n\n### Proof of Concept\n\n```solidity\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n```\n\n[QTokenStringUtils.sol#L115-L130](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130)<br>\n\n```solidity\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n```\n\n[QTokenStringUtils.sol#L181-L199](https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199)<br>\n\n### Recommended Mitigation Steps\n\nInclude the full year in the token's symbol.\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/38#issuecomment-1102149864):**\n > Resolved in [RollaProject/quant-protocol#86](https://github.com/RollaProject/quant-protocol/pull/86).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to the Rolla protocol, which is a smart contract trading platform. The protocol allows users to mint tokens, which are used to trade with other users. The tokens are identified by the token's symbol and name, which are generated automatically. The issue is that the token's symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a token with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. This can lead to users buying the wrong option on a DEX or making a mistake during minting. The recommended mitigation step is to include the full year in the token's symbol. This bug was identified through code inspection.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/38",
      "tags": [],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "1689",
      "title": "[M-04] ConfigTimeLockController will put QuantConfig in a stalemate (rendering it unusable) ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27\n\n\n## Vulnerability details\n\nThe QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28\n\n I discussed with one of the devs about the use of this specific mapping :\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27\n\nAfter discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.\n\nIt is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:\n\nrequire(minimum delay ≤MAXIMUM_DELAY, “ too high”)",
      "summary": "\nThis bug report is about the QuantConfig contract which is subjected to a timelock before setters such as setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole() can be executed. The issue is that in the ConfigTimelockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max, which could render the QuantConfig contract unusable. After discussion with one of the developers, it was understood that the values are for the rollaOrderFee which is part of the limit order protocol contract. This means that the configuration setting within QuantConfig will be severely impacted and the old percentage fees won't be able to be changed. To solve this issue, it is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/27",
      "tags": [],
      "finders": [
        "0xmint"
      ]
    },
    {
      "id": "1688",
      "title": "[M-03] Usage of deprecated Chainlink functions",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum, also found by 0x1f8b, cccz, and WatchPug_\n\nThe Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.\n\n### Proof of Concept\n\n[ChainlinkOracleManager.sol#L120](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120)<br>\n\n[ChainlinkFixedTimeOracleManager.sol#L81](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81)<br>\n\n[ChainlinkFixedTimeOracleManager.sol#L84](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84)<br>\n\nGo to <https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code> and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.\n\n### Recommended Mitigation Steps\n\nSwitch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata).\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/17#issuecomment-1102151105):**\n > Fixed in [RollaProject/quant-protocol#89](https://github.com/RollaProject/quant-protocol/pull/89).\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Chainlink functions `latestAnswer()` and `getAnswer()` being deprecated. This means that they should no longer be used in the code. Instead, the functions `latestRoundData()` and `getRoundData()` should be used. To verify this, one can go to the Etherscan website and search for `latestAnswer()` or `getAnswer()` to find the deprecation notice. The recommended mitigation step for this issue is to switch to `latestRoundData()` as described in the Chainlink documentation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/17",
      "tags": [],
      "finders": [
        "cccz",
        "WatchPug",
        "Ruhum",
        "0x1f8b"
      ]
    },
    {
      "id": "1687",
      "title": "[M-02] COLLATERAL_MINTER_ROLE can be granted by the deployer of QuantConfig and mint arbitrary amount of tokens",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117\n\n\n## Vulnerability details\n\n## Impact\n```\n    function mintCollateralToken(\n        address recipient,\n        uint256 collateralTokenId,\n        uint256 amount\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n        );\n\n        emit CollateralTokenMinted(recipient, collateralTokenId, amount);\n\n        _mint(recipient, collateralTokenId, amount, \"\");\n    }\n```\n\nUsing the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.\n\nIf the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.\n\nWe believe this is unnecessary and poses a serious centralization risk.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160\n## Tools Used\nNone\n\n## Recommended Mitigation Steps\nConsider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.",
      "summary": "\nThis bug report is about a vulnerability in the mintCollateralToken() function of the CollateralToken smart contract. Using this function, an address with the COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens. This poses a serious centralization risk, as if the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens. The proof of concept can be found at the provided GitHub links.\n\nThe recommended mitigation steps are to remove the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter. This will ensure that only the owner can mint tokens and therefore reduce the risk of malicious actors minting unlimited tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/12",
      "tags": [],
      "finders": [
        "cccz",
        "danb",
        "WatchPug"
      ]
    },
    {
      "id": "1686",
      "title": "[M-01] No use of upgradeable SafeERC20 contract in Controller.sol",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L5\n\n\n## Vulnerability details\n\n## Impact\nController.sol makes use of Open Zeppelins ReentrancyGuardUpgradeable.sol in the file but does not use an upgradeable version of SafeERC20.sol \n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L5\n\n## Tools Used\nManual code review \n\n## Recommended Mitigation Steps\nMake use of Open Zeppelins upgradeable version of the SafeERC20.sol contract:  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol",
      "summary": "\nThis bug report concerns a vulnerability found in the Controller.sol file of the 2022-03-rolla repository on Github. The vulnerability is due to the use of Open Zeppelins ReentrancyGuardUpgradeable.sol, but not using an upgradeable version of SafeERC20.sol. The bug was discovered through manual code review and the proof of concept can be found at the link provided. The recommended mitigation steps to fix this bug are to make use of Open Zeppelins upgradeable version of the SafeERC20.sol contract, which is also provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/5",
      "tags": [],
      "finders": [
        "jayjonah8"
      ]
    },
    {
      "id": "1685",
      "title": "[H-04] EIP712MetaTransaction.executeMetaTransaction() failed txs are open to replay attacks",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86\n\n\n## Vulnerability details\n\nAny transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).\n\nIn the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.\n\nAs a result, the same tx can be replayed by anyone, using the same signature.\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86\n\n```solidity\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n```\n\nSee also the implementation of OpenZeppelin's `MinimalForwarder`:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66\n\n### PoC\n\nGiven:\n\n- The collateral is USDC;\n- Alice got `10,000 USDC` in the wallet.\n\n1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`;\n2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob;\n3. The MetaTransaction submited by Alice in step 1 get executed but failed;\n4. A few days later, Bob sent `1,000 USDC` to Alice;\n5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.\n\nAlice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.\n\n### Recommendation\n\nFailed txs should still increase the nonce.\n\nWhile implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).",
      "summary": "\nThis bug report is about an issue found in the implementation of the EIP712MetaTransaction.sol contract. The issue is that when a transaction fails due to certain conditions, the nonce of the transaction does not get incremented. This allows anyone to replay the same transaction with the same signature, which can lead to unexpected fund loss.\n\nTo demonstrate the issue, an example is given. Alice has 10,000 USDC in her wallet. She submits a MetaTransaction to operate and _mintOptionsPosition with 10,000 USDC. Before the MetaTransaction is executed, Alice sends 1,000 USDC to Bob. The MetaTransaction submitted by Alice fails, and a few days later Bob sends 1,000 USDC to Alice. The attacker can then replay the MetaTransaction that failed to execute and succeed, leading to Alice's 10,000 USDC being spent unexpectedly and potentially causing fund loss.\n\nThe recommendation given to resolve this issue is to ensure that failed transactions still increase the nonce. Additionally, it is suggested to add a check to require sufficient gas to be paid to prevent \"insufficient gas griefing attack\".",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/45",
      "tags": [
        "Replay Attack",
        "Nonce"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1684",
      "title": "[H-03]  Wrong implementation of EIP712MetaTransaction",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n\n## Vulnerability details\n\n1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\nOtherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53\n\n```solidity\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n```\n\nSee also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1\n\n\n2. `initializer` can only be called once, it can not be \"called once after every upgrade\".\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\n\n3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.\n\nSee the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28\n\n```solidity\nabstract contract EIP712Upgradeable is Initializable {\n    // ...\n}\n```\n\n### Recommendation\n\nChange to:\n\n```solidity\nabstract contract EIP712MetaTransaction is EIP712Upgradeable {\n    // ...\n}\n```\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function __EIP712MetaTransaction_init(string memory _name, string memory _version)\n        internal\n        onlyInitializing\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```",
      "summary": "\nThis bug report is about a utils contract called `EIP712MetaTransaction`. It is intended to be inherited by concrete (actual) contracts, and its initializer function should not use the `initializer` modifier, instead it should use the `onlyInitializing` modifier. This is because the `initializer` modifier can only be called once, and not after every upgrade. The utils contract should also be declared as `abstract` and its `initializer` function should be `internal`. The recommendation is to change the contract to `abstract` and the `initializer` function to `internal` and `onlyInitializing`.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/43",
      "tags": [
        "onlyInitializing modifier",
        "initializer modifier",
        "Initializer"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1683",
      "title": "[H-02] Mint spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion",
      "impact": "HIGH",
      "content": "_Submitted by rayn_\n\n[QuantMath.sol#L137](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137)<br>\n[QuantMath.sol#L151](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151)<br>\n[SignedConverter.sol#L28](https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28)<br>\n\nThis report presents 2 different incorrect behaviour that can affect the correctness of math calculations:\n\n1.  Unattended Implicit rounding in QuantMath.sol `div` and `mul`\n2.  Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`\n\nBug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.\n\n### Proof of Concept\n\nIn this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.\n\nBefore getting started, we should go over an important concept while dealing with fixed point number -- rounding.\nMath has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of \"money\" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.\n\nIn QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never \"lose tokens\" due to rounding.\n\n    library QuantMath {\n        ...\n        struct FixedPointInt {\n            int256 value;\n        }\n\n        int256 private constant _SCALING_FACTOR = 1e27;\n        uint256 private constant _BASE_DECIMALS = 27;\n\n        ...\n\n        function toScaledUint(\n            FixedPointInt memory _a,\n            uint256 _decimals,\n            bool _roundDown\n        ) internal pure returns (uint256) {\n            uint256 scaledUint;\n\n            if (_decimals == _BASE_DECIMALS) {\n                scaledUint = _a.value.intToUint();\n            } else if (_decimals > _BASE_DECIMALS) {\n                uint256 exp = _decimals - _BASE_DECIMALS;\n                scaledUint = (_a.value).intToUint() * 10**exp;\n            } else {\n                uint256 exp = _BASE_DECIMALS - _decimals;\n                uint256 tailing;\n                if (!_roundDown) {\n                    uint256 remainer = (_a.value).intToUint() % 10**exp;\n                    if (remainer > 0) tailing = 1;\n                }\n                scaledUint = (_a.value).intToUint() / 10**exp + tailing;\n            }\n\n            return scaledUint;\n        }\n        ...\n    }\n\nIn practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.\n\n        function mul(FixedPointInt memory a, FixedPointInt memory b)\n            internal\n            pure\n            returns (FixedPointInt memory)\n        {\n            return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);\n        }\n\n\n        function div(FixedPointInt memory a, FixedPointInt memory b)\n            internal\n            pure\n            returns (FixedPointInt memory)\n        {\n            return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);\n        }\n\nNow let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.\n\n*   `Controller._mintSpread`\n    *   `QuantCalculator.getCollateralRequirement`\n        *   `FundsCalculator.getCollateralRequirement`\n            *   `FundsCalculator.getOptionCollateralRequirement`\n                *   `FundsCalculator.getCallCollateralRequirement`\n                    *   scales `_qTokenToMintStrikePrice` from\n                        `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n                    *   scales `_qTokenForCollateralStrikePrice` from\n                        `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n                    *   `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`\n                *   scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`\n                *   `collateralAmount = _optionsAmount.mul(collateralPerOption)`\n            *   uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral\n        *   scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`\n\nIf we extract all the math related stuff, it would be something like below\n\n    def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n            X1 = _qTokenToMintStrikePrice * 10^19\n            X2 = _qTokenForCollateralStrikePrice * 10^19\n            X3 = _optionsAmount * 10^9\n\n            assert X1 < X2          #credit spread\n\n            Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div\n            Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n            Z = Y2 // 10^9\n            if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)\n                    Z+=1\n            return Z\n\nBoth implicit round downs can be abused, but we shall focus on the `mul` one here.\nAssume we follow the following actions\n\n1.  create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH`<br>\n2.  create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH`<br>\n3.  mint `10^-18` (1 under 18 decimals) option `A`<br>\n    3-1. `pay 1 eth`<br>\n4.  mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral<br>\n    4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`<br>\n    4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`<br>\n    4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`<br>\n    4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`<br>\n    4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`<br>\n    4-6. `Z = Y2 // 10^9 = 0`<br>\n    4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged<br>\n\nWe minted a call credit spread without paying any fee.\n\nNow let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.\n\nFor neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.\n\n    def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n            X1 = _qTokenToMintStrikePrice * 10^19\n            X2 = _qTokenForCollateralStrikePrice * 10^19\n            X3 = _optionsAmount * 10^9\n\n            assert X1 < X2          #credit spread\n\n            Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div\n            Y2 = Y1 * X3 // 10^27   #implicit round down due to mul\n\n            Z = Y2 // 10^9  #explicit scaling\n            return Z\n\nThere are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling.\nTo achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option.\nThen we neutralize all those spreads at once, the calculation is shown below.\n\n1.  neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`<br>\n    4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`<br>\n    4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`<br>\n    4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`<br>\n    4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`<br>\n    4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`<br>\n    4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`<br>\n\nAnd with this, we managed to generate 10^-18 weth of revenue.\n\nThis approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.\n\nIt's time to start looking at the second bug.\n\nRecall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.\n\n        function intToUint(int256 a) internal pure returns (uint256) {\n            if (a < 0) {\n                return uint256(-a);\n            } else {\n                return uint256(a);\n            }\n        }\n\nWhere is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.\n\n1.  mint a `qTokenLong` option\n2.  mint a `qTokenShort` spread with `qTokenLong` as collateral\n3.  wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort\n\n<!---->\n\n    ----------- qTokenLong strike price\n\n    ----------- expiryPrice\n\n    ----------- qTokenShort strike price\n\nHere is the outline of the long waited claimCollateral for spread.\n\n*   `Controller._claimCollateral`\n    *   `QuantCalculator.calculateClaimableCollateral`\n        *   `FundsCalculator.getSettlementPriceWithDecimals`\n        *   `FundsCalculator.getPayout` for qTokenLong\n            *   qTokenLong strike price is above expiry price, worth 0\n        *   `FundsCalculator.getCollateralRequirement`\n            *   This part we saw earlier, omit details\n        *   `FundsCalculator.getPayout` for qTokenShort\n            *   uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral\n            *   `FundsCalculator.getPayoutAmount` for qTokenShort\n                *   scale `_strikePrice` from\n                    `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`\n                *   scale `_expiryPrice.price` from\n                    `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`\n                *   scale `_amount` from\n                    `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`\n                *   `FundsCalculator.getPayoutForCall` for qTokenShort\n                    *   `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`\n        *   `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`\n        *   scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`\n\nAgain, we summarize the math part into a function.\n\n    def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):\n\n            def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):\n                    X1 = _qTokenToMintStrikePrice * 10^19\n                    X2 = _qTokenForCollateralStrikePrice * 10^19\n                    X3 = _optionsAmount * 10^9\n\n                    Y1 = (X2 - X1) * 10^27 // X2\n                    Y2 = Y1 * X3 // 10^27\n                    return Y2\n\n            def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):\n                    X1 = _strikePrice * 10^19\n                    X2 = _expiryPrice * 10^19\n                    X3 = _amount * 10^9\n\n                    Y1 = (X2-X1) * X3 // 10^27\n                    Y2 = Y1 * 10^27 // X2\n                    return Y2\n\n\n            assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice\n\n            A1 = payoutFromLong = 0\n            A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)\n            A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)\n\n            B1 = A1 + A2 - A3\n\n            Z = abs(B1) // 10^9\n            return Z\n\nGiven the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.\n\n    X = _qTokenLongStrikePrice (8 decimals)\n    Y = _expiryPrice (8 decimals)\n    Z = _qTokenShortStrikePrice (8 decimals)\n    A = _amount (scaled to 27 decimals)\n\n    assert X>Y>Z>0\n    assert X,Y,Z are integers\n    assert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y)\n\nNotice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.\n\nUtilizing this, we turn to solve the equation of:\n\n    (X-Z) / X - (Y-Z) / Y < 10^-27\n    => Z / Y - Z / X < 10^-27\n    => (Z = 1 yields best solution)\n    => 1 / Y - 1 / X < 10^-27\n    => X - Y < X * Y * 10^-27\n    => 0 < X * Y - 10^27 * X + 10^27 * Y\n\n    => require X > Y, so model Y as X - B, where B > 0 and B is an integer\n    => 0 < X^2 - B * X - 10^27 * B\n\nIt is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.\n\nApart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.\n\n    0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B\n    => (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B\n    => B <= 9\n\nNow we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function.\n\n1.  in `callCreditSpreadCollateralRequirement`<br>\n    1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`<br>\n    1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`<br>\n    1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`<br>\n    1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`<br>\n    1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10`<br>\n2.  in `callCreditSpreadQTokenShortPayout`<br>\n    2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`<br>\n    2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`<br>\n    2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`<br>\n    2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`<br>\n    2-5. \\`Y2 = Y1 \\* 10^27 / X2 = (99999999999997 \\* 10^28) \\* 10^27 / (10^33 - 2 \\* 10^19) = 9999999999999899999999999997999999999<br>\n3.  combine terms<br>\n    3-1. ` B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001<br>\n         3-2.  `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2<br>\n\nAnd with this, we managed to squeeze 2 wei from a presumably worthless collateral.\n\nThis attack still suffers from several problems\n\n1.  cost of WETH in BUSD is way higher than current market\n2.  need to predict target price accurately to profit\n3.  requires large amount of WETH to profit\n\nWhile it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.\n\nThis concludes our demonstration of two attacks against the potential flaws in number handling.\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nFor `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.\n\nFor `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.\n\n**[0xca11 (Rolla) confirmed, resolved, and commented](https://github.com/code-423n4/2022-03-rolla-findings/issues/31#issuecomment-1102147125):**\n > Resolved by adding explicit rounding on fixed-point multiplication and division operations: [RollaProject/quant-protocol#91](https://github.com/RollaProject/quant-protocol/pull/91).\n\n\n\n***\n\n",
      "summary": "\nA bug report has been issued for the code-423n4/2022-03-rolla repository. This report presents two different incorrect behaviours that can affect the correctness of math calculations. The first bug affects the correctness when calculating collateral required for `_mintSpread`, and the second expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, however, it is still too costly to exploit under current BNB chain environment. \n\nIn order to demonstrate the bug, the proof of concept was used to calculate profit with a modest long strike price. The attack still suffers from several problems, including the cost of WETH in BUSD being higher than current market, the need to predict target price accurately to profit, and the requirement of large amount of WETH to profit.\n\nThe recommended mitigation steps for this bug include adding an opt-out round up argument to the `div` and `mul` functions, and adopting a similar strategy to the `uintToInt` function for the `intToUint` function. If the value goes out of directly convertable range ( < 0), it should revert and throw an error message.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/31",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "1682",
      "title": "[H-01] Incorrect strike price displayed in name/symbol of qToken ",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206\n\n\n## Vulnerability details\n\n## Impact\n\n`_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.\n\n\n## Proof of Concept\n\nERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.\n\nThe bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.\n\nThe exploit can be outlined through the following steps:\n\n* Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`\n\n* Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`\n\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90\n\n```\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\t\t\n        ...\n\t\t\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n```\n\n```\n\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n```\n\n* `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`\n\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136\n```\nfunction _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n```\n\n* However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`\n\nhttps://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206\n\n```\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n```\n\n* The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nFix the bug in the `_slice()`\n\n```\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n```",
      "summary": "\nThis bug report is about the `_slice()` function in `options/QTokenStringUtils.sol` which is used to cut a string into `string[start:end]`. The bug is that while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.\n\nFor example, Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`. However, due to this bug, the final qtoken name becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.\n\nThe exploit can be outlined through the following steps:\n\n* Alice created a call option with strike price 10000.90001.\n* Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.util` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`.\n* `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute.\n* However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`.\n* The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.\n\nThe bug was identified using manual code review. The recommended mitigation step is to fix the bug in the `_slice()` by changing `slice[i] = bytes(_s)[_start + 1];` to `slice[i] = bytes(_s)[_start + i];`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Rolla",
      "source_link": "https://code4rena.com/reports/2022-03-rolla",
      "github_link": "https://github.com/code-423n4/2022-03-rolla-findings/issues/28",
      "tags": [],
      "finders": [
        "rayn"
      ]
    },
    {
      "id": "42445",
      "title": "[M-01] `_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood, also found by cmichel, cmichel, egjlmn1, kenzo, MaCree, onewayfunction, sirhashalot, and WatchPug_\n\n#### Impact\n\nNFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.\n\nWhen positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.\n\nThis edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.\n\n#### Proof of Concept\n```solidity\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n```\n```solidity\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n```\n\n```solidity\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_length;\n    require(count > uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n```\n\n#### Recommended Mitigation Steps\n\nConsider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .\n\n**[deluca-mike (XDEFI) confirmed](https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1012535766):**\n> In the release candidate contract, `_generateNewTokenId` now used an [internal `_tokensMinted` variable](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L36) instead of `totalSupply()`, as seen [here](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L393).\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/17#issuecomment-1013783639):**\n> Agreed with sponsor\n> \n> As for mitigation, the new way to generate token IDs seems cleaner, but more gas consuming\n\n",
      "summary": "\nThe bug report discusses an issue with the XDEFI protocol, where a specific edge case can cause transactions to fail unexpectedly. This occurs when positions are unlocked after expiring, but the corresponding NFT is not deleted. This can result in the same `tokenId` being used multiple times, causing `_safeMint()` to fail. The report suggests replacing `totalSupply()` with an internal counter to ensure unique `tokenId` values. The sponsor has confirmed that this has been addressed in the release candidate contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17",
      "tags": [],
      "finders": []
    },
    {
      "id": "42444",
      "title": "[H-01] Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151>\n\n```solidity\n_pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n```\n\nIn the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.\n\nA malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.\n\nAs a result, the contract can be malfunctioning and even freeze users' funds in edge cases.\n\n#### Proof of Concept\n\nGiven:\n\n*   bonusMultiplierOf\\[30 days] = 100\n\n1.  Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`;\n2.  Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n_pointsPerUnit += ((170141183460469 * 2**128) / 1);\n```\n\n3.  Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows;\n4.  Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days;\n5.  The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n_pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1));\n```\n\n6.  30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.\n\n#### Recommended Mitigation Steps\n\nUniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.\n\nThe same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44>\n\n```solidity\nconstructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n    require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n    owner = msg.sender;\n    baseURI = baseURI_;\n    _zeroDurationPointBase = zeroDurationPointBase_;\n\n    totalUnits = 100_000_000;\n}\n```\n\n**[deluca-mike (XDEFI) confirmed](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008255566):**\n> This is a great catch! I just tested it:\n> \n> ```js\n> const { expect } = require(\"chai\");\n> const { ethers } = require(\"hardhat\");\n> \n> const totalSupply = '240000000000000000000000000';\n> \n> const toWei = (value, add = 0, sub = 0) => (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) - BigInt(sub)).toString();\n> \n> describe(\"XDEFIDistribution\", () => {\n>     it(\"Can overflow _pointsPerUnit\", async () => {\n>         const [god, alice, bob] = await ethers.getSigners();\n> \n>         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n>         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n> \n>         // Give each account 2,000,000 XDEFI\n>         await (await XDEFI.transfer(alice.address, toWei(2_000_000))).wait();\n>         await (await XDEFI.transfer(bob.address, toWei(2_000_000))).wait();\n> \n>         // bonusMultiplierOf[30 days] = 100\n>         await (await XDEFIDistribution.setLockPeriods([2592000], [100])).wait();\n> \n>         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;\n>         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n>         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n>         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(1);\n> \n>         // 2. Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, 170141183460469)).wait();\n>         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n> \n>         // 3. Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overflows\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_100_000))).wait();\n>         await expect(XDEFIDistribution.connect(bob).lock(toWei(1_100_000), 2592000, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n> \n>         // 4. Bob lock() 1,000,000 * 1e18 of XDEFI for 30 days\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(1_000_000))).wait();\n>         await (await XDEFIDistribution.connect(bob).lock(toWei(1_000_000), 2592000, bob.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n>         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(1_000_000));\n> \n>         // 5. The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(250_000))).wait();\n>         await (await XDEFIDistribution.updateDistribution()).wait();\n> \n>         // 6. 30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.\n>         await hre.ethers.provider.send('evm_increaseTime', [2592000]);\n>         await expect(XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).to.be.revertedWith(\"_toInt256Safe failed\");\n>     });\n> });\n> ```\n> \n> While I do like the suggestion to to `totalUnits = 100_000_000;` in the constructor, it will result \"uneven\" numbers due to the `totalUnits` offset. I wonder if I can resolve this but just reducing `_pointsMultiplier` to `uint256(2**96)` as per https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728.\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1008266150):**\n> OK, I think I can solve this with `_pointsMultiplier = uint256(2**72)`:\n> \n> ```js\n> const { expect } = require(\"chai\");\n> const { ethers } = require(\"hardhat\");\n> \n> const totalSupply = '240000000000000000000000000';\n> \n> const toWei = (value, add = 0, sub = 0) => (BigInt(value) * 1_000_000_000_000_000_000n + BigInt(add) - BigInt(sub)).toString();\n> \n> describe(\"XDEFIDistribution\", () => {\n>     it(\"Can overflow _pointsPerUnit\", async () => {\n>         const [god, alice, bob] = await ethers.getSigners();\n> \n>         const XDEFI = await (await (await ethers.getContractFactory(\"XDEFI\")).deploy(\"XDEFI\", \"XDEFI\", totalSupply)).deployed();\n>         const XDEFIDistribution = await (await (await ethers.getContractFactory(\"XDEFIDistribution\")).deploy(XDEFI.address, \"https://www.xdefi.io/nfts/\", 0)).deployed();\n> \n>         // Give each account 100M XDEFI\n>         await (await XDEFI.transfer(alice.address, toWei(100_000_000))).wait();\n>         await (await XDEFI.transfer(bob.address, toWei(100_000_000))).wait();\n> \n>         // bonusMultiplierOf[30 days] = 255\n>         await (await XDEFIDistribution.setLockPeriods([2592000], [255])).wait();\n> \n>         // 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1\n>         await (await XDEFI.connect(alice).approve(XDEFIDistribution.address, 1)).wait();\n>         await (await XDEFIDistribution.connect(alice).lock(1, 2592000, alice.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(alice.address)).to.equal('1');\n>         const nft1 = (await XDEFIDistribution.tokenOfOwnerByIndex(alice.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft1)).units).to.equal(2);\n> \n>         // 2. Alice sends 100M XDEFI minus 1 wei to the contract and calls updateDistribution()\n>         await (await XDEFI.connect(alice).transfer(XDEFIDistribution.address, toWei(100_000_000, 0, 1))).wait();\n>         await (await XDEFIDistribution.connect(alice).updateDistribution()).wait();\n> \n>         // 3. Bob can lock() 100M XDEFI for 30 days\n>         await (await XDEFI.connect(bob).approve(XDEFIDistribution.address, toWei(100_000_000))).wait();\n>         await (await XDEFIDistribution.connect(bob).lock(toWei(100_000_000), 2592000, bob.address)).wait();\n>         expect(await XDEFIDistribution.balanceOf(bob.address)).to.equal('1');\n>         const nft2 = (await XDEFIDistribution.tokenOfOwnerByIndex(bob.address, 0)).toString();\n>         expect((await XDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(255_000_000));\n> \n>         // 4. The rewarder sends 40M XDEFI to the contract and calls updateDistribution()\n>         await (await XDEFI.transfer(XDEFIDistribution.address, toWei(40_000_000))).wait();\n>         await (await XDEFIDistribution.updateDistribution()).wait();\n> \n>         // 5. 30 days later, Bob can call unlock()\n>         await hre.ethers.provider.send('evm_increaseTime', [2592000]);\n>         await (await XDEFIDistribution.connect(bob).unlock(nft2, bob.address)).wait();\n>     });\n> });\n> ```\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1012773001):**\n> In the [release candidate contract](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol), in order to preserve the math (formulas), at the cost of some accuracy, we went with a [`_pointsMultiplier` of 72 bits](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L23).\n> \n> Also, a [minimum units locked](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L53) is enforced, to prevent \"dust\" from creating a very very high `_pointsPerUnit`.\n> \n> Tests were written in order to stress test the contract against the above extreme cases.\n> \n> Further, a \"no-going-back\" [emergency mode setter](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L100) was implemented that allows (but does not force) users to [withdraw only their deposits](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L147) without any of the funds distribution math from being expected, in the event that some an edge case does arise.\n\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/156#issuecomment-1013782548):**\n> fantastic finding, agreed with the proposed severity!\n> \n> The sponsor fixes seem adequate: a lower `_poinsMultiplier`, a minimum lock and an emergency mode that disables reward math, somewhat similar to emergency withdraw functions in contracts like masterchef.\n\n\n\n",
      "summary": "\nThis bug report is submitted by WatchPug and concerns a potential issue in the XDEFIDistribution contract. The code in question can be found at lines 151-151 in the link provided. The report explains that the current implementation allows for the `_pointsPerUnit` variable to be changed in the `updateDistribution()` function, which can be called by anyone. This could potentially be exploited by a malicious user who locks only 1 wei of XDEFI, causing the `_pointsPerUnit` to become very large and resulting in future users not being able to lock or unlock their funds due to overflow in the arithmetic. This could cause the contract to malfunction and even freeze user's funds in certain cases. The report provides a proof of concept and recommends a mitigation step of setting an initial amount for `totalUnits` in the constructor to prevent this issue. The report also includes comments from the XDEFI team confirming the bug and discussing potential fixes. The judge agrees with the severity of the bug and the proposed fixes provided by the sponsor. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156",
      "tags": [],
      "finders": []
    },
    {
      "id": "1256",
      "title": "[M-01] _safeMint Will Fail Due To An Edge Case In Calculating tokenId Using The _generateNewTokenId Function",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nNFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.\n\nWhen positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.\n\nThis edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.\n\n## Proof of Concept\n\n```\nfunction _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n\n    // Create Position.\n    uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));\n    totalUnits += units;\n    positionOf[tokenId_] =\n        Position({\n            units: units,\n            depositedXDEFI: uint88(amount_),\n            expiry: uint32(block.timestamp + duration_),\n            created: uint32(block.timestamp),\n            bonusMultiplier: bonusMultiplier,\n            pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)\n        });\n\n    emit LockPositionCreated(tokenId_, destination_, amount_, duration_);\n}\n```\n\n```\nfunction _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {\n    // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.\n    return (points_ << uint256(128)) + uint128(totalSupply() + 1);\n}\n```\n\n```\nfunction merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {\n    uint256 count = tokenIds_.length;\n    require(count > uint256(1), \"MIN_2_TO_MERGE\");\n\n    uint256 points;\n\n    // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.\n    for (uint256 i; i < count; ++i) {\n        uint256 tokenId = tokenIds_[i];\n        require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");\n        require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");\n\n        _burn(tokenId);\n\n        points += _getPointsFromTokenId(tokenId);\n    }\n\n    // Mine a new NFT to the destinations, based on the accumulated points.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(points));\n}\n```\n\n## Tools Used\n\nManual code review.\nDiscussions with Michael.\n\n## Recommended Mitigation Steps\n\nConsider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .",
      "summary": "\nA bug was found in the `XDEFI` protocol which can cause some transactions to fail unexpectedly. This occurs when the `tokenId` value, which is used to represent unique positions referenced by the generated `tokenId`, contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits. When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used. This can happen if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`.\n\nA manual code review and discussions with Michael were used to find the bug. To mitigate this issue, it is recommended to replace `totalSupply()` in `_generateNewTokenId()` with an internal counter, which should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17",
      "tags": [],
      "finders": [
        "sirhashalot",
        "onewayfunction",
        "cmichel",
        "leastwood",
        "WatchPug",
        "egjlmn1",
        "MaCree",
        "kenzo"
      ]
    },
    {
      "id": "1255",
      "title": "[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by cmichel, Fitraldys, kenzo, onewayfunction, and tqts_\n\nThere is a reentrancy vulnerability in the \\_safeMint function\n```solidity\nfunction _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) internal virtual {\n    _mint(to, tokenId);\n    require(\n        _checkOnERC721Received(address(0), to, tokenId, _data),\n        \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n}\n...\nfunction _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n) private returns (bool) {\n    if (to.isContract()) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n```\nThe lock function changes the totalDepositedXDEFI variable after calling the \\_safeMint function\n```solidity\nfunction lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {\n    // Lock the XDEFI in the contract.\n    SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);\n\n    // Handle the lock position creation and get the tokenId of the locked position.\n    return _lock(amount_, duration_, destination_);\n}\n...\n    function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {\n    // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.\n    require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");\n\n    // Get bonus multiplier and check that it is not zero (which validates the duration).\n    uint8 bonusMultiplier = bonusMultiplierOf[duration_];\n    require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");\n\n    // Mint a locked staked position NFT to the destination.\n    _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));\n\n    // Track deposits.\n    totalDepositedXDEFI += amount_;\n```\n\nSince the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the \\_safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the \\_pointsPerUnit variable will become abnormally large.\n\n```solidity\n    function updateDistribution() external {\n       uint256 totalUnitsCached = totalUnits;\n\n       require(totalUnitsCached> uint256(0), \"NO_UNIT_SUPPLY\");\n\n       uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());\n\n       if (newXDEFI == uint256(0)) return;\n\n       _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n\n       emit DistributionUpdated(msg.sender, newXDEFI);\n   }\n   ...\n   function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {\n       uint256 previousDistributableXDEFI = distributableXDEFI;\n       uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;\n\n       return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);\n   }\n\n```\n\nIf the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the \\_updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user\n```solidity\n\nfunction unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {\n    // Handle the unlock and get the amount of XDEFI eligible to withdraw.\n    amountUnlocked_ = _unlock(msg.sender, tokenId_);\n\n    // Send the the unlocked XDEFI to the destination.\n    SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);\n\n    // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.\n    _updateXDEFIBalance();\n}\n...\nfunction _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {\n    // Check that the account is the position NFT owner.\n    require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");\n\n    // Fetch position.\n    Position storage position = positionOf[tokenId_];\n    uint96 units = position.units;\n    uint88 depositedXDEFI = position.depositedXDEFI;\n    uint32 expiry = position.expiry;\n\n    // Check that enough time has elapsed in order to unlock.\n    require(expiry != uint32(0), \"NO_LOCKED_POSITION\");\n    require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");\n\n    // Get the withdrawable amount of XDEFI for the position.\n    amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);\n\n    // Track deposits.\n    totalDepositedXDEFI -= uint256(depositedXDEFI);\n\n    // Burn FDT Position.\n    totalUnits -= units;\n    delete positionOf[tokenId_];\n\n    emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);\n}\n...\nfunction _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {\n    return\n        (\n            _toUint256Safe(\n                _toInt256Safe(_pointsPerUnit * uint256(units_)) +\n                pointsCorrection_\n            ) / _pointsMultiplier\n        ) + uint256(depositedXDEFI_);\n}\n```\n\n#### Proof of Concept\n\n<https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281>\n\n#### Recommended Mitigation Steps\n\n    -    function updateDistribution() external  {\n    +    function updateDistribution() external  noReenter {\n\n\n**[deluca-mike (XDEFI) resolved](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1008233320):**\n> Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead, `updateDistribution()` will be called at the start of every lock/unlock function (so it can't have a `noReenter` modifier), and the `_safeMint` calls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a `_pointsPerUnit` before a re-entering from `_safeMint` can affect it). Tests will be added to show this is not longer possible.\n\n**[deluca-mike (XDEFI) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1012774852):**\n> In our release candidate contract, as mentioned above, `updateDistribution()` is called before each locking and unlocking function, via a [`updatePointsPerUnitAtStart` modifier](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L77-L80), and thus, `updateDistribution()` is now a public fucntion, and since it is used by other functions, cannot be behind a `noReenter`.\n> \n> See:\n> - [`lock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L177)\n> - [`lockWithPermit`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L181)\n> - [`relock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L188)\n> - [`unlock`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L195)\n> - [`relockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L233)\n> - [`unlockBatch`](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/contracts/XDEFIDistribution.sol#L240)\n> \n> Also, [a test was written](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-rc.0/test/XDEFIDistributionReceivers.js) to ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy call `updateDistribution()`.\n\n**[Ivshti (Judge) commented](https://github.com/code-423n4/2022-01-xdefi-findings/issues/25#issuecomment-1013783009):**\n> Agreed with the severity.\n> \n> Resolution of reordering the calls seems to be adequate \n\n\n\n \n",
      "summary": "\nThis bug report is about a reentrancy vulnerability in the _safeMint function of the XDEFIDistribution.sol contract. This function is called by the lock function which changes the totalDepositedXDEFI variable. Since the updateDistribution function does not have the noReenter modifier, an attacker can re-enter the updateDistribution function in the _safeMint function. This will cause the _pointsPerUnit variable to become abnormally large and the attacker can call the lock function to get an NFT before exploiting the reentrance vulnerability. The attacker can then call the unlock function to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function.\n\nThe recommended mitigation step for this vulnerability is to add the noReenter modifier to the updateDistribution function. This will prevent the attacker from re-entering the updateDistribution function in the _safeMint function and exploiting the vulnerability.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/25",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "onewayfunction",
        "tqts",
        "cccz",
        "cmichel",
        "Fitraldys",
        "kenzo"
      ]
    },
    {
      "id": "1254",
      "title": "[H-01] Malicious early user/attacker can malfunction the contract and even freeze users’ funds in edge cases",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151\n\n```solidity\n    _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);\n```\n\nIn the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone. \n\nA malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.\n\nAs a result, the contract can be malfunctioning and even freeze users' funds in edge cases.\n\n### PoC\n\nGiven:\n\n- bonusMultiplierOf[30 days] = 100\n\n1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`;\n2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:\n\n```solidity\n    _pointsPerUnit += ((170141183460469 * 2**128) / 1);\n```\n\n3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows;\n4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days;\n5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`: \n\n```solidity\n    _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1));\n```\n\n6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows. \n\n\n### Recomandation\n\nUniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.\n\nThe same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`  \n\nhttps://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44\n\n```solidity\nconstructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {\n        require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");\n        owner = msg.sender;\n        baseURI = baseURI_;\n        _zeroDurationPointBase = zeroDurationPointBase_;\n\n        totalUnits = 100_000_000;\n    }\n```",
      "summary": "\nThis bug report is about a vulnerability in the XDeFi Distribution contract that can lead to malfunctioning and freezing of user funds. The vulnerability is related to the `_pointsPerUnit` variable, which can be changed by anyone in the `updateDistribution()` function. A malicious early user can take advantage of this by locking a small amount of XDEFI with only 1 wei and increasing the `_pointsPerUnit` value to a very large number, causing future users to be unable to lock or unlock their funds due to overflow in arithmetic related to `_pointsMultiplier`.\n\nA proof-of-concept was provided to illustrate the vulnerability. It demonstrated that if Alice locks 1 wei of XDEFI for 30 days, then Bob will not be able to lock 1,100,000 * 1e18 of XDEFI for 30 days due to the overflow issue.\n\nThe recommendation is to set an initial amount for `totalUnits` on the constructor, similar to the way Uniswap v2 sends the first 1000 lp tokens to the zero address. This should solve the problem.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "XDEFI",
      "source_link": "https://code4rena.com/reports/2022-01-xdefi",
      "github_link": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "42375",
      "title": "[M-06] UniswapV3's path issue for `swapExactOutput`",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nUniswapV3 expects a path object like `(tokenA, feeAB, tokenB, feeBC, tokenC)`.\nThe `UniV3Trader.swapExactOutput` code tries to reverse this path to get to `(tokenC, feeBC, tokenB, feeAB, tokenA)` but that's not what the `_reverseBytes` function does.\nNote that it reverts the entire encoded `path` byte array **byte-by-byte** which breaks the byte-order in a token.\nFor example, `tokenA` would have every single byte reversed and lead to a different token.\n\n```solidity\nfunction _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {\n    /** @audit reverses byte order? */\n    for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];\n}\n```\n\n#### Impact\n\nThe `UniV3Trader.swapExactOutput` function with multi-hops is broken and cannot be used.\n\n#### Recommended Mitigation Steps\n\nDon't reverse the path byte-by-byte but element-by-element.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/50#issuecomment-1005680245):**\n > Can you confirm if this issue is valid or not? @MihanixA\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/50#issuecomment-1006253424):**\n > I actually agree with the warden's finding here. Leaving as is.\n\n\n\n",
      "summary": "\nThe bug report is about a function called `swapExactOutput` in a code called `UniV3Trader` that is not working properly. The function expects a specific format for the input, but when it tries to reverse the input, it does it in a way that breaks the order of the tokens. This means that the function cannot be used with multiple tokens. The recommended solution is to change the way the input is reversed so that it doesn't break the token order. There is a discussion about the validity of the issue, but it has not been resolved yet.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/50",
      "tags": [],
      "finders": []
    },
    {
      "id": "42374",
      "title": "[M-05] Admin can break `_numberOfValidTokens`",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by gzeon and 0x1f8b_\n\nThe `ProtocolGovernance._numberOfValidTokens` can be decreased by the admin in the `ProtocolGovernance.removeFromTokenWhitelist` function:\n\n```solidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    _tokensAllowed[addr] = false;\n    if (_tokenEverAdded[addr]) {\n        // @audit admin can repeatedly call this function and sets _numberOfValidTokens to zero. because they don't flip _tokenEverAdded[addr] here\n        --_numberOfValidTokens;\n    }\n}\n```\n\nThis function can be called repeatedly until the `_numberOfValidTokens` is zero.\n\n#### Impact\n\nThe `_numberOfValidTokens` is wrong and with it the `tokenWhitelist()`.\n\n#### Recommended Mitigation Steps\n\nIt seems that `_numberOfValidTokens` should only be decreased if the token was previously allowed:\n\n```solidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    if (_tokensAllowed[addr]) {\n        _tokensAllowed[addr] = false;\n        --_numberOfValidTokens;\n    }\n}\n```\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1005680208):**\n > Can you confirm if this issue is valid or not? @MihanixA\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1006252085):**\n > Just realised this is a duplicate of another issue. Marking this as the primary issue\n\n**[MihanixA (Mellow Protocol) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1006394949):**\n > @0xleastwood Confirmed, it's a bug.\n\n\n\n",
      "summary": "\nThe bug report is about a function called `removeFromTokenWhitelist` in a contract called `ProtocolGovernance`. This function can be called by an administrator and it has a problem where it can decrease a variable called `_numberOfValidTokens` even if the token was not previously allowed. This can happen multiple times until the variable becomes zero. This bug can cause the variable to have the wrong value and also affect the `tokenWhitelist` in the contract. The recommended solution is to only decrease the variable if the token was previously allowed. The bug has been confirmed by the team and marked as a duplicate of another issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "42373",
      "title": "[M-04] `ChiefTrader.sol` Wrong implementation of `swapExactInput()` and `swapExactOutput()`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by Meta0xNull_\n\nWhen a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59>\n\n```solidity\nreturn ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);\n```\n\nHowever, in the current implementation, `inputToken` is not approved to the `traderAddress`.\n\nFor example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.\n\nPlus, the `inputToken` should also be transferred from the caller before calling the subtrader.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89>\n\n```solidity\nIERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n```\n\nThe same problem exists in `swapExactOutput()`:\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75>\n\n```solidity\nfunction swapExactOutput(\n    uint256 traderId,\n    uint256 amount,\n    address,\n    PathItem[] calldata path,\n    bytes calldata options\n) external returns (uint256) {\n    require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n    _requireAllowedTokens(path);\n    address traderAddress = _traders[traderId];\n    address recipient = msg.sender;\n    return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);\n}\n```\n\n#### Recommendation\n\nApprove the `inputToken` to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.\n\nOr maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/108#issuecomment-995456401):**\n > In fact, tokens are approved to the trader https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L67\n> The problem is that `safeTransferFrom` uses `msg.sender` which is `ChiefTrader` instead of `recipient` which is `ERC20Vault`.\n\n\n\n",
      "summary": "\nThe bug report is about a problem in the code for the Mellow Protocol's ChiefTrader contract. When a specific function, `swapExactInput()`, is called, it tries to use a different function called `swapExactInput()` from another contract. However, the code currently does not allow for the correct token to be used in this function, causing the transaction to fail. The same problem also exists in another function called `swapExactOutput()`. The recommendation is to either fix the code to allow for the correct token to be used or to remove support for these functions in the ChiefTrader contract. A team member from Mellow Protocol has confirmed the issue and suggested a possible solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/108",
      "tags": [],
      "finders": []
    },
    {
      "id": "42372",
      "title": "[M-02] Withdraw from `AaveVault` will receive less than actual share",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\n#### Impact\n\n`AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150>\n- <https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13>\n\n#### Recommended Mitigation Steps\n\nCall `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/82)**\n\n",
      "summary": "\nThis bug report is about an issue in the `AaveVault` cache that affects users who withdraw from the `LpIssuer` platform. The problem is that when withdrawing, the `tokenAmounts` are calculated using a cached value of the total value locked (tvl) in the `AaveVault`. This means that users may not receive their fair share of interest or donations since the last update. The proof of concept and suggested mitigation steps can be found in the provided links. The team behind Mellow Protocol has confirmed the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/82",
      "tags": [],
      "finders": []
    },
    {
      "id": "42371",
      "title": "[M-01] User deposits don't have min. return checks",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `LPIssuer.deposit` first computes *balanced amounts* on the user's defined `tokenAmounts`.\nThe idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be *balanced*, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.\n\nBut the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance.\nThis frontrun can happen accidentally whenever the strategist rebalances\n\n#### Proof Of Concept\n\nThere's a vault with two tokens A and B, tvls are `[500, 1500]`\n\n*   The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply).\n*   The strategist rebalances to `[1000, 1000]`\n*   The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.\n\n#### Impact\n\nUsers can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.\n\n#### Recommended Mitigation Steps\n\nAdd minimum return amount checks.\nAccept a function parameter that can be chosen by the user indicating their *expected LP amount* for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/46)**\n\n",
      "summary": "\nThe user \"cmichel\" has reported a bug in the `LPIssuer.deposit` function. The function is supposed to calculate balanced amounts based on the user's provided token amounts, but a strategist can manipulate the token values and cause the function to miscalculate. This can result in users receiving an unexpected amount of LP tokens, which can lead to financial losses. To mitigate this issue, the user suggests adding checks for minimum return amounts and allowing users to specify their expected LP token amount. MihanixA from Mellow Protocol has confirmed the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "42370",
      "title": "[H-03] `UniV3Vault.sol#collectEarnings()` can be front run",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nFor `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).\n\nHowever, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.\n\n- <https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122>\n\n- <https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97>\n\n#### Proof Of Concept\n\nGiven:\n\n*   Current `tvl()` is `10 ETH` and `40,000 USDC`;\n*   Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;\n\n1.  `strategy` calls `collectEarnings()` to collect fees and reinvest;\n2.  The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool;\n3.  After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.\n\nAs a result, the attacker has stolen half of the pending yields in about 1 block of time.\n\n#### Recommendation\n\nConsider including fees in `tvl()`.\n\nFor the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:\n\n- <https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806>\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/98#issuecomment-995467521):**\n > Thanks! \n> Added `tokensOwed` to `UniV3Vault`'s `tvl` \n\n\n\n",
      "summary": "\nThe report is about a bug in the `UniV3Vault` code submitted by a user named WatchPug. The bug involves the collection and reinvestment of lp fees in the strategy of the vault. Currently, unharvested yields are not included in the total value of the vault, leaving it vulnerable to front-run attacks that can steal pending yields. The report includes a proof of concept where an attacker can take advantage of this vulnerability and steal half of the pending yields in just one block of time. The report recommends including fees in the total value of the vault and provides a code reference for calculating fees earned. The bug has been confirmed by MihanixA from Mellow Protocol and a fix has been implemented to include `tokensOwed` in the `tvl` of `UniV3Vault`. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/98",
      "tags": [],
      "finders": []
    },
    {
      "id": "42369",
      "title": "[H-02] Wrong implementation of `performanceFee` can cause users to lose 50% to 100% of their funds",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\nA certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.\n\nHowever, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271>\n\n```solidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n```\n\n#### Proof of Concept\n\nGiven:\n\n*   `strategyParams.performanceFee`: `10e7` (1%)\n\n1.  Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`;\n2.  3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:\n\n*   Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC);\n*   Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.\n\n#### Recommendation\n\nChange to:\n\n```solidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n```\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/91)**\n\n",
      "summary": "\nThe user WatchPug has reported a bug in the Mellow Protocol. When a certain amount of lp tokens (shares of the vault) are minted to the `strategyPerformanceTreasury` as `performanceFee`, the current formula for `toMint` is incorrect and issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. This results in users losing 50% to 100% of their funds after a few times. The bug has been confirmed by MihanixA and a recommendation has been made to change the formula to prevent this issue from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/91",
      "tags": [],
      "finders": []
    },
    {
      "id": "42368",
      "title": "[H-01] `YearnVault.sol#pull()` will most certainly fail",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101>\n\n```solidity\n    for (uint256 i = 0; i < _yTokens.length; i++) {\n        if (tokenAmounts[i] == 0) {\n            continue;\n        }\n\n        IYearnVault yToken = IYearnVault(_yTokens[i]);\n        uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n        uint256 balance = yToken.balanceOf(address(this));\n        if (yTokenAmount > balance) {\n            yTokenAmount = balance;\n        }\n        if (yTokenAmount == 0) {\n            continue;\n        }\n        yToken.withdraw(yTokenAmount, to, maxLoss);\n        (tokenAmounts[i], address(this));\n    }\n    actualTokenAmounts = tokenAmounts;\n```\n\nThe actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.\n\nAs a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.\n\n#### Recommendation\n\nChange to:\n\n```solidity\ntokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss);\n```\n\n**[MihanixA (Mellow Protocol) confirmed and disagreed with severity](https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1005637681):**\n > Actually I don't see how this could lead to fund loss. I think this one is a bug.\n> @0xleastwood what do you think? \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1007872447):**\n > my understanding is that users won't be able to withdraw pushed funds @MihanixA \n > \n > so fund loss is related to not being able to withdraw rather than by extracting value from the protocol\n\n**[Oxn1ck (Mellow Protocol) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1030698636):**\n > While we agree that this will prevent full withdrawal of the funds, that wil be limited to only a couple of wei's which is the yearn precision loss. So in case you put 100eth you will be able to recover 100eth - 1wei. So we'd rather name the issue \"some small amounts cannot be withdrawn from the pool\"\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1030720307):**\n > If my understanding is correct, `YearnVault._pull` will withdraw `yTokenAmount` representing the yToken's shares and then withdraw on this amount but return `tokenAmounts` where the amount withdrawn is typically less than the amount intended to be withdrawn. `LpIssuer.withdraw()` will expect `actualTokenAmounts` to be available to be transferred which isn't exactly in the contract's balance.\n> \n> - https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L90\n> - https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L152\n> \n > Let's use an example:\n> \n> - Alice calls `LpIssuer.withdraw()` with `tokensAmount[0]` equal to 100 tokens. Let's ignore the `lpTokenAmount` argument for the sake of this example.\n> - `_subvault().pull` is called on this `tokensAmount[0]`.\n> - `yTokenAmount` is calculated according to `((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());` which potentially leads to a slightly truncated output.\n> - This truncated output represents the shares belonging to the user which is then parsed to `yToken.withdraw()`.\n> - `yToken.withdraw()` is likely less than 100 tokens and is sent to the `LpIssuer.sol` contract but `actualTokenAmounts[0]` is equal to 100 tokens.\n> - `LpIssuer.withdraw()` attempts to send tokens to the withdrawer but is unable as the contract does not have sufficient balance. `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);`\n> - If I'm not mistaken, it seems like this issue would be apparent on any withdrawal amount (assuming there is some amount truncated).\n> - There is also an important edge case where the amount to withdraw from the yearn vault is greater than the available contract balance, it will always revert.\n\n**[Oxn1ck (Mellow Protocol) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1032415580):**\n > Agreed, thank you!\n\n\n",
      "summary": "\nThe bug report is about an issue in the YearnVault contract where the actual token withdrawn from the `yToken.withdraw()` function is less than the intended amount due to precision loss in the calculation of `yTokenAmount`. This can result in the `LpIssuer.withdraw()` function reverting due to insufficient balance, preventing users from withdrawing their funds. The recommendation is to change the code to `tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss);` to prevent this issue. There was some discussion about the severity of the bug, with some team members disagreeing on the impact it may have. However, it was ultimately agreed that this issue should be addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/121",
      "tags": [],
      "finders": []
    },
    {
      "id": "1154",
      "title": "[M-07] Bad redirects can make it impossible to deposit & withdraw",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `GatewayVault._push()` function gets `redirects` from the `strategyParams`.\nIf `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.\n\nNote that the deposits for vault index `i` are cleared, as they are redirected:\n\n```solidity\nfor (uint256 j = 0; j < _vaultTokens.length; j++) {\n    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n    amountsByVault[i][j] = 0;\n}\n```\n\n> The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.\n\nIf the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero.\nFor example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc.\nThere are many misconfigurations that can lead to not being able to deposit to the pool anymore.\n\n#### Recommended Mitigation Steps\n\nThe `redirects[i] = j` matrix needs to be restricted.\nIf `i` is redirected to `j`, `j` may not redirect itself.\nCheck for this when setting the `redirects` array.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1005680123):**\n > Can you confirm if this issue is valid or not? @MihanixA \n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1006406574):**\n > @0xleastwood Confirmed\n\n**[MihanixA (Mellow Protocol) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1006407377):**\n > (notice that this one is a deploy-related issue)\n\n",
      "summary": "\nA bug has been identified in the `GatewayVault._push()` function of the GatewayVault smart contract. This function gets `redirects` from the `strategyParams` and if `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`. When this happens, the deposits for vault index `i` are cleared. The same is true for withdrawals in the `_pull` function. This could mean users are unable to withdraw.\n\nThe bug occurs when the `redirects` array is misconfigured. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. In this case, all `amountsByVault` are set to zero, meaning users are unable to deposit to the pool.\n\nThe recommended mitigation steps to prevent this bug from occurring are to restrict the `redirects[i] = j` matrix. If `i` is redirected to `j`, `j` may not redirect itself. This should be checked when setting the `redirects` array.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/44",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1153",
      "title": "[M-06] UniswapV3’s path issue for swapExactOutput",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nUniswapV3 expects a path object like `(tokenA, feeAB, tokenB, feeBC, tokenC)`.\nThe `UniV3Trader.swapExactOutput` code tries to reverse this path to get to `(tokenC, feeBC, tokenB, feeAB, tokenA)` but that's not what the `_reverseBytes` function does.\nNote that it reverts the entire encoded `path` byte array **byte-by-byte** which breaks the byte-order in a token.\nFor example, `tokenA` would have every single byte reversed and lead to a different token.\n\n```solidity\nfunction _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {\n    /** @audit reverses byte order? */\n    for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];\n}\n```\n\n## Impact\nThe `UniV3Trader.swapExactOutput` function with multi-hops is broken and cannot be used.\n\n## Recommended Mitigation Steps\nDon't reverse the path byte-by-byte but element-by-element.",
      "summary": "\nThis bug report is about the UniswapV3 exchange, which expects a path object like `(tokenA, feeAB, tokenB, feeBC, tokenC)`. The code in the `UniV3Trader.swapExactOutput` function tries to reverse this path to get to `(tokenC, feeBC, tokenB, feeAB, tokenA)` but this is not what the `_reverseBytes` function does. The `_reverseBytes` function reverses the entire encoded `path` byte array byte-by-byte, which breaks the byte-order of the token. As a result, the `UniV3Trader.swapExactOutput` function with multi-hops is broken and cannot be used. To fix this bug, the recommended mitigation step is to not reverse the path byte-by-byte, but element-by-element.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/50",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1152",
      "title": "[M-05] Admin can break _numberOfValidTokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `ProtocolGovernance._numberOfValidTokens` can be decreased by the admin in the `ProtocolGovernance.removeFromTokenWhitelist` function:\n\n```solidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    _tokensAllowed[addr] = false;\n    if (_tokenEverAdded[addr]) {\n        // @audit admin can repeatedly call this function and sets _numberOfValidTokens to zero. because they don't flip _tokenEverAdded[addr] here\n        --_numberOfValidTokens;\n    }\n}\n```\n\nThis function can be called repeatedly until the `_numberOfValidTokens` is zero.\n\n## Impact\nThe `_numberOfValidTokens` is wrong and with it the `tokenWhitelist()`.\n\n## Recommended Mitigation Steps\nIt seems that `_numberOfValidTokens` should only be decreased if the token was previously allowed:\n\n```solidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    if (_tokensAllowed[addr]) {\n        _tokensAllowed[addr] = false;\n        --_numberOfValidTokens;\n    }\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the `ProtocolGovernance._numberOfValidTokens` function. It is possible for the admin to repeatedly call the `ProtocolGovernance.removeFromTokenWhitelist` function, which results in the `_numberOfValidTokens` becoming zero. This in turn affects the `tokenWhitelist()` function. The recommended mitigation step is to ensure that the `_numberOfValidTokens` is only decreased if the token was previously allowed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/49",
      "tags": [],
      "finders": [
        "cmichel",
        "gzeon  0x1f8b"
      ]
    },
    {
      "id": "1151",
      "title": "[M-04] ChiefTrader.sol Wrong implementation of swapExactInput() and swapExactOutput()",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nWhen a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59\n\n```solidity=59\nreturn ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);\n```\n\nHowever, in the current implementation, inputToken is not approved to the `traderAddress`.\n\nFor example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.\n\nPlus, the inputToken should also be transferred from the caller before calling the subtrader.\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89\n\n```solidity=89\n    IERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n```\n\nThe same problem exits in `swapExactOutput()`:\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75\n\n```solidity=63\nfunction swapExactOutput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] calldata path,\n        bytes calldata options\n    ) external returns (uint256) {\n        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n        _requireAllowedTokens(path);\n        address traderAddress = _traders[traderId];\n        address recipient = msg.sender;\n        return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);\n    }\n```\n\n### Recommendation\n\nApprove the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.\n\nOr maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.",
      "summary": "\nA bug was identified in the code for WatchPug, a decentralized trading protocol. The bug occurs when a user calls `ChiefTrader.sol#swapExactInput()`, which then calls `ITrader(traderAddress).swapExactInput()`. The problem is that the inputToken is not approved to the `traderAddress`, and this causes the transfer to revert. The same issue is present in `swapExactOutput()` as well.\n\nTo fix the bug, it is recommended that the inputToken be approved to the subtrader and transferred from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`. Alternatively, support for `swapExactInput()` and `swapExactOutput()` could be removed from `ChiefTrader`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/108",
      "tags": [],
      "finders": [
        "WatchPug",
        "Meta0xNull"
      ]
    },
    {
      "id": "1150",
      "title": "[M-03] Users can avoid paying vault fees",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `LPIssuer.deposit/withdraw` function charges protocol\\&management\\&performance fees through inflating the LP supply in the `_chargeFees` function.\nHowever, this LP fees minting is skipped if the elapsed time is less than the `managementFeeChargeDelay`:\n\n```solidity\nif (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n    return;\n}\n```\n\nThis allows a user to avoid paying any fees if they deposit right after a charge fee interaction and withdraw within again `managementFeeChargeDelay` time period.\n\n#### Proof Of Concept\n\nThis can be abused heavily on networks where the gas fees are a lot cheaper than the three vault fees:\n\n*   deposit a tiny amount just to trigger the charge fees. This sets `lastFeeCharge`\n*   deposit a huge amount, tvl increases significantly\n*   let it earn interest. withdraw it before the `managementFeeChargeDelay`. No fees are paid, tvl reduces significantly\n*   repeat, fees are only paid on tiny tvl\n\n#### Impact\n\nIn the worst case, nobody pays fees by repeating the above actions.\n\n#### Recommended Mitigation Steps\n\nFees must always be charged on each deposit and withdrawal, even within the same block as it could be that a huge interest \"harvest\" comes in that an attacker sandwiches.\nRemove the `if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) { return; }` code.\n\n**[MihanixA (Mellow Protocol) disputed](https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-999373852):**\n > Charging fees on every deposit costs a lot of gas. \n> If we notice users avoid paying fees we would just switch `managementFeeChargeDelay` to zero. \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005658252):**\n > I don't think this is a valid reason. At the end of the day, users can still abuse this feature and it is best to think about worse case scenario. I'll keep this issue as `high` severity unless there is any reason not to? @MihanixA \n\n**[MihanixA (Mellow Protocol) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005665074):**\n > @0xleastwood \n> Notice that users funds are not at risk and we can not remove this behaviour because this would lead to high withdraw/deposit fees.\n> Anyway feel free to mark this issue anything seems fair to you.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005668810):**\n > While I understand funds aren't directly at risk. It does seem like this issue can be exploited to earn additional yield at a lower opportunity cost as the user does not pay fees.\n> \n> I think I'll mark this as `medium` then.\n> ```\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> ```\n\n\n\n",
      "summary": "\nA bug was discovered in the `LPIssuer.deposit/withdraw` function, which allows a user to avoid paying any fees if they deposit right after a charge fee interaction and withdraw within the `managementFeeChargeDelay` time period. This can be abused heavily on networks where the gas fees are cheaper than the three vault fees, allowing an attacker to repeat the process and avoid paying any fees. The impact of this bug is that in the worst case, nobody pays fees. The recommended mitigation step for this bug is to remove the code that allows the user to avoid fees and to always charge fees on each deposit and withdrawal, even within the same block.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/47",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1149",
      "title": "[M-02] Withdraw from AaveVault will receive less than actual share",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngzeon\n\n\n## Vulnerability details\n\n## Impact\n`AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13\n\n## Recommended Mitigation Steps\nCall `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl",
      "summary": "\nThis bug report is about an issue with the AaveVault, which is a smart contract used for managing user funds. The issue is that when a user withdraws from the LpIssuer, the tokenAmounts are calculated using the cached tvl from the AaveVault, which may lead to the user missing out on their share of the accrued interest or donations to Aave since the last updateTvls. The recommended mitigation step for this issue is to call updateTvls at the beginning of the withdraw function if the subvault will be caching tvl.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/82",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1148",
      "title": "[M-01] User deposits don’t have min. return checks",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`.\nThe idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.\n\nBut the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance.\nThis frontrun can happen accidentally whenever the strategist rebalances\n\n## POC\nThere's a vault with two tokens A and B, tvls are `[500, 1500]`\n\n- The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply).\n- The strategist rebalances to `[1000, 1000]`\n- The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.\n\n## Impact\nUsers can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.\n\n## Recommended Mitigation Steps\nAdd minimum return amount checks.\nAccept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.",
      "summary": "\nThis bug report describes a vulnerability in the `LPIssuer.deposit` function which can lead to users receiving a different amount of LP tokens than they expected. This can happen when a strategist frontruns the user’s deposit and rebalances the vault tokens, changing the tvl for each vault token. The user’s deposit amount is then calculated based on the new tvl, leading to them receiving a smaller LP amount than they expected. \n\nFor example, if a user deposits an equal amount of two tokens A and B, expecting to get 50% of the supply, but the strategist rebalances the tokens to equal tvl, the user will only receive 33.3% of the total supply. \n\nThe impact of this vulnerability is that users can get rekt when depositing, as the received LP amount is unpredictable and leads to a trade using a very different balanced token mix than they intended. \n\nTo mitigate this vulnerability, it is recommended to add a minimum return amount check and accept a function parameter that can be chosen by the user indicating their expected LP amount for their deposit token amounts, then check that the actually minted LP token amount is above this parameter.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/46",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1147",
      "title": "[H-04] AaveVault does not update TVL on deposit/withdraw",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by WatchPug_\n\nAave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest.\n\nThe `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call.\n\nThis call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share *of the old tvl*, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the *new tvl*, receiving back their initial deposit + the share of the interest.\nThis can be done risk-free in a single transaction.\n\n#### Proof Of Concept\n\n*   Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens`\n*   Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called.\n*   The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000`\n*   The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply\n*   Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`.\n*   Attacker makes a profit of `0.5 * interest`\n\n#### Impact\n\nThe interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing.\nIf the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest\n\n#### Recommended Mitigation Steps\n\nUpdate the tvl when depositing and withdrawing before doing anything else.\n\n**[MihanixA (Mellow Protocol) confirmed](https://github.com/code-423n4/2021-12-mellow-findings/issues/41)**\n \n",
      "summary": "\nAave is a decentralized finance platform that uses rebasing tokens. This means that the token balance of the platform increases over time with the accrued interest. The vulnerability in the Aave platform is that when depositing tokens, the internal \"tvl\" variable is not updated before any other action is taken. This allows an attacker to deposit tokens, get a fair share of the old tvl, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the new tvl, receiving back their initial deposit plus the share of the interest.\n\nTo illustrate the impact of this vulnerability, imagine an Aave Vault with a single vault token, and current TVL = 1,000 aTokens. The attacker calls LPIssuer.push([1000]) which loads the old, cached tvl. No updateTvl is called. The 1000 underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: aaveVault.transferAndPush([1000]). This deposits 1000 underlying tokens to the Aave lending pool and returns actualTokenAmounts = [1000]. After that, the internal _tvls variable is updated with the latest aTokens, including the 1000 aTokens just deposited and also the new rebased aToken amounts, the interest the vault received from supplying the tokens since last updateTvls call. The LP amount to mint amountToMint is still calculated on the old cached tvl memory variable, i.e., attacker receives amount/oldTvl = 1000/1000 = 100% of existing LP supply. The attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in deposit's transferAndPush call). The attacker receives 50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest, thus making a profit of 0.5 * interest.\n\nThe vulnerability can be exploited by taking a flash loan and depositing and withdrawing a large amount to capture a large share of the interest. To mitigate this vulnerability, it is recommended to update the tvl when depositing and withdrawing before doing anything else.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/41",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "WatchPug",
        "cmichel"
      ]
    },
    {
      "id": "1146",
      "title": "[H-03] UniV3Vault.sol#collectEarnings() can be front run",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nFor `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).\n\nHowever, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97\n\n### POC\n\nGiven:\n\n- Current `tvl()` is `10 ETH` and `40,000 USDC`;\n- Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;\n\n1. `strategy` calls `collectEarnings()` to collect fees and reinvest;\n2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool;\n3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.\n\nAs a result, the attacker has stolen half of the pending yields in about 1 block of time.\n\n### Recommendation\n\nConsider including fees in `tvl()`.\n\nFor the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:\n\nhttps://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806",
      "summary": "\nThe bug report concerns a vulnerability of the UniV3Vault contract, which is a part of the Mellow project. This contract allows a strategy to call the collectEarnings() function to collect fees and reinvest. However, unharvested yields are not included in the tvl() function, making it vulnerable to front-run attacks. A Proof of Concept (POC) is provided to demonstrate how an attacker can exploit this vulnerability. The recommendation is to consider including fees in the tvl() function. The code to calculate fees earned is provided from the G-UNI project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/98",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1145",
      "title": "[H-02] Wrong implementation of performanceFee can cause users to lose 50% to 100% of their funds",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nA certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.\n\nHowever, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271\n\n```solidity=269\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n```\n\n### PoC\n\nGiven:\n\n- `strategyParams.performanceFee`: `10e7` (1%)\n\n1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`;\n2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:\n\n- Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC);\n- Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.\n\n### Recommendation\n\nChange to:\n\n```solidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n```",
      "summary": "\nA bug has been reported in the WatchPug Vault, where a certain amount of lp tokens (shares of the vault) are minted to the strategyPerformanceTreasury as performanceFee, the amount is calculated based on the minLpPriceFactor. However, the current formula for toMint is wrong, which issues more than 100% of the current totalSupply of the lp token to the strategyPerformanceTreasury each time, causing users to lose 50% to 100% of their funds after a few times.\n\nA Proof of Concept has been given to demonstrate the issue. Given that the strategyParams.performanceFee is 10e7 (1%), Alice deposited 1,000 USDC, received 1000 lpToken; the totalSupply of the lpToken is now: 1000. 3 days later, baseTvl increased to 1,001 USDC, Bob deposited 1 USDC and trigegred _chargeFees(). The expected result is that the strategyPerformanceTreasury to receive about 0.01 lpToken (1% of 1 USDC). However, the actual result is that the minLpPriceFactor is about 1.001, and the strategyPerformanceTreasury will received 1001 lpToken as performanceFee, causing Alice to lose 50% of her deposited funds.\n\nA recommendation has been given to fix the issue, which is to change the formula to: address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint);\n\nIn conclusion, a bug has been discovered in the WatchPug Vault that causes users to lose 50% to 100% of their funds after a few times. A Proof of Concept and a recommendation have been given to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/91",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1144",
      "title": "[H-01] YearnVault.sol#pull() will most certainly fail",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101\n\n```solidity=84\n    for (uint256 i = 0; i < _yTokens.length; i++) {\n        if (tokenAmounts[i] == 0) {\n            continue;\n        }\n\n        IYearnVault yToken = IYearnVault(_yTokens[i]);\n        uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n        uint256 balance = yToken.balanceOf(address(this));\n        if (yTokenAmount > balance) {\n            yTokenAmount = balance;\n        }\n        if (yTokenAmount == 0) {\n            continue;\n        }\n        yToken.withdraw(yTokenAmount, to, maxLoss);\n        (tokenAmounts[i], address(this));\n    }\n    actualTokenAmounts = tokenAmounts;\n```\n\nThe actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.\n\nAs a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.\n\n ### Recommendation\n\nChange to:\n\n```solidity=98\ntokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss);\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of a project called WatchPug. The code in question is located in a file called YearnVault.sol, line 84 to 101. The code is intended to withdraw tokens from a vault, however due to precision loss in the calculation of the amount of tokens to be withdrawn, the actual amount of tokens withdrawn will be less than the amount specified. This will cause a function in a different file, LpIssuer.sol, to revert due to insufficient balance. The recommendation is to change the code to include the actual amount of tokens withdrawn in the calculation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mellow Protocol",
      "source_link": "https://code4rena.com/reports/2021-12-mellow",
      "github_link": "https://github.com/code-423n4/2021-12-mellow-findings/issues/121",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "42392",
      "title": "[M-30] Malt Protocol Uses Stale Results From `MaltDataLab` Which Can Be Abused By Users",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.\n\n#### Proof of Concept\n\nConsider the following attack vector:\n\n*   The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user.\n*   The `_stabilityWindowOverride` function is satisfied, hence the function will execute.\n*   The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate.\n*   `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction.\n*   As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments.\n*   If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.\n\nThis threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.\n\n`trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable.\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105>\n\n\n#### Recommended Mitigation Steps\n\nConsider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/373):** \n > Gas issues were the reason updates weren't inlined into paths that update critical values. However based on some thoughts from the team over the past few weeks and suggestions in other audit findings I think we can reduce gas enough to make it viable to inline it \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/373#issuecomment-1019283105):**\n > 1) Miners can censor transactions, that is a fact\n> 2) Relying on an external call can cause race conditions or situations where the call didn't happen (price didn't update in time)\n> 3) Arguably a malicious actor could collude with miners with the goal of extracting further value\n> \n> However, the target chain for the deployment is Polygon, so unless they were to create custom validator code, and collude 1-1 with each validator (no flashbots on Polygon, yet) then the attack is increasingly more complex.\n> \n> The attack is reliant on the externalities of the validator + somebody incentivized enough to exploit this.\n> \n> I agree with he finding and believe after stabilize the system should auto-update the prices\n> Because of the external requirements am downgrading to medium severity\n\n",
      "summary": "\nThe bug report discusses a potential vulnerability in the MaltDataLab contract used by the Malt protocol. The contract relies on an external account to update important data, but this can be censored by miners, allowing them to manipulate the data and extract value from the protocol. This could lead to instability in the protocol. The report suggests adding calls to update the data in various parts of the code to prevent this attack. The judges have confirmed the issue and suggest making changes to the contract to use cumulative price updates instead of spot price to prevent manipulation by well-funded actors. They also mention that the target chain for deployment is Polygon, which makes the attack more complex. The severity of the bug has been downgraded to medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/373",
      "tags": [],
      "finders": []
    },
    {
      "id": "42391",
      "title": "[M-29] User can bypass Recovery Mode via UniswapHandler to buy Malt",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nOne of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.\n\n#### Proof of Concept\n\n1.  User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted\n\n`swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);`\n2\\) User send matching amount of dai to uniswapHandler\n3\\) User call addLiquidity() and get back LP token\n4\\) User call removeLiquidity() and get back both dai and malt\n\n#### Recommended Mitigation Steps\n\nAccording to documentation in <https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol>\n\n> Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.\n\n, this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue \"Unable to remove liquidity in Recovery Mode\")\nThis exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/325)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/325#issuecomment-1020752336):**\n > The Malt token is programmed to explicitly prevent buying it when at discount.\n> However, because `addLiquidity` and `removeLiquidity` are callable by anyone, and the `UniswapHandler` is whitelisted, through a calculated addition and removal of liquidity anyone can mimick buying Malt for a discount (by providing imbalanced underlying and redeeming them).\n> \n> I believe this sidesteps the majority of the functionality of the protocol, and while the attack is fairly simple, it denies the protocol functionality and as such agree with a High Severity\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/325#issuecomment-1025167069):**\n > After re-review:\n> Addressing each step:\n> \n> 1) The swap can be done as the whitelisting is bypassed (so finding is valid on that end)\n> 2) User can send more liquidity\n> 3) User can add liquidity at discount (as they bought at discount) (notice that this subjects them to potentially more IL so arguably the MEV extraction happened at step 1)\n> 4) This cannot be done because of #323 which was found by the same warden. As per #323 you can't remove liquidity as the `transfer` will be from pool to user and as such will be reverted due to the system being in recovery mode.\n> \n> I believe that the warden identified a way to sidestep purchasing malt via purchase -> send to UniswapHandler -> add liquidity which should allow for some MEV extraction (with the user risking IL as they assume malt will go back to peg)\n> \n> Because of this there's still some validity to the finding, but it's not as dire as I originally believed.\n> \n> I'm going to downgrade the finding to Medium Severity as:\n> 1) Value can be extracted\n> 2) by bypassing the check for buying malt\n> \n> But this doesn't allow the selling of malt, so it's not a protocol breaking exploit but rather a way to gain MEV.\n\n\n\n",
      "summary": "\nThe reported bug is about a feature in Malt, a protocol that allows users to buy and sell tokens at a specific price. The bug allows users to bypass the buy block feature, which is designed to prevent buying tokens at a discounted price. This can be done by swapping the token to a whitelisted contract, and then using the add and remove liquidity functions to extract the token without paying the full price. This is considered a serious issue as it undermines the protocol's ability to generate profit and poses a risk for users. The recommended mitigation step is to disable the addLiquidity function when the protocol is in recovery mode. The judges and sponsor have confirmed the validity of the bug and have downgraded its severity from high to medium. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/325",
      "tags": [],
      "finders": []
    },
    {
      "id": "42390",
      "title": "[M-25] AMM pool can be drained using a flashloan and calling `stabilize`",
      "impact": "MEDIUM",
      "content": "_Submitted by stonesandtrees_\n\nAll of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.\n\n#### Proof of Concept\n\nIn the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP:\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156>\n\nHowever, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275>\n\nAttack:\n\n1.  Wait for TWAP to rise above the stabilization threshold\n2.  Flashloan remove all but a tiny amount of Malt from the pool.\n3.  Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.\n4.  Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool.\n5.  The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.\n\nThe amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.\n\n#### Recommended Mitigation Steps\n\nUse a short TWAP to calculate the trade size instead of reading directly from the pool.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/372)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/372#issuecomment-1020734907):**\n > I believe the warden has identified a valid grief and potential exploit\n> \n> I'm not convinced on the simplicity of:\n> `2. Flashloan remove all but a tiny amount of Malt from the pool.`\n> \n> You'd have to buy that liquidity in order to be able to remove the malt, which effectively makes the operation not as straightforward (if not unprofitable for the attacker).\n> \n> I do believe the grief can be performed but in lack of a clear incentive for the attacker, am going to downgrade to Medium Severity.\n> Can be done, but not clear on the incentives\n\n\n\n",
      "summary": "\nThe bug report highlights a vulnerability in the `StabilizerNode` contract, where an attacker can manipulate the price of Malt, a cryptocurrency, to steal a small amount of money from the protocol. This can also cause confusion and damage to the protocol. The recommended solution is to use a different method for calculating the trade size to prevent this exploit. The severity of the bug has been downgraded to medium, as there is not a clear incentive for an attacker to perform this exploit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/372",
      "tags": [],
      "finders": []
    },
    {
      "id": "42389",
      "title": "[M-24] `_distributeRewards` Does Not Reset Approval If Not All Tokens Were Allocated",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253>\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871>\n\n\n#### Recommended Mitigation Steps\n\nConsider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/229)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/229#issuecomment-1020720987):**\n > Finding is valid, incorrect approvals can cause reverts (USDT being an example), and not fully resetting will also negate gas refunds\n\n\n\n",
      "summary": "\nThe report is about a bug in the `distributeRewards` function of Malt Finance. This function is supposed to reward LP token holders when the price of Malt exceeds its target price. However, there is an issue with the `allocateArbRewards` function, which makes an external call to `Auction`. This function does not always use the full amount of tokens approved by the `StabilizerNode` contract, leading to a buildup of small amounts of unused tokens. This can cause reverts and negate gas refunds. To fix this, it is recommended to reset the approval amount if the input `rewarded` amount is less than the output amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/229",
      "tags": [],
      "finders": []
    },
    {
      "id": "42388",
      "title": "[M-23] `addLiquidity` Does Not Reset Approval If Not All Tokens Were Added To Liquidity Pool",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214>\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218>\n\n#### Recommended Mitigation Steps\n\nConsider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/228)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/228#issuecomment-1020718747):**\n > The UniV2Router will first [calculate the amounts](https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L71) and then [pull them](https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L73) from the msg.sender\n> \n> This means that approvals may not be fully utilized, leaving traces of approvals here and there.\n> This can cause issues with certain tokens (USDT comes to mind), and will also not trigger gas refunds.\n\n\n\n",
      "summary": "\nThe report discusses a bug in the `addLiquidity` function, which is used when users reinvest their tokens through bonding events. The function is supposed to provide protections against slippage and return any dust token amounts to the caller, which is the `RewardReinvestor` contract. However, the token approval for this outcome is not handled properly, which can lead to large Uniswap approval amounts by the `UniswapHandler` contract over time. The report recommends resetting the approval amount in certain cases to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/228",
      "tags": [],
      "finders": []
    },
    {
      "id": "42387",
      "title": "[M-22] `_calculateMaltRequiredForExit` Uses Spot Price To Calculate Malt Quantity In `exitEarly`",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109>\n- <https://shouldiusespotpriceasmyoracle.com/>\n\n\n#### Recommended Mitigation Steps\n\nConsider implementing/integrating a TWAP oracle to track the price of Malt.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/215)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/215#issuecomment-1020710474):**\n > I feel like this issue highlights the design challenge that the sponsor will have to solve, on one hand the protocol is meant to stabilize the price of malt in specific pools (impossible to block / control every pool due to permissionless nature).\n> At the same time in order to determine which direction to move the price to, they need to refer to the pricing of the underlying pools (in this case a UniV2Pool, most likely from QuickSwap)\n> \n> Personally I understand the finding and think it's valid, however I don't believe there's easy answers as to how the sponsor should address this.\n> \n> Whenever there's excess value there will be entities trying to seize it and perhaps through such a harsh environment this protocol can truly find a way to be sustainable.\n> \n> That said, I'll mark the finding as valid, but believe this specific issue underlines the challenges that await the sponsor in making the protocol succesful\n\n\n\n",
      "summary": "\nThe bug report highlights a vulnerability in the `calculateMaltRequiredForExit` function in the `AuctionEscapeHatch` contract. This function uses Malt's spot price to calculate the amount to return to a user who is exiting the protocol. However, this spot price can be manipulated through a flash loan attack, allowing an attacker to extract funds from the protocol. The report recommends implementing a TWAP oracle to track the price of Malt as a mitigation step. The sponsor of the project has confirmed the issue and a judge commented on the design challenges that need to be addressed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/215",
      "tags": [],
      "finders": []
    },
    {
      "id": "42386",
      "title": "[M-21] `StabilizerNode` Will Mint An Incentive For Triggering An Auction Even If An Auction Exists Already",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.\n\n#### Proof of Concept\n\n`_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.\n\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888>\n\n\n#### Recommended Mitigation Steps\n\nConsider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/191)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/191#issuecomment-1020125296):**\n > The warden found a way to effectively mint free malt by spamming the caller incentive by abusing a specific edge case.\n\n\n\n",
      "summary": "\nThe bug report is about a potential vulnerability in the code that allows for the creation of free Malt, a type of cryptocurrency. The vulnerability occurs when the `_startAuction` function is used to purchase Malt using the `SwingTrader` contract. If the `SwingTrader` does not have enough funds to return the price of Malt back to its target price, an auction is triggered. However, the code does not properly check if the current auction exists, which can lead to an inactive auction being used and resulting in free Malt being minted. The report suggests using consistent checks for the existence and activity of auctions in the code to prevent this vulnerability from being exploited. The bug has been confirmed by the sponsor and commented on by a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/191",
      "tags": [],
      "finders": []
    },
    {
      "id": "42385",
      "title": "[M-18] AuctionParticipant.sol: `purchaseArbitrageTokens` should not push duplicate auctions",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_\n\nIn AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.\n\nSpecifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).\n\nIt is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.\n\nNOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.\n\n#### Proof of Concept\n\nSee code for `purchaseArbitrageTokens` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40>\n\nNotice that `currentAuction` is always appended to `auctionIds`.\n\n\n#### Recommended Mitigation Steps\n\nAdd a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/87)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/87#issuecomment-1019521510):**\n > I agree with the finding, adding the same `auctionId` can lead to undefined behaviour. This can break claiming of incentives. Because of that, I think medium severity to be appropriate\n\n\n\n",
      "summary": "\nThe bug report was submitted by user harleythedog and it pertains to an issue in the AuctionParticpant.sol contract. The problem occurs when the `purchaseArbitrageTokens` function is called multiple times on the same auction. This results in the same auction id being pushed multiple times into the `auctionIds` array, causing issues with the `claim` function and the `replenishingIndex` variable. This can lead to the contract needing manual intervention to set `replenishingIndex` and can also break the claiming of incentives. The recommended mitigation step is to add a check in the `purchaseArbitrageTokens` function to ensure that duplicate ids are not added, such as by using a mapping instead of an array. The severity of this bug is considered medium and it has been confirmed by the sponsor and commented on by the judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/87",
      "tags": [],
      "finders": []
    },
    {
      "id": "42384",
      "title": "[M-17] Auction collateralToken won't work if token is fee-on-transfer token",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_\n\nThere are several ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: <https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code>). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.\n\nFor example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.\n\n#### Proof of Concept\n\nSee `purchaseArbitrageTokens` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177>\n\nSee `purchaseAndBurn` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117>\n\n\n#### Recommended Mitigation Steps\n\nAdd logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/227)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/227#issuecomment-1019511655):**\n > Agree with the finding, the system as a whole seem to not deal with feeOnTransfer Token\n> Mitigation can be as simple as never using them, or refactoring to check for actual amounts received\n\n\n\n",
      "summary": "\nERC20 tokens have a small fee on transfers called \"fee-on-transfer\" tokens. This fee is currently set to 0 for USDT, but it may change in the future. This means that when using these tokens as `collateralTokens`, special care needs to be taken. In the current test environment, there are no issues because DAI is the only `collateralToken` available. However, if more pools are added in the future, there may be problems. The function `purchaseArbitrageTokens` in Auction.sol transfers `realCommitment` amount of `collateralToken` to the liquidityExtension and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. However, the first line of `purchaseAndBurn(amount)` will revert if the token has a fee-on-transfer, causing all calls to `purchaseArbitrageTokens` to fail. This could be a problem when the price goes below peg. The recommended mitigation is to add logic to calculate the exact amount of tokens sent to a specific address, instead of using the original amount. The sponsor and judge have confirmed and commented on the finding, suggesting to either not use fee-on-transfer tokens or refactor the code to check for actual amounts received.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/227",
      "tags": [],
      "finders": []
    },
    {
      "id": "42383",
      "title": "[M-15] Bonding doesn't work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nCertain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\n#### Impact\n\nThe `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.\n\n#### Recommended Mitigation Steps\n\nTo support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/251)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/251#issuecomment-1019394195):**\n > Agree with the finding, the check will revert on a token that takes fees as the system assumes that `amount` is the amount that will be received\n\n\n\n",
      "summary": "\nThe bug report is about a problem with certain ERC20 tokens that make changes to their `transfer` or `balanceOf` functions. These tokens charge a fee for every transfer made, which is known as a fee-on-transfer token. The bug affects the `Bonding._bond()` function, which will not work properly when transferring a fee-on-transfer token. The recommended solution is to measure the change in assets before and after the transfer, and use this difference as the actual bonded amount. The bug has been confirmed by a sponsor and commented on by a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/251",
      "tags": [],
      "finders": []
    },
    {
      "id": "42382",
      "title": "[M-14] Wrong permissions on `reassignGlobalAdmin`",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")`.\n\nHowever, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.\n\n#### Recommended Mitigation Steps\n\nThe idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller *only* has the `TIMELOCK` roll and will revert in this case.\nMaybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/250)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/250#issuecomment-1019393705):**\n > The warden has identified a flaw in the roles implementation, while the system seems to work when the timelock has multiple roles, the name of the roles implies a different functionality than what can actually be done.\n> The sponsor confirms.\n> While I believe the impact in the demo setup to be fairly minor, because the finding shows a flow in the role setup, and the sponsor confirmed, I agree with medium severity\n\n\n\n",
      "summary": "\nThe `Permissions.reassignGlobalAdmin` function is used to reassign admin roles to a specific account. However, it is currently not working as intended. The function is supposed to only be called by the `TIMELOCK_ROLE`, but the caller must also have the `ADMIN_ROLE` in order for it to work properly. This means that if the `TIMELOCK_ROLE` does not have the `ADMIN_ROLE`, the function will fail. This could potentially be a problem if the `TIMELOCK_ROLE` is the only one with access to the function, as it would be impossible to reassign admin roles. This issue has been confirmed by the sponsor and a judge, and has been given a medium severity rating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/250",
      "tags": [],
      "finders": []
    },
    {
      "id": "42381",
      "title": "[M-10] AuctionParticipant.sol: `setReplenishingIndex` mistake could freeze unclaimed tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_\n\nIn AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.\n\nRight now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.\n\n#### Proof of Concept\n\nSee code for `setReplenishingIndex` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132>\n\n\n#### Recommended Mitigation Steps\n\nRemove the require statement on line 136, so that an admin can set the index to a smaller value.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/88)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/88#issuecomment-1011612291):**\n > Agree with the finding in that if the `ADMIN` were to increase the `replenishingIndex` then the unclaim tokens at auctions below the index wouldn't be claimable anymore.\n> \n> I believe the warden properly highlighted what an hypothetical abuse of `admin privilege` would look like.\n> As such I'll rate the finding with medium severity.\n> \n> I don't necessarily agree with the warden recommended mitigation, it may actually be best to simply delete the setter, or force it to go up by one index at a time after checking that all tokens are claimed\n\n\n",
      "summary": "\nThe bug report is about a function called `setReplenishingIndex` in a code file called AuctionParticipant.sol. This function is used by administrators to manually set a value called `replenishingIndex`. The person who submitted the report believes that this function could be called frequently and that eventually an administrator might accidentally set the `replenishingIndex` to the wrong value. This could cause all unclaimed tokens in auctions to be locked forever. The report suggests removing a line of code to prevent this issue from happening. The severity of the bug is rated as medium and a solution is proposed by a sponsor and a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/88",
      "tags": [],
      "finders": []
    },
    {
      "id": "42380",
      "title": "[M-09] `UniswapHandler.maltMarketPrice` returns wrong decimals",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by gzeon_\n\n\n\nThe `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price.\nHowever, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:\n\n```solidity\nelse if (rewardDecimals < maltDecimals) {\n  uint256 diff = maltDecimals - rewardDecimals;\n  price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n  decimals = maltDecimals;\n}\n```\n\nNote that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals).\nThen, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`.\nHowever `decimals = maltDecimals` is wrongly returned.\n\n#### Impact\n\nCallers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount.\nLuckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.\n\n#### Recommendation\n\nFix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/255)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/255#issuecomment-1010461081):**\n > Finding is valid, because the returned value is unused, I agree with the medium severity\n\n\n\n",
      "summary": "\nThe function `UniswapHandler.maltMarketPrice` is not returning the correct value for the `decimals` variable when the `rewardDecimals` are less than the `maltDecimals`. This can cause incorrect prices to be displayed and could potentially lead to issues. It is recommended to fix the function by returning `rewardDecimals` instead of `maltDecimals` in this case. The bug has been confirmed by a sponsor and a judge has commented that it is a valid finding.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/255",
      "tags": [],
      "finders": []
    },
    {
      "id": "42379",
      "title": "[M-08] `_getFirstSample` returns wrong sample if count < sampleMemory",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer:\n\n*   `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations.\n*   `counter`: The pending sample index (modulo `sampleMemory`)\n\nThe `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only *if the ring buffer is full*, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).\n\nIf the `samples` array does not wrap around yet, the zero index should be returned instead.\n\n#### Impact\n\nReturning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index.\nThis then leads to a wrong computation of the TWAP.\n\n#### Recommended Mitigation Steps\n\nAdd an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.\n\n**[0xScotch (sponsor) confirmed and disagreed with severity](https://github.com/code-423n4/2021-11-malt-findings/issues/252):**\n > Funds aren't directly at risk. I believe this is medium severity\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/252#issuecomment-1008466725):**\n > Personally am not sure the first sample after wrapping would be `counter + 1` (why not  `counter % sampleMemory`)\n> \n> That said, I do agree that before wrapping, the first item in the array is at the 0 index\n> \n> I agree that the protocol is not behaving properly so I can understand the high severity, that said I also agree with the Sponsor's statement, the worst case would be a leak of value, so Medium severity seems the most appropriate\n\n\n\n",
      "summary": "\nThe `MovingAverage.sol` contract has a bug that affects its computation of the TWAP (Time-Weighted Average Price). The bug is caused by the `_getFirstSample` function, which returns the wrong index for the first sample if the `samples` array is not full. This can lead to incorrect TWAP calculations. The recommended fix is to add an additional check in the function. The severity of the bug is debated, with some considering it high and others medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/252",
      "tags": [],
      "finders": []
    },
    {
      "id": "42378",
      "title": "[M-07] `MovingAverage.setSampleMemory()` may broke MovingAverage, making the value of `exchangeRate` in `StabilizerNode.stabilize()` being extremely wrong",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442>\n\n```solidity\nfunction setSampleMemory(uint256 _sampleMemory)\n  external\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");\n\n  if (_sampleMemory > sampleMemory) {\n    for (uint i = sampleMemory; i < _sampleMemory; i++) {\n      samples.push();\n    }\n    counter = counter % _sampleMemory;\n  } else {\n    activeSamples = _sampleMemory;\n\n    // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n  }\n\n  sampleMemory = _sampleMemory;\n}\n```\n\nIn the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.\n\n#### Proof of Concept\n\n*   When initial sampleMemory is `10`\n*   After `movingAverage.update(1e18)` being called for 120 times\n*   The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`\n\nThe current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`\n\nAfter `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.\n\n##### Recommendation\n\nConsider removing `setSampleMemory` function.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/313)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/313#issuecomment-1008462965):**\n > I agree that calling `setSampleMemory` will cause issues, and can cause opportunities to further extract value.\n> However this can be triggered by an admin action.\n> I'll think about the severity, but as of now, because it is contingent on admin privilege, will downgrade to Medium\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/313#issuecomment-1025181213):**\n > I stand by my decision of Medium Severity. While the consequences can be troublesome, they are contingent on the admin breaking / griefing the system\n\n\n\n",
      "summary": "\nThis bug report is about a function called `setSampleMemory` in the MovingAverage.sol contract. The function is supposed to update the `sampleMemory` variable, but it has a bug that causes the index of the samples to be incorrect. This means that when another function, `getValueWithLookback`, tries to retrieve the samples, it will get the wrong ones and return the wrong value. This bug was discovered when the sampleMemory was set to `118` after being initially set to `10` and the value returned by `getValueWithLookback` was incorrect. The recommendation is to remove the `setSampleMemory` function to prevent any further issues. The severity of this bug was initially considered high, but was downgraded to medium because it can only be triggered by an admin and not by regular users. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/313",
      "tags": [],
      "finders": []
    },
    {
      "id": "42377",
      "title": "[M-05] _notSameBlock() can be circumvented in bondToAccount()",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by leastwood and ScopeLift_\n\n\nThe function bondToAccount() of Bonding.sol has a check based on \\_notSameBlock()\n\\_notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.\n\nHowever this can be circumvented in this case:\nSuppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract.\nFor a pseudo code proof of concept see below.\n\nI'm not sure what the deeper reason is for the \\_notSameBlock() in bondToAccount().\nBut if it is important then circumventing this check it will pose a risk.\n\n#### Proof of Concept\n\ncall function attack1.attack()\n\n```JS\ncontract attack1 {\n   function attack(address account, uint256 amount) {\n         call attack2.forward(account, amount);\n         call any other function of malt\n  }\n}\n\ncontract attack2 {\n   function forward(address account, uint256 amount) {\n       call bonding.bondToAccount(account, amount); // uses msg.sender of attack2\n   }\n}\n```\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92>\n\n```JS\nfunction bondToAccount(address account, uint256 amount) public {\n    if (msg.sender != offering) {\n         _notSameBlock();\n    }\n    ...\n```\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141>\n\n```JS\nfunction _notSameBlock() internal {\n    require( block.number > lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );\n    lastBlock[_msgSender()] = block.number;\n  }\n```\n\n#### Recommended Mitigation Steps\n\nAdd access controls to the function bondToAccount()\nAn end-user could still call bond()\n\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/195)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/195#issuecomment-1008447039):**\n > `notSameBlock` is effectively being used as the `nonReentrant` modifier, without the same security guarantees, as such, in spite of not having a specific attack vector, because the warden showed how to side step this security feature of the protocol, am going to raise the severity to Medium\n\n\n\n",
      "summary": "\nThe function bondToAccount() in the Bonding.sol contract has a check called \\_notSameBlock() to prevent the same person from doing two actions within the same block. However, this check can be bypassed if a custom smart contract is used to call bondToAccount(). This poses a risk if the \\_notSameBlock() check is important. A proof of concept is provided in the report to demonstrate how this can be done. To mitigate this issue, access controls should be added to the bondToAccount() function. The severity of this bug has been raised to Medium by the judge, as the \\_notSameBlock() check is not as secure as the nonReentrant modifier.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/195",
      "tags": [],
      "finders": []
    },
    {
      "id": "42376",
      "title": "[H-04] `AuctionBurnReserveSkew.getPegDeltaFrequency()` Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132>\n\n```solidity\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n```\n\nWhen `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.\n\nThe result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.\n\n**[0xScotch (sponsor) confirmed and disagreed with severity](https://github.com/code-423n4/2021-11-malt-findings/issues/294):**\n > I actually think this should be higher severity. This bug could manifest in liquidity extension being depleted to zero which could have catastrophic consequences downstream.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/294#issuecomment-1019392232):**\n > Agree with the finding, this is an incorrect logic in the protocol, which can limit it's functionality and as the sponsor says: `could have catastrophic consequences downstream` as such I'll increase the severity to high.\n> \n> Mitigation seems to be straightforward\n\n\n",
      "summary": "\nThe bug report is about an incorrect logic in a function called `getPegDeltaFrequency()`. This function is used to calculate the `realBurnBudget` for auctions. However, when the value of `count` is less than `auctionAverageLookback`, the function returns a smaller value than expected. This can result in an improper amount of excess Liquidity Extension balance being used at the end of an auction. The severity of this bug was initially debated, but it was ultimately decided to be a high severity issue. The mitigation for this bug is straightforward. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/294",
      "tags": [],
      "finders": []
    },
    {
      "id": "1125",
      "title": "[M-30] Malt Protocol Uses Stale Results From MaltDataLab Which Can Be Abused By Users",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.\n\n## Proof of Concept\n\nConsider the following attack vector:\n- The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user.\n- The `_stabilityWindowOverride` function is satisfied, hence the function will execute.\n- The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate.\n- `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction.\n- As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments.\n- If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.\n\nThis threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.\n\n`trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable.\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.",
      "summary": "\nThe bug report is about the Malt protocol, which is a decentralized finance (DeFi) protocol that integrates several MovingAverage contracts to fetch sensitive data. The primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. These functions are called by an EOA account, which must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to MaltDataLab and effectively extract value from other areas of the protocol which use stale values. \n\nThe proof of concept for the attack vector involves a malicious attacker colluding with a miner to censor further pool updates and call the stabilize function on every fastAveragePeriod interval to extract incentive payments. If the payments exceed what the UPDATER_ROLE is willing to pay to call trackMaltPrice, then the user is able to sustain this attack. \n\nThe vulnerability threatens the overall stability of the protocol and should be properly handled to prevent such attacks. The recommended mitigation steps involve adding calls to trackMaltPrice, trackPoolReserves and trackPool wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Additionally, there needs to be necessary changes made to MaltDataLab to use cumulative price updates as its moving average instead of spot price.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/373",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1124",
      "title": "[M-29] User can bypass Recovery Mode via UniswapHandler to buy Malt ",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngzeon\n\n\n## Vulnerability details\n\n## Impact\nOne of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.\n\n## Proof of Concept\n1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted\n`swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);`\n2) User send matching amount of dai to uniswapHandler\n3) User call addLiquidity() and get back LP token\n4) User call removeLiquidity() and get back both dai and malt\n\n## Recommended Mitigation Steps\nAccording to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol\n> Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.\n, this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue \"Unable to remove liquidity in Recovery Mode\")\nThis exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode",
      "summary": "\nThis bug report is about a vulnerability in the Malt protocol, which allows users to bypass the buy block and extract tokens by abusing the add and remove liquidity function. This is considered a high severity issue because it undermines the protocol's ability to generate profit and allows potential risk-free MEV. The bug can be exploited by swapping Dai into Malt and sending Malt directly to UniswapHandler, followed by sending a matching amount of Dai to UniswapHandler. Then, the user calls addLiquidity() and gets back LP token, and then calls removeLiquidity() and gets back both Dai and Malt. The recommended mitigation step is to disable addLiquidity() when the protocol is in recovery mode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/325",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1123",
      "title": "[M-28] Bonding.sol _unbondAndBreak does not account for edge case where no tokens are returned",
      "impact": "MEDIUM",
      "content": "_Submitted by harleythedog_\n\nIn Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code:\n\n```solidity\nif (amountMalt == 0 || amountReward == 0) {\n  liquidityBalance = lpToken.balanceOf(address(this));\n  lpToken.safeTransfer(msg.sender, liquidityBalance);\n  return (amountMalt, amountReward);\n}\n```\n\nIf this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.\n\n#### Proof of Concept\n\nSee `_unbondAndBreak` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226>\n\nNotice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240>\n\n#### Recommended Mitigation Steps\n\nAdd a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/234)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/234#issuecomment-1022203715):**\n > In the `then` case the tokens will be sent back to the `Bonding.sol` contract, which has no way of rescuing or returning the tokens, probably reverting would be a better solution.\n> \n> Because the warden identified a way for tokens to get stucked, I think Medium Severity to be appropriate\n\n\n",
      "summary": "\nA bug has been reported in the Bonding.sol smart contract. This bug could cause a user's stake tokens to become stuck in the contract if the Uniswap handler's `removeLiquidity` function returns zero tokens. This is an edge case that the Uniswap handler has code to handle, but Bonding.sol does not have any logic to recognize this. As a result, the user will not get any of their value back. To fix this issue, a similar edge case check should be added to Bonding.sol and any LP tokens that are transferred back to Bonding.sol should be forwarded back to the user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/234",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1122",
      "title": "[M-27] Slippage checks when adding liquidity are too strict",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nWhen adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances.\nIf the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.\n\nSee `UniswapHandler.buyMalt`:\n\n```solidity\n(maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n  address(malt),\n  address(rewardToken),\n  maltBalance, // @audit-info amountADesired\n  rewardBalance,\n  // @audit assumes that whatever is in this contract is already balanced. good assumption?\n  maltBalance.mul(95).div(100), // @audit-info amountAMin\n  rewardBalance.mul(95).div(100),\n  msg.sender, // transfer LP tokens to sender\n  now\n);\n```\n\n#### Impact\n\nIf the contract has unbalanced balances, then the `router.addLiquidity` call will revert.\nNote that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.\n\n#### Recommended Mitigation Steps\n\nIt needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio.\nIt might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/257)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/257#issuecomment-1022202079):**\n > Interestingly the warden highlights the other side of the \"missing slippage check\" argument.\n> Slippage checks in general need to be calculated offChain (as you will get frontrun in the mempool, so the slippage check is a risk minimization tool more than anything else)\n> \n> The warden also specified a griefing attack that can be used because of the hardcoded check.\n> The sponsor confirms, I think medium severity is appropriate\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in a contract called UniswapHandler.addLiquidity. This function uses the entire contract balance to add liquidity and sets the minimum amounts to 95% of these balances. If the contract balance is unbalanced, the function will revert and no liquidity will be added. This can be exploited by an attacker sending tokens to the contract to make them unbalanced and cause the function to revert. To mitigate this vulnerability, it is recommended to ensure that the contract balances are always balanced and match the current reserve ratio. Additionally, it might be better to avoid directly using the balances and accept parameters from the caller side instead.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/257",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1121",
      "title": "[M-26] Dutch auction can be manipulated",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nWhen malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until \\_endAuction() is called. <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589>\n\n\\_endAuction() is called in\n\n1.  When auction.commitments >= auction.maxCommitments\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212>\n\n2.  On stabilize() -> checkAuctionFinalization() -> \\_checkAuctionFinalization()\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146>\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754>\n\n3.  On stabilize() ->\\_startAuction() -> triggerAuction() -> \\_checkAuctionFinalization()\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170>\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754>\n\nIt is possible manipulate the dutch auction by preventing \\_endAuction() being called.\n\n#### Proof of Concept\n\nConsider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184>) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.\n\nAs such, the only way for the auction to finalize is to call stabilize().\nHowever, this is not immediately possible because it require\n`block.timestamp >= stabilizeWindowEnd` where\n`stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod`\nstabilizeBackoffPeriod is initially set to 5 minutes in the contract\n\nAfter 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)\n\nAlso note that stabilize() might not be called since there is no incentive.\n\n#### Recommended Mitigation Steps\n\n1.  Incentivize stabilize() or incentivize a permission-less call to \\_endAuction()\n2.  Lock-in auction price when user commit purchase\n\n\n**[0xScotch (sponsor) labeled](https://github.com/code-423n4/2021-11-malt-findings/issues/375) sponsor confirmed**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1020758586):**\n > By purchasing all but 1 wei of arbitrageTokens, any caller can guarantee that the auction will offer the steepest discount.\n> \n> This is caused by the fact that AMMs (esp UniV2) will revert with small numbers, as rounding will cause the amountOut to == 0 which will cause a INSUFFICIENT_AMOUNT revert.\n> \n> I agree with the pre-conditions and the possibility of this to happen.\n> In a sense I believe this can become the meta strategy that every dutch auction participant will use (the fight between buyers will be done by paying gas to be the first few to buy arbitrageTokens).\n> \n> So the question is how to avoid it.\n> I guess purchasing at a time should lock the price for that particular buyer at that particular time (adding a mapping should increase cost of 20k on write and a few thousand gas on read).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1020759031):**\n > TODO: Decide on severity\n> \n> Medium for sure, extract value reliably.\n> Is it high though? Arguably the dutch auction is not properly coded as it allows to get a further discount instead of locking in a price for the user at time of deposit\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/375#issuecomment-1022195290):**\n > While an argument for the Dutch Auction being coded wrong (user locking in price) can be made, that's not the definition of a Dutch Auciton\n> \n> <img width=\"600\" alt=\"Screenshot 2022-01-26 at 14 16 34\" src=\"https://user-images.githubusercontent.com/13383782/151169628-a1d8e7e7-15c2-4064-a985-9f923154170a.png\">\n> https://www.investopedia.com/terms/d/dutchauction.asp\n> \n> So arguably the dutch auction is properly coded, it's that there's a specific way to sidestep it which is caused by:\n> - 1 wei tx reverting on swap\n> - sum of purchases not being enough\n> \n> For this conditions to happen the \"exploiter\" needs to be fast enough to place an order, in such a way that their order will leave 1 commitment left.\n> I can imagine them setting up a contract that reverts if this condition isn't met and that checks for w/e amount is needed at that time.\n> \n> I would assume that having an admin privileged function to close the auction prematurely would solve this specific attack.\n> \n> I believe that the warden has identified a fairly reliable way to get a discount from the protocol because of the impact and some of the technicalities I believe Medium Severity to be more appropriate.\n> This will be exploited, but in doing so will make the protocol successful (all auction full minus 1 wei), the premium / discount will be reliable predicted (50% between start and end) and as such I believe it will be priced in\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the malt system that can be manipulated by preventing the _endAuction() function from being called. The vulnerability is due to the Dutch auction, which allows users to purchase arb tokens at a decreasing price until the _endAuction() function is called. The _endAuction() function is called in three cases: when the auction.commitments is greater than or equal to the auction.maxCommitments, when stabilize() is called, or when _startAuction() is called. An attacker can exploit this vulnerability by calling purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, preventing the _endAuction() from being called. This allows the attacker to guarantee they can purchase at (startingPrice+endingPrice)/2 or lower. \n\nTo mitigate this vulnerability, two steps are recommended. The first is to incentivize stabilize() or incentivize a permission-less call to _endAuction(). The second is to lock-in the auction price when users commit to purchase.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/375",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1120",
      "title": "[M-25] AMM pool can be drained using a flashloan and calling stabilize",
      "impact": "MEDIUM",
      "content": "## Handle\n\nstonesandtrees\n\n\n## Vulnerability details\n\n## Impact\nAll of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.\n\n## Proof of Concept\nIn the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP:\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156\n\nHowever, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275\n\nAttack:\n1. Wait for TWAP to rise above the stabilization threshold\n2. Flashloan remove all but a tiny amount of Malt from the pool.\n3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg. \n4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool.\n5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.\n\nThe amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.\n\n## Tools Used\nManual review\n\n## Recommended Mitigation Steps\nUse a short TWAP to calculate the trade size instead of reading directly from the pool.",
      "summary": "\nThis bug report is about a vulnerability in the \"StabilizerNode\" of the \"2021-11-malt\" project. The vulnerability allows a malicious actor to remove all of the \"rewardToken\" from a given AMM pool and distribute it as LP rewards. To exploit the vulnerability, the malicious actor waits for the TWAP to rise above the stabilization threshold, flashloans to remove all but a tiny amount of Malt from the pool, calls the \"stabilize\" method, and then the protocol will distribute the received \"rewardToken\" as rewards. The amount of money that can be directly stolen by the malicious actor is small, but it can cause a lot of damage to the protocol. To mitigate this vulnerability, the project should use a short TWAP to calculate the trade size instead of reading directly from the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/372",
      "tags": [],
      "finders": [
        "stonestrees"
      ]
    },
    {
      "id": "1119",
      "title": "[M-24] _distributeRewards Does Not Reset Approval If Not All Tokens Were Allocated",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.",
      "summary": "\nThis bug report describes a vulnerability in Malt Finance, a decentralized finance (DeFi) protocol. The vulnerability affects the `_distributeRewards` function, which is used to reward LP token holders when the price of Malt exceeds its price target. The vulnerability occurs when an external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. As a result, dust token approval amounts may accrue from within the `StabilizerNode` contract.\n\nThe bug was discovered through manual code review and the proof of concept code can be found in the links provided in the report. The recommended mitigation step is to consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount. This will help to prevent dust token approval amounts from accruing in the `StabilizerNode` contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/229",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1118",
      "title": "[M-23] addLiquidity Does Not Reset Approval If Not All Tokens Were Added To Liquidity Pool",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.",
      "summary": "\nThis bug report is about the `addLiquidity` function which is called when users reinvest their tokens through bonding events. The `RewardReinvestor` contract first transfers Malt and rewards tokens before adding liquidity to the token pool. The bug is that the token approval for this outcome is not handled properly. This can lead to large Uniswap approval amounts by the `UniswapHandler` contract, which can accrue over time. The bug was discovered through manual code review. The recommended mitigation step is to consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/228",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1117",
      "title": "[M-22] _calculateMaltRequiredForExit Uses Spot Price To Calculate Malt Quantity In exitEarly",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109\nhttps://shouldiusespotpriceasmyoracle.com/\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider implementing/integrating a TWAP oracle to track the price of Malt.",
      "summary": "\nThis bug report is about a vulnerability in the `_calculateMaltRequiredForExit` function in the `AuctionEscapeHatch` contract. This function uses Malt's spot price to calculate the quantity to return to the exiting user, which can be manipulated via a flash loan attack to extract funds from the protocol. A proof of concept is provided in the report, as well as a link to a website that provides further information. The recommended mitigation step is to consider implementing/integrating a TWAP (Time Weighted Average Price) oracle to track the price of Malt.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/215",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1116",
      "title": "[M-21] StabilizerNode Will Mint An Incentive For Triggering An Auction Even If An Auction Exists Already",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.\n\n## Proof of Concept\n\n`_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nConsider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.",
      "summary": "\nThis bug report is about an issue with the `_startAuction` function in the Malt smart contract. The function is used to purchase Malt and, if `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, the bug is that an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.\n\nThe bug was discovered through manual code review. To fix the issue, it is recommended to use `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/191",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1115",
      "title": "[M-20] Users Can Contribute To An Auction Without Directly Committing Collateral Tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.\n\n#### Proof of Concept\n\nConsider the following scenario:\n\n*   An auction is currently active.\n*   A user sends collateral tokens to the `LiquidityExtension` contract.\n*   The same user calls `purchaseArbitrageTokens` with amount `0`.\n*   The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.\n\nAs a result, a user could effectively influence the average malt price used throughout the `Auction` contract.\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214>\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128>\n\n#### Recommended Mitigation Steps\n\nConsider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/188)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/188#issuecomment-1020112892):**\n > The warden has identified a way to side-step the cap on commitments.\n> Because the commitments are used for calculating limits, but `maltPurchased` is used to calculate rewards, an exploiter can effectively use an auction to purchase as many arbitrage tokens as they desire.\n> \n> Using any `amount` greater than zero will eventually allow to end the auction, however, by using 0 this process can be repeated continuously.\n> \n> Agree with the finding and severity\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `purchaseArbitrageTokens` function of the `Auction` and `LiquidityExtension` contracts. This function enables users to commit collateral tokens and in return receive arbitrage tokens, but it has a commitment cap which prevents users from participating in the auction when it is reached. However, this commitment cap can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`. This could lead to a user influencing the average malt price used throughout the `Auction` contract.\n\nThe bug was found using manual code review. The recommended mitigation step is to add a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/188",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1114",
      "title": "[M-19] MiningService.setBonding should use BONDING role instead of REINVESTOR one",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nBONDING_ROLE cannot be managed after it was initialized.\n\n#### Proof of Concept\n\n`setBonding` set the wrong role via \\_swapRole:\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116>\n\n#### Recommended Mitigation Steps\n\nSet `BONDING_ROLE` instead of `REINVESTOR_ROLE` in `setBonding` function:\n\nNow:\n```solidity\nfunction setBonding(address _bonding)\n  public\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_bonding != address(0), \"Cannot use address 0\");\n  _swapRole(_bonding, bonding, REINVESTOR_ROLE);\n  bonding = _bonding;\n}\n```\n\nTo be:\n```solidity\nfunction setBonding(address _bonding)\n  public\n  onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n{\n  require(_bonding != address(0), \"Cannot use address 0\");\n  _swapRole(_bonding, bonding, BONDING_ROLE);\n  bonding = _bonding;\n}\n```\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/370)**\n\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the MiningService.sol contract. The problem is that the BONDING_ROLE cannot be managed after it was initialized. A proof of concept is provided, which shows that the setBonding function sets the wrong role via _swapRole. The recommended mitigation steps are to set BONDING_ROLE instead of REINVESTOR_ROLE in the setBonding function. This change should resolve the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/370",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1113",
      "title": "[M-18] AuctionParticipant.sol: purchaseArbitrageTokens should not push duplicate auctions",
      "impact": "MEDIUM",
      "content": "## Handle\n\nharleythedog\n\n\n## Vulnerability details\n\n## Impact\nIn AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`. \n\nSpecifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield). \n\nIt is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.\n\nNOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.\n\n## Proof of Concept\nSee code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40\n\nNotice that `currentAuction` is always appended to `auctionIds`. \n\n## Tools Used\nInspection\n\n## Recommended Mitigation Steps\nAdd a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.",
      "summary": "\nThis bug report is about a vulnerability in the AuctionParticipant.sol contract. The vulnerability is that when the `purchaseArbitrageTokens` function is called multiple times on the same auction, it pushes the same auction id multiple times into the `auctionIds` array. This can cause issues with the `claim` function, specifically with the `replenishingIndex` variable. It is possible that the auction at the next index will never reward any more tokens, so the contract would need manual intervention to set `replenishingIndex`. \n\nThe bug was discovered through inspection and the proof of concept can be seen in the code for `purchaseArbitrageTokens` in the given GitHub link. The recommended mitigation step is to add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added, for example by changing `auctionIds` to a mapping instead of an array.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/87",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1112",
      "title": "[M-17] Auction collateralToken won’t work if token is fee-on-transfer token ",
      "impact": "MEDIUM",
      "content": "## Handle\n\nharleythedog\n\n\n## Vulnerability details\n\n## Impact\nThere are several ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.\n\nFor example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.\n\n## Proof of Concept\nSee `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177\n\nSee `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117\n\n## Tools Used\nInspection\n\n## Recommended Mitigation Steps\nAdd logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.",
      "summary": "\nThis bug report is about ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). The report focuses on the function `purchaseArbitrageTokens` in Auction.sol, which transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken, which would cause all calls to `purchaseArbitrageTokens` to fail.\n\nThe recommended mitigation steps are to add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/227",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1111",
      "title": "[M-16] theft of system profit",
      "impact": "MEDIUM",
      "content": "_Submitted by danb, also found by leastwood and WatchPug_\n\nSystem profit comes from the stabilize function when the price of malt is above 1. Therefore it should not be allowed for anyone to take a part of the system profit when the price is above one. Right now, anyone can take a part of the investors' profits, even if they don't own any malt at all.\n\n#### Proof of Concept\n\nsuppose that the price went up to 1.2 dai; the investors should get the reward for this rise. instead, anyone can take a part of the reward in the following steps:\nThe price of malt is now 1.2 dai.\nTake a flash loan of a large amount of malt.\nSell the malt for dai.\nNow the price went down to 1.1 dai because of the enormous swap.\nCall stabilize in order to lower the price to 1 dai.\nBuy malt to repay the flash loan at a lower cost with the bought dai.\nRepay the flash loan, and take the profit.\n\nIt is a sandwich attack because they sold malt for a high price, then they called stabilize to lower the value, then repurchase it for a low price.\n\nThe user made a profit at the expense of the investors.\n\nIf a user already has malt, it’s even easier:\njust sell all malt at a high cost.\n\n#### Recommended Mitigation Steps\n\nin \\_beforeTokenTransfer, if the price is above 1\\$ and the receiver is the AMM pool, stabilize it.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/56#issuecomment-1010442853):**\n > @0xScotch The warden says that if the price is above the peg price, the system should stabilize it\n> From reading the `PoolTransferVerification.verifyTransfer`, the system wants you to trade when Malt is above peg (minus tolerance)\n> \n> Would you say this finding is invalid?\n\n**[0xScotch (sponsor) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/56#issuecomment-1019287914):**\n > > @0xScotch The warden says that if the price is above the peg price, the system should stabilize it From reading the `PoolTransferVerification.verifyTransfer`, the system wants you to trade when Malt is above peg (minus tolerance)\n> > \n> > Would you say this finding is invalid?\n> \n> I think the issue being pointed out is that the stabilization above peg can be sandwiched and some profit that would go to LPs can be extracted. I think this is an issue but its not absolutely critical.\n> \n> We have discussed internally how to deal with this and the suggestion of calling stabilize would require some additional logic in the transfer verification as it would create a circular execution path.\n> 1. User tries to sell at 1.2\n> 2. Transfer verifier triggers stabilize\n> 3. StabilizerNode tries to sell Malt ahead of initial user\n> 4. Transfer verifier runs again and will call stabilize again unless we modify it to deal with this case.\n> \n> I don't think that is an issue but we will consider how to best move ahead with it.\n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/56#issuecomment-1019511028):**\n > Let's dissect the warden's finding:\n> ```\n> The price of malt is now 1.2 dai.\n> Take a flash loan of a large amount of malt.\n> Sell the malt for dai.\n> Now the price went down to 1.1 dai because of the enormous swap.\n> Call stabilize in order to lower the price to 1 dai.\n> Buy malt to repay the flash loan at a lower cost with the bought dai.\n> Repay the flash loan, and take the profit.\n> ```\n> \n> -> Flashloan Malt (assumes liquidity to do so, but let's allow that)\n> -> Sell malt for dai -> price goes lower\n> -> Call stabilize -> system reduces price even further\n> -> Buy back the malt\n> -> repay the loan\n> \n> I feel like this is something that can't really be avoided as due to the permissionless nature of liquidity pools, limiting the ability to sell or buy to a path will be sidestepped by having other pools being deployed to avoid those checks.\n> \n> That said, the warden has identified a way to leak value from the price control system.\n> \n> To be precise the value is being extracted against traders, as to get Malt to 1.2 you'd need a trader to be so aggressive in their purchase to push the price that high.\n> The warden showed how any arber / frontrunner can then \"steal\" the potential profits of the malt system users by frontrunning them.\n> \n> Due to the profit extraction nature of the finding, I believe Medium Severity to be correct\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in a system where profits come from a stabilize function when the price of malt is above 1. The vulnerability allows anyone to take a part of the investors' profits even if they don't own any malt. This is done by taking a flash loan of a large amount of malt, selling it for dai, then calling stabilize to lower the price of malt to 1, and then repurchasing it with the bought dai at a lower cost. This is a sandwich attack because they sold malt for a high price, then called stabilize to lower the value, and then repurchased it for a low price. The user made a profit at the expense of the investors. If a user already has malt, it is even easier, as they just need to sell all malt at a high cost. The recommended mitigation steps for this vulnerability is to add a check in _beforeTokenTransfer, if the price is above 1$ and the receiver is the AMM pool, stabilize it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/56",
      "tags": [],
      "finders": [
        "danb",
        "leastwood  WatchPug"
      ]
    },
    {
      "id": "1110",
      "title": "[M-15] Bonding doesn’t work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nCertain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\n## Impact\nThe `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.\n\n## Recommended Mitigation Steps\nTo support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.",
      "summary": "\nThis bug report details a vulnerability in certain ERC20 tokens. These tokens make modifications to their ERC20's `transfer` or `balanceOf` functions, such as charging a fee for every `transfer()` or `transferFrom()`. This can cause the `Bonding._bond()` function to revert in the `_balanceCheck` when transferring the token, as it assumes the entire `amount` was received. The recommended mitigation steps for this vulnerability are to measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/251",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1109",
      "title": "[M-14] Wrong permissions on reassignGlobalAdmin",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")`.\n\nHowever, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.\n\n## Recommended Mitigation Steps\nThe idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case.\nMaybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.",
      "summary": "\nThis bug report is about an issue with the `Permissions.reassignGlobalAdmin` function in the system. This function is supposed to only be run with the `TIMELOCK_ROLE` role, however, it does not work if the caller only has the `TIMELOCK_ROLE` role and will revert in this case. This is because the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`. The recommended mitigation step is to check why the admin role was removed from the timelock, which is making it impossible to call `reassignGlobalAdmin` anymore.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/250",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1108",
      "title": "[M-13] Reducing the epoch length results in leaking value from advancement incentives",
      "impact": "MEDIUM",
      "content": "_Submitted by TomFrench_\n\n\nUnintended advancement incentives being paid out to third party\n\n#### Proof of Concept\n\n`DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63>\n\nThis start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67>\n\nThis method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114>\n\nIn the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.\n\n#### Recommended Mitigation Steps\n\nRather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/4)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/4#issuecomment-1019293929):**\n > Given a specific epoch length, the system will be able to determine which incentives to pay out.\n> Because the math for calculating the next epoch is based on the initial time, changing the `epochLength` can cause unintended consequences and allow for further calls to `advance` with the goal of receiving more caller incentives.\n> \n> The exploit can be triggered by admin privileges (changing epochLength), and because it's a leak of value, I agree with medium severity\n\n\n\n",
      "summary": "\nThis bug report relates to unintended advancement incentives being paid out to third parties in the code-423n4/2021-11-malt application. The `advance` function in the `DAO.sol` file incentivizes outside parties to advance the epoch by minting 100 MALT tokens. This is limited by checking that the start timestamp of the next epoch has passed, which is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp. However, this method does not take into account the fact that the epoch length may have been changed in the past. If the epoch length is reduced, it is possible for the epoch number to be incremented multiple times and unnecessary incentives to be paid out. To fix this vulnerability, it is recommended to store the last time the epoch length was modified and calculate from there.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/4",
      "tags": [],
      "finders": [
        "TomFrench"
      ]
    },
    {
      "id": "1107",
      "title": "[M-12] Permissions - return values not checked when sending ETH",
      "impact": "MEDIUM",
      "content": "_Submitted by ScopeLift, also found by nathaniel_\n\nOn lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance\n\n#### Proof of Concept\n\nEnter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Receivier{}\n\ncontract Permissions {\n  constructor() payable {}\n\n  function emergencyWithdrawGAS(address payable destination) external {\n    (bool ok, ) = destination.call{value: address(this).balance}('');\n    require(ok, \"call failed\");\n  }\n}\n```\n\n#### Tools Used\n\nRemix\n\n#### Recommended Mitigation Steps\n\nIn `emergencyWithdrawGAS`:\n\n```diff\n- destination.call{value: address(this).balance}('');\n+ (bool ok, ) = destination.call{value: address(this).balance}('');\n+ require(ok, \"call failed\");\n```\n\nAnd similar for `partialWithdrawGAS`\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/329)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/329#issuecomment-1019293046):**\n > Agree with the finding, I believe if a developer were to not use safeTransfer we'd rate as medium, so while I believe the impact to be minimal (no composability), I'll keep the severity to medium\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ScopeLift code. The vulnerability is that on lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance. To prove this vulnerability, the user was asked to enter some code in Remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Then, calling `emergencyWithdrawGAS` with the receiver address should result in a revert.\n\nThe recommended mitigation steps for this vulnerability are to add a verification to the `emergencyWithdrawGAS` and `partialWithdrawGAS` functions. This can be done by adding a `require(ok, \"call failed\");` line after the `.call` statement. This verifies that the call was successful and prevents the vulnerability from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/329",
      "tags": [],
      "finders": [
        "ScopeLift",
        "nathaniel"
      ]
    },
    {
      "id": "1106",
      "title": "[M-11] No max for advanceIncentive",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by 0x1f8b_\n\n\nThe function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive.\nIf incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.\n\nThe function setAdvanceIncentive() can only be called by an admin, but a mistake could be made.\nAlso if an admin would want to do a rug pull, this would be an ideal place to do it.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104>\n\n```js\nfunction setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, \"Must have admin role\") {\n  ...\n  advanceIncentive = incentive;\n```\n\n<https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63>\n\n```js\nfunction advance() external {\n...\n  malt.mint(msg.sender, advanceIncentive * 1e18);\n\n```\n\n#### Recommended Mitigation Steps\n\nCheck for a reasonable maximum value in advance()\n\n**[0xScotch (sponsor) confirmed and disagreed with severity](https://github.com/code-423n4/2021-11-malt-findings/issues/190):** \n > Definitely need to guard against arbitrarily large incentives. Disagree the risk is medium though.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/190#issuecomment-1019288176):**\n > Agree with the finding, this is an example of admin privilege, where the admin can set a variable which can be used to dilute the token and rug the protocol.\n> \n> Because this is contingent on the admin's action, I believe medium severity to be proper\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/190#issuecomment-1025181758):**\n > The simple rationale on the medium severity is that the owner could set the incentive to an exorbitant amount with the goal of minting a lot of tokens for an exit scam\n\n\n\n",
      "summary": "\nThis bug report concerns the function setAdvanceIncentive of DAO.sol in the code-423n4/2021-11-malt repository. This function does not check for a maximum value of incentive, which can cause the function advance() to mint a large amount of malt. This could be exploited by an admin to do a rug pull.\n\nThe recommended mitigation step is to check for a reasonable maximum value in advance(). This can be done by adding a line of code that checks the value of incentive against a reasonable maximum before allowing advanceIncentive to be set.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/190",
      "tags": [],
      "finders": [
        "gpersoon",
        "0x1f8b"
      ]
    },
    {
      "id": "1105",
      "title": "[M-10] AuctionParticipant.sol: setReplenishingIndex mistake could freeze unclaimed tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\nharleythedog\n\n\n## Vulnerability details\n\n## Impact\nIn AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.\n\nRight now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.\n\n## Proof of Concept\nSee code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132\n\n## Tools Used\nInspection\n\n## Recommended Mitigation Steps\nRemove the require statement on line 136, so that an admin can set the index to a smaller value.",
      "summary": "\nThis bug report is about a vulnerability in the AuctionParticipant.sol smart contract. This vulnerability is related to the function setReplenishingIndex which allows an admin to manually set the replenishingIndex value. If an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value. This would result in all unclaimed tokens on auctions at smaller indices being locked forever. The recommended mitigation step is to remove the require statement on line 136, so that an admin can set the index to a smaller value. This would prevent this issue from happening in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/88",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "1104",
      "title": "[M-09] UniswapHandler.maltMarketPrice returns wrong decimals",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price.\nHowever, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:\n\n```solidity\nelse if (rewardDecimals < maltDecimals) {\n  uint256 diff = maltDecimals - rewardDecimals;\n  price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n  decimals = maltDecimals;\n}\n```\n\nNote that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals).\nThen, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`.\nHowever `decimals = maltDecimals` is wrongly returned.\n\n## Impact\nCallers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount.\nLuckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.\n\n## Recommendation\nFix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.",
      "summary": "\nThe UniswapHandler.maltMarketPrice function returns a tuple of the price and the decimals of the price, but the decimals do not match the computed price in the else if (rewardDecimals < maltDecimals) branch. This could lead to an issue as the caller to the function will receive a price in unexpected decimals and might inflate or deflate the actual amount. However, the AuctionEscapeHatch decides to completely ignore the returned decimals, so the issue is currently not being seen. The recommendation is to fix the function by returning rewardDecimals instead of maltDecimals in the rewardDecimals < maltDecimals branch.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/255",
      "tags": [],
      "finders": [
        "cmichel",
        "gzeon"
      ]
    },
    {
      "id": "1103",
      "title": "[M-08] _getFirstSample returns wrong sample if count < sampleMemory",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer:\n- `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations.\n- `counter`: The pending sample index (modulo `sampleMemory`)\n\nThe `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).\n\nIf the `samples` array does not wrap around yet, the zero index should be returned instead.\n\n## Impact\nReturning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index.\nThis then leads to a wrong computation of the TWAP.\n\n## Recommended Mitigation Steps\nAdd an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.",
      "summary": "\nThis bug report is about a vulnerability in the `MovingAverage.sol` contract. The `samples` array in the contract acts as a ring buffer and the `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which should return the correct index only if the ring buffer is full. However, if the `samples` array does not wrap around yet, the zero index should be returned instead. As a result, returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index which then leads to a wrong computation of the TWAP. The recommended mitigation step is to add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/252",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1102",
      "title": "[M-07] MovingAverage.setSampleMemory() may broke MovingAverage, making the value of exchangeRate in StabilizerNode.stabilize() being extremely wrong",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442\n\n```solidity=424\n  function setSampleMemory(uint256 _sampleMemory)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");\n\n    if (_sampleMemory > sampleMemory) {\n      for (uint i = sampleMemory; i < _sampleMemory; i++) {\n        samples.push();\n      }\n      counter = counter % _sampleMemory;\n    } else {\n      activeSamples = _sampleMemory;\n\n      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n    }\n\n    sampleMemory = _sampleMemory;\n  }\n```\n\nIn the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.\n\n## PoC\n\n-  When initial sampleMemory is `10`\n-  After `movingAverage.update(1e18)` being called for 120 times\n-  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`\n\nThe current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`\n\nAfter `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.\n\n### Recommendation\n\nConsider removing `setSampleMemory` function.",
      "summary": "\nBug report summary: A bug was discovered in the MovingAverage.sol contract on line 424-442. When the sampleMemory is updated, the samples index is malpositioned, making the getValueWithLookback() function return the wrong value. A proof of concept was provided, in which the admin calls setSampleMemory(118) and the getValueWithLookback(sampleLength * 10) returns 0.00000203312 e18 instead of the expected 1e18. The recommendation is to remove the setSampleMemory() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/313",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1101",
      "title": "[M-06] AbstractRewardMine - Re-entrancy attack during withdrawal",
      "impact": "MEDIUM",
      "content": "_Submitted by ScopeLift_\n\n\nThe internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.\n\n#### Recommended Mitigation Steps\n\nThe internal accounting should be done before the transfer occurs:\n\n```solidity\nfunction _withdraw(address account, uint256 amountReward, address to) internal {\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;f\n\n   rewardToken.safeTransfer(to, amountReward);\n\n    emit Withdraw(account, amountReward, to);\n  }\n```\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/333)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/333#issuecomment-1008447954):**\n > The warden identified a re-entrancy vulnerability that, given the right token would allow to drain the entirety of the contract.\n> \n> Tokens with hooks (ERC777 and ERC677) would allow to exploit the contract and drain it in it's entirety.\n> \n> This is a very serious vulnerability.\n> However it can happen exclusively on a malicious or a token with hooks, as such (while I recommend the sponsor to mitigate by following recommendation by the warden), the attack can be completely prevented by using a token without hooks.\n> \n> For that reason I'll rate the finding of medium severity (as it requires external conditions)\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the internal `_withdraw` method of ScopeLift. This method does not follow the checks-effects-interactions pattern, which means a malicious token or one that implements transfer hooks could re-enter the public calling function before proper internal accounting is completed. This would allow a malicious contract to re-enter `_withdraw` repeatedly and drain the pool. No proof of concept or tools were used to identify the vulnerability. The recommended mitigation step is to revise the internal accounting so that it is done before the transfer occurs. This would ensure that the `_userWithdrawn` mapping is updated before the transfer and reduce the risk of a malicious contract draining the pool.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/333",
      "tags": [],
      "finders": [
        "ScopeLift"
      ]
    },
    {
      "id": "1100",
      "title": "[M-05] _notSameBlock() can be circumvented in bondToAccount() ",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function bondToAccount() of Bonding.sol has a check based on _notSameBlock()\n _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.\n\nHowever this can be circumvented in this case:\nSuppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract.\nFor a pseudo code proof of concept see below.\n\nI'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount().\nBut if it is important then circumventing this check it will pose a risk.\n\n## Proof of Concept\ncall function attack1.attack()\n```JS\ncontract attack1 {\n   function attack(address account, uint256 amount) {\n         call attack2.forward(account, amount);\n         call any other function of malt\n  }\n}\n\ncontract attack2 {\n   function forward(address account, uint256 amount) {\n       call bonding.bondToAccount(account, amount); // uses msg.sender of attack2\n   }\n}\n```\n\nhttps://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92\n\n```JS\nfunction bondToAccount(address account, uint256 amount) public {\n    if (msg.sender != offering) {\n         _notSameBlock();\n    }\n    ...\n```\n\nhttps://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141\n```JS\nfunction _notSameBlock() internal {\n    require( block.number > lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );\n    lastBlock[_msgSender()] = block.number;\n  }\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\nAdd access controls to the function bondToAccount()\nAn end-user could still call bond()",
      "summary": "\nA bug report has been filed for the function bondToAccount() of Bonding.sol in the code-423n4/2021-11-malt repository. The bug is related to the check based on _notSameBlock() which is meant to make sure the same msg.sender cannot do two actions within the same block. However, if the function is called via a custom smart contract, the msg.sender will be the address of the smart contract, and this check can be circumvented. This poses a risk if the _notSameBlock() is important. The recommended mitigation step is to add access controls to the function bondToAccount(), although an end-user could still call bond().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/195",
      "tags": [],
      "finders": [
        "leastwood  ScopeLift",
        "gpersoon"
      ]
    },
    {
      "id": "1099",
      "title": "[M-04] The Power Structure is Too Centralized And Protocol May Break If Anything Happen to Admin",
      "impact": "MEDIUM",
      "content": "_Submitted by Meta0xNull_\n\n\nThere are a lot of different roles in Malt Finance to handle different tasks. All these roles only can set by Admin. If anything happen to Admin and he/she no longer available, the protocol will start countdown to the end of life.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L890-L1013>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardDistributor.sol#L291-L345>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L327-L355>\nMany More Sol....\n\n#### Recommended Mitigation Steps\n\n1.  Some tasks don't really need a special role like StabilizerNode. Should allow any community members to run their own StabilizerNode without approval needed.\n2.  Consider transfer Admin to Multisig or DAO.\n\n**[0xScotch (sponsor) disputed](https://github.com/code-423n4/2021-11-malt-findings/issues/124):**\n > This is a known risk that is by design. We will migrate to DAO control of parameters when the protocol matures. \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/124#issuecomment-1008445251):**\n > I respect the wardens work for flagging this up.\n> Because any of these exploits are contingent on the Admin being malicious, I'll downgrade to Medium Severity\n\n\n\n",
      "summary": "\nThis bug report is about Malt Finance, a protocol which has a lot of different roles to handle different tasks. These roles can only be set by an Admin, and if anything happens to the Admin, the protocol will start a countdown to the end of life. The bug was found using Manual Review, and two recommended mitigation steps are proposed: allowing any community members to run their own StabilizerNode without approval needed, and considering transferring Admin to Multisig or DAO.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/124",
      "tags": [],
      "finders": [
        "Meta0xNull"
      ]
    },
    {
      "id": "1098",
      "title": "[M-03] AbstractRewardMine.sol#setRewardToken is dangerous",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x0x0x, also found by harleythedog and hyh_\n\n\nIn case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.\n\n#### Recommendation\n\nI think it would be the best to remove this function.\n\nIf you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/285)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/285#issuecomment-1008437864):**\n > Agree with highlighting the Admin Privilege, however because this is contingent on a malicious Admin, I'll downgrade the finding to Medium Severity.\n> \n> Mitigation could be done by ensuring old rewards are sent out, still claimable, or by making the `rewardToken` immutable\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability in the reward token system. If the reward token is changed, the totalDeclaredReward will be set to 0, and the _userStakePadding and _globalStakePadding variables will remain unchanged. This could create problems. The recommendation is to remove the function entirely, or if it is to be kept, it should be used by a timelock contract and the new token should be distributed in a way that the padding variables still make sense.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/285",
      "tags": [],
      "finders": [
        "0x0x0x",
        "harleythedog  hyh"
      ]
    },
    {
      "id": "1097",
      "title": "[M-02] Frontrunning in UniswapHandler calls to UniswapV2Router",
      "impact": "MEDIUM",
      "content": "_Submitted by thank_you, also found by 0x0x0x, cmichel, defsec, harleythedog, hyh, Koustre, leastwood, Meta0xNull, pauliax, pmerkleplant, tabish, WatchPug, and xYrYuYx_\n\n\nUniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.\n\n*   addLiquidity\n*   removeLiquidity\n*   swapExactTokensForTokens (swaps for both DAI and Malt)\n\nIn all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.\n\nUniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.\n\nHow does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.\n\nIt's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.\n\nThe following functions when called are vulnerable to frontrunning attacks:\n\n*   [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131)\n*   [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160)\n*   [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)\n\nAnd by extension the following contract functions since they also call the UniswapHandler function calls:\n\n*   [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114)\n*   [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117)\n*   [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78)\n*   [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145)\n*   [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)\n\n#### Proof of Concept\n\nRefer to the impact section for affected code and links to the appropriate LoC.\n\n#### Recommended Mitigation Steps\n\nThe UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.\n\n#### Anything Else We Should Know\n\nI wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.\n\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/219)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/219#issuecomment-1008433912):**\n > Because transactions sit on the mempool (which is public, hence accessible by anyone), they can be frontrun, because of this swapping protocols (uniswap in this case) offer slippage checks.\n> Setting the slippage checks allows a frontrunner to squeeze the maximum amount of value possible (sometimes the whole amount).\n> \n> Because this applies to a leak of value, I believe medium severity to be correct\n\n\n\n",
      "summary": "\nThis bug report is about the UniswapHandler contract which utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. The problem is that UniswapHandler does not correctly handle price slippage when calling removeLiquidity and swapExactTokensForTokens, and passes in 0 as the amount out minimum allowed for a trade, which allows for anyone watching the mempool to sandwich attack UniswapHandler. This means that a hacker can watch the mempool for a transaction, buy as much of the token being traded, raise the price, and then trade their tokens for the original token, earning a profit due to the artificially inflated price. This affects the buyMalt, sellMalt, removeLiquidity, unbondAndBreak, purchaseAndBurn, splitReinvest, stabilize, and buyMalt functions.\n\nThe recommended mitigation steps are to allow only the UniswapHandler contract to call the UniswapV2Router and UniswapV2Pair contracts, and to implement price slippage checks whenever removing liquidity or swapping tokens. This would prevent a frontrunning attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/219",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "pmerkleplant",
        "harleythedog",
        "pauliax",
        "cmichel",
        "leastwood",
        "Meta0xNull",
        "Koustre",
        "thankyou",
        "WatchPug",
        "tabish",
        "0x0x0x",
        "hyh",
        "xYrYuYx_",
        "defsec"
      ]
    },
    {
      "id": "1096",
      "title": "[M-01] TIMELOCK_ROLE Has Absolute Power to Withdraw All FUND May Raise Red Flags for Investors",
      "impact": "MEDIUM",
      "content": "_Submitted by Meta0xNull_\n\n\n`TIMELOCK_ROLE` Can Withdraw All FUND from the Contracts via `emergencyWithdrawGAS(), emergencyWithdraw(), partialWithdrawGAS(), partialWithdraw()`.\n\nWhile I believe developer have good intention to use these functions. It often associate with Rug Pull by developer in the eyes of investors because Rug Pull is not uncommon in Defi. Investors lose all their hard earn money.\n\nRead More: \\$10.8M Stolen, Developers Implicated in Alleged Smart Contract 'Rug Pull'\n<https://www.coindesk.com/tech/2020/12/02/108m-stolen-developers-implicated-in-alleged-smart-contract-rug-pull/>\n\nRead More: The Rise of Cryptocurrency Exit Scams and DeFi Rug Pulls\n<https://www.cylynx.io/blog/the-rise-of-cryptocurrency-exit-scams-and-defi-rug-pulls/>\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L80-L109>\n\n#### Recommended Mitigation Steps\n\n1.  Pause the Contract and Disable All Functions when Bad Thing Happen rather than Withdraw All Fund to a random address.\n2.  If Withdraw Fund can't avoid, a Multi Sig ETH Address should be hardcoded into the contract to ensure the fund move to a safe wallet.\n\n\n**[0xScotch (sponsor) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/125#issuecomment-988785042):**\n > Duplicate of #263\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/125#issuecomment-1008068213):**\n > This is not a duplicate of #263, where 263 talks about sidestepping the delay of the timelock, this finding talks about the high degree of power that the TIMELOCK_ROLE has.\n> \n> This is a typical \"admin privilege\" finding, it's very important to disclose admin privileges to users so that they can make informed decisions\n> \n> In this case the TIMELOCK_ROLE can effectively rug the protocol, however this is contingent on the account that has the role to pull the rug.\n> \n> Because of its reliance on external factors, am downgrading the finding to medium severity\n\n\n\n",
      "summary": "\nThis bug report is about a vulnerability that could allow the TIMELOCK_ROLE to withdraw all funds from a contract using emergencyWithdrawGAS(), emergencyWithdraw(), partialWithdrawGAS(), and partialWithdraw() functions. This could be seen as a rug pull, which is when a developer takes all the funds from a contract without warning, leaving investors with nothing. This vulnerability could be exploited by malicious actors to steal funds.\n\nThe proof of concept is provided in the report, which is a link to a GitHub page. The tools used to find the vulnerability were manual review.\n\nThe recommended mitigation steps are to pause the contract and disable all functions when bad things happen, and if withdrawing funds can't be avoided, a multi-sig ETH address should be hardcoded into the contract to ensure the funds move to a safe wallet.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/125",
      "tags": [],
      "finders": [
        "Meta0xNull"
      ]
    },
    {
      "id": "1095",
      "title": "[H-05] AuctionEschapeHatch.sol#exitEarly updates state of the auction wrongly",
      "impact": "HIGH",
      "content": "_Submitted by 0x0x0x_\n\n`AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the\n\nWhen the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:\n\n`uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`\n\nThe ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.\n\nIn other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.\n\n#### Mitigation Step\n\nMake sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/268)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/268#issuecomment-1020736987):**\n > The warden has identified an exploit that allows early withdrawers to gain more rewards than expected.\n> Anytime \"points\" and rewards need to be earned over time, it's ideal to accrue points in order to distribute them (see how Compound or AAVE tokens work)\n> Because the warden showed a flow in the accounting logic for the protocol, I agree with high severity.\n\n\n\n \n",
      "summary": "\nThis bug report is about an issue in the \"AuctionEschapeHatch.sol#exitEarly\" function. When a user exits an auction with profit, the penalty applied to the liquidated amount is less than the amount of malt token the liquidated amount corresponds to. This is because the function \"auction.amendAccountParticipation()\" subtracts the malt quantity with penalty and full amount from the user's auction stats. This causes a problem because the ratio of \"userMaltPurchased / userCommitment\" gets higher after each profit taking, allowing the user to earn more than they should. Furthermore, after all the userMaltPurchased is claimed, the user can have userCommitment left over, which can be used to claimArbitrage.\n\nTo mitigate this issue, it is important to make sure which values are used for what and update values which don't create problems like this. Additionally, it is important to rethink how to track values of an auction correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/268",
      "tags": [],
      "finders": [
        "0x0x0x"
      ]
    },
    {
      "id": "1094",
      "title": "[H-04] AuctionBurnReserveSkew.getPegDeltaFrequency() Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction ",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132\n\n```solidity=116{131}\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n```\n\nWhen `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.\n\nThe result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.",
      "summary": "\nThis bug report is about a vulnerability found in the code of the WatchPug project. The code in question is located in the AuctionBurnReserveSkew.sol file, from line 116 to line 132. The vulnerability is related to the function getPegDeltaFrequency(), which calculates the total of pegObservations and returns it multiplied by 10000 divided by auctionAverageLookback. The problem is that when count is smaller than auctionAverageLookback, the return should be the total multiplied by 10000 divided by count instead, otherwise the result will be smaller than expected. This can lead to an improper amount of excess Liquidity Extension balance being used at the end of an auction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/294",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1093",
      "title": "[H-03] getAuctionCore function returns wrong values out of order",
      "impact": "HIGH",
      "content": "_Submitted by jayjonah8_\n\n\n\n#### Impact\n\nIn the `AuctionEscapeHatch.sol` file both `earlyExitReturn()` and `\\_calculateMaltRequiredForExit` call the `getAuctionCore()` function which has 10 possible return values most of which are not used.  It gets the wrong value back for the \"active\"  variable since it's the 10th argument but both functions have it as the 9th return value where \"preAuctionReserveRatio\" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174>\n- <https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527>\n\n#### Tools Used\n\nManual code review\n\n#### Recommended Mitigation Steps\n\nIn `AuctionEscapeHatch.sol` change the following in `\\_calculateMaltRequiredForExit()` and earlyExitReturn() functions:\n\nFrom:\n\n(,,,,,\nuint256 pegPrice,\n,\nuint256 auctionEndTime,\nbool active\n) = auction.getAuctionCore(\\_auctionId);\n\nTo:\n\n(,,,,,\nuint256 pegPrice,\n,\nuint256 auctionEndTime,\n,\nbool active\n) = auction.getAuctionCore(\\_auctionId);\n\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/63)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/63#issuecomment-1019278807):**\n > The warden identified a mistake in programming where the code would use the wrong returned value.\n> Because of this, the entire protocol functionality can be compromised.\n> As such I agree with High Severity\n\n\n\n",
      "summary": "\nThis bug report describes a vulnerability in the AuctionEscapeHatch.sol file of the 2021-11-malt project. This vulnerability can result in a loss of user funds. The functions _calculateMaltRequiredForExit and earlyExitReturn both call the getAuctionCore() function, which has 10 possible return values. However, due to a missing comma, the wrong value is returned for the \"active\" variable. \n\nThe bug was discovered through manual code review and the proof of concept can be found at the following links:\n\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174\nhttps://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527\n\nThe recommended mitigation step is to change the code in _calculateMaltRequiredForExit() and earlyExitReturn() functions by adding a comma where it is missing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/63",
      "tags": [],
      "finders": [
        "jayjonah8"
      ]
    },
    {
      "id": "1092",
      "title": "[H-02] Unable to remove liquidity in Recovery Mode",
      "impact": "HIGH",
      "content": "_Submitted by gzeon_\n\nAccording to <https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol>\n\n> When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.\n\nHowever, in <https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236>\nliquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53>\n\n#### Recommended Mitigation Steps\n\nLiquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender\n\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/323)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/323#issuecomment-1010448871):**\n > I believe this finding to be correct, because of the whitelisting on `verifyTransfer`, during recovery mode the removal of liquidity from UniSwapV2Pair will perform safeTransfers: https://github.com/Uniswap/v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/UniswapV2Pair.sol#L148\n> \n> This means that the `_beforeTokenTransfer` will be called which eventually will call `verifyTransfer` which, if the price is below peg will revert.\n> \n> Transfering the funds to the whitelisted contract should avoid this issue.\n> \n> \n> I'd like to remind the sponsor that anyone could deploy similar swapping contracts (or different ones such as curve), so if a person is motivate enough, all the whitelisting could technically be sidestepped.\n> \n> That said, given the condition of LPing on Uniswap, the check and the current system would make it impossible to withdraw funds.\n> \n> Because this does indeed compromises the availability of funds (effectively requiring the admin to unstock them manually via Whitelisting each user), I agree with High Severity\n\n\n\n",
      "summary": "\nThis bug report is about the Malt protocol, which is a protocol for trading on decentralized exchanges. The bug is that when the Malt price TWAP drops below a certain threshold, the protocol will revert any transaction that tries to remove Malt from the AMM pool. The recommended mitigation step is to have liquidity removed to the UniswapHandler contract, and then the proceed is sent to msg.sender. This will ensure that the transaction will not be reverted.",
      "quality_score": 4,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/323",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1091",
      "title": "[H-01] Timelock can be bypassed",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0x0x0x and gzeon_\n\nThe purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.\n\nHowever, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.\n\nTo do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.\n\nAnd the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.\n\nThe new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.\n\nIn conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105>\n\n```solidity\n  function setGovernor(address _governor)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    _swapRole(_governor, governor, GOVERNOR_ROLE);\n    governor = _governor;\n    emit NewGovernor(_governor);\n  }\n```\n\n<https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77>\n\n```solidity\n  function setDelay(uint256 _delay)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _delay >= 0 && _delay < gracePeriod,\n      \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"\n    );\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n```\n\n#### Recommendation\n\nConsider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.\n\nSpecificaly, changing from `onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")` to `require(msg.sender == address(this), \"...\")`.\n\nAlso, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.\n\n**[0xScotch (sponsor) confirmed](https://github.com/code-423n4/2021-11-malt-findings/issues/263)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-11-malt-findings/issues/263#issuecomment-1008067115):**\n > The warden has identified an exploit that allows to sidestep the delay for the timelock, effectively bypassing all of the timelock's security guarantees. Because of the gravity of this, I agree with the high risk severity.\n> \n> Mitigation can be achieved by ensuring that all operations run under a time delay\n\n\n\n",
      "summary": "\nThis bug report is about a Timelock contract, which is meant to put a limit on the privileges of the governor by forcing a two step process with a preset delay time. However, the current implementation allows the governor to execute any transactions without any constraints. This is done by the governor calling the Timelock#setGovernor(address _governor) function and setting a new governor effective immediately, and then the new governor can call Timelock#setDelay() and change the delay to 0, also effective immediately. The new governor then has unrestricted access to privileges, including granting minter role to any address and minting unlimited amounts of MALT.\n\nThe recommendation is to consider making the setGovernor and setDelay functions only callable from the Timelock contract itself, by changing the onlyRole(GOVERNOR_ROLE, \"Must have timelock role\") to require(msg.sender == address(this), \"...\"), and also changing the _adminSetup(_admin) in Timelock#initialize() to _adminSetup(address(this)). This would ensure that all roles are managed by the timelock itself.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Malt Finance",
      "source_link": "https://code4rena.com/reports/2021-11-malt",
      "github_link": "https://github.com/code-423n4/2021-11-malt-findings/issues/263",
      "tags": [],
      "finders": [
        "WatchPug",
        "0x0x0x  gzeon"
      ]
    },
    {
      "id": "42306",
      "title": "[M-15] `MochiTreasuryV0.sol` Is Unusable In Its Current State",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n#### Impact\n`MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.\n\n#### Proof of Concept\n- [`VotingEscrow.vy` L418](https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418)\n- [`VotingEscrow.vy` L438](https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438)\n- [`VotingEscrow.vy` L455](https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455)\n\n\n#### Tools Used\n- Manual code review\n- Discussions with the Mochi team\n\n#### Recommended Mitigation Steps\nConsider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/168)**\n\n",
      "summary": "\nA user named leastwood has reported a bug in the `MochiTreasuryV0.sol` contract. This contract interacts with another contract called `VotingEscrow.vy` to lock tokens for 90 days and then withdraw them later. However, the `VotingEscrow.vy` contract does not allow contracts to call certain functions, which means that any attempts to lock tokens will fail. This bug has been confirmed by the Mochi team and it is recommended to either update the contract to use a different escrow service or replace the functionality with an internal contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/168",
      "tags": [],
      "finders": []
    },
    {
      "id": "42305",
      "title": "[M-14] `MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n#### Impact\n`withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.\n\n#### Proof of Concept\n- [`MochiTreasuryV0.sol#L40` L42](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42)\n\n#### Tools Used\nManual code review\n\n#### Recommended Mitigation Steps\nConsider adding `require(lockCrv, \"!lock\");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.\n\n[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/161)\n\n",
      "summary": "\nThe report states that the function `withdrawLock()` in the MochiTreasuryV0.sol contract does not prevent users from calling it even when the locking feature has been toggled. This can lead to unexpected withdrawals. The bug was found through a manual code review and the recommended solution is to add a requirement to check if the lock has been toggled before allowing the function to be called. The Mochi team has confirmed the issue and is working on a fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/161",
      "tags": [],
      "finders": []
    },
    {
      "id": "42304",
      "title": "[M-13] Improper Validation Of `create2` Return Value",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n#### Impact\nThe `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).\n\n#### Proof of Concept\n- [`BeaconProxyDeployer.sol` L31](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31)\n\n#### Tools Used\n- Manual code review\n- Discussions with the Mochi team\n- Discussions with library dev\n\n#### Recommended Mitigation Steps\nThe recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/155)**\n\n",
      "summary": "\nThe `BeaconProxyDeployer.deploy()` function is not working properly when there is a failed contract deployment or revert from the `create2` opcode. This is because the function does not properly check the returned address for bytecode. The recommended solution is to update `iszero(result)` to `iszero(extcodesize(result))` in the corresponding library and also in Mochi's contracts. This has already been confirmed by the Mochi team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/155",
      "tags": [],
      "finders": []
    },
    {
      "id": "42303",
      "title": "[M-09] `UniswapV2TokenAdapter` does not support Sushiswap-only assets",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `UniswapV2TokenAdapter.supports` function calls its `aboveLiquidity` function which returns the UniswapV2 liquidity if the pair exists.\nIf this is below `minimumLiquidity`, the `supports` function will return `false`.\n\nHowever, it could be that the `Sushiswap` pair has lots of liquidity and could be used.\n\n```solidity\ntry uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n    float memory price = cssrRouter.getPrice(_pairedWith);\n    // @audit this returns early. if it's false it should check sushiswap first\n    return convertToValue(liq, price) >= minimumLiquidity;\n} catch {\n    try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n        uint256 liq\n    ) {\n        float memory price = cssrRouter.getPrice(_pairedWith);\n        return convertToValue(liq, price) >= minimumLiquidity;\n    } catch {\n        return false;\n    }\n}\n```\n\n#### Impact\nSuppose the `UniswapV2TokenAdapter` wants to be used as an adapter for a Sushiswap pool.\nAn attacker creates a UniswapV2 pool for the same pair and does not provide liquidity.\nThe `Router.setPriceSource` calls `UniswapV2TokenAdapter.supports` and returns false as the Uniswap liquidity is too low, without checking the Sushiswap liquidity.\n\n#### Recommendation\nIn `aboveLiquidity`, if the UniswapV2 liquidity is *less* than the minimum liquidity, instead of returning, compare the Sushiswap liquidity against this threshold.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/135)**\n\n",
      "summary": "\nThe report discusses a bug in the `UniswapV2TokenAdapter` function, specifically in the `supports` function. This function checks if the UniswapV2 liquidity is above a certain threshold, and if not, returns false. However, the function does not check if there is liquidity in the Sushiswap pool, which could also be used. This could be exploited by an attacker who creates a UniswapV2 pool without providing liquidity, causing the `supports` function to return false without checking the Sushiswap pool. The recommendation is to modify the `aboveLiquidity` function to also check the Sushiswap liquidity if the UniswapV2 liquidity is below the threshold. The bug has been confirmed by a team member.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/135",
      "tags": [],
      "finders": []
    },
    {
      "id": "42302",
      "title": "[M-08] `UniswapV2/SushiwapLPAdapter` update the wrong token",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again.\nThis will end up with the router calling this function again recursively.\n\n#### Impact\nThis function fails as there's an infinite recursion and eventually runs out of gas.\n\n#### Recommendation\nThe idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.\n\nCall `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/134)**\n\n",
      "summary": "\nThe report discusses a bug in the `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function. This function retrieves the `underlying` from the LP token pair, but then calls a function that results in an infinite recursion. This can cause the function to fail and run out of gas. The recommendation is to call a different function instead, as the current one may not update the desired pair. This issue has been confirmed by another user.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/134",
      "tags": [],
      "finders": []
    },
    {
      "id": "42301",
      "title": "[M-05] Chainlink's `latestRoundData` might return stale or incorrect results",
      "impact": "MEDIUM",
      "content": "_Submitted by nikitastupin, also found by cmichel, defsec, leastwood, and WatchPug_\n\n#### Proof of Concept\n[`ChainlinkAdapter.sol` L49](https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49)\n\nThe `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).\n\n#### Recommended Mitigation Steps\nRecommend adding the following checks:\n```solidity\n    ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData();\n    require(rawPrice > 0, \"Chainlink price <= 0\");\n    require(updateTime != 0, \"Incomplete round\");\n    require(answeredInRound >= roundId, \"Stale price\");\n```\n#### References\n*   <https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results>\n*   <https://github.com/code-423n4/2021-05-fairside-findings/issues/70>\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/87)**\n\n",
      "summary": "\nA bug has been found in the ChainlinkAdapter contract, which is used to call out to a Chainlink oracle and receive the latestRoundData. This can cause issues if there are problems with Chainlink starting a new round or finding consensus on the new value for the oracle. This can lead to consumers of the contract using outdated or incorrect data. To mitigate this, it is recommended to add certain checks to the contract. References and confirmation of the bug have been provided.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/87",
      "tags": [],
      "finders": []
    },
    {
      "id": "42300",
      "title": "[M-02] `regerralFeePool` is vulnerable to MEV searcher",
      "impact": "MEDIUM",
      "content": "_Submitted by jonah1005, also found by cmichel_\n\n#### Impact\n`claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to <https://github.com/flashbots/pm>.\n\nGiven the current state of the Ethereum network, users would likely be sandwiched. I consider this is a high-risk issue.\n\n#### Proof of Concept\n[ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)\nPlease refer to  [Mushrooms Finance Theft of Yield Bug Fix Postmortem | by Immunefi | Immunefi | Medium](https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f) to see a possible attack pattern.\n\n#### Recommended Mitigation Steps\nI recommend adding `minReceivedAmount` as a parameter.\n\n```solidity\nfunction claimRewardAsMochi(uint256 _minReceivedAmount) external {\n    // original logic here\n    require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, \"!min\");\n    engine.mochi().transfer(\n        msg.sender,\n        engine.mochi().balanceOf(address(this))\n    );\n}\n```\n\nAlso, the front-end should calculate the min amount with the current price.\n\n[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/62)\n\n",
      "summary": "\nThe bug report is about a function called `claimRewardAsMochi` in the `ReferralFeePoolV0` contract. This function does not take into account the slippage, which means that users could potentially lose a lot of money when swapping assets. This is a high-risk issue because there are many MEV searchers on the Ethereum network. The bug was found by jonah1005 and cmichel and they recommend adding a new parameter called `minReceivedAmount` to mitigate this issue. The front-end should also calculate the minimum amount with the current price. This has been confirmed by ryuheimat from Mochi.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/62",
      "tags": [],
      "finders": []
    },
    {
      "id": "949",
      "title": "[M-15] MochiTreasuryV0.sol Is Unusable In Its Current State",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.\n\n## Proof of Concept\n\nhttps://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418\nhttps://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438\nhttps://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455\n\n## Tools Used\n\nManual code review\nDiscussions with the Mochi team\n\n## Recommended Mitigation Steps\n\nConsider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.",
      "summary": "\nA bug has been reported in the `MochiTreasuryV0.sol` contract, which interacts with Curve's voting escrow contract to lock tokens for 90 days. The bug is that `VotingEscrow.vy` does not allow contracts to call certain functions (`create_lock()`, `increase_amount()` and `increase_unlock_time()`), and only allows EOA accounts or approved smart wallets to do so. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`. The bug was discovered through manual code review and discussions with the Mochi team.\n\nThe recommended mitigation steps are to consider updating the contract to use another escrow service that allows `msg.sender` to be a contract, or to replace the escrow functionality with an internal contract that holds `usdm` tokens instead. Holding Curve tokens for a minimum of 90 days may expose the Mochi treasury to Curve token price fluctuations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/168",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "948",
      "title": "[M-14] MochiTreasuryV0.withdrawLock() Is Callable When Locking Has Been Toggled",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider adding `require(lockCrv, \"!lock\");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.",
      "summary": "\nThis bug report concerns the function `withdrawLock()` in the MochiTreasuryV0.sol contract. This function does not prevent users from calling it when locking has been toggled, which means withdraws may be made unexpectedly. The proof of concept is provided in the link given, and the tools used to identify this bug were manual code review. The recommended mitigation step is to either add `require(lockCrv, \"!lock\");` to `withdrawLock()` to prevent this function from being called unexpectedly, or to check that the lock has not been toggled if this is intended behaviour.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/161",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "947",
      "title": "[M-13] Improper Validation Of create2 Return Value",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31\n\n## Tools Used\n\nManual code review\nDiscussions with the Mochi team\nDiscussions with library dev\n\n## Recommended Mitigation Steps\n\nThe recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.",
      "summary": "\nThis bug report is about a vulnerability in the `BeaconProxyDeployer.deploy()` function of the Mochi library. This function is used to deploy lightweight proxy contracts that act as each asset's vault. The vulnerability is that the function does not properly check the returned address for bytecode if there is a failed contract deployment or revert from the `create2` opcode. This means that the function could be exploited, allowing an attacker to gain access to the assets in the vault. \n\nThe recommended mitigation for this vulnerability is to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library and needs to be reflected in Mochi's contracts. The vulnerability was discovered through manual code review, discussions with the Mochi team, and discussions with library dev.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/155",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "946",
      "title": "[M-12] anyone can create a vault by directly calling the factory",
      "impact": "MEDIUM",
      "content": "_Submitted by jonah1005_\n\n#### Impact\nIn [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37), there's no permission control in the `vaultFactory`. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.\n\nAs the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.\n\nI consider this is a medium-risk issue.\n\n#### Proof of Concept\nHere's a web3.py script to trigger the bug.\n\n```py\nvault_factory.functions.deployVault(usdt.address).transact()\n## this tx would be reverted\nprofile.functions.registerAssetByGov([usdt.address], [3]).transact()\n```\n\n#### Recommended Mitigation Steps\nRecommend to add a check.\n\n```solidity\nrequire(msg.sender == engine, \"!engine\");\n```\n\n[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/80)\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the MochiVaultFactory.sol file, which is part of the Mochi protocol. This vulnerability could allow anyone to create a vault, which would be recognized as a valid one by the protocol. This is considered a medium-risk issue. A web3.py script has been provided as a proof of concept to trigger the bug. The recommended mitigation step is to add a check to the code so that only the engine can create a vault.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/80",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "945",
      "title": "[M-11] borrow function will borrow max cf when trying to borrow > cf",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\n#### Impact\nBorrow function in `MochiVault` will borrow to max cf when trying to borrow > cf instead of revert with \">cf\" as specified in the supplied test. The difference in behavior may cause user to borrow at dangerous collateral level, and receive less than the amount requested.\n\n#### Proof of Concept\n* [`MochiVault` sol](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol)\n\n#### Recommended Mitigation Steps\nRevert if `details\\[\\_id].debt` + `\\_amount` > `maxMinted` with \">cf\"\n\n\n**[ryuheimat (Mochi) conirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/45)**\n\n",
      "summary": "\nThis bug report concerns an issue with the Borrow function in the MochiVault smart contract. The bug causes the contract to borrow to the maximum collateral factor (cf) when trying to borrow more than the maximum, instead of reverting with a “>cf” error as specified in the supplied test. This difference in behavior can cause users to borrow at dangerous collateral levels and receive less than the amount requested. A proof of concept can be found at the provided Github link. No tools were used to discover the issue. The recommended mitigation step is to revert if details[_id].debt + _amount > maxMinted with “>cf”.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/45",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "944",
      "title": "[M-10] griefing attack to block withdraws",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\n#### Impact\nEvery time you deposit some assets in the vault (via `deposit()` of `MochiVault.sol`) then \"lastDeposit\\[\\_id]\" is set to `block.timestamp`.\nThe modifier `wait()` checks this value and makes sure you cannot withdraw for \"`delay()`\" blocks.\nThe default value for `delay()` is 3 minutes.\n\nKnowing this delay you can do a griefing attack:\nOn chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets).\nOn chains with high gas fees: monitor the mempool for a `withdraw()` transaction and frontrun it with a `deposit()`\n\nThis way the owner of the NFT-id can never withdraw the funds.\n\n#### Proof of Concept\n- [`MochiVault.sol#L47` L54](https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54)\n- [`vault/MochiVault.sol` L171](https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171)\n- [`profile/MochiProfileV0.sol` L33](https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33)\n\n#### Recommended Mitigation Steps\nCreate a mechanism where you only block the withdraw of recently deposited funds\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/21#issuecomment-952886314):**\n > Will update deposit function to allow only NFT owner to deposit\n\n",
      "summary": "\nThis bug report is about a vulnerability in the MochiVault.sol code, which allows a griefing attack. When assets are deposited into the vault, the \"lastDeposit[_id]\" is set to the block timestamp. This is used by the wait() modifier to prevent a withdrawal for a certain number of blocks, which is 3 minutes by default. Knowing this delay, a user can deposit a small amount of assets every 3 minutes for a specific NFT-id, preventing the owner of the NFT-id from ever withdrawing the funds. This can be done on chains with low gas fees, or by frontrunning a withdraw() transaction on chains with high gas fees. The code for this bug can be found in the provided Github links. To mitigate this vulnerability, a mechanism should be created to only block the withdrawal of recently deposited funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/21",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "943",
      "title": "[M-09] UniswapV2TokenAdapter does not support Sushiswap-only assets",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `UniswapV2TokenAdapter.supports` function calls its `aboveLiquidity` function which returns the UniswapV2 liquidity if the pair exists.\nIf this is below `minimumLiquidity`, the `supports` function will return `false`.\n\nHowever, it could be that the `Sushiswap` pair has lots of liquidity and could be used.\n\n```solidity\ntry uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n    float memory price = cssrRouter.getPrice(_pairedWith);\n    // @audit this returns early. if it's false it should check sushiswap first\n    return convertToValue(liq, price) >= minimumLiquidity;\n} catch {\n    try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n        uint256 liq\n    ) {\n        float memory price = cssrRouter.getPrice(_pairedWith);\n        return convertToValue(liq, price) >= minimumLiquidity;\n    } catch {\n        return false;\n    }\n}\n```\n\n## Impact\nSuppose the `UniswapV2TokenAdapter` wants to be used as an adapter for a Sushiswap pool.\nAn attacker creates a UniswapV2 pool for the same pair and does not provide liquidity.\nThe `Router.setPriceSource` calls `UniswapV2TokenAdapter.supports` and returns false as the Uniswap liquidity is too low, without checking the Sushiswap liquidity.\n\n## Recommendation\nIn `aboveLiquidity`, if the UniswapV2 liquidity is _less_ than the minimum liquidity, instead of returning, compare the Sushiswap liquidity against this threshold.",
      "summary": "\nThis bug report focuses on the UniswapV2TokenAdapter function. It explains that the function calls its `aboveLiquidity` function which returns the UniswapV2 liquidity if the pair exists. If the liquidity is below the `minimumLiquidity`, the `supports` function will return `false`. However, it could be that the `Sushiswap` pair has lots of liquidity and could be used.\n\nThe impact of this bug is that if the UniswapV2TokenAdapter wants to be used as an adapter for a Sushiswap pool, an attacker can create a UniswapV2 pool for the same pair and not provide liquidity. The `Router.setPriceSource` calls `UniswapV2TokenAdapter.supports` and returns false as the Uniswap liquidity is too low, without checking the Sushiswap liquidity.\n\nThe recommendation provided is that in `aboveLiquidity`, if the UniswapV2 liquidity is _less_ than the minimum liquidity, instead of returning, compare the Sushiswap liquidity against this threshold. This will ensure that the Sushiswap liquidity is checked if the UniswapV2 liquidity is below the threshold.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/135",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "942",
      "title": "[M-08] UniswapV2/SushiwapLPAdapter update the wrong token",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again.\nThis will end up with the router calling this function again recursively.\n\n## Impact\nThis function fails as there's an infinite recursion and eventually runs out of gas.\n\n## Recommendation\nThe idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.\n\nCall `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.",
      "summary": "\nThis bug report is about the `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function which is used to retrieve the `underlying` from the LP token pair (`_asset`). The bug is that when `router.update(_asset, _proof)` is called, it results in an infinite recursion which runs out of gas and fails. The impact of this bug is that the function fails and cannot be used. The recommendation is to call `router.update(underlying, _proof)` instead, as it will update the `underlying <> WETH` pair. This will allow the `_getPrice` function to be used, which uses the `underlying` price.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/134",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "941",
      "title": "[M-07] Changing engine.nft contract breaks vaults",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nGovernance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP).\nWhen minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.\n\n#### Impact\nChanging the NFT address will allow overwriting existing CDPs.\n\n#### Recommended Mitigation Steps\nDisallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/130)**\n\n",
      "summary": "\nThis bug report details a vulnerability in the Governance of a system that allows it to change the `engine.nft` address used by vaults to represent collateralized debt positions (CDP). If this address is changed, it could allow existing CDPs to be overwritten when a vault is minted using `MochiVault.mint`. This could have a significant negative impact on the system.\n\nThe recommended mitigation steps for this vulnerability are to either disallow setting a new NFT address, or to ensure that the new NFT's IDs start at the old NFT's IDs. This will help to ensure that existing CDPs are not inadvertently overwritten.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/130",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "940",
      "title": "[M-06] Debt accrual is path-dependant and inaccurate",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth.\nThis is correct but the total `debt` is then *reduced* again by the calling *user's* discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.\n\nThis should not be the case.\n\n#### POC\nAssume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100.\nThe (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.\n\nThere's a difference if user A or B first does the accrual.\n\n###### User A accrues first\nUser A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`.\nThen `debts = 2200 - 10 = 2190`.\n\nThe next accrual will work with a total debt of `2190`.\n\n###### User B accruess first\nUser B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`.\nThen `debts = 2200 - 1 = 2199`.\n\nThe next accrual will work with a total debt of `2199`, leading to more debt overall.\n\n#### Impact\nThe total debt of a system depends on who performs the accruals which should ideally not be the case.\nThe discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.\n\n#### Recommended Mitigation Steps\nDon't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/129)**\n\n",
      "summary": "\nA bug has been identified in the MochiVault accrueDebt system where the total debt is affected by which user performs the debt accrual. This should not be the case as the total debt should remain the same regardless of who performs the accrual. To demonstrate this bug, two users A and B were used, with A having a debt of 1000 and B having a debt of 100. When user A accrues first, the total debt increases to 2200 and then decreases to 2190 due to user A's discounted debt. When user B accrues first, the total debt increases to 2200 and then decreases to 2199 due to user B's discounted debt. This discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount. To mitigate this bug, the discount should be applied to all users instead of the current caller when accruing to correctly track the debt.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/129",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "939",
      "title": "[M-05] Chainlink’s latestRoundData might return stale or incorrect results",
      "impact": "MEDIUM",
      "content": "## Handle\n\nnikitastupin\n\n\n## Vulnerability details\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49 \n\nThe `ChainlinkAdapter` calls out to a Chainlink oracle receiving the `latestRoundData()`. If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).\n\n## Recommended Mitigation Steps\n\nAdd the following checks:\n\n```\n...\n( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData();\nrequire(rawPrice > 0, \"Chainlink price <= 0\");\nrequire(updateTime != 0, \"Incomplete round\");\nrequire(answeredInRound >= roundId, \"Stale price\");\n...\n```\n\n## References\n\n- https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results\n- https://github.com/code-423n4/2021-05-fairside-findings/issues/70",
      "summary": "\nThis bug report is about a vulnerability in the ChainlinkAdapter contract, which is used to retrieve data from a Chainlink oracle. The vulnerability is that if there is an issue with Chainlink starting a new round or finding consensus on the new value for the oracle, the contract may continue using outdated, stale, or incorrect data. To mitigate this issue, recommended steps include adding checks to ensure the raw price is greater than 0, the update time is not 0, and that the round is not stale. References are provided for further information.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/87",
      "tags": [],
      "finders": [
        "nikitastupin",
        "cmichel",
        "leastwood",
        "WatchPug",
        "defsec"
      ]
    },
    {
      "id": "938",
      "title": "[M-04] Unchecked ERC20 transfer calls",
      "impact": "MEDIUM",
      "content": "_Submitted by loop, also found by cmichel, defsec, gzeon, leastwood, nikitastupin, pants, and WatchPug_\n\nERC20 `transfer` and `transferFrom` calls normally return `true` on a succesful transfer. In DutchAuctionLiquidator the call `asset.transfer(msg.sender, _collateral);` is made. `asset` refers to whichever ERC20 asset is used for the vault of that auction. If `asset` is an ERC20 token which does not comply with the EIP-20 standard it might return `false` on a failed transaction rather than revert. In this case it would count as a valid transaction even though it is not. If a vault would be making use of USDT the transfer call would always revert as USDT returns `void` on transfers.\n\nThere are a few more transfer(From) calls which are unchecked, these are however all on a predetermined asset (mochi, usdM and crv) and unlikely to cause problems.\n\n#### Proof of Concept\nSee [issue page](https://github.com/code-423n4/reports/blob/mochi/mochi/2021-10-mochi-findings-DRAFT.md) for referenced code.\n\n\n#### Tools Used\nSlither\n\n#### Recommended Mitigation Steps\nIn other contracts the functions `cheapTransfer` and `cheapTransferFrom` are used which are part of the mochifi cheapERC20 library. These functions do check for a return value and could be used rather than `transfer` and `transferFrom`.\n\n### Comments:\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/75#issuecomment-952083361):**\n > `transferFrom` and `transfer` functions are used for mochi and usdm tokens which are standard EIP-20 tokens.\n>\n\n",
      "summary": "\nThis bug report is about the DutchAuctionLiquidator contract, which is part of the Mochi project. It is related to the ERC20 tokens `transfer` and `transferFrom` calls, which normally return `true` on a successful transfer. However, if the ERC20 token does not comply with the EIP-20 standard, it might return `false` on a failed transaction instead of reverting. In this case, it would count as a valid transaction even though it is not. The report also mentions a few other transfer(From) calls which are unchecked, but these are all on a predetermined asset (mochi, usdM and crv) and unlikely to cause problems.\n\nThe recommended mitigation step is to use the functions `cheapTransfer` and `cheapTransferFrom`, which are part of the mochifi cheapERC20 library. These functions do check for a return value and could be used rather than `transfer` and `transferFrom`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/75",
      "tags": [],
      "finders": [
        "nikitastupin",
        "cmichel",
        "leastwood",
        "gzeon",
        "WatchPug",
        "loop",
        "pants",
        "defsec"
      ]
    },
    {
      "id": "937",
      "title": "[M-03] A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by jonah1005_\n\nIn the current implementation, a liquidated position can be used for depositing and borrowing again.\n\nHowever, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.\n\nThe liquidator must `settleLiquidation` first.\n\nIf the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.\n\nConsidering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.\n\nSince the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.\n\nThe malicious user will then deposit borrow the actual loan.\n\nWhen this loan becomes `liquidatable`, liquidators may:\n\n1.  confuse the current dust auction with the `liquidatable` position;\n2.  unable to proceed with such a complex liquidation.\n\nAs a result, the malicious user can potentially escape liquidation.\n\n##### Recommendation\nConsider making liquidated positions unable to be used (for depositing and borrowing) again.\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/127)**\n\n",
      "summary": "\nThis bug report is about a vulnerability in the current implementation of the WatchPug system. The vulnerability allows a malicious user to potentially escape liquidation by creating a dust amount position which triggers the liquidation. The liquidator may confuse the current dust auction with the ‘liquidatable’ position or be unable to proceed with such a complex liquidation. The recommendation is to consider making liquidated positions unable to be used (for depositing and borrowing) again.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/127",
      "tags": [],
      "finders": [
        "WatchPug",
        "jonah1005"
      ]
    },
    {
      "id": "936",
      "title": "[M-02] regerralFeePool is vulnerable to MEV searcher",
      "impact": "MEDIUM",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## regerralFeePool is vulnerable to MEV searcher\n\n## Impact\n`claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.\n\nGiven the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.\n\n## Proof of Concept\n[ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)\n\nPlease refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f\n to see a possible attack pattern.\n\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\nI recommend adding minReceivedAmount as a parameter.\n\n```solidity\nfunction claimRewardAsMochi(uint256 _minReceivedAmount) external {\n    // original logic here\n    require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, \"!min\");\n    engine.mochi().transfer(\n        msg.sender,\n        engine.mochi().balanceOf(address(this))\n    );\n}\n```\nAlso, the front-end should calculate the min amount with the current price.",
      "summary": "\nThe bug report is about the ReferralFeePoolV0 contract which is vulnerable to MEV (miner extractable value) searchers. This is because the `claimRewardAsMochi` function in the contract ignores slippage, which is not desirable as there are many MEV searchers in the Ethereum network. This means that users can be sandwiched and it is a high-risk issue. The proof of concept and recommended mitigation steps are also included in the report. The proof of concept is ReferralFeePoolV0.sol#L28-L48 and the recommended mitigation steps are adding a minReceivedAmount parameter and having the front-end calculate the minimum amount with the current price.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/62",
      "tags": [],
      "finders": [
        "cmichel",
        "jonah1005"
      ]
    },
    {
      "id": "935",
      "title": "[M-01] liquidation factor < collateral factor for Sigma type",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by gzeon_\n\nThe `MochiProfileV0` defines liquidation and collateral factors for different asset types.\nFor the `AssetClass.Sigma` type, the liquidation factor is *less* than the collateral factor:\n\n```solidity\nfunction liquidationFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {\n        return float({numerator: 40, denominator: 100});\n    }\n}\n\nfunction maxCollateralFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) {\n        return float({numerator: 45, denominator: 100});\n    }\n}\n```\n\nThis means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%.\nThere should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:\n\n> A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)\n\n#### Recommended Mitigation Steps\nThe max collateral factor for the Sigma type should be higher than its liquidation factor.\n\n\n**[ryuheimat (Mochi) confirmed](https://github.com/code-423n4/2021-10-mochi-findings/issues/126)**\n\n",
      "summary": "\nThis bug report is about the `MochiProfileV0` smart contract which defines liquidation and collateral factors for different asset types. The bug is that for the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor, meaning that a user can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. This goes against the safety buffer that should be maintained between max CF and LF to protect users against liquidations due to normal volatility. The recommended mitigation step for this bug is to increase the max collateral factor for the Sigma type so that it is higher than its liquidation factor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/126",
      "tags": [],
      "finders": [
        "cmichel",
        "gzeon"
      ]
    },
    {
      "id": "934",
      "title": "[H-13] Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()",
      "impact": "HIGH",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64\n\n## Tools Used\n\nManual code review\nDiscussions with the Mochi team\n\n## Recommended Mitigation Steps\n\nEnsure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.",
      "summary": "\nA bug has been discovered in the `VestedRewardPool.sol` contract of the Mochi project. This contract is used to vest tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` and `lock()` functions do not utilize `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient, making it possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. This has been confirmed with manual code review and discussions with the Mochi team. To mitigate this issue, it is recommended that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/92",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "933",
      "title": "[H-12] feePool is vulnerable to sandwich attack.",
      "impact": "HIGH",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## Impact\nThere's a permissionless function `distributeMochi` in FeePoolV0. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds.\n[FeePoolV0.sol#L55-L62](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L55-L62)\nThe devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack. \n\nAttackers can steal all the funds in the pool. I consider this is a high-risk issue. \n\n## Proof of Concept\n[FeePoolV0.sol#L55-L62](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L55-L62)\n\nPlease refer to [yDai Incident](https://peckshield.medium.com/the-ydai-incident-analysis-forced-investment-2b8ac6058eb5) to check the severity of a `harvest` function without slippage control.\n\nPlease refer to [Mushrooms-finance-theft]( https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f) to check how likely this kind of attack might happen.\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\nIf the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage.",
      "summary": "\nThis bug report is about a vulnerability in the FeePoolV0.sol function `distributeMochi`. This function is permissionless, meaning anyone can trigger it. This creates a vulnerability where an attacker can launch a sandwich attack with a flash loan to steal all the funds in the pool. This is considered a high-risk issue due to the potential for large losses. As examples of similar issues, the report references the yDai Incident and the Mushrooms-finance-theft incident. To mitigate this vulnerability, the dev should add a slippage control to the contract to calculate a minimum return based on a Time Weighted Average Price (TWAP).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/65",
      "tags": [
        "Sandwich Attack"
      ],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "932",
      "title": "[H-11] treasuryShare is Overwritten in FeePoolV0._shareMochi()",
      "impact": "HIGH",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract. \n\n## Proof of Concept\n\nConsider the following scenario:\n  - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.\n  - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.\n  - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.\n  - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.\n  - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).\n  - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`. \n  - `mochiShare` is now set to 16 `usdm` tokens.\n  - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.\n  - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94\n\n## Tools Used\n\nManual code review\nDiscussions with the Mochi team.\n\n## Recommended Mitigation Steps\n\nConsider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.",
      "summary": "\nThe bug report is about a vulnerability in the `FeePoolV0.sol` contract, which is used to accrue fees upon the liquidation of undercollaterised positions. This contract splits the fees between the treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract. This means that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.\n\nThe bug was discovered through manual code review and discussions with the Mochi team. The recommended mitigation step is to remove the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/89",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "931",
      "title": "[H-10] Changing NFT contract in the MochiEngine would break the protocol",
      "impact": "HIGH",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## Impact\nMochiEngine allows the operator to change the NFT contract.\n[MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)\nAll the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.\n\nIMHO, A function that would break the entire protocol shouldn't exist.\n\nI consider this is a high-risk issue.\n## Proof of Concept\n[MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)\n\n## Tools Used\nNone\n## Recommended Mitigation Steps\nRemove the function.",
      "summary": "\nJonah1005 has identified a vulnerability in MochiEngine that could break the entire protocol. If the operator changes the NFT contract, all the vaults would point to a different NFT address and users would not be able to access their positions. The proof of concept can be found in MochiEngine.sol#L91-L93. As this is a high-risk issue, the recommended mitigation step is to remove the function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/63",
      "tags": [],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "930",
      "title": "[H-09] treasury is vulnerable to sandwich attack",
      "impact": "HIGH",
      "content": "## Handle\n\njonah1005\n\n\n## Vulnerability details\n\n## treasury is vulnerable to sandwich attack.\n\n\n## Impact\nThere's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.\n[MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\n\nAttackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.\n\n## Proof of Concept\n[MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\n\nHere's an exploit pattern\n1. Flashloan and buy CRV the uniswap pool\n2. Trigger `veCRVlock()`\n3. The treasury buys CRV at a very high price.\n4. Sell CRV and pay back the loan.\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\nRecommend to add `onlyOwner` modifier.",
      "summary": "\nA user with the handle jonah1005 has identified a vulnerability in MochiTreasury, a permissionless function called veCRVlock. This vulnerability allows an attacker to launch a sandwich attack with a flashloan to steal funds from the treasury. This is considered to be a high-risk issue, as it could potentially allow an attacker to steal all of the funds in the treasury. The exploit pattern involves using a flashloan to buy CRV from the uniswap pool, triggering veCRVlock, then the treasury buying CRV at a high price, and finally selling CRV and paying back the loan. No tools were used in the identification of this vulnerability. The recommended mitigation step is to add an onlyOwner modifier to the function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/60",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "jonah1005"
      ]
    },
    {
      "id": "929",
      "title": "[H-08] Anyone can extend withdraw wait period by depositing zero collateral",
      "impact": "HIGH",
      "content": "## Handle\n\nharleythedog\n\n\n## Vulnerability details\n\n## Impact\nIn MochiVault.sol, the deposit function allows anyone to deposit collateral into any position. A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This is especially troublesome with longer delays, as a malicious user would only have to spend a little gas to lock out all other users from being able to withdraw from their positions, compromising the functionality of the contract altogether.\n\n## Proof of Concept\ndeposit function here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,deposit,-(uint256%20_id%2C%20uint256\n\nNotice that calling this function with amount = 0 is not disallowed. This overwrites lastDeposit[_id], extending the wait period before a withdraw is allowed.\n\n## Tools Used\nManual inspection.\n\n## Recommended Mitigation Steps\nI would recommend adding:\n\nrequire(amount > 0, \"zero\")\n\nat the start of the function, as depositing zero collateral does not seem to be a necessary use case to support.\n\nIt may also be worthwhile to consider only allowing the owner of a position to deposit collateral.",
      "summary": "\nA bug has been identified in the MochiVault.sol contract where anyone can call the deposit function with an amount of 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This could be used maliciously to lock out all other users from withdrawing from their positions, compromising the functionality of the contract. This has been identified through manual inspection of the code, and the recommended mitigation step is to add a require statement to the start of the function to prevent anyone from depositing zero collateral. It may also be worthwhile to consider only allowing the owner of a position to deposit collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/69",
      "tags": [],
      "finders": [
        "WatchPug",
        "harleythedog"
      ]
    },
    {
      "id": "928",
      "title": "[H-07] Liquidation will never work with non-zero discounts",
      "impact": "HIGH",
      "content": "## Handle\n\nharleythedog\n\n\n## Vulnerability details\n\n## Impact\nRight now, there is only one discount profile in the github repo: the \"NoDiscountProfile\" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.\n\nSuppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable \"debt\" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable \"collateral\" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107. \n\nEventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.\n\n## Proof of Concept\nLiquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(\n\ntriggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256\n\nRetracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:\n\ndetails[_id].debt -= _usdm;\n\nthrowing an error since _usdm will be larger than details[_id].debt.\n\n## Tools Used\nManual inspection.\n\n## Recommended Mitigation Steps\nAn easy fix is to simply change:\n\ndetails[_id].debt -= _usdm;\n\nto be:\n\ndetails[_id].debt = 0;\n\nas liquidating a position should probably just be equivalent to repaying all of the debt in the position. \n\nSide Note: If there are no other discount profiles planned to be added other than \"NoDiscountProfile\", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything",
      "summary": "\nThis bug report is about the MochiVault.sol and DutchAuctionLiquidator.sol contracts in the 2021-10-mochi Github repo. Currently, the repo contains only one discount profile, the \"NoDiscountProfile\" which does not discount the debt at all. However, any other discount profile that discounts the debt will cause liquidation to never work due to an underflow issue. This is because the debt of the position is discounted when it is updated, but the passed in parameter of _usdm is not discounted and thus is larger in value. This results in an underflow error when reaching line 293 in MochiVault.sol. As a result, no collateral can be liquidated, compromising the functionality of the contract. To fix this, the code should be changed so that details[_id].debt is set to 0 when liquidating a position, or all of the discount logic should be deleted if no other discount profiles are planned.",
      "quality_score": 2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/66",
      "tags": [],
      "finders": [
        "harleythedog"
      ]
    },
    {
      "id": "927",
      "title": "[H-06] Referrer can drain ReferralFeePoolV0",
      "impact": "HIGH",
      "content": "## Handle\n\ngzeon\n\n\n## Vulnerability details\n\n## Impact\nfunction claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol\nL28-47 did not reduce user reward balance\n\n## Tools Used\nNone\n\n## Recommended Mitigation Steps\nAdd the following lines\n> rewards -= reward[msg.sender];\n> reward[msg.sender] = 0;",
      "summary": "\nThis bug report is about a vulnerability in the function claimRewardAsMochi in the ReferralFeePoolV0.sol contract. This vulnerability allowed referrers to claim the same reward repeatedly, thus draining the fee pool. No tools were used to identify this vulnerability. \n\nThe impact of this vulnerability was that it allowed referrers to claim the same reward multiple times and drain the fee pool. A proof of concept was provided in the form of a link to the GitHub repository, which showed that lines 28-47 of the ReferralFeePoolV0.sol contract did not reduce the user reward balance.\n\nThe recommended mitigation steps for this vulnerability are to add the following lines of code to the ReferralFeePoolV0.sol contract: rewards -= reward[msg.sender]; reward[msg.sender] = 0;. This will reduce the user reward balance and prevent referrers from claiming the same reward multiple times.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/55",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "926",
      "title": "[H-05] debts calculation is not accurate",
      "impact": "HIGH",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.\n\nIn the function borrow() the variable debts is increased with a value excluding the fee.\nHowever in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.\n\nThis would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.\n\nIn the mean time the value of debts isn't accurate.\nThis value is used directly or indirectly in: \n- utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol \n- liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol\n\nThis means the entire debt and claimable calculations are slightly off.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol\n\nfunction borrow(..)\n    details[_id].debt = totalDebt; // includes the fee\n    debts += _amount;     // excludes the fee \n\nfunction repay(..)\n    debts -= _amount;  \n    details[_id].debt -= _amount;\n\nfunction liquidate(..)\n   debts -= _usdm;\n   details[_id].debt -= _usdm;\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIn function borrow():\nreplace\n    debts += _amount;\nwith\n    debts += totalDebt",
      "summary": "\nA bug has been reported in the contract MochiVault.sol, which is used to calculate the global variable debts in an inconsistent way. In the function borrow(), the variable debts is increased with a value excluding the fee, while in repay() and liquidate() it is decreased with the same value as details[_id].debt, which is including the fee. This would mean that debts will end up in a negative value when all debts are repay-ed. As a result, the value of debts is not accurate and is used directly or indirectly in various functions, which means the entire debt and claimable calculations are slightly off. \n\nTo mitigate this issue, it is recommended to replace the line 'debts += _amount;' in the borrow() function with 'debts += totalDebt'.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/25",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "925",
      "title": "[H-04] registerAsset() can overwrite _assetClass value",
      "impact": "HIGH",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nEveryone can call the function registerAsset() of MochiProfileV0.sol\nAssuming the liquidity for the asset is sufficient, registerAsset() will reset the _assetClass of an already registered asset to AssetClass.Sigma.\n\nWhen the _assetClass is changed to AssetClass.Sigma then liquidationFactor(), riskFactor(), maxCollateralFactor(), liquidationFee() keeperFee() maxFee() will also return a different value.\nThen the entire vault will behave differently. \nThe threshold for liquidation will also be different, possibly leading to a liquidation that isn't supposed to happen.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L58-L62\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L105-L128\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L129-L146\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L148-L170\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L176-L198\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L200-L222\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L224-L240\n\n## Tools Used\n\n## Recommended Mitigation Steps\nAdd the following in function registerAsset():\nrequire(_assetClass[_asset] ==0,\"Already exists\");",
      "summary": "\nThis bug report is about the function registerAsset() of MochiProfileV0.sol. Everyone can call this function, and if the liquidity for the asset is sufficient, this function will reset the _assetClass of an already registered asset to AssetClass.Sigma. This can cause the entire vault to behave differently and the threshold for liquidation will also be different, possibly leading to a liquidation that isn't supposed to happen. The Proof of Concept is provided in the report with a list of tools used. The recommended mitigation step is to add the following in the function registerAsset(): require(_assetClass[_asset] ==0,\"Already exists\").",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/20",
      "tags": [],
      "finders": [
        "jonah1005  leastwood",
        "gpersoon"
      ]
    },
    {
      "id": "924",
      "title": "[H-03] ReferralFeePoolV0.sol#claimRewardAsMochi() Array out of bound exception",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42\n\n```solidity=28\nfunction claimRewardAsMochi() external {\n    IUSDM usdm = engine.usdm();\n    address[] memory path = new address[](2);\n    path[0] = address(usdm);\n    path[1] = uniswapRouter.WETH();\n    path[2] = address(engine.mochi());\n    usdm.approve(address(uniswapRouter), reward[msg.sender]);\n    // we are going to ingore the slippages here\n    uniswapRouter.swapExactTokensForTokens(\n        reward[msg.sender],\n        1,\n        path,\n        address(this),\n        type(uint256).max\n    );\n```\n\nIn `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.\n\nAs a result, at L33, an out-of-bound exception will be thrown and revert the transaction.\n\n### Impact\n\n`claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.",
      "summary": "\nThis bug report is about a vulnerability in the ReferralFeePoolV0.sol contract, which is part of the WatchPug project. In the function claimRewardAsMochi(), the path array is defined as having a length of 2, while it should be length 3. As a result, an out-of-bound exception will be thrown and the transaction will be reverted. This means that the referral fees cannot be claimed, leading to them getting stuck in the contract. This bug has a major impact on the project, as it prevents users from claiming their rewards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/97",
      "tags": [],
      "finders": [
        "WatchPug",
        "pauliax"
      ]
    },
    {
      "id": "923",
      "title": "[H-02] FeePoolV0.sol#distributeMochi() will unexpectedly flush treasuryShare, causing the protocol fee cannot be properly accounted for and collected",
      "impact": "HIGH",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\n`distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.\n\nHowever, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.\n\nhttps://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95\n\n```solidity=79\nfunction _shareMochi() internal {\n    IMochi mochi = engine.mochi();\n    uint256 mochiBalance = mochi.balanceOf(address(this));\n    // send Mochi to vMochi Vault\n    mochi.transfer(\n        address(engine.vMochi()),\n        (mochiBalance * vMochiRatio) / 1e18\n    );\n    // send Mochi to veCRV Holders\n    mochi.transfer(\n        crvVoterRewardPool,\n        (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n    );\n    // flush mochiShare\n    mochiShare = 0;\n    treasuryShare = 0;\n}\n```\n\n### Impact\n\nAnyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.\n\nRepeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.\n\n### Recommendation\n\nChange to:\n\n```solidity=64\nfunction _buyMochi() internal {\n    IUSDM usdm = engine.usdm();\n    address[] memory path = new address[](2);\n    path[0] = address(usdm);\n    path[1] = address(engine.mochi());\n    usdm.approve(address(uniswapRouter), mochiShare);\n    uniswapRouter.swapExactTokensForTokens(\n        mochiShare,\n        1,\n        path,\n        address(this),\n        type(uint256).max\n    );\n    // flush mochiShare\n    mochiShare = 0;\n}\n\nfunction _shareMochi() internal {\n    IMochi mochi = engine.mochi();\n    uint256 mochiBalance = mochi.balanceOf(address(this));\n    // send Mochi to vMochi Vault\n    mochi.transfer(\n        address(engine.vMochi()),\n        (mochiBalance * vMochiRatio) / 1e18\n    );\n    // send Mochi to veCRV Holders\n    mochi.transfer(\n        crvVoterRewardPool,\n        (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n    );\n}\n```",
      "summary": "\nA bug has been discovered in the code for the WatchPug project. The `distributeMochi()` function will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. However, it will also reset the `treasuryShare` to `0` which is unexpected. This means the protocol fee cannot be properly accounted for and collected.\n\nAnyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`. Repeating these steps will cause the `treasuryShare` to be consumed to near zero, which profits the vMochi Vault holders and veCRV Holders, while the protocol suffers the loss of funds.\n\nThe recommendation is to change the code to the code provided in the report. This will ensure that the `treasuryShare` is not reset to `0` and the protocol fee can be properly accounted for and collected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/114",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "922",
      "title": "[H-01] Vault fails to track debt correctly that leads to bad debt",
      "impact": "HIGH",
      "content": "_Submitted by jonah1005, also found by WatchPug_\n\n#### Impact\nIt's similar to the issue \"misuse amount as increasing debt in the vault contract\".\nSimilar issue in a different place that leads to different exploit patterns and severity.\n\nWhen users borrow usdm from a vault, the debt increases by the amount \\* 1.005.\n\n```solidity\n    uint256 increasingDebt = (_amount * 1005) / 1000;\n```\n\nHowever, when the contract records the total debt it uses `_amount` instead of `increasingDebt`.\n\n```solidity\ndetails[_id].debtIndex =\n    (details[_id].debtIndex * (totalDebt)) /\n    (details[_id].debt + _amount);\ndetails[_id].debt = totalDebt;\ndetails[_id].status = Status.Active;\ndebts += _amount;\n```\n\n[MochiVault.sol L242-L249](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L242-L249)\n\nThe contract's debt is inconsistent with the total sum of all users' debt. The bias increases overtime and would break the vault at the end.\n\nFor simplicity, we assume there's only one user in the vault.\nExample:\n\n1.  User deposits 1.2 M worth of BTC and borrows 1M USDM.\n2.  The user's debt (`details[_id].debt`) would be 1.005 M as there's a .5 percent fee.\n3.  The contract's debt is 1M.\n4.  BTC price decrease by 20 percent\n5.  The liquidator tries to liquidate the position.\n6.  The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M\n7.  The transaction is reverted as `details[_id].debt -= _usdm;` would raise exception.\n\ninaccurate accounting would lead to serious issues. I consider this a high-risk issue.\n\n#### Proof of Concept\nThis is a web3.py script that a liquidation may fail.\n\n```python\ndeposit_amount = 10**18\nbig_deposit = deposit_amount * 100000\nminter.functions.mint(user, big_deposit).transact()\n\ndai.functions.approve(vault.address, big_deposit + deposit_amount).transact()\n\n",
      "summary": "\nA bug report has been filed by jonah1005, which details a vulnerability in a contract that leads to an exploit pattern with varying severity. The issue is similar to the issue \"misuse amount as increasing debt in the vault contract\". When users borrow usdm from a vault, the debt increases by the amount multiplied by 1.005. However, when the contract records the total debt, it uses the original amount instead of the increased amount. This inconsistency leads to an inaccuracy in the accounting of the debt, which could lead to serious issues.\n\nA proof of concept has been provided in the form of a web3.py script, which demonstrates how a liquidation could fail. No tools are used in this report.\n\nThe recommended mitigation steps are to check the contract to make sure the increased debt amount is used consistently.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Mochi",
      "source_link": "https://code4rena.com/reports/2021-10-mochi",
      "github_link": "https://github.com/code-423n4/2021-10-mochi-findings/issues/72",
      "tags": [],
      "finders": [
        "WatchPug",
        "jonah1005"
      ]
    },
    {
      "id": "11256",
      "title": "[L02] Tests not passing",
      "impact": "LOW",
      "content": "The testing suite finishes with 4 failing tests. These tests are:\n\n\n`1) Tickets Feature: should not be possible to buy or transfer tickets during award  \n\n2) SingleRandomWinner: removeExternalErc20Award()  \n\n3) SingleRandomWinner: addExternalErc721Award()  \n\n4) SingleRandomWinner: removeExternalErc721Award()`\n\n\nAs the test suite was left outside of the audit’s scope, please consider thoroughly reviewing the test suite to make sure all tests run successfully. Furthermore, it is advisable to only merge code that neither breaks the existing tests nor decreases coverage.\n\n\n***Update:** Fixed in [pull request #205](https://github.com/pooltogether/pooltogether-pool-contracts/pull/205).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11255",
      "title": "[L01] Missing docstrings",
      "impact": "LOW",
      "content": "All the functions in the [`CompoundPrizePoolBuilder`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/builders/CompoundPrizePoolBuilder.sol) and the [`yVaultPrizePoolBuilder`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/builders/yVaultPrizePoolBuilder.sol) contracts lack documentation. This hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Fixed in [pull request #216](https://github.com/pooltogether/pooltogether-pool-contracts/pull/216).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11254",
      "title": "[M01] Capturing the award balance may fail",
      "impact": "MEDIUM",
      "content": "The [`captureAwardBalance` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L461) of the `PrizePool` contract relies on the [underlying asset balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L463) to calculate any available interest as award balance. Given that the way of calculating this balance may differ on each yield source, there is a possiblity that the [calculated `totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) may be greater than the `_currentAwardBalance` accumulated. For instance, the [`balanceOfUnderlying`](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L190) function in the Compound’s `CToken` contract [truncates the returned result](https://github.com/compound-finance/compound-protocol/blob/23eac9425accafb82551777c93896ee7678a85a3/contracts/CToken.sol#L192), which could lead into [an underflow when calculating the unnacounted prize balance](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L465) in extreme cases, and therefore stall the function for future calls.\n\n\nEven though this might not occur in the system as it is, this may change in future versions of the protocol when introducing new yield sources.\n\n\nConsider checking that the [`totalInterest`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/5a9381340a7cef139c77e44c5ad5c2a5d6e12e36/contracts/prize-pool/PrizePool.sol#L464) value calculated using the underlying asset’s balance is greater than the accumulated `_currentAwardBalance`.\n\n\n***Update:** Fixed in [pull request #205](https://github.com/pooltogether/pooltogether-pool-contracts/pull/205). The `captureAwardBalance` function now checks that the `totalInterest` value is greater than the `_currentAwardBalance` value to avoid the subtraction underflow.*",
      "summary": "\nThe `captureAwardBalance` function of the `PrizePool` contract is used to calculate any available interest as award balance. The way of calculating this balance may differ on each yield source, and there is a possibility that the calculated `totalInterest` may be greater than the `_currentAwardBalance` accumulated. This could lead to an underflow when calculating the unnacounted prize balance in extreme cases, and therefore stall the function for future calls. To avoid this, it is important to check that the `totalInterest` value is greater than the `_currentAwardBalance` value. This issue has been fixed in pull request #205, and the `captureAwardBalance` function now checks for this to prevent any subtraction underflow.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11253",
      "title": "[L06] Naming suggestions",
      "impact": "LOW",
      "content": "The [`PrizePool` contract](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol) implements the naming convention of prefixing `internal` values with an underscore. However, the following functions and variables disregard this convention:\n\n\n* [timelockBalances](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L110)\n* [unlockTimestamps](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L113)\n* [limitExitFee](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L305)\n* [isControlled](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L618)\n\n\nAdditionally, in the `MappedSinglyLinkedList` library, [`SENTINAL`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L8) should be `SENTINEL`.\n\n\n***Update:** Fixed in [pull request #108](https://github.com/pooltogether/pooltogether-pool-contracts/pull/108) and [pull request #109](https://github.com/pooltogether/pooltogether-pool-contracts/pull/109).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11252",
      "title": "[L05] MappedSinglyLinkedList Encapsulation",
      "impact": "LOW",
      "content": "To improve encapsulation of the `MappedSinglyLinkedList` data structure, consider renaming [both](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L79) [instances](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L91) of the `currentToken` variable to `currentAddress`.\n\n\nAdditionally, consider including `start`, `end` and `next` functions so [functions that traverse the list](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L606-L613) do not need to know the `addressMap` or `SENTINAL` implementation details.\n\n\n***Update:** Fixed in [pull request #108](https://github.com/pooltogether/pooltogether-pool-contracts/pull/108).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11251",
      "title": "[L04] Lack of event emission after sensitive changes",
      "impact": "LOW",
      "content": "The [`addControlledToken` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L554) of the `PrizePool` contract adds a new token to the `_tokens` array without emitting an event. To facilitate off-chain services tracking important state changes, consider emitting an event with the new token address, as well as emitting the same event for the first set of tokens added in the `initialize` function.\n\n\n***Update**: Fixed in [pull request #107](https://github.com/pooltogether/pooltogether-pool-contracts/pull/107). The `addControlledToken` function now emits the `ControlledTokenAdded` event.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11250",
      "title": "[L03] Lists can be initialized multiple times",
      "impact": "LOW",
      "content": "The `MappedSinglyLinkedList` data structure can be initialized multiple times by calling any of the [initialize functions](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L21-L39), which can lead to several inconsistencies:\n\n\n* Addresses in the original list cannot be [added](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L44) to the active one\n* Addresses in the original list **can** be [removed](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L56), despite not affecting the active list, which [may lead to a negative integer overflow](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L61)\n* Addresses in the original list will appear to be [contained](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L68) in the active one\n\n\nThis does not occur in the audited code. Nevertheless, consider preventing initialization of non-empty lists.\n\n\n***Update:** Fixed in [pull request #106](https://github.com/pooltogether/pooltogether-pool-contracts/pull/106). Now, the `initialize` function explicitly checks that the number of items in the list is zero before initialization.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11249",
      "title": "[L02] Linked list contains SENTINAL",
      "impact": "LOW",
      "content": "The [`contains` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L68) of the `MappedSinglyLinkedList` library will incorrectly return `true` when called with the [`SENTINAL` address](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L8). Consider checking and returning `false` in this edge case.\n\n\n***Update:** Fixed in [pull request #105](https://github.com/pooltogether/pooltogether-pool-contracts/pull/105). The `contains` function now returns false when called with the `SENTINAL` address.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11248",
      "title": "[L01] Duplicate code",
      "impact": "LOW",
      "content": "The `withdrawInstantlyFrom` function of the `PrizePool` contract  \n\n[caps the exit fee](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L271) with the `limitExitFee` function, and then immediately [performs the same operation to limit it again](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L274-L277). Consider removing the redundant code.\n\n\n***Update:** Fixed in [pull request #104](https://github.com/pooltogether/pooltogether-pool-contracts/pull/104).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11247",
      "title": "[M01] Inconsistent list initialization",
      "impact": "MEDIUM",
      "content": "The `MappedSinglyLinkedList` library has an [`initialize` function that accepts multiple addresses](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L29). However, it does not perform any validation of the user-supplied addresses. If the list contains duplicate addresses or the special `SENTINAL` address, it will be created in an inconsistent state. Consider using the [`addAddress` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/utils/MappedSinglyLinkedList.sol#L44) in the loop to perform the appropriate checks.\n\n\n***Update:** Fixed in [pull request #103](https://github.com/pooltogether/pooltogether-pool-contracts/pull/103). The `initialize` function no longer accepts an array of addresses as a parameter, and the `addAddresses` function was implemented to add multiple items to the list, handling both duplicate addresses and the `SENTINAL` address.*",
      "summary": "\nThe `MappedSinglyLinkedList` library contains an `initialize` function that can accept multiple addresses as parameters. However, this function does not check for duplicate addresses or the special `SENTINAL` address, which can lead to an inconsistent state. To solve this issue, the `addAddress` function should be used in a loop to perform the necessary checks. This issue has now been fixed in pull request #103, where the `initialize` function no longer accepts an array of addresses and the `addAddresses` function was implemented to add multiple items to the list while ensuring that duplicate addresses and the `SENTINAL` address are handled appropriately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11246",
      "title": "[H02] Trapped sponsorship",
      "impact": "HIGH",
      "content": "The `withdrawInstantlyFrom` function of the `PrizePool` allows the caller to [optionally provide a `sponsorAmount`](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L260) that will be applied towards the exit fee. In practice, this should be equivalent to a simple transfer from the caller to the `from` address. Whether or not a `sponsorAmount` is provided, the exit fee should be implicitly levied by leaving this amount in the yield service. However, the prize pool [only leaves the non-sponsored component of the exit fee in the yield service](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L293-L294), which is the same amount that is [transferred to the user](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L296). This means the sponsored amount remains trapped in the `PrizePool` contract and is not included in the next award. Consider adjusting the `_redeem` parameters so the full exit fee is left in the yield service.\n\n\n***Update:** Fixed in [pull request #102](https://github.com/pooltogether/pooltogether-pool-contracts/pull/102). The Pooltogether team decided to remove the sponsor amount from the `withdrawInstantlyFrom` function.*",
      "summary": "\nA bug was reported in the `withdrawInstantlyFrom` function of the `PrizePool` contract. This function allows the caller to optionally provide a `sponsorAmount` that should be applied towards the exit fee. However, the prize pool only leaves the non-sponsored component of the exit fee in the yield service, and does not include the sponsored amount in the next award. This means the sponsored amount remains trapped in the `PrizePool` contract.\n\nThe Pooltogether team decided to remove the sponsored amount from the `withdrawInstantlyFrom` function, which was fixed in pull request #102.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11245",
      "title": "[H01] Improper Error Handling",
      "impact": "HIGH",
      "content": "The `CompoundPrizePool` contract interacts with the Compound system to [mint new cTokens](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L87) and [redeem them for the underlying asset](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/compound/CompoundPrizePool.sol#L101). In both cases the code ignores the returned [error code](https://github.com/compound-finance/compound-protocol/blob/master/contracts/CErc20.sol#L42). Since these calls are intended to be part of atomic operations that [mint](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L240-L242) and [burn](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L289-L294) pool tokens, failure to account for errors in the Compound calls could lead to internal inconsistencies, under-invested tokens and loss of user funds.\n\n\nConsider reverting the transaction whenever the Compound system returns an error, to ensure the operations remain atomic.\n\n\n***Update:** Fixed in [pull request #101](https://github.com/pooltogether/pooltogether-pool-contracts/pull/101/). The `_redeem` and `_supply` functions in `CompoundPrizePool.sol` now require that the value returned by the `cToken` contract equals zero, which represents the [NO\\_ERROR code in Compound](https://github.com/compound-finance/compound-protocol/blob/1cf040412fc8a0cfd1187bb0d8a525c3ae2f78aa/contracts/ErrorReporter.sol#L5).*",
      "summary": "\nA bug was found in the `CompoundPrizePool` contract, which interacts with the Compound system to mint new cTokens and redeem them for the underlying asset. In both cases, the code ignored the returned error code, which could lead to internal inconsistencies, under-invested tokens and loss of user funds. To fix the issue, the transaction was reverted whenever the Compound system returns an error, to ensure the operations remain atomic. The bug was fixed in pull request #101, where the `_redeem` and `_supply` functions now require that the value returned by the `cToken` contract equals zero, which represents the NO_ERROR code in Compound.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11244",
      "title": "[C01] Funds can be lost",
      "impact": "HIGH",
      "content": "The [`sweepTimelockBalances` function](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L471) accepts a list of users with unlocked balances to distribute. However, if there are duplicate users in the list, their balances will be counted multiple times when calculating the [total amount to withdraw](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L493) from the yield service. This has two consequences:\n\n\n* After the transaction is complete, the excess amount withdrawn will be held by the `PrizePool` contract (instead of the yield service) and will not earn interest\n* Eventually, a user will want to withdraw that amount, which will fail when the `PrizePool` attempts to [redeem it from the yield service](https://github.com/pooltogether/pooltogether-pool-contracts/blob/23b826b94e62d9c3a49bbe637da44cd1409c5b7f/contracts/prize-pool/PrizePool.sol#L294). This means the last users to withdraw will lose their funds. Interestingly, in the case of the `CompoundPrizePool`, this is partially mitigated by the [**“[H01] Improper Error Handling”**](#h01) issue.\n\n\nConsider checking for duplicate users when calculating the amount to withdraw.\n\n\n***Update**: Fixed in [pull request #100](https://github.com/pooltogether/pooltogether-pool-contracts/pull/100). The `_sweepTimelockBalances` function now removes the user’s timelock balance after adding it to the total withdrawal amount and saving it into an auxiliary array named `balances`, which has the same size as the `users` array provided as a parameter. In this process, as the code still allows the `users` to have duplicate addresses, a zero will be saved in the `balances` array for each repeated address.*",
      "summary": "\nA bug was found in the `sweepTimelockBalances` function of the PoolTogether Pool Contracts which allowed for duplicate users to be included in the list of users with unlocked balances to distribute. This caused an excess amount to be withdrawn from the yield service, which was then held by the `PrizePool` contract instead. This meant that the last users to withdraw would lose their funds, and the issue was partially mitigated by the “H01 Improper Error Handling” issue.\n\nTo fix the bug, the `_sweepTimelockBalances` function was updated in pull request #100. Duplicate users are now removed after adding their balance to the total withdrawal amount, and a zero is saved in the `balances` array for each repeated address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "PoolTogether v3 Audit",
      "source_link": "https://blog.openzeppelin.com/pooltogether-v3-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11382",
      "title": "[L10] underlyingPrecision can overflow",
      "impact": "LOW",
      "content": "[`underlyingPrecision`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L206) is defined within the `ACOToken.init` function as `10 ** uint256(underlyingDecimals)`. When [`underlyingDecimals` is set](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L202), there are no checks afterwards to ensure that `underlyingDecimals < 78`. The maximum possible value of [`uint256`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L119) is roughly `1e77`, so any value above `77` for `underlyingDecimals` will cause `underlyingPrecision` to overflow. Consider implementing a check on `underlyingDecimals` after setting it.\n\n\n**Update:** *Fixed in [pull request #10](https://github.com/AuctusProject/aco/pull/10).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11381",
      "title": "[L09] An infinite loop may exist",
      "impact": "LOW",
      "content": "Within `ACOToken.sol` there is an [infinite loop](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L665) on line 665. The continuation condition for this loop is that `i >= 0`. Since `i` is a `uint` type and since it is decreased at each iteration, it will end up passing from `0` and then start again from the maximum positive value of an `uint` variable. So the continuation condition will always be true no matter what the value for `i` is.\n\n\nConsidering the [check following the loop](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L671) (which checks that `tokenAmount == 0`) and the [`break` condition](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L666) for the loop which checks the same thing, it appears that the intention was for this loop to be exitable without using the `break` condition.\n\n\nConsider changing the definition of `i` to `int` instead of `uint`.\n\n\n**Update:** *Fixed. They refactored the mentioned loop in different pull requests. Now it iterates over a maximum number of accounts that can be exercised for each call, shown in [pull request #9](https://github.com/AuctusProject/aco/pull/9).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11380",
      "title": "[L08] Lack of indexed parameters",
      "impact": "LOW",
      "content": "None of the parameters in the [`SetFactoryAdmin`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L18), [`SetAcoTokenImplementation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L25), [`SetAcoFee`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L32) and [`SetAcoFeeDestination`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L39) events in the [`ACOFactory`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol) are indexed. The same is true for the [`ProxyAdminUpdated`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol#L16) and [`SetImplementation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol#L23) events of the [`ACOProxy`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOProxy.sol) contract.\n\n\nIndexing parameters in these events allows the timeline of sensitive changes to be more easily tracked. Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n**Update:** *Partially fixed. The Auctus team decided to index event parameters in the `ACOFactory` contract in [pull request #11](https://github.com/AuctusProject/aco/pull/11), but not in `ACOProxy` as shown in [pull request #15](https://github.com/AuctusProject/aco/pull/15). Auctus’ statemement for this issue:*\n\n\n\n> \n>  We indexed parameters in the ACOFactory. About the proxy parameters, we don’t expect significant amount of data to justify changing our current proxy address.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11379",
      "title": "[L07] Warning about listing tokens",
      "impact": "LOW",
      "content": "When taking into consideration the list of supported token pairs, special attention should be paid to:\n\n\n* Tokens which do not revert on failing `transfer`s or `transferFrom`s.\n* Tokens that extract fees (e.g. `USDT`) which may transfer less tokens than intended.\n* Tokens with whitelists (`ACOToken` proxies may not be allowed to transfer in those cases).\n* Tokens with `ERC777`-compliant hooks that can execute code.\n\n\nThe first two points are addressed in the issue [**`ERC20` transfers can misbehave**](#m01).\n\n\n**Update:** *Acknowledged. Auctus’ statement for this issue:*\n\n\n\n> \n>  The team is aware and will always check if new token pairs are supported, paying attention to the points mentioned.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11378",
      "title": "[L06] Use of / operator can cause unexplained reverts",
      "impact": "LOW",
      "content": "In the [`UniswapV2Library` library](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol) the `/` operator is used. If a division by `0` occurs, the transaction would revert with no explanation.\n\n\nThe `/` operator used in [line 57 of `UniswapV2Library.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L57) would revert with no error message if a division by `0` occurs.\n\n\nNote that the `/` operator used in lines [38](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L38) and [48](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L48) of the same file would revert if the divisor is `0` before it is able to reach the actual division expression. This is due to the checks in [line 37](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L37) and [line 44](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L44).\n\n\nConsider implementing a check before calling [`getAmountIn`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L52) to ensure that `reserveOut != amountOut`, [preventing a division by 0](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/UniswapV2Library.sol#L56). Alternatively, consider using [`div` from the `SafeMath` library](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/SafeMath.sol#L98), which [checks if the denominator is 0](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/libs/SafeMath.sol#L114) and reverts with an error message.\n\n\n**Update:** *Fixed in [pull request #23](https://github.com/AuctusProject/aco/pull/23). The Auctus team acknowledged the problem and decided to remove the library and to use directly the `IUniswapV2Router02` interface. Notably, the Uniswap implementation of such interface [is still using the same library](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L7) presenting the highlighted issue.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11377",
      "title": "[L05] ACOTokens become non-transferrable after expiration",
      "impact": "LOW",
      "content": "Although the [`ACOToken` contract inherits](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L13) `ERC20.sol`, which has a standard [`transfer`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ERC20.sol#L33) function, the [`_transfer` function of `ERC20.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ERC20.sol#L59) is overridden by the [`_transfer` function in `ACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L590). Although it does call [`_transferAction`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ERC20.sol#L72) just like the `ERC20.sol` version, one notable difference is that the [version in `ACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L590) has the [`notExpired()`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L150) modifier on it, which means that calls to `transfer` will revert after the `ACOToken` expires.\n\n\nUsers should be aware that not only will their tokens be worthless after expiry, but any `transfer` attempts will fail. So, if users place their tokens in liquidity pools, such as UniswapV1, or within custodial exchanges, any attempts to transfer out their tokens will not succeed after expiration. This is especially noteworthy in the Uniswap case, as removing liquidity will [always fail](https://github.com/Uniswap/uniswap-v1/blob/c10c08d81d6114f694baa8bd32f555a40f6264da/contracts/uniswap_exchange.vy#L94) if one of the assets is an expired `ACOToken`, meaning that all other liquidity in the pair will also be locked.\n\n\nConsider informing users of the risks of trading and transferring their tokens after expiration, especially in the case of using Uniswap.\n\n\n**Update:** *Fixed in [pull request #14](https://github.com/AuctusProject/aco/pull/14) and [pull request #22](https://github.com/AuctusProject/aco/pull/22). Tokens are now transferrable and approvable after expiration.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11376",
      "title": "[L04] Allowance requiring functions can be front-run",
      "impact": "LOW",
      "content": "There are many functions within [`ACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol) which require an allowance of one user to another. For example, [`burnFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L439), [`redeemFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L458), and [`exerciseFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L482) allow one account `A` to perform actions on behalf of account `B` when account `B` has given `A` an allowance of `ACOToken`s.\n\n\nIf `B` gives `A` an allowance of `ACOToken`s, but front-runs `A`‘s calls to these functions to change the allowance to `0`, it will cause a `revert`. For example, in [`exerciseFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L482), front-running by `B` can cause `A`‘s call to fail [within `_burnFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ERC20.sol#L68).\n\n\nThe implicit mitigation for issues is that a trust relationship between `A` and `B` should exist for an allowance to be given in the first place. However, in certain cases, such as other DeFi protocols building off of ACO, or users selling allowances for their `ACOToken`s, front-running can be abused to cause losses or prevent functionality of external protocols.\n\n\nWe report this issue to better inform external developers and users. Both should be aware that allowances can be changed arbitrarily. Consider informing users of the risks of using functions which rely on allowances.\n\n\n**Update:** *Acknowledged. Auctus’s statement for this issue:*\n\n\n\n> \n>  We will inform developers and external users using our channels and when we publish a development documentation.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11375",
      "title": "[L03] Invalid data can be returned after expiration",
      "impact": "LOW",
      "content": "Comments on lines [252](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L252), [263](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L263), [283](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L283), and [298](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L298) of `ACOToken.sol` state that the functions `unassignableCollateral`, `assignableCollateral`, `unassignableTokens` and `assignableTokens` are only valid when the `ACOToken` is not “expired”. These functions are all `view` and are not called by other functions within the `ACOToken` contract. There also exists a `notExpired()` modifier, which is applied to many other functions within `ACOToken.sol` and causes reverts after the `ACOToken` is expired. Additionally, [`unassignableCollateral` calls `unassignableTokens`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L258) and [`assignableCollateral` calls `assignableTokens`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L269).\n\n\nConsider applying the `notExpired()` modifier to [`unassignableTokens`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L288) and [`assignableTokens`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L303). This will cause calls to `unassignableCollateral`, `assignableCollateral`, `unassignableTokens` and `assignableTokens` to revert once the `ACOToken` is expired. This will not only improve the code’s readability and auditability, but it will also protect future developers, both internal and external, who may have missed the comments mentioned above. When being called after expiration, these functions will revert rather than return erroneous data. Alternatively, consider implementing code such that the correct values are returned both before and after expiration.\n\n\n**Update:** *Fixed in [pull request #7](https://github.com/AuctusProject/aco/pull/7). Correct values are returned now, depending on the expiration status.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11374",
      "title": "[L02] ACOToken.sol reference implementation is publicly initializable",
      "impact": "LOW",
      "content": "The [`init` function of `ACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177-L185) is `public` and allows anyone to call it, setting key parameters for the contract. `ACOToken` contracts are deployed to new addresses [via the minimal proxy pattern](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235-L249), so a reference implementation must be deployed beforehand, exposing the `init` function. A malicious user can access the `init` function and set the contract parameters as if it was a reputable `ACOToken` from Auctus. Even though this will not affect any other token contract, it should never be treated as a valid token, given that it may appear to be so to an uninformed user.\n\n\nConsider initializing the `ACOToken.sol` reference implementation with “garbage” data, such as invalid [asset addresses](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L178-L179) and an expiry time that has already passed, to make this clearer to users and [prevent other calls to `init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L186). Additionally, consider establishing a developer process for doing this every time a new version of `ACOToken.sol` is deployed to the network. Consider informing users to only access `ACOToken`s through the official user interface.\n\n\n**Update:** *Acknowledged. Auctus’ statement for this issue:*\n\n\n\n> \n>  The team will establish a process to initialize the ACOToken.sol reference implementation with “garbage” data after every new deployment.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11373",
      "title": "[L01] Using .call for init is not flexible",
      "impact": "LOW",
      "content": "When [deploying another `ACOToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235) using `ACOFactory.sol`, after [a minimal proxy is deployed](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L239-L245), the low-level [`call` function is used](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L246) to call [`init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177) for the proxy. The [`_acoTokenInitializeError`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L257) function is used to [return any error message from the proxy](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L247).\n\n\nWhile such a method of calling `init` makes sense when `ACOToken.sol`‘s `init` function may be [changed](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L178), we noticed the presence of the [`_getAcoTokenInitData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L212-L228) function, which is used to format data for passing into the `init` function [in the `createAcoToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L124) function. This is the only method which calls `_deployAcoToken`, and is therefore the only way to deploy a new `ACOToken` proxy instance.\n\n\nIf any future changes are made to the parameters passed into the `init` function of `ACOToken.sol`, a modified version of `ACOFactory.sol` will have to be deployed, as the `_getAcoTokenInitData` function will no longer be valid. So, the use of the low-level `call` function is unfortunately not any more useful than a direct call to the `init` function, since the flexibility of passing arbitrary data is lost. However, by implementing extra code to [format the `init` input data](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L219-L226) and [handle any errors](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L258-L267), a larger surface for error is created.\n\n\nConsider removing [`_getAcoTokenInitData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L212) and [`_acoTokenInitializeError`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L257), and replacing the low-level `call` with a direct call to the proxy’s `init` function. This will require importing [`IACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/interfaces/IACOToken.sol) and adding the [`init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177-L185) function to the interface. All parameters for `init` can then be passed directly to [`_deployAcoToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235). By doing so, the code’s readability and auditability will be greatly increased, and the surface for error will be made significantly smaller.\n\n\n**Update:** *Fixed in [pull request #13](https://github.com/AuctusProject/aco/pull/13).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11372",
      "title": "[M03] Collateral owners can skip being exercised",
      "impact": "MEDIUM",
      "content": "When a user calls [`exercise()`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L469) or [`exerciseFrom()`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L482), an eventual call to [`exerciseOwners()` will be made](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L640). Within `exerciseOwners()`, a [loop](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L664-L669) will call `_exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount)` with decreasing `i` after every iteration. Within [`_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L697), the collateral owner in question (`_collateralOwners[i]`) will only [be exercised](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L701-L722) if [`_getAssignableAmount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L698-L699) for that account evaluates to `> 0`. If the collateral owner in question has an account balance greater than or equal to their `tokenData[account].amount` value, [`_getAssignableAmount` will return `0`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L806-L807). This will cause the account to not be exercised upon.\n\n\nA user, or coalition of users, may do this by having two accounts which own collateral, with one near index `0` of the `_collateralOwners` array and one near the final index of the same array. If the user or users suspect that the account closer to the final index of the array may be exercised, they can transfer tokens from the account closer to index `0` such that the balance of the account further from index `0` equals the `tokenData[account].amount` value for that account. This can be done by front-running an `exercise` transaction, or proactively before an `exercise` transaction takes place.\n\n\nIt is also important to note that this could cause the [`_exerciseOwners`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L663) function to [always run out of gas due to the loop](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L664-L669), in the case of too many users having no exercisable collateral. This would effectively disable the [`exercise`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L469) and [`exerciseFrom`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L482) functions.\n\n\nConsider adding some mechanism which allows users to be exercised once they have transferred minted tokens out of their account, even if they transfer them back.  \n\nThis could be accomplished with a new data field in [`tokenData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L124), perhaps called something like `transferredTokens`. With any functionality changes to the code, thorough test coverage is a must.\n\n\n**Update:** *Fixed. The Auctus team implemented a different solution in [pull request #25](https://github.com/AuctusProject/aco/pull/25/files) which mitigates the possibility of disabled `exercise` and `exerciseFrom` functions. Auctus’ statement for this issue:*\n\n\n\n> \n>  We are proposing an alternative solution, because the proposed solution would make it impossible to avoid being exercised even if the option is bought back. In traditional markets, most traders buy it back to avoid being exercised. Our proposed solution is adding a salt argument that will put randomness on the start index to the array of accounts to exercise.\n> \n> \n>",
      "summary": "\nA bug report has been issued regarding the Auctus Project's ACOToken.sol code. The bug states that when a user calls either the exercise() or exerciseFrom() functions, an eventual call to exerciseOwners() will be made. Within exerciseOwners(), a loop will call _exerciseAccount() with decreasing i after every iteration. Within _exerciseAccount(), the collateral owner in question will only be exercised if _getAssignableAmount for that account evaluates to greater than 0. If the collateral owner in question has an account balance greater than or equal to their tokenData[account].amount value, _getAssignableAmount will return 0. This will cause the account to not be exercised upon.\n\nThis bug could be exploited by a user or coalition of users. They could have two accounts which own collateral, with one near index 0 of the _collateralOwners array and one near the final index of the same array. If the user or users suspect that the account closer to the final index of the array may be exercised, they can transfer tokens from the account closer to index 0 such that the balance of the account further from index 0 equals the tokenData[account].amount value for that account. This could be done by front-running an exercise transaction, or proactively before an exercise transaction takes place.\n\nAdditionally, this could cause the _exerciseOwners function to always run out of gas due to the loop, in the case of too many users having no exercisable collateral. This would effectively disable the exercise and exerciseFrom functions.\n\nThe Auctus team implemented a different solution in pull request #25 which mitigates the possibility of disabled exercise and exerciseFrom functions. The proposed solution adds a salt argument that will put randomness on the start index to the array of accounts to exercise. Additionally, thorough test coverage is a must with any functionality changes to the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11371",
      "title": "[M02] It is possible to mint 0 tokens",
      "impact": "MEDIUM",
      "content": "The various minting functions ([`mintPayable`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L378), [`mintToPayable`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L389), [`mint`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L399), and [`mintTo`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L414)) all call [`_mintToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L565). This function calculates the number of tokens minted via [`getTokenAmount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L327) based on the `collateralAmount` sent in by the user. In the case of a `PUT` option, where `underlyingPrecision < strikePrice`, it is possible for `getTokenAmount` to [return `0`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L331), even with a [non-zero `collateralAmount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L566). This will mint `0` tokens to the user or targeted address. Notably, if an account has `0` tokens, the [check on line 568](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L568) will pass and [the account will be added to the `_collateralOwners` array](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L569-L570). This can be repeated, causing the same account to be added to the array. This will cause execution of [`_exerciseOwners`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L663) to require more gas, since any calls to [`_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L669) on an account with `0` balance will [do nothing](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L699-L723) when the [`available`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L698) amount for that account [is `0`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L804-L807). If abused, it could lead to a freezing of this function. However, it should also be noted that [`_exerciseAccounts`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L680-L688) exists and could be used to work around this. Consider adding a check [after line 573](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L573) that requires `tokenAmount != 0`. This will help keep the `_collateralOwners` array clean and minimize user error.\n\n\n**Update:** *Fixed in [pull request #6](https://github.com/AuctusProject/aco/pull/6).*",
      "summary": "\nA bug has been reported in the AuctusProject/aco repository. The bug relates to the minting functions of the ACOToken.sol contract. These functions are used to mint tokens to the user or targeted address. The bug occurs when the `underlyingPrecision` is less than the `strikePrice` and the `getTokenAmount` function returns `0`, even with a non-zero `collateralAmount`. This will cause `0` tokens to be minted. Additionally, if an account has `0` tokens, the check on line 568 will pass and the account will be added to the `_collateralOwners` array, which can be repeated. This will cause execution of `_exerciseOwners` to require more gas since calls to `_exerciseAccount` on an account with `0` balance will do nothing. If abused, it could lead to a freezing of this function.\n\nTo fix the bug, a check should be added after line 573 that requires `tokenAmount != 0`. This will help keep the `_collateralOwners` array clean and minimize user error. The bug has now been fixed in pull request #6.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11370",
      "title": "[M01] ERC20 transfers can misbehave",
      "impact": "MEDIUM",
      "content": "The [`_transferFromERC20`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L1071) function is used throughout `ACOToken.sol` to handle transferring funds into the contract from a user. It is called [within `mint`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L403), [within `mintTo`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L418), and [within `_validateAndBurn`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L750). In each case, the destination is the `ACOToken` contract.\n\n\nSuch transfers may behave unexpectedly if the token contract charges fees. As an example, the popular USDT token does not presently charge any fees upon transfer, but it has the potential to do so. In this case the amount received would be less than the amount sent. Such tokens have the potential to lead to protocol insolvency when they are used to mint new `ACOToken`s.\n\n\nTransfers may also behave unexpectedly when they don’t `throw` upon an execution’s failure. Remember that the [`ERC20` standard](https://eips.ethereum.org/EIPS/eip-20) allows for such tokens to still be considered `ERC20` compliant. In this case, the [`require` on line 1073](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L1073) or [line 1061](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L1061) may not cause a `revert`, since `success` will be true.\n\n\nIn the case of [`_transferERC20`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L1059), similar issues can occur, and could cause users to receive less than expected [when collateral is transferred](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L624) or [when exercise assets are transferred](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L720).\n\n\nConsider thoroughly vetting each token used within an ACO options pair, ensuring that failing `transferFrom` and `transfer` calls will cause reverts within `ACOToken.sol`. Additionally, consider implementing some sort of sanity check which enforces that the balance of the `ACOToken` contract increases by the desired amount when calling `_transferFromERC20`. See related issue [**Warning about listing tokens**](#l07).\n\n\n**Update:** *Ackowledged. Auctus’ statement for this issue:*\n\n\n\n> \n>  The team is aware and will always check if new token pairs are supported, paying attention to the points mentioned in [L07]\n> \n> \n>",
      "summary": "\nThis bug report is about the `_transferFromERC20` function in the ACOToken.sol file. This function is used to transfer funds into the contract from a user. It is called in the mint, mintTo and _validateAndBurn functions. The issue is that if the token contract charges fees, then the amount received will be less than the amount sent. This could lead to protocol insolvency when used to mint new ACOTokens. Additionally, the `ERC20` standard allows for tokens to still be considered `ERC20` compliant even if they don't `throw` upon an execution's failure. This could cause users to receive less than expected when collateral or exercise assets are transferred.\n\nTo address this issue, the team should thoroughly vet each token used within an ACO options pair to ensure that failing `transferFrom` and `transfer` calls will cause reverts within `ACOToken.sol`. Additionally, they should consider implementing a sanity check which enforces that the balance of the `ACOToken` contract increases by the desired amount when calling `_transferFromERC20`. The team acknowledged the issue and stated that they will always check if new token pairs are supported, paying attention to the points mentioned in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11369",
      "title": "[H01] Users can exercise small amounts without sending collateral",
      "impact": "HIGH",
      "content": "When exercising option tokens, the [`_exercise` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L638) calls `_validateAndBurn` to validate that the exercising account is able to transfer in the required amount of the `exerciseAsset`. This is calculated by [`getExerciseData(tokenAmount)`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L744), which uses the amount of option token units transferred in as `tokenAmount`. In the case of a `CALL` option, [`getExerciseData` will call `_getTokenStrikePriceRelation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L343-344). If `tokenAmount` is small enough, and `strikePrice` is smaller than `underlyingPrecision`, it is possible for `_getTokenStrikePriceRelation` to [return `0`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L760). This results in the `expectedAmount` (which the exerciser is [required to transfer in](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L746-750)) being `0` as well. So, the user can choose a `tokenAmount` which is nonzero, that allows them to transfer in no tokens to conduct an exercise.\n\n\nAfter `_validateAndBurn`, the [`_exerciseOwners` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L640) is called. Within this function, the [`_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L697) function calls [`getExerciseData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L711) to determine the amount to be [transferred](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-21) to the accounts being exercised. In the case of a `CALL` option, it will again utilize [`_getTokenStrikePriceRelation(tokenAmount)`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L344), where `tokenAmount` is the amount of collateral tokens being exercised. This results in `_exerciseAccount` also [transferring](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-721) `0` units of the asset to the account being exercised. This should be the option minter’s reward for selling their collateral, but we see that the minter receives nothing and thus is effectively robbed.\n\n\nFinally, the `_exercise` function calls [`getCollateralOnExercise`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L654), which will simply return `tokenAmount` with a fee taken out for the `CALL` case. The following call to [`_transferCollateral`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L655) will then [transfer this amount back to `msg.sender`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L618-628).\n\n\nAs can be seen from the above situation, it is possible for a user to exercise another “for free”. In the case of a `CALL` option for `ETH/USDC`, with the strike price being `200 USDC`, any amount under `5e9` option token units will result in the exerciser having to pay nothing. This, notably, can be extended to users receiving more collateral than deserved by always exercising an amount of token units that is one less than a number evenly divisible by `5e9`. Thus, although redeeming `4.99...e9` tokens is disinentivized by gas costs, there is little disincentive to modify a larger token amount when exercising if the exercise was already planned anyway.\n\n\nHere we present two potential solutions. First, consider modifiying the `_getTokenStrikePriceRelation` function such that instead of rounding down by default, it rounds up upon any division which results in a fraction. However, this  \n\nmay cause problems when exercising multiple accounts, as each account’s received amount within `_exerciseAccount` is determined via a call to [`getExerciseData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L711), which may also round. So, the amount transferred in by the user to exercise may be calculated as `x+1` units due to rounding, but when exercising `n` accounts, the total amount transferred to the accounts may be as high as `x+n` due to rounding on *each separate account’s transfer*. This means that the [transfers within `_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-721) may attempt to transfer more than the exercising account [originally paid within `_validateAndBurn`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L746-750). To solve this, the user could be required to transfer in the required amount of units plus `n_max`, where `n_max` is the highest possible number of accounts that could be exercised. Any extra funds can be returned to the user at the end of the [`_exercise` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L642). Alternatively, it can be left in the contract if it is deemed to not be worth as much as the potential gas savings from avoiding the transfer.\n\n\nThe second potential solution is to refactor all calculation functions to take the less precise asset of any asset pair, and determine option token amounts based on this. Then, the corresponding amount of the higher precision asset can be derived via multiplication. This way, fractional units will never occur, as all mathematical operations will be based on multiplication. However it may require more complex logic to handle different combinations of `CALL` vs. `PUT` and underlying assets having more decimals vs. less decimals than the stike assets.\n\n\nConsider implementing one of the described solutions. In general, any rounding errors should favor protocol solvency, followed by the users minting tokens, since they are taking a risk. If there is any loss of units of assets, it should be done in such a way that the protocol never has, and option minters never receive, less assets than expected. As always, when making large changes to the codebase, thorough passing test coverage should be achieved before moving to deployment.\n\n\n**Update:** *Fixed in [pull request #12](https://github.com/AuctusProject/aco/pull/12). They are implementing the first solution presented. We want to highlight the fact that the exercising account doesn’t receive back the amount of extra tokens left after the exercise. While this can be acceptable if the gas cost to send them back is higher than the value they represent, it can start to be a problem if a single token unit is highly valuable.*",
      "summary": "\nA bug has been identified in the Auctus Project's ACO smart contract. The bug allows users to exercise option tokens for free, which should not be possible. The bug occurs when exercising a `CALL` option with a strike price of `200 USDC` and an amount of option token units that is smaller than `5e9`. In this case, the `_getTokenStrikePriceRelation` function returns `0`, resulting in `expectedAmount` being `0` as well. This allows the user to exercise the option without transferring in any tokens. \n\nThe bug occurs again in the `_exerciseAccount` function, which calls `getExerciseData` with the amount of collateral tokens being exercised. This again results in `_exerciseAccount` transferring `0` units of the asset to the account being exercised. This should be the option minter’s reward for selling their collateral, but they receive nothing and thus are effectively robbed.\n\nTwo potential solutions have been presented. The first solution is to modify the `_getTokenStrikePriceRelation` function such that instead of rounding down by default, it rounds up upon any division which results in a fraction. This would solve the problem of users exercising options for free, but it may cause problems when exercising multiple accounts, as each account’s received amount within `_exerciseAccount` is determined via a call to `getExerciseData`, which may also round. To solve this, the user could be required to transfer in the required amount of units plus the highest possible number of accounts that could be exercised. The second solution is to refactor all calculation functions to take the less precise asset of any asset pair, and determine option token amounts based on this. This way, fractional units will never occur, as all mathematical operations will be based on multiplication.\n\nThe bug has been fixed in pull request #12, and the first solution presented has been implemented. The exercising account doesn’t receive back the amount of extra tokens left after the exercise, but this can be acceptable if the gas cost to send them back is higher than the value they represent.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "ACO Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/aco-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13738",
      "title": "Where possible, a specific contract type should be used rather than address  Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was partially addressed by changing some state variable declarations from `address` to the specific contract type. For example, methods in `Exchange` still take `address` parameters instead of concrete `Perpetual` types.\n\n\n#### Description\n\n\nRather than storing `address`es and then casting to the known contract type, it’s better to use the best type available so the compiler can check for type safety.\n\n\n#### Examples\n\n\n`Collateral. collateral` is of type `address`, but it could be type `IERC20` instead. Not only would this give a little more type safety when deploying new modules, but it would avoid repeated casts throughout the codebase of the form `IERC20(collateral)`, `IPerpetual(_perpetual)` and others. The following is an incomplete list of examples:\n\n\n* declare collateral as IERC20\n\n\n**code/contracts/perpetual/Collateral.sol:L19-L19**\n\n\n\n```\naddress public collateral;\n\n```\n**code/contracts/perpetual/Collateral.sol:L51-L51**\n\n\n\n```\nIERC20(collateral).safeTransferFrom(guy, address(this), rawAmount);\n\n```\n* declare argument `perpetual` as `IPerpetual`\n\n\n**code/contracts/exchange/Exchange.sol:L34-L42**\n\n\n\n```\nfunction matchOrders(\n    LibOrder.OrderParam memory takerOrderParam,\n    LibOrder.OrderParam[] memory makerOrderParams,\n    address \\_perpetual,\n    uint256[] memory amounts\n) public {\n    require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n    IPerpetual perpetual = IPerpetual(\\_perpetual);\n\n```\n* declare argument `feeder` as `IChainlinkFeeder`\n\n\n**code/contracts/oracle/ChainlinkAdapter.sol:L12-L14**\n\n\n\n```\nconstructor(address \\_feeder) public {\n    feeder = IChainlinkFeeder(\\_feeder);\n}\n\n```\n#### Remediation\n\n\nWhere possible, use more specific types instead of `address`. This goes for parameter types as well as state variable types.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13737",
      "title": "LibMath/LibOrder - unused named return value ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was resolved by either returning a named value or using the return statement.\n\n\n#### Description\n\n\nThe following methods declare a named return value but explicitly return a value instead. The named return value is not used.\n\n\n* `LibMathSigned.min()`\n* `LibMathSigned.max()`\n* `LibMathUnsigned.min()`\n* `LibMathUnsigned.max()`\n* `LibOrder.getOrderHash()`\n* `LibOrder.hashOrder()`\n\n\n#### Examples\n\n\n**code/contracts/lib/LibMath.sol:L90-L96**\n\n\n\n```\nfunction min(int256 x, int256 y) internal pure returns (int256 z) {\n    return x <= y ? x : y;\n}\n\nfunction max(int256 x, int256 y) internal pure returns (int256 z) {\n    return x >= y ? x : y;\n}\n\n```\n**code/contracts/lib/LibMath.sol:L285-L292**\n\n\n\n```\nfunction min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x <= y ? x : y;\n}\n\nfunction max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x >= y ? x : y;\n}\n\n\n```\n**code/contracts/lib/LibOrder.sol:L68-L71**\n\n\n\n```\nfunction getOrderHash(Order memory order) internal pure returns (bytes32 orderHash) {\n    orderHash = LibEIP712.hashEIP712Message(hashOrder(order));\n    return orderHash;\n}\n\n```\n**code/contracts/lib/LibOrder.sol:L86-L97**\n\n\n\n```\nfunction hashOrder(Order memory order) internal pure returns (bytes32 result) {\n    bytes32 orderType = EIP712\\_ORDER\\_TYPE;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n        let start := sub(order, 32)\n        let tmp := mload(start)\n        mstore(start, orderType)\n        result := keccak256(start, 224)\n        mstore(start, tmp)\n    }\n    return result;\n}\n\n```\n#### Recommendation\n\n\nRemove the named return value and explicitly return the value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13736",
      "title": "LibMath - roundHalfUp returns unfinished result ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by adding the following comment to the function signature. Please note that the code documentation does not adhere to the natspec format.\n\n\n\n> \n> // ROUND\\_HALF\\_UP rule helper. You have to call roundHalfUp(x, y) / y to finish the rounding operation\n> \n> \n> \n\n\nThere is still the residual risk that someone might miss the comment and wrongly assume that the method finishes rounding. This is, however, accepted by the client.\n\n\n\n\n#### Description\n\n\nThe method `LibMathSigned.roundHalfUp(int x, int y)` returns the value `x` rounded up to the base `y`. The method suggests that the result is the rounded value while that’s not actually true. The result for a positive `x` is `x + base/2` and `x - base/2` for negative values. The rounding is not yet finished as this would require a final division by base `y` to manifest the rounding.\n\n\nIt is assumed that the final rounding step is not executed for performance reasons. However, this might easily introduce errors when the caller assumes the result is rounded for base while it is not.\n\n\n#### Examples\n\n\n* `roundHalfUp(-4700, 1000) = -4700` instead of `5000`\n* `roundHalfUp(4700, 1000) = 4700` instead of `5000`\n\n\n**code/contracts/lib/LibMath.sol:L126-L133**\n\n\n\n```\n// ROUND\\_HALF\\_UP rule helper. 0.5 ≈ 1, 0.4 ≈ 0, -0.5 ≈ -1, -0.4 ≈ 0\nfunction roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\n    require(y > 0, \"roundHalfUp only supports y > 0\");\n    if (x >= 0) {\n        return add(x, y / 2);\n    }\n    return sub(x, y / 2);\n}\n\n```\n#### Recommendation\n\n\nWe have verified the current code-base and the callers for `roundHalfUp` are correctly finishing the rounding step. However, it is recommended to finish the rounding within the method or document this behavior to prevent errors caused by code that falsely assumes that the returned value finished rounding.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13735",
      "title": "LibMath - inconsistent assertion text and improve representation of literals with many digits  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe client acknowledges this issue without providing further information.\n\n\n#### Description\n\n\nThe assertion below states that `logE only accepts v <= 1e22 * 1e18` while the argument name is `x`. In addition to that we suggest representing large literals in scientific notation.\n\n\n#### Examples\n\n\n**code/contracts/lib/LibMath.sol:L153-L157**\n\n\n\n```\nfunction wln(int256 x) internal pure returns (int256) {\n    require(x > 0, \"logE of negative number\");\n    require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 \\* 1e18\"); // in order to prevent using safe-math\n    int256 r = 0;\n    uint8 extra\\_digits = longer\\_digits - fixed\\_digits;\n\n```\n#### Recommendation\n\n\nUpdate the inconsistent assertion text `v` -> `x` and represent large literals in [scientific notation](https://solidity.readthedocs.io/en/latest/types.html#rational-and-integer-literals) as they are otherwise difficult to read and review.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13734",
      "title": "LibMath - Inaccurate declaration of _UINT256_MAX ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by renaming `_UINT256_MAX` to `_POSITIVE_INT256_MAX`.\n\n\n#### Description\n\n\n`LibMathUnsigned` declares `_UINT256_MAX` as `2^255-1` while this value actually represents `_INT256_MAX`. This appears to just be a naming issue.\n\n\n#### Examples\n\n\n(`UINT256_MAX/2-1 => pos INT256_MAX`; `2**256/2-1==2**255-1`)\n\n\n**code/contracts/lib/LibMath.sol:L228-L230**\n\n\n\n```\nlibrary LibMathUnsigned {\n    uint256 private constant \\_WAD = 10\\*\\*18;\n    uint256 private constant \\_UINT256\\_MAX = 2\\*\\*255 - 1;\n\n```\n#### Recommendation\n\n\nRename `_UINT256_MAX` to `_INT256MAX` or `_SIGNED_INT256MAX`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13733",
      "title": "Exchange - OrderStatus is never used ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was resolved by removing the unused code.\n\n\n#### Description\n\n\nThe enum `OrderStatus` is declared but never used.\n\n\n#### Examples\n\n\n**code/contracts/exchange/Exchange.sol:L20-L20**\n\n\n\n```\nenum OrderStatus {EXPIRED, CANCELLED, FILLABLE, FULLY\\_FILLED}\n\n```\n#### Recommendation\n\n\nRemove unused code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13732",
      "title": "Unused Imports ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by removing the listed imports.\n\n\n#### Description\n\n\nThe following source units are imported but not referenced in the contract:\n\n\n#### Examples\n\n\n**code/contracts/perpetual/Perpetual.sol:L4-L5**\n\n\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n```\n**code/contracts/perpetual/Perpetual.sol:L14-L15**\n\n\n\n```\nimport \"../interface/IPriceFeeder.sol\";\nimport \"../interface/IGlobalConfig.sol\";\n\n```\n**code/contracts/token/ShareToken.sol:L5-L5**\n\n\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\n\n```\n**code/contracts/token/ShareToken.sol:L3-L3**\n\n\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n```\n#### Recommendation\n\n\nCheck all imports and remove all unused/unreferenced and unnecessary imports.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13731",
      "title": "Perpetual - beginGlobalSettlement can be called multiple times  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe client addressed this issue with the following statement:\n\n\n\n> \n> Acknowledged. It sill can be call multiple times to correct the settlement price. Voting and pausemay improve the situation.When pause, no liquidation which may leading to losing position happens event in theemergency mode.\n> \n> \n> \n\n\n`beginGlobalSettlement` can still be called multiple times.\n\n\n\n\n#### Description\n\n\nThe system can be put into emergency mode by an admin calling `beginGlobalSettlement` and providing a fixed `settlementPrice`. The method can be invoked even when the contract is already in `SETTLING` (emergency) mode, allowing an admin to selectively adjust the settlement price again. This does not seem to be the intended behavior as calling the method again re-sets the status to `SETTLING`. Furthermore, it may affect users' behavior during the SETTLING phase.\n\n\n#### Examples\n\n\n**code/contracts/perpetual/PerpetualGovernance.sol:L96-L101**\n\n\n\n```\nfunction beginGlobalSettlement(uint256 price) public onlyWhitelistAdmin {\n    require(status != LibTypes.Status.SETTLED, \"already settled\");\n    settlementPrice = price;\n    status = LibTypes.Status.SETTLING;\n    emit BeginGlobalSettlement(price);\n}\n\n```\n#### Recommendation\n\n\n* Emergency mode should only be allowed to be set once",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13730",
      "title": "AMM - Unchecked return value in ShareToken.mint  Pending",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by adding checks to `mintShareTokenTo` verifying its return value. In addition, the signature for `ShareToken.burn` was changed to also return an error indicator. The assessment team would like to note that this deviates from the openzeppelin implementation which (a) does not return an error indication but throws instead, (b) burns the callers token on calls to `burn` while this implementation more behaves like a `burnFrom`.\n\n\n#### Description\n\n\n`ShareToken` is an extension of the Openzeppelin [ERC20Mintable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/token/ERC20/ERC20Mintable.sol#L20-L23) pattern which exposes a method called `mint()` that allows accounts owning the minter role to mint new tokens. The return value of `ShareToken.mint()` is not checked.\n\n\nSince the ERC20 standard does not define whether this method should return a value or revert it may be problematic to assume that all tokens revert. If, for example, an implementation is used that does not revert on error but returns a boolean error indicator instead the caller might falsely continue without the token minted.\n\n\nWe would like to note that the functionality is intended to be used with the provided `ShareToken` and therefore the contract is safe to use assuming `ERC20Mintable.mint` reverts on error. The issue arises if the system is used with a different `ShareToken` implementation that is not implemented in the same way.\n\n\n#### Examples\n\n\n* Openzeppelin implementation\n\n\n\n```\nfunction mint(address account, uint256 amount) public onlyMinter returns (bool) {\n    \\_mint(account, amount);\n    return true;\n}\n\n```\n* Call with unchecked return value\n\n\n**code/contracts/liquidity/AMM.sol:L499-L502**\n\n\n\n```\n\nfunction mintShareTokenTo(address guy, uint256 amount) internal {\n    shareToken.mint(guy, amount);\n}\n\n```\n#### Recommendation\n\n\nConsider wrapping the `mint` statement in a `require` clause, however, this way only tokens that are returning a boolean error indicator are supported. Document the specification requirements for the `ShareToken` and clearly state if the token is expected to revert or return an error indicator.\n\n\nIt should also be documented that the Token exposes a `burn` method that does not adhere to the Openzeppelin `ERC20Burnable` implementation. The `ERC20Burnable` import is unused as noted in [issue 6.23](#unused-imports).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13729",
      "title": "Perpetual - The specified decimals for the collateral may not reflect the token’s actual decimals  Acknowledged",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThe client acknowledges this issue without providing further information.\n\n\n#### Description\n\n\nWhen initializing the `Perpetual` contract, the deployer can decide to use either `ETH`, or an `ERC20`-compliant collateral. In the latter case, the deployer must provide a nonzero address for the token, as well as the number of `decimals` used by the token:\n\n\n**code/contracts/perpetual/Collateral.sol:L28-L34**\n\n\n\n```\nconstructor(address \\_collateral, uint256 decimals) public {\n    require(decimals <= MAX\\_DECIMALS, \"decimals out of range\");\n    require(\\_collateral != address(0x0) || (\\_collateral == address(0x0) && decimals == 18), \"invalid decimals\");\n\n    collateral = \\_collateral;\n    scaler = (decimals == MAX\\_DECIMALS ? 1 : 10\\*\\*(MAX\\_DECIMALS - decimals)).toInt256();\n}\n\n```\nThe provided `decimals` value is not checked for validity and can differ from the actual token’s decimals.\n\n\n#### Recommendation\n\n\nEnsure to establish documentation that makes users aware of the fact that the decimals configured are not enforced to match the actual tokens decimals. This is to allow users to audit the system configuration and decide whether they want to participate in it.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13728",
      "title": "Perpetual - Variable shadowing in constructor ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by following the recommendation.\n\n\n#### Description\n\n\n`Perpetual` inherits from `PerpetualGovernance` and `Collateral`, which declare state variables that are shadowed in the `Perpetual` constructor.\n\n\n#### Examples\n\n\n* Local constructor argument shadows `PerpetualGovernance.globalConfig`, `PerpetualGovernance.devAddress`, `Collateral.collateral`\n\n\nNote: Confusing name: `Collateral` is an inherited contract and a state variable.\n\n\n**code/contracts/perpetual/Perpetual.sol:L34-L41**\n\n\n\n```\nconstructor(address globalConfig, address devAddress, address collateral, uint256 collateralDecimals)\n    public\n    Position(collateral, collateralDecimals)\n{\n    setGovernanceAddress(\"globalConfig\", globalConfig);\n    setGovernanceAddress(\"dev\", devAddress);\n    emit CreatePerpetual();\n}\n\n```\n#### Recommendation\n\n\nRename the parameter or state variable.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13727",
      "title": "AMM - ONE_WAD_U is never used ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis issue is resolved by removing `ONE_WAD_U`. The assessment team would like to note that the code-base still directly hardcodes one WAD as `10**18` in `PerpetualGovernance` and `AMMGovernance`.\n\n\n#### Description\n\n\nThe const `ONE_WAD_U` is declared but never used. Avoid re-declaring the same constants in multiple source-units (and unit-test cases) as this will be hard to maintain.\n\n\n#### Examples\n\n\n**code/contracts/liquidity/AMM.sol:L17-L17**\n\n\n\n```\nuint256 private constant ONE\\_WAD\\_U = 10\\*\\*18;\n\n```\n#### Recommendation\n\n\nRemove unused code. Import the value from a shared resource. E.g.`ONE_WAD` is declared multiple times in `LibMathSigned`, `LibMathUnsigned`, `AMM`, hardcoded in checks in `PerpetualGovernance.setGovernanceParameter`, `AMMGovernance.setGovernanceParameter`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13726",
      "title": "Outdated solidity version and floating pragma  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by removing the floating pragma and fixing the compiler version to v0.5.15. The assessment team would like to note, that the latest `0.5.x` release of solidity is [0.5.17](https://github.com/ethereum/solidity/releases/tag/v0.5.17) with 0.5.16 addressing an ABIEncoder issue.\n\n\n#### Description\n\n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues (see also <https://github.com/ethereum/solidity/releases>) that affect the current compiler version.\n\n\nThe codebase specifies a floating version of `^0.5.2` and makes use of the experimental feature `ABIEncoderV2`.\n\n\nIt should be noted, that `ABIEncoderV2` was subject to multiple bug-fixes up until the latest `0.6.x`version and contracts compiled with earlier versions are - for example - susceptible to the following issues:\n\n\n* ImplicitConstructorCallvalueCheck\n* TupleAssignmentMultiStackSlotComponents\n* MemoryArrayCreationOverflow\n* privateCanBeOverridden\n* YulOptimizerRedundantAssignmentBreakContinue0.5\n* ABIEncoderV2CalldataStructsWithStaticallySizedAndDynamicallyEncodedMembers\n* SignedArrayStorageCopy\n* ABIEncoderV2StorageArrayWithMultiSlotElement\n* DynamicConstructorArgumentsClippedABIV2\n\n\n#### Examples\n\n\nCodebase declares compiler version `^0.5.2`:\n\n\n**code/contracts/liquidity/AMM.sol:L1-L2**\n\n\n\n```\npragma solidity ^0.5.2;\npragma experimental ABIEncoderV2; // to enable structure-type parameters\n\n```\nAccording to etherscan.io, the currently deployed main-net `AMM` contract is compiled with solidity version `0.5.8`:\n\n\n<https://etherscan.io/address/0xb95B9fb0539Ec84DeD2855Ed1C9C686Af9A4e8b3#code>\n\n\n#### Recommendation\n\n\nIt is recommended to settle on the latest stable 0.6.x or 0.5.x version of the Solidity compiler and lock the pragma version to a specifically tested compiler release.",
      "summary": "\nThis bug report is about a codebase that had an outdated compiler version and was using the experimental feature ABIEncoderV2. This could lead to multiple bugs and issues as the latest 0.5.x release of solidity is 0.5.17 and 0.5.16 addresses an ABIEncoder issue. The codebase specified a floating version of ^0.5.2 and made use of the ABIEncoderV2 feature. \n\nThe bug was addressed by removing the floating pragma and fixing the compiler version to v0.5.15. It is recommended to settle on the latest stable 0.6.x or 0.5.x version of the Solidity compiler and lock the pragma version to a specifically tested compiler release. This will ensure that the codebase is not subject to any potential bugs and issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13725",
      "title": "LibMathSigned - wpowi returns an invalid result for a negative exponent  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by requiring that `n` is a positive signed integer ([here](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibMath.sol#L121)). The method is still lacking proper natspec documentation outlining expected argument types and valid ranges. The client chose not to implement a check to detect the case where a user accidentally provides `n`  in WAD.\n\n\n#### Description\n\n\n`LibMathSigned.wpowi(x,n)` calculates Wad value `x` (base) to the power of `n` (exponent). The exponent is declared as a signed int, however, the method returns wrong results when calculating `x ^(-n)`.\n\n\nThe comment for the `wpowi` method suggests that `n` is a normal integer instead of a Wad-denominated value. This, however, is not being enforced.\n\n\n#### Examples\n\n\n* `LibMathSigned.wpowi(8000000000000000000, 2) = 64000000000000000000`\n* (wrong) `LibMathSigned.wpowi(8000000000000000000, -2) = 64000000000000000000`\n\n\n**code/contracts/lib/LibMath.sol:L103-L116**\n\n\n\n```\n// x ^ n\n// NOTE: n is a normal integer, do not shift 18 decimals\n// solium-disable-next-line security/no-assign-params\nfunction wpowi(int256 x, int256 n) internal pure returns (int256 z) {\n    z = n % 2 != 0 ? x : \\_WAD;\n\n    for (n /= 2; n != 0; n /= 2) {\n        x = wmul(x, x);\n\n        if (n % 2 != 0) {\n            z = wmul(z, x);\n        }\n    }\n}\n\n```\n#### Recommendation\n\n\nMake `wpowi` support negative exponents or use the proper type for `n` (`uint`) and reject negative values.\n\n\nEnforce that the exponent bounds are within sane ranges and less than a Wad to detect potential misuse where someone accidentally provides a Wad value as `n`.\n\n\nAdd positive and negative unit-tests to fully cover this functionality.",
      "summary": "\nThe `LibMathSigned.wpowi(x,n)` method calculates Wad value `x` (base) to the power of `n` (exponent). The exponent is declared as a signed int, however, the method returns wrong results when calculating `x ^(-n)`. To resolve this issue, the code was updated to require that `n` is a positive signed integer. The client chose not to implement a check to detect the case where a user accidentally provides `n` in WAD. It is recommended that `wpowi` support negative exponents or use the proper type for `n` (`uint`) and reject negative values. Additionally, bounds should be enforced within sane ranges and less than a Wad to detect potential misuse. Finally, positive and negative unit-tests should be added to fully cover this functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13724",
      "title": "Exchange - validateOrderParam does not check against SUPPORTED_ORDER_VERSION ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was resolved by checking against `SUPPORTED_ORDER_VERSION` instead of the hardcoded value `2`.\n\n\n#### Description\n\n\n`validateOrderParam` verifies the signature and version of a provided order. Instead of checking against the contract constant `SUPPORTED_ORDER_VERSION` it, however, checks against a hardcoded version `2` in the method itself.\n\n\nThis might be a problem if `SUPPORTED_ORDER_VERSION` is seen as the configuration parameter for the allowed version. Changing it would not change the allowed order version for `validateOrderParam` as this constant literal is never used.\n\n\nAt the time of this audit, however, the `SUPPORTED_ORDER_VERSION` value equals the hardcoded value in the `validateOrderParam` method.\n\n\n#### Examples\n\n\n**code/contracts/exchange/Exchange.sol:L155-L170**\n\n\n\n```\nfunction validateOrderParam(IPerpetual perpetual, LibOrder.OrderParam memory orderParam)\n    internal\n    view\n    returns (bytes32)\n{\n    address broker = perpetual.currentBroker(orderParam.trader);\n    require(broker == msg.sender, \"invalid broker\");\n    require(orderParam.getOrderVersion() == 2, \"unsupported version\");\n    require(orderParam.getExpiredAt() >= block.timestamp, \"order expired\");\n\n    bytes32 orderHash = orderParam.getOrderHash(address(perpetual), broker);\n    require(orderParam.signature.isValidSignature(orderHash, orderParam.trader), \"invalid signature\");\n    require(filled[orderHash] < orderParam.amount, \"fullfilled order\");\n\n    return orderHash;\n}\n\n```\n#### Recommendation\n\n\nCheck against `SUPPORTED_ORDER_VERSION` instead of the hardcoded value `2`.",
      "summary": "\nThis bug report is about the `validateOrderParam` function in the Exchange.sol contract, which verifies the signature and version of a provided order. Instead of checking against the contract constant `SUPPORTED_ORDER_VERSION`, it was found to check against a hardcoded version `2` in the method itself. This could be a problem if `SUPPORTED_ORDER_VERSION` is seen as the configuration parameter for the allowed version, as changing it would not change the allowed order version for `validateOrderParam`. \n\nAt the time of the audit, however, the `SUPPORTED_ORDER_VERSION` value equaled the hardcoded value in the `validateOrderParam` method. The recommendation is to check against `SUPPORTED_ORDER_VERSION` instead of the hardcoded value `2`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13723",
      "title": "Signed data may be usable cross-chain ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by adding the `chainId` to the [order data](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibOrder.sol#L43) and verifying it as part of `validateOrderParam`. Additional checks were added to `LibSignature` to ensure `s`, `v`, and the result of `ecrecover()` are within valid bounds.\n\n\n#### Description\n\n\nSigned order data may be re-usable cross-chain as the chain-id is not explicitly part of the signed data.\n\n\nIt is also recommended to further harden the signature verification and validate that `v` and `s` are within expected bounds. `ecrecover()` returns `0x0` to indicate an error condition, therefore, a `signerAddress` or `recovered` address of `0x0` should explicitly be disallowed.\n\n\n#### Examples\n\n\nThe signed order data currently includes the EIP712 Domain Name `Mai Protocol` and the following information:\n\n\n**code/contracts/lib/LibOrder.sol:L23-L48**\n\n\n\n```\nstruct Order {\n    address trader;\n    address broker;\n    address perpetual;\n    uint256 amount;\n    uint256 price;\n    /\\*\\*\n \\* Data contains the following values packed into 32 bytes\n \\* ╔════════════════════╤═══════════════════════════════════════════════════════════╗\n \\* ║ │ length(bytes) desc ║\n \\* ╟────────────────────┼───────────────────────────────────────────────────────────╢\n \\* ║ version │ 1 order version ║\n \\* ║ side │ 1 0: buy (long), 1: sell (short) ║\n \\* ║ isMarketOrder │ 1 0: limitOrder, 1: marketOrder ║\n \\* ║ expiredAt │ 5 order expiration time in seconds ║\n \\* ║ asMakerFeeRate │ 2 maker fee rate (base 100,000) ║\n \\* ║ asTakerFeeRate │ 2 taker fee rate (base 100,000) ║\n \\* ║ (d) makerRebateRate│ 2 rebate rate for maker (base 100) ║\n \\* ║ salt │ 8 salt ║\n \\* ║ isMakerOnly │ 1 is maker only ║\n \\* ║ isInversed │ 1 is inversed contract ║\n \\* ║ │ 8 reserved ║\n \\* ╚════════════════════╧═══════════════════════════════════════════════════════════╝\n \\*/\n    bytes32 data;\n}\n\n```\nSignature verification:\n\n\n**code/contracts/lib/LibSignature.sol:L24-L47**\n\n\n\n```\nfunction isValidSignature(OrderSignature memory signature, bytes32 hash, address signerAddress)\n    internal\n    pure\n    returns (bool)\n{\n    uint8 method = uint8(signature.config[1]);\n    address recovered;\n    uint8 v = uint8(signature.config[0]);\n\n    if (method == uint8(SignatureMethod.ETH\\_SIGN)) {\n        recovered = ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\n            v,\n            signature.r,\n            signature.s\n        );\n    } else if (method == uint8(SignatureMethod.EIP712)) {\n        recovered = ecrecover(hash, v, signature.r, signature.s);\n    } else {\n        revert(\"invalid sign method\");\n    }\n\n    return signerAddress == recovered;\n}\n\n```\n#### Recommendation\n\n\n* Include the `chain-id` in the signature to avoid cross-chain validity of signatures\n* verify `s` is within valid bounds to avoid signature malleability\n\n\n\n```\nif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert(\"ECDSA: invalid signature 's' value\");\n }\n\n```\n* verify `v` is within valid bounds\n\n\n\n```\nif (v != 27 && v != 28) {\n     revert(\"ECDSA: invalid signature 'v' value\");\n}\n\n```\n* return invalid if the result of `ecrecover()` is `0x0`",
      "summary": "\nThis bug report is about the issue of signed order data being re-usable cross-chain as the chain-id is not explicitly part of the signed data. The issue was addressed by adding the chainId to the order data and verifying it as part of validateOrderParam. Additional checks were added to LibSignature to ensure s, v, and the result of ecrecover() are within valid bounds. \n\nThe signed order data includes the EIP712 Domain Name ‘Mai Protocol’ and the following information: version, side, isMarketOrder, expiredAt, asMakerFeeRate, asTakerFeeRate, makerRebateRate, salt, isMakerOnly, and isInversed. \n\nThe recommendation to avoid cross-chain validity of signatures is to include the chain-id in the signature. To avoid signature malleability, verify s is within valid bounds and v is within valid bounds. If the result of ecrecover() is 0x0, return invalid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13722",
      "title": "Perpetual - Administrators can put the system into emergency mode indefinitely  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe client provided the following statement addressing the issue:\n\n\n\n> \n> It should be solved by voting. Moreover, we add two roles who is able to disable withdrawing /pause the system.\n> \n> \n> \n\n\nThe duration of the emergency phase is still unrestricted.\n\n\n\n\n#### Description\n\n\nThere is no limitation on how long an administrator can put the `Perpetual` contract into emergency mode. Users cannot trade or withdraw funds in emergency mode and are effectively locked out until the admin chooses to put the contract in `SETTLED` mode.\n\n\n#### Examples\n\n\n**code/contracts/perpetual/PerpetualGovernance.sol:L96-L101**\n\n\n\n```\nfunction beginGlobalSettlement(uint256 price) public onlyWhitelistAdmin {\n    require(status != LibTypes.Status.SETTLED, \"already settled\");\n    settlementPrice = price;\n    status = LibTypes.Status.SETTLING;\n    emit BeginGlobalSettlement(price);\n}\n\n```\n**code/contracts/perpetual/Perpetual.sol:L146-L154**\n\n\n\n```\nfunction endGlobalSettlement() public onlyWhitelistAdmin {\n    require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\n\n    address guy = address(amm.perpetualProxy());\n    settleFor(guy);\n    status = LibTypes.Status.SETTLED;\n\n    emit EndGlobalSettlement();\n}\n\n```\n#### Recommendation\n\n\n* Set a time-lock when entering emergency mode that allows anyone to set the system to `SETTLED` after a fixed amount of time.",
      "summary": "\nThis bug report is about an issue with the `Perpetual` contract, where there is no limitation on how long an administrator can put the contract into emergency mode. This means that users cannot trade or withdraw funds in emergency mode and are effectively locked out until the admin chooses to put the contract in `SETTLED` mode. The client suggested that the issue should be solved by voting and adding two roles who can disable withdrawing/pause the system. The report includes code examples from the `PerpetualGovernance.sol` and `Perpetual.sol` contracts, and the recommendation is to set a time-lock when entering emergency mode, allowing anyone to set the system to `SETTLED` after a fixed amount of time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13721",
      "title": "AMM - Liquidity pools can be initialized with zero collateral  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by checking that `amount > 0`. The assessment team would like to note that;\n\n\n* The client chose to verify that `amount` is non-zero when calling `createPool` instead of requiring a minimum of a `lotSize`.\n* The client did not address the issues about `removeLiquidity` and `addLiquidity` allowing to remove and add zero liquidity.\n\n\n\n\n#### Description\n\n\n`createPool` can be initialized with `amount == 0`. Because a subsequent call to `initFunding` can only happen once, the contract is now initialized with a zero size pool that does not allow any liquidity to be added.\n\n\nTrying to recover by calling `createPool` again fails as the funding state is already `initialized`. The [specification](https://github.com/mcdexio/documents/blob/84ddfa77e2bb25db7366b01fc0133cd66122c675/en/perpetual-interfaces.md) also states the following about `createPool`:\n\n\n\n> \n> Open asset pool by deposit to AMM. Only available when pool is empty.\n> \n> \n> \n\n\nThis is inaccurate, as `createPool` can only be called once due to a check in `initFunding`, but this call may leave the pool empty.\n\n\nFurthermore, the contract’s liquidity management functionality (`addLiquidity` and `removeLiquidity`) allows adding zero liquidity (`amount == 0`) and removing zero shares (`shareAmount == 0`). As these actions do not change the liquidity of the pool, they should be rejected.\n\n\n#### Recommendation\n\n\n* Require a minimum amount `lotSize` to be provided when creating a Pool and adding liquidity via `addLiquidity`\n* Require a minimum amount of shares to be provided when removing liquidity via `removeLiquidity`",
      "summary": "\nThis bug report concerns the `createPool` function in a contract, which allows it to be initialized with amount equal to zero. This is an issue because a subsequent call to `initFunding` can only happen once, and the contract is now initialized with a zero size pool that does not allow any liquidity to be added. The specification for `createPool` is inaccurate, as it can only be called once due to a check in `initFunding`, but this call may leave the pool empty. Additionally, the contract's liquidity management functionality (`addLiquidity` and `removeLiquidity`) allows adding zero liquidity (`amount == 0`) and removing zero shares (`shareAmount == 0`).\n\nThe issue was addressed by checking that `amount > 0`. The assessment team proposed two recommendations to prevent this issue in the future: requiring a minimum amount `lotSize` to be provided when creating a Pool and adding liquidity via `addLiquidity`, and requiring a minimum amount of shares to be provided when removing liquidity via `removeLiquidity`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13720",
      "title": "Oracle - Unchecked oracle response timestamp and integer over/underflow ✓ Fixed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was resolved by following the recommendations,\n\n\n* using `LibMath` for arithmetic operations to guard against over/underflows,\n* checking that `newPrice != 0`\n* verifying that the timestamp is within a configurable range,\n* duplicating the code and combining the reverse oracle into one contract\n\n\nThe assessment team would like to note that the acceptable time-frame for answers can vary, the price may be outdated, and it is totally up to the deployer to configure the acceptable timeout. The timeout can be changed by the account deploying the oracle feed without a delay allowing the price-feed owner to arbitrarily make calls to `AMM.indexPrice` fail (front-running). A timeout may be set to an arbitrarily high value to bypass the check. User’s of the system are advised to validate that they trust the account operating the feeder and that the timeout is set correctly.\n\n\n\n\n#### Description\n\n\nThe external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the AMM. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.\n\n\nEnsuring that unexpected oracle return values are properly handled will reduce reliance on off-chain components and increase the resiliency of the smart contract system that depends on them.\n\n\n#### Examples\n\n\n1. The `ChainlinkAdapter` and `InversedChainlinkAdapter` take the oracle’s (int256) `latestAnswer` and convert the result using `chainlinkDecimalsAdapter`. This arithmetic operation can underflow/overflow if the Oracle provides a large enough answer:\n\n\n**code/contracts/oracle/ChainlinkAdapter.sol:L10-L19**\n\n\n\n```\nint256 public constant chainlinkDecimalsAdapter = 10\\*\\*10;\n\nconstructor(address \\_feeder) public {\n    feeder = IChainlinkFeeder(\\_feeder);\n}\n\nfunction price() public view returns (uint256 newPrice, uint256 timestamp) {\n    newPrice = (feeder.latestAnswer() \\* chainlinkDecimalsAdapter).toUint256();\n    timestamp = feeder.latestTimestamp();\n}\n\n```\n**code/contracts/oracle/InversedChainlinkAdapter.sol:L11-L20**\n\n\n\n```\nint256 public constant chainlinkDecimalsAdapter = 10\\*\\*10;\n\nconstructor(address \\_feeder) public {\n    feeder = IChainlinkFeeder(\\_feeder);\n}\n\nfunction price() public view returns (uint256 newPrice, uint256 timestamp) {\n    newPrice = ONE.wdiv(feeder.latestAnswer() \\* chainlinkDecimalsAdapter).toUint256();\n    timestamp = feeder.latestTimestamp();\n}\n\n```\n2. The oracle provides a timestamp for the `latestAnswer` that is not validated and may lead to old oracle timestamps being accepted (e.g. caused by congestion on the blockchain or a directed censorship attack).\n\n\n**code/contracts/oracle/InversedChainlinkAdapter.sol:L19-L20**\n\n\n\n```\n    timestamp = feeder.latestTimestamp();\n}\n\n```\n#### Recommendation\n\n\n* Use `SafeMath` for mathematical computations\n* Verify `latestAnswer` is within valid bounds (`!=0`)\n* Verify `latestTimestamp` is within accepted bounds (not in the future, was updated within a reasonable amount of time)\n* Deduplicate code by combining both Adapters into one as the only difference is that the `InversedChainlinkAdapter` returns `ONE.wdiv(price)`.",
      "summary": "\nA bug was reported in the Chainlink oracle, which provides index price information to the system. This bug can lead to outdated data being fed to the index price calculations of the AMM, resulting in crippled on-chain systems. To resolve the bug, the assessment team recommended the use of `LibMath` for arithmetic operations to guard against over/underflows, checking that `newPrice != 0`, verifying that the timestamp is within a configurable range, and deduplicating the code by combining both Adapters into one. The timeout can be changed by the account deploying the oracle feed without a delay allowing the price-feed owner to arbitrarily make calls to `AMM.indexPrice` fail. Users of the system should validate that they trust the account operating the feeder and that the timeout is set correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13719",
      "title": "AMM - Liquidity provider may lose up to lotSize when removing liquidity  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe client acknowledges this issue without providing further information.\n\n\n#### Description\n\n\nWhen removing liquidity, the amount of collateral received is calculated from the `shareAmount` (ShareToken) of the liquidity provider. The liquidity removal process registers a trade on the amount, with the liquidity provider and `AMM` taking opposite sides. Because trading only accepts multiple of the `lotSize`, the leftover is discarded. The amount discarded may be up to `lotSize - 1`.\n\n\nThe expectation is that this value should not be too high, but as `lotSize` can be set to arbitrary values by an admin, it is possible that this step discards significant value. Additionally, see [issue 6.6](#unpredictable-behavior-due-to-front-running-or-general-bad-timing) for how this can be exploited by an admin.\n\n\nNote that similar behavior is present in `Perpetual.liquidateFrom`, where the `liquidatableAmount` calculated undergoes a similar modulo operation:\n\n\n**code/contracts/perpetual/Perpetual.sol:L277-L278**\n\n\n\n```\nuint256 liquidatableAmount = totalPositionSize.sub(totalPositionSize.mod(governance.lotSize));\nliquidationAmount = liquidationAmount.ceil(governance.lotSize).min(maxAmount).min(liquidatableAmount);\n\n```\n#### Examples\n\n\n* `lotSize` can arbitrarily be set up to `pos_int256_max` as long as `tradingLotSize % lotSize == 0`\n\n\n**code/contracts/perpetual/PerpetualGovernance.sol:L61-L69**\n\n\n\n```\n} else if (key == \"lotSize\") {\n    require(\n        governance.tradingLotSize == 0 || governance.tradingLotSize.mod(value.toUint256()) == 0,\n        \"require tls % ls == 0\"\n    );\n    governance.lotSize = value.toUint256();\n} else if (key == \"tradingLotSize\") {\n    require(governance.lotSize == 0 || value.toUint256().mod(governance.lotSize) == 0, \"require tls % ls == 0\");\n    governance.tradingLotSize = value.toUint256();\n\n```\n* `amount` is derived from `shareAmount` rounded down to the next multiple of the `lotSize`. The leftover is discarded.\n\n\n**code/contracts/liquidity/AMM.sol:L289-L294**\n\n\n\n```\nuint256 amount = shareAmount.wmul(oldPoolPositionSize).wdiv(shareToken.totalSupply());\namount = amount.sub(amount.mod(perpetualProxy.lotSize()));\n\nperpetualProxy.transferBalanceOut(trader, price.wmul(amount).mul(2));\nburnShareTokenFrom(trader, shareAmount);\nuint256 opened = perpetualProxy.trade(trader, LibTypes.Side.LONG, price, amount);\n\n```\n#### Recommendation\n\n\n* Ensure that documentation makes users aware of the fact that they may lose up to `lotsize-1` in value.\n* Alternatively, track accrued value and permit trades on values that exceed `lotSize`. Note that this may add significant complexity.\n* Ensure that similar system behavior, like the `liquidatableAmount` calculated in `Perpetual.liquidateFrom`, is also documented and communicated clearly to users.",
      "summary": "\nThis bug report is about the issue with removing liquidity from the `AMM` (automated market maker). The issue is that when removing liquidity, the amount of collateral received is calculated from the `shareAmount` (ShareToken) of the liquidity provider. The liquidity removal process registers a trade on the amount, with the liquidity provider and `AMM` taking opposite sides. Because trading only accepts multiple of the `lotSize`, the leftover is discarded. This can cause the user to lose up to `lotSize - 1` in value. \n\nThe issue is that the `lotSize` can be set to arbitrary values by an admin, which can lead to significant value being discarded. Additionally, this may be exploited by an admin. Similar behavior is present in `Perpetual.liquidateFrom`, where the `liquidatableAmount` calculated undergoes a similar modulo operation.\n\nThe recommendation is to ensure that documentation makes users aware of the fact that they may lose up to `lotsize-1` in value. Alternatively, track accrued value and permit trades on values that exceed `lotSize`. Note that this may add significant complexity. Additionally, ensure that similar system behavior, like the `liquidatableAmount` calculated in `Perpetual.liquidateFrom`, is also documented and communicated clearly to users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13718",
      "title": "Exchange - insufficient input validation in matchOrders  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by following the recommendation to verify that `amounts.length > 0 && makerOrderParams.length == amounts.length`. However, the code does not abort if one of the `amounts` is zero which should never happen and therefore raise an exception due to it likely being an erroneous call. Additionally, the method now enforces that only a broker can interact with the interface.\n\n\n#### Description\n\n\n`matchOrders` does not check that that the sender has provided the same number of `amounts` as `makerOrderParams`. When fewer `amounts` exist than `makerOrderParams`, the method will revert because of an out-of-bounds array access. When fewer `makerOrderParams` exist than `amounts`, the method will succeed, and the additional values in `amounts` will be ignored.\n\n\nAdditionally, the method allows the sender to provide no `makerOrderParams` at all, resulting in no state changes.\n\n\n`matchOrders` also does not reject trades with an amount set to zero. Such orders should be rejected because they do not comply with the minimum `tradingLotSize` configured for the system. As a side-effect, events may be emitted for zero-amount trades and unexpected state changes may occur.\n\n\n#### Examples\n\n\n**code/contracts/exchange/Exchange.sol:L34-L39**\n\n\n\n```\nfunction matchOrders(\n    LibOrder.OrderParam memory takerOrderParam,\n    LibOrder.OrderParam[] memory makerOrderParams,\n    address \\_perpetual,\n    uint256[] memory amounts\n) public {\n\n```\n**code/contracts/exchange/Exchange.sol:L113-L113**\n\n\n\n```\nfunction matchOrderWithAMM(LibOrder.OrderParam memory takerOrderParam, address \\_perpetual, uint256 amount) public {\n\n```\n#### Recommendation\n\n\n* Require `makerOrderParams.length > 0 && amounts.length == makerOrderParams.length`\n* Require that `amount` or any of the `amounts[i]` provided to `matchOrders` is `>=tradingLotSize`.",
      "summary": "\nThis bug report describes an issue with the `matchOrders` method in the Exchange.sol contract. The method does not check that the sender has provided the same number of amounts as makerOrderParams. When fewer amounts exist than makerOrderParams, the method will revert due to an out-of-bounds array access. When fewer makerOrderParams exist than amounts, the method will succeed and the additional values in amounts will be ignored. Additionally, the method allows the sender to provide no makerOrderParams at all, resulting in no state changes. \n\nThe method also does not reject trades with an amount set to zero, which should be rejected due to the minimum tradingLotSize configured for the system. As a side-effect, events may be emitted for zero-amount trades and unexpected state changes may occur.\n\nIn order to address this issue, the recommendation is to require that makerOrderParams.length > 0 && amounts.length == makerOrderParams.length, and that amount or any of the amounts[i] provided to matchOrders is >=tradingLotSize. Additionally, the method now enforces that only a broker can interact with the interface.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13717",
      "title": "AMM - Amount of collateral spent or shares received may be unpredictable for liquidity provider  Acknowledged",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThe client acknowledges this issue without providing further information or implementing the recommended fixes.\n\n\n#### Description\n\n\nWhen providing liquidity with `addLiquidity()`, the amount of collateral required is based on the current price and the amount of shares received depends on the total amount of shares in circulation. This price can fluctuate at a moment’s notice, making the behavior of the function unpredictable for the user.\n\n\nThe same is true when removing liquidity via `removeLiquidity()`.\n\n\n#### Recommendation\n\n\nUnpredictability can be introduced by someone front-running the transaction, or simply by poor timing. For example, adjustments to global variable configuration by the system admin will directly impact subsequent actions by the user. In order to ensure users know what to expect:\n\n\n* Allow the caller to specify a price limit or maximum amount of collateral to be spent\n* Allow the caller to specify the minimum amount of shares expected to be received",
      "summary": "\nThis bug report is about the unpredictability of the `addLiquidity()` and `removeLiquidity()` functions when providing or removing liquidity in a decentralized finance (DeFi) protocol. The price of the assets in the protocol can fluctuate at any time, making it difficult for users to predict the behavior of the functions. \n\nIn order to make the functions more predictable, the report recommends allowing the caller to specify a price limit or maximum amount of collateral to be spent, and also to specify the minimum amount of shares expected to be received. This will help users to know what to expect when using the functions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13716",
      "title": "AMM - Governance is able to set an invalid alpha value  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by checking that the provided `emaAlpha <= 1 WAD`. This would allow a data smoothing factor of 1 which causes `emaAlpha2` and `emaAlpha2Ln` to go zero which should not be allowed. As outlined in the recommendation, check `0 < α < 1` instead.\n\n\n#### Description\n\n\nAccording to <https://en.wikipedia.org/wiki/Moving_average>\n\n\n\n> \n> The coefficient α represents the degree of weighting decrease, a constant smoothing factor between 0 and 1. A higher α discounts older observations faster.\n> \n> \n> \n\n\nHowever, the code does not check upper bounds. An admin may, therefore, set an invalid alpha that puts `emaAlpha2` out of bounds or negative.\n\n\n#### Examples\n\n\n**code/contracts/liquidity/AMMGovernance.sol:L27-L31**\n\n\n\n```\n} else if (key == \"emaAlpha\") {\n    require(value > 0, \"alpha should be > 0\");\n    governance.emaAlpha = value;\n    emaAlpha2 = 10\\*\\*18 - governance.emaAlpha;\n    emaAlpha2Ln = emaAlpha2.wln();\n\n```\n#### Recommendation\n\n\nEnsure that the system configuration is always within safe bounds. Document expected system variable types and their safe operating ranges. Enforce that bounds are checked every time a value is set. Enforce safe defaults when deploying contracts.\n\n\nEnsure `emaAlpha` is `0 < value < 1 WAD`",
      "summary": "\nThis bug report is about an issue with the code in the `AMMGovernance.sol` contract. The issue is that the code does not check the upper bounds of the coefficient α, which is a constant smoothing factor between 0 and 1. This means that an admin may set an invalid alpha which could cause `emaAlpha2` and `emaAlpha2Ln` to go out of bounds or negative. \n\nThe resolution to this issue was to check that the provided `emaAlpha <= 1 WAD`. This would allow a data smoothing factor of 1 which would prevent `emaAlpha2` and `emaAlpha2Ln` from going out of bounds. The recommendation was to ensure `emaAlpha` is `0 < value < 1 WAD` to keep it within safe bounds. Additionally, the system should document expected system variable types and their safe operating ranges, enforce that bounds are checked every time a value is set, and enforce safe defaults when deploying contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13715",
      "title": "Unpredictable behavior due to front running or general bad timing  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by the client providing the following statement:\n\n\n\n> \n> Not fixed in the perpetual. But later a voting system will take over the administration key. We intent to add a waiting period before voted changes applying.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nIn a number of cases, administrators of contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.\n\n\nSpecifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to unfortunate timing of changes.\n\n\nSome instances of this are more important than others, but in general users of the system should have assurances about the behavior of the action they’re about to take.\n\n\n#### Examples\n\n\nThe deployer of the `PerpetualGovernance`, `AMMGovernance`, and `GlobalConfig` contracts are set as administrators for the contracts through `WhitelistedRole`. The `WhitelistedAdminRole` can whitelist other accounts at any time and allow them to perform actions protected by the `onlyWhitelisted` decorator.\n\n\nUpdating governance and global configuration parameters are not protected by a time-lock and take effect immediately. This, therefore, creates an opportunity for administrators to front-run users on the exchange by changing parameters for orders. It may also allow an administrator to temporarily lift restrictions for themselves (e.g. `withdrawalLockBlockCount`).\n\n\n* `GlobalConfig`\n\t+ `withdrawalLockBlockCount` is queried when applying for withdrawal. This value can be set zero enabling allowing immediate withdrawal.\n\t+ `brokerLockBlockCount` is queried when setting a new broker. This value can e set to zero effectively enabling immediate broker changes.\n\n\n**code/contracts/global/GlobalConfig.sol:L18-L27**\n\n\n\n```\nfunction setGlobalParameter(bytes32 key, uint256 value) public onlyWhitelistAdmin {\n    if (key == \"withdrawalLockBlockCount\") {\n        withdrawalLockBlockCount = value;\n    } else if (key == \"brokerLockBlockCount\") {\n        brokerLockBlockCount = value;\n    } else {\n        revert(\"key not exists\");\n    }\n    emit UpdateGlobalParameter(key, value);\n}\n\n```\n* `PerpetualGovernance`\n\t+ e.g. Admin can front-run specific `matchOrder` calls and set arbitrary dev fees or curve parameters…\n\n\n**code/contracts/perpetual/PerpetualGovernance.sol:L39-L80**\n\n\n\n```\nfunction setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\n    if (key == \"initialMarginRate\") {\n        governance.initialMarginRate = value.toUint256();\n        require(governance.initialMarginRate > 0, \"require im > 0\");\n        require(governance.initialMarginRate < 10\\*\\*18, \"require im < 1\");\n        require(governance.maintenanceMarginRate < governance.initialMarginRate, \"require mm < im\");\n    } else if (key == \"maintenanceMarginRate\") {\n        governance.maintenanceMarginRate = value.toUint256();\n        require(governance.maintenanceMarginRate > 0, \"require mm > 0\");\n        require(governance.maintenanceMarginRate < governance.initialMarginRate, \"require mm < im\");\n        require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, \"require lpr < mm\");\n        require(governance.penaltyFundRate < governance.maintenanceMarginRate, \"require pfr < mm\");\n    } else if (key == \"liquidationPenaltyRate\") {\n        governance.liquidationPenaltyRate = value.toUint256();\n        require(governance.liquidationPenaltyRate < governance.maintenanceMarginRate, \"require lpr < mm\");\n    } else if (key == \"penaltyFundRate\") {\n        governance.penaltyFundRate = value.toUint256();\n        require(governance.penaltyFundRate < governance.maintenanceMarginRate, \"require pfr < mm\");\n    } else if (key == \"takerDevFeeRate\") {\n        governance.takerDevFeeRate = value;\n    } else if (key == \"makerDevFeeRate\") {\n        governance.makerDevFeeRate = value;\n    } else if (key == \"lotSize\") {\n        require(\n            governance.tradingLotSize == 0 || governance.tradingLotSize.mod(value.toUint256()) == 0,\n            \"require tls % ls == 0\"\n        );\n        governance.lotSize = value.toUint256();\n    } else if (key == \"tradingLotSize\") {\n        require(governance.lotSize == 0 || value.toUint256().mod(governance.lotSize) == 0, \"require tls % ls == 0\");\n        governance.tradingLotSize = value.toUint256();\n    } else if (key == \"longSocialLossPerContracts\") {\n        require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\n        socialLossPerContracts[uint256(LibTypes.Side.LONG)] = value;\n    } else if (key == \"shortSocialLossPerContracts\") {\n        require(status == LibTypes.Status.SETTLING, \"wrong perpetual status\");\n        socialLossPerContracts[uint256(LibTypes.Side.SHORT)] = value;\n    } else {\n        revert(\"key not exists\");\n    }\n    emit UpdateGovernanceParameter(key, value);\n}\n\n```\n* Admin can set `devAddress` or even update to a new `amm` and `globalConfig`\n\n\n**code/contracts/perpetual/PerpetualGovernance.sol:L82-L94**\n\n\n\n```\nfunction setGovernanceAddress(bytes32 key, address value) public onlyWhitelistAdmin {\n    require(value != address(0x0), \"invalid address\");\n    if (key == \"dev\") {\n        devAddress = value;\n    } else if (key == \"amm\") {\n        amm = IAMM(value);\n    } else if (key == \"globalConfig\") {\n        globalConfig = IGlobalConfig(value);\n    } else {\n        revert(\"key not exists\");\n    }\n    emit UpdateGovernanceAddress(key, value);\n}\n\n```\n* `AMMGovernance`\n\n\n**code/contracts/liquidity/AMMGovernance.sol:L22-L43**\n\n\n\n```\nfunction setGovernanceParameter(bytes32 key, int256 value) public onlyWhitelistAdmin {\n    if (key == \"poolFeeRate\") {\n        governance.poolFeeRate = value.toUint256();\n    } else if (key == \"poolDevFeeRate\") {\n        governance.poolDevFeeRate = value.toUint256();\n    } else if (key == \"emaAlpha\") {\n        require(value > 0, \"alpha should be > 0\");\n        governance.emaAlpha = value;\n        emaAlpha2 = 10\\*\\*18 - governance.emaAlpha;\n        emaAlpha2Ln = emaAlpha2.wln();\n    } else if (key == \"updatePremiumPrize\") {\n        governance.updatePremiumPrize = value.toUint256();\n    } else if (key == \"markPremiumLimit\") {\n        governance.markPremiumLimit = value;\n    } else if (key == \"fundingDampener\") {\n        governance.fundingDampener = value;\n    } else {\n        revert(\"key not exists\");\n    }\n    emit UpdateGovernanceParameter(key, value);\n}\n\n\n```\n#### Recommendation\n\n\nThe underlying issue is that users of the system can’t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.\n\n\nWe recommend giving the user advance notice of changes with a time lock. For example, make all updates to system parameters or upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period.\n\n\nAdditionally, users should verify the whitelist setup before using the contract system and monitor it for new additions to the whitelist. Documentation should clearly outline what roles are owned by whom to support suitability. Sane parameter bounds should be enforced (e.g. min. disallow block delay of zero )",
      "summary": "\nThis bug report deals with a security issue in a number of contracts, whereby administrators of the contracts can update or upgrade things without warning. This could lead to malicious changes being made just ahead of incoming transactions, or accidental negative effects due to unfortunate timing of changes. It specifically focuses on the `PerpetualGovernance`, `AMMGovernance`, and `GlobalConfig` contracts, which are set as administrators for the contracts through `WhitelistedRole`. \n\nThe recommendation is to give users advance notice of any changes with a time lock, and to have two steps with a mandatory time window between them. This would broadcast to users that a particular change is coming, and then commit that change after a suitable waiting period. Additionally, users should verify the whitelist setup before using the contract system and monitor it for new additions, and documentation should outline what roles are owned by whom. Lastly, sane parameter bounds should be enforced, such as a minimum disallow block delay of zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13714",
      "title": "Perpetual - liquidateFrom should not have public visibility  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue has been resolved by removing the `liquidateFrom` method entirely and refactoring `liquidate`. The method now enforces that `status != LibTypes.Status.SETTLED`. Additionally, the method now checks that `msg.sender!=trader`.\n\n\n#### Description\n\n\n`Perpetual.liquidate` is used to liquidate an account that is “unsafe,” determined by the relative sizes of `marginBalanceWithPrice` and `maintenanceMarginWithPrice`:\n\n\n**code/contracts/perpetual/Perpetual.sol:L248-L253**\n\n\n\n```\n// safe for liquidation\nfunction isSafeWithPrice(address guy, uint256 currentMarkPrice) public returns (bool) {\n    return\n        marginBalanceWithPrice(guy, currentMarkPrice) >=\n        maintenanceMarginWithPrice(guy, currentMarkPrice).toInt256();\n}\n\n```\n`Perpetual.liquidate` allows the caller to assume the liquidated account’s position, as well as a small amount of “penalty collateral.” The steps to liquidate are, roughly:\n\n\n1. Close the liquidated account’s position\n2. Perform a trade on the liquidated assets with the liquidator acting as counter-party\n3. Grant the liquidator a portion of the liquidated assets as a reward. An additional portion is added to the insurance fund.\n4. Handle any losses\n\n\nWe found several issues in `Perpetual.liquidate`:\n\n\n#### Examples\n\n\n`liquidateFrom` has `public` visibility:\n\n\n**code/contracts/perpetual/Perpetual.sol:L270**\n\n\n\n```\nfunction liquidateFrom(address from, address guy, uint256 maxAmount) public returns (uint256, uint256) {\n\n```\nGiven that `liquidate` only calls `liquidateFrom` after checking the current contract’s status, this oversight allows anyone to call `liquidateFrom` during the `SETTLED` stage:\n\n\n**code/contracts/perpetual/Perpetual.sol:L291-L294**\n\n\n\n```\nfunction liquidate(address guy, uint256 maxAmount) public returns (uint256, uint256) {\n    require(status != LibTypes.Status.SETTLED, \"wrong perpetual status\");\n    return liquidateFrom(msg.sender, guy, maxAmount);\n}\n\n```\nAdditionally, directly calling `liquidateFrom` allows anyone to liquidate on behalf of other users, forcing other accounts to assume liquidated positions.\n\n\nFinally, neither `liquidate` nor `liquidateFrom` check that the liquidated account and liquidator are the same. Though the liquidation accounting process is hard to follow, we believe this is unintended and could lead to large errors in internal contract accounting.\n\n\n#### Recommendation\n\n\n* Make `liquidateFrom` an `internal` function\n* In `liquidate` or `liquidateFrom`, check that `msg.sender != guy`",
      "summary": "\nThis bug report is about a function in the Perpetual contract called `liquidate`, which is used to liquidate an account that is \"unsafe\". The function was found to have several issues, including the fact that it did not check that the liquidated account and liquidator were the same, which could lead to errors in the internal contract accounting. The resolution to this bug was to remove the `liquidateFrom` method entirely and refactor `liquidate`. The method now enforces that `status != LibTypes.Status.SETTLED` and also checks that `msg.sender!=trader`. Additionally, the recommendation is to make `liquidateFrom` an `internal` function and to check that `msg.sender != guy` in `liquidate` or `liquidateFrom`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13713",
      "title": "Perpetual - withdrawFromInsuranceFund should check wadAmount instead of rawAmount  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by checking `wadBalance` instead of the `rawAmount` against `insuranceFundBalance`. `withdrawFromProtocol` was renamed to `pushCollateral` which now forwards all gas to the recipient and does not check for `amount==0` by itself anymore (which may be fine because the callers in the current code revision do). It should be noted that the unit-test cases still attempt to provide a `WAD` value instead of the raw token amount.\n\n\n#### Description\n\n\n`withdrawFromInsurance` checks that enough funds are in the insurance fund before allowing withdrawal by an admin by checking the provided `rawAmount <= insuranceFundBalance.toUint256()`. `rawAmount` is the `ETH` (18 digit precision) or collateral token amount (can be less than 18 digit precision) to be withdrawn while `insuranceFundBalance` is a WAD-denominated value (18 digit precision).\n\n\nThe check does not hold if the configured collateral has different precision and may have unwanted consequences, e.g. the withdrawal of more funds than expected.\n\n\nNote: there is another check for `insuranceFundBalance` staying positive after the potential external call to collateral.\n\n\n#### Examples\n\n\n**code/contracts/perpetual/Perpetual.sol:L204-L216**\n\n\n\n```\nfunction withdrawFromInsuranceFund(uint256 rawAmount) public onlyWhitelistAdmin {\n    require(rawAmount > 0, \"invalid amount\");\n    require(insuranceFundBalance > 0, \"insufficient funds\");\n    require(rawAmount <= insuranceFundBalance.toUint256(), \"insufficient funds\");\n\n    int256 wadAmount = toWad(rawAmount);\n    insuranceFundBalance = insuranceFundBalance.sub(wadAmount);\n    withdrawFromProtocol(msg.sender, rawAmount);\n\n    require(insuranceFundBalance >= 0, \"negtive insurance fund\");\n\n    emit UpdateInsuranceFund(insuranceFundBalance);\n}\n\n```\nWhen looking at the test-cases there seems to be a misconception about what unit of amount `withdrawFromInsuranceFund` is taking. For example, the insurance fund withdrawal and deposit are not tested for collateral that specifies a precision that is not 18. The test-cases falsely assume that the input to `withdrawFromInsuranceFund` is a WAD value, while it is taking the collateral’s `rawAmount` which is then converted to a WAD number.\n\n\n**code/test/test\\_perpetual.js:L471-L473**\n\n\n\n```\nawait perpetual.withdrawFromInsuranceFund(toWad(10.111));\nfund = await perpetual.insuranceFundBalance();\nassert.equal(fund.toString(), 0);\n\n```\n#### Recommendation\n\n\nCheck that `require(wadAmount <= insuranceFundBalance.toUint256(), \"insufficient funds\");`, add a test-suite testing the insurance fund with collaterals with different precision and update existing tests that properly provide the expected input to `withdraFromInsurance`.",
      "summary": "\nA bug was found in the code of the `withdrawFromInsurance` function in the Perpetual contract that could lead to the withdrawal of more funds than expected. This was caused by a check that compared the provided `rawAmount` against `insuranceFundBalance` which is a WAD-denominated value with 18 digit precision. This check does not hold if the configured collateral has a different precision. The issue was addressed by checking `wadBalance` instead of the `rawAmount` against `insuranceFundBalance` and renaming `withdrawFromProtocol` to `pushCollateral`. It should also be noted that the unit-test cases still attempt to provide a `WAD` value instead of the raw token amount. To avoid this issue, it is recommended to check that `wadAmount <= insuranceFundBalance.toUint256()`, add a test-suite testing the insurance fund with collaterals with different precision and update existing tests that properly provide the expected input to `withdrawFromInsurance`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13712",
      "title": "Perpetual - withdraw should only be available in NORMAL state  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was resolved by requiring `status == LibTypes.Status.NORMAL`.\n\n\n#### Description\n\n\nAccording to the [specification](https://github.com/mcdexio/documents/blob/0a44d7ec48e09e2d229a3c5b77501235d4de82b3/en/perpetual-interfaces.md) `withdraw` can only be called in `NORMAL` state. However, the implementation allows it to be called in `NORMAL` and `SETTLED` mode.\n\n\n#### Examples\n\n\nWithdraw only checks for `!SETTLING` state which resolves to `NORMAL` and `SETTLED`.\n\n\n**code/contracts/perpetual/Perpetual.sol:L175-L178**\n\n\n\n```\n\nfunction withdraw(uint256 amount) public {\n    withdrawFromAccount(msg.sender, amount);\n}\n\n```\n**code/contracts/perpetual/Perpetual.sol:L156-L169**\n\n\n\n```\nfunction withdrawFromAccount(address payable guy, uint256 amount) private {\n    require(guy != address(0), \"invalid guy\");\n    require(status != LibTypes.Status.SETTLING, \"wrong perpetual status\");\n\n    uint256 currentMarkPrice = markPrice();\n    require(isSafeWithPrice(guy, currentMarkPrice), \"unsafe before withdraw\");\n    remargin(guy, currentMarkPrice);\n    address broker = currentBroker(guy);\n    bool forced = broker == address(amm.perpetualProxy()) || broker == address(0);\n    withdraw(guy, amount, forced);\n\n    require(isSafeWithPrice(guy, currentMarkPrice), \"unsafe after withdraw\");\n    require(availableMarginWithPrice(guy, currentMarkPrice) >= 0, \"withdraw margin\");\n}\n\n```\nIn contrast, `withdrawFor` requires the state to be `NORMAL`:\n\n\n**code/contracts/perpetual/Perpetual.sol:L171-L174**\n\n\n\n```\nfunction withdrawFor(address payable guy, uint256 amount) public onlyWhitelisted {\n    require(status == LibTypes.Status.NORMAL, \"wrong perpetual status\");\n    withdrawFromAccount(guy, amount);\n}\n\n```\n#### Recommendation\n\n\n`withdraw` should only be available in the `NORMAL` operation mode.",
      "summary": "\nThis bug report describes an issue with the implementation of the `withdraw` function in the Perpetual contract. According to the specification, this function can only be called in `NORMAL` state, however, the implementation allows it to be called in both `NORMAL` and `SETTLED` mode. This issue was resolved by requiring `status == LibTypes.Status.NORMAL` for the `withdraw` function. The `withdrawFor` function already requires the state to be `NORMAL` and it is recommended that `withdraw` should also only be available in the `NORMAL` operation mode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13711",
      "title": "AMM - funding can be called in emergency mode  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue was addressed by silently skipping `funding()` if the status is not `NORMAL`.\n\n\n#### Description\n\n\nThe [specification](https://github.com/mcdexio/documents/blob/b94b98a806d29d7ce135e1011b094868e07eeb5d/en/internal-amm.md#funding) for `AMM.funding()` states `isEmergency==FALSE` as a requirement. However, the state `isEmergency` does not exist (we assume `EMERGENCY` aka. `SETTLING`) and the implementation does not perform any state checks. This method is called by many other functions in `AMM`.\n\n\n#### Recommendation\n\n\nAccording to the specification, `forceFunding` should not be allowed in `EMERGENCY` mode. However, it is assumed that this method should only be callable in `NORMAL` mode.\n\n\nThe assessment team would like to note that the specification appears to be inconsistent and dated (method names, variable names, …).",
      "summary": "\nA bug was identified in the specification of the AMM.funding() function, which states that isEmergency==FALSE is a requirement. However, the state isEmergency does not exist and the implementation does not perform any state checks. This method is called by many other functions in AMM. It was recommended that forceFunding should not be allowed in EMERGENCY mode, but should only be callable in NORMAL mode. The assessment team noted that the specification appears to be inconsistent and dated. To address this issue, the code was changed to silently skip funding() if the status is not NORMAL.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13710",
      "title": "Exchange - CancelOrder has no effect  Pending",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue has been addressed with [mai-protocol-v2/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1](https://github.com/mcdexio/mai-protocol-v2/tree/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1) by verifying that an order has not been cancelled in method [validateOrderParam](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/exchange/Exchange.sol#L252).\n\n\n`cancelOrder` still does not verify the order signature.\n\n\n\n\n#### Description\n\n\nThe exchange provides means for the `trader` or `broker` to cancel the order. The `cancelOrder` method, however, only stores the hash of the canceled order in mapping but the mapping is never checked. It is therefore effectively impossible for a trader to cancel an order.\n\n\n#### Examples\n\n\n**code/contracts/exchange/Exchange.sol:L179-L187**\n\n\n\n```\n\nfunction cancelOrder(LibOrder.Order memory order) public {\n    require(msg.sender == order.trader || msg.sender == order.broker, \"invalid caller\");\n\n    bytes32 orderHash = order.getOrderHash();\n    cancelled[orderHash] = true;\n\n    emit Cancel(orderHash);\n}\n\n```\n#### Recommendation\n\n\n* `matchOrders*` or `validateOrderParam` should check if `cancelled[orderHash] == true` and abort fulfilling the order.\n* Verify the order params (Signature) before accepting it as canceled.",
      "summary": "\nThis bug report is about an issue with the exchange providing means for traders or brokers to cancel orders. The `cancelOrder` method stores the hash of the canceled order in a mapping, but it does not verify the order signature. This makes it impossible for a trader to cancel an order. To resolve the issue, the `matchOrders*` or `validateOrderParam` methods should check if `cancelled[orderHash] == true` and abort fulfilling the order. Additionally, the order params (Signature) should be verified before accepting it as canceled. A fix for this issue has been addressed with a new version of the protocol, which verifies that an order has not been cancelled in the `validateOrderParam` method.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "MCDEX Mai Protocol V2",
      "source_link": "https://consensys.net/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "11756",
      "title": "[P5-L09] Undocumented assembly block in the IsPrime contract",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`VDF`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF)\n\n\nThe `IsPrime` contract [contains an assembly block](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/IsPrime.sol#L14-L26) without extensive documentation.\n\n\nAs this is a low-level language that is harder to parse by readers, consider including extensive documentation regarding the rationale behind its use, clearly explaining what every single assembly instruction does. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it.\n\n\n***Update**: Fixed. The ECO team has added inline comments to the assembly code.*\n\n\n\n\n#### [P5-L10] Wrong comments for the calculation of maximum uint256\n\n\n###### Low\n\n\nComponent: [`VDF`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF)\n\n\nIn lines [289](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L289) and [403](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L403) of `BigNumber.sol`, the maximum possible `uint256` is calculated with `not(0x0)`. However, the comments next to both statements say it is calculated using an underflow.\n\n\nConsider updating the inline comments to avoid mismatches with the actual implementation.\n\n\n***Update**: Fixed. Both comments in lines [289](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/VDF/BigNumber.sol#L289) and [403](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/VDF/BigNumber.sol#L403) have been updated to describe the actual implementation.*\n\n\n#### [P5-L11] Maximum BigNumber is not enforced or documented\n\n\n###### Low\n\n\nComponent: [`VDF`](https://github.com/BeamNetwork/currency/blob/master/contracts/VDF)\n\n\nIn the `privateRightShift` function of the `BigNumber` library, there is a cast of the array length from `uint256` to `int256`. This means that if the length of the array is bigger than 2^128, it will overflow the cast and become negative, giving unexpected results. We do not expect users of the library to require numbers this big. We do not even know what would happen to the EVM in those cases. The block gas limit would be exceeded by too much. However, it is important to document the limitations of the library and prevent extreme use cases that could break it.\n\n\nConsider adding a require statement to the [`from` function](https://github.com/BeamNetwork/currency/blob/bdea601e2bfd7ef56535bd31a3a1f7d664a2eb08/contracts/VDF/BigNumber.sol#L49) or before the [cast](https://github.com/BeamNetwork/currency/blob/bdea601e2bfd7ef56535bd31a3a1f7d664a2eb08/contracts/VDF/BigNumber.sol#L685) to make sure that it will never overflow.\n\n\nConsider experimenting with the upper limits of the library to document the maximum possible `BigNumber` that it can handle.\n\n\n\n\n***Update**: Fixed. Now, the [length of the array](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/VDF/BigNumber.sol#L680-L683) is checked before the cast to `int256`. Note that the [`length` local variable](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/VDF/BigNumber.sol#L677) could be used to avoid reading the array’s length again. Moreover, the error message should better denote the actual condition checked, such as “Length of the dividend’s value must be equal or less than 1024 bytes”.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11755",
      "title": "[P5-L06] Unused Transfer event",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nIn the `EcoBalanceStore` contract, there is a declared [`Transfer` event](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L29) that is never used.\n\n\nConsider removing it.\n\n\n***Update**: Fixed. [The `Transfer` event](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol) has been removed.*\n\n\n\n\n#### [P5-L07] Wrong comment in the AccountBalanceGenerationUpdate event\n\n\n###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nThe [comment of the `AccountBalanceGenerationUpdate` event](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L57) in the `EcoBalanceStore` contract mentions a value parameter that does not exist.\n\n\nConsider removing this line from the comment.\n\n\n***Update**: Fixed. [The wrong comment in the `AccountBalanceGenerationUpdate` event](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L46) has been removed.*\n\n\n#### [P5-L08] Wrong comment in the tokenTransfer and tokenBurn functions\n\n\n###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nIn the `EcoBalanceStore` contract, the functions [`tokenTransfer`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L240) and [`tokenBurn`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L286) say in their docstrings, “This function is restricted and can only be accessed by authorized addresses — specifically those in the authorizedContracts set.”\n\n\nHowever, the [`authorizedContracts` array](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L64) does not contain addresses. The array actually used in these functions is [`authorizedContractAddresses`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L67).\n\n\nConsider updating the functions’ docstrings to better reflect which data structure holds the authorized addresses allowed to call them.\n\n\n***Update**: Fixed. Now the `authorizedContractAddresses` array is mentioned in the docstrings of the [`tokenTransfer` function](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L216) and in the ones of the [`tokenBurn` function](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L271).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11754",
      "title": "[P5-L05] Undocumented authorization in the tokenBurn function",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nIn the `EcoBalanceStore` contract, the `tokenBurn` function [allows the `policy` contract to burn tokens from any account](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L300). However, such sensitive behavior is not documented.\n\n\nConsider explicitly stating this in the function’s docstrings.\n\n\n***Update**: Fixed. Now, [the function’s docstrings](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L272) state that the root `policy` contract is authorized to call the function. Yet, it doesn’t explicitly say that it can burn tokens from any account.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11753",
      "title": "[P5-L04] The tokenTransfer and tokenBurn functions do not fail early",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency)\n\n\nIn the `EcoBalanceStore` contract, the [`tokenTransfer`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L240) and [`tokenBurn`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L286) functions are do not follow the [fail early](https://blog.openzeppelin.com/onward-with-ethereum-smart-contract-security-97a827e47702/) pattern. These functions first update the balances, and afterwards check if the operation is authorized, reverting the transaction if not.\n\n\nConsider first validating whether the sender is an authorized account, and then apply balance updates.\n\n\n***Update**: Fixed. Now, in the `tokenTransfer` function the [authorization check](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L240-L256) comes before [the balance updates](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L258-L264). The same happens with the `tokenBurn` function: [the authorization check](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L287-L301) comes before [the updates](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L303-L308).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11752",
      "title": "[P5-L03] Outdated README file in the currency repository",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nThe [`README` file of the `currency` repository](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/README.md) is outdated. For example, it refers to the functions [`burn`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/README.md#burn) and [`updateTo`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/README.md#updateto), which have been renamed. It also [mentions](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/README.md#background) that the `EcoBalanceStore` contract implements the `ERC20` interface, which is no longer true.\n\n\nConsider updating all documentation in the `README` file to reflect the current state of the code base.\n\n\n***Update**: Fixed. [All documentation](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/README.md) related to the `EcoBalanceStore` contract API has been removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11751",
      "title": "[P5-L02] The AccountBalanceGenerationUpdate event is missing relevant data",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`currency`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/)\n\n\nIn the `EcoBalanceStore` contract, the [`AccountBalanceGenerationUpdate` event](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L397) does not log the generation to which the address has been updated. This may impede reconstructing the history of generation updates for an account through emitted events.\n\n\nConsider adding the generation as a parameter to the event.\n\n\n***Update**: Fixed. [The event](https://github.com/BeamNetwork/currency/blob/audit-fix-5/contracts/currency/EcoBalanceStore.sol#L48) now [logs the `generation` too](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/currency/EcoBalanceStore.sol#L391).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11750",
      "title": "[P5-L01] Use of hash constants without comment",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nIn the `PolicedUtils`, there are [11 constants for the identifiers of the policies](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/PolicedUtils.sol#L14-L24). The value of these constants is a hash value, generated from a human-readable string that describes the policy. However, the corresponding strings are not present in the code. This makes it hard to understand where the hashes come from.\n\n\nConsider adding a comment before every constant with the string used to generate the hash.\n\n\n***Update**: Fixed. Now all [11 constants have comments](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/policy/PolicedUtils.sol#L14-L45) with the strings used to generate the hashes.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11749",
      "title": "[P5-M01] Policy self-removal not failing loudly",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/e707a08114c09a51f76384562c390d5f26dd6bcd/contracts/policy)\n\n\nIn the `Policy` contract, the [`removeSelf` function checks if the sender is the current interface implementer](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/Policy.sol#L27). If it is not, the function just does nothing, failing to explicitly inform the caller of a failed transaction.\n\n\nFollowing the [Fail Loudly principle](https://blog.openzeppelin.com/onward-with-ethereum-smart-contract-security-97a827e47702/), and to avoid hiding errors from the caller, consider reverting the transaction when the sender is not required.\n\n\n***Update**: Not fixed. The [code remains the same](https://github.com/BeamNetwork/currency/blob/d1b4bfe01310c709e54f9b4bf3fc123fba55af2a/contracts/policy/Policy.sol#L27). Nevertheless, now the comment has changed and it states, “[…] if another contract has taken the role, this does nothing”. Eco’s statement for this issue:*\n\n\n\n> \n>  The `removeSelf` function fails silently to allow its use in places where another contract may have taken ownership of the role. For example, when a contract is being destructed it can first `removeSelf` from its usual role without worrying that another contract might have been granted the role.\n> \n> \n>",
      "summary": "\nThis bug report is about the `Policy` contract in the BeamNetwork/currency repository. The `removeSelf` function checks if the sender is the current interface implementer, but if it is not, the function does nothing and fails to inform the caller of a failed transaction. This goes against the Fail Loudly principle, which states that errors should be made explicit. To fix the issue, the transaction should be reverted when the sender is not required. However, the code remains the same and the comment has been changed to explain the behavior. The statement from Eco is that the `removeSelf` function fails silently to allow its use in places where another contract may have taken ownership of the role. This is to avoid worrying that another contract might have been granted the role, for example when a contract is being destructed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11748",
      "title": "[P4-L12] Not using mixed case for variables",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the assembly blocks of the [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) [library](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol), variables are named using lowercase with underscores.\n\n\nThis does not follow the [Solidity style guide](https://solidity.readthedocs.io/en/v0.5.9/style-guide.html#local-and-state-variable-names) and is inconsistent with the rest of the variables declared outside of assembly blocks.\n\n\nConsider using mixed case for all variables.\n\n\n***Update:*** *Not fixed. See Eco’s statement for this issue in **[P4-L09] Use of magic constants***",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11747",
      "title": "[P4-L11] Missing explicit return statement",
      "impact": "LOW",
      "content": "###### Low\n\n\nSolidity allows the naming of the return variables on function declarations. When this feature is used, it is optional to use the `return` statement. If `return` is not explicitly called by the time a function ends, it returns any value assigned to the named return variable.\n\n\nThe [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) [library](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) uses named return variables extensively and uses explicit `return` statements inconsistently.\n\n\nFor explicitness and readability, consider always using the `return` statement.\n\n\n***Update:** Fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11746",
      "title": "[P4-L10] Misleading comments",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn lines [600](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L600) and [606](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L606) of the `BigNumber` library, the comments refer to the variable `length_ptr` as `start_ptr`. Consider updating the comments to reflect the correct variable name.\n\n\nIn line [616](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L616), the comment is only valid if there are no leading zero words. Otherwise, the offset needs to be adjusted. Consider updating the comment to include the case with at least one leading zero word.\n\n\n***Update:*** *Fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11745",
      "title": "[P4-L09] Use of magic constants",
      "impact": "LOW",
      "content": "###### Low\n\n\nThere are several occurrences of magic constants in the `BigNumber` library (e.g., [L54](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L54), [L544](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L544), [L545](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L545), [L583](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L583), and [L584](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L584)). These values make the code harder to understand and maintain.\n\n\nConsider defining a constant variable for every magic constant, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen. All of this will allow for added readability, easing the code’s maintenance.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  We didn’t refactor all of the code when we imported the library. We’d prefer not to include external libraries this way at all, and are interested in helping to build a gas-efficient general big number library for Solidity. Once one is available we’ll migrate the code over to use it.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11744",
      "title": "[P4-L08] Inconsistent use of hexadecimal and decimal numbers",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) library, hexadecimal and decimal numbers are used inconsistently. For example, see [`0x20`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L58) [in L58](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L58) and [`32`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L88) [in L88](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L88).\n\n\nTo make the code easier to read, consider using number bases consistently.\n\n\n***Update:*** *Fixed. The [`BigNumber` library](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol) now uses hexadecimal numbers.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11743",
      "title": "[P4-L07] Maximum uint256 value calculated with underflow",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn [L261](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L261) and [L370](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L370) of the `BigNumber` library, the maximum `uint256` value is calculated by forcing an underflow.\n\n\nThis is hard to read. Consider using `not(0)` instead.\n\n\n***Update:*** *Fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11742",
      "title": "[P4-L06] Duplicated load of the array length",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [`innerAdd`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252) [function of the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252) [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252) [library](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252), the length of the two parameter arrays are repeatedly loaded with `mload(_max)` and `mload(_min)`. Consider assigning the length of the arrays to two variables named `maxLength` and `minLength`, which will make the code more readable.\n\n\nAlso, note that in [L277,](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L277) the difference between `mload(_max)` and `mload(_min)` is repeatedly calculated inside a `for` loop. This difference is a constant, so consider calculating it once and assigning it to a variable.\n\n\n***Update:*** *Fixed in [68adc904](https://github.com/BeamNetwork/currency/blob/68adc904f55130fae0254a00864ea26dccd3805d/contracts/VDF/BigNumber.sol#L293-L294).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11741",
      "title": "[P4-L05] Confusing loop boundary",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn [line 639 of the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L639) [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L639) [library](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L639), the variable `max` is intentionally set (unnecessarily with assembly) to `uint256(-32)`. It is then used to bound [a loop](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L643) that starts counting from a multiple of 32 down to 0, subtracting 32 each time until it terminates when it reaches `max`. This is very confusing. Presumably, this pattern was chosen because the condition `i >= 0` would always succeed for a `uint256` value. Consider using a signed loop counter and stopping the loop when it becomes negative.\n\n\n***Update:*** *[Fixed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L685). Note, however, that this change reduces the maximum size of a `BigNumber`. The length of the array is stored in a `uint256` variable. Now, if the length is bigger than 2^128, it will overflow the cast to `int256`, giving unexpected results. This has been reported as an issue in the Phase 5.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11740",
      "title": "[P4-L04] Lack of input validation",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L625) [library, the function](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L625) [`privateRightShift`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L625) has a `uint256` parameter for the number of bits to shift. The maximum value for that parameter should be 256, but this is never validated. If this function is called by mistake with a higher value, there will be an underflow in [L632](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L632), and the results returned will be unexpected.\n\n\nThis is not currently vulnerable, because the `privateRightShift` function is only used internally to shift 2 bits. However, it will be hard to find the problem if the code is changed in the future and the wrong value is mistakenly passed to the function.\n\n\nConsider adding this validation to [fail as early and loudly as possible](https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702).\n\n\n***Update:*** *Fixed. The `privateRightShift` function now has a [requirement to only shift by two positions](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L679).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11739",
      "title": "[P4-L03] No mechanism to make a BigNumber instance from a zero byte",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe `BigNumber` library makes a new instance by calling one of the two `_new` functions. [The first](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) [`_new`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) [function](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) receives a dynamically sized `bytes` array. When the array size is not a multiple of 32 bytes, it [confirms that the first element of the array is not 0](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L68-L70).\n\n\nThis means that it is not possible to make a new instance from a `bytes` array with a single zero byte.\n\n\nHowever, it is possible to make a new instance with value 0 by calling the first `_new` function with an empty `bytes` array or by calling the second `_new` function with the 0 `uint256`. Nevertheless, for completeness, consider supporting the `bytes` array `0x0` as a valid argument to make a new `BigNumber` instance.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  This functionality isn’t needed for our project, but would be a great addition to include in a published library.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11738",
      "title": "[P4-L02] Complicated modulus length calculation",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [function](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L471) [`opAndSquare`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L471) [of the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L471) [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L471) [library](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L471), the square is calculated by using the [modular exponentiation precompile](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-198.md) with a modulus value that is big enough to return the full exponentiation value.\n\n\nThe value of modulus is calculated in [L487](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L487) and [L496](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L496) with the following formula:\n\n\n\n```\n((base.length * 16 / 256) + 1) * 32\n```\n\nThis is very hard to understand and unnecessary given the rest of the function assumes that `base.length` is a multiple of 32. Consider simplifying it to:\n\n\n\n```\n(base.length * 2) + 32\n```\n\nThis shows in a clearer way that it has to be twice the length plus one extra word.\n\n\n***Update:** [Fixed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L523).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11737",
      "title": "[P4-L01] Inconsistent representations of zero",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe `BigNumber` library makes a new instance by either passing a [dynamically-sized](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) [`bytes`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) [array](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L48) or a [`uint256`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L85) [value](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L85).\n\n\nWhen the empty `bytes` array is used to make a new instance, it is internally represented as an array of length 0. This is consistent with the manually-constructed values produced by other functions. However, when the 0 `uint256` is used to make a new instance, it is internally represented as an array of 32 zero bytes. This inconsistency makes the [`cmp`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L188) function fail when the two different representations are compared. Consequently, the functions that use `cmp` (like [`privateDiff`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L338)) will behave in unexpected ways when operating on the two different representations of 0.\n\n\nConsider using a single internal representation for an instance of value 0.\n\n\n***Update:*** *Fixed. Now, when the `BigNumber` is instantiated by passing a 0 `uint256` value, is [represented as an array of length 0](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L93).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11736",
      "title": "[P4-M05] Cannot verify short proofs",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nWhen starting a proof in the `VDFVerifier` contract, [the minimum](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L74) [`t`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L74) [value is 1](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L74). However, [the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L95-L174) [`update`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L95-L174) [function](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L95-L174) that is used to complete the proof has a minimum `_nextProgress` value of 1, which is assumed to be less than `t` (and `t - 1` in the last step of the proof).\n\n\nThe contract should be able to directly verify the relationship, but it requires the prover to provide the intermediate `u` value, which does not exist. Consequently, the prover cannot complete the proof.\n\n\nConsider requiring `t` to exceed 1, or provide a mechanism for the contract to verify the function when `t` is 1.\n\n\n***Update:** Fixed. Now [`t` must be at least 2.](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/VDFVerifier.sol#L78)*",
      "summary": "\nThis bug report is about the `VDFVerifier` contract in the BeamNetwork/currency repository. The issue is that the `update` function, which is used to complete a proof, has a minimum `_nextProgress` value of 1, which is assumed to be less than `t` (and `t - 1` in the last step of the proof). This causes the prover to be unable to complete the proof as the contract is unable to verify the relationship without the intermediate `u` value. To fix this issue, the requirement for `t` was changed to be at least 2.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11735",
      "title": "[P4-M04] The identity precompile return value is ignored",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the `innerModExp` function of the `BigNumber` library, the identity precompiled contract stored at address `0x4` is called in [L543](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L543), [L554](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L554), and [L565](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L565) to copy the arguments to memory. Only the last call [checks the return value](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L574) for errors during the call.\n\n\nConsider adding checks to all the calls to the identity precompiled contract.\n\n\n***Update:*** *Fixed. Now, the results of all the [calls to the identity precompiled contract are combined with an `and` operation](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L592), and afterwards, they are checked that none of the calls failed.*",
      "summary": "\nThis bug report is about the `innerModExp` function of the `BigNumber` library. This function calls the identity precompiled contract stored at address `0x4` in [L543](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L543), [L554](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L554), and [L565](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L565) to copy the arguments to memory. The bug is that only the last call checks the return value for errors during the call. The suggested solution was to add checks to all the calls to the identity precompiled contract. This was fixed by combining the results of all the calls to the identity precompiled contract with an `and` operation, and afterwards, they are checked that none of the calls failed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11734",
      "title": "[P4-M03] Returning the incorrect buffer",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe `innerModExp` function in the `BigNumber` contract has [an assembly loop](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L601-L608) that removes leading zero words in the result and decrements the buffer length accordingly. However, if the base value is zero, the result will be zero. This will cause the loop to continue past the end of the result buffer until it reaches the first non-zero word. Then the length field will underflow and become huge, causing the function to return an arbitrary junk value. Alternatively, if there are no non-zero bytes after the return buffer, the loop will never terminate and exhaust all the gas.\n\n\nSimilarly, the `privateRightShift` also has [an equivalent loop](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L666-L673). If the right shift causes the result to be zero, it will also either return an arbitrary junk value or enter an infinite loop.\n\n\nConsider adding bounds checking to ensure the loop does not pass the length of the result buffer.\n\n\n***Update:*** *Fixed. Now both [`privateRightShift`](https://github.com/BeamNetwork/currency/blob/68adc904f55130fae0254a00864ea26dccd3805d/contracts/VDF/BigNumber.sol#L715-L722) and [`innerModExp`](https://github.com/BeamNetwork/currency/blob/68adc904f55130fae0254a00864ea26dccd3805d/contracts/VDF/BigNumber.sol#L644-L651) implement bound checks.*",
      "summary": "\nThis bug report is about the `BigNumber` contract, which contains two functions, `innerModExp` and `privateRightShift`. The issue is that if the base value is zero, the loop in `innerModExp` will continue past the end of the result buffer until it reaches the first non-zero word, causing the function to return an arbitrary junk value, or alternatively, enter an infinite loop. The same issue applies to the `privateRightShift` function. To fix this, bounds checking should be added to ensure the loop does not pass the length of the result buffer. This issue has now been fixed, and both `privateRightShift` and `innerModExp` now implement bound checks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11733",
      "title": "[P4-M02] VDF inputs may be precomputable",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe security of the VDF relies on potential attackers having a known maximum time window to complete the attack. This assumption can be undermined if:\n\n\n* The attacker has precomputed the VDF solution for the input `x`.\n* The attacker has precomputed the VDF solution for the factors of `x`.\n\n\nIn the current design:\n\n\n* The `Inflation` contract uses a recent Ethereum block hash as input to the VDF. This is believed to be probabilistically immune to precomputation (see the Open Questions section).\n* The individual trusted nodes use a VDF to mask their votes during currency governance. The VDF inputs will be chosen by the Eco-provided software to be immune to precomputation.\n\n\nHowever, the `VDFVerifier` contract is designed to be usable in other scenarios and should enforce secure inputs wherever possible. Potential modifications:\n\n\n* Enforce a minimum `x` value outside the range of plausibly precomputed values. It is worth noting that the [Eco VDF documentation](https://github.com/BeamNetwork/currency/tree/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF) states that `x` should be at least 256 bits, but this is not enforced by the contract.\n* Hash the input `x` value to probabilistically ensure a large factor.\n* Use the [Miller-Rabin primality test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test) to ensure `x` is probably prime and is therefore immune to having the VDF solution of its factors precomputed. This idea was suggested by the Eco team.\n\n\nConsider restricting or modifying the input `x` to mitigate against precomputation and documenting the method chosen, along with its security assumptions.\n\n\n***Update:*** *Partially fixed. The [`start` function now checks if `x` is a probable prime](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/VDFVerifier.sol#L87) with 10 iterations. Eco’s statement for this issue:*\n\n\n\n> \n>  The next iteration on our code will reduce the use of VDFs to just a few cases, where the input will always be a block hash. We believe that this, combined with the Miller-Rabin primality testing, will be sufficient to ensure the security of the processes it will be used in.\n> \n> \n>",
      "summary": "\nA bug report was filed regarding the VDFVerifier contract, which is designed to be used in other scenarios and should enforce secure inputs wherever possible. The issue was that the attacker may have precomputed the VDF solution for the input 'x' or its factors, undermining the security of the VDF. \n\nThe current design of the `Inflation` contract uses a recent Ethereum block hash as input to the VDF, which is believed to be probabilistically immune to precomputation. The individual trusted nodes use a VDF to mask their votes during currency governance and the VDF inputs will be chosen by the Eco-provided software to be immune to precomputation.\n\nTo mitigate against precomputation, it was suggested to enforce a minimum `x` value outside the range of plausibly precomputed values, hash the input `x` value to probabilistically ensure a large factor, and use the Miller-Rabin primality test to ensure `x` is probably prime. This was partially fixed in the `start` function, which now checks if `x` is a probable prime with 10 iterations. The Eco team stated that the next iteration on their code will reduce the use of VDFs to just a few cases, where the input will always be a block hash. This, combined with the Miller-Rabin primality testing, is believed to be sufficient to ensure the security of the processes it will be used in.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11732",
      "title": "[P4-M01] Undocumented security assumptions",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe `VDFVerifier` contract [uses a constant modulus](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L12) [`N`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol#L12). This is the [2048-bit number from the (elapsed) RSA challenge](https://en.wikipedia.org/wiki/RSA_numbers#RSA-2048). The security of the VDF depends on various assumptions about that value:\n\n\n* It is the product of two primes.\n* The factors are [safe primes](https://en.wikipedia.org/wiki/Safe_prime).\n* No attacker knows or can obtain the factorization.\n\n\nNaturally, the Eco team is unable to verify these claims. In such cases, it is good practice to clearly explain the assumptions and their security implications.\n\n\nConsider adding the reason for the choice of `N` as well as the security assumptions and implications to the documentation.\n\n\n***Update:*** *Fixed. A [comment has been added to explain the security assumptions of the chosen `N`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/VDFVerifier.sol#L12).*",
      "summary": "\nThis bug report is about the `VDFVerifier` contract, which uses a constant modulus called `N`. This modulus is a 2048-bit number from the RSA challenge, and the security of the VDF depends on various assumptions about the value of `N`, such as that it is the product of two primes, that the factors are safe primes, and that no attacker knows or can obtain the factorization. The Eco team was unable to verify these claims, so it was suggested that the reason for the choice of `N` as well as the security assumptions and implications should be added to the documentation. This has now been fixed, with a comment added to explain the security assumptions of the chosen `N`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11731",
      "title": "[P4-H04] BigNumber internal values can be manipulated",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) library internally stores its value in a `bytes` buffer. When it is initialized with a `uint256` or a `bytes` buffer with a length not divisible by 32, a new `bytes` buffer is allocated for the `BigNumber` object.\n\n\nHowever, when it is initialized with a `bytes` buffer with a length divisible by 32, it uses that buffer directly in its internal representation. This means that if the caller subsequently clears or modifies the input buffer, it will corrupt the `BigNumber` value.\n\n\nSimilarly, [the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L93-L137) [`asBytes`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L93-L137) [functions](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L93-L137) return a new buffer when no output size is specified or the output needs to be padded However, they return a reference to the internal `bytes` buffer when the requested size matches the `BigNumber` size. Once again, if the caller modifies the returned buffer, it will corrupt the `BigNumber` value.\n\n\nConsider creating a new buffer for every `BigNumber` instance and returning a new buffer whenever `asBytes` is called.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  A user of the library could definitely modify the buffer as described, but our system uses the library internally only so there’s no opportunity to use this maliciously. The problem should be fixed before this `BigNumber` code is released as a library, but it doesn’t represent an attack against our system.\n> \n> \n>",
      "summary": "\nThis bug report is about the BigNumber library, which is used to store values in a bytes buffer. When it is initialized with a uint256 or a bytes buffer with a length not divisible by 32, a new bytes buffer is allocated for the BigNumber object. However, when it is initialized with a bytes buffer with a length divisible by 32, it uses that buffer directly in its internal representation. This means that if the caller subsequently clears or modifies the input buffer, it will corrupt the BigNumber value. Similarly, the asBytes functions return a new buffer when no output size is specified or the output needs to be padded. However, they return a reference to the internal bytes buffer when the requested size matches the BigNumber size. If the caller modifies the returned buffer, it will corrupt the BigNumber value.\n\nThe issue has not been fixed yet, and the statement from the developers is that a user of the library could potentially use this maliciously, but it doesn't represent an attack against their system. The developers suggest that the problem should be fixed before this BigNumber code is released as a library.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11730",
      "title": "[P4-H03] Missing unit tests",
      "impact": "HIGH",
      "content": "###### High\n\n\nTests are the best way to specify the expected behavior of a system. When the code is written test-driven, the test coverage is automatically 100%, many issues are prevented, and the design of the code can be improved. Additionally, when bugs are found, it is easier to fix them without introducing regression errors.\n\n\nThere are no unit tests for the functions of the [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) library. Instead, they are tested through the [unit tests of the](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/test/VDF/VDFVerifier.js) [`VDFVerifier`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/test/VDF/VDFVerifier.js) [contract](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/test/VDF/VDFVerifier.js). The correct functionality of this library is critical for the success of the system. Even if all the features of `BigNumber` used by the `VDFVerifier` are currently correct, it is possible that, in the future, a change in the verifier assumes that an untested `BigNumber` code path is correct and starts breaking in surprising ways.\n\n\nIn this case, it is particularly important because a large fraction of the contract is written in assembly, which is harder to parse and reason for. Note that the use of assembly discards several important safety features of Solidity, which may render the code less safe and more error-prone.\n\n\nConsider test-driving a rewrite of the `BigNumber` library.\n\n\n***Update:*** *Not fixed. See Eco’s statement for this issue in **[P4-H02] Excessive use of assembly**.*",
      "summary": "\nThis bug report is about the lack of unit tests for the functions of the BigNumber library. This library is used by the VDFVerifier contract and is critical for the success of the system. Without tests, it is possible that a future change in the verifier may assume that an untested BigNumber code path is correct and start breaking in unexpected ways. Additionally, a large fraction of the contract is written in assembly, which is harder to parse and reason for, and this could make the code less safe and more error-prone. The report suggests that a rewrite of the BigNumber library should be test-driven to ensure its correct functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11729",
      "title": "[P4-H02] Excessive use of assembly",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) library uses inline assembly to manage buffers and manipulate individual words in memory. However, in many functions, it also uses assembly to perform the calculations and control flow. These could be written in Solidity, which would be clearer, less error-prone, and more conducive to code reuse.\n\n\nConsider extracting low-level memory management operations (like storing a word at a particular location or clearing the zero words from the start of a buffer) into separate functions that use inline assembly and using Solidity for all other logic and processing.\n\n\n***Update:** Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  The `BigNumber` library is external code that we’ve imported so we could modify it. We’d prefer to participate in a rewrite in collaboration with someone who could be a permanent owner for the library.\n> \n> \n>",
      "summary": "\nThis bug report is about the [`BigNumber`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol) library used in Solidity. The library uses inline assembly to manage buffers and manipulate individual words in memory, as well as to perform calculations and control flow. The bug report suggests extracting low-level memory management operations into separate functions that use inline assembly and using Solidity for all other logic and processing. This would make the code clearer, less error-prone, and more conducive to code reuse. However, the bug report has not been fixed yet, and the developers would prefer to participate in a rewrite in collaboration with someone who could be a permanent owner for the library.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11728",
      "title": "[P4-H01] Undocumented cryptographic algorithm changes",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe verification procedure in the [`VDFVerifier`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/VDFVerifier.sol) contract is based on the [The Simple Verifiable Delay Functions specification](https://eprint.iacr.org/2018/627.pdf). However, the implementation has some differences with the specification:\n\n\n* The implementation uses the [Fiat-Shamir heuristic](https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic) to make the verification non-interactive. This needs to be done very carefully to ensure the prover, who now has some control over the random number, cannot leverage their additional power to generate a false proof.\n* The specification requires that all input variables are tested to ensure they are in the Positive Signed Quadratic Residue group mod `N`. Instead, the input values are squared to produce a corresponding value in that group.\n* The commitment is for the input `x` value before it is squared, which is a value that has no analogue in the specification.\n* In the specification, the difficulty of computing the VDF is parameterized by the number of squaring operations, which can be any positive integer. In the implementation, it is parameterized by the number of steps in the proof, thereby implicitly fixing the number of squaring operations to be a power of 2.\n* The last step in the specification occurs when the function has been reduced to `y = x^2`. The implementation stops at the previous step when `y = x^4`.\n\n\nThere are practical reasons for these deviations, and they mostly restrict and simplify the procedure, but as a general principle, modifications to cryptographic algorithms have a high probability of introducing vulnerabilities. They may also mislead users who are unaware of the changes to misuse the algorithm.\n\n\nConsider documenting any discrepancies between the specification and the implementation, along with an explanation for the change and a security justification.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> When applying the Fiat-Shamir heuristic we create a situation where a user who can control the input value of the VDF has influence over the steps that are used to prove the correctness of the VDF computation. We’re confident in the application of the Fiat-Shamir heuristic here specifically because it’s applied as described in the source paper “Simple Verifiable Delay Functions” (Pietrzak) and in the similar paper “Efficient verifiable delay functions” (Wesolowski).\n> \n> \n> Ben Fisch, one of our early team members and cryptographic advisors, drafted the following responses to the points raised:\n> \n> \n> * Our implementation follows the protocol for the original version of Simple Verifiable Delay Functions, which can be retrieved from ePrint. Our implementation squares the input x to produce z = x^2, and then runs the VDF on z as an input. This guarantees that z is in the Quadratic Residue subgroup mod N. The VDF verifier program receives x, which enables it to verify that z is in the Quadratic Residue subgroup. Thus, the VDF protocol we implemented, which proves that y is the result of the repeated squaring of z a specified number of times, has been proven secure in both the original version of the paper, as well as in the survey article <https://crypto.stanford.edu/~dabo/pubs/papers/VDFsurvey.pdf>. It is statistically secure as long as the input z lies in a group with no low order elements, which is indeed true of the Quadratic Residue subgroup mod N, where N is the product of strong primes.\n> * On page 6 of the latest version of “Simple Verifiable Delay Functions”, referenced here as the “specification”, it is explained that the original version of the paper used the subgroup of Quadratic Residues, while the newer version uses the Positive Signed Quadratic Residues. The motivation for this change is irrelevant to our setting, where it is completely fine to fix the VDF input challenge to be x^2. In fact, the same technique is also used in the recent paper Continuous Verifiable Delay Functions. <https://eprint.iacr.org/2019/619.pdf>.\n> * A restriction on the number of squaring operations does not affect security, and is good enough for our application.\n> * Stopping at `y = x^2` does not affect the security of the protocol.\n> \n> \n>",
      "summary": "\nThe VDFVerifier contract implements a verification procedure based on the Simple Verifiable Delay Functions specification. However, there are some differences between the implementation and the specification that could lead to vulnerabilities. These discrepancies include the use of the Fiat-Shamir heuristic to make the verification non-interactive, the use of the Positive Signed Quadratic Residue group mod N, and the parameterization of the difficulty by the number of steps in the proof instead of the number of squaring operations. It is important to document these discrepancies and provide an explanation for the change and a security justification. Eco's statement for this issue explains that the implementation follows the protocol for the original version of Simple Verifiable Delay Functions and is statistically secure as long as the input lies in a group with no low order elements. It also explains that the restriction on the number of squaring operations does not affect security and stopping at y = x^2 does not affect the security of the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11727",
      "title": "[P4-C02] Calculation error in the BigNumber addition",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nThe `BigNumber` library has an [`innerAdd`](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252) [function](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L252) that adds two numbers, starting from their least significant 256-bit words.\n\n\nThis function needs to take the carry into account, when the addition of two words overflows. To do this, in [L283](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L283), it checks if the word of the first number exceeds the minimum size that can be added without overflow. This value should be calculated as follows:\n\n\n\n```\nword1 + word2 + carry > MAX_256_BIT_INTEGER [ overflow condition ]\n=>   word1 > MAX_256_BIT_INTEGER - word2 - carry\n=>   word1 > MAX_256_BIT_INTEGER - ( word2 + carry )\n```\n\nHowever, it is calculated as:\n\n\n\n```\nword1 > MAX_256_BIT_INTEGER - ( word2 - carry )\n```\n\nIn addition to this incorrect calculation, the last term underflows when `word2` is 0 and `carry` is 1.\n\n\nConsider fixing the carry calculation. Note that the correct calculation obsoletes the `switch` statement in [L288](https://github.com/BeamNetwork/currency/blob/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF/BigNumber.sol#L288), which should handle the case where `word2 + carry` overflows instead.\n\n\n***Update:*** *Fixed. First, the [conditional was updated to the suggested calculation](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/VDF/BigNumber.sol#L311). And afterwards, the [switch statement was updated](https://github.com/BeamNetwork/currency/blob/68adc904f55130fae0254a00864ea26dccd3805d/contracts/VDF/BigNumber.sol#L319) to handle the case where `word2 + carry` overflows. However, note that there are still no specific tests to cover all possible code paths of the BigNumber operations – as reported in **[P4-H03] Missing unit tests***",
      "summary": "\nThe BigNumber library has a function called innerAdd that adds two numbers, starting from their least significant 256-bit words. This function should take the carry into account when the addition of two words overflows, however, it is calculated incorrectly. The incorrect calculation also causes the last term to underflow when word2 is 0 and carry is 1. \n\nThe suggested fix is to update the conditional to the suggested calculation and the switch statement to handle the case where word2 + carry overflows. This has been fixed, but there are still no specific tests to cover all possible code paths of the BigNumber operations.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11726",
      "title": "[P4-C01] Unknown attacker advantage",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nThe VDF difficulty parameter must be chosen to ensure any plausible attacker cannot compute the VDF solution within the minimum time bound. Correctly setting this value requires estimating the capability of the attacker’s hardware. Unfortunately, this is an area of active research and therefore is currently unknown. It is worth noting that [the Ethereum Foundation, Protocol Labs, and other contributors are actively involved in this research](https://vdfresearch.org/) and intend to significantly raise the standard of widely available hardware in order to minimize the plausible attacker advantage.\n\n\nThe [Eco security documentation](https://github.com/BeamNetwork/currency/tree/de81d9bad4195e03f07aedd2a6817f0cb04a8c8d/contracts/VDF) provides time estimates for consumer hardware, but it does not contrast this with the advantage an attacker may have from using an optimized ASIC.\n\n\nConsider documenting the maximum attacker advantage implied by the choice of time windows and difficulty functions for all use cases. However, it is our understanding that the field is not mature enough to confidently estimate the true upper bound, and the procedure will remain vulnerable to potential attackers with a greater advantage than the selected one.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  The advantage an attacker can achieve using custom hardware is definitely a concern here. We’ve done internal research on high end consumer hardware and extrapolated beyond that to attempt to account for custom hardware. However, we anticipate more information about the power of custom hardware before we launch. We’ll need to review the Ethereum Foundation’s work on hardware VDF implementations and factor those gains in to the security parameters we use in our VDFs at launch.\n> \n> \n>",
      "summary": "\nThis bug report is about VDF difficulty parameter, which is used to ensure that attackers cannot compute the VDF solution within the minimum time bound. It is an area of active research and therefore is currently unknown. The Eco security documentation provides time estimates for consumer hardware, but it does not contrast this with the advantage an attacker may have from using an optimized ASIC. It is recommended to document the maximum attacker advantage implied by the choice of time windows and difficulty functions for all use cases. However, it is understood that the field is not mature enough to confidently estimate the upper bound, and the procedure will remain vulnerable to potential attackers with a greater advantage than the selected one. Eco's statement for this issue is that they have done internal research on high end consumer hardware and extrapolated beyond that, but they anticipate more information about the power of custom hardware before they launch. They will need to review the Ethereum Foundation’s work on hardware VDF implementations and factor those gains in to the security parameters they use in their VDFs at launch.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11725",
      "title": "[P3-L18] Use of magic constants",
      "impact": "LOW",
      "content": "###### Low\n\n\nThere are three locations where the policy is updated using a `SimplePolicySetter` clone initialized with magic string constants [`\"CurrencyGovernance\"`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TimedPolicies.sol#L110), [`\"PolicyProposals\"`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TimedPolicies.sol#L140), and [`\"PolicyVotes\"`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L264).\n\n\nThis makes the code harder to understand and maintain.\n\n\nConsider defining constant variables with inline comments explaining the relationship between the magic strings and the corresponding constants in the [`PolicedUtils`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/policy/PolicedUtils.sol) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/policy/PolicedUtils.sol).\n\n\n***Update:*** *Fixed. The string constants were replaced with named constants from the [`PolicedUtils` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/PolicedUtils.sol).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11724",
      "title": "[P3-L17] Wrong error messages in require statements",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `computeVote` function of the `CurrencyGovernance` contract, there are multiple `require` statements in [L269](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L269), [L275](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L275), [L281](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L281), and [L287](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L287) that state ‘`... but one is not`‘, when actually, it should say ‘`... but at least one is not`‘.\n\n\nConsider changing the messages to describe the actual behavior.\n\n\n***Update:*** *Fixed. [Error messages](https://github.com/BeamNetwork/currency/blob/68adc904f55130fae0254a00864ea26dccd3805d/contracts/governance/CurrencyGovernance.sol) have been modified following our suggestion.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11723",
      "title": "[P3-L16] Multiple wrong comments",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L255) [function of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L255) [`CurrencyGovernance`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L255) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L255), when the number of revealed valid votes is 0, the comment says, “[…] some votes could not be revealed […].” A more accurate comment would be, “All the committed votes were invalid.” It also says, “Alternately, the next inflation cycle has started, and this contract is invalid,” but that check happens in a higher block in [L232](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L232).\n\n\nThe `TrustedNodes` contract maintains an [array with the addresses of the trusted nodes](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L19). When an address that is not at the end of the array is distrusted, it is overwritten by the last address, which is then removed from the end of the array.\n\n\nThe comments in the functions [`trust`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L47), [`distrust`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L58), and [`trustedNodesLength`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L84) are wrong, suggesting that the size of the array is never decreased and that new trusted nodes are inserted into empty slots.\n\n\nIn the comment of the [`support`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203) [function of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203) [`PolicyProposals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203), it says that if the stake cannot be increased, the function will do nothing. However, the actual behavior is to revert when the call fails to increase the stake.\n\n\nThe comment from the [`DepositCertificates`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L15) contract states that the contract instance is cloned by the `Inflation` contract when a deflationary action is the winner. However, the `CurrencyGovernance` contract is the one that does that during the [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L398) function.\n\n\nThe [`certificatesTotal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L94) [variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L94) in the `DepositCertificates` contract is the maximum deposit amount the contract will accept, whereas the [`totalDeposit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L82) [variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L82) is the amount currently deposited. The variable comments indicate the opposite.\n\n\nConsider updating the comments to describe the actual behavior.\n\n\n***Update:*** *All the comments mentioned above were fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11722",
      "title": "[P3-L15] Unused variables",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `CurrencyGovernance` contract, there are two unused variables. Firstly, the [`REVEAL_TIME`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L26) [constant](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L26) is declared but never used. Secondly, the [state variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L120) [`randomVDFDifficulty`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L120) is instantiated in [L435](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L435), but other than that, it is never used.\n\n\nSimilarly, in the `PolicyVotes` contract, the [`LOCKUP_TIME`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L51) [constant](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L51) is declared but never used.\n\n\nConsider removing all the unused code to reduce the size of the contracts and to make them clearer.\n\n\nThe [`winners`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L54) variable of the `CurrencyGovernance` contract is a slightly different situation. It is declared as an internal state variable, but it is only used inside the [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) function.\n\n\nConsider declaring the `winners` variable inside the `computeVote` function.\n\n\n***Update:*** *Fixed. The `REVEAL_TIME` constant and the `randomVDFDifficulty` state variable were removed from the [`CurrencyGovernance` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol). The `LOCKUP_TIME` constant was removed from the [`PolicyVotes` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol). The [`winners` variable is now declared in the initiateInflationCycle function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol#L422).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11721",
      "title": "[P3-L14] Duplicated statements",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the [`withdrawalAvailableFor`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L226) function of the `DepositCertificates` contract, there are two different `if` statements that check the same condition — whether or not the certificate term has expired. If so, `_availableBalance` is [set to the total interest earned](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L257) and then later, [incremented by the principal](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L258), indicating that the user can withdraw all locked funds.\n\n\nConsider merging the two operations into a single code block under one conditional.\n\n\nIn the `reveal` function of the `PolicyVotes` contract, there is a duplicated loop — first in [L125](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L125) and then in [L138](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L138). This wastes gas and makes the code harder to understand.\n\n\nConsider removing the second loop by moving the statement in [L139](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L139) to the end of the first loop.\n\n\nIn the `computeVote` function of the `CurrencyGovernance` contract, there are duplicated calculations:\n\n\n* The number of non-zero inflation votes is independently calculated in [L357](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L357) and [L359](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L359).\n* The number of non-zero certificate votes is independently calculated in [L386](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L386) and [L388](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L388).\n* The shift of the `mid` variable to the relevant section of the `_certificatesTotalOrder` array is independently calculated in [L389](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L389) and [L393](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L393).\n\n\nConsider assigning the calculations to a variable in a common code block instead of duplicating the code.\n\n\n***Update:*** *Partially fixed. The loops were removed from the [`reveal` function of the `PolicyVotes` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L112). The other duplicated statements are still present. Eco’s statement for this issue:*\n\n\n\n> \n>  The Solidity optimizer isn’t great, and function dispatch can be inefficient. In a few places we duplicate code instead of abstracting it into a function to save on gas costs.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11720",
      "title": "[P3-L13] Inconsistent use of the onlyClone modifier",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the Eco system, most of the contracts that are executed are clones, instantiated for a one-time use only and then destructed. There is an [`onlyClone`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/policy/Policed.sol#L30) [modifier](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/policy/Policed.sol#L30) that prevents a function from being executed on the original contract. This modifier is correctly used on the cloned contracts to prevent the original from self-destructing. However, it is also used on a couple of other functions that will not destruct the original, like [configure](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L199).\n\n\nThis inconsistent use is confusing. It makes no sense to execute most of the functions on the original contracts, so consider adding the `onlyClone` modifier to all the functions that are intended for clones only.\n\n\n***Update:*** *Not Fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  It definitely doesn’t make sense to call these functions on the original contracts, but checking at every call would increase the gas cost for those calls. Since there’s no negative impact on the system resulting from functions being called on original contracts, we prefer to save the gas on clone calls at the expense of not reverting for invalid ones to the original contracts.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11719",
      "title": "[P3-L12] Units of variables are not clear",
      "impact": "LOW",
      "content": "###### Low\n\n\nWhen writing code for Ethereum, there are usually at least two units at play: wei and the basic unit of a token specific to the system. Often, percentages and the count of other items are also used.\n\n\nIn many places of the Eco system it is not clear what the units of the variables and parameters are, such as in [`inflation`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L46), [`prize`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L50), [`certificatesTotal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L58), and [`interest`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L62).\n\n\nConsider clarifying which unit they are using in the comments of the variables and parameters of the system .\n\n\n***Update:** Fixed. The variables now have comments indicating their units.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11718",
      "title": "[P3-L11] Redundant addresses in structs",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `PolicyVotes` contract, there is a [`Prop`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L26) [struct](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L26) and a [`proposals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L33) [mapping](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L33). The key of the mapping is the address of a proposal, and the value of the mapping is the `Prop` struct which stores the same address and the amount staked. Something similar happens in the `PolicyProposals` contract where its own [`Props`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L30) [struct](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L30) and [`proposals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L48) [mapping](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L48) duplicate and store the same address.\n\n\nThis redundancy is needed because mappings [“are virtually initialised such that every possible key exists and is mapped to a value whose byte-representation is all zeros”](https://solidity.readthedocs.io/en/v0.5.9/types.html#mapping-types). Therefore, it is necessary to store a value on the struct that will indicate if the proposal is in the mapping or not.\n\n\nHowever, using the address for this makes the code a little more complicated. Consider using a boolean named `exists` in the struct instead of the address. This will make the pattern clearer and more readable, while avoiding duplicating the address.\n\n\n***Update:** Partially fixed. The proposals mapping was removed from the [`PolicyVotes` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol). The `PolicyProposals` contract still has the [`proposals` mapping duplicating the address](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L49).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11717",
      "title": "[P3-L10] Important state variables are not public",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `Inflation` contract, the [`generation`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L44) [state variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L44) is used to get a historical token balance from the address registering for inflation payouts. Similarly, the [`generation`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L98) [state variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L98) in the `PolicyProposals` contract and the [analogous one](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L88) in the `PolicyVotes` contract are used to get a historical token balance from the address supporting a proposal.\n\n\nThese variables are not public, which makes them hard to read for users and contracts building on top of them. They are important to understand the state of the contracts and for the stakeholders to make informed decisions before making their transactions.\n\n\nConsider giving easier access to the `generation` variables by making them public.\n\n\n***Update:*** *The `generation` state variables are now public in the [`Inflation`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/Inflation.sol#L45), [`PolicyProposals`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L95), and [`PolicyVotes`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L96) contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11716",
      "title": "[P3-L09] Slightly biased inflation lottery",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe `Inflation` contract achieves inflation by pseudo-randomly distributing the funds among token holders in proportion to their holdings (at the previous generation in the balance store).\n\n\nTo achieve this, it first allows anyone to [register a lottery ticket](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L168) on behalf of any token holder. Each ticket is assigned a range of unique winning numbers, where the size of the range is equal to the number of tokens held. Subsequently, it divides the inflation funds evenly among a series of lotteries and allocates each jackpot to the holder of the ticket containing the pseudo-randomly chosen winning number.\n\n\nHowever, the mapping from pseudo-random number to lottery ticket is slightly biased towards lower winning numbers, corresponding to a slight bias in favor of early registrants. Specifically, if we define the total number of winning numbers as `N`, the lottery chooses a uniformly distributed 256-bit pseudo-random number `R` and [reduces it modulo](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L293-L295) [`N`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L293-L295). Whenever `N` does not evenly divide `2**256`, the largest possible 256-bit number will map to some value between `0` and `N`. Numbers less than this value can be reached from one more possible `R` than numbers above this value.\n\n\nThis effect is very small for large values of `2**256 / N` and is unlikely to be important in practice. Nevertheless, it is a provable bias in the lottery. Consider discarding the range of `R` values that do not map evenly to numbers between `0` and `N` and choosing another pseudo-random number.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  We agree that this is a problem. Since we know that the inflation lottery is going to change to reflect new thinking on economic governance, we’re deferring fixing this until our second audit.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11715",
      "title": "[P3-L08] Unnecessary require statement",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `withdrawFor` function of the `DepositCertificates` contract, there are four `require` statements that check if a withdraw can be executed.\n\n\nThe [second](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L279) [`require`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L279) [statement](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L279) checks if the current time is greater than or equal to the end of the sale. The [fourth](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L287) [`require`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L287) [statement](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L287) checks if the current time is greater than or equal to the end of the sale plus one interest period. Therefore, the second `require` statement is unnecessary.\n\n\nConsider deleting the unnecessary `require` statement.\n\n\n***Update:*** *[Fixed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/DepositCertificates.sol#L288).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11714",
      "title": "[P3-L07] Wrong variable type in an event",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`Sale`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L36) [event](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L36) of the `DepositCertificates` contract is declared with a `uint256` as the second parameter.\n\n\nThis event is only used in the [`deposit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L142) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L142), which passes a `uint128` variable as the second argument.\n\n\nConsider changing the parameter of the event to be `uint128`.\n\n\n***Update:*** *[Fixed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/DepositCertificates.sol#L35).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11713",
      "title": "[P3-L06] SafeMath used for uint128 variables",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.3.0/contracts/math/SafeMath.sol) [contract of OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.3.0/contracts/math/SafeMath.sol) protects against overflows and underflows but only for operations on `uint256` variables.\n\n\nIn [line 28 of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L28) [`DepositCertificates`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L28) [contract,](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L28) it is declared that `SafeMath` will be used for `uint128` operations, which would be problematic. However, in this contract, no `SafeMath` operations on `uint128` are executed.\n\n\nConsider removing the statement that declares the use of `SafeMath` for `uint128` variables.\n\n\n***Update:** Fixed. Now [`SafeMath` is used for `uint256` variables](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/DepositCertificates.sol#L27).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11712",
      "title": "[P3-L05] No easy way to get the number of committed or discarded votes",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `CurrencyGovernance` contract, [when a new vote is committed, the number of](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L471) [`totalVoters`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L471) [is increased by 1](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L471). Then, during the reveal phase, [when an invalid vote is discovered, this same](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L525) [`totalVoters`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L525) [variable is decreased by 1](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L525).\n\n\nReusing this variable makes it harder after the reveal phase to get the number of committed and discarded votes. These values can be calculated by getting the event logs or by looking at the state of the contract in the past, but this is not straightforward. Getting these values quickly could be important for checking the health and security of the system or for other contracts building on top of it.\n\n\nConsider using separate public variables for the number of committed votes and the number of discarded votes.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> \n>  We will likely be replacing this entire mechanism before launch. Subsequent feedback on the currency governance system has led us to refine certain processes which may represent larger changes, so we want to hold off on the smaller fixes for the time being.\n> \n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11711",
      "title": "[P3-L04] Confusing reorder function",
      "impact": "LOW",
      "content": "###### Low\n\n\nOnce a vote in the `PolicyVotes` contract has finished and has been executed, the proposals with enough staked tokens are enacted. In this contract, there is also a [`reorder`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L148) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L148) that can alter the order in which the proposals are enacted.\n\n\nHowever, it is not clear why a new order is needed, when the proposals should be reordered, or how the sender decides the new order.\n\n\nConsider adding comments to explain the purpose of this function in further detail.\n\n\nNote: The Eco team is planning to stake on only one proposal at a time and to remove the `reorder` function.\n\n\n***Update:*** *Fixed. Now only one proposal at a time is staked, and the `reorder` function was removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11710",
      "title": "[P3-L03] Missing time requirement to challenge",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `PolicyVotes` contract, [there are state variables that define the time intervals](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L72-L84) for the different phases of the policy decision process. Those variables are `holdEnds`, `voteEnds`, `revealEnds`, and `challengeEnds`.\n\n\nThe [comment of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L82) [`challengeEnds`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L82) variable says that it is used to define when the veto period ends, but it is never used in the [`challenge`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245). Furthermore, this function does not have any type of time requirement. Based on how the other functions work, it should be possible to `challenge` proposals only during the `CHALLENGE_TIME`.\n\n\nConsider adding a time requirement in the [`challenge`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245) that allows challenging proposals before the `challengeEnds` timestamp. It could make sense to also require that the `holdEnds` or the `revealEnds` timestamps have passed.\n\n\n***Update:*** *Fixed. The `challenge` function now [requires that the `revealEnds` timestamp has passed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L211). However, note that the state transitions in this contract are still confusing and prone to error, as explained in **“*****[M3-09] Confusing phase transitions”**.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11709",
      "title": "[P3-L02] Confusing operation to update the no-confidence stake",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `PolicyVotes` contract, it is possible to [`challenge`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245) all the proposals. When this happens, the token balance of the challenger set at a specific historical time when the contract was [`configured`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L207) is added to the `noConfidenceStake`.\n\n\nThis function is confusing, because it subtracts the amount previously staked by the sender and adds the new amount. Also, it checks that the new stake is higher than the previous value. However, the amount is always taken from the same historic balance, so the sender can only go from 0 stake to everything staked.\n\n\nConsider making this function clearer by requiring that the sender has not challenged the proposals yet and that it held tokens at the configured time. In that case, the balance can just be added to the `noConfidenceStake` without the comparison and the subtraction.\n\n\n***Update:** Fixed. The [`challenge` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L208) now has the suggested checks and is simpler and clearer.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11708",
      "title": "[P3-L01] Top proposals are recalculated every time one is supported",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `PolicyProposals` contract, the [`best`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L61) [array](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L61) stores the top 3 most supported proposals. Every time somebody supports a proposal, the [top 3 are recalculated](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L228). This increases the gas costs of supporting a proposal, and in many cases, it could be wasted work.\n\n\nConsider moving the calculation of the top 3 proposals after the staking phase ends, doing it only once in the [`compute`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L250) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L250).\n\n\nNote: The Eco team is planning to select only one proposal out of this voting phase. In that case, there is no need to sort the proposals every time `support` is called. The most staked proposal can be kept in a simple variable updated in the `support` function, or it can be found at the end with a simple loop in the `compute` function.\n\n\n***Update:*** *Fixed. The [`best` variable](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L62) is now a single address. It is [kept up-to-date by the `support` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L244).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11707",
      "title": "[P4-M14] Contracts not using safe math",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe contracts [`CurrencyGovernance`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol) and [`Inflation`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol) do not use [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.3.0/contracts/math/SafeMath.sol) to prevent overflows and underflows in arithmetic operations. They have a comment at the top that says, “Humongous Safety Warning: This does not check for math overflow anywhere.” This comment is more alarmist than informative.\n\n\nThe contract [`DepositCertificates`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol) uses `SafeMath` intermittently.\n\n\nThe contracts [`PolicyProposals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol), [`TrustedNodes`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol), and [`PolicyVotes`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol) neither use `SafeMath` nor have safety warning comments. `PolicyProposals` contains [a decrement that may underflow](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L305) in some scenarios.\n\n\nThe only valid reason for not using `SafeMath` is that the design of the system makes it impossible for overflows or underflows to occur. But even in that case, the only way to prove it is with extensive formal verifications, and a mistake in any place of the system could be catastrophic.\n\n\nConsider being extra safe by adding `SafeMath` operations to all the arithmetic operations in all the contracts.\n\n\nIf that becomes significantly more expensive, then consider adding a comment to every statement with an arithmetic operation explaining why it is safe. Ideally, these claims would be accompanied by a formal verification.\n\n\n***Update:** Fixed. All the contracts are now using `SafeMath` for all their arithmetic operations that can overflow or underflow.*",
      "summary": "\nThis bug report is about the lack of use of the 'SafeMath' function in the contracts 'CurrencyGovernance', 'Inflation', 'DepositCertificates', 'PolicyProposals', 'TrustedNodes' and 'PolicyVotes'. 'SafeMath' is a smart contract function that is used to prevent overflows and underflows in arithmetic operations. The report states that the contracts 'CurrencyGovernance' and 'Inflation' do not use 'SafeMath' and have a comment at the top which is more alarmist than informative. The contract 'DepositCertificates' uses 'SafeMath' intermittently and the other contracts neither use 'SafeMath' nor have safety warning comments. The report suggests that these contracts should use 'SafeMath' for all their arithmetic operations that can overflow or underflow. It also suggests that if that becomes too expensive, then the contracts should add a comment to every statement with an arithmetic operation explaining why it is safe. The report has been updated to state that the issue has been fixed and all the contracts are now using 'SafeMath' for all their arithmetic operations that can overflow or underflow.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11706",
      "title": "[P3-M13] Unbounded loops",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nMultiple `for` loops are bounded by a variable that does not have a maximum value:\n\n\n* In `CurrencyGovernance`, the loops in [L266](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L266) and [L313](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L313) are bounded by the number of trusted nodes.\n* In `Inflation`, the loop in [L111](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L111) is bounded by the number of `winners` resulting from a vote.\n* In `PolicyVotes`, the loops in [L125](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L125), [L138](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L138), [L160](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L160), [L210](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L210), and [L277](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L277) are bounded by the number of candidate proposals.\n\n\nThese variables are supposed to be small. For example, according to the Eco team, the initial number of trusted nodes is going to be around 20. In order to add more trusted nodes, a proposal needs to be voted on. The number of winners is selected after a vote in which only trusted nodes can participate. Because they are trusted, this is likely to be a reasonable number that does not break the system. The maximum number of proposals that go into `PolicyVote` is [set to 3 by the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L81) [`PolicyProposals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L81) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L81).\n\n\nHowever, there is nothing in the contracts of those loops that enforces a maximum value. Actors and proposals can be malicious or make mistakes, and the loops could get too big. Therefore, the system is susceptible to hit the maximum `gas` limit, which would prevent critical functions to execute.\n\n\nConsider defining and documenting a safe maximum value for the upper bound on every loop, to guarantee the correct functionality of the contracts.\n\n\n***Update:** Partially fixed. One of the loops in the `CurrencyGovernance` contract and all of the loops in the `PolicyVotes` contract have been removed. Comments about the bounds were added to all the other loops. However, note that the bounds are still not enforced on-chain.*",
      "summary": "\nThis bug report is about the potential for malicious actors or mistakes in the code of the Beam Network's currency contracts to cause the system to exceed its maximum gas limit. The code in question contains multiple `for` loops that are bounded by a variable with no maximum value. These variables are intended to be small, such as the initial number of trusted nodes being around 20. However, the code does not enforce a maximum value, making it possible for the loops to get too large and cause the system to hit its maximum gas limit.\n\nTo address this issue, the report suggests defining and documenting a safe maximum value for the upper bound on each loop, to guarantee the correct functionality of the contracts. The issue has since been partially fixed, with one of the loops in the `CurrencyGovernance` contract and all of the loops in the `PolicyVotes` contract being removed, and comments about the bounds being added to all the other loops. However, the bounds are still not enforced on-chain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11705",
      "title": "[P3-M12] Events not emitted for important state changes",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn Solidity, events are used to log important state changes on the contracts. Users of the contracts can subscribe and be notified when these events happen. They are also useful to analyze the historic transactions and to find issues or potential problems.\n\n\nSome of the important state changes of the Eco contracts do not emit events.\n\n\nConsider emitting events at the end of the following functions:\n\n\n* In `PolicyProposals.sol`: [`support`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203) and [`refund`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L290)\n* In `PolicyVotes.sol`: [`reveal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L100), [`commit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223), [`challenge`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L245), and [`execute`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L266)\n* In `TrustedNodes.sol`: [`trust`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L47) and [`distrust`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/TrustedNodes.sol#L58)\n\n\n***Update:*** *Fixed. The events were added and are now emitted by the corresponding functions: [`ProposalSupported`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L246), [`ProposalRefunded`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L316), [`PolicyVoteRevealed`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L137), [`PolicyVoteCommitmentRecorded`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L203), [`PolicyVoteChallenged`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L203), [`VoteCompleted`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyVotes.sol#L269), [`TrustedNodeAdded`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/TrustedNodes.sol#L52), and [`TrustedNodeRemoved`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/TrustedNodes.sol#L82).*",
      "summary": "\nThis bug report is about the Solidity programming language. Solidity is a programming language used to create smart contracts on the Ethereum blockchain. Events are used to log important state changes on the contracts and users of the contracts can subscribe and be notified when these events happen. \n\nThe bug report states that some of the important state changes of the Eco contracts do not emit events. The report suggests emitting events at the end of the functions in the following files: PolicyProposals.sol, PolicyVotes.sol, and TrustedNodes.sol. \n\nThe bug has now been fixed and the events have been added and are now emitted by the corresponding functions in the files mentioned above.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11704",
      "title": "[P3-M11] Missing incentives to complete the voting process",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the `CurrencyGovernance` contract, in order to complete the voting process, the trusted nodes have to [`commit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L448) votes, and then, somebody has to [`reveal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L492) them. Finally, somebody has to call the [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) function. Similarly, in the `PolicyVotes` contract, the stakeholders have to [`commit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223) votes and then [`reveal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L100) them, and finally somebody, has to call the [`execute`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L266) function. These functions require work and money to pay for the gas.\n\n\nThere are no direct incentives for any of the prospective callers. There are going to be external incentives, the Eco team can take care of calling some of these functions, and the intrinsic incentive of everybody who is part of the system to make it work can be very powerful. However, a more powerful system would have embedded incentives that are transparently written into the blockchain. As it is, the system depends on a traditionally centralized entity to put the incentives in place and to constantly care for them.\n\n\nConsider adding incentives to the voting protocol. An idea could be to give priority to the voters when disbursing the inflation prize or to purchase deposit certificates. Another could be to set up a [gas station network](https://blog.zeppelinos.org/gas-station-network-alliance/) that will be used to pay for the functions that finalize the voting, and that could be financed through the same minting process that ends a vote. At the very least, the external incentives should be described in the contracts, so voters know that they can trust the system to continue and not worry about their money being poorly managed due to neglect.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> In the launch version of the system, trustees will be compensated. Compensation will be conditional on revealing a valid vote.\n> \n>",
      "summary": "\nThe `CurrencyGovernance` and `PolicyVotes` contracts are part of the Beam Network, and they require users to \"commit\" and \"reveal\" votes, and for somebody to call the \"computeVote\" and \"execute\" functions. However, there are no direct incentives in place for people to do this, and the system currently depends on a centralized entity to provide external incentives. It is suggested that incentives be added to the voting protocol, such as priority for disbursing the inflation prize or purchasing deposit certificates, or setting up a gas station network to pay for the functions that finalize the voting. At the very least, the external incentives should be described in the contracts so that voters are aware of them. The Eco team has stated that trustees will be compensated in the launch version of the system, and that compensation will be conditional on revealing a valid vote.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11703",
      "title": "[P3-M10] Contracts can be destructed",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nAll the cloned contracts of the [`inflation`](https://github.com/BeamNetwork/currency/tree/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation) module can be destructed. This happens when the contract has successfully finished all its responsibilities and is no longer needed.\n\n\nThe contracts are cloned just for a one-time usage, so there is no risk of other contracts internal to the Eco system that are depending on them. If they hold a policy role in the network, they remove themselves before calling `selfdestruct`; if they hold ether, it is transferred to the policy contract.\n\n\nThe `selfdestruct` happens in a very controlled way. However, it still is a very extreme action with no way to rollback. There could be a bug in the system that allows a call to `selfdestruct` before it is supposed to happen. This could leave a very important vote without the code that should execute it. And because the functions are not always verifying the sender, other kinds of bugs could let the wrong people destruct a contract. Not all of the contracts transfer the Eco tokens they might hold, so destructing them could lock the tokens transferred by mistake forever. Finally, even if the contracts are no longer useful for the Eco system, they could be useful for historical purposes or for other systems building on top of it.\n\n\nConsider the more conservative approach of disabling the contracts instead of destructing them. Alternatively, consider allowing only trusted destroyers to call `selfdestruct`. Consider adding functions to recover tokens transferred by mistake.\n\n\n***Update:*** *Not fixed.*",
      "summary": "\nThe bug report describes a situation in which contracts in the [`inflation`](https://github.com/BeamNetwork/currency/tree/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation) module can be destructed when they are no longer needed. This can cause a number of problems, such as a bug that allows a call to `selfdestruct` before it is supposed to happen, or the wrong people destructing a contract. Furthermore, if the contracts hold Eco tokens, they may not be transferred and could be locked forever. \n\nThe report suggests considering a more conservative approach of disabling the contracts instead of destructing them, allowing only trusted destroyers to call `selfdestruct`, and adding functions to recover tokens transferred by mistake. As of yet, the bug has not been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11702",
      "title": "[P3-M09] Confusing phase transitions",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [inflation](https://github.com/BeamNetwork/currency/tree/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation) module of the Eco system is characterized by having clearly defined phases. For example, there is a commit phase, a reveal phase, a challenge phase, and a refund phase. Usually, at the end of the process, there is a destruct phase in which the contract is no longer useful. It is removed from the policy network and destructed.\n\n\nThese phases are critical for the success of the governance of the monetary processes and the policy network. However, the transitions between the phases are not so clear. Most of the functions will start with a set of `require` statements that ensure that they are executed only when the time-based and state-based constraints are satisfied. There are so many constraints of different sorts that it is hard to think about the possible phases, the things that trigger a transition, and which correct phase follows.\n\n\nConsider modeling the system as a [finite-state machine](https://en.wikipedia.org/wiki/Finite-state_machine) and refactoring the code to make this model clearly visible. The `require` statements could then be grouped into state-checking functions that return `true` if the system is in a specified state. Then, every action could be guarded by a single check to verify that the system is in the correct state and could end up updating the system to the next state.\n\n\nThe code would become more readable, it would be easier to analyze the system as a whole, and it would open the door to interesting new options like formally verifying all the state transitions.\n\n\n***Update:*** *Partially fixed. The [`atStage` modifier](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol#L177) was added to make the transitions of the `CurrencyGovernance` contract clearer. The other contracts are still using the unclear stage transitions. Eco’s statement for this issue:*\n\n\n\n> We agree that the code here is complicated and could be cleaner. We’re anticipating changes in this part of the system before we launch, and will take OpenZeppelin’s advice into consideration as we adapt the code to those changes.\n> \n>",
      "summary": "\nThe inflation module of the Eco system is characterized by having clearly defined phases. These phases are key for the success of the governance of the monetary processes and the policy network, however, the transitions between the phases are not so clear. It is proposed that the system should be modeled as a finite-state machine and refactored so that the code becomes more readable and the system is easier to analyze. The `require` statements could be grouped into state-checking functions that return `true` if the system is in a specified state and then every action could be guarded by a single check. This would open the door to new possibilities like formally verifying all the state transitions. A `atStage` modifier was added to make the transitions of the `CurrencyGovernance` contract clearer, however, the other contracts are still using unclear stage transitions. Eco is aware of this issue and is anticipating changes in this part of the system before launch, taking advice into consideration as they adapt the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11701",
      "title": "[P3-M08] Duplicable votes",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the [`commit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223) [function of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223) [`PolicyVotes`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L223), a token holder can commit to a vote that supports a subset of the proposals on the ballot. The commitment is a `keccak256` hash of the approved proposals with a random salt to provide entropy. Later, the token holder can [`reveal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L100) their vote and salt so it can be compared to the commitment and then processed if valid.\n\n\nHowever, the commitment is not cryptographically tied to the token holder address. This means it is possible for a token holder to copy and submit another voter’s commitment without knowing the contents. When the original voter reveals their vote and salt, the copycat can reveal the same values.\n\n\nConsider including the voter address within the hash commitment to prevent duplication.\n\n\nSimilarly, in the [`commit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L448) [function of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L448) [`CurrencyGovernance`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L448) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L448), a trusted node can commit to an encrypted vote and the VDF seed that was used to generate the encryption key. When the voter (or anyone else) [`reveals`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L492) the VDF output, it can be used to decrypt and process the vote.\n\n\nOnce again, the encrypted vote is not cryptographically tied to the voter’s address, which means anyone can reuse the commitment and corresponding VDF seed without knowing the contents.\n\n\nConsider including and verifying a hash of the voter address and their chosen parameters within the encrypted vote to prevent duplication. It is important to note that encrypting the voter address directly will not prevent vote duplication — it should be hashed, along with the vote parameters first.\n\n\nAlthough simply encrypting the voter address will prevent direct duplication, it does not mitigate targeted modification of the ciphertext. When using a stream cipher for encryption (as the `CurrencyGovernance` contract does), a change in a particular location of the ciphertext will produce a corresponding change in the same location in the plaintext.\n\n\nNote that we can segment the key stream created by [`keyExpand`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L577) and the ciphertext using the corresponding plaintext section:\n\n\n\n```\nplaintext  = p_inflation || p_prize || p_certificates || p_interest\nkeystream  = k_inflation || k_prize || k_certificates || k_interest\nciphertext = c_inflation || c_prize || c_certificates || c_interest\n```\n\nThen,\n\n\n\n```\nciphertext  =  plaintext  ^  keystream\n```\n\nbecomes:\n\n\n\n```\nc_inflation  =  p_inflation  ^  k_inflation\nc_prize  =  p_prize  ^  k_prize\nc_certificates  =  p_certificates ^  k_certificates\nc_interest  =  p_interest  ^  k_interest\n```\n\nAdding the voter address simply adds one more sub-encryption to the list:\n\n\n\n```\nc_voter  =  p_voter  ^  k_voter\n```\n\nThere are two important observations:\n\n\n1. Flipping bits in **c\\_voter** will produce corresponding bit flips in the decrypted **p\\_voter**.\n2. This will not affect the decryption of any of the other parts of the ciphertext.\n\n\nNotably, the copycat could construct a ciphertext that would replace the voter address in the corresponding plaintext with their own:\n\n\n\n```\nc'_voter  =  c_voter  ^  p_voter  ^  [copycat address]\n```\n\nThis will now decrypt to the copycat address:\n\n\n\n```\np'_voter  =  c'_voter  ^  k_voter\n          =  c_voter  ^  p_voter  ^  [copycat address]  ^  k_voter\n          =  p_voter  ^  ( c_voter ^ k_voter )  ^  [copycat address]\n          =  p_voter  ^  p_voter  ^  [copycat address]\n          =  0  ^  [copycat address]\n          =  [copycat address]\n```\n\nSince the rest of the plaintext will be unchanged, this allows the copycat to use another vote as their own.\n\n\nIn fact, using this method, they could make targeted modifications to another vote provided the modifications can be described as a bitwise change. For example, they could toggle the high bit of the prize chosen by a target voter without knowing the original parameters.\n\n\nThis attack is possible whenever the copycat wants to change a predictable part of the underlying plaintext. Including and verifying a hash of all parameters and the voter address ensures that any modification will be detected.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> We’ll be removing this obfuscation mechanism before launch.\n> \n>",
      "summary": "\nThis bug report is about two functions, `commit` and `reveal`, in two contracts `PolicyVotes` and `CurrencyGovernance` of the Beam Network. The `commit` function allows a token holder to commit to a vote by creating a `keccak256` hash of the approved proposals with a random salt. The `reveal` function allows the token holder to reveal their vote and salt so it can be compared to the commitment and then processed if valid.\n\nHowever, the commitment is not cryptographically tied to the token holder address which means it is possible for a token holder to copy and submit another voter’s commitment without knowing the contents. Similarly, in the `CurrencyGovernance` contract, a trusted node can commit to an encrypted vote and the VDF seed that was used to generate the encryption key. Once again, the encrypted vote is not cryptographically tied to the voter’s address, which means anyone can reuse the commitment and corresponding VDF seed without knowing the contents.\n\nTo prevent this duplication, the bug report suggests including and verifying a hash of the voter address and their chosen parameters within the encrypted vote. It also suggests segmenting the key stream created by `keyExpand` and the ciphertext using the corresponding plaintext section.\n\nThe bug report also mentions that simply encrypting the voter address will not prevent vote duplication and that it should be hashed, along with the vote parameters first. It also mentions that encrypting the voter address directly will not prevent targeted modification of the ciphertext.\n\nThe update states that this issue has not been fixed yet and that the obfuscation mechanism will be removed before launch.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11700",
      "title": "[P3-M07] Ticket Registration emits the incorrect ticket number",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the `registerFor` function of the `Inflation` contract, the registrant is [assigned a ticket immediately after the contract emits the corresponding event](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L184-L186). However, the event uses 0-up indexing, whereas the `holders` mapping, which can be used to look up the ticket associated with an address, uses 1-up indexing.\n\n\nThis means the two mechanisms for determining the ticket associated with an address are inconsistent with each other. Consider using 1-up indexing in the `TicketsRegistered` event.\n\n\n***Update:** [Fixed](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/Inflation.sol#L197).*",
      "summary": "\nThe `Inflation` contract contains a `registerFor` function which assigns a ticket to the registrant immediately after the corresponding event is emitted. However, the event uses 0-up indexing while the `holders` mapping, which is used to look up the ticket associated with an address, uses 1-up indexing. This inconsistency between the two mechanisms caused an issue. To fix the problem, the `TicketsRegistered` event was updated to use 1-up indexing. The issue has now been resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11699",
      "title": "[P3-M06] Rejected votes can affect currency governance",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`reveal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L492) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L492) of the `CurrencyGovernance` contract ensures that the voter did not choose a non-zero value for both inflation and the number of certificates to issue.\n\n\nHowever, there are other combinations of parameters that can affect the vote unexpectedly. In particular, it is possible to vote for inflation (or neither inflation nor deflation) and still choose a high interest. If the deflation vote succeeds, the interest chosen by the inflation voter is still used when calculating the median, provided it is higher than the lowest value chosen by a deflation voter. In this case, the deflation voter’s choice is discarded. Similarly, it is possible to vote for deflation (or neither) and still choose a high prize, which will be considered in the same way if the inflation vote succeeds.\n\n\nIt may seem counterproductive to vote in this way but there are potential game-theoretic reasons (e.g., a [pre-commitment](https://effectiviology.com/precommitment/) to an outrageous result on one side of the vote). Regardless, it is preferable to prevent undesirable results where possible rather than rely on assumptions about how users will behave.\n\n\nThe [comment](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L483-L484) on the `reveal` function suggests that the function restricts inconsistent votes, but this is not enforced by the code.\n\n\nConsider requiring all voters to choose either inflation or deflation and to prevent or disregard non-zero values for `interest` and `prize` when they are inconsistent with the vote.\n\n\n***Update:*** *Fixed. The [`reveal` function now calls the `invalidVote` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol#L627), which requires votes to be consistent.*",
      "summary": "\nA bug was reported in the `CurrencyGovernance` contract's `reveal` function. This function is meant to ensure that a voter did not choose a non-zero value for both inflation and the number of certificates to issue. However, some combinations of parameters can affect the vote unexpectedly. For example, it is possible to vote for inflation (or neither inflation nor deflation) and still choose a high interest. If the deflation vote succeeds, the interest chosen by the inflation voter will be used when calculating the median, even if it is higher than the lowest value chosen by a deflation voter. Similarly, it is possible to vote for deflation (or neither) and still choose a high prize, which will be considered in the same way if the inflation vote succeeds.\n\nThe comment on the `reveal` function suggested that the function restricts inconsistent votes, but this was not enforced by the code. To fix this, the `reveal` function now calls the `invalidVote` function, which requires votes to be consistent. This ensures that all voters must choose either inflation or deflation and that non-zero values for `interest` and `prize` must be consistent with the vote.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11698",
      "title": "[P3-M05] Failed vote ends with no error",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) [function of the](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) [`CurrencyGovernance`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226), there are two cases when a failed vote ends with no error and instead emits a `VoteResults` event:\n\n\n* [The current contract is not the policy for](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L232) [`ID_CURRENCY_GOVERNANCE`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L232).\n* [The number of valid votes revealed is 0](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L254).\n\n\nThis is misleading, and it does not follow the principle of [failing as early and loudly as possible](https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702). It also produces the same behavior as a successful vote that ends in a tie, which may lead to confusion.\n\n\nConsider emitting a `VoteFailed` event on these cases and ensuring that `computeVote` cannot be called again.\n\n\n***Update:** Not fixed. Eco’s statement for this issue:* \n\n\n\n> In both of the cases covered the result of the vote is that 0 inflation is printed, 0 tokens are distributed to each prize winner, 0 tokens are accepted for deposit certificates, and 0 interest is paid on deposit certificates. We concluded that this is accurately represented by the `VoteResult(0,0,0,0)` event that the system emits, and the regular vote tally process already ensures that `computeVote` cannot be called a second time.\n> \n>",
      "summary": "\nThis bug report is about the `computeVote` function of the `CurrencyGovernance` contract. This function emits a `VoteResults` event when the current contract is not the policy for `ID_CURRENCY_GOVERNANCE` or when the number of valid votes revealed is 0. This behavior is misleading and does not follow the principle of failing as early and loudly as possible. It also produces the same behavior as a successful vote that ends in a tie, which may lead to confusion. The bug report suggests emitting a `VoteFailed` event on these cases and ensuring that `computeVote` cannot be called again. However, this has not been fixed yet. The reason for this is that the result of the vote is that 0 inflation is printed, 0 tokens are distributed to each prize winner, 0 tokens are accepted for deposit certificates, and 0 interest is paid on deposit certificates. This is accurately represented by the `VoteResult(0,0,0,0)` event that the system emits, and the regular vote tally process already ensures that `computeVote` cannot be called a second time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11697",
      "title": "[P3-M04] The function that computes votes is too long",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) in the `CurrencyGovernance` contract is almost 200 lines long.\n\n\nThere are too many statements in this function covering many different tasks, making it very hard to read and very prone to errors if it is changed in the future. It is the source of multiple issues found in this audit.\n\n\nConsider splitting this function into many smaller private functions with intent-revealing names. This would increase the cost of calling this already expensive function, but it is important in a function so sensitive as this one.\n\n\nIf the cost increases are considered prohibitive, try to find other ways to reduce the size of the function like separating it into different transactions, or at the very least, document the limitations that make the function so long.\n\n\n***Update:*** *Not fixed. Eco’s statement for this issue:*\n\n\n\n> We’ll be rewriting this before launch – we plan to move to a new vote tabulation algorithm.\n> \n>",
      "summary": "\nThis bug report is about the `computeVote` function in the `CurrencyGovernance` contract. The function is over 200 lines long, making it difficult to read and prone to errors if it is changed in the future. The bug report suggests splitting the function into multiple smaller private functions with intent-revealing names to make it easier to read and reduce the risk of errors. If the cost of calling the function increases too much, the bug report suggests finding other ways to reduce its size, like separating it into different transactions or documenting the limitations that make the function so long. The bug report has not been fixed yet, but it is planned to be rewritten and moved to a new vote tabulation algorithm before launch.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11696",
      "title": "[P3-M03] Lack of input validation",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the `SimplePolicySetter` contract, the [`set`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/SimplePolicySetter.sol#L34) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/SimplePolicySetter.sol#L34) is used to set the ERC20 key and address value that will update the system to use a new implementation contract.\n\n\nThis function does not verify that the key and address arguments passed are not 0, which in almost every case will be wrong values. Also, the docstring of the function says that it can only be called once, but without validation it can be called with arguments set to zero multiple times.\n\n\nConsider validating the arguments in this very sensitive function.\n\n\n***Update:*** *Partially fixed. The [`set` function now requires the `_key` argument to be different to 0](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/SimplePolicySetter.sol#L36). However, the `_value` argument can still be 0. Eco’s statement for this issue:*\n\n\n\n> Allowing 0 as a `_value` argument here is necessary to allow us to unset the value. We use this throughout our code to grant temporary privileges. User-provided values should always be sanitized before passing them to a `SimplePolicySetter` call to prevent significant security issues.\n> \n>",
      "summary": "\nThis bug report is about the `SimplePolicySetter` contract. This contract has a function called `set` which is used to set a new implementation contract. The issue is that this function does not verify that the key and address arguments passed are not 0, which usually will be incorrect values. The docstring of the function also says that it can only be called once, but without validation it can be called with arguments set to zero multiple times. A partial fix has been applied, which requires the `_key` argument to be different from 0. However, the `_value` argument can still be 0. It is advised to sanitize user-provided values before passing them to a `SimplePolicySetter` call to prevent security issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11695",
      "title": "[P3-M02] The non-refunded tokens are not transferred",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nIn the `PolicyProposals` contract, [registering proposals requires transferring tokens to this contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L180). Then, up to 3 proposals are selected to go to a second staking phase. The proposers of the unselected ones can [get a partial refund](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L308).\n\n\nIt is not clear what should happen to the tokens that cannot be refunded (i.e., the ones corresponding to the registration of the selected proposals and what remains after the refunds are processed). They are just held by the `PolicyProposals` contract, until it is [destroyed](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L315), and then, they are locked forever.\n\n\nConsider transferring these tokens after the top proposals are selected. If they should be locked forever, consider explicitly signalling this by transferring them to the 0 address.\n\n\n***Update:*** *Fixed. The `destruct` function now [transfers the tokens to the `policy` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L331). Note, however, that this behavior is not documented. It is not clear what happens to the tokens owned by the policy: Are they now owned by the Eco team? How can the `policy` contract transfer or use those tokens? Because these details might be unexpected or sensitive for some users, consider documenting them as explicitly as possible. Also, note that the transfer function could fail, and the contract would still be destroyed.*",
      "summary": "\nThis bug report is about the `PolicyProposals` contract in the BeamNetwork/currency repository. In this contract, users are required to transfer tokens to register proposals. Up to three proposals are then selected for a second staking phase, and the proposers of the unselected proposals can get a partial refund. The issue is that it is not clear what should happen to the tokens that cannot be refunded. \n\nThe update to this bug report states that the `destruct` function now transfers the tokens to the `policy` contract, however, this behavior is not documented. It is not clear who owns the tokens now, and how the `policy` contract can transfer or use those tokens. It is suggested to document this information as explicitly as possible, and also note that the transfer function could fail and the contract would still be destroyed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11694",
      "title": "[P3-M01] The proposal registration fee is staked",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nWhen the [`registerProposal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L168) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L168) of the `PolicyProposals` contract is called, a registration fee is transferred to the contract.\n\n\nThe fee is also added to the total stake supporting the proposal. This is confusing in two ways. Firstly, the proposal’s `staked` mapping is not updated, thereby creating a situation where there are staked tokens not assigned to anybody in particular. Secondly, if the proposer decides to [`support`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L203) their proposal, they will stake the tokens from their balance at the contract’s `generation`, which may include the tokens they already staked as part of the registration fee.\n\n\nWhether or not this is considered a bias in the result depends on if the registration fee is intended to be taken from the staked amount. If so, some proposers are double staking the tokens used to pay the registration fee, while others are staking tokens that they did not have at the contract’s `generation`. On the other hand, if the registration fee is intended simply as a deterrent against ill willed or spam proposals, it should not be treated as part of the stake.\n\n\nIn the first case, consider confirming the proposer had enough tokens in the contract’s `generation` before accepting the fee in the current generation. Also ensure that the `support` function does not add tokens that were part of the registration fee.\n\n\nIn the second case, consider setting the proposal’s initial stake to the proposer’s balance at the contract’s `generation` and updating the proposal’s `staked` mapping accordingly. Alternatively, to retain the option of the proposer choosing not to support their proposal, consider leaving the proposal’s initial stake at zero.\n\n\n***Update:*** *Fixed. The [`registerProposal` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L182) now leaves the initial stake at zero.*",
      "summary": "\nA bug was reported in the `registerProposal` function of the `PolicyProposals` contract. The bug caused a registration fee to be transferred to the contract, which was also added to the total stake supporting the proposal. This created a situation where there were staked tokens not assigned to anybody in particular, and if the proposer decided to support their proposal, they could be double staking the tokens used to pay the registration fee.\n\nThe bug was fixed by updating the `registerProposal` function to leave the initial stake at zero. This ensures that the proposer had enough tokens in the contract’s `generation` before accepting the fee in the current generation, and that the `support` function does not add tokens that were part of the registration fee.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11693",
      "title": "[P3-H02] Executed policy proposals have full control over the system",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe Eco system is built from a registry of policy contracts. Every 40 days, a voting over policy proposals can take place. The voting has two staking phases. At the end of the voting, [3 proposals can be enacted](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyVotes.sol#L280) if they have more stake than the no-confidence vote and more than 3/4 of the total staked. When a proposal is enacted, it will immediately replace one of the policy contracts, and it can only be removed following the same voting procedure.\n\n\nThis means that a new contract can take full control over a part of the system functionality. For example, the new enacted proposal could add or remove trusted nodes for the monetary vote, it could change the rules or frequency of the votes, or it could completely replace the token.\n\n\nIt is expected that the token holders will not put their stake on proposals that will break the system. But humans are known for making bad decisions collectively once in a while. And even if the proposals are extensively discussed, votes carefully thought out, and many people voting for what appears to be a good decision out of the wisdom of the crowd, it is possible for the proposal to have issues that will have unintended consequences that nobody noted until they were enacted.\n\n\nRegistering a proposal for voting requires spending a lot of tokens, but anybody who can get that amount of tokens can register one. In addition, all the token holders will be able to stake in favor of proposals. This is a very interesting and radical approach for transparent and decentralized governance. However, there is a lot of risk in allowing the token holders to decide directly over the execution of all the functions of the system.\n\n\nConsider adding the role of trusted auditors and adding an extra phase to the policy proposal process to allow the auditors to review the proposed contracts. The auditors would not have any control over the results of the vote. They would just review that the contracts do exactly what the proposers intend them to do — that there are no bugs and that they will not break the Eco system. After a successful audit, the proposal can be whitelisted, and only whitelisted proposals should be enacted.\n\n\n***Update:** Not fixed. Eco’s statement for this issue:*\n\n\n\n> In order to reduce the risks inherent in the policy proposals process, we’ve reduced the number of proposals that can be enacted in a given voting cycle from 3 to 1. This helps ensure that proposals do not conflict with each other – if multiple changes should be made at the same time, they need to be combined into a single proposal covering all of the changes to make in the voting cycle. We decided not to place any further restrictions on the process, because we don’t want to constrain the possible future directions ECO stakeholders may take the currency after launch.  \n> \n> We considered the creation of a trusted auditor role as suggested in the report, but came to the conclusion that this sort of arrangement is better handled off-chain. By enforcing the auditor role on-chain, we would introduce the challenges of managing which auditors are trusted using the governance process itself. We would have to rely on the auditor to approve a proposal that replaces the auditor, which is more than a small conflict of interest.  \n> \n> Instead, we rely on our community to demand an audit, and vote down any proposal that has not been thoroughly audited by someone they trust.\n> \n>",
      "summary": "\nThe Eco system is a registry of policy contracts that are voted on by token holders every 40 days. Up to 3 proposals can be enacted if they have more stake than the no-confidence vote and more than 3/4 of the total staked. This means that a new contract can take full control over a part of the system functionality, such as adding or removing trusted nodes for the monetary vote, changing the rules or frequency of the votes, or completely replacing the token. \n\nHowever, registering a proposal for voting requires spending a lot of tokens, and anyone who can get that amount of tokens can register one. This poses a risk of bad decisions being made collectively by token holders, and even if the proposals are discussed and votes thought out, there is still a chance of unintended consequences. \n\nIn order to reduce the risks, Eco has reduced the number of proposals that can be enacted in a given voting cycle from 3 to 1. This helps ensure that proposals do not conflict with each other. Additionally, Eco relies on the community to demand an audit and vote down any proposal that has not been thoroughly audited by someone they trust, rather than introducing an auditor role on-chain.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11692",
      "title": "[P3-H01] Incorrect currency vote result",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe `computeVote` function in the `CurrencyGovernance` contract contains a [loop](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L313-L338) to calculate the number of zero inflation votes and zero certificate votes. These values are later compared with the total number of revealed votes in order to calculate the number of non-zero inflation and certificate votes.\n\n\nIt does this by requiring the user to sort the array of voter addresses by their inflation votes (implicitly creating a sorted array of inflation votes) and by their certificate votes (implicitly creating a sorted array of certificate votes). It then cycles through both implicit lists in order, updating the number of seen zero votes in each iteration, stopping at the second to last element. This means that if either implicit list contains only zero votes, the count will be one less than it should be.\n\n\nIn most cases, this has no effect, because inflation votes are anti-correlated with deflation votes. Additionally, when there are exclusively zero votes on one side, only the other side is used in subsequent calculations. However, relying on these facts about the current code base makes it fragile to changes.\n\n\nMore importantly, it is possible for a voter to select zero for both inflation and certificates. Consider a vote with exactly one non-zero ballot for one of the parameters and at least one zero vote for both parameters (and no other votes). This should resolve in favor of the non-zero ballot; in fact, it resolves as a tie.\n\n\nConsider updating the algorithm to correctly count the number of zero votes in this scenario.\n\n\n***Update:*** *Fixed. A patch was added to [cover the cases when the last value of the array is 0](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol#L343-L358). Note, however, that the function is still big and hard to read.*",
      "summary": "\nThe `CurrencyGovernance` contract contains a loop to calculate the number of zero inflation votes and zero certificate votes. This is done by sorting the array of voter addresses by their inflation votes and certificate votes, cycling through both implicit lists in order, and updating the number of seen zero votes in each iteration. However, if either implicit list contains only zero votes, the count will be one less than it should be. This can cause issues if a voter selects zero for both inflation and certificates, as it will resolve as a tie instead of in favor of the non-zero ballot.\n\nA patch has been added to cover the cases when the last value of the array is 0, however the function is still big and hard to read.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11691",
      "title": "[P3-C04] Miscalculation of claimed interest",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nThe `DepositCertificates` contract maintains a public [`claimedInterest`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L86) [variable](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L86) that tracks the total amount of interest that has been issued by the contract.\n\n\nWhenever a user invokes the [`deposit`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L121) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L121) to purchase a deposit certificate, only the newly issued interest should be added to `claimedInterest`. Instead, the total interest issued to the user by the contract is added, which effectively counts previously issued interest multiple times. This means that whenever a user buys certificates over multiple transactions, the public `claimedInterest` value will be incorrect.\n\n\nIn addition, `claimedInterest` is used in the [`destruct`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L161) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L161) to determine whether all issued and locked funds have been withdrawn. Since it will be too high if the bug is triggered, the contract will be unable to burn its tokens and will self destruct.\n\n\nConsider updating the `deposit` function to add only the newly issued interest to `claimedInterest`.\n\n\n***Update:*** *Fixed. The `deposit` function now [adds only the unclaimed interest](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/DepositCertificates.sol#L149).*",
      "summary": "\nA critical bug was identified in the `DepositCertificates` contract, which is used to track the total amount of interest issued by the contract. Whenever a user invokes the `deposit` function to purchase a deposit certificate, the total interest issued to the user by the contract is added to the public `claimedInterest` variable, which should only include the newly issued interest. This means that the public `claimedInterest` value will be incorrect if the user purchases certificates over multiple transactions. \n\nIn addition, `claimedInterest` is used in the `destruct` function to determine whether all issued and locked funds have been withdrawn. Since it will be too high if the bug is triggered, the contract will be unable to burn its tokens and will self destruct.\n\nThe bug has since been fixed - the `deposit` function now adds only the unclaimed interest.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11690",
      "title": "[P3-C03] Inflation parameters are miscalculated",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nThe [`computeVote`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L226) of the `CurrencyGovernance` contract can be invoked to finalize the voting procedure. In the case where there are more votes for inflation than deflation, the function should select the median amount of inflation and the median prize from the non-zero inflation votes. It does this by requiring the user to sort the array of voter addresses by their inflation votes (implicitly creating a sorted array of inflation votes) and separately by their prize votes (implicitly creating a sorted array of prize votes) and then, by selecting the middle of the non-zero elements in the implicit array.\n\n\nIf there is an even number of non-zero elements, it is supposed to average the middle two. However, the middle index is miscalculated. Specifically, [it is set](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L357) to half the number of non-zero elements, but it is not offset into the non-zero elements section of the array.\n\n\nThis means that inflation and prize will be the average of two elements that are too low (and possibly zero) and will not reflect the results of the vote. Consider moving the offset operation from [`CurrencyGovernance` (line 360)](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L360) out of the `if` statement (line 358) to correctly calculate the middle index.\n\n\n***Update:** Fixed. The `initiateInflationCycle` function now [correctly offsets the middle index](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/CurrencyGovernance.sol#L425).*",
      "summary": "\nThis bug report is about the `computeVote` function of the `CurrencyGovernance` contract. This function is used to finalize the voting procedure, and should select the median amount of inflation and the median prize from the non-zero inflation votes. To do this, it requires the user to sort the array of voter addresses by their inflation votes and separately by their prize votes. \n\nThe bug was that when there was an even number of non-zero elements, it was miscalculating the middle index. Specifically, it was set to half the number of non-zero elements, but not offset into the non-zero elements section of the array. This meant that inflation and prize would be the average of two elements that were too low (and possibly zero), and would not reflect the results of the vote.\n\nThe bug has now been fixed, and the `initiateInflationCycle` function now correctly offsets the middle index.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11689",
      "title": "[P3-C02] Any token holder can prevent currency governance",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nThe [`CurrencyGovernance`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol) oversees a governance process that may culminate in the deployment of an [`Inflation`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol) or a [`DepositCertificates`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol) [contract](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol).\n\n\nIn the first case, after inflation tokens are [minted and assigned](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L376) to the `Inflation` contract, `startInflation` [confirms](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/Inflation.sol#L150-L153) the contract token balance exactly matches the expected value. Similarly, in the second case, after interest tokens are [minted and assigned](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/CurrencyGovernance.sol#L401) to the `DepositCertificates` contract, `startSale` [confirms](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/DepositCertificates.sol#L193-L196) the contract token balance exactly matches the expected value.\n\n\nHowever, either contract would be deployed to a [predictable address](https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html#accounts). This makes it possible for any token holder to [pre-compute the contract address](https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed) and transfer tokens to the contract before it is deployed. Consequently, when it is initialized after deployment, it will have an unexpectedly high balance, and the transaction will be reverted. This effectively means that any token holder can prevent the `CurrencyGovernance` contract from deploying new `Inflation` or `DepositCertificates` contracts.\n\n\nConsider changing the guard condition to set a minimum (but no maximum) bound on the contract balance.\n\n\n***Update:*** *Fixed. The [`startInflation`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/Inflation.sol#L162) and [`startSale`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/DepositCertificates.sol#L209) functions now check for a balance greater than or equal to the required.*",
      "summary": "\nThis bug report is about the CurrencyGovernance contract, which is responsible for overseeing a governance process that can lead to the deployment of an Inflation or DepositCertificates contract. The bug occurs when either of these contracts are deployed to a predictable address, which makes it possible for any token holder to pre-compute the contract address and transfer tokens to the contract before it is deployed. This will cause the contract to have an unexpectedly high balance when it is initialized after deployment, resulting in the transaction being reverted.\n\nThe suggested solution is to set a minimum bound on the contract balance, which has now been implemented. The startInflation and startSale functions now check for a balance greater than or equal to the required.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11688",
      "title": "[P3-C01] Funds can be lost",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nAny token holder can call the [`registerProposal`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L168) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L168) of the `PolicyProposals` contract to register a proposal address. There is a token cost per registration, which can be partially refunded with the [`refund`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L290) [function](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L290) if the proposal does not make the ballot.\n\n\nHowever, the guard conditions intended to avoid duplicate proposal registrations or prevent refund requests for ineligible proposals do not apply to the zero address. This has a number of consequences.\n\n\nEach time the zero address is registered as a proposal, it will overwrite the proposer address, add a new item to the `allProposals` array, increment `totalproposals`, and emit a new `ProposalAdded` event. This will cause `allProposals` and `totalproposals` to return incorrect values.\n\n\nInterestingly, this would also prevent `totalproposals` from being decremented to zero, which would prevent the contract from destructing, as long as the `refund` function did not have the same bug.\n\n\nIf the zero address proposal is registered, it can be refunded like any other proposal that did not make the ballot. Subsequently (or if it was never registered), calls to `refund` the zero address will decrement the `totalproposals` variable and send `REFUND_IF_LOST` tokens to the zero address.\n\n\nThis will cause the `totalproposals` variable to return the wrong value when queried. Additionally, each call to `refund` reduces the contract balance, and it may not have enough funds to honor all refunds, causing some legitimate refund requests to fail. Alternatively, if `totalproposals` is decremented to zero, anyone can [`destruct`](https://github.com/BeamNetwork/currency/blob/51b65c5c7af455391af2bc30d13d761566d8c236/contracts/inflation/PolicyProposals.sol#L315) the contract before everyone has received their refunds. Lastly, `totalproposals` can be decremented past zero, causing it to underflow and prevent `destruct` from ever being called.\n\n\nConsider preventing `registerProposal` and `refund` from being called with the zero address.\n\n\n***Update:** Fixed. The [`registerProposal`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L185) and the [`refund`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/governance/PolicyProposals.sol#L299) functions now require that the address passed as an argument is not 0.*",
      "summary": "\nA bug has been found in the `PolicyProposals` contract of the BeamNetwork currency. Token holders are able to call the `registerProposal` function to register a proposal address, but the guard conditions intended to avoid duplicate proposal registrations or prevent refund requests for ineligible proposals do not apply to the zero address. This has a number of consequences, including incorrect values being returned when queried, some legitimate refund requests failing, and the contract potentially being destructed before everyone has received their refunds. To fix this issue, the `registerProposal` and `refund` functions have been updated to require that the address passed as an argument is not 0.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11687",
      "title": "[P2-L18] Outdated solc version in use",
      "impact": "LOW",
      "content": "###### Low\n\n\nAn outdated solc version, 0.5.4, [is currently in use](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/truffle-config.js#L25). As Solidity is now under a fast release cycle, make sure that the latest version of the compiler is being used at the time of deployment (presently [0.5.7](https://github.com/ethereum/solidity/releases/tag/v0.5.7)).\n\n\n***Update:*** *Fixed. [Eco now uses Solidity 0.5.12](https://github.com/BeamNetwork/currency/blob/b487802ad09fe70654283a8dab63d62c0e85330f/truffle-config.js#L25).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11686",
      "title": "[P2-L17] Incomplete API documentation",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [README.md](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#api) file includes a section where the public API of the [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) contract is documented. However, public functions [`tokenTransfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L199), [`balance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L207), [`initialize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L217), [`destruct`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L371), and [`reAuthorize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L451) are not included. As these functions are part of the public API of the `BeamBalanceStore` contract, consider adding them to the documentation.\n\n\n***Update:*** *Fixed.* *The [API documentation in the README file](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency#api) now includes the mentioned functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11685",
      "title": "[P2-L16] Confusing error message in the ERC777BeamToken contract",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `ERC777BeamToken` contract, the [error message in line 168](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L168) should be clarified to better inform users about the specific failed condition that causes the transaction to revert (e.g., *“Recipient cannot be the zero address”*). Moreover, it points the user to use a burn feature not implemented in the `ERC777BeamToken` contract, which may be confusing.\n\n\n***Update:*** *Fixed. The [revert message has been updated](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L194).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11684",
      "title": "[P2-L15] Confusing docstrings for the granularity function in the ERC777BeamToken contract",
      "impact": "LOW",
      "content": "###### Low\n\n\n[Docstrings for the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L52) [`granularity`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L52) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L52) of the `ERC777BeamToken` contract are phrased as a question, which may be confusing for users and developers alike. Consider rephrasing them as a clear and straightforward statement, such as `Return the smallest unit of this token that can be transferred`.\n\n\n***Update:*** *Fixed. The [docstring of the `granularity` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L41) is now clearer.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11683",
      "title": "[P2-L14] The EIP 820 implementation should be updated to EIP 1820",
      "impact": "LOW",
      "content": "###### Low\n\n\nConsidering that [EIP 1820](https://github.com/ethereum/EIPs/pull/1820) has recently superseded [EIP 820](https://github.com/ethereum/EIPs/issues/820), the former being the latter’s adaptation for Solidity 0.5, it is advisable to upgrade all references to EIP 820 in [ERC777BeamToken](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol) and the [README](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/README.md) with the newer EIP 1820. Although entirely out of scope for this audit, it was observed that this work has already begun in <https://github.com/BeamNetwork/currency/pull/39>.\n\n\n***Update:** Fixed. The Eco project is now [using the EIP 1820](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/package.json#L71).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11682",
      "title": "[P2-L13] The total token supply is not tracked across generations",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [generational balance store](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#the-generational-store) implemented in the [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) [contract](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) does not track the total token supply across generations. Instead, the token supply registered in [the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L91) [`tokenSupply`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L91) [state variable](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L91) always refers to the latest generation. If this is the intended behavior of the balance store, consider properly documenting it. Otherwise, consider implementing the necessary logic to track the total token supply across all generations.\n\n\n***Update:** Fixed. The behavior has been [clearly documented](https://github.com/BeamNetwork/currency/commit/b169e9e395844d066dd9cd1e5c11ca9476913ee8).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11681",
      "title": "[P2-L12] Potentially unnecessary extra iterations in the revoke function",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) function in the `BeamBalanceStore` contract allows the root policy to revoke access privileges that were granted to other contracts (whose addresses are stored in the [`authorizedContracts`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L59) [mapping](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L59)) by providing the identifier of the policy contract to be removed. Internally, the function [loops through all registered policies](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L153) in the [policies](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52), reorganizing the elements left in the array after finding and removing the target policy. However, it currently does not break from the loop once the policy is found and deleted; instead, the function unnecessarily keeps iterating over the array.\n\n\nAs each iteration increases the gas cost of the transaction, consider adding a `break` statement right after [the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L163) [`revoked`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L163) [local variable is set to](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L163) [`true`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L163). This issue should be disregarded if the `policies` array can contain repeated policies. Consider documenting it in the function’s docstrings if this was indeed the case.\n\n\n***Update:*** *Fixed. Now the [`authorize` function reverts if the policy has been authorized](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L160). The `revoke` function is now simpler, [ending the loop after the first policy is found](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L199).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11680",
      "title": "[P2-L11] A potentially inefficient mechanism for revoking policies",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe function [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) of the `BeamBalanceStore` contract removes all occurrences of policies matching a given `_policyIdentifier`. In order to do so, the function features two loops. [The first](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L153) compares the provided `_policyIdentifier` with the elements in the [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52). [The second one](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L156), nested inside the first, overrides the matching element by [moving all the following elements one position](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L157), thereby removing the target policy.\n\n\nIn a scenario where a `_policyIdentifier` appears several times in the `policies` array, the implemented algorithm for removing policies can be quite expensive in terms of gas costs, essentially due to the described nested loops. The worst scenario is in the order of `policy.length * R` where R is the number of times the element to be revoked appears.\n\n\nIf appropriate, consider either disallowing duplicate policies when registering them via the [`authorize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L131) function or providing a more efficient implementation for the `revoke` function. As a mere illustration of a plausible approach, consider [this draft](https://gist.github.com/garbervetsky/3f4be81966edfaba987fa07a0178d173) as an alternative version of `revoke`, which is linear on `policy.length`, even in the case of repeated policies (Note that this suggestion is only a proof of concept and should *not* be used in production under any circumstances).\n\n\n***Update:*** *Fixed. Now, the [`authorize` function reverts if the policy has been authorized](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L160). The `revoke` function is now simpler, [ending the loop after the first policy is found](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L199).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11679",
      "title": "[P2-L10] Redundant deletion of the array’s element in the revoke function",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) of the `BeamBalanceStore` contract is in charge of finding and removing a given policy from the [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52). [When the policy is found](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L154), a [loop](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L156) takes care of moving the tail of the array one step forward, thus successfully removing the target policy by overriding it. As all elements are moved one position, the [last element of the array is then set to zero](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L159) before [decreasing the array’s length](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L162) by one.\n\n\nThese last two instructions are redundant, since just decreasing the array’s length [will suffice](https://solidity.readthedocs.io/en/v0.5.4/types.html#array-members). Therefore, consider removing [the instruction that zeroes the last element](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L159) in the array.\n\n\n***Update:** Fixed. The [`revoke` function now only decreases the array’s length](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L195).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11678",
      "title": "[L2-09] The revoke function may not inform the user of a failed operation",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) of the `BeamBalanceStore` contract is in charge of finding and removing a given policy from the [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52). However, the function does not implement the necessary logic to handle a scenario where no policy is revoked. In such cases, the transaction will successfully be completed without explicitly notifying the sender that the policy identifier provided is not registered and was therefore not removed.\n\n\nConsider adding the needed `require` statement to revert the transaction and explicitly notify the sender with an informative error message when it is impossible to revoke a given policy identifier.\n\n\n***Update:** Fixed. Now, when the policy is not revoked, [the function reverts](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L203).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11677",
      "title": "[P2-L08] The evoke function should be better modularized",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149) of the `BeamBalanceStore` implements all the necessary business logic to search for a given policy identifier as well as remove it from the [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) when found. Considering the entire operation is currently done in convoluted nested loops, without inline documentation explaining what each code segment is actually doing, the function may benefit from some refactoring and modularization into more decoupled private functions. For instance, functions for searching and deleting a policy could be implemented separately and called from `revoke`. This should improve the code’s readability, thereby easing its documentation, testability, and maintenance.\n\n\n***Update:*** *Fixed. The [`revoke` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L185) has been refactored and is now more readable.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11676",
      "title": "[P2-L07] Complex and potentially inefficient authorization mechanism",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) contract restricts some of its functionality (e.g., the [`tokenTransfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L199) function) to a set of authorized contracts. To do so, it relies on the [`authorizedContracts`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L59) mapping which is built out of the [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L52) array. In order to keep both variables synchronized, the [`reAuthorize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L451) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L451) is intended to remove all elements from the mapping and recompute it from scratch by reading the information from the `policies` array. `reAuthorize` must be called each time a policy is authorized (via [`authorize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L131)) or revoked (via [`revoke`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L149)). Each time one policy is added or removed, the whole authorization mapping is then entirely rebuilt.\n\n\nBesides the fact that this approach could be quite inefficient if `authorize` and `revoke` are frequently called, the purposes of state variable `policies` and `authorizedContracts` seem to be too overlapped, which leads to the need to always keep them in sync. It appears, however, that the functions `authorize` and `revoke` only add and remove one policy at a time. In this setting, it may be possible to update the `authorizedContracts` mapping directly without completely rebuilding it. This could be done by resorting to the [`policyFor`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/policy/Policy.sol#L39) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/policy/Policy.sol#L39), as in [line 460](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L460) of the `reAuthorize` function. Given a policy `p`, the function `policyFor(p)` can be used to obtain the contract’s address `c` and update `authorizedContracts[c]` with `true` or `false` accordingly. Using this approach, the array [`authorizedContractsKeys`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L62) would become pointless.\n\n\nConsider either making the authorization mechanism more efficient or documenting the rationale behind the current implementation (e.g., policies are rarely authorized or revoked once the contract is initialized).\n\n\n***Update:** Fixed.* *The authorization mechanism has been simplified and now only relies on the [`authorizedContracts`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L64) and [`authorizedContractAddresses`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L67) arrays.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11675",
      "title": "[P2-L06] Weak condition in the cleaning mechanism",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe function [`updateTo`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) in the `BeamBalanceStore` contract aims at updating the balance of a given address to a specific generation. It also intends to clean the balances for old generations, always keeping up to 12 past generations.\n\n\nThe cleaning process is guarded by an [`if`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L316) [statement](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L316) that checks if the specified target generation is greater than [`generationMinimumKeep`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L74) ([set to 12](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L105) during construction). When the number of generations becomes greater than `generationMinimumKeep`, the `if` condition will always be true, meaning that the [logic including the cleaning mechanism](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L317-L323) will be executed every time.\n\n\nConsider improving the referenced `if` condition (which can potentially lead to gas savings), along with the changes proposed in the related issue on `updateTo`‘s complexity (see **“Convoluted implementation of updateTo”**).\n\n\n***Update:*** *Fixed. The [`updateToCurrentGeneration` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L390) has been refactored and the conditions for cleaning improved.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11674",
      "title": "[P2-L05] Unclear and undocumented looping algorithm for the balance updates",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe function [`updateTo`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) in the `BeamBalanceStore` contract aims at updating the balance of a given address to a specific generation. It also cleans the balances for older generations.\n\n\nThe documentation does not describe how the update mechanism is to be performed, but the goal seems to promote the balances of the last available balance for the `_owner` (referred by the variable `last`) to its future generations (up to `_targetGeneration`). This is done in the [loop in lines 308-310](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L308-L310) which is not documented, making it difficult to analyze. In particular, the loop ends up assigning the same value (i.e., the last available balance) to all subsequent balances, even if it takes that value from a different variable in each iteration.\n\n\nConsider documenting how the `updateTo` function should update the balances and include inline comments to clearly describe the intended behavior. If this is indeed replicating the same value throughout the array, consider simplifying the logic to ease readability.\n\n\n***Update:*** *Fixed. The [`updateToCurrentGeneration` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L390) has been refactored, cleaned, and commented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11673",
      "title": "[P2-L04] Repeated initialization code in the BeamBalanceStore contract",
      "impact": "LOW",
      "content": "###### Low\n\n\nThe `BeamBalanceStore` contract is set up [during construction](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L96) with an initial configuration that defines which policies are allowed to interact with sensitive functions of the contract. This is done by [pushing the IDs of three different policies to the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L97-L99) [`policies`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L97-L99) [array](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L97-L99). As `BeamBalanceStore` is an upgradeable contract, it also features an [`initialize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L217) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L217) that is to be called after construction, via a proxy, to effectively initialize the proxy’s storage by copying the configuration set during the implementation contract’s construction. The `initialize` function initializes [policies in the exact same way](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L219-L221) as the `constructor`, repeating the code used to push the three initial policies.\n\n\nGiven how error-prone this approach is, consider refactoring the repeated code into a private function that encapsulates the initialization of all policies required during the initial setup of the `BeamBalanceStore` contract.\n\n\n***Update:*** *Fixed. The [`configureDefaultAuthorizedContracts`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L141) function was added, and now, it is called by the [constructor](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L131) and the [`initialize`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L336) function.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11672",
      "title": "[P2-L03] Redundant balance getter functions in the BeamBalanceStore contract",
      "impact": "LOW",
      "content": "###### Low\n\n\nIn the `BeamBalanceStore` contract, there are two public functions to return an address’s token balance: [`balance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L207) and [`balanceOf`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L407). Given [`balanceOf`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L408) [internally calls](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L408) [`balance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L408), consider restricting `balance`‘s visibility to `internal`, leaving `balanceOf` as the only public getter to retrieve the balance of an address. Should this suggestion be applied, functions `balanceOf` in [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L62) and [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L66) need to be updated accordingly, along with all related unit tests.\n\n\nAlternatively, if the ERC20 interface is finally moved out of the `BeamBalanceStore` contract, as is strongly suggested in **“Unnecessary reimplementation of ERC20 features in BeamBalanceStore”**, then only the [`balance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L207) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L207) should be kept in `BeamBalanceStore` (as a `public` or `external` function) to be used by the rest of the contracts to query the token balances registered in `BeamBalanceStore`.\n\n\n***Update:*** *Fixed. The `balanceOf` function was removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11671",
      "title": "[P2-L02] Erroneous emission of the ERC20 Transfer event",
      "impact": "LOW",
      "content": "###### Low\n\n\nAuthorized token contracts, such as [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol) and [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol), are allowed to transfer tokens registered in the `BeamBalanceStore` contract by calling its [`tokenTransfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L199) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L199), which in turn, calls the internal [`tokenTransferHelper`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L476) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L476). After transferring the tokens, this last function [emits two](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L488-L495) [`Transfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L488-L495) [events](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L488-L495). While the first `Transfer` event is [defined in the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L29) [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L29) [contract](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L29), the second one is the [inherited ERC20](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/IERC20.sol#L20) [`Transfer`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/IERC20.sol#L20) [event](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/IERC20.sol#L20). This means that for every single transfer triggered by any of the different interfaces allowed to interact with `BeamBalanceStore`, an ERC20 `Transfer` event will be emitted, but it will be erroneous if the original call was not made to an ERC20 function.\n\n\nDocstrings for the `tokenTransfer` function further hinder discerning the intended behavior, as they state, *“A Transfer event must be emitted for any transfer made […].”* However, it is never specified which `Transfer` event in particular is expected to be emitted. Additionally, related unit tests only [check for the emission of a single](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/test/currency/BeamBalanceStore.js#L632) [`Transfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/test/currency/BeamBalanceStore.js#L632) [event](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/test/currency/BeamBalanceStore.js#L632).\n\n\nAs this unexpected behavior might be misleading for external off-chain clients tracking token transactions, consider only emitting the ERC20 `Transfer` event in the ERC20 [`transfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L413) and [`transferFrom`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L422) functions.\n\n\n***Update:*** *Fixed. The [`tokenTransfer` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L240) no longer emits `Transfer` events.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11670",
      "title": "[P2-L01] Not following the Check-Effects-Interaction Pattern",
      "impact": "LOW",
      "content": "###### Low\n\n\n[Solidity recommends the usage of the Check-Effects-Interaction Pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) to avoid potential security vulnerabilities, such as [reentrancy](http://dasp.co/#item-1). However, the [`transferFrom`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L91) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L91) of the `ERC223BeamToken` contract executes an [external call to do the token transfer](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L95) before modifying the storage to [reduce the caller’s allowance](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L96). Had the call been made to an unknown contract, this pattern would have led to a severe reentrancy vulnerability.\n\n\nIn this particular case, there is no actual risk of a reentrancy attack, as [the external call](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L95) is made to a trusted contract (i.e., [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol)). Always consider following the Check-Effects-Interactions pattern, thus modifying the contract’s state *before* making any external call to other contracts.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11669",
      "title": "[P2-M10] BeamBalanceStore’s initialize function lacks the onlyConstruction modifier",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`initialize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L217) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L217) of the `BeamBalanceStore` contract is missing the [`onlyConstruction`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/proxy/ForwardTarget.sol#L10) [modifier](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/proxy/ForwardTarget.sol#L10). While this issue does not pose a security risk, as the [parent contract’s](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/policy/PolicedUtils.sol#L77) [`initialize`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/policy/PolicedUtils.sol#L77) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/policy/PolicedUtils.sol#L77) does include this modifier (making any transaction to the child’s function revert when called more than once), no unit tests covering this sensitive scenario were found in the test suite.\n\n\nConsider including the `onlyConstruction` modifier in the mentioned function to favor explicitness. Additionally, given how critical this function is, thorough unit tests covering the behavior of the `initialize` function of the `BeamBalanceStore` contract should be included, making sure it is impossible for anyone to call it more than once.\n\n\n***Update:** Fixed. The [`initialize` function now has the `onlyConstruction` modifier](https://github.com/BeamNetwork/currency/blob/1464bbb504ba8823bc06e626048ed5565f6728d8/contracts/currency/EcoBalanceStore.sol#L334). Unit tests covering calls to the `initialize` function of the `EcoBalanceStore` contract have been [added](https://github.com/BeamNetwork/currency/commit/960a1caa2565ff1b5778553e1924d4fa9f20fed6).*",
      "summary": "\nA bug was found in the `BeamBalanceStore` contract, which is part of the BeamNetwork/currency repository. The `initialize` function was missing the `onlyConstruction` modifier, which would ensure that the function can only be called once. This issue does not pose a security risk, as the parent contract’s `initialize` function does include this modifier, but no unit tests were found in the test suite.\n\nThe bug has since been fixed, with the `initialize` function now having the `onlyConstruction` modifier and unit tests covering calls to the `initialize` function of the `EcoBalanceStore` contract having been added.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11668",
      "title": "[P2-M09] Receiver contract is not notified in transferFrom function of the ERC223BeamToken contract",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe `ERC223BeamToken` contract reimplements the ERC20 [`transferFrom`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L91) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L91), adding the necessary logic to effectively [transfer the tokens](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L95) by calling the `BeamBalanceStore` contract. Nonetheless, the `transferFrom` function never checks if the receiver address is a contract to later call its `tokenFallback` function, [as the](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L77) [`transfer`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L77) [function correctly does](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L77) (following the [EIP 223 specification](https://github.com/ethereum/EIPs/issues/223)).\n\n\nSimilar to what is already implemented in the `transfer` function, consider implementing the necessary logic to notify the receiver contract about the token transfer when using the `transferFrom` function. Even though this function is not currently part of the interface proposed in the EIP 223 (so there is no standard expected behavior), failing to notify the receiver contract goes against the EIP’s original intention. Alternatively, consider removing the `transferFrom` function altogether to conform to the current state of the EIP.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed.*",
      "summary": "\nA bug was reported in the `ERC223BeamToken` contract, which is a reimplementation of the ERC20 `transferFrom` function. This function was not checking if the receiver address is a contract and thus failing to notify the receiver contract about the token transfer. This went against the intention of the EIP 223 specification. To fix this bug, the necessary logic to notify the receiver contract was implemented or alternatively, the `transferFrom` function was removed altogether. The bug has now been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11667",
      "title": "[P2-M08] Implementation of EIP 777 does not fully match the specification",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe following mismatches between the [EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777) and the related implementation contracts (i.e., [`ERC777Token`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777Token.sol) and [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol)) were identified:\n\n\n* The `ERC777BeamToken` contract does not register the interface with its own address via the [ERC1820 registry](https://eips.ethereum.org/EIPS/eip-1820#erc1820-registry-smart-contract) deployed at an address specified [here](https://eips.ethereum.org/EIPS/eip-1820#registry-contract-address), which is strictly required by the EIP. According to the spec, this must be done by calling the [`setInterfaceImplementer`](https://eips.ethereum.org/EIPS/eip-1820#set-an-interface-for-an-address) [function in the registry](https://eips.ethereum.org/EIPS/eip-1820#set-an-interface-for-an-address) with the token contract address as both the address and the implementer and the `keccak256` hash of `ERC777Token` as the interface hash.\n* The function `defaultOperators() external view returns (address[] memory)` is not defined in `ERC777Token` or in `ERC777BeamToken`, and it is considered a must by the specification. According to the EIP, if the token contract does not have any default operators, [this function must still be included and return an empty list](https://eips.ethereum.org/EIPS/eip-777#defaultOperators).\n* Neither `ERC777Token` nor `ERC777BeamToken` define the `burn(uint256, bytes)` and `operatorBurn(address, uint256, bytes, bytes)` functions, which are a must according to the EIP’s spec. If no burning functionality is needed in the implementation contract (i.e., in [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol)), the recommended course of action would be to still define the missing functions and revert all calls to them with an informative error message (Note, however, that the error message in line 168 of [`ERC777BeamToken.sol`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol#L168) does refer to a burn feature, as reported in the issue **“Confusing error message in ERC777BeamToken contract”**.).\n* The defined [`Minted`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777Token.sol#L39) [event](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777Token.sol#L39) is missing one `bytes` argument. In other words, it is defined as `Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);` but instead should be `Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData)`). It is worth mentioning that this event is never actually used in the [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol) contract.\n\n\nWhile these particular noncompliances were detected during the audit, the development team must bear in mind that the EIP 777 is still under discussion and can therefore suffer breaking changes at any moment. Hence, it is highly advisable for the Beam team to closely follow the EIP’s progress so as to implement any future changes that the proposed interface may suffer. As another reference, consider following the development of [PR #1684 in the OpenZeppelin library](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1684).\n\n\n***Update:*** *Partially fixed. The [`ERC777Token` contract was replaced with the `IERC777` interface from OpenZeppelin Contracts](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L6). The [`ERC777EcoToken` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L27) is still not registering itself in the ERC1820 registry. The [`defaultOperators` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L68) was added, and it is returning an empty list. The functions [`burn`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L123) and [`operatorBurn`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L127) were added. The `Minted` event is now properly defined (imported from [the OpenZeppelin Contracts `IERC777` interface](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC777EcoToken.sol#L6)). Eco’s statement for this issue:* \n\n\n\n> We register the ERC777 interface with the ERC1820 registry as part of our deployment process rather than in the ERC777 `EcoToken` implementation. See `fusedInit` in the `PolicyInit` contract, and its use in `tools/deploy.js`.\n> \n>",
      "summary": "\nA bug report was submitted for the implementation contracts (i.e., `ERC777Token` and `ERC777BeamToken`) related to the [EIP 777 specification](https://eips.ethereum.org/EIPS/eip-777). It was found that the `ERC777BeamToken` contract did not register the interface with its own address to the [ERC1820 registry](https://eips.ethereum.org/EIPS/eip-1820#erc1820-registry-smart-contract) deployed at an address specified [here](https://eips.ethereum.org/EIPS/eip-1820#registry-contract-address). This is a mandatory requirement according to the EIP. Additionally, the functions `defaultOperators() external view returns (address[] memory)`, `burn(uint256, bytes)` and `operatorBurn(address, uint256, bytes, bytes)` were not defined in either `ERC777Token` or `ERC777BeamToken` which are also musts according to the EIP’s spec. The defined `Minted` event was found to be missing one `bytes` argument.\n\nThe development team was advised to closely follow the progress of the EIP 777 as it can suffer breaking changes at any moment. As another reference, they were suggested to follow the development of [PR #1684 in the OpenZeppelin library](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1684). The issue was partially fixed by replacing the `ERC777Token` contract with the `IERC777` interface from OpenZeppelin Contracts. The `ERC777EcoToken` contract was still not registering itself in the ERC1820 registry. The `defaultOperators` function was added, and it is returning an empty list. The functions `burn` and `operatorBurn` were added. The `Minted` event is now properly defined.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11666",
      "title": "[P2-M07] No indexed parameters in the BeamBalanceStore events",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nNone of the parameters of the [events defined](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L29-L47) in the `BeamBalanceStore` contract are indexed. Consider indexing event parameters where appropriate to avoid hindering off-chain clients’ ability to search and filter for specific events.\n\n\n***Update:*** *Fixed. All the [events in the `EcoBalanceStore` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L26-L54) have indexed parameters.*",
      "summary": "\nThis bug report is about the BeamBalanceStore contract in the BeamNetwork/currency repository. The problem is that none of the parameters of the events defined in the contract are indexed, which hinders off-chain clients' ability to search and filter for specific events. The bug has since been fixed, and all the events in the EcoBalanceStore contract now have indexed parameters. Indexing event parameters is important because it allows off-chain clients to easily search and filter for specific events.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11665",
      "title": "[P2-M06] balanceAt function allows for querying of balances of cleaned generations",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`balanceAt`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L354) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L354) in the `BeamBalanceStore` contract allows any user to query the balance of a given account at a specified generation. However, there is no restriction regarding up to which past generation the balances can be queried. For instance, users can currently query their balance at generation 0, which is not even a valid generation. Moreover, after a generation has been cleaned, users not fully aware of the internal garbage collection mechanism of old balances might not expect their balance to be zero at a generation where they used to have a positive token balance. The user experience is further hindered considering that no notifying events are emitted when the balances are set to zero during the garbage collection (as seen in **“Lack of event emission in updateTo function”**).\n\n\nAs balances of old cleaned generations are no longer relevant for the system (they are set to zero), consider restricting up to which past generation a user can query the [`balances`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L79) mapping. In this regard, it is advisable to include a `require` statement to revert the call to [`balanceAt`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L354) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L354) if the specified generation is 0 or has already been cleaned, which would be a more reasonable and user-friendly behavior for this function.\n\n\n***Update:** Partially fixed. The `balanceAt` function still allows querying balances of cleaned generations, but the [docstrings have been updated to clearly state the function’s behavior](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L502). Eco’s statement for this issue:* \n\n\n\n> Reverting when checking balances of cleaned generations would introduce loud failures elsewhere in the system where they don’t make sense. Previous generations are used for staking, and using an old generation fails in a convenient way – it values the balance at 0 tokens, so participation in voting or staking is not possible. This has the same effect on the user’s actions that a revert would, but does not cause iterative processes to break. Additionally, the implementation of balanceAt is simplified to avoid complex bounds checking that could be a significant source of bugs.\n> \n>",
      "summary": "\nThis bug report is about the `balanceAt` function in the `BeamBalanceStore` contract. This function allows any user to query the balance of a given account at a specified generation. The issue is that there is no restriction regarding up to which past generation the balances can be queried. As a result, users can currently query their balance at generation 0, which is not even a valid generation. Moreover, after a generation has been cleaned, users not fully aware of the internal garbage collection mechanism of old balances might not expect their balance to be zero at a generation where they used to have a positive token balance.\n\nTo address this issue, it has been suggested to restrict up to which past generation a user can query the `balances` mapping. To do this, a `require` statement should be added to the `balanceAt` function to revert the call if the specified generation is 0 or has already been cleaned. This would create a more reasonable and user-friendly behavior for this function.\n\nThe bug has been partially fixed by updating the docstrings to clearly state the function’s behavior. The implementation of `balanceAt` has also been simplified to avoid complex bounds checking that could be a significant source of bugs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11664",
      "title": "[P2-M05] Lack of event emission in the updateTo function",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe function [`updateTo`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) in the `BeamBalanceStore` contract can be called by any user to update a given [address](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L290) to a specified [generation](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L291). Under certain circumstances, the function also takes care of [cleaning the address’s balances](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L320) in old generations that are no longer needed by the system. However, it never notifies users about old balances of their accounts being set to zero, which may be totally unexpected if an unaware user queries the balance at a cleaned generation and sees a balance set to zero where it should be positive (see **“[P2-M06] balanceAt function allows querying balances of cleaned generations”**). The lack of a notifying event further hinders the user’s experience in tracking and understanding how and when the balance got changed to zero.\n\n\nTo improve off-chain client experience when interacting with the `BeamBalanceStore` contract, consider defining and emitting informative events every time:\n\n\n* An address is updated to a more recent generation.\n* The balance of an account in a past generation is set to zero due to the garbage collection mechanism of old generations.\n\n\n***Update:** Partially fixed. The [`AccountBalanceGenerationUpdate` event is now emitted](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L397) when an address is updated to the current generation. No event is emitted when balances from past generations are set to 0. Eco’s statement for this issue:*\n\n\n\n> Emitting events increases gas costs, and the number of generations preserved is a constant relative to the current generation of each address. It’s pretty easy to check which generations have data for a given address, both on-chain and off-chain. For analyzing when a generation was erased, the `AccountBalanceGenerationUpdate` event can be used as an indicator.\n> \n>",
      "summary": "\nThis bug report is about the function `updateTo` in the `BeamBalanceStore` contract. This function allows users to update an address to a specified generation. However, it does not notify users about old balances of their accounts being set to zero, which may be unexpected if an unaware user queries the balance at a cleaned generation and sees a balance set to zero where it should be positive. To improve off-chain client experience when interacting with the `BeamBalanceStore` contract, two events should be defined and emitted: one when an address is updated to a more recent generation and one when the balance of an account in a past generation is set to zero due to the garbage collection mechanism of old generations. Partially, this issue has been fixed with the `AccountBalanceGenerationUpdate` event being emitted when an address is updated to the current generation. However, no event is emitted when balances from past generations are set to 0. Eco’s statement is that it is easy to check which generations have data for a given address both on-chain and off-chain and the `AccountBalanceGenerationUpdate` event can be used as an indicator for analyzing when a generation was erased.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11663",
      "title": "[P2-M04] Off-by-one error in the generation cleaning mechanism",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThere is an off-by-one error in the [`updateTo`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) [function](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) of the `BeamBalanceStore` contract that causes the system to keep one generation more than what is expected after executing the cleaning mechanism for older generations. According to the [docs,](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#the-generational-store) “Old checkpoints (more than 12 generations ago) for the account are cleaned up during the new checkpoint creation to reduce storage requirements.”\n\n\nHowever, this statement does not hold true, as the current implementation is keeping an additional generation (i.e., 13) in the state. A unit test confirming the issue can be found [in this secret gist](https://gist.github.com/tinchoabbate/0b9f01ae08a3acc13938a36edb1e0632).\n\n\nThe lack of additional context in the documentation regarding the purpose of the [generational store](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#the-generational-store) prevents us from exactly determining the impact and severity of this issue. Consider then properly analyzing its risk and taking the necessary actions to fix the off-by-one error in the `updateTo` function. More extensive unit tests to increase this function’s coverage are also suggested, which will avoid regression bugs in future changes to the codebase.\n\n\n***Update:** Fixed. The [pruning loop](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L450) now keeps only the number of generations declared in the [`GENERATIONS_TO_KEEP` constant](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L79).*",
      "summary": "\nThis bug report is about an off-by-one error in the `updateTo` function of the `BeamBalanceStore` contract. This error causes the system to keep one generation more than what is expected after executing the cleaning mechanism for older generations. This is contrary to the documentation, which states that “Old checkpoints (more than 12 generations ago) for the account are cleaned up during the new checkpoint creation to reduce storage requirements.” The lack of additional context in the documentation regarding the purpose of the generational store prevents us from exactly determining the impact and severity of this issue.\n\nTo fix the off-by-one error, the pruning loop was updated to keep only the number of generations declared in the `GENERATIONS_TO_KEEP` constant. Additionally, more extensive unit tests were suggested to increase the coverage of the `updateTo` function and avoid regression bugs in future changes to the codebase.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11662",
      "title": "[P2-M03] Unnecessary reimplementation of the ERC20 features in ERC223BeamToken",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol) [contract](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol) inherits from [OpenZeppelin’s ERC20 implementation contract](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol), unnecessarily redefining the functions [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L103) and [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L112). If these features are not to be modified by the `ERC223BeamToken`, consider removing them from the contract to avoid code repetition, thus easing the project’s maintainability.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed.*",
      "summary": "\nThis bug report is about a contract called ERC223BeamToken, which is a part of the BeamNetwork project. This contract inherited from OpenZeppelin's ERC20 implementation contract, but it unnecessarily redefined the functions approve and allowance. This repetition of code could make the project difficult to maintain, so it was suggested that these features should be removed from the contract if they are not to be modified. The bug has since been fixed and the contract has been removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11661",
      "title": "[P2-M02] Unnecessary reimplementation of the ERC20 features in BeamBalanceStore",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [BeamBalanceStore](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) [contract](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) inherits from [OpenZeppelin’s ERC20 implementation contract](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol), unnecessarily redefining the functions [approve](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L103) and [allowance](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L112). Considering that OpenZeppelin’s contracts are already audited and considered secure implementations of the ERC20 standard, it is never recommended to redefine inherited functions without thorough unit testing and extensive documentation explaining users why the functions are being overridden.\n\n\nFurthermore, the implementation of all ERC20 features within the `BeamBalanceStore` contract is not consistent with how other token interfaces (e.g., [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol) and [`ERC777BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC777BeamToken.sol)) are treated, the latter being split into external contracts. Even though the [documentation](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#background) states, *“[The ERC20 interface] is implemented directly in the balance store for simplicity,”* we noted during the audit that the loss in consistency and modularization outweighs any potential gain in simplicity.\n\n\nHence, it is advisable to refactor the entire implementation of the ERC20 interface out of the `BeamBalanceStore` contract and implement it separately in a new `ERC20BeamToken` contract that interacts with `BeamBalanceStore`, similar to how `ERC223BeamToken` and `ERC777BeamToken` currently do. Should the development team not follow this last suggestion, it is advisable to at least remove the unnecessarily re-implemented ERC20 features (i.e., `approve` and `allowance` functions) to avoid code repetition and ease the project’s maintainability.\n\n\n***Update:** Fixed. The [`EcoBalanceStore` contract no longer inherits from `ERC20`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L23). A new [`ERC20EcoToken` contract](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/ERC20EcoToken.sol) was added to integrate the ERC20 standard with the `EcoBalanceStore`.*",
      "summary": "\nThis bug report is about the BeamBalanceStore contract, which is part of the BeamNetwork/currency repository. The contract inherits from OpenZeppelin’s ERC20 implementation contract, but unnecessarily redefines the functions approve and allowance. This is not recommended, as OpenZeppelin’s contracts are already audited and considered secure implementations of the ERC20 standard. Furthermore, the implementation of all ERC20 features within the BeamBalanceStore contract is not consistent with how other token interfaces are treated.\n\nIt is advisable to refactor the entire implementation of the ERC20 interface out of the BeamBalanceStore contract and implement it separately in a new ERC20BeamToken contract that interacts with BeamBalanceStore. Alternatively, the unnecessarily re-implemented ERC20 features (approve and allowance functions) can be removed to avoid code repetition and ease the project’s maintainability.\n\nThe issue was fixed by replacing the BeamBalanceStore contract with the EcoBalanceStore contract, which no longer inherits from ERC20. A new ERC20EcoToken contract was added to integrate the ERC20 standard with the EcoBalanceStore.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11660",
      "title": "[P2-M01] Token allowances are tracked in different contracts",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nThe [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) [contract](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) implements a unified [generational store](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/README.md#the-generational-store) for the token balances, which is independent of the interface used to interact with it. Despite currently only working with [ERC20](https://eips.ethereum.org/EIPS/eip-20), [ERC223](https://github.com/ethereum/EIPs/issues/223), and [ERC777](https://eips.ethereum.org/EIPS/eip-777), the Beam team aims to develop a balance store extensible and flexible enough to handle any other token interface in the future.\n\n\nToken allowances are not tracked in a single contract as balances are. As in some interfaces, such as ERC777, it does not track allowances by design. The Beam team has avoided centrally tracking token allowances in the `BeamBalanceStore` contract and instead, has delegated the task to each interface that needs to work with them. While this course of action might be appropriate, some shortcomings must be addressed to effectively implement it.\n\n\nFirst of all, the fact that the ERC20 interface is, for no clear reasons, entirely integrated into the `BeamBalanceStore` contract could confuse users and developers alike. After seeing that the contract’s code implements related functions such as [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L434), [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L443), and an [`allowances`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94) [mapping](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94), they might be led to conclude that allowances are indeed centrally tracked in `BeamBalanceStore`. This would be a mistake, as these functions and data structure are only part of the `BeamBalanceStore` contract, because the ERC20 interface is integrated within it. A related issue with more specific details regarding the ERC20 implementation is reported in **“[P2-M02] Unnecessary reimplementation of ERC20 features in BeamBalanceStore”**.\n\n\nSecond of all, there is no documentation regarding how or why token allowances are tracked in separate contracts. As a consequence, it is difficult to understand what the system’s intended behavior is, therefore hindering the assessment of the code’s correctness. Simple and user-friendly documentation concerning how all users are expected to handle allowances should be included both in docstrings and in the repository. In it, it is of utter importance to highlight that allowances given through an interface are not going to be registered in other interfaces.\n\n\nLastly, even though the allowances mechanism is inherited from OpenZeppelin’s secure implementation of the ERC20 standard, it is unnecessarily overridden both in `BeamBalanceStore` and `ERC223BeamToken`, which leads to a severe bug in the implementation reported in **“[P2-H01] Broken token approval implementation”**. Other issues related to these points are reported in **“[P2-M02] Unnecessary reimplementation of ERC20 features in BeamBalanceStore”** and **“[P2-M03] Unnecessary reimplementation of ERC20 features in ERC223BeamToken”**.\n\n\nDesign decisions always come with trade-offs. In this case, given the fact that some token interfaces do not handle allowances, the Eco development team decided to avoid centrally tracking them, and instead, they delegate that task to each particular interface. While this approach is feasible, it is not the one initially expected after reading about the generational store and how balances are centrally tracked. Consider, after fixing all particular issues in the implementation, raising more end-user awareness about how the system is expected to work by providing extensive documentation and guides on how users should interact with the contracts, in particular, in terms of token allowances.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed. The [`EcoBalanceStore` contract no longer inherits from `ERC20`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L23) and no longer tracks allowances.*",
      "summary": "\nThis bug report concerns the BeamBalanceStore contract, which is used to store token balances for the Beam Network. It is designed to work with ERC20, ERC223, and ERC777 tokens, with plans to work with other token interfaces in the future. The issue is that token allowances are not tracked in a single contract, as balances are. This has led to confusion among users and developers, as some of the functions and data structures related to ERC20 are integrated into the BeamBalanceStore contract. Additionally, there is no documentation regarding how or why token allowances are tracked in separate contracts, making it difficult to understand the intended behavior. Finally, the allowances mechanism is unnecessarily overridden in BeamBalanceStore and ERC223BeamToken, leading to a severe bug in the implementation.\n\nThe Beam team has since fixed the issue by removing the ERC223BeamToken contract and making sure that the EcoBalanceStore contract no longer inherits from ERC20 and no longer tracks allowances. They have also recommended raising user awareness about how the system works by providing extensive documentation and guides.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11659",
      "title": "[P2-H02] Convoluted implementation of the updateTo function in the BeamBalanceStore contract",
      "impact": "HIGH",
      "content": "###### High\n\n\nThe function [`updateTo`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L293) performs two fundamental tasks related to Beam’s [generational store](https://github.com/BeamNetwork/currency/tree/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency#the-generational-store):\n\n\n* keeps the balances updated to the latest generation\n* clean the balances for older generations\n\n\nThese two tasks are currently performed in two `for` loops (see lines [308](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L308) and [319](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L319) of `BeamBalanceStore.sol`) that modify token balances\n\n\nHaving two different loops in the function makes it unnecessarily complex, since the functions they perform could be easily encapsulated in helper functions. Moreover, the logic within these loops is tangled enough to render it hard to follow. The lack of inline comments and a detailed specification for the generational store mechanics further hinders the implementation’s assessment. For more specific issues related to the `updateTo` function, refer to **“[P2-M04] Off-by-one error in generation cleaning mechanism”, “[P2-M05] Lack of event emission in updateTo function”**, **“[P2-L06] Weak condition in cleaning mechanism”,** and **“[P2-L05] Unclear and undocumented looping algorithm for balance updates”**.\n\n\nBesides addressing these specific implementation issues, consider refactoring the `updateTo` function by splitting the responsibilities into several helper functions, making sure to include documentation explaining the update and cleaning mechanisms in detail.\n\n\n***Update:*** *Fixed. The [`updateToCurrentGeneration` function](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L390) has been refactored, cleaned, and commented. However, the function still has two `for` loops that, while short and properly commented, could be extracted to functions to make things cleaner.*",
      "summary": "\nThis bug report is about the function `updateTo` in the BeamBalanceStore.sol file, which is used to update and clean token balances related to the generational store. The report states that the two tasks are currently performed in two `for` loops, making the function unnecessarily complex and hard to follow. The report also mentions four specific implementation issues related to the `updateTo` function. The report suggests refactoring the function by splitting the responsibilities into several helper functions, and adding documentation to explain the update and cleaning mechanisms in detail. The bug has been fixed, and the `updateToCurrentGeneration` function has been refactored, cleaned, and commented. However, the function still has two `for` loops which could be extracted to functions to make things cleaner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11658",
      "title": "[P2-H01] Broken token approval implementation",
      "impact": "HIGH",
      "content": "###### High\n\n\nContracts inheriting from [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol), such as [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol) and [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol), reimplement several inherited ERC20 features (sometimes unnecessarily, as reported in **“Unnecessary reimplementation of ERC20 features in ERC223BeamToken”** and **“Unnecessary reimplementation of ERC20 features in BeamBalanceStore”**). This attempts to seamlessly integrate different token interfaces with the [generational balance store](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/README.md#the-generational-store) in `BeamBalanceStore`. Unexpectedly, these contracts override functionalities related to token approvals, such as the inherited [`approve`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L72) and [`allowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L49) functions. Moreover, both `BeamBalanceStore` and `ERC223BeamToken` declare an internal `allowances` mapping (see [`BeamBalanceStore`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94) [at line 94](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L94) and [`ERC223BeamToken`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L22) [at line 22](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/ERC223BeamToken.sol#L22)) to independently track token allowances. Both `approve` and `allowance` were customized to work with this new `allowances` mapping.\n\n\nBesides those already mentioned, two other relevant functions are inherited from the `ERC20` contract: [`increaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L101) and [`decreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L116), which are intended to increase and decrease allowances in a way that mitigates the [known front-running vulnerability in ERC20 contracts](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit). While both functions are inherited and therefore publicly available in the contracts’ APIs, neither of these two functions are overridden in `BeamBalanceStore` nor `ERC223BeamToken` to work with the previously mentioned `allowances` mapping (as [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L434) and [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L443) do). Instead, `increaseAllowance` and `decreaseAllowance` work with the [private](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) [`_allowed`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) [mapping](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/ERC20.sol#L23) defined in the parent [`ERC20`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/token/ERC20/ERC20.sol) contract. This leads to a severe mismatch in how allowances are tracked in the contracts, breaking the token approval feature. As regular [`Approval`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9ed1b4486519113ee05fa648acb4ebcecd070cbf/contracts/token/ERC20/IERC20.sol#L22) events are emitted by these calls, they will seem successful in the eyes of the caller, yet the modification in the allowance will not be reflected when querying the [`allowance`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L443) public getter. If users notice this mismatch and thus attempt to use the [`approve`](https://github.com/BeamNetwork/currency/blob/c0d8477866a8667a37f45c85378c5938c84569cd/contracts/currency/BeamBalanceStore.sol#L434) function to increase/decrease token allowances, they will then become vulnerable to the referenced front-running attack.\n\n\nThis issue stems from having the entire token approval mechanism reimplemented in both the `BeamBalanceStore` and `ERC223BeamToken` contracts. Consider reassessing the need to redefine such functionality when it is already inherited from a secure, audited, and battle-tested contract such as OpenZeppelin’s ERC20. Should the development team still consider it necessary to adapt the inherited functions, all of them must be carefully and thoroughly tested to avoid severe bugs that can break entire contract features.\n\n\n***Update:** Fixed. The `ERC223BeamToken` contract has been removed. The [`EcoBalanceStore` contract no longer inherits from `ERC20`](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/currency/EcoBalanceStore.sol#L23). The functions `approve` and `allowance` were removed. The `allowances` mapping was removed. Eco’s statement for this issue:*\n\n\n\n> When we upgraded the OpenZeppelin contract versions that we had been building on top of, we didn’t notice significant changes in the layout of the OpenZeppelin Contracts package. Contracts that used to be interface definitions only were modified to be full implementations. This broke some functionality, and introduced duplicate implementation of others. Our tests have improved since then, and we’re more careful about upgrading dependencies.\n> \n>",
      "summary": "\nThis bug report is about two contracts, BeamBalanceStore and ERC223BeamToken, which are inheriting from OpenZeppelin’s ERC20 implementation. These contracts are attempting to integrate different token interfaces with the generational balance store. However, the contracts have overridden the approve and allowance functions, which are intended to increase and decrease allowances in a way that mitigates the known front-running vulnerability in ERC20 contracts. Additionally, both contracts have declared an internal allowances mapping to independently track token allowances. The increaseAllowance and decreaseAllowance functions, which are intended to increase and decrease allowances, are not overridden to work with the allowances mapping. This leads to a mismatch in how allowances are tracked, breaking the token approval feature. \n\nTo fix this issue, the ERC223BeamToken contract was removed and the EcoBalanceStore contract no longer inherits from ERC20. The functions approve and allowance were removed and the allowances mapping was removed. The development team should be more careful when upgrading dependencies and thoroughly test any changes to ensure that features are not broken.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11657",
      "title": "[P1-L11] Proxy delegation logic can be simplified",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nThe [fallback](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L20) function in charge of the delegation process for the proxy can be simplified. It is not necessary to use the [free memory pointer](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L23), and [`returndatasize`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L26) can be saved to a variable instead of calling it twice. Also, the [result of](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L25) [`delegatecall`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L25) can be checked after the `returndatacopy` to avoid the duplicated statement.\n\n\nBecause this code is hard to understand and Solidity does not check its safety, it is a good idea to make it as short and clear as possible.\n\n\nConsider refactoring the assembly block. See the [OpenZeppelin SDK delegate implementation](https://github.com/zeppelinos/zos/blob/7b2ed4a7ddb4ed0b84035ff4c55f7e54e80cfd40/packages/lib/contracts/upgradeability/Proxy.sol#L31) as an example of a thoroughly tested alternative.\n\n\n***Update:*** *Partially fixed. The* [*proxy implementation*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy/ForwardProxy.sol#L42) *no longer uses the free memory pointer. Eco’s statement for this issue:*\n\n\n\n> The current implementation minimizes gas overhead, which was an important design consideration for us.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11656",
      "title": "[P1-L10] Unnecessary empty constructors defined",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nBoth [`Policy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L17) and [`PolicyInit`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L16) define empty constructors, which is not necessary and only hinders code readability. According to the [Solidity docs on constructors](https://solidity.readthedocs.io/en/v0.4.24/contracts.html#constructors), “*If there is no constructor, the contract will assume the default constructor:* *`constructor() public {}`**.”*\n\n\nConsider removing all empty constructors from the codebase.\n\n\n***Update:*** *Fixed.* [*Policy*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/Policy.sol#L11) *and* [*PolicyInit*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/PolicyInit.sol#L13) *no longer have empty constructors.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11655",
      "title": "[P1-L09] Reimplementing the Ownable pattern",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponent: [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy)\n\n\n[`BeamInitializable`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol) and [`BeamBootstrap`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol) implement the Owner pattern (with the latter calling it `deployAccount`).\n\n\nConsider using the [`Ownable`](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.0.0/contracts/ownership/Ownable.sol) [contract from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/ownership/Ownable.sol) instead of reimplementing it.\n\n\n**Update:** A [comment has been added explaining the reason for not using `Ownable` from OpenZeppelin](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy/EcoInitializable.sol#L17).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11654",
      "title": "[P1-L08] There are multiple typos",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nThere are multiple typos in the repository:\n\n\nIn `policed-contracts`:\n\n\n* In [`Policed.sol`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L34) and [`PolicedUtils.sol`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L73): pf instead of “of”\n\n\n* \n\n\nConsider running [codespell](https://github.com/codespell-project/codespell) on pull requests.\n\n\n***Update:*** *Fixed. The typos mentioned above have been fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11653",
      "title": "[P1-L07] Not using the latest OpenZeppelin Contracts library",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy) and [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy)\n\n\n[`beam-bootstrap-chain`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/package.json#L42) and [`policed-contracts`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/package.json#L37) are using `openzeppelin-solidity` v1.12.0. This is an outdated release. At the time of writing, the latest stable version was v2.4.0.\n\n\nConsider updating the projects to the latest `openzeppelin-solidity` version.\n\n\n***Update:*** *Fixed. The* [*openzeppelin-solidity dependency*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/package.json#L77) *has been updated.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11652",
      "title": "[P1-L06] Unused imports",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy), [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy), and [`proxy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy)\n\n\nIn `beam-bootstrap-chain`, [`SampleForward.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/test/SampleForward.sol#L5) [imports](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/test/SampleForward.sol#L5) [`ForwardProxy`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/test/SampleForward.sol#L5) and never uses it.\n\n\nIn `policed-contracts`, [`Policy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L4) and [`PolicedUtils`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L4) import `ERC820ImplementerInterface` and never use it.\n\n\nConsider removing unused imports.\n\n\n***Update:*** *Fixed. The unused imports mentioned above have been removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11651",
      "title": "[P1-L05] Undocumented assembly code",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy), [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy), and [`proxy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy)\n\n\nIn `beam-bootstrap-chain`, the [fallback](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L20) [function of](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L20) [`ForwardProxy`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L20), and in `policed-contracts`, the [`policyCommand`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L59) [of](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L59) [`Policed`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L59) use a complex assembly block without comments.\n\n\nThis is a low-level language that is difficult to understand.\n\n\nConsider documenting the mentioned function in detail to explain the rationale behind the use of assembly and to clarify what every single assembly instruction is doing. This will make it easier for users to trust the code, for reviewers to verify it, and for developers to build on top of it or update it.\n\n\nNote that the use of assembly discards several important safety features of Solidity, so this is a highly vulnerable part of the project. Consider implementing thorough tests to cover all potential use cases of the `ForwardProxy` contract to ensure it behaves as expected.\n\n\n***Update:*** *Fixed. Extensive documentation has been added to the assembly code blocks. Tests have been added to the* [*policy*](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/test/policy) *and* [*bootstrap*](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/test/bootstrap) *contracts.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11650",
      "title": "[P1-L04] Functions can be made external to clarify intended use",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: all\n\n\nIn `beam-boostrap-chain`, [`BeamBootstrap`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L23)[‘s](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L23) [`cleanup`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L23), [`BeamInitializable`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L44)[‘s](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L44) [`cleanup`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L44), and [`setImplementation`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L21) are never called internally.\n\n\nIn `policed-contracts`, [`policyFor`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L22) is never called internally.\n\n\nConsider making the functions `external` to clarify intended use. If they should be `public`, consider documenting the reason and intended use from inside the contracts.\n\n\n***Update:*** *Fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11649",
      "title": "[P1-L03] Not following consistent code style",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: all\n\n\nA consistent code style is essential to make the code base clear and readable and to make it possible to combine contributions from wildly diverse people, as is the case in open source projects.\n\n\nConsider making every file in the project follow the documented code style guide and enforce that every new contribution sticks to this code style by adding a linter check that runs on every pull request.\n\n\nNote that [`eslint`](https://eslint.org/docs/rules/) [does not enable any rules by default](https://eslint.org/docs/rules/), so at least, the recommended rules should be added to the configuration file.\n\n\n***Update:*** *Fixed. The two repositories now follow a consistent code style and have rules and tasks for running `solhint` and `eslint`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11648",
      "title": "[P1-L02] Missing comments on the code and comments not following NatSpec",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: all\n\n\nIn the [`beam-bootstrap-chain`](https://github.com/BeamNetwork/beam-bootstrap-chain/tree/96beab1c5cfd41310bfba733ab7216426caf4a38) and  [`policed-contracts`](https://github.com/BeamNetwork/policed-contracts/tree/f9299f43e2bf3629bee2f82bf637918ac9221d62) repositories, there are some contracts, struct fields, state variables, mapping keys, functions and parameters without comments, some with comments that do not follow the [NatSpec format](https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format), and some that are missing important details on their comments.\n\n\nIn the [`deployment-nicks-method`](https://github.com/BeamNetwork/deployment-nicks-method/tree/8a8b2d3356db689ae09c6c9bc1affc86f83684f0) repository, there are no comments at all.\n\n\nThis makes it hard to understand the code and to review that the implemented functionality matches the intended behavior.\n\n\nConsider adding docstrings for all contracts, struct fields, state variables, mapping keys, and functions, paying particular attention to the ones that represent complicated concepts. Consider following the NatSpec format thoroughly for docstrings to improve documentation and code legibility.\n\n\n***Update:*** *Fixed. Many comments have been added to all the contracts. Most of them exhaustively document the parameters and strictly follow the NatSpec format.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11647",
      "title": "[P1-L01] README empty or missing important information",
      "impact": "LOW",
      "content": "###### Low\n\n\nComponents: all\n\n\nThe `README.md` on the root of the GitHub repositories are the first documents that most developers will read, so they should be complete, clear, concise, and accurate.\n\n\nThe `README.md` files of [`deployment-nicks-method`](https://github.com/BeamNetwork/deployment-nicks-method/blob/8a8b2d3356db689ae09c6c9bc1affc86f83684f0/README.md), [`beam-bootstrap-chain`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/README.md) and  [`policed-contracts`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/README.md), have little or no information about what the purpose of the project is nor how to use it.\n\n\nIn [`beam-bootstrap-chain`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/README.md), it describes a set of instructions to create a bootstrap transaction without the needed context to understand it, including a command named `generate-portable-transaction`, which is not available. A a sample of the output file used in the example `bootstrap-truffle.json` is also not available.\n\n\nConsider following [Standard Readme](https://github.com/RichardLitt/standard-readme) to define the structure and contents for the `README.md` file. Consider including an explanation of the core concepts of each repository, the usage workflows, the public APIs, instructions to test and deploy them independently, and how they relate to the other repositories in the Beam project.\n\n\n***Update:*** *Fixed. All repositories and some sub-directories now have good README files.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11646",
      "title": "[P1-M07] Lack of input validation",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nIn multiple functions, the values received as arguments are not validated.\n\n\nIn `PolicyInit.sol`:\n\n\n* In the `fusedInit` function:\n\t+ Not checking for empty arrays: [`_setters`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L42), [`_keys`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L43), [`_values`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L44), [`_tokenResolvers`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L45)\n\t+ Not checking for zero address: [`_policyCode`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L41)\n\t+ Not checking that [`uint256(_policycode)`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicyInit.sol#L50) is different from the current `implementation`. Otherwise, `implementation` might not be actually changed, and `fusedInit` could be potentially called again.\n\n\nIn `Policy.sol`:\n\n\n* In the `internalCommand` function, not checking for zero address: [`_delegate`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L28)\n\n\nIn `Policed.sol`:\n\n\n* In the `constructor`, not checking for zero address: [`_policy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L20)\n* In the `initialize` function, not checking for zero address: [`_self`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L34)\n\n\nIn `PolicedUtils.sol`:\n\n\n* In the `initialize` function, not checking for zero address: [`_self`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L47)\n* In the `setExpectedInterfaceSet` function, not checking for zero address: [`_addr`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L55)\n\n\nConsider implementing `require` clauses where appropriate to validate all user-controlled input.\n\n\n***Update:*** *Only the* [*check for a different implementation*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy/ForwardTarget.sol#L57) *has been fixed. Eco’s statement for this issue:*\n\n\n\n> The `fusedInit` function of `PolicyInit` is only called by our own code during deployment and immediately disabled, so we’re not concerned about invalid inputs. `Policy`, `Policed`, and `PolicedUtils` are library contracts that are built on top of our contracts. User-provided addresses are never passed to the functions described, so we’re not concerned about accidental 0 address values.\n> \n>",
      "summary": "\nThis bug report is about the lack of validation of user-controlled input in multiple functions of the policy component of the BeamNetwork/currency repository. The functions affected are `fusedInit` in `PolicyInit.sol`, `internalCommand` in `Policy.sol`, `constructor` and `initialize` in `Policed.sol`, and `initialize` and `setExpectedInterfaceSet` in `PolicedUtils.sol`.\n\nIn the `fusedInit` function, the values received as arguments are not checked for empty arrays, zero address, and whether `uint256(_policycode)` is different from the current `implementation`. \n\nIn the `internalCommand` function, the value received as argument `_delegate` is not checked for zero address. \n\nIn the `constructor` and `initialize` functions of `Policed.sol`, the value received as argument `_policy` is not checked for zero address. \n\nIn the `initialize` and `setExpectedInterfaceSet` functions of `PolicedUtils.sol`, the value received as argument `_self` and `_addr` is not checked for zero address. \n\nIt is recommended to implement `require` clauses to validate all user-controlled input. An update to this report states that only the check for a different implementation has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11645",
      "title": "[P1-M06] Unclear public cloning functionality",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nThe `PolicedUtils` contract includes a **public** function [`clone`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L65), which according to the docstrings, “*Creates a clone of this contract by instantiating a proxy at a new address and initializing it based on the current contract […].”*\n\n\nHowever, the rationale behind including such a functionality is never explained, nor is it clear if the function is supposed to be public and called by anyone.\n\n\n[The single test](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/test/policed.js#L74) that attempts to cover the cloning functionality is too vague and poorly documented to understand what is being tested and, more importantly, why. Furthermore, it strangely uses a [mock](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/test/FakePolicy.sol#L50) to wrap the `clone` function inside another [`cloneMe`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/test/FakePolicy.sol#L66) function, the latter being the one [called](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/test/policed.js#L75) during the test.\n\n\nConsider including further tests (while enhancing the existing one) and more thorough documentation regarding the cloning functionality. Moreover, analyze restricting the visibility of the function through custom modifiers if it is not supposed to be called publicly but only by certain privileged accounts.\n\n\n***Update:*** *Fixed.* [*More documentation has been added to the clone function*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/PolicedUtils.sol#L67)*. The* [*test has been improved*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/test/policy/policed.js#L138)*, but note that the cloneMe function is still confusing.*",
      "summary": "\nThis bug report is about the `PolicedUtils` contract in the `policy` component of the BeamNetwork/currency repository. The contract includes a public function `clone`, which is supposed to create a clone of the contract. However, the rationale behind this functionality is not explained and it is not clear if it is supposed to be public and called by anyone. The single test that attempts to cover the cloning functionality is too vague and poorly documented.\n\nTo fix this, more tests have been added and more thorough documentation has been provided for the cloning functionality. Moreover, the visibility of the function has been restricted through custom modifiers, so that it can only be called by certain privileged accounts. The test has also been improved, but the `cloneMe` function is still confusing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11644",
      "title": "[P1-M05] Missing zero address checks",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponents: [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy) and [`proxy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy)\n\n\nThe functions that take an address as an argument are not validating that the address is not `0`.\n\n\nFor example:\n\n\n* [`BeamBootstrap.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L14)[:L14](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L14)\n* [`BeamInitializable.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L11)[:L11](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L11)\n* [`ForwardProxy.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L13)[:L13](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardProxy.sol#L13)\n* [`ForwardTarget.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21)[:L21](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21)\n\n\nIn most cases, passing a `0` address is a mistake.\n\n\nConsider adding a require statement to check that the address is different from `address(0)`.\n\n\n***Update:*** *Fixed only in* [*EcoBootstrap.sol*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy/EcoBootstrap.sol#L30)*. Eco’s statement for this issue:*\n\n\n\n> Thorough testing prevents our system from mistakenly passing the 0 address when initializing a contract or configuring a proxy. Inserting code to prevent the 0 address from being passed at all also prevents us from doing so intentionally, so as a practice we avoid disallowing the 0 address in code.\n> \n>",
      "summary": "\nThis bug report is about two components, `deploy` and `proxy`, which are part of the BeamNetwork/currency repository. The bug is that functions that take an address as an argument are not validating that the address is not `0`. This means that a mistake could be made by passing a `0` address. The report provides four examples of functions that are affected by this bug.\n\nTo fix this issue, the report suggests adding a require statement to check that the address is different from `address(0)`. This issue has been fixed in the `EcoBootstrap.sol` file, and the report provides a statement from the Eco team about why they chose not to disallow the `0` address in code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11643",
      "title": "[P1-M04] Overriding initialize is confusing",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponent: [`proxy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy)\n\n\nThe [`ForwardTarget`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21) [contract defines and implements the](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21) [`initialize`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21) [function](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21). Then, the [`BeamInitializable`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L9) contract inherits from `ForwardTarget` and [overrides the](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L16) [`initialize`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L16) [function](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L16).\n\n\nIt is not clear if this function is intended to be overridden, but if so, it is not clear why it has an implementation.\n\n\nConsider documenting the intended use of `ForwardTarget` as a base class, explaining when and how to override the `initialize` function. Also, consider commenting on the overriding functions to make it clear that they are not shadowing members from the base class by mistake.\n\n\n***Update:*** *Fixed. A comment has been added to the* [*`initialize` function*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy/ForwardTarget.sol#L36) *to clarify its use.*",
      "summary": "\nThis bug report is regarding the [`ForwardTarget`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L21) contract and the [`BeamInitializable`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L9) contract. The ForwardTarget contract defines and implements the `initialize` function, and the BeamInitializable contract inherits from ForwardTarget and overrides the `initialize` function. \n\nThe bug report was that it was not clear if this function was intended to be overridden, and if so, why it had an implementation. The solution to this bug was to document the intended use of ForwardTarget as a base class, explaining when and how to override the `initialize` function. Additionally, comments were made on the overriding functions to make it clear that they were not shadowing members from the base class by mistake. The bug was successfully fixed, with a comment added to the `initialize` function to clarify its use.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11642",
      "title": "[P1-M03] Solidity optimizations in tests may cause unpredictable behavior",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponents: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy) and [`beam-bootstrap-chain`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38)\n\n\nIn [`beam-bootstrap-chain/truffle.js`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/truffle.js#L15) and [`policed-contracts/truffle.js`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/truffle.js#L11), Solidity optimizations are enabled.\n\n\nSolidity has some optimizations that are default and are always executed, and some others are optional. Enabling the optional ones increases the risk of unexpected behavior, since they are not as battle-tested as the default optimizations. Consider adding full test coverage without optimizations before enabling them to verify that the introduced optimizations preserve expected behavior.\n\n\n***Update:*** *Partially fixed.* [*Test coverage*](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c#eco-currency-and-governance-currency) *has improved a lot, but it is still not 100%. A* [*note has been added to the README*](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c#note-on-solidity-optimizations) *to take this risk into consideration. Eco’s statement for this issue:*\n\n\n\n> Our Solidity test coverage is 98%. While this is slightly less than 100%, we’re satisfied that it covers the risk introduced by using the Solidity optimizer.\n> \n>",
      "summary": "\nThis bug report concerns two components of the BeamNetwork project: `policy` and `beam-bootstrap-chain`. It was discovered that both components had enabled optional Solidity optimizations. These optimizations increase the risk of unexpected behavior, as they are not as battle-tested as the default ones. To reduce this risk, full test coverage without optimizations should be implemented before enabling them.\n\nThe bug has been partially fixed. Test coverage has improved a lot, but is still not 100%. A note has been added to the README to make users aware of the risk. The team is satisfied with the 98% coverage, as it covers the risk introduced by using the Solidity optimizer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11641",
      "title": "[P1-M02] Unit tests are not verifying a single condition",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponents: all\n\n\nEvery unit test should verify a single code path to ensure isolation and to make it easier to blame a single line of code when one of the tests fails. The test structure should follow the [four phase pattern](http://xunitpatterns.com/Four%20Phase%20Test.html), clearly separating the interactions with the system under test from the verification.\n\n\nConsider splitting the tests to make them fully isolated and as short and focused as possible. Consider following the four phase pattern on each of them. Consider following a [data-driven pattern](https://booker.codes/data-driven-tests-in-javascript-using-mocha/%E2%80%9D%20with%20%E2%80%9Chttps://web.archive.org/web/20181217141248/https://booker.codes/data-driven-tests-in-javascript-using-mocha/) for test cases with multiple scenarios like the [abs tests](https://github.com/BeamNetwork/beam-channels/blob/8f6b26301f5a96a3e397847ceedc56aaaccc9523/test/beam_math_test.js#L18).\n\n\n***Update:*** *Fixed. Many tests have been added with a nice and clean style.*",
      "summary": "\nThis bug report is about unit tests that should be written to verify a single code path. It should follow the four phase pattern, which separates interactions with the system under test from the verification. The tests should also be split into smaller, more focused tests. Additionally, a data-driven pattern should be used for test cases with multiple scenarios. This bug report has been fixed, and many tests have been added with a nice and clean style.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11640",
      "title": "[P1-M01] There are multiple hard-coded constants",
      "impact": "MEDIUM",
      "content": "###### Medium\n\n\nComponents: all\n\n\nHard-coded booleans, numbers, and strings in the code are hard to understand, and they are prone to error, because after some time, their origin and context can be forgotten or mistaken.\n\n\nFor example:\n\n\nIn `deployment-nicks-method`:\n\n\n* [`index.js`](https://github.com/BeamNetwork/deployment-nicks-method/blob/8a8b2d3356db689ae09c6c9bc1affc86f83684f0/index.js#L40)[:L40](https://github.com/BeamNetwork/deployment-nicks-method/blob/8a8b2d3356db689ae09c6c9bc1affc86f83684f0/index.js#L40)\n\n\nIn `beam-bootstrap-chain`:\n\n\n* [`BeamBootstrap.sol`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L17)[:L17](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L17): hard-coded `20`\n* [`truffle.js`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/truffle.js#L9)[:L9](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/truffle.js#L9): hard-coded address\n\n\nIn `policed-contracts`:\n\n\n* [`Policy.sol`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L59)[:L59](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L59): hard-coded address\n* `erc820.js`:[L5](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/erc820.js#L5): bytecode without comment\n* `erc820.js`:[L9](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/erc820.js#L9): hard-coded address\n* `erc820.js`:[L10](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/erc820.js#L10): hard-coded address\n\n\nConsider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For the complex values, consider adding a comment explaining how they were calculated or why they were chosen.\n\n\n***Update:*** *Fixed. All the hard-coded values mentioned above have been moved to constants, commented, or removed.*",
      "summary": "\nThis bug report is about hard-coded values in the code which are prone to errors and hard to understand. Hard-coded values refer to booleans, numbers, and strings which are not defined as variables in the code. An example of hard-coded values is given in the report. The report suggests that for every hard-coded value, a constant variable should be defined with a clear and explanatory name. For the complex values, a comment should be added to explain how they were calculated or why they were chosen. The bug report was later updated to indicate that the hard-coded values have been fixed and moved to constants, commented, or removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11639",
      "title": "[P1-H03] Outdated ERC820",
      "impact": "HIGH",
      "content": "###### High\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\nIn [line 59 of `Policy.sol`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol#L59) and in [line 49 of `PolicedUtils.sol`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/PolicedUtils.sol#L49), the hard-coded address for the `ERC820Registry` contract is outdated.\n\n\nThe address used is `0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7`.\n\n\nThe correct address is `0x820b586C8C28125366C998641B09DCbE7d4cBF06`.\n\n\nAlso, the `npm` dependency [`“erc820”: “0.0.22”`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/package.json#L46) is outdated. Moreover, it is set as fixed in the `package.json` file, so not even minor changes in the versions will be downloaded when users run `npm install`.\n\n\nThe address and version used correspond to a previous version while the standard was a work in progress. Now, the standard is on the final call, but there is still a chance that a new version will be released and/or that the address will change.\n\n\nConsider changing the address of the `ERC820Registry` to point it to the actual one. Consider updating the version of the `erc820` package and allowing it to install newer minor versions.\n\n\nFor further reference: <https://eips.ethereum.org/EIPS/eip-820>\n\n\nBefore deploying to production, confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.\n\n\n***Update:*** *Fixed. The EIP 820 is now final, but the Eco team found and reported an issue to the implementation. A new EIP 1820 was proposed to fix it, and it now supersedes EIP 820. The contracts are now [using the upstream implementation of EIP 1820](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/package.json#L71)**.*",
      "summary": "\nThis bug report is about the outdated address and version of the `ERC820Registry` contract and the `npm` dependency `“erc820”: “0.0.22”` which are used in the `Policy.sol` and `PolicedUtils.sol` files. The address used is `0x820c4597Fc3E4193282576750Ea4fcfe34DdF0a7` while the correct address is `0x820b586C8C28125366C998641B09DCbE7d4cBF06`. The version used corresponds to a previous version while the standard was a work in progress.\n\nThe Eco team suggested to change the address of the `ERC820Registry` to point it to the actual one and to update the version of the `erc820` package to allow it to install newer minor versions. Before deploying to production, it is important to confirm that the EIP is final, that the address has not changed, and that the package version used is the latest.\n\nThe bug has been fixed as the EIP 820 is now final and a new EIP 1820 was proposed to fix the issue. The contracts are now using the upstream implementation of EIP 1820.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11638",
      "title": "[P1-H02] Low unit test coverage",
      "impact": "HIGH",
      "content": "###### High\n\n\nComponents: all\n\n\nIn the [`deployment-nicks-method`](https://github.com/BeamNetwork/deployment-nicks-method/tree/8a8b2d3356db689ae09c6c9bc1affc86f83684f0) [repository](https://github.com/BeamNetwork/deployment-nicks-method/tree/8a8b2d3356db689ae09c6c9bc1affc86f83684f0), there are no tests at all.\n\n\nIn `beam-bootstrap-chain`:\n\n\n* Test case file named [`compute-gas.js`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/test/compute-gas.js#L1) only deploys a `BeamBootstrap` contract and nothing more. It does not compute gas as supposedly intended.\n* The `ForwardTarget` and `BeamBootstrap` contracts have no unit tests.\n\n\nIn [`policed-contracts`](https://github.com/BeamNetwork/policed-contracts/tree/f9299f43e2bf3629bee2f82bf637918ac9221d62), only the `Policed` contract has tests.\n\n\nTests are the best way to specify the expected behavior of a system. Automating these tests and running them continuously pins down the behavior to make sure that it is not broken by future changes.\n\n\nConsider adding unit tests for every code path. Consider running the tests on every pull request.\n\n\n***Update:*** *Partially fixed. Extensive tests have been added to the* *[`currency`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c#eco-currency-and-governance-currency) repository. However,* *it has [92% of test coverage](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c#eco-currency-and-governance-currency). See Eco’s statement for this issue in **[P1-H01] Missing test coverage reports**.*",
      "summary": "\nThis bug report is about the lack of tests in the BeamNetwork project. Tests are important for ensuring that the project behaves as expected. The `deployment-nicks-method` repository had no tests at all, and the `beam-bootstrap-chain` repository only had a test case file that did not compute gas. The `policed-contracts` repository had tests for the `Policed` contract, but not for other components.\n\nThe bug has been partially fixed, with extensive tests added to the `currency` repository. However, it still has 92% test coverage.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11637",
      "title": "[P1-H01] Missing test coverage reports",
      "impact": "HIGH",
      "content": "###### High\n\n\nComponents: all\n\n\nThere are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.\n\n\nConsider adding the test coverage reports and making it reach at least 95% of the source code.\n\n\n***Update:*** *Partially fixed. The* [*test coverage report*](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c#eco-currency-and-governance-currency) *was added to the currency repository, reporting 92% of coverage. Eco’s statement for this issue:*\n\n\n\n> Test coverage of our contracts is around 98%. Our overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. Coverage on the JavaScript code is intentionally less thorough, approximately 87%. This allows us to iterate more quickly on the JavaScript code, while still covering the core functionality.\n> \n>",
      "summary": "\nThis bug report describes an issue where there are no test coverage reports on any of the repositories. Without these reports, it is impossible to know whether there are parts of the code which are never executed by the automated tests. For every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving. The solution proposed was to add the test coverage reports and make it reach at least 95% of the source code.\n\nThe issue was partially fixed by adding the test coverage report to the currency repository, which reported 92% of coverage. The overall coverage reporting includes the additional JavaScript tooling included in the repository, used for deployment and testing. The coverage on the JavaScript code is intentionally less thorough, around 87%, to allow for quicker iteration on the JavaScript code while still covering the core functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11636",
      "title": "[P1-C02] Storage collision on Policed contract",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nComponent: [`policy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy)\n\n\n[`Policy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol) [contracts](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol) have the power to enforce actions over [`Policed`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol) [contracts](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol) (i.e., the latter are managed by the former). This means that `Policy` contracts are allowed to execute arbitrary code in a `Policed` contract context, as long as the `Policy` contract is set as the manager during construction.\n\n\nThis enforcement of actions is done via the [`policyCommand`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L59) [function of the `Policed` contract](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L59), which can only be executed by the managing policy – this last restriction being enforced by the custom [`onlyPolicy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L15) [modifier](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol#L15).\n\n\nThe `policyCommand` function, acting as a proxy, uses a low-level assembly implementation of `delegatecall` to allow any address passed in the `_delegate` parameter to execute any logic but in its context (i.e., with access to the `Policed` contract storage). While this operation may be initially considered safe, since it is the `Policy` contract that is triggering it, the logic contract in charge of executing the code may unexpectedly overwrite the whole `Policed` contract storage due to the storage collision vulnerability. This vulnerability can be exploited as follows.\n\n\nGiven a Policy contract such as:\n\n\n\n```\npragma solidity ^0.4.24;\n\nimport \"../contracts/Policy.sol\";\nimport \"../contracts/Policed.sol\";\ncontract BadPolicy is Policy {\n    function execute(address policedAddr, address logicAddress, bytes data) public {\n        // This contract manages the contract at `policedAddr`, so it can call `policyCommand`\n        Policed(policedAddr).policyCommand(logicAddress, data);\n    }\n}\n```\n\nAnd the following contract with some logic that the Policy is going to enforce over the Policed contract:\n\n\n\n```\npragma solidity ^0.4.24;\n\ncontract BadLogic {\n    address public firstSlot = address(0x123);\n    address public secondSlot = address(0x123);\n\n    event Overwrite();\n\n    /**\n     * Instead of writing to this contract state variables,\n     * when overwriter is called via delegatecall, it will end up\n     * writing to the caller's state variables at first and second\n     * position of the caller's storage.\n     */\n    function overwriter() public {\n        firstSlot = address(0);\n        secondSlot = address(0);\n    }\n\n    // [... some more logic ...]\n}\n```\n\nBy looking at the `overwriter` function, one could initially think that it will just write over its `firstSlot` and `secondSlot` state variables, no matter how it is called. However, as the logic contract will be called via a `delegatecall`, the `overwriter` function will unexpectedly write over the first and second slot of the `Policed` contract (i.e., over the `implementation` variable in the first slot and the `policy` variable in the second slot, with the former inherited from `ForwardTarget`), without ever writing to its own state variables `firstSlot` and `secondSlot`.\n\n\nHere is a snippet of the Policed contract showing its state variable `policy`:\n\n\n\n```\npragma solidity ^0.4.25;\npragma experimental \"v0.5.0\";\n\nimport \"erc820/contracts/ERC820ImplementerInterface.sol\";\nimport \"@beamnetwork/bootstrap-chain/contracts/ForwardTarget.sol\";\n\n\n/** @title Policed Contracts\n *\n * A policed contract is any contract managed by a policy.\n */\ncontract Policed is ForwardTarget, ERC820ImplementerInterface {\n    address public policy;\n// [...]\n}\n```\n\nA proof of concept of this issue goes as follows:\n\n\n\n```\nconst BadPolicy = artifacts.require('./BadPolicy.sol');\nconst BadLogic = artifacts.require('./BadLogic.sol');\nconst Policed = artifacts.require('Policed');\nconst assert = require('assert');\n\ncontract.only('Policed contract', () => {\n  const NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n  beforeEach(async function () {\n    this.badPolicy = await BadPolicy.new();\n\n    // BadPolicy contract manages the Policed contract\n    this.policed = await Policed.new(this.badPolicy.address);\n\n    this.badlogic = await BadLogic.new();\n  });\n\n  describe('Storage collision', () => {\n    it('overwrites Policed contract storage', async function () {\n      // First, assert that initially the storage is not null\n\n      // `implementation` is at slot 1, inherited from ForwardTarget contract\n      assert.notEqual(await this.policed.implementation(), 0);\n      // `policy` is at slot 2, defined at Policed contract\n      assert.equal(await this.policed.policy(), this.badPolicy.address);\n\n      // Make the managing policy execute the `overwriter` function in BadLogic contract\n      const functionSignature = web3.utils.sha3('overwriter()').slice(0, 10);\n      await this.badPolicy.execute(this.policed.address, this.badlogic.address, functionSignature);\n\n      // Assert that the state variables at BadLogic were never written\n      assert.notEqual(await this.badlogic.firstSlot(), NULL_ADDRESS);\n      assert.notEqual(await this.badlogic.secondSlot(), NULL_ADDRESS);\n\n      // Assert that finally the whole storage\n      // was accidentally overwritten by BadLogic.sol#overwriter. Boom.\n      assert.equal(await this.policed.implementation(), 0);\n      assert.equal(await this.policed.policy(), NULL_ADDRESS);\n    });\n  });\n});\n```\n\nLow-level calls such as `delegatecall` are always to be implemented with utter care and be thoroughly tested. Strategies to avoid this vulnerability, along with further cases and explanations, can be found at [OpenZeppelin SDK documentation on unstructured storage](https://docs.openzeppelin.com/sdk/2.5/pattern.html#unstructured-storage-proxies).\n\n\n***Update:*** *Partially fixed. The* [*`implementation`*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy/ForwardTarget.sol#L55) *is now stored in unstructured storage. The* [*`policy`*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/policy/Policed.sol#L16) *variable is still stored in the first slot of the delegator contract, making it vulnerable to storage collisions. Eco’s statement for this issue:*\n\n\n\n> The unstructured storage approach recommended by OpenZeppelin here does help prevent accidental storage collisions, but at the same time it significantly complicates maintenance and upgrades in the future. Eco’s engineering team has adopted OpenZeppelin’s unstructured storage approach for the core proxy functionality (the `implementation` slot), but prefers to adopt policies and develop tools to manage the risk for other parts of the system. Specifically, when dealing with the `policy` slot identified here, we plan to extend our linter rules and thoroughly test upgrades to ensure collisions do not cause problems.\n> \n>",
      "summary": "\nThis bug report is about a vulnerability in the [`Policy`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policy.sol) and [`Policed`](https://github.com/BeamNetwork/policed-contracts/blob/f9299f43e2bf3629bee2f82bf637918ac9221d62/contracts/Policed.sol) contracts. The `Policy` contract has the power to enforce actions over the `Policed` contract, and does so via the `policyCommand` function. This function uses a low-level assembly implementation of `delegatecall` to allow any address passed in the `_delegate` parameter to execute any logic but in its context, with access to the `Policed` contract storage. \n\nThe vulnerability lies in the fact that the logic contract in charge of executing the code may unexpectedly overwrite the whole `Policed` contract storage due to the storage collision vulnerability. This can be exploited by making the managing policy execute the `overwriter` function in a BadLogic contract, which will end up writing to the caller's state variables at first and second position of the caller's storage, instead of writing to its own state variables. \n\nThe `implementation` variable of the `Policed` contract has been partially fixed, as it is now stored in unstructured storage. However, the `policy` variable is still stored in the first slot of the delegator contract, making it vulnerable to storage collisions. Eco’s engineering team has adopted OpenZeppelin’s unstructured storage approach for the core proxy functionality, but plans to extend their linter rules and thoroughly test upgrades to ensure collisions do not cause problems.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11635",
      "title": "[P1-C01] The bootstrap process can be hijacked",
      "impact": "HIGH",
      "content": "###### Critical\n\n\nComponents: [`deploy`](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy) and [proxy](https://github.com/BeamNetwork/currency/tree/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/proxy)\n\n\nThe [`BeamBootstrap`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L10) contract stores its owner in the [`deployAccount`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L11) [variable](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L11), which also gets transferred to [20](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L17) [`ForwardProxy`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamBootstrap.sol#L17) contracts through [`BeamInitializable`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L9).\n\n\nThe `BeamInitializable` contract also uses an ownership pattern, which allows only the owner to [set the implementation](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L23) that will be delegated from the proxy and to [`selfdestruct`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L45) [the contract](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L45).\n\n\nThe issue here is that the [`initialize`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L16) [function](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/BeamInitializable.sol#L16) is `public`. It does not have a restriction that only the owner can call, and it can be called more than once.\n\n\nFor an attacker to hijack the entire Bootstrap process, it would only require them to deploy a malicious contract like this:\n\n\n\n```\ncontract Malicious {\n    address public owner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n}\n```\n\nThis sets an address in their control as the `owner`. Then, they can feed it to the 20 `FordwardProxy`s through a `BeamInitializable` interface, call `initialize` with the address of the `Malicious` contract, and give themselves ownership of all the `ForwardProxy`s.\n\n\nThey can also get ownership of the original `BeamInitializable` contract, but that does not seem to give them any gain.\n\n\nTest case: <https://gist.github.com/mattaereal/9a7fe9d20b3c3253b1effe049cb9211e>\n\n\nConsider requiring that only the `owner` can call the `initialize` function, thus making it possible to call it only once during initialization with the [`onlyConstruction`](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L11) [modifier](https://github.com/BeamNetwork/beam-bootstrap-chain/blob/96beab1c5cfd41310bfba733ab7216426caf4a38/contracts/ForwardTarget.sol#L11).\n\n\n***Update:*** *Partially fixed. The* [*`destruct`*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy/EcoInitializable.sol#L56) *function now can be called only by the* *`owner`**. The* [*`initialize`*](https://github.com/BeamNetwork/currency/blob/af3428020545e3f3ae2f3567b94e1fbc5e5bdb4c/contracts/deploy/EcoInitializable.sol#L62) *function can be called only once. However,* *`initialize`* *can still be called by any account, not just by its current owner. Eco’s statement for this issue:*\n\n\n\n> The problem highlighted here has two parts to consider. First, the addresses reserved by `EcoBootstrap` respond to the `initialize` call described. These proxy contracts have their `implementation` slot set, so the `onlyConstruction` modifier will prevent calls. The modifier might not protect the underlying implementation contract though – since the underlying implementation isn’t itself a proxy contract the `implementation` slot might not be set. Fortunately, the `ForwardTarget` constructor is run when the `EcoInitializable` contract is deployed, and it sets the `implementation` slot. This makes it impossible to call `initialize` on the underlying implementation contract.\n> \n> \n> Per OpenZeppelin’s audit, `initialize` can only be called once on any proxy, and it’s always called immediately during proxy construction – ensured by the `ForwardProxy` constructor. Further, the `onlyConstruction` modifier checks the `implementation` slot, which is set in the `EcoInitializable` constructor preventing any calls at all on contracts that are deployed directly. OpenZeppelin’s finding is correct, any account can make the one permissible call `initialize`, but there is no exposure here because either the `ForwardProxy` constructor or the `EcoInitializable` constructor always consumes the call.\n> \n>",
      "summary": "\nThis bug report is about the BeamBootstrap contract and its related components. The BeamBootstrap contract stores its owner in the deployAccount variable, which is transferred to 20 ForwardProxy contracts through BeamInitializable. The issue is that the initialize function of BeamInitializable is public, so it can be called more than once. This means that an attacker can deploy a malicious contract and feed it to the 20 ForwardProxy contracts, thus hijacking the entire Bootstrap process.\n\nTo fix this issue, consider requiring that only the owner can call the initialize function, thus making it possible to call it only once during initialization with the onlyConstruction modifier. The issue has been partially fixed so the destruct function can now be called only by the owner. The initialize function can be called only once, but it can still be called by any account, not just by its current owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Eco Contracts Audit",
      "source_link": "https://blog.openzeppelin.com/eco-contracts-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "13870",
      "title": "BlockController - maintainer should be the only entity to set new authority ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit 25c2560e3b2e40ce9a10c40da97c3f79afc2c641](https://github.com/omisego/plasma-contracts/pull/434/commits/25c2560e3b2e40ce9a10c40da97c3f79afc2c641) with the removal of the `setAuthority` function.\n\n\n#### Description\n\n\n**code/plasma\\_framework/contracts/src/framework/BlockController.sol:L69-L72**\n\n\n\n```\nfunction setAuthority(address newAuthority) external onlyFrom(authority) {\n    require(newAuthority != address(0), \"Authority address cannot be zero\");\n    authority = newAuthority;\n}\n\n```\n`deployer` initially sets the account that is allowed to submit new blocks as `authority`. `authority` can then set a new `authority` at will. In a system that is set-up and maintained by a `maintainer` role (multi-sig) that can upgrade certain parts of the system it is unexpected for another role to be able to pass along its permissions. The [security specification](https://github.com/omisego/plasma-contracts/blob/422f77adabbcca0061cbf73df2ac12b73ed054f8/security/spec.md) notes that the `authority` role is only used to submit blocks:\n\n\n\n> \n> Authority: EOA used exclusively to submit plasma block hashes to the root chain. The child chain assumes at deployment that the authority account has nonce zero and no transactions have been sent from it.\n> \n> \n> \n\n\nHowever, **no transactions** might not be possible as `authority` is the only one to `activateChildChain`. Once activated, the child chain cannot be de-activated but the `authority` can change.\n\n\n[elixir-omg#managing-the-operator-address](https://github.com/omisego/elixir-omg#managing-the-operator-address) notes the following for `operator` aka `authority`:\n\n\n\n> \n> As a consequence, the operator address must never send any other transactions, if it intends to continue submitting blocks. (Workarounds to this limitation are available, if there’s such requirement.)\n> \n> \n> \n\n\nAdditionally, `setAuthority` should emit an event to allow participants to react to this change in the system and have an audit trial.\n\n\n#### Remediation\n\n\nRemove the `setAuthority` function, or clarify its intended purpose and add an event so it can be detected by users.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/403>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13869",
      "title": "PlasmaFramework - Can omit inheritance of VaultRegistry",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe contract `PlasmaFramework` inherits `VaultRegistry` even though it does not use any of the methods directly. Also `BlockController` inherits `VaultRegistry` effectively adding all of the needed functionality in there.\n\n\n#### Remediation\n\n\n`PlasmaFramework` does not need to inherit `VaultRegistry`, thus the import and the inheritance can be removed from `PlasmaFramework.sol`.\n\n\n\n```\n import \"./BlockController.sol\";\n import \"./ExitGameController.sol\";\n-import \"./registries/VaultRegistry.sol\";\n import \"./registries/ExitGameRegistry.sol\";\n\n-contract PlasmaFramework is VaultRegistry, ExitGameRegistry, ExitGameController, BlockController {\n+contract PlasmaFramework is ExitGameRegistry, ExitGameController, BlockController {\n     uint256 public constant CHILD_BLOCK_INTERVAL = 1000;\n\n     /**\n\n```\nAll tests still pass after removing the inheritance.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13868",
      "title": "BlockController - inaccurate description of childBlockInterval for submitDepositBlock",
      "impact": "LOW",
      "content": "#### Description\n\n\nThe Vault calls `submitDepositBlock` when a user deposits funds into the plasma chain. Each deposit transaction creates one deposit block on the plasma chain. The number of deposit blocks between two child blocks is limited by the `childBlockInterval`. For example, a `childBlockInterval` of `1` would not allow any deposit blocks, a `childBlockInterval` of `2` would allow one deposit block after each child block `[child][optional: deposit][child][optional: deposit]`.\n\n\n**code/plasma\\_framework/contracts/src/framework/BlockController.sol:L96-L114**\n\n\n\n```\n/\\*\\*\n \\* @notice Submits a block for deposit\n \\* @dev Block number adds 1 per submission; it's possible to have at most 'childBlockInterval' deposit blocks between two child chain blocks\n \\* @param \\_blockRoot Merkle root of the Plasma block\n \\* @return The deposit block number\n \\*/\nfunction submitDepositBlock(bytes32 \\_blockRoot) public onlyFromNonQuarantinedVault returns (uint256) {\n    require(isChildChainActivated == true, \"Child chain has not been activated by authority address yet\");\n    require(nextDeposit < childBlockInterval, \"Exceeded limit of deposits per child block interval\");\n\n    uint256 blknum = nextDepositBlock();\n    blocks[blknum] = BlockModel.Block({\n        root : \\_blockRoot,\n        timestamp : block.timestamp\n    });\n\n    nextDeposit++;\n    return blknum;\n}\n\n```\nHowever, the comment at line 98 mentions the following:\n\n\n\n> \n> [..] it’s possible to have at most ‘childBlockInterval’ deposit blocks between two child chain blocks [..]\n> \n> \n> \n\n\nThis comment is inaccurate, as a `childBlockInterval` of `1` would not allow deposits at all (Note how `nextDeposit` is always `>=1`).\n\n\n#### Remediation\n\n\nThe comment should read: [..] it’s possible to have at most ‘childBlockInterval -1’ deposit blocks between two child chain blocks [..]. Make sure to properly validate inputs for these values when deploying the contract to avoid obvious misconfiguration.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13867",
      "title": "PaymentExitGame contains several redundant plasmaFramework declarations",
      "impact": "LOW",
      "content": "#### Description\n\n\n`PaymentExitGame` inherits from both `PaymentInFlightExitRouter` and `PaymentStandardExitRouter`. All three contracts declare and initialize their own `PlasmaFramework` variable. This pattern can be misleading, and may lead to subtle issues in future versions of the code.\n\n\n#### Examples\n\n\n1. `PaymentExitGame` declaration:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/PaymentExitGame.sol:L18**\n\n\n\n```\nPlasmaFramework private plasmaFramework;\n\n```\n2. `PaymentInFlightExitRouter` declaration:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/routers/PaymentInFlightExitRouter.sol:L53**\n\n\n\n```\nPlasmaFramework private framework;\n\n```\n3. `PaymentStandardExitRouter` declaration:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/routers/PaymentStandardExitRouter.sol:L45**\n\n\n\n```\nPlasmaFramework private framework;\n\n```\nEach variable is initialized in the corresponding file’s constructor.\n\n\n#### Recommendation\n\n\nIntroduce an inherited contract common to `PaymentStandardExitRouter` and `PaymentInFlightExitRouter` with the `PlasmaFramework` variable. Make the variable internal so it is visible to inheriting contracts.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13866",
      "title": "BondSize - effectiveUpdateTime should be uint64",
      "impact": "LOW",
      "content": "#### Description\n\n\nIn BondSize, the mechanism to update the size of the bond has a grace period after which the new bond size becomes active.\n\n\nWhen updating the bond size, the time is casted as a `uint64` and saved in a `uint128` variable.\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/BondSize.sol:L24**\n\n\n\n```\nuint128 effectiveUpdateTime;\n\n```\n**code/plasma\\_framework/contracts/src/exits/utils/BondSize.sol:L11**\n\n\n\n```\nuint64 constant public WAITING\\_PERIOD = 2 days;\n\n```\n**code/plasma\\_framework/contracts/src/exits/utils/BondSize.sol:L57**\n\n\n\n```\nself.effectiveUpdateTime = uint64(now) + WAITING\\_PERIOD;\n\n```\nThere’s no need to use a `uint128` to save the time if it never will take up that much space.\n\n\n#### Recommendation\n\n\nChange the type of the `effectiveUpdateTime` to `uint64`.\n\n\n\n```\n- uint128 effectiveUpdateTime;\n+ uint64 effectiveUpdateTime;\n\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13865",
      "title": "No existence checks on framework block and timestamp reads ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit c5e5a460a2082b809a2c45b2d6a69b738b34937a](https://github.com/omisego/plasma-contracts/commit/c5e5a460a2082b809a2c45b2d6a69b738b34937a) by adding checks that block root and timestamp reads return nonzero values.\n\n\n#### Description\n\n\nThe exit game libraries make several queries to the main `PlasmaFramework` contract where plasma block hashes and timestamps are stored. In multiple locations, the return values of these queries are not checked for existence.\n\n\n#### Examples\n\n\n1. `PaymentStartStandardExit.setupStartStandardExitData`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartStandardExit.sol:L124**\n\n\n\n```\n(, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum());\n\n```\n2. `PaymentChallengeIFENotCanonical.respond`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L176**\n\n\n\n```\n(bytes32 root, ) = self.framework.blocks(utxoPos.blockNum());\n\n```\n3. `PaymentPiggybackInFlightExit.enqueue`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L167**\n\n\n\n```\n(, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum());\n\n```\n4. `TxFinalizationVerifier.checkInclusionProof`:\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/TxFinalizationVerifier.sol:L54**\n\n\n\n```\n(bytes32 root,) = data.framework.blocks(data.txPos.blockNum());\n\n```\n#### Recommendation\n\n\nAlthough none of these examples seem exploitable, adding existence checks makes it easier to reason about the code. Each query to `PlasmaFramework.blocks` should be followed with a check that the returned value is nonzero.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/463>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13864",
      "title": "ECDSA error value is not handled ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit 32288ccff5b867a7477b4eaf3beb0587a4684d7a](https://github.com/omisego/plasma-contracts/pull/459/commits/32288ccff5b867a7477b4eaf3beb0587a4684d7a) by adding a check that the returned value is nonzero.\n\n\n#### Description\n\n\nThe OpenZeppelin `ECDSA` library returns `address(0x00)` for many cases with malformed signatures:\n\n\n**contracts/cryptography/ECDSA.sol:L57-L63**\n\n\n\n```\nif (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n    return address(0);\n}\n\nif (v != 27 && v != 28) {\n    return address(0);\n}\n\n```\nThe `PaymentOutputToPaymentTxCondition` contract does not explicitly handle this case:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/spendingConditions/PaymentOutputToPaymentTxCondition.sol:L65-L68**\n\n\n\n```\naddress payable owner = inputTx.outputs[outputIndex].owner();\nrequire(owner == ECDSA.recover(eip712.hashTx(spendingTx), signature), \"Tx in not signed correctly\");\n\nreturn true;\n\n```\n#### Recommendation\n\n\nAdding a check to handle this case will make it easier to reason about the code.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/454>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13863",
      "title": "Recommendation: Remove WireTransaction and PaymentOutputModel. Fold functionality into an extended PaymentTransactionModel",
      "impact": "LOW",
      "content": "#### Description\n\n\nRLP decoding is performed on transaction bytes in each of `WireTransaction`, `PaymentOutputModel`, and `PaymentTransactionModel`. The latter is the primary decoding function for transactions, while the former two contracts deal with outputs specifically.\n\n\nBoth `WireTransaction` and `PaymentOutputModel` make use of `RLPReader` to decode transaction objects, and both implement very similar features. Rather than having a codebase with two separate definitions for `struct Output`, `PaymentTransactionModel` should be extended to implement all required functionality.\n\n\n#### Examples\n\n\n* `PaymentTransactionModel` should include three distinct decoding functions:\n\t+ `decodeDepositTx` decodes a deposit transaction, which has no inputs and exactly 1 output.\n\t+ `decodeSpendTx` decodes a spend transaction, which has exactly 4 inputs and 4 outputs.\n\t+ `decodeOutput` decodes an output, which is a long list with 4 fields (`uint`, `address`, `address`, `uint`)\n\n\nA mock implementation including `decodeSpendTx` and `decodeOutput` is shown here: <https://gist.github.com/wadeAlexC/7820c0cd82fd5fdc11a0ad58a84165ae>\n\n\nOmiseGo may want to consider enforcing restrictions on the ordering of empty and nonempty fields here as well.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/456>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13862",
      "title": "Recommendation: Remove optional arguments and clean unused code ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [omisego/plasma-contracts#496](https://github.com/omisego/plasma-contracts/pull/496) and [omisego/plasma-contracts#503](https://github.com/omisego/plasma-contracts/pull/503) with the removal of the output guard handler pattern, the simplification of the tx finalization check via `MoreVpFinalization`, and the removal of various unused function parameters and struct fields.\n\n\n#### Description\n\n\nSeveral locations in the codebase feature unused arguments, functions, return values, and more. There are two primary reasons to remove these artifacts from the codebase:\n\n\n1. Mass exits are the primary safeguard against a byzantine operator. The biggest bottleneck of a mass exit is transaction throughput, so plasma rootchain implementations should strive to be as efficient as possible. Many unused features require external calls, memory allocation, unneeded calculation, and more.\n2. The contracts are set up to be extensible by way of the addition of new exit games to the system. “Optional” or unimplemented features in current exit games should be removed for simplicity’s sake, as they currently make up a large portion of the codebase.\n\n\n#### Examples\n\n\n* Output guard handlers\n\n\n\t+ These offer very little utility in the current contracts. The main contract, `PaymentOutputGuardHandler`, has three functions:\n\t\t- `isValid` enforces that some “preimage” value passed in via calldata has a length of zero. This could be removed along with the unused “preimage” parameter.\n\t\t- `getExitTarget` converts a `bytes20` to `address payable` (with the help of `AddressPayable.sol`). This could be removed in favor of using `AddressPayable` directly where needed.\n\t\t- `getConfirmSigAddress` simply returns an empty address. This should be removed wherever used - empty fields should be a rare exception or an error, rather than being injected as unused values into critical functions.\n\t+ The minimal utility offered comes at the price of using an external call to the `OutputGuardHandlerRegistry`, as well as an external call for each of the functions mentioned above. Overall, the existence of output guard handlers adds thousands of gas to the exit process.\n\t+ Referenced contracts: `IOutputGuardHandler`, `OutputGuardModel`, `PaymentOutputGuardHandler`, `OutputGuardHandlerRegistry`\n* Payment router arguments\n\n\n\t+ Several fields in the exit router structs are marked “optional,” and are not used in the contracts. While this is not particularly impactful, it does clutter and confuse the contracts. Many “optional” fields are referenced and passed into functions which do not use them. Of note is the crucially-important signature verification function, `PaymentOutputToPaymentTxCondition.verify`, where `StartExitData.inputSpendingConditionOptionalArgs` resolves to an unnamed parameter:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L323-L332**\n\n\n\n```\nbool isSpentByInFlightTx = condition.verify(\n    exitData.inputTxs[i],\n    exitData.inputUtxosPos[i].outputIndex(),\n    exitData.inputUtxosPos[i].txPos().value,\n    exitData.inFlightTxRaw,\n    i,\n    exitData.inFlightTxWitnesses[i],\n    exitData.inputSpendingConditionOptionalArgs[i]\n);\nrequire(isSpentByInFlightTx, \"Spending condition failed\");\n\n```\n**code/plasma\\_framework/contracts/src/exits/payment/spendingConditions/PaymentOutputToPaymentTxCondition.sol:L40-L47**\n\n\n\n```\nfunction verify(\n    bytes calldata inputTxBytes,\n    uint16 outputIndex,\n    uint256 inputTxPos,\n    bytes calldata spendingTxBytes,\n    uint16 inputIndex,\n    bytes calldata signature,\n    bytes calldata /\\*optionalArgs\\*/\n\n```\nThe additional fields clutter the namespace of each struct, confusing the purpose of the other fields. For example, `PaymentInFlightExitRouterArgs.StartExitArgs` features two fields, `inputTxsConfirmSigs` and `inFlightTxsWitnesses`, the former of which is marked “optional”. In fact, the `inFlightTxsWitnesses` field ends up containing the signatures passed to the spending condition verifier and `ECDSA` library:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/routers/PaymentInFlightExitRouterArgs.sol:L4-L24**\n\n\n\n```\n/\\*\\*\n\\* @notice Wraps arguments for startInFlightExit.\n\\* @param inFlightTx RLP encoded in-flight transaction.\n\\* @param inputTxs Transactions that created the inputs to the in-flight transaction. In the same order as in-flight transaction inputs.\n\\* @param inputUtxosPos Utxos that represent in-flight transaction inputs. In the same order as input transactions.\n\\* @param outputGuardPreimagesForInputs (Optional) Output guard pre-images for in-flight transaction inputs. Length must always match that of the inputTxs\n\\* @param inputTxsInclusionProofs Merkle proofs that show the input-creating transactions are valid. In the same order as input transactions.\n\\* @param inputTxsConfirmSigs (Optional) Confirm signatures for the input txs. Should be empty bytes if the input tx is MoreVP. Length must always match that of the inputTxs\n\\* @param inFlightTxWitnesses Witnesses for in-flight transaction. In the same order as input transactions.\n\\* @param inputSpendingConditionOptionalArgs (Optional) Additional args for the spending condition for checking inputs. Should provide empty bytes if nothing is required. Length must always match that of the inputTxs\n\\*/\nstruct StartExitArgs {\n    bytes inFlightTx;\n    bytes[] inputTxs;\n    uint256[] inputUtxosPos;\n    bytes[] outputGuardPreimagesForInputs;\n    bytes[] inputTxsInclusionProofs;\n    bytes[] inputTxsConfirmSigs;\n    bytes[] inFlightTxWitnesses;\n    bytes[] inputSpendingConditionOptionalArgs;\n}\n\n```\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/457>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13861",
      "title": "Recommendation: Implement additional existence and range checks on inputs and storage reads",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was partially addressed in [omisego/plasma-contracts#524](https://github.com/omisego/plasma-contracts/pull/524) and [omisego/plasma-contracts#483](https://github.com/omisego/plasma-contracts/pull/483). Not all recommended checks were included.\n\n\n#### Description\n\n\nMany input validation and storage read checks are made implicitly, rather than explicitly. The following compilation notes each line of code in the exit controller contracts where an additional check should be added.\n\n\n#### Examples\n\n\n##### 1. `PaymentChallengeIFEInputSpent`:\n\n\n* Check that `inFlightTx` has a nonzero input at the provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L96**\n\n\n\n```\nrequire(ife.isInputPiggybacked(args.inFlightTxInputIndex), \"The indexed input has not been piggybacked\");\n\n```\n* Check that each transaction is nonzero and is correctly formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L98-L101**\n\n\n\n```\nrequire(\n    keccak256(args.inFlightTx) != keccak256(args.challengingTx),\n    \"The challenging transaction is the same as the in-flight transaction\"\n);\n\n```\n* Check that resulting `outputId` is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L123**\n\n\n\n```\nbytes32 ifeInputOutputId = data.ife.inputs[data.args.inFlightTxInputIndex].outputId;\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L125**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(data.args.inputUtxoPos);\n\n```\n* See [issue 5.9](#recommendation-remove-isdeposit-and-add-a-similar-getter-to-blockcontroller)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L126**\n\n\n\n```\nbytes32 challengingTxInputOutputId = data.controller.isDeposit.test(utxoPos.blockNum())\n\n```\n* Check that `inputTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L127-L128**\n\n\n\n```\n? OutputId.computeDepositOutputId(data.args.inputTx, utxoPos.outputIndex(), utxoPos.value)\n: OutputId.computeNormalOutputId(data.args.inputTx, utxoPos.outputIndex());\n\n```\n* Check that output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L149**\n\n\n\n```\nWireTransaction.Output memory output = WireTransaction.getOutput(data.args.challengingTx, data.args.challengingTxInputIndex);\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L156**\n\n\n\n```\nUtxoPosLib.UtxoPos memory inputUtxoPos = UtxoPosLib.UtxoPos(data.args.inputUtxoPos);\n\n```\n* Check that `challengingTx` has a nonzero input at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol:L163**\n\n\n\n```\ndata.args.challengingTxInputIndex,\n\n```\n##### 2. `PaymentChallengeIFENotCanonical`:\n\n\n* Check that each transaction is nonzero and is correctly formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L98-L101**\n\n\n\n```\nrequire(\n    keccak256(args.inFlightTx) != keccak256(args.competingTx),\n    \"The competitor transaction is the same as transaction in-flight\"\n);\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L104**\n\n\n\n```\nUtxoPosLib.UtxoPos memory inputUtxoPos = UtxoPosLib.UtxoPos(args.inputUtxoPos);\n\n```\n* See [issue 5.9](#recommendation-remove-isdeposit-and-add-a-similar-getter-to-blockcontroller)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L107**\n\n\n\n```\nif (self.isDeposit.test(inputUtxoPos.blockNum())) {\n\n```\n* Check that `inputTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L108-L110**\n\n\n\n```\n    outputId = OutputId.computeDepositOutputId(args.inputTx, inputUtxoPos.outputIndex(), inputUtxoPos.value);\n} else {\n    outputId = OutputId.computeNormalOutputId(args.inputTx, inputUtxoPos.outputIndex());\n\n```\n* Check that `inFlightTx` has a nonzero input at the provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L112-L113**\n\n\n\n```\nrequire(outputId == ife.inputs[args.inFlightTxInputIndex].outputId,\n        \"Provided inputs data does not point to the same outputId from the in-flight exit\");\n\n```\n* Check that output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L115**\n\n\n\n```\nWireTransaction.Output memory output = WireTransaction.getOutput(args.inputTx, args.inFlightTxInputIndex);\n\n```\n* Check that `competingTx` has a nonzero input at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L126**\n\n\n\n```\nargs.competingTxInputIndex,\n\n```\n* Check that resulting position is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L133**\n\n\n\n```\nuint256 competitorPosition = verifyCompetingTxFinalized(self, args, output);\n\n```\n* Check that `inFlightTxPos` is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L171-L173**\n\n\n\n```\nrequire(\n    ife.oldestCompetitorPosition > inFlightTxPos,\n    \"In-flight transaction must be younger than competitors to respond to non-canonical challenge\");\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L175**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(inFlightTxPos);\n\n```\n* Check that block root is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L176**\n\n\n\n```\n(bytes32 root, ) = self.framework.blocks(utxoPos.blockNum());\n\n```\n* Check that `inFlightTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L178**\n\n\n\n```\ninFlightTx, utxoPos, root, inFlightTxInclusionProof\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L218**\n\n\n\n```\nUtxoPosLib.UtxoPos memory competingTxUtxoPos = UtxoPosLib.UtxoPos(args.competingTxPos);\n\n```\n##### 3. `PaymentChallengeIFEOutputSpent`:\n\n\n* Check that `inFlightTx` is nonzero and is well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L54**\n\n\n\n```\nuint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L58**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(args.outputUtxoPos);\n\n```\n* Check that `inFlightTx` has a nonzero output at the provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L60-L63**\n\n\n\n```\nrequire(\n    ife.isOutputPiggybacked(outputIndex),\n    \"Output is not piggybacked\"\n);\n\n```\n* Check that bond size is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L70**\n\n\n\n```\nuint256 piggybackBondSize = ife.outputs[outputIndex].piggybackBondSize;\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L83**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(args.outputUtxoPos);\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L101**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(args.outputUtxoPos);\n\n```\n* Check that `challengingTx` is nonzero and is well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L102**\n\n\n\n```\nuint256 challengingTxType = WireTransaction.getTransactionType(args.challengingTx);\n\n```\n* Check that output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L103**\n\n\n\n```\nWireTransaction.Output memory output = WireTransaction.getOutput(args.challengingTx, utxoPos.outputIndex());\n\n```\n* Check that `challengingTx` has a nonzero input at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L116**\n\n\n\n```\nargs.challengingTxInputIndex,\n\n```\n##### 4. `PaymentChallengeStandardExit`:\n\n\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L110**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(data.exitData.utxoPos);\n\n```\n* Check that `exitingTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L112**\n\n\n\n```\n.decode(data.args.exitingTx)\n\n```\n* Check that output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L111-L113**\n\n\n\n```\nPaymentOutputModel.Output memory output = PaymentTransactionModel\n    .decode(data.args.exitingTx)\n    .outputs[utxoPos.outputIndex()];\n\n```\n* Check that `challengeTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L128**\n\n\n\n```\nuint256 challengeTxType = WireTransaction.getTransactionType(data.args.challengeTx);\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L134**\n\n\n\n```\ntxPos: TxPosLib.TxPos(data.args.challengeTxPos),\n\n```\n* See [issue 5.9](#recommendation-remove-isdeposit-and-add-a-similar-getter-to-blockcontroller)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L157**\n\n\n\n```\nbytes32 outputId = data.controller.isDeposit.test(utxoPos.blockNum())\n\n```\n* Check that `challengeTx` has a nonzero input at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol:L166**\n\n\n\n```\nargs.inputIndex,\n\n```\n##### 5. `PaymentPiggybackInFlightExit`:\n\n\n* Check that `inFlightTx` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L93**\n\n\n\n```\nuint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n\n```\n* Check that `inFlightTx` has a nonzero input at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L99**\n\n\n\n```\nrequire(!exit.isInputPiggybacked(args.inputIndex), \"Indexed input already piggybacked\");\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L108**\n\n\n\n```\nenqueue(self, withdrawData.token, UtxoPosLib.UtxoPos(exit.position), exitId);\n\n```\n* Check that `inFlightTx` is nonzero and is well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L130**\n\n\n\n```\nuint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n\n```\n* Check that `inFlightTx` has a nonzero output at provided index:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L136**\n\n\n\n```\nrequire(!exit.isOutputPiggybacked(args.outputIndex), \"Indexed output already piggybacked\");\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol:L147**\n\n\n\n```\nenqueue(self, withdrawData.token, UtxoPosLib.UtxoPos(exit.position), exitId);\n\n```\n##### 6. `PaymentStartInFlightExit`:\n\n\n* Check that `inFlightTx` is nonzero and is well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L146**\n\n\n\n```\nexitData.exitId = ExitId.getInFlightExitId(args.inFlightTx);\n\n```\n* Check that the length of `inputTxs` is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L150**\n\n\n\n```\nexitData.inputTxs = args.inputTxs;\n\n```\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L167**\n\n\n\n```\nutxosPos[i] = UtxoPosLib.UtxoPos(inputUtxosPos[i]);\n\n```\n* See [issue 5.9](#recommendation-remove-isdeposit-and-add-a-similar-getter-to-blockcontroller)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L180**\n\n\n\n```\nbool isDepositTx = controller.isDeposit.test(utxoPos[i].blockNum());\n\n```\n* Check that each `inputTxs` is nonzero and well-formed:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L181-L183**\n\n\n\n```\noutputIds[i] = isDepositTx\n    ? OutputId.computeDepositOutputId(inputTxs[i], utxoPos[i].outputIndex(), utxoPos[i].value)\n    : OutputId.computeNormalOutputId(inputTxs[i], utxoPos[i].outputIndex());\n\n```\n* Check that each output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L200**\n\n\n\n```\nWireTransaction.Output memory output = WireTransaction.getOutput(inputTxs[i], outputIndex);\n\n```\n* Check that `inFlightTx` has nonzero inputs for all `i`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L327-L328**\n\n\n\n```\nexitData.inFlightTxRaw,\ni,\n\n```\n* Check that each output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L407**\n\n\n\n```\nPaymentOutputModel.Output memory output = exitData.inFlightTx.outputs[i];\n\n```\n##### 7. `PaymentStartStandardExit`:\n\n\n* See [issue 5.10](#recommendation-merge-txposlib-into-utxoposlib-and-implement-a-decode-function-with-range-checks)\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartStandardExit.sol:L119**\n\n\n\n```\nUtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.UtxoPos(args.utxoPos);\n\n```\n* Check that output is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartStandardExit.sol:L121**\n\n\n\n```\nPaymentOutputModel.Output memory output = outputTx.outputs[utxoPos.outputIndex()];\n\n```\n* Check that timestamp is nonzero:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartStandardExit.sol:L124**\n\n\n\n```\n(, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum());\n\n```\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/463>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13860",
      "title": "Recommendation: Merge TxPosLib into UtxoPosLib and implement a decode function with range checks.",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was partially addressed in [omisego/plasma-contracts#515](https://github.com/omisego/plasma-contracts/pull/515) with the merging of `TxPosLib` and `UtxoPosLib` into `PosLib`. A subsequent change in [omisego/plasma-contracts#533](https://github.com/omisego/plasma-contracts/pull/533) implemented stricter range checks for block number and transaction index. Note that the maximum output index in `PosLib` is still 9999, well above the currently-supported maximum of “3”. Additionally, `PosLib.encode` lacks an explicit range check on `txIndex` and `PosLib.decode` lacks an explicit range check on `outputIndex`.\n\n\n#### Description\n\n\n`TxPosLib` and `UtxoPosLib` serve very similar functions. They both provide utility functions to access the block number and tx index of a packed utxo position variable. `UtxoPosLib`, additionally, provides a function to retrieve the output index of a packed utxo position variable.\n\n\nWhat they both lack, though, is sanity checks on the values packed inside a utxo position variable. By implementing a function `UtxoPosLib.decode(uint _utxoPos) returns (UtxoPos)`, each exit controller contract can ensure that the values it is using make logical sense. The `decode` function should check that:\n\n\n* `txIndex` is between 0 and `2**16`\n* `outputIndex` is between 0 and 3\n\n\nCurrently, neither of these restrictions is explicitly enforced. As for `blockNum`, the best check is that it exists in the `PlasmaFramework` contract with a nonzero root. Since `UtxoPosLib` is a pure library, that check is better performed elsewhere (See <https://github.com/ConsenSys/omisego-morevp-audit-2019-10/issues/21)>.\n\n\nOnce implemented, all contracts should avoid casting values directly to the `UtxoPos` struct, in favor of using the `decode` function. Merging the two files will help with this.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/465>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13859",
      "title": "Recommendation: remove IsDeposit and add a similar getter to BlockController ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit 0fee13f7f084983139eb47636ff785ebea8a1c36](https://github.com/omisego/plasma-contracts/pull/516/commits/0fee13f7f084983139eb47636ff785ebea8a1c36) by removing the `IsDeposit` contract and replicating its functionality in `BlockController.sol`.\n\n\n#### Description\n\n\nThe `IsDeposit` library is used to check whether a block number is a deposit or not. The logic is simple - if `blockNum % childBlockInterval` is nonzero, the block number is a deposit.\n\n\nBy including this check in `BlockController` instead, the contract can perform an existence check as well. The function in `BlockController` would return the same result as the `IsDeposit` library, but would additionally revert if the block in question does not exist:\n\n\n\n```\nfunction isDeposit(uint _blockNum) public view returns (bool) {\r\n  require(blocks[_blockNum].timestamp != 0, \"Block does not exist\");\r\n  return _blockNum % childBlockInterval != 0;\r\n}\r\n\n```\nNote that this check is made at the cost of an external call. If the check needs to be made multiple times in a transaction, the result should be cached.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/466>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13858",
      "title": "Recommendation: Add a tree height limit check to Merkle.sol",
      "impact": "LOW",
      "content": "#### Description\n\n\nEach plasma block has a maximum of `2 ** 16` transactions, which corresponds to a maximum Merkle tree height of 16. The `Merkle` library currently checks that the proof is comprised of 32-byte segments, but neglects to check the maximum height:\n\n\n**code/plasma\\_framework/contracts/src/utils/Merkle.sol:L17-L23**\n\n\n\n```\nfunction checkMembership(bytes32 leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n    internal\n    pure\n    returns (bool)\n{\n    require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n\n```\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/467>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13857",
      "title": "EthVault - Unused state variable ✓ Addressed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit ea36f5ff46ab72ec5c281fa0a3dffe3bcc83178b](https://github.com/omisego/plasma-contracts/commit/ea36f5ff46ab72ec5c281fa0a3dffe3bcc83178b).\n\n\n#### Description\n\n\nThe state variable `withdrawEntryCounter` is not used in the code.\n\n\n**code/plasma\\_framework/contracts/src/vaults/EthVault.sol:L8**\n\n\n\n```\nuint256 private withdrawEntryCounter = 0;\n\n```\n#### Recommendation\n\n\nRemove it from the contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13856",
      "title": "Maintainer can bypass exit game quarantine by registering not-yet-deployed contracts ✓ Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis was addressed in [commit 7669076be1dff47473ee877dcebef5989d7617ac](https://github.com/omisego/plasma-contracts/pull/469/commits/7669076be1dff47473ee877dcebef5989d7617ac) by adding a check that registered contracts had nonzero `extcodesize`.\n\n\n#### Description\n\n\nThe plasma framework uses an `ExitGameRegistry` to allow the maintainer to add new exit games after deployment. An exit game is any arbitrary contract. In order to prevent the maintainer from adding malicious exit games that steal user funds, the framework uses a “quarantine” system whereby newly-registered exit games have restricted permissions until their quarantine period has expired. The quarantine period is by default `3 * minExitPeriod`, and is intended to facilitate auditing of the new exit game’s functionality by the plasma users.\n\n\nHowever, by registering an exit game at a contract which has not yet been deployed, the maintainer can prevent plasma users from auditing the game until the quarantine period has expired. After the quarantine period has expired, the maintainer can deploy the malicious exit game and immediately steal funds.\n\n\n#### Explanation\n\n\nExit games are registered in the following function, callable only by the plasma contract maintainer:\n\n\n**code/plasma\\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**\n\n\n\n```\n/\\*\\*\n \\* @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n \\* @dev Emits ExitGameRegistered event to notify clients\n \\* @param \\_txType The tx type where the exit game wants to register\n \\* @param \\_contract Address of the exit game contract\n \\* @param \\_protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n \\*/\nfunction registerExitGame(uint256 \\_txType, address \\_contract, uint8 \\_protocol) public onlyFrom(getMaintainer()) {\n    require(\\_txType != 0, \"Should not register with tx type 0\");\n    require(\\_contract != address(0), \"Should not register with an empty exit game address\");\n    require(\\_exitGames[\\_txType] == address(0), \"The tx type is already registered\");\n    require(\\_exitGameToTxType[\\_contract] == 0, \"The exit game contract is already registered\");\n    require(Protocol.isValidProtocol(\\_protocol), \"Invalid protocol value\");\n\n    \\_exitGames[\\_txType] = \\_contract;\n    \\_exitGameToTxType[\\_contract] = \\_txType;\n    \\_protocols[\\_txType] = \\_protocol;\n    \\_exitGameQuarantine.quarantine(\\_contract);\n\n    emit ExitGameRegistered(\\_txType, \\_contract, \\_protocol);\n}\n\n```\nNotably, the function does not check the `extcodesize` of the submitted contract. As such, the maintainer can submit the address of a contract which does not yet exist and is not auditable.\n\n\nAfter at least `3 * minExitPeriod` seconds pass, the submitted contract now has full permissions as a registered exit game and can pass all checks using the `onlyFromNonQuarantinedExitGame` modifier:\n\n\n**code/plasma\\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L33-L40**\n\n\n\n```\n/\\*\\*\n \\* @notice A modifier to verify that the call is from a non-quarantined exit game\n \\*/\nmodifier onlyFromNonQuarantinedExitGame() {\n    require(\\_exitGameToTxType[msg.sender] != 0, \"The call is not from a registered exit game contract\");\n    require(!\\_exitGameQuarantine.isQuarantined(msg.sender), \"ExitGame is quarantined\");\n    \\_;\n}\n\n```\nAdditionally, the submitted contract passes checks made by external contracts using the `isExitGameSafeToUse` function:\n\n\n**code/plasma\\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L48-L56**\n\n\n\n```\n/\\*\\*\n \\* @notice Checks whether the contract is safe to use and is not under quarantine\n \\* @dev Exposes information about exit games quarantine\n \\* @param \\_contract Address of the exit game contract\n \\* @return boolean Whether the contract is safe to use and is not under quarantine\n \\*/\nfunction isExitGameSafeToUse(address \\_contract) public view returns (bool) {\n    return \\_exitGameToTxType[\\_contract] != 0 && !\\_exitGameQuarantine.isQuarantined(\\_contract);\n}\n\n```\nThese permissions allow a registered quarantine to:\n\n\n1. Withdraw any users' tokens from `ERC20Vault`:\n\n\n**code/plasma\\_framework/contracts/src/vaults/Erc20Vault.sol:L52-L55**\n\n\n\n```\nfunction withdraw(address payable receiver, address token, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    IERC20(token).safeTransfer(receiver, amount);\n    emit Erc20Withdrawn(receiver, token, amount);\n}\n\n```\n2. Withdraw any users' ETH from `EthVault`:\n\n\n**code/plasma\\_framework/contracts/src/vaults/EthVault.sol:L46-L54**\n\n\n\n```\nfunction withdraw(address payable receiver, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    // we do not want to block exit queue if transfer is unucessful\n    // solhint-disable-next-line avoid-call-value\n    (bool success, ) = receiver.call.value(amount)(\"\");\n    if (success) {\n        emit EthWithdrawn(receiver, amount);\n    } else {\n        emit WithdrawFailed(receiver, amount);\n    }\n\n```\n3. Activate and deactivate the `ExitGameController` reentrancy mutex:\n\n\n**code/plasma\\_framework/contracts/src/framework/ExitGameController.sol:L63-L66**\n\n\n\n```\nfunction activateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n    require(!mutex, \"Reentrant call\");\n    mutex = true;\n}\n\n```\n**code/plasma\\_framework/contracts/src/framework/ExitGameController.sol:L72-L75**\n\n\n\n```\nfunction deactivateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n    require(mutex, \"Not locked\");\n    mutex = false;\n}\n\n```\n4. `enqueue` arbitrary exits:\n\n\n**code/plasma\\_framework/contracts/src/framework/ExitGameController.sol:L115-L138**\n\n\n\n```\nfunction enqueue(\n    uint256 vaultId,\n    address token,\n    uint64 exitableAt,\n    TxPosLib.TxPos calldata txPos,\n    uint160 exitId,\n    IExitProcessor exitProcessor\n)\n    external\n    onlyFromNonQuarantinedExitGame\n    returns (uint256)\n{\n    bytes32 key = exitQueueKey(vaultId, token);\n    require(hasExitQueue(key), \"The queue for the (vaultId, token) pair is not yet added to the Plasma framework\");\n    PriorityQueue queue = exitsQueues[key];\n\n    uint256 priority = ExitPriority.computePriority(exitableAt, txPos, exitId);\n\n    queue.insert(priority);\n    delegations[priority] = exitProcessor;\n\n    emit ExitQueued(exitId, priority);\n    return priority;\n}\n\n```\n5. Flag outputs as “spent”:\n\n\n**code/plasma\\_framework/contracts/src/framework/ExitGameController.sol:L210-L213**\n\n\n\n```\nfunction flagOutputSpent(bytes32 \\_outputId) external onlyFromNonQuarantinedExitGame {\n    require(\\_outputId != bytes32(\"\"), \"Should not flag with empty outputId\");\n    isOutputSpent[\\_outputId] = true;\n}\n\n```\n#### Recommendation\n\n\n`registerExitGame` should check that `extcodesize` of the submitted contract is non-zero.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/410>",
      "summary": "\nThis bug report is about a vulnerability in the plasma framework, which uses an `ExitGameRegistry` to allow the maintainer to add new exit games after deployment. The plasma framework uses a “quarantine” system whereby newly-registered exit games have restricted permissions until their quarantine period has expired. This quarantine period is by default `3 * minExitPeriod`, and is intended to facilitate auditing of the new exit game’s functionality by the plasma users. \n\nHowever, by registering an exit game at a contract which has not yet been deployed, the maintainer can prevent plasma users from auditing the game until the quarantine period has expired. After the quarantine period has expired, the maintainer can deploy the malicious exit game and immediately steal funds. \n\nThe vulnerability is that the `registerExitGame` function, which is callable only by the plasma contract maintainer, does not check the `extcodesize` of the submitted contract. As such, the maintainer can submit the address of a contract which does not yet exist and is not auditable. After at least `3 * minExitPeriod` seconds pass, the submitted contract now has full permissions as a registered exit game and can pass all checks using the `onlyFromNonQuarantinedExitGame` modifier. This allows the malicious exit game to withdraw any users' tokens from `ERC20Vault`, withdraw any users' ETH from `EthVault`, activate and deactivate the `ExitGameController` reentrancy mutex, `enqueue` arbitrary exits, and flag outputs as “spent”. \n\nThe resolution to this vulnerability is that `registerExitGame` should check that `extcodesize` of the submitted contract is non-zero. This was addressed in [commit 7669076be1dff47473ee877dcebef5989d7617ac](https://github.com/omisego/plasma-contracts/pull/469/commits/7669076be1dff47473ee877dcebef5989d7617ac) by adding a check that registered contracts had nonzero `extcodesize`. The corresponding issue in plasma-contracts repo can be found at <https://github.com/omisego/plasma-contracts/issues/410>.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13855",
      "title": "Merkle - The implementation does not enforce inclusion of leaf nodes. ✓ Addressed",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis was addressed in [omisego/plasma-contracts#452](https://github.com/omisego/plasma-contracts/pull/452) with the addition of leaf and node salts to the `checkMembership` function.\n\n\n#### Description\n\n\nA observation with the current Merkle tree implementation is that it may be possible to validate nodes other than leaves. This is done by providing `checkMembership` with a reference to a hash within the tree, rather than a leaf.\n\n\n**code/plasma\\_framework/contracts/src/utils/Merkle.sol:L9-L42**\n\n\n\n```\n/\\*\\*\n \\* @notice Checks that a leaf hash is contained in a root hash\n \\* @param leaf Leaf hash to verify\n \\* @param index Position of the leaf hash in the Merkle tree\n \\* @param rootHash Root of the Merkle tree\n \\* @param proof A Merkle proof demonstrating membership of the leaf hash\n \\* @return True, if the leaf hash is in the Merkle tree; otherwise, False\n\\*/\nfunction checkMembership(bytes32 leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n    internal\n    pure\n    returns (bool)\n{\n    require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n    bytes32 proofElement;\n    bytes32 computedHash = leaf;\n    uint256 j = index;\n    // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n    for (uint256 i = 32; i <= proof.length; i += 32) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proofElement := mload(add(proof, i))\n        }\n        if (j % 2 == 0) {\n            computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n        } else {\n            computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n        }\n        j = j / 2;\n    }\n\n    return computedHash == rootHash;\n}\n\n```\nThe current implementation will validate the provided “leaf” and return `true`. This is a known problem of Merkle trees <https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack>.\n\n\n#### Examples\n\n\nProvide a hash from within the Merkle tree as the `leaf` argument. The index has to match the index of that node in regards to its current level in the tree.\nThe `rootHash` has to be the correct Merkle tree `rootHash`.\nThe proof has to skip the necessary number of levels because the nodes “underneath” the provided “leaf” will not be processed.\n\n\n#### Recommendation\n\n\nA remediation needs a fixed Merkle tree size as well as the addition of a byte prepended to each node in the tree. Another way would be to create a structure for the Merkle node and mark it as `leaf` or `no leaf`.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/425>",
      "summary": "\nA bug was identified in the Merkle tree implementation of the plasma-contracts repo. It was possible to validate nodes other than leaves by providing the `checkMembership` function with a reference to a hash within the tree, instead of a leaf. This is a known problem of Merkle trees called the Second Preimage Attack. The bug was addressed by adding leaf and node salts to the `checkMembership` function. This was done by adding a fixed Merkle tree size and a byte prepended to each node in the tree. Alternatively, a structure was created for the Merkle node and marked as `leaf` or `no leaf`. The bug was addressed in the plasma-contracts repo at pull #452.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13854",
      "title": "Recommendation: Remove TxFinalizationModel and TxFinalizationVerifier. Implement stronger checks in Merkle",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nThis was partially addressed in <https://github.com/omisego/plasma-contracts/pull/503,> with the removal of several unneeded branches of logic in `TxFinalizationModel` (now renamed to `MoreVpFinalization`). A subsequent change in [omisego/plasma-contracts#533](https://github.com/omisego/plasma-contracts/pull/533) added a non-zero proof length check in `Merkle`. Note that `PaymentChallengeIFENotCanonical.respond` still calls `Merkle.checkMembership` directly, and lacks the typical transaction type protocol check made in `MoreVpFinalization.isStandardFinalized`.\n\n\n#### Description\n\n\n`TxFinalizationVerifier` is an abstraction around the block inclusion check needed for many of the features of plasma exit games. It uses a struct defined in `TxFinalizationModel` as inputs to its two functions: `isStandardFinalized` and `isProtocolFinalized`.\n\n\n`isStandardFinalized` returns the result of an inclusion proof. Although there are several branches, only the first is used:\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/TxFinalizationVerifier.sol:L19-L32**\n\n\n\n```\n/\\*\\*\n\\* @notice Checks whether a transaction is \"standard finalized\"\n\\* @dev MVP: requires that both inclusion proof and confirm signature is checked\n\\* @dev MoreVp: checks inclusion proof only\n\\*/\nfunction isStandardFinalized(Model.Data memory data) public view returns (bool) {\n    if (data.protocol == Protocol.MORE\\_VP()) {\n        return checkInclusionProof(data);\n    } else if (data.protocol == Protocol.MVP()) {\n        revert(\"MVP is not yet supported\");\n    } else {\n        revert(\"Invalid protocol value\");\n    }\n}\n\n```\n`isProtocolFinalized` is unused:\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/TxFinalizationVerifier.sol:L34-L47**\n\n\n\n```\n/\\*\\*\n\\* @notice Checks whether a transaction is \"protocol finalized\"\n\\* @dev MVP: must be standard finalized\n\\* @dev MoreVp: allows in-flight tx, so only checks for the existence of the transaction\n\\*/\nfunction isProtocolFinalized(Model.Data memory data) public view returns (bool) {\n    if (data.protocol == Protocol.MORE\\_VP()) {\n        return data.txBytes.length > 0;\n    } else if (data.protocol == Protocol.MVP()) {\n        revert(\"MVP is not yet supported\");\n    } else {\n        revert(\"Invalid protocol value\");\n    }\n}\n\n```\nThe abstraction used introduces branching logic and requires several files to be visited to fully understand the function of each line of code: `ITxFinalizationVerifier`, `TxFinalizationModel`, `TxPosLib`, `Protocol`, `BlockController`, and `Merkle`. Additionally, the abstraction obfuscates the underlying inclusion proof primitive when used in the exit game contracts. `isStandardFinalized` is not clearly an inclusion proof, and `isProtocolFinalized` simply adds confusion.\n\n\nFinally, the abstraction may have ramifications on the safety of `Merkle.sol`. As it stands now, `Merkle.checkMembership` should never be called directly by the exit game controllers, as it lacks an important check made in `TxFinalizationVerifier.checkInclusionProof`:\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/TxFinalizationVerifier.sol:L49-L59**\n\n\n\n```\nfunction checkInclusionProof(Model.Data memory data) private view returns (bool) {\n    if (data.inclusionProof.length == 0) {\n        return false;\n    }\n\n    (bytes32 root,) = data.framework.blocks(data.txPos.blockNum());\n    bytes32 leafData = keccak256(data.txBytes);\n    return Merkle.checkMembership(\n        leafData, data.txPos.txIndex(), root, data.inclusionProof\n    );\n}\n\n```\nBy introducing the abstraction of `TxFinalizationVerifier`, the input validation performed by `Merkle` is split across multiple files, and the reasonable-seeming decision of calling `Merkle.checkMembership` directly becomes unsafe. In fact, this occurs in one location in the contracts:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L187-L204**\n\n\n\n```\nfunction verifyAndDeterminePositionOfTransactionIncludedInBlock(\n    bytes memory txbytes,\n    UtxoPosLib.UtxoPos memory utxoPos,\n    bytes32 root,\n    bytes memory inclusionProof\n)\n    private\n    pure\n    returns(uint256)\n{\n    bytes32 leaf = keccak256(txbytes);\n    require(\n        Merkle.checkMembership(leaf, utxoPos.txIndex(), root, inclusionProof),\n        \"Transaction is not included in block of Plasma chain\"\n    );\n\n    return utxoPos.value;\n}\n\n```\n#### Recommendation\n\n\n1. Remove `TxFinalizationVerifier` and `TxFinalizationModel`\n2. Implement a proof length check in `Merkle.sol`\n3. Call `Merkle.checkMembership` directly from exit controller contracts:\n\n\n* `PaymentChallengeIFEOutputSpent.verifyInFlightTransactionStandardFinalized`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol:L91**\n\n\n\n```\nrequire(controller.txFinalizationVerifier.isStandardFinalized(finalizationData), \"In-flight transaction not finalized\");\n\n```\n* `PaymentChallengeIFENotCanonical.verifyCompetingTxFinalized`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol:L244**\n\n\n\n```\nrequire(self.txFinalizationVerifier.isStandardFinalized(finalizationData), \"Failed to verify the position of competing tx\");\n\n```\n* `PaymentStartInFlightExit.verifyInputTransactionIsStandardFinalized`:\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol:L307-L308**\n\n\n\n```\nrequire(exitData.controller.txFinalizationVerifier.isStandardFinalized(finalizationData),\n        \"Input transaction is not standard finalized\");\n\n```\n4. If none of the above recommendations are implemented, ensure that `PaymentChallengeIFENotCanonical` uses the abstraction `TxFinalizationVerifier` so that a length check is performed on the inclusion proof.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/471>",
      "summary": "\nA bug was discovered in the `TxFinalizationVerifier` abstraction in the OmiseGo Plasma Framework contracts. This abstraction was used to verify the block inclusion check needed for many of the features of plasma exit games. The abstraction introduced branching logic and required several files to be visited to fully understand its function. Additionally, the abstraction obfuscated the underlying inclusion proof primitive when used in the exit game contracts. The `isStandardFinalized` function did not clearly perform an inclusion proof, and `isProtocolFinalized` simply added confusion. \n\nThe abstraction may have also had ramifications on the safety of the `Merkle.sol` file. As it stands, `Merkle.checkMembership` should never be called directly by the exit game controllers, as it lacked an important check made in `TxFinalizationVerifier.checkInclusionProof`. This occurs in one location in the contracts, `PaymentChallengeIFENotCanonical.respond`.\n\nTo address this bug, several changes were made. The first was the removal of several unneeded branches of logic in `TxFinalizationModel` (now renamed to `MoreVpFinalization`) in <https://github.com/omisego/plasma-contracts/pull/503>. A subsequent change in [omisego/plasma-contracts#533](https://github.com/omisego/plasma-contracts/pull/533) added a non-zero proof length check in `Merkle`.\n\nFour recommendations were made to address the bug: 1) Remove `TxFinalizationVerifier` and `TxFinalizationModel`; 2) Implement a proof length check in `Merkle.sol`; 3) Call `Merkle.checkMembership` directly from exit controller contracts; and 4) If none of the above recommendations are implemented, ensure that `PaymentChallengeIFENotCanonical` uses the abstraction `TxFinalizationVerifier` so that a length check is performed on the inclusion proof. The corresponding issue in the plasma-contracts repo is <https://github.com/omisego/plasma-contracts/issues/471>.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13853",
      "title": "RLPReader - Leading zeroes allow multiple valid encodings and exit / output ids for the same transaction ✓ Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis was addressed in [omisego/plasma-contracts#507](https://github.com/omisego/plasma-contracts/pull/507) with the addition of checks to ensure primitive decoding functions in `RLPReader` (`toAddress`, `toUint`, `toBytes32`) do not decode lists. A subsequent change in [omisego/plasma-contracts#476](https://github.com/omisego/plasma-contracts/pull/476) rejects leading zeroes in `toUint`, and improves on size requirements for decoded payloads. Note that the scalar “0” should be encoded as `0x80`.\n\n\n#### Description\n\n\nThe current implementation of RLP decoding can take 2 different `txBytes` and decode them to the same structure. Specifically, the `RLPReader.toUint` method can decode 2 different types of bytes to the same number. For example:\n\n\n* `0x821234` is decoded to `uint(0x1234)`\n* `0x83001234` is decoded to `uint(0x1234)`\n* `0xc101` can decode to `uint(1)`, even though the tag specifies a short list\n* `0x01` can decode to `uint(1)`, even though the tag specifies a single byte\n\n\nAs explanation for this encoding:\n\n\n`0x821234` is broken down into 2 parts:\n\n\n* `0x82` - represents `0x80` (the string tag) + `0x02` bytes encoded\n* `0x1234` - are the encoded bytes\n\n\nThe same for `0x83001234`:\n\n\n* `0x83` - represents `0x80` (the string tag) + `0x03` bytes encoded\n* `0x001234` - are the encoded bytes\n\n\nThe current implementation casts the encoded bytes into a uint256, so these different encodings are interpreted by the contracts as the same number:\n\n\n`uint(0x1234) = uint(0x001234)`\n\n\n**code/plasma\\_framework/contracts/src/utils/RLPReader.sol:L112**\n\n\n\n```\nresult := mload(memPtr)\n\n```\nHaving different valid encodings for the same data is a problem because the encodings are used to create hashes that are used as unique ids. This means that multiple ids can be created for the same data. The data should only have one possible id.\n\n\nThe encoding is used to create ids in these parts of the code:\n\n\n* Outputid.sol\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/OutputId.sol:L18**\n\n\n\n```\nreturn keccak256(abi.encodePacked(\\_txBytes, \\_outputIndex, \\_utxoPosValue));\n\n```\n**code/plasma\\_framework/contracts/src/exits/utils/OutputId.sol:L32**\n\n\n\n```\nreturn keccak256(abi.encodePacked(\\_txBytes, \\_outputIndex));\n\n```\n* ExitId.sol\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/ExitId.sol:L41**\n\n\n\n```\nbytes32 hashData = keccak256(abi.encodePacked(\\_txBytes, \\_utxoPos.value));\n\n```\n**code/plasma\\_framework/contracts/src/exits/utils/ExitId.sol:L54**\n\n\n\n```\nreturn uint160((uint256(keccak256(\\_txBytes)) >> 105).setBit(151));\n\n```\n* TxFinalizationVerifier.sol\n\n\n**code/plasma\\_framework/contracts/src/exits/utils/TxFinalizationVerifier.sol:L55**\n\n\n\n```\nbytes32 leafData = keccak256(data.txBytes);\n\n```\nOther methods that are affected because they rely on the return values of these methods:\n\n\n* `ExitId.sol`\n\t+ getStandardExitId\n\t+ getInFlightExitId\n* `OutputId.sol`\n\t+ computeDepositOutputId\n\t+ computeNormalOutputId\n* `PaymentChallengeIFENotCanonical.sol`\n\t+ verifyAndDeterminePositionOfTransactionIncludedInBlock\n\t+ verifyCompetingTxFinalized\n* `PaymentChallengeStandardExit.sol`\n\t+ verifyChallengeTxProtocolFinalized\n* `PaymentStartInFlightExit.sol`\n\t+ verifyInputTransactionIsStandardFinalized\n* `PaymentExitGame.sol`\n\t+ getStandardExitId\n\t+ getInFlightExitId\n* `PaymentOutputToPaymentTxCondition.sol`\n\t+ verify\n\n\n#### Recommendation\n\n\nEnforce strict-length decoding for `txBytes`, and specify that `uint` is decoded from a 32-byte short string.\n\n\nEnforcing a 32-byte length for `uint` means that `0x1234` should always be encoded as:\n\n\n`0xa00000000000000000000000000000000000000000000000000000000000001234`\n\n\n* `0xa0` represents the tag + the length: `0x80 + 32`\n* `0000000000000000000000000000000000000000000000000000000000001234` is the number 32 bytes long with leading zeroes\n\n\nUnfortunately, using leading zeroes is against the RLP spec:\n\n\n<https://github.com/ethereum/wiki/wiki/RLP>\n\n\n\n> \n> positive RLP integers must be represented in big endian binary form with no leading zeroes\n> \n> \n> \n\n\nThis means that libraries interacting with OMG contracts which are going to correctly and fully implement the spec will generate “incorrect” encodings for uints; encodings that are not going to be recognized by the OMG contracts.\n\n\nFully correct spec encoding: `0x821234`. Proposed encoding in this solution: `0xa00000000000000000000000000000000000000000000000000000000000001234`.\n\n\nSimilarly enforce restrictions where they can be added; this is possible because of the strict structure format that needs to be encoded.\n\n\nSome other potential solutions are included below. Note that these solutions are not recommended for reasons included below:\n\n\n1. Normalize the encoding that gets passed to methods that hash the transaction for use as an id:\n\n\nThis can be implemented in the methods that call `keccak256` on `txBytes` and should decode and re-encode the passed `txBytes` in order to normalize the passed encoding.\n\n\n* a `txBytes` is passed\n* the txBytes are decoded into structure: `tmpDecodedStruct = decode(txBytes)`\n* the `tmpDecodedStruct` is re-encoded in order to normalize it: `normalizedTxBytes = encode(txBytes)`\n\n\nThis method is not recommended because it needs a Solidity encoder to be implemented and a lot of gas will be used to decode and re-encode the initial `txBytes`.\n\n\n2. Correctly and fully implement RLP decoding\n\n\nThis is another solution that adds a lot of code and is prone to errors.\n\n\nThe solution would be to enforce all of the restrictions when decoding and not accept any encoding that doesn’t fully follow the spec. This for example means that is should not accept uints with leading zeroes.\n\n\nThis is a problem because it needs a lot of code that is not easy to write in Solidity (or EVM).",
      "summary": "\nThis bug report is about the current implementation of RLP decoding in the OmiseGo Plasma Contracts which can take two different `txBytes` and decode them to the same structure. This is a problem because the encodings are used to create hashes that are used as unique ids, meaning multiple ids can be created for the same data. The encoding is used to create ids in the OutputId.sol, ExitId.sol and TxFinalizationVerifier.sol contracts.\n\nThe solution proposed in this bug report is to enforce strict-length decoding for `txBytes`, and specify that `uint` is decoded from a 32-byte short string. This means that `0x1234` should always be encoded as `0xa00000000000000000000000000000000000000000000000000000000000001234`. Unfortunately, using leading zeroes is against the RLP spec.\n\nSome other potential solutions are included in the report, but they are not recommended for various reasons. These solutions include normalizing the encoding that gets passed to methods that hash the transaction for use as an id, and correctly and fully implementing RLP decoding. This would add a lot of code and is prone to errors.\n\nThis bug was addressed in [omisego/plasma-contracts#507](https://github.com/omisego/plasma-contracts/pull/507) with the addition of checks to ensure primitive decoding functions in `RLPReader` (`toAddress`, `toUint`, `toBytes32`) do not decode lists. A subsequent change in [omisego/plasma-contracts#476](https://github.com/omisego/plasma-contracts/pull/476) rejected leading zeroes in `toUint`, and improved on size requirements for decoded payloads.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13852",
      "title": "Improper initialization of spending condition abstraction allows “v2 transactions” to exit using PaymentExitGame ✓ Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis was addressed in [omisego/plasma-contracts#478](https://github.com/omisego/plasma-contracts/pull/478) by requiring that `PaymentStartStandardExit` and `PaymentStartInFlightExit` check the exiting transaction’s transaction type.\n\n\n#### Description\n\n\n`PaymentOutputToPaymentTxCondition` is an abstraction around the transaction signature check needed for many components of the exit games. Its only function, `verify`, returns `true` if one transaction (`inputTxBytes`) is spent by another transaction (`spendingTxBytes`):\n\n\n**code/plasma\\_framework/contracts/src/exits/payment/spendingConditions/PaymentOutputToPaymentTxCondition.sol:L40-L69**\n\n\n\n```\nfunction verify(\n    bytes calldata inputTxBytes,\n    uint16 outputIndex,\n    uint256 inputTxPos,\n    bytes calldata spendingTxBytes,\n    uint16 inputIndex,\n    bytes calldata signature,\n    bytes calldata /\\*optionalArgs\\*/\n)\n    external\n    view\n    returns (bool)\n{\n    PaymentTransactionModel.Transaction memory inputTx = PaymentTransactionModel.decode(inputTxBytes);\n    require(inputTx.txType == supportInputTxType, \"Input tx is an unsupported payment tx type\");\n\n    PaymentTransactionModel.Transaction memory spendingTx = PaymentTransactionModel.decode(spendingTxBytes);\n    require(spendingTx.txType == supportSpendingTxType, \"The spending tx is an unsupported payment tx type\");\n\n    UtxoPosLib.UtxoPos memory utxoPos = UtxoPosLib.build(TxPosLib.TxPos(inputTxPos), outputIndex);\n    require(\n        spendingTx.inputs[inputIndex] == bytes32(utxoPos.value),\n        \"Spending tx points to the incorrect output UTXO position\"\n    );\n\n    address payable owner = inputTx.outputs[outputIndex].owner();\n    require(owner == ECDSA.recover(eip712.hashTx(spendingTx), signature), \"Tx in not signed correctly\");\n\n    return true;\n}\n\n```\n##### Verification process\n\n\nThe verification process is relatively straightforward. The contract performs some basic input validation, checking that the input transaction’s `txType` matches `supportInputTxType`, and that the spending transaction’s `txType` matches `supportSpendingTxType`. These values are set during construction.\n\n\nNext, `verify` checks that the spending transaction contains an input that matches the position of one of the input transaction’s outputs.\n\n\nFinally, `verify` performs an EIP-712 hash on the spending transaction, and ensures it is signed by the owner of the output in question.\n\n\n##### Implications of the abstraction\n\n\nThe abstraction used requires several files to be visited to fully understand the function of each line of code: `ISpendingCondition`, `PaymentEIP712Lib`, `UtxoPosLib`, `TxPosLib`, `PaymentTransactionModel`, `PaymentOutputModel`, `RLPReader`, `ECDSA`, and `SpendingConditionRegistry`. Additionally, the abstraction obfuscates the underlying spending condition verification primitive where used.\n\n\nFinally, understanding the abstraction requires an understanding of how `SpendingConditionRegistry` is initialized, as well as the nature of its relationship with `PlasmaFramework` and `ExitGameRegistry`. The aforementioned `txType` values, `supportInputTxType` and `supportSpendingTxType`, are set during construction. Their use in `ExitGameRegistry` seems to suggest they are intended to represent different versions of transaction types, and that separate exit game contracts are meant to handle different transaction types:\n\n\n**code/plasma\\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**\n\n\n\n```\n/\\*\\*\n \\* @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n \\* @dev Emits ExitGameRegistered event to notify clients\n \\* @param \\_txType The tx type where the exit game wants to register\n \\* @param \\_contract Address of the exit game contract\n \\* @param \\_protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n \\*/\nfunction registerExitGame(uint256 \\_txType, address \\_contract, uint8 \\_protocol) public onlyFrom(getMaintainer()) {\n    require(\\_txType != 0, \"Should not register with tx type 0\");\n    require(\\_contract != address(0), \"Should not register with an empty exit game address\");\n    require(\\_exitGames[\\_txType] == address(0), \"The tx type is already registered\");\n    require(\\_exitGameToTxType[\\_contract] == 0, \"The exit game contract is already registered\");\n    require(Protocol.isValidProtocol(\\_protocol), \"Invalid protocol value\");\n\n    \\_exitGames[\\_txType] = \\_contract;\n    \\_exitGameToTxType[\\_contract] = \\_txType;\n    \\_protocols[\\_txType] = \\_protocol;\n    \\_exitGameQuarantine.quarantine(\\_contract);\n\n    emit ExitGameRegistered(\\_txType, \\_contract, \\_protocol);\n}\n\n```\n##### Migration and initialization\n\n\nThe migration script seems to corroborate this interpretation:\n\n\n**code/plasma\\_framework/migrations/5\\_deploy\\_and\\_register\\_payment\\_exit\\_game.js:L109-L124**\n\n\n\n```\n// handle spending condition\nawait deployer.deploy(\n    PaymentOutputToPaymentTxCondition,\n    plasmaFramework.address,\n    PAYMENT\\_OUTPUT\\_TYPE,\n    PAYMENT\\_TX\\_TYPE,\n);\nconst paymentToPaymentCondition = await PaymentOutputToPaymentTxCondition.deployed();\n\nawait deployer.deploy(\n    PaymentOutputToPaymentTxCondition,\n    plasmaFramework.address,\n    PAYMENT\\_OUTPUT\\_TYPE,\n    PAYMENT\\_V2\\_TX\\_TYPE,\n);\nconst paymentToPaymentV2Condition = await PaymentOutputToPaymentTxCondition.deployed();\n\n```\nThe migration script shown above deploys two different versions of `PaymentOutputToPaymentTxCondition`. The first sets `supportInputTxType` and `supportSpendingTxType` to `PAYMENT_OUTPUT_TYPE` and `PAYMENT_TX_TYPE`, respectively. The second sets those same variables to `PAYMENT_OUTPUT_TYPE` and `PAYMENT_V2_TX_TYPE`, respectively.\n\n\nThe migration script then registers both of these contracts in `SpendingConditionRegistry`, and then calls `renounceOwnership`, freezing the spending conditions registered permanently:\n\n\n**code/plasma\\_framework/migrations/5\\_deploy\\_and\\_register\\_payment\\_exit\\_game.js:L126-L135**\n\n\n\n```\nconsole.log(`Registering paymentToPaymentCondition (${paymentToPaymentCondition.address}) to spendingConditionRegistry`);\nawait spendingConditionRegistry.registerSpendingCondition(\n    PAYMENT\\_OUTPUT\\_TYPE, PAYMENT\\_TX\\_TYPE, paymentToPaymentCondition.address,\n);\n\nconsole.log(`Registering paymentToPaymentV2Condition (${paymentToPaymentV2Condition.address}) to spendingConditionRegistry`);\nawait spendingConditionRegistry.registerSpendingCondition(\n    PAYMENT\\_OUTPUT\\_TYPE, PAYMENT\\_V2\\_TX\\_TYPE, paymentToPaymentV2Condition.address,\n);\nawait spendingConditionRegistry.renounceOwnership();\n\n```\nFinally, the migration script registers a single exit game contract in `PlasmaFramework`:\n\n\n**code/plasma\\_framework/migrations/5\\_deploy\\_and\\_register\\_payment\\_exit\\_game.js:L137-L143**\n\n\n\n```\n// register the exit game to framework\nawait plasmaFramework.registerExitGame(\n    PAYMENT\\_TX\\_TYPE,\n    paymentExitGame.address,\n    config.frameworks.protocols.moreVp,\n    { from: maintainerAddress },\n);\n\n```\nNote that the associated `_txType` is permanently associated with the deployed exit game contract:\n\n\n**code/plasma\\_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**\n\n\n\n```\n/\\*\\*\n \\* @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n \\* @dev Emits ExitGameRegistered event to notify clients\n \\* @param \\_txType The tx type where the exit game wants to register\n \\* @param \\_contract Address of the exit game contract\n \\* @param \\_protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n \\*/\nfunction registerExitGame(uint256 \\_txType, address \\_contract, uint8 \\_protocol) public onlyFrom(getMaintainer()) {\n    require(\\_txType != 0, \"Should not register with tx type 0\");\n    require(\\_contract != address(0), \"Should not register with an empty exit game address\");\n    require(\\_exitGames[\\_txType] == address(0), \"The tx type is already registered\");\n    require(\\_exitGameToTxType[\\_contract] == 0, \"The exit game contract is already registered\");\n    require(Protocol.isValidProtocol(\\_protocol), \"Invalid protocol value\");\n\n    \\_exitGames[\\_txType] = \\_contract;\n    \\_exitGameToTxType[\\_contract] = \\_txType;\n    \\_protocols[\\_txType] = \\_protocol;\n    \\_exitGameQuarantine.quarantine(\\_contract);\n\n    emit ExitGameRegistered(\\_txType, \\_contract, \\_protocol);\n}\n\n```\n##### Conclusion\n\n\nCrucially, this association is never used. It is implied heavily that transactions with some `txType` must use a certain registered exit game contract. In fact, this is not true. When using `PaymentExitGame`, its routers, and their associated controllers, the `txType` is invariably inferred from the encoded transaction, not from the mappings in `ExitGameRegistry`. If initialized as-is, both `PAYMENT_TX_TYPE` and `PAYMENT_V2_TX_TYPE` transactions may be exited using `PaymentExitGame`, provided they exist in the plasma chain.\n\n\n#### Recommendation\n\n\n* Remove `PaymentOutputToPaymentTxCondition` and `SpendingConditionRegistry`\n* Implement checks for specific spending conditions directly in exit game controllers. Emphasize clarity of function: ensure it is clear when called from the top level that a signature verification check and spending condition check are being performed.\n* If the inferred relationship between `txType` and `PaymentExitGame` is correct, ensure that each `PaymentExitGame` router checks for its supported `txType`. Alternatively, the check could be made in `PaymentExitGame` itself.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/472>",
      "summary": "\nThis bug report is about the `PaymentOutputToPaymentTxCondition` abstraction which is used in the exit games of the Plasma Framework. This abstraction is used to verify the signature of a transaction that is trying to exit the Plasma chain. The issue with this abstraction is that it requires several files to be visited to fully understand the function of each line of code and it also obfuscates the underlying spending condition verification primitive where used. \n\nThe migration script deploys two different versions of `PaymentOutputToPaymentTxCondition` and registers both of them in `SpendingConditionRegistry`. It then calls `renounceOwnership`, freezing the spending conditions registered permanently. The migration script also registers a single exit game contract in `PlasmaFramework`. \n\nThe main issue is that the association between `txType` and `PaymentExitGame` is never used. In fact, when using `PaymentExitGame`, its routers, and their associated controllers, the `txType` is inferred from the encoded transaction, not from the mappings in `ExitGameRegistry`. \n\nThe recommendation is to remove `PaymentOutputToPaymentTxCondition` and `SpendingConditionRegistry`, implement checks for specific spending conditions directly in exit game controllers, and if the inferred relationship between `txType` and `PaymentExitGame` is correct, ensure that each `PaymentExitGame` router checks for its supported `txType`. Alternatively, the check could be made in `PaymentExitGame` itself.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13851",
      "title": "Merkle.checkMembership allows existence proofs for the same leaf in multiple locations in the tree ✓ Addressed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis was addressed in [omisego/plasma-contracts#533](https://github.com/omisego/plasma-contracts/pull/533) by including a check in `PosLib` that restricts transaction indices to between `0` and `2**16 - 1` inclusive. A subsequent change in [omisego/plasma-contracts#547](https://github.com/omisego/plasma-contracts/pull/547) ensured the passed-in index satisfied the recommended criterion.\n\n\n#### Description\n\n\n`checkMembership` is used by several contracts to prove that transactions exist in the child chain. The function uses a `leaf`, an `index`, and a `proof` to construct a hypothetical root hash. This constructed hash is compared to the passed in `rootHash` parameter. If the two are equivalent, the proof is considered valid.\n\n\nThe proof is performed iteratively, and uses a pseudo-index (`j`) to determine whether the next proof element represents a “left branch” or “right branch”:\n\n\n**code/plasma\\_framework/contracts/src/utils/Merkle.sol:L28-L41**\n\n\n\n```\nuint256 j = index;\n// Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\nfor (uint256 i = 32; i <= proof.length; i += 32) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        proofElement := mload(add(proof, i))\n    }\n    if (j % 2 == 0) {\n        computedHash = keccak256(abi.encodePacked(NODE\\_SALT, computedHash, proofElement));\n    } else {\n        computedHash = keccak256(abi.encodePacked(NODE\\_SALT, proofElement, computedHash));\n    }\n    j = j / 2;\n}\n\n```\nIf `j` is even, the computed hash is placed before the next proof element. If `j` is odd, the computed hash is placed after the next proof element. After each iteration, j is decremented by `j = j / 2`.\n\n\nBecause `checkMembership` makes no requirements on the height of the tree or the size of the proof relative to the provided `index`, it is possible to pass in invalid values for `index` that prove a leaf’s existence in multiple locations in the tree.\n\n\n#### Examples\n\n\nBy modifying existing tests, we showed that for a tree with 3 leaves, leaf 2 can be proven to exist at indices 2, 6, and 10 using the same proof each time. The modified test can be found here: <https://gist.github.com/wadeAlexC/01b60099282a026f8dc1ac85d83489fd#file-merkle-test-js-L40-L67>\n\n\n\n```\nit('should accidentally allow different indices to use the same proof', async () => {\r\n  const rootHash = this.merkleTree.root;\r\n  const proof = this.merkleTree.getInclusionProof(leaves[2]);\r\n\r\n  const result = await this.merkleContract.checkMembership(\r\n    leaves[2],\r\n    2,\r\n    rootHash,\r\n    proof,\r\n  );\r\n  expect(result).to.be.true;\r\n\r\n  const nextResult = await this.merkleContract.checkMembership(\r\n    leaves[2],\r\n    6,\r\n    rootHash,\r\n    proof,\r\n  );\r\n  expect(nextResult).to.be.true;\r\n\r\n  const nextNextResult = await this.merkleContract.checkMembership(\r\n    leaves[2],\r\n    10,\r\n    rootHash,\r\n    proof,\r\n  );\r\n  expect(nextNextResult).to.be.true;\r\n});\r\n\n```\n#### Conclusion\n\n\nExit processing is meant to bypass exits processed more than once. This is implemented using an “output id” system, where each exited output should correspond to a unique id that gets flagged in the `ExitGameController` contract as it’s exited. Before an exit is processed, its output id is calculated and checked against `ExitGameController`. If the output has already been exited, the exit being processed is deleted and skipped. Crucially, output id is calculated differently for standard transactions and deposit transactions: deposit output ids factor in the transaction index.\n\n\nBy using the behavior described in this issue in conjunction with methods discussed in [issue 5.8](#recommendation-add-a-tree-height-limit-check-to-merklesol) and <https://github.com/ConsenSys/omisego-morevp-audit-2019-10/issues/20,> we showed that deposit transactions can be exited twice using indices `0` and `2**16`. Because of the distinct output id calculation, these exits have different output ids and can be processed twice, allowing users to exit double their deposited amount.\n\n\nA modified `StandardExit.load.test.js` shows that exits are successfully enqueued with a transaction index of `65536`: <https://gist.github.com/wadeAlexC/4ad459b7510e512bc9556e7c919e0965#file-standardexit-load-test-js-L55>\n\n\n#### Recommendation\n\n\nUse the length of the proof to determine the maximum allowed index. The passed-in index should satisfy the following criterion: `index < 2**(proof.length/32)`. Additionally, ensure range checks on transaction position decoding are sufficiently restrictive (see <https://github.com/ConsenSys/omisego-morevp-audit-2019-10/issues/20)>.\n\n\nCorresponding issue in plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/546>",
      "summary": "\nA bug was discovered in the `checkMembership` function used by several contracts to prove that transactions exist in the child chain. This function uses a `leaf`, an `index`, and a `proof` to construct a hypothetical root hash which is then compared to the passed in `rootHash` parameter. The bug was that because the function makes no requirements on the height of the tree or the size of the proof relative to the provided `index`, it is possible to pass in invalid values for `index` that prove a leaf’s existence in multiple locations in the tree. \n\nThis was addressed in [omisego/plasma-contracts#533](https://github.com/omisego/plasma-contracts/pull/533) by including a check in `PosLib` that restricts transaction indices to between `0` and `2**16 - 1` inclusive. A subsequent change in [omisego/plasma-contracts#547](https://github.com/omisego/plasma-contracts/pull/547) ensured the passed-in index satisfied the recommended criterion.\n\nThe bug could be used to double exit deposit transactions, as the output id calculation is different for standard transactions and deposit transactions. By using the behavior described in this issue in conjunction with methods discussed in [issue 5.8](#recommendation-add-a-tree-height-limit-check-to-merklesol) and <https://github.com/ConsenSys/omisego-morevp-audit-2019-10/issues/20,> it was possible to exit deposit transactions twice using indices `0` and `2**16`.\n\nThe recommended solution was to use the length of the proof to determine the maximum allowed index, and ensure range checks on transaction position decoding are sufficiently restrictive. This bug was reported in the plasma-contracts repo: <https://github.com/omisego/plasma-contracts/issues/546>.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "OmiseGo MoreVP",
      "source_link": "https://consensys.net/diligence/audits/2020/01/omisego-morevp/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Daniel Luca",
        " Martin Ortner",
        "Alexander Wade"
      ]
    },
    {
      "id": "13850",
      "title": "ERC20Lockable - inconsistent locking status ✓ Fixed",
      "impact": "LOW",
      "content": "#### Resolution\n\n\n\nIssue was fixed by completely removing the unlock date mechanism.\n\n\n#### Description\n\n\n`Vega_Token.is_tradable()` will incorrectly return `false` if the token is never manually unlocked by the owner but `unlock_time` has passed, which will automatically unlock trading.\n\n\n#### Examples\n\n\n**code/ERC20Lockable.sol:L48-L67**\n\n\n\n```\n/\\*\\*\n \\* @dev locked status, only applicable before unlock\\_date\n \\*/\nbool public \\_is\\_locked = true;\n\n/\\*\\*\n \\* @dev Modifier that only allows function to run if either token is unlocked or time has expired.\n \\* Throws if called while token is locked.\n \\*/\nmodifier onlyUnlocked() {\n    require(!\\_is\\_locked || now > unlock\\_date);\n    \\_;\n}\n\n/\\*\\*\n \\* @dev Internal function that unlocks token. Can only be ran before expiration (give that it's irrelevant after)\n \\*/\nfunction \\_unlock() internal {\n    require(now <= unlock\\_date);\n    \\_is\\_locked = false;\n\n```\n#### Recommendation\n\n\n* declare `_is_locked` as `private` instead of `public`\n* create a getter method that correctly returns the locking status\n\n\n\n```\nfunction \\_isLocked() internal view {\n       return !\\_is\\_locked || now > unlock\\_date;\n}\n\n```\n* make `modifier onlyUnlocked()` use the newly created getter (`_isLocked()`)\n* make `Vega_Token.is_tradeable()` use the newly created getter (`_isLocked()`)\n* `_unlock()` should raise an errorcondition when called on an already unlocked contract\n\t+ it could make sense to emit a “contract hast been unlocked” event for auditing purposes",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Vega Vegatoken",
      "source_link": "https://consensys.net/diligence/audits/2020/01/vega-vegatoken/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Martin Ortner",
        "Gonçalo Sá"
      ]
    },
    {
      "id": "11909",
      "title": "Grammatical errors in code and comments",
      "impact": "LOW",
      "content": "Many comments are poorly written, with some containing grammatical or typing errors (e.g. [“*desgined*”](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L11), [“*transaction does not exists*”](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L63), [“*singatures*”](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L109)). This extends to the [“*transactionDoesNotExists*”](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L68) modifier name, which also has a grammatical error.\n\n\nConsider fixing these to improve code readability.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11908",
      "title": "Inconsistent coding style",
      "impact": "LOW",
      "content": "There is a significant coding style difference between code segments:\n\n\n* The wrapping of statement structures varies widely (as seen in events [`L29`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L29) and [`L35`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L35)).\n* [Indentation in](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) [`if`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) [`clauses`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) is inconsistent.\n* There is inconsistent spacing between typing, such as in lines: [`49–51`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L49), [`54`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L54) and [`59`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L59).\n* There is no ruling standard defining line wrapping (e.g. [line](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L241) [`241`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L241)). Recommended is 80 columns.\n* There is an inconsistent ordering of visibility and custom modifiers (e.g. `addTransaction` and `addFundsToTransaction`).\n\n\nConsider following best practices and applying the same style guidelines across the codebase (see [Solidity’s style guide](https://solidity.readthedocs.io/en/latest/style-guide.html) for reference).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11907",
      "title": "“Dispute” state is not among possible transaction states",
      "impact": "LOW",
      "content": "The [error message](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L75) in the [`inFundedState`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L73) [modifier](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L73) mentions “dispute” as a possible transaction state. [The](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L19) [`enum`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L19) in charge of defining transaction states, however, only lists “FUNDED” and “RELEASED” as possible states.\n\n\nConsider either including this third state in the `enum` — along with the necessary logic to support it — or suitably modifying the error message.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11906",
      "title": "Misleading comment in execute function",
      "impact": "LOW",
      "content": "The [docstrings for](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L315) [`execute`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L315) [function](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L315) hints at moderators being the ones responsible for executing transactions. Yet, the function does not validate who the calling account actually is, meaning that execute can be called by anyone — including actors not involved in the transaction.\n\n\nConsider clarifying this situation in the docstrings.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11905",
      "title": "Wrong error message on transaction verification failure",
      "impact": "LOW",
      "content": "The [`verifyTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L416) function implements several checks to verify the conditions under which transactions should be accepted or rejected. One complex validation is performed in [a single](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) [`if`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) [`clause`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441), which has an associated [error message](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L445) that does not cover all possible causes of failure.\n\n\nConsider refactoring the `if` clause in order to include specific error messages for each checked condition.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11904",
      "title": "Unnecessary field in Transaction struct",
      "impact": "LOW",
      "content": "The [`scriptHash`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L38) [field](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L38) is being unnecessarily stored within the `Transaction struct`. Considering that it is never used other than as an index to access `Transactions` in mappings, this field can safely be removed from the `struct` to avoid duplication.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11903",
      "title": "Lack of explicit return statements",
      "impact": "LOW",
      "content": "Several functions in the codebase have implicit return statements ([`checkBeneficiary`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L212), [`calculateRedeemScriptHash`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L369), [`transferFunds`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L453), [`verifySignatures`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L497) and [`isTimeLockExpired`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L552)).\n\n\nNot using explicit return statements on functions that are expected to return values can lead to problems in future changes to the codebase. Should a return parameter’s name be eventually removed (for instance if `returns (bool check)` is replaced with `returns (bool)`), no compilation-time warnings will be thrown by the Solidity compiler. In this scenario, the function’s return value will be always automatically set to the default value of the return type, in this case `false`, which could lead to unforeseen issues.\n\n\nConsider modifying the listed functions to include explicit return statements.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11902",
      "title": "Dead code in transferFunds function",
      "impact": "LOW",
      "content": "Inside the [`transferFunds`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L453) function, [a multiple conditional](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L463) is used to determine the transaction type (*i.e.* whether it is in Ether or in tokens). [A](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L489) [`else`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L489) [clause](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L489) is included as a fallback to revert the Ethereum transaction in case the received transaction type does not match a known value. However, given that transaction types can only be set by the smart contract (see [`L142`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L142) and [`L194`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L194)), this `else` clause will never be executed.\n\n\nTo improve readability and avoid confusion, consider removing all segments of code that are not to be executed under any circumstances.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11901",
      "title": "Convoluted transaction verification implementation",
      "impact": "MEDIUM",
      "content": "[`execute`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L324) is the function responsible for releasing funds to destination addresses, once all the necessary verification steps are taken. Currently, the entire process for verifying a transaction is divided and scattered throughout separate parts of the code, making it difficult for users to understand what requirements a transaction should meet in order for it to be approved, and rendering the code more error-prone and difficult to test.\n\n\nFrom `execute`, which has a first [`require`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L336) clause of its own, the [`verifyTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L416) function is called. This function in turn call [`verifySignatures`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L497), which has several require statements, and then [`isTimeLockExpired`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L552), to finally reach an [`if clause`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) that obscurely checks for further conditions using nested `and` and `or` operators and reverting when some of them are met. Back in `execute`, the [`transferFunds`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L453) function is called within a require statement, which performs [additional](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L466) [verifications](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L467) distributed in [several](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L481) [`require`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L482) clauses within loops.\n\n\nConsider decoupling the verification of transaction requirements from the business logic as much as possible, encapsulating validations in specific straightforward functions that can be easily reused and tested.",
      "summary": "\nThis bug report is about the `execute` function in the OpenBazaar smart contracts code. This function is responsible for releasing funds to destination addresses, once all the necessary verification steps are taken. Currently, the entire process for verifying a transaction is divided and scattered throughout separate parts of the code, making it difficult for users to understand what requirements a transaction should meet in order for it to be approved, and rendering the code more error-prone and difficult to test.\n\nThe bug report suggests that the verification of transaction requirements should be decoupled from the business logic as much as possible, encapsulating validations in specific straightforward functions that can be easily reused and tested. This would make it easier for users to understand what requirements a transaction should meet, and make the code less error-prone and easier to test.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11900",
      "title": "Signature ordering may prevent transaction verification",
      "impact": "MEDIUM",
      "content": "In the [`verifyTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L416) function, an [`if clause`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L441) defines the conditions under which transactions fail to be verified (and the associated Ethereum transaction reverts). One way to have transactions verified is to call the execute function with a number of signatures above the transaction threshold. Another, meant as a *failsafe*, consists of having the transaction executed with just the seller’s signature once the time lock is expired.\n\n\nThe implementation of the *failsafe* case requires the `execute` function to be called with the seller’s signature as the last one in the signature component arrays for the transaction to be validated. This mismatch between specification and implementation entails cases where according to the specification the funds should be released, but they will not according to the implementation. One such case occurs when three signatures are required, the time lock is already expired, and `execute` is called with the `seller` and the `moderator` signatures, appearing in that order in the arrays. This function call will not release the funds, contrary to the specification. Furthermore, the error message provided will be “*sigV.length is under the threshold.*”, which is not diagnostic of the actual failure (see **Wrong error messages on transaction verification failure** below).\n\n\nConsider an implementation that is agnostic to signature ordering in order to fully match the specification.",
      "summary": "\nThis bug report concerns the `verifyTransaction` function of the OpenBazaar smart contracts. This function defines the conditions under which transactions fail to be verified, and the associated Ethereum transaction reverts. One way to have transactions verified is to call the `execute` function with a number of signatures above the transaction threshold. Additionally, a failsafe exists where the transaction can be executed with just the seller’s signature once the time lock is expired. \n\nHowever, the current implementation requires the `execute` function to be called with the seller’s signature as the last one in the signature component arrays for the transaction to be validated. This means that in cases where the specification states the funds should be released, they will not be released according to the implementation. An example of this is when three signatures are required, the time lock is expired, and `execute` is called with the `seller` and the `moderator` signatures, appearing in that order in the arrays. \n\nFurthermore, the error message provided in this case will be “*sigV.length is under the threshold.*”, which is not diagnostic of the actual failure. To fix this bug, the implementation should be agnostic to signature ordering in order to fully match the specification.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11899",
      "title": "Buyers can lock funds indefinitely",
      "impact": "HIGH",
      "content": "Transactions in the [`Escrow_v1_0`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol) contract are described by the [`Transaction struct`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L37). Among its fields, [`timeoutHours`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L44) is used to set a timeout after which a seller can execute the transaction without the need for the buyer’s or the moderator’s signatures. In order to do this, the seller calls the [`execute`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L324) function, which itself calls [`verifyTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L416), which finally calls [`isTimeLockExpired`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L552). This last function verifies that the time elapsed since the last modification of the transaction, tracked by the [`lastModified`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L40) field in the `Transaction struct`, is greater than the transaction’s time lock.\n\n\nA malicious buyer trying to prevent a transaction from being executed can periodically update it by adding tiny amounts of Ether or tokens to its value through the [`addFundsToTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L261) or [`addTokensToTransaction`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L295) functions respectively. These calls will [reset the](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L261) [`lastModified`](https://github.com/OpenBazaar/smart-contracts/blob/c4f02cdd41cb85d28bba637a01f20a8ee8bb04bd/contracts/escrow/Escrow_v1_0.sol#L261) field of the transaction, thus preventing it from ever reaching the time lock. If the transaction requires only two signatures, a seller can appeal to the moderator to execute it. If the transaction requires three signatures, however, the funds will be effectively locked until the buyer ceases to update it.\n\n\nConsider keeping track of, and limiting, the number of times a transaction can be modified in order to prevent the indefinite locking of funds by buyers.",
      "summary": "\nThis bug report is about the OpenBazaar smart contracts, specifically the Escrow_v1_0 contract. This contract is used for transactions between buyers and sellers. One of the fields of the Transaction struct is the timeoutHours, which is used to set a timeout after which a seller can execute the transaction without the need for the buyer’s or the moderator’s signatures. The seller does this by calling the execute function, which calls the verifyTransaction function, which finally calls the isTimeLockExpired function. This last function verifies that the time elapsed since the last modification of the transaction is greater than the transaction’s time lock. \n\nHowever, a malicious buyer can prevent a transaction from being executed by periodically updating it by adding tiny amounts of Ether or tokens to its value. This will reset the lastModified field of the transaction, thus preventing it from ever reaching the time lock. If the transaction requires only two signatures, a seller can appeal to the moderator to execute it. If the transaction requires three signatures, however, the funds will be effectively locked until the buyer ceases to update it.\n\nThe bug report suggests keeping track of and limiting the number of times a transaction can be modified in order to prevent the indefinite locking of funds by buyers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "OpenBazaar’s Escrow Audit",
      "source_link": "https://blog.openzeppelin.com/openbazaars-escrow-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12007",
      "title": "ERC20 compliance",
      "impact": "LOW",
      "content": "Although a minor problem, the `decimals` state variable should be defined with type `uint8` to be [compliant with ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals).\n\n\nAdditionally, the version of OpenZeppelin used for Enigma (1.2.0) included [a restriction](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.2.0/contracts/token/StandardToken.sol#L46-L50) to the usage of `approve` that has been deemed non-compliant and was [removed](https://github.com/OpenZeppelin/zeppelin-solidity/pull/446) in the next version. Consider upgrading to OpenZeppelin 1.3.0.\n\n\n***Update:** Fixed in [`a09d58c`](https://github.com/element-group/enigma-erc20-smart-contract/commit/a09d58c412300f8d1460da6cf45143d24b3843e2).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Enigma Token Audit",
      "source_link": "https://blog.openzeppelin.com/enigma-token-audit-91111e0b7f8a/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "12006",
      "title": "No Transfer for initial supply creation",
      "impact": "LOW",
      "content": "Consider emitting an event `Transfer(0x0, msg.sender, INITIAL_SUPPLY)` in the [constructor](https://github.com/element-group/enigma-erc20-smart-contract/blob/9b6a6edab5eaf79242cc59d705f8b315657f87b7/contracts/EnigmaToken.sol#L38). This is consistent with the [recommended behavior](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer) for token creation, and will improve the user experience. For example, the created token amount will be immediately displayed in the Etherscan token interface.\n\n\n***Update:** Event added in [`84412e9`](https://github.com/element-group/enigma-erc20-smart-contract/commit/84412e9a899734f6845ed645837f370c702b5a82).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Enigma Token Audit",
      "source_link": "https://blog.openzeppelin.com/enigma-token-audit-91111e0b7f8a/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}